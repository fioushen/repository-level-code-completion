{"filename": "test/submod/src/main/java/shcm/test/fabric/testmod/ExampleMod.java", "chunked_list": ["package shcm.test.fabric.testmod;\n\nimport net.fabricmc.api.ModInitializer;\n\nimport net.minecraft.item.Item;\nimport net.minecraft.util.Identifier;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/*? >=1.19.4 {?*/", "\n/*? >=1.19.4 {?*/\nimport net.minecraft.registry.Registries;\n/*?} else {?*//*\nimport net.minecraft.util.registry.Registry;\n/*?}?*/\n\npublic class ExampleMod implements ModInitializer {\n    public static final Logger LOGGER = LoggerFactory.getLogger(\"testmod\");\n\n\t@Override", "    public static final Logger LOGGER = LoggerFactory.getLogger(\"testmod\");\n\n\t@Override\n\tpublic void onInitialize() {\n\n\t\tLOGGER.info(\"Example of inline versioned value getter\");\n\t\tItem item = /*? >=1.19.4 {?*/ Registries.ITEM.get(new Identifier(\"minecraft:flint\")) /*?} else {?*//* Registry.ITEM.get(new Identifier(\"minecraft:flint\")) /*?}?*/;\n\n\t\tLOGGER.info(\"Example of 'only run in this version constraint' syntax\");\n\t\t/*? ~1.20 {?*/\n\t\titem = Registries.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?}?*/\n\n\t\tLOGGER.info(\"Example of 'if else' syntax\");\n\t\t/*? >=1.19.4 {?*/\n\t\titem = Registries.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?} else {?*//*\n\t\titem = Registry.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?}?*/\n\n\t\tLOGGER.info(\"Example of 'if elseif else' syntax and how to avoid versioned imports\");\n\t\t/*? >=1.19.4 {?*/\n\t\titem = net.minecraft.registry.Registries.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?} else ~1.19.3 {?*//*\n\t\titem = net.minecraft.registry.Registries.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?} else {?*//*\n\t\titem = net.minecraft.util.registry.Registry.ITEM.get(new Identifier(\"minecraft:flint\"));\n\t\t/*?}?*/\n\t}\n\n\n\t{\n\t\t/*?$token disable test_token?*/\n\t\tSystem.out.println(\"the test was for 1.19.2\");\n\t\tSystem.out.println(\"the test was for 1.19.2\"); // this was the 1.19.2 thing?\n\t\t/*?$token enable test_token?*/\n\t\tSystem.out.println(\"the test is the 1.20.1\");\n\t\tSystem.out.println(\"the test is for 1.20.1\");\n\t\tSystem.out.println(\"This is for 1.20.1\");\n\t\tSystem.out.println(\"the test is for 1.20.1\");\n\t\tSystem.out.println(\"the test was lmaoXDKEKW  1.19.2\");\n\t\t/*?$token disable test_token?*/\n\t\tSystem.out.println(\"the test was for 1.19.2\");\n\n\t\t/*\n\t\tThis was for 1.19.2\n\t\t */\n\t}\n}"]}
{"filename": "test/submod/src/main/java/shcm/test/fabric/testmod/mixin/ExampleMixin.java", "chunked_list": ["package shcm.test.fabric.testmod.mixin;\n\nimport net.minecraft.server.MinecraftServer;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(MinecraftServer.class)\npublic class ExampleMixin {\n\t@Inject(at = @At(\"HEAD\"), method = \"loadWorld\")\n\tprivate void init(CallbackInfo info) {\n\t\t// This code is injected into the start of MinecraftServer.loadWorld()V\n\t}\n}", "@Mixin(MinecraftServer.class)\npublic class ExampleMixin {\n\t@Inject(at = @At(\"HEAD\"), method = \"loadWorld\")\n\tprivate void init(CallbackInfo info) {\n\t\t// This code is injected into the start of MinecraftServer.loadWorld()V\n\t}\n}"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/StonecutterSettingsGradle.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter;\n\nimport org.gradle.api.Action;\nimport org.gradle.api.GradleException;\nimport org.gradle.api.initialization.ProjectDescriptor;\nimport org.gradle.api.initialization.Settings;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Set;\n\npublic class StonecutterSettingsGradle {\n    private final Settings settings;\n    private final StonecutterProjectSetups stonecutterProjects;\n\n    private StonecutterProjectBuilder shared = StonecutterProjectBuilder.DEFAULT;\n\n    public StonecutterSettingsGradle(Settings settings) {\n        this.settings = settings;\n        this.stonecutterProjects = settings.getGradle().getExtensions().create(\"stonecutterProjects\", StonecutterProjectSetups.class);\n", "        try {\n            File stonecutter = new File(this.settings.getRootDir(), \".gradle/stonecutter\");\n            stonecutter.mkdirs();\n            File thisJar = new File(getClass().getProtectionDomain().getCodeSource().getLocation().toURI());\n            stonecutter = new File(stonecutter, thisJar.getName());\n            if (!stonecutter.exists())\n                Files.copy(thisJar.toPath(), stonecutter.toPath());\n        } catch (Exception ignored) { }\n    }\n\n    public void shared(Action<StonecutterProjectBuilder> stonecutterProjectBuilder) {\n        this.shared = new StonecutterProjectBuilder(shared, stonecutterProjectBuilder);\n    }\n", "    public void shared(Action<StonecutterProjectBuilder> stonecutterProjectBuilder) {\n        this.shared = new StonecutterProjectBuilder(shared, stonecutterProjectBuilder);\n    }\n\n    public void create(ProjectDescriptor... projects) {\n        for (ProjectDescriptor project : projects)\n            create(project, builder -> {\n                if (builder.versions.length == 0)\n                    throw new GradleException(\"[Stonecutter] To create a stonecutter project without a configuration element, make use of shared default values.\");\n            });\n    }\n", "    public void create(ProjectDescriptor project, Action<StonecutterProjectBuilder> stonecutterProjectBuilder) {\n        StonecutterProjectBuilder builder = new StonecutterProjectBuilder(shared, stonecutterProjectBuilder);\n\n        if (builder.versions.length == 0)\n            throw new GradleException(\"[Stonecutter] Stonecutter projects must have at the very least one version specified.\");\n\n        if (builder.vcsVersion == null)\n            builder.vcsVersion = builder.versions[0];\n\n        if (!stonecutterProjects.registerVersioned(project.getPath(), builder))\n            throw new IllegalArgumentException(\"Project already registered as a stonecutter project\");\n", "        if (!stonecutterProjects.registerVersioned(project.getPath(), builder))\n            throw new IllegalArgumentException(\"Project already registered as a stonecutter project\");\n\n        try {\n            project.setBuildFileName(\"stonecutter.gradle\");\n            File stonecutterGradle = new File(project.getProjectDir(), \"stonecutter.gradle\");\n            if (!stonecutterGradle.exists())\n                Files.write(stonecutterGradle.toPath(),\n                        \"\"\"\n                        plugins.apply 'io.shcm.shsupercm.fabric.stonecutter'\n                        stonecutter.active '%s'\n                        //-------- !DO NOT EDIT ABOVE THIS LINE! --------\\\\\\\\\n                        \"\"\".formatted(builder.vcsVersion).getBytes(), StandardOpenOption.CREATE);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n", "        for (String version : builder.versions) {\n            String path = project.getPath();\n            if (!path.endsWith(\":\"))\n                path = path + \":\";\n            path = path + version;\n\n            settings.include(path);\n            ProjectDescriptor versionedProject = settings.project(path);\n\n            File versionDir = new File(project.getProjectDir(), \"/versions/\" + version);\n            versionDir.mkdirs();", "            try { new File(versionDir, \"tokens.gradle\").createNewFile(); } catch (IOException ignored) { }\n\n            versionedProject.setProjectDir(versionDir);\n            versionedProject.setName(version);\n            if (!Boolean.getBoolean(\"stonecutter.disableCentralBuildScript\"))\n                versionedProject.setBuildFileName(\"../../build.gradle\");\n        }\n    }\n\n    public static class StonecutterProjectBuilder {\n        public static final StonecutterProjectBuilder DEFAULT = new StonecutterProjectBuilder(); StonecutterProjectBuilder() { }\n\n        protected String[] versions = new String[0];\n        protected String vcsVersion = null;\n\n        protected StonecutterProjectBuilder(StonecutterProjectBuilder defaultValues, Action<StonecutterProjectBuilder> builder) {\n            this.versions = defaultValues.versions;\n            this.vcsVersion = defaultValues.vcsVersion;\n\n            builder.execute(this);\n        }\n", "    public static class StonecutterProjectBuilder {\n        public static final StonecutterProjectBuilder DEFAULT = new StonecutterProjectBuilder(); StonecutterProjectBuilder() { }\n\n        protected String[] versions = new String[0];\n        protected String vcsVersion = null;\n\n        protected StonecutterProjectBuilder(StonecutterProjectBuilder defaultValues, Action<StonecutterProjectBuilder> builder) {\n            this.versions = defaultValues.versions;\n            this.vcsVersion = defaultValues.vcsVersion;\n\n            builder.execute(this);\n        }\n", "        public void versions(String... versions) {\n            if (versions.length == 0 || versions.length != Set.of(versions).size())\n                throw new IllegalArgumentException(\"Invalid list of versions\");\n\n            this.versions = versions;\n        }\n\n        public void vcsVersion(String version) {\n            this.vcsVersion = version;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/ChiseledTask.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter;\n\nimport org.gradle.api.DefaultTask;\nimport org.gradle.api.Task;\nimport org.gradle.api.provider.ListProperty;\nimport org.gradle.api.tasks.Input;\n\npublic abstract class ChiseledTask extends DefaultTask {\n    public final StonecutterProjectSetups.Setup setup = getProject().getGradle().getExtensions().getByType(StonecutterProjectSetups.class).get(getProject());\n    \n    @Input public abstract ListProperty<String> getVersions(); { getVersions().convention(() -> setup.versions().iterator()); }\n\n    private final Task setupChiselTask;\n\n    public ChiseledTask() {\n        this.setupChiselTask = getProject().getTasks().getByName(\"chiseledStonecutter\");\n        this.dependsOn(setupChiselTask);\n    }\n", "    public final StonecutterProjectSetups.Setup setup = getProject().getGradle().getExtensions().getByType(StonecutterProjectSetups.class).get(getProject());\n    \n    @Input public abstract ListProperty<String> getVersions(); { getVersions().convention(() -> setup.versions().iterator()); }\n\n    private final Task setupChiselTask;\n\n    public ChiseledTask() {\n        this.setupChiselTask = getProject().getTasks().getByName(\"chiseledStonecutter\");\n        this.dependsOn(setupChiselTask);\n    }\n", "    public void ofTask(String taskName) {\n        for (String version : getVersions().get()) {\n            Task task = getProject().project(version).getTasks().getByName(taskName);\n            this.finalizedBy(task);\n            task.mustRunAfter(setupChiselTask);\n        }\n    }\n}"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/StonecutterPlugin.java", "chunked_list": ["/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage io.shcm.shsupercm.fabric.stonecutter;\n\nimport org.gradle.api.Plugin;\nimport org.gradle.api.Project;\nimport org.gradle.api.initialization.Settings;\nimport org.gradle.api.plugins.ExtensionAware;\nimport org.jetbrains.annotations.NotNull;", "import org.gradle.api.plugins.ExtensionAware;\nimport org.jetbrains.annotations.NotNull;\n\npublic class StonecutterPlugin implements Plugin<ExtensionAware> {\n    @Override\n    public void apply(@NotNull ExtensionAware dest) {\n        Class<?> type;\n        if (dest instanceof Settings settings)\n            type = StonecutterSettingsGradle.class;\n        else if (dest instanceof Project project)\n            type = project.getBuildFile().getName().equals(\"stonecutter.gradle\") ?\n                    StonecutterControllerGradle.class :\n                    StonecutterBuildGradle.class;\n        else\n            throw new IllegalArgumentException(\"The Stonecutter plugin may only be applied to Settings and Projects\");\n\n        dest.getExtensions().create(\"stonecutter\", type, dest);\n    }\n}\n", "        else if (dest instanceof Project project)\n            type = project.getBuildFile().getName().equals(\"stonecutter.gradle\") ?\n                    StonecutterControllerGradle.class :\n                    StonecutterBuildGradle.class;\n        else\n            throw new IllegalArgumentException(\"The Stonecutter plugin may only be applied to Settings and Projects\");\n\n        dest.getExtensions().create(\"stonecutter\", type, dest);\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/StonecutterBuildGradle.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter;\n\nimport groovy.lang.MissingPropertyException;\nimport io.shcm.shsupercm.fabric.stonecutter.cutter.StoneRegexTokenizer;\nimport io.shcm.shsupercm.fabric.stonecutter.cutter.StonecutterTask;\nimport org.gradle.api.Project;\nimport org.gradle.api.artifacts.Configuration;\nimport org.gradle.api.artifacts.Dependency;\nimport org.gradle.api.tasks.SourceSet;\nimport org.gradle.api.tasks.SourceSetContainer;", "import org.gradle.api.tasks.SourceSet;\nimport org.gradle.api.tasks.SourceSetContainer;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.util.Objects;\n\npublic class StonecutterBuildGradle {\n    private final Project project;\n    private final StonecutterProjectSetups.Setup setup;\n    private final Version version;\n\n    public StonecutterBuildGradle(Project project) {\n        this.project = project;\n        this.setup = project.getGradle().getExtensions().getByType(StonecutterProjectSetups.class).get(Objects.requireNonNull(project.getParent()));\n        this.version = new Version(this, project.getName());\n\n        project.getTasks().register(\"setupChiseledStonecutterBuild\", StonecutterTask.class, task -> {\n            task.getFromVersion().set(project.getParent().project(setup.current()).getExtensions().getByType(StonecutterBuildGradle.class).current());\n            task.getToVersion().set(version);\n            task.getInputDir().set(project.getParent().file(\"./src\"));\n            task.getOutputDir().set(new File(project.getBuildDir(), \"chiseledSrc\"));\n        });\n\n        project.afterEvaluate(this::afterEvaluate);\n    }\n\n    private void afterEvaluate(Project project) {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n        loaderCopy.mkdirs();\n        loaderCopy = new File(loaderCopy, \"fabric-loader.jar\");", "        if (!loaderCopy.exists())\n            loaderSearch: for (Configuration configuration : project.getConfigurations())\n                for (Dependency dependency : configuration.getDependencies())\n                    if (\"net.fabricmc\".equals(dependency.getGroup()) && \"fabric-loader\".equals(dependency.getName()))\n                        for (File file : configuration.getFiles())\n                            if (file.getName().startsWith(\"fabric-loader\")) {\n                                try {\n                                    Files.copy(file.toPath(), loaderCopy.toPath());\n                                    break loaderSearch;\n                                } catch (Exception ignored) { }\n                            }\n\n", "        try {\n            if (setup.anyChiseled(project.getGradle().getStartParameter().getTaskNames())) {\n                for (SourceSet sourceSet : (SourceSetContainer) Objects.requireNonNull(project.property(\"sourceSets\"))) {\n                    sourceSet.getJava().srcDir(new File(project.getBuildDir(), \"chiseledSrc/\" + sourceSet.getName() + \"/java\"));\n                    sourceSet.getResources().srcDir(new File(project.getBuildDir(), \"chiseledSrc/\" + sourceSet.getName() + \"/resources\"));\n                }\n                return;\n            }\n\n            if (this.version.isActiveVersion()) {\n                for (SourceSet sourceSet : (SourceSetContainer) Objects.requireNonNull(project.property(\"sourceSets\"))) {\n                    sourceSet.getJava().srcDir(\"../../src/\" + sourceSet.getName() + \"/java\");\n                    sourceSet.getResources().srcDir(\"../../src/\" + sourceSet.getName() + \"/resources\");\n                }\n            }\n        } catch (MissingPropertyException ignored) { }\n    }\n", "            if (this.version.isActiveVersion()) {\n                for (SourceSet sourceSet : (SourceSetContainer) Objects.requireNonNull(project.property(\"sourceSets\"))) {\n                    sourceSet.getJava().srcDir(\"../../src/\" + sourceSet.getName() + \"/java\");\n                    sourceSet.getResources().srcDir(\"../../src/\" + sourceSet.getName() + \"/resources\");\n                }\n            }\n        } catch (MissingPropertyException ignored) { }\n    }\n\n    public Version current() {\n        return this.version;\n    }\n\n    public Iterable<String> versions() {\n        return setup.versions();\n    }\n", "    public Version current() {\n        return this.version;\n    }\n\n    public Iterable<String> versions() {\n        return setup.versions();\n    }\n\n    public static class Version {\n        private final StonecutterBuildGradle plugin;\n        private final String version;\n        private StoneRegexTokenizer tokenizer = null;\n\n        public Version(StonecutterBuildGradle plugin, String version) {\n            this.plugin = plugin;\n            this.version = version;\n        }\n", "    public static class Version {\n        private final StonecutterBuildGradle plugin;\n        private final String version;\n        private StoneRegexTokenizer tokenizer = null;\n\n        public Version(StonecutterBuildGradle plugin, String version) {\n            this.plugin = plugin;\n            this.version = version;\n        }\n\n        public String version() {\n            return this.version;\n        }\n", "        public String version() {\n            return this.version;\n        }\n\n        public boolean isActiveVersion() {\n            return this.version.equals(plugin.setup.current());\n        }\n\n        public Project project() {\n            return this.plugin.project;\n        }\n", "        public Project project() {\n            return this.plugin.project;\n        }\n\n        public StoneRegexTokenizer tokenizer() {\n            if (this.tokenizer == null) {\n                this.tokenizer = new StoneRegexTokenizer();\n                final File tokensFile = project().file(\"tokens.gradle\");\n                if (tokensFile.exists())\n                    project().apply(it -> {\n                        it.from(tokensFile);\n                        it.to(this.tokenizer);\n                    });\n            }\n\n            return this.tokenizer;\n        }\n    }\n}\n", "                if (tokensFile.exists())\n                    project().apply(it -> {\n                        it.from(tokensFile);\n                        it.to(this.tokenizer);\n                    });\n            }\n\n            return this.tokenizer;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/StonecutterProjectSetups.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter;\n\nimport org.gradle.api.Project;\n\nimport java.util.*;\n\npublic class StonecutterProjectSetups {\n    private final Map<String, Setup> controllerSetups = new HashMap<>();\n\n    protected boolean registerVersioned(String project, StonecutterSettingsGradle.StonecutterProjectBuilder setupBuilder) {\n        return this.controllerSetups.putIfAbsent(project, new Setup(setupBuilder)) == null;\n    }\n", "    public Setup get(Project project) {\n        return this.controllerSetups.get(project.getPath());\n    }\n\n    public static class Setup {\n        private final String[] versions;\n        private final String vcsVersion;\n        private String current;\n        private final Set<String> chiseledTasks = new HashSet<>();\n\n        private Setup(StonecutterSettingsGradle.StonecutterProjectBuilder setupBuilder) {\n            this.versions = setupBuilder.versions;\n            this.vcsVersion = setupBuilder.vcsVersion;\n\n            this.current = vcsVersion;\n        }\n\n        public List<String> versions() {\n            return List.of(this.versions);\n        }\n", "        public String current() {\n            return this.current;\n        }\n\n        public void setCurrent(String version) {\n            if (!versions().contains(version))\n                throw new IllegalArgumentException(\"Version not registered for project\");\n            this.current = version;\n        }\n\n        public void registerChiseled(String taskName) {\n            this.chiseledTasks.add(taskName);\n        }\n", "        public void registerChiseled(String taskName) {\n            this.chiseledTasks.add(taskName);\n        }\n\n        public boolean anyChiseled(Iterable<String> taskNames) {\n            for (String taskName : taskNames)\n                if (chiseledTasks.contains(taskName))\n                    return true;\n\n            return false;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/StonecutterControllerGradle.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter;\n\nimport io.shcm.shsupercm.fabric.stonecutter.cutter.StonecutterTask;\nimport org.gradle.api.Project;\nimport org.gradle.api.tasks.TaskProvider;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;", "import java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StonecutterControllerGradle {\n    public final Class<ChiseledTask> chiseled = ChiseledTask.class;\n    private final StonecutterProjectSetups.Setup setup;\n\n    public StonecutterControllerGradle(Project project) {\n        setup = project.getGradle().getExtensions().getByType(StonecutterProjectSetups.class).get(project);\n", "        for (String version : setup.versions())\n            project.project(version).getPluginManager().apply(StonecutterPlugin.class);\n\n        project.getTasks().create(\"chiseledStonecutter\", task -> {\n            for (String version : setup.versions())\n                task.dependsOn(version + \":setupChiseledStonecutterBuild\");\n        });\n\n        project.afterEvaluate(afterEvaluate -> {\n            StonecutterBuildGradle.Version currentVersionData = afterEvaluate.project(setup.current()).getExtensions().getByType(StonecutterBuildGradle.class).current();\n            for (String version : setup.versions()) {\n                Project versionProject = afterEvaluate.project(version);\n                StonecutterBuildGradle.Version versionData = versionProject.getExtensions().getByType(StonecutterBuildGradle.class).current();\n                StonecutterTask task = afterEvaluate.getTasks().create(\"Set active version to \" + versionData.version(), StonecutterTask.class);\n                task.setGroup(\"stonecutter\");\n\n                task.getFromVersion().set(currentVersionData);\n                task.getToVersion().set(versionData);\n                task.getInputDir().set(afterEvaluate.file(\"./src\"));\n                task.getOutputDir().set(task.getInputDir().get());\n\n                task.doLast(taskRun -> {", "            for (String version : setup.versions()) {\n                Project versionProject = afterEvaluate.project(version);\n                StonecutterBuildGradle.Version versionData = versionProject.getExtensions().getByType(StonecutterBuildGradle.class).current();\n                StonecutterTask task = afterEvaluate.getTasks().create(\"Set active version to \" + versionData.version(), StonecutterTask.class);\n                task.setGroup(\"stonecutter\");\n\n                task.getFromVersion().set(currentVersionData);\n                task.getToVersion().set(versionData);\n                task.getInputDir().set(afterEvaluate.file(\"./src\"));\n                task.getOutputDir().set(task.getInputDir().get());\n\n                task.doLast(taskRun -> {", "                    try {\n                        File stonecutterGradle = taskRun.getProject().getBuildFile();\n                        List<String> stonecutterGradleLines = new ArrayList<>(Files.readAllLines(stonecutterGradle.toPath(), StandardCharsets.ISO_8859_1));\n\n                        stonecutterGradleLines.set(1, \"stonecutter.active '\" + versionData.version() + \"'\");\n\n                        stonecutterGradle.delete();\n                        Files.write(stonecutterGradle.toPath(), stonecutterGradleLines, StandardCharsets.ISO_8859_1, StandardOpenOption.CREATE);\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n            }\n        });\n    }\n", "    public void active(String current) {\n        setup.setCurrent(current);\n    }\n\n    public Iterable<String> versions() {\n        return setup.versions();\n    }\n\n    public void registerChiseled(TaskProvider<?> registeredTask) {\n        setup.registerChiseled(registeredTask.getName());\n    }\n}\n", "    public void registerChiseled(TaskProvider<?> registeredTask) {\n        setup.registerChiseled(registeredTask.getName());\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/cutter/FabricLoaderAPI.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.cutter;\n\nimport org.gradle.api.Project;\nimport org.gradle.api.artifacts.Configuration;\nimport org.gradle.api.artifacts.Dependency;\n\nimport java.io.File;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.net.URL;", "import java.lang.reflect.Method;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class FabricLoaderAPI {\n    private final ClassLoader classLoader;\n    private final Class<?> classSemanticVersion;\n    private final Method methodSemanticVersionParse, methodVersionPredicateParse;\n\n    public FabricLoaderAPI(URL... jar) throws Exception {\n        this.classLoader = new URLClassLoader(jar, getClass().getClassLoader());\n\n        this.classSemanticVersion = classLoader.loadClass(\"net.fabricmc.loader.api.SemanticVersion\");\n        this.methodSemanticVersionParse = classSemanticVersion.getDeclaredMethod(\"parse\", String.class);\n        this.methodVersionPredicateParse = classLoader.loadClass(\"net.fabricmc.loader.api.metadata.version.VersionPredicate\").getDeclaredMethod(\"parse\", String.class);\n    }\n", "    public Object parseVersion(String version) throws InvocationTargetException, IllegalAccessException {\n        return this.methodSemanticVersionParse.invoke(null, version);\n    }\n\n    public Predicate<Object> parseVersionPredicate(String predicate) throws InvocationTargetException, IllegalAccessException {\n        //noinspection unchecked\n        return (Predicate<Object>) this.methodVersionPredicateParse.invoke(null, predicate);\n    }\n\n    public static FabricLoaderAPI fromDependencies(Project project) throws Exception {\n        File fabricLoaderFile = null;", "    public static FabricLoaderAPI fromDependencies(Project project) throws Exception {\n        File fabricLoaderFile = null;\n        loaderSearch: for (Configuration configuration : project.getConfigurations())\n            for (Dependency dependency : configuration.getDependencies())\n                if (\"net.fabricmc\".equals(dependency.getGroup()) && \"fabric-loader\".equals(dependency.getName()))\n                    for (File file : configuration.getFiles())\n                        if (file.getName().startsWith(\"fabric-loader\")) {\n                            fabricLoaderFile = file;\n                            break loaderSearch;\n                        }\n\n        return new FabricLoaderAPI(Objects.requireNonNull(fabricLoaderFile).toURI().toURL());\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/cutter/StoneRegexTokenizer.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.cutter;\n\nimport groovy.lang.Closure;\n\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.regex.Matcher;", "import java.util.function.Predicate;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class StoneRegexTokenizer {\n    private final Map<String, Token> tokens = new HashMap<>();\n\n    public void token(String id, Closure<Token.Builder> builder) {\n        if (id.chars().anyMatch(Character::isWhitespace))\n            throw new IllegalArgumentException(\"Token identifier must not contain spaces\");\n\n        Token.Builder tokenBuilder = new Token.Builder(builder);", "        if (id.chars().anyMatch(Character::isWhitespace))\n            throw new IllegalArgumentException(\"Token identifier must not contain spaces\");\n\n        Token.Builder tokenBuilder = new Token.Builder(builder);\n        if (tokenBuilder.read == null || tokenBuilder.write == null)\n            throw new IllegalArgumentException(\"Token builder missing read/write values\");\n\n        tokens.put(id, new Token(id, tokenBuilder.read, tokenBuilder.write, tokenBuilder.defaultEnabled, tokenBuilder.fileFilter == null ? file -> true : tokenBuilder.fileFilter));\n    }\n\n    public Set<String> tokens() {\n        return this.tokens.keySet();\n    }\n", "    public static StoneRegexTokenizer remap(StoneRegexTokenizer source, StoneRegexTokenizer target) {\n        if (source == target)\n            return source;\n\n        StoneRegexTokenizer remapper = new StoneRegexTokenizer();\n\n        for (Token sourceToken : source.tokens.values()) {\n            Token targetToken = target.tokens.get(sourceToken.id);\n            if (targetToken == null)\n                continue;\n\n            remapper.tokens.put(sourceToken.id, Token.remap(sourceToken, targetToken));\n        }\n\n        return remapper;\n    }\n", "            if (targetToken == null)\n                continue;\n\n            remapper.tokens.put(sourceToken.id, Token.remap(sourceToken, targetToken));\n        }\n\n        return remapper;\n    }\n\n    public void apply(File file, StringBuilder value) {\n        if (tokens.isEmpty())\n            return;\n        CharSequence applied = value;", "    public void apply(File file, StringBuilder value) {\n        if (tokens.isEmpty())\n            return;\n        CharSequence applied = value;\n        for (Token token : tokens.values())\n            if (token.fileFilter().test(file))\n                applied = token.apply(applied);\n        value.setLength(0);\n        value.append(applied);\n    }\n", "    public record Token(String id, Pattern read, String write, boolean defaultEnabled, Predicate<File> fileFilter) {\n        public CharSequence apply(CharSequence value) {\n            class Static {\n                static final Pattern PATTERN_TOKEN_SET_STATE = Pattern.compile(\"/\\\\*\\\\?\\\\$token (?<state>enable|disable) (?<id>.+)\\\\?\\\\*/\");\n            }\n\n            StringBuilder output = new StringBuilder(), buffer = new StringBuilder();\n            boolean enabled = defaultEnabled;\n\n            Matcher flagsMatcher = Static.PATTERN_TOKEN_SET_STATE.matcher(value);\n            while (flagsMatcher.find()) {\n                flagsMatcher.appendReplacement(buffer, \"\");\n                output.append(enabled ? read.matcher(buffer).replaceAll(write) : buffer)\n                      .append(flagsMatcher.group());\n                buffer.setLength(0);\n", "            while (flagsMatcher.find()) {\n                flagsMatcher.appendReplacement(buffer, \"\");\n                output.append(enabled ? read.matcher(buffer).replaceAll(write) : buffer)\n                      .append(flagsMatcher.group());\n                buffer.setLength(0);\n\n                if (this.id.equals(flagsMatcher.group(\"id\")))\n                    enabled = \"enable\".equals(flagsMatcher.group(\"state\"));\n            }\n\n            flagsMatcher.appendTail(buffer);\n            output.append(enabled ? read.matcher(buffer).replaceAll(write) : buffer);\n\n            return output;\n        }\n", "        public static Token remap(Token source, Token target) {\n            return new Token(source.id, source.read, target.write, source.defaultEnabled, source.fileFilter);\n        }\n\n        public static class Builder {\n            public Pattern read = null;\n            public String write = null;\n            public boolean defaultEnabled = false;\n            public Predicate<File> fileFilter = null;\n\n            public Builder(Closure<Builder> builder) {\n                builder.setDelegate(this);\n                builder.call();\n            }\n", "            public void read(Pattern read) {\n                this.read = read;\n            }\n\n            public void write(String write) {\n                this.write = write;\n            }\n\n            public void defaultEnabled(boolean defaultEnabled) {\n                this.defaultEnabled = defaultEnabled;\n            }\n", "            public void defaultEnabled(boolean defaultEnabled) {\n                this.defaultEnabled = defaultEnabled;\n            }\n\n            public void fileFilter(Predicate<File> fileFilter) {\n                this.fileFilter = fileFilter;\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/cutter/FileCutter.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.cutter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Deque;\nimport java.util.LinkedList;", "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class FileCutter {\n    private final File file;\n    private final StonecutterTask stonecutter;\n\n    public FileCutter(File file, StonecutterTask stonecutter) {\n        this.file = file;\n        this.stonecutter = stonecutter;\n    }\n", "    public void write(File outputFile) throws Exception {\n        StringBuilder transformedContents = new StringBuilder();\n\n        try (Reader oldContents = Files.newBufferedReader(file.toPath(), StandardCharsets.ISO_8859_1)) {\n            applyVersionedCodeComments(oldContents, transformedContents);\n            stonecutter.tokenRemapper().apply(file, transformedContents);\n        }\n\n        outputFile.delete();\n        Files.writeString(outputFile.toPath(), transformedContents, StandardCharsets.ISO_8859_1, StandardOpenOption.CREATE);\n    }\n\n    private void applyVersionedCodeComments(Reader input, StringBuilder output) throws StonecutterSyntaxException, IOException {\n        Deque<Boolean> conditions = new LinkedList<>();", "        while (read(\"/*?\", input, output) != null) {\n            String expression = read(\"?*/\", input, output);\n            if (expression == null)\n                throw new StonecutterSyntaxException(\"Expected ?*/ to close stonecutter expression\");\n            expression = expression.trim();\n\n            if (expression.startsWith(\"$token\"))\n                continue;\n\n            Boolean closedState = null;\n            final boolean skip;\n", "            if (expression.startsWith(\"}\")) {\n                if (conditions.isEmpty())\n                    throw new StonecutterSyntaxException(\"Unexpected } symbol\");\n\n                skip = (closedState = conditions.pop()) == null;\n                expression = expression.substring(1).stripLeading();\n            } else\n                skip = false;\n\n            if (!expression.isBlank()) {\n                if (expression.endsWith(\"{\"))\n                    expression = expression.substring(0, expression.length() - 1).stripTrailing();\n                else\n                    throw new StonecutterSyntaxException(\"Expected { symbol\");\n", "            if (!expression.isBlank()) {\n                if (expression.endsWith(\"{\"))\n                    expression = expression.substring(0, expression.length() - 1).stripTrailing();\n                else\n                    throw new StonecutterSyntaxException(\"Expected { symbol\");\n\n                if ((closedState != null && closedState) || ((skip || !conditions.isEmpty()) && (conditions.peek() == null || !conditions.peek()))) {\n                    conditions.push(null);\n                } else {\n                    boolean conditionResult = true;\n                    if (expression.startsWith(\"else\"))\n                        expression = expression.substring(4).stripLeading();", "                    if (expression.startsWith(\"else\"))\n                        expression = expression.substring(4).stripLeading();\n                    if (!expression.isBlank())\n                        conditionResult = stonecutter.testVersion(expression);\n\n                    conditions.push(conditionResult);\n                }\n\n                // skip 2 only if \"/*\" is next\n                input.mark(2);\n                if (input.read() != '/' || input.read() != '*')\n                    input.reset();\n", "                if (input.read() != '/' || input.read() != '*')\n                    input.reset();\n\n                if (conditions.peek() == null || !conditions.peek())\n                    output.append(\"/*\");\n            }\n        }\n    }\n\n    private static String read(String match, Reader input, StringBuilder output) throws IOException {\n        StringBuilder substring = new StringBuilder();\n\n        int current;\n", "        while ((current = input.read()) != -1) {\n            char ch = (char) current;\n            substring.append(ch);\n            output.append(ch);\n\n            if (substring.toString().endsWith(match))\n                return substring.substring(0, substring.length() - match.length());\n        }\n\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/cutter/StonecutterSyntaxException.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.cutter;\n\npublic class StonecutterSyntaxException extends Exception {\n    public StonecutterSyntaxException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/cutter/StonecutterTask.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.cutter;\n\nimport io.shcm.shsupercm.fabric.stonecutter.StonecutterBuildGradle;\nimport io.shcm.shsupercm.fabric.stonecutter.version.StonecutterVersionChecker;\nimport org.gradle.api.DefaultTask;\nimport org.gradle.api.Project;\nimport org.gradle.api.provider.Property;\nimport org.gradle.api.tasks.Input;\nimport org.gradle.api.tasks.TaskAction;\n", "import org.gradle.api.tasks.TaskAction;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\npublic abstract class StonecutterTask extends DefaultTask {", "import java.util.function.Predicate;\n\npublic abstract class StonecutterTask extends DefaultTask {\n    @Input public abstract Property<File> getInputDir();\n    @Input public abstract Property<File> getOutputDir();\n    @Input public abstract Property<StonecutterBuildGradle.Version> getFromVersion();\n    @Input public abstract Property<StonecutterBuildGradle.Version> getToVersion();\n    @Input public abstract Property<Predicate<File>> getFileFilter(); { getFileFilter().convention(f -> true); }\n    @Input public abstract Property<Function<Project, StonecutterVersionChecker>> getVersionChecker(); { getVersionChecker().convention(StonecutterVersionChecker.FABRIC_LOADER_API); }\n\n    private Predicate<String> versionChecker = predicate -> false;\n\n    private StoneRegexTokenizer remapTokenizer = null;\n\n    @TaskAction", "    @Input public abstract Property<Function<Project, StonecutterVersionChecker>> getVersionChecker(); { getVersionChecker().convention(StonecutterVersionChecker.FABRIC_LOADER_API); }\n\n    private Predicate<String> versionChecker = predicate -> false;\n\n    private StoneRegexTokenizer remapTokenizer = null;\n\n    @TaskAction\n    public void run() {\n        if (!getInputDir().isPresent() || !getOutputDir().isPresent() || !getFromVersion().isPresent() || !getToVersion().isPresent())\n            throw new IllegalArgumentException();\n", "        if (!getInputDir().isPresent() || !getOutputDir().isPresent() || !getFromVersion().isPresent() || !getToVersion().isPresent())\n            throw new IllegalArgumentException();\n\n        try {\n            final StonecutterVersionChecker versionCheckerImplementation = getVersionChecker().get().apply(getProject());\n            final Object targetCheckerVersion = versionCheckerImplementation.parseVersion(getToVersion().get().version());\n            this.versionChecker = predicate -> versionCheckerImplementation.check(targetCheckerVersion, predicate);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Could not create version checker implementation\", e);\n        }\n", "        try {\n            StoneRegexTokenizer sourceTokenizer = getFromVersion().get().tokenizer();\n            StoneRegexTokenizer targetTokenizer = getToVersion().get().tokenizer();\n\n            if (!targetTokenizer.tokens().containsAll(sourceTokenizer.tokens())) {\n                Set<String> missing = new HashSet<>(sourceTokenizer.tokens());\n                missing.removeAll(targetTokenizer.tokens());\n                getLogger().warn(\"Target token set not complete! Skipping mapping for: [\" + String.join(\", \", missing) + \"]\");\n            }\n\n            this.remapTokenizer = StoneRegexTokenizer.remap(sourceTokenizer, targetTokenizer);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Could not load tokenizer!\", e);\n        }\n", "        try {\n            transform(getInputDir().get(), getInputDir().get(), getOutputDir().get());\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Errored while processing files\", e);\n        }\n    }\n\n    private void transform(File file, File inputRoot, File outputRoot) throws Exception {\n        if (file == null || !file.exists())\n            return;\n", "        if (file == null || !file.exists())\n            return;\n\n        if (file.isDirectory())\n            for (File subFile : Objects.requireNonNull(file.listFiles()))\n                transform(subFile, inputRoot, outputRoot);\n        else if (getFileFilter().get().test(file)) {\n            File output = file;\n            if (!inputRoot.equals(outputRoot)) {\n                output = outputRoot.toPath().resolve(inputRoot.toPath().relativize(output.toPath())).toFile();\n                output.getParentFile().mkdirs();\n            }\n            new FileCutter(file, this).write(output);\n        }\n    }\n", "            if (!inputRoot.equals(outputRoot)) {\n                output = outputRoot.toPath().resolve(inputRoot.toPath().relativize(output.toPath())).toFile();\n                output.getParentFile().mkdirs();\n            }\n            new FileCutter(file, this).write(output);\n        }\n    }\n\n    public boolean testVersion(String predicate) {\n        return this.versionChecker.test(predicate);\n    }\n", "    public boolean testVersion(String predicate) {\n        return this.versionChecker.test(predicate);\n    }\n\n    public StoneRegexTokenizer tokenRemapper() {\n        return this.remapTokenizer;\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/version/FabricLoaderAPIVersionChecker.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.version;\n\nimport java.lang.reflect.Method;\nimport java.util.function.Predicate;\n\npublic class FabricLoaderAPIVersionChecker implements StonecutterVersionChecker {\n    private final ClassLoader classLoader;\n    private final Class<?> classSemanticVersion;\n    private final Method methodSemanticVersionParse, methodVersionPredicateParse;\n\n    public FabricLoaderAPIVersionChecker(ClassLoader classLoader) throws ClassNotFoundException, NoSuchMethodException {\n        this.classLoader = classLoader;\n\n        this.classSemanticVersion = classLoader.loadClass(\"net.fabricmc.loader.api.SemanticVersion\");\n        this.methodSemanticVersionParse = classSemanticVersion.getDeclaredMethod(\"parse\", String.class);\n        this.methodVersionPredicateParse = classLoader.loadClass(\"net.fabricmc.loader.api.metadata.version.VersionPredicate\").getDeclaredMethod(\"parse\", String.class);\n    }\n\n    @Override", "    public Object parseVersion(String versionString) throws Exception {\n        return this.methodSemanticVersionParse.invoke(null, versionString);\n    }\n\n    @Override\n    public Predicate<Object> parseChecker(String predicateString) throws Exception {\n        //noinspection unchecked\n        return (Predicate<Object>) this.methodVersionPredicateParse.invoke(null, predicateString);\n    }\n}\n"]}
{"filename": "src/main/java/io/shcm/shsupercm/fabric/stonecutter/version/StonecutterVersionChecker.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.version;\n\nimport org.gradle.api.Project;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\npublic interface StonecutterVersionChecker {\n    Object parseVersion(String versionString) throws Exception;\n\n    Predicate<Object> parseChecker(String predicateString) throws Exception;\n\n    default boolean check(Object version, String predicateString) {", "import java.util.function.Predicate;\n\npublic interface StonecutterVersionChecker {\n    Object parseVersion(String versionString) throws Exception;\n\n    Predicate<Object> parseChecker(String predicateString) throws Exception;\n\n    default boolean check(Object version, String predicateString) {\n        try {\n            return parseChecker(predicateString).test(version);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    Function<Project, StonecutterVersionChecker> FABRIC_LOADER_API = project -> {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n        loaderCopy.mkdirs();\n        loaderCopy = new File(loaderCopy, \"fabric-loader.jar\");\n", "        try {\n            return parseChecker(predicateString).test(version);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    Function<Project, StonecutterVersionChecker> FABRIC_LOADER_API = project -> {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n        loaderCopy.mkdirs();\n        loaderCopy = new File(loaderCopy, \"fabric-loader.jar\");\n", "        if (loaderCopy.exists())\n            try {\n                return new FabricLoaderAPIVersionChecker(new URLClassLoader(new URL[]{ loaderCopy.toURI().toURL() }, StonecutterVersionChecker.class.getClassLoader()));\n            } catch (Exception ignored) {}\n\n        project.getLogger().error(\"Could not create default fabric loader api version checker!\");\n        return new StonecutterVersionChecker() {\n            @Override\n            public Object parseVersion(String versionString) throws Exception {\n                return versionString;\n            }\n\n            @Override\n            public Predicate<Object> parseChecker(String predicateString) throws Exception {\n                return o -> false;\n            }\n        };\n    };\n}\n", "            public Object parseVersion(String versionString) throws Exception {\n                return versionString;\n            }\n\n            @Override\n            public Predicate<Object> parseChecker(String predicateString) throws Exception {\n                return o -> false;\n            }\n        };\n    };\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/StonecutterService.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea;\n\nimport com.intellij.execution.executors.DefaultRunExecutor;\nimport com.intellij.notification.Notification;\nimport com.intellij.notification.NotificationGroup;\nimport com.intellij.notification.NotificationType;\nimport com.intellij.notification.Notifications;\nimport com.intellij.openapi.externalSystem.model.DataNode;\nimport com.intellij.openapi.externalSystem.model.project.ProjectData;\nimport com.intellij.openapi.module.Module;", "import com.intellij.openapi.externalSystem.model.project.ProjectData;\nimport com.intellij.openapi.module.Module;\nimport com.intellij.openapi.module.ModuleManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.project.ProjectManager;\nimport com.intellij.openapi.roots.ModuleRootManager;\nimport com.intellij.openapi.roots.ProjectRootManager;\nimport com.intellij.openapi.util.IconLoader;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport org.jetbrains.annotations.NotNull;", "import com.intellij.openapi.vfs.VirtualFile;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.plugins.gradle.action.GradleExecuteTaskAction;\nimport org.jetbrains.plugins.gradle.model.ExternalProject;\nimport org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension;\nimport org.jetbrains.plugins.gradle.service.project.data.ExternalProjectDataCache;\n\nimport javax.swing.*;\nimport java.io.BufferedReader;\nimport java.io.File;", "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\npublic class StonecutterService {\n    public static final Icon ICON = IconLoader.getIcon(\"/Stonecutter.svg\", StonecutterService.class);\n\n    private final Project project;\n\n    private final Map<Module, StonecutterSetup> byController = new HashMap<>(), byVersioned = new HashMap<>();\n\n    public StonecutterService(Project project) {\n        this.project = project;\n        loadFromProject();\n    }\n", "\npublic class StonecutterService {\n    public static final Icon ICON = IconLoader.getIcon(\"/Stonecutter.svg\", StonecutterService.class);\n\n    private final Project project;\n\n    private final Map<Module, StonecutterSetup> byController = new HashMap<>(), byVersioned = new HashMap<>();\n\n    public StonecutterService(Project project) {\n        this.project = project;\n        loadFromProject();\n    }\n", "    public void switchActive(String version) {\n        Notifications.Bus.notify(new Notification(NotificationGroup.createIdWithTitle(\"stonecutter\", \"Stonecutter\"), \"Stonecutter\", \"Switching active stonecutter version to \" + version, NotificationType.INFORMATION));\n\n        GradleExecuteTaskAction.runGradle(project, DefaultRunExecutor.getRunExecutorInstance(), project.getBasePath(), \"\\\"Set active version to \" + version + \"\\\" -Dstonecutter.disableCentralBuildScript=true\");\n    }\n\n    public StonecutterSetup fromControllerModule(Module module) {\n        return byController.get(module);\n    }\n\n    public StonecutterSetup fromVersionedModule(Module module) {\n        return byVersioned.get(module);\n    }\n", "    public StonecutterSetup fromVersionedModule(Module module) {\n        return byVersioned.get(module);\n    }\n\n    public StonecutterSetup fromControllerFile(VirtualFile file) {\n        try {\n            return fromControllerModule(ProjectRootManager.getInstance(project).getFileIndex().getModuleForFile(file));\n        } catch (Exception ignored) {\n            return null;\n        }\n    }\n", "    public StonecutterSetup fromVersionedFile(VirtualFile file) {\n        try {\n            return fromVersionedModule(ProjectRootManager.getInstance(project).getFileIndex().getModuleForFile(file));\n        } catch (Exception ignored) {\n            return null;\n        }\n    }\n\n    public void loadFromProject() {\n        ExternalProjectDataCache gradleCache = ExternalProjectDataCache.getInstance(project);\n        ModuleManager moduleManager = ModuleManager.getInstance(project);\n\n        byController.clear();\n        byVersioned.clear();\n\n        Map<File, Module> moduleByRoot = new HashMap<>();\n", "    public void loadFromProject() {\n        ExternalProjectDataCache gradleCache = ExternalProjectDataCache.getInstance(project);\n        ModuleManager moduleManager = ModuleManager.getInstance(project);\n\n        byController.clear();\n        byVersioned.clear();\n\n        Map<File, Module> moduleByRoot = new HashMap<>();\n\n        for (Module module : moduleManager.getModules())\n            for (VirtualFile root : module.getComponent(ModuleRootManager.class).getContentRoots())\n                moduleByRoot.put(new File(root.getPath()), module);\n", "        for (Module module : moduleManager.getModules())\n            for (VirtualFile root : module.getComponent(ModuleRootManager.class).getContentRoots())\n                moduleByRoot.put(new File(root.getPath()), module);\n\n        for (Module module : moduleManager.getModules())\n            for (VirtualFile root : module.getComponent(ModuleRootManager.class).getContentRoots()) {\n                ExternalProject externalProject = gradleCache.getRootExternalProject(root.getPath());\n                if (externalProject == null)\n                    continue;\n\n                exploreGradleProject(externalProject, moduleByRoot::get);\n            }\n", "        for (StonecutterSetup setup : byController.values())\n            for (String version : setup.versions())\n                byVersioned.put(moduleByRoot.get((setup.gradleProject().getChildProjects().get(version)).getProjectDir()), setup);\n\n        for (Map.Entry<Module, StonecutterSetup> entry : new HashMap<>(byVersioned).entrySet())\n            for (String sourceSetName : gradleCache.findExternalProject(entry.getValue().gradleProject(), entry.getKey()).keySet()) {\n                Module sourceSetModule = moduleManager.findModuleByName(entry.getKey().getName() + \".\" + sourceSetName);\n                if (sourceSetModule != null)\n                    byVersioned.put(sourceSetModule, entry.getValue());\n            }\n    }\n\n    private void exploreGradleProject(ExternalProject project, Function<File, Module> moduleGetter) {", "        try {\n            File stonecutterGradleFile = project.getBuildFile();\n            if (!Objects.requireNonNull(stonecutterGradleFile).getName().equals(\"stonecutter.gradle\"))\n                throw new Exception();\n\n            try (BufferedReader reader = new BufferedReader(new FileReader(stonecutterGradleFile, StandardCharsets.ISO_8859_1))) {\n                if (!reader.readLine().equals(\"plugins.apply 'io.shcm.shsupercm.fabric.stonecutter'\"))\n                    throw new Exception();\n\n                String currentActive = reader.readLine();\n                currentActive = currentActive.substring(currentActive.indexOf('\\'') + 1, currentActive.lastIndexOf('\\''));\n\n                byController.putIfAbsent(moduleGetter.apply(project.getProjectDir()), new StonecutterSetup(project, currentActive));\n            }\n        } catch (Exception ignored) { }\n", "        for (ExternalProject child : project.getChildProjects().values())\n            exploreGradleProject(child, moduleGetter);\n    }\n\n    public static class ReloadListener extends AbstractProjectResolverExtension {\n        @Override\n        public void resolveFinished(@NotNull DataNode<ProjectData> projectDataNode) {\n            for (Project project : ProjectManager.getInstance().getOpenProjects()) {\n                StonecutterService service = project.getServiceIfCreated(StonecutterService.class);\n                if (service != null)\n                    service.loadFromProject();\n            }\n        }\n    }\n}\n", "                if (service != null)\n                    service.loadFromProject();\n            }\n        }\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/StonecutterSetup.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea;\n\nimport groovy.lang.*;\nimport org.codehaus.groovy.control.CompilerConfiguration;\nimport org.jetbrains.plugins.gradle.model.ExternalProject;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;", "import java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class StonecutterSetup {\n    private final ExternalProject gradleProject;\n    private final String currentActive;\n    private final String[] versions;\n    private final TokenMapper tokensCache;\n\n    public StonecutterSetup(ExternalProject gradleProject, String currentActive) {\n        this.gradleProject = gradleProject;\n        this.currentActive = currentActive;\n\n        List<String> versions = new ArrayList<>(); {", "            for (Map.Entry<String, ? extends ExternalProject> entry : gradleProject.getChildProjects().entrySet()) {\n                File versionedDir = entry.getValue().getProjectDir();\n                if (versionedDir.getName().equals(entry.getKey()) && versionedDir.getParentFile().getName().equals(\"versions\"))\n                    versions.add(entry.getKey());\n            }\n        } this.versions = versions.toArray(String[]::new);\n\n        Map<String, File> tokens = new HashMap<>();\n        for (String version : this.versions)\n            tokens.put(version, new File(gradleProject.getChildProjects().get(version).getProjectDir(), \"tokens.gradle\"));\n        this.tokensCache = new TokenMapper(tokens);\n    }\n", "        for (String version : this.versions)\n            tokens.put(version, new File(gradleProject.getChildProjects().get(version).getProjectDir(), \"tokens.gradle\"));\n        this.tokensCache = new TokenMapper(tokens);\n    }\n\n    public ExternalProject gradleProject() {\n        return this.gradleProject;\n    }\n\n    public String currentActive() {\n        return this.currentActive;\n    }\n\n    public Iterable<String> versions() {\n        return Arrays.asList(this.versions);\n    }\n", "    public String currentActive() {\n        return this.currentActive;\n    }\n\n    public Iterable<String> versions() {\n        return Arrays.asList(this.versions);\n    }\n\n    public TokenMapper tokenCache() {\n        return this.tokensCache;\n    }\n", "    public TokenMapper tokenCache() {\n        return this.tokensCache;\n    }\n\n    public static class TokenMapper {\n        public final Map<String, Map<String, Token>> tokensByVersion = new HashMap<>();\n        public final Set<String> commonTokens = new HashSet<>(), missingTokens = new HashSet<>();\n\n        public static class Token {\n            public final String id;\n            public final Pattern read;", "        public static class Token {\n            public final String id;\n            public final Pattern read;\n            public final String write;\n            public final boolean defaultEnabled;\n            public final Predicate<File> fileFilter;\n\n            public Token(String id, Pattern read, String write, boolean defaultEnabled, Predicate<File> fileFilter) {\n                this.id = id;\n                this.read = read;\n                this.write = write;\n                this.defaultEnabled = defaultEnabled;\n                this.fileFilter = fileFilter;\n            }\n        }\n\n        public TokenMapper(Map<String, File> tokenScripts) {\n            CompilerConfiguration groovyCompiler = new CompilerConfiguration();\n            groovyCompiler.setScriptBaseClass(TokensScriptClass.class.getName());\n            GroovyClassLoader classLoader = new GroovyClassLoader(TokensScriptClass.class.getClassLoader(), groovyCompiler);\n            GroovyShell groovy = new GroovyShell(classLoader, groovyCompiler);", "            for (Map.Entry<String, File> entry : tokenScripts.entrySet()) {\n                try {\n                    TokensScriptClass tokensScript = (TokensScriptClass) groovy.parse(entry.getValue());\n                    tokensScript.run();\n                    for (Map.Entry<String, TokensScriptClass.Builder> token : tokensScript.tokenBuilders.entrySet())\n                        try {\n                            tokensByVersion.computeIfAbsent(entry.getKey(), v -> new HashMap<>())\n                                    .put(token.getKey(), new Token(token.getKey(), token.getValue().read, token.getValue().write, token.getValue().defaultEnabled, token.getValue().fileFilter));\n                        } catch (Exception ignored) { }\n                } catch (Exception ignored) { }\n            }\n", "            for (Map.Entry<String, Map<String, Token>> entry : tokensByVersion.entrySet()) {\n                for (String token : entry.getValue().keySet()) {\n                    if (commonTokens.contains(token))\n                        continue;\n\n                    boolean common = true;\n                    for (Map<String, Token> tokens : tokensByVersion.values())\n                        if (!(common = tokens.containsKey(token)))\n                            break;\n                    (common ? commonTokens : missingTokens).add(token);\n                }\n            }\n        }\n", "        public static class TokensScriptClass extends Script {\n            public final Map<String, Builder> tokenBuilders = new HashMap<>();\n\n            @Override\n            public Object run() {\n                return null;\n            }\n\n            public void token(String id, Closure<Builder> builder) {\n                tokenBuilders.put(id, new Builder(builder));\n            }\n", "            public void token(String id, Closure<Builder> builder) {\n                tokenBuilders.put(id, new Builder(builder));\n            }\n\n            public static class Builder {\n                public Pattern read = null;\n                public String write = null;\n                public boolean defaultEnabled = false;\n                public Predicate<File> fileFilter = null;\n\n                public Builder(Closure<Builder> builder) {\n                    builder.setDelegate(this);\n                    builder.call();\n                }\n", "                public void read(Pattern read) {\n                    this.read = read;\n                }\n\n                public void write(String write) {\n                    this.write = write;\n                }\n\n                public void defaultEnabled(boolean defaultEnabled) {\n                    this.defaultEnabled = defaultEnabled;\n                }\n", "                public void defaultEnabled(boolean defaultEnabled) {\n                    this.defaultEnabled = defaultEnabled;\n                }\n\n                public void fileFilter(Predicate<File> fileFilter) {\n                    this.fileFilter = fileFilter;\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/actions/OpenStonecutterEditorAction.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.actions;\n\nimport com.intellij.openapi.actionSystem.AnAction;\nimport com.intellij.openapi.actionSystem.AnActionEvent;\nimport com.intellij.openapi.actionSystem.PlatformDataKeys;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.ui.StonecutterEditorPopup;", "import io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.ui.StonecutterEditorPopup;\nimport org.jetbrains.annotations.NotNull;\n\npublic class OpenStonecutterEditorAction extends AnAction {\n    @Override\n    public void actionPerformed(@NotNull AnActionEvent e) {\n        Project project = e.getRequiredData(PlatformDataKeys.PROJECT);\n        Editor editor = e.getRequiredData(PlatformDataKeys.EDITOR);\n        VirtualFile file = e.getRequiredData(PlatformDataKeys.VIRTUAL_FILE);\n\n        StonecutterEditorPopup.builder(project, editor, file)\n                .createPopup()\n                .showInBestPositionFor(editor);\n    }\n\n    @Override", "    public void update(@NotNull AnActionEvent e) {\n        Project project = e.getData(PlatformDataKeys.PROJECT);\n        Editor editor = e.getData(PlatformDataKeys.EDITOR);\n        VirtualFile file = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n\n        e.getPresentation().setEnabled(project != null && editor != null && file != null && project.getService(StonecutterService.class).fromVersionedFile(file) != null);\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/ext/CutterFolding.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.ext;\n\nimport com.intellij.lang.ASTNode;\nimport com.intellij.lang.folding.FoldingBuilder;\nimport com.intellij.lang.folding.FoldingDescriptor;\nimport com.intellij.openapi.editor.Document;\nimport com.intellij.openapi.editor.FoldingGroup;\nimport com.intellij.openapi.util.TextRange;\nimport com.intellij.psi.JavaTokenType;\nimport com.intellij.psi.PsiComment;", "import com.intellij.psi.JavaTokenType;\nimport com.intellij.psi.PsiComment;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\n\nimport java.util.*;\n\npublic class CutterFolding implements FoldingBuilder {\n    public static FoldingGroup GROUP_SYNTAX = FoldingGroup.newGroup(\"stonecutterSyntax\");\n\n    private List<FoldingDescriptor> descriptors = null;\n\n    @Override\n    public FoldingDescriptor[] buildFoldRegions(ASTNode node, Document document) {", "        if (node.getPsi().getProject().getService(StonecutterService.class).fromVersionedFile(node.getPsi().getContainingFile().getVirtualFile()) == null)\n            return FoldingDescriptor.EMPTY;\n\n        descriptors = new ArrayList<>();\n\n        buildFolds(node);\n\n        return descriptors.isEmpty() ? FoldingDescriptor.EMPTY : descriptors.toArray(new FoldingDescriptor[0]);\n    }\n\n    private void buildFolds(ASTNode node) {", "        if (node.getElementType() == JavaTokenType.C_STYLE_COMMENT)\n            buildFold(node.getPsi(PsiComment.class));\n\n        for (ASTNode child : node.getChildren(null))\n            buildFolds(child);\n    }\n\n    private void buildFold(PsiComment comment) {\n        if (comment.getText().startsWith(\"/*?\") && comment.getText().endsWith(\"?*/\")) {\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + 1, comment.getTextOffset() + comment.getTextLength()), null, Set.of(comment), true, comment.getText().substring(3, comment.getTextLength() - 3).trim(), true));\n        } else if (!descriptors.isEmpty() && comment.getText().startsWith(\"/*\") && comment.getText().endsWith(\"?*/\") &&\n                    descriptors.get(descriptors.size() - 1).getRange().getEndOffset() == comment.getTextRange().getStartOffset()) {\n            int nextExpression = comment.getText().lastIndexOf(\"/*?\");\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + 1, comment.getTextOffset() + nextExpression), null, Set.of(comment), true, comment.getText().substring(2, nextExpression).trim(), true));\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + nextExpression + 1, comment.getTextOffset() + comment.getTextLength()), null, Set.of(comment), true, comment.getText().substring(nextExpression + 3, comment.getTextLength() - 3).trim(), true));\n        }\n    }\n\n    @Override", "        if (comment.getText().startsWith(\"/*?\") && comment.getText().endsWith(\"?*/\")) {\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + 1, comment.getTextOffset() + comment.getTextLength()), null, Set.of(comment), true, comment.getText().substring(3, comment.getTextLength() - 3).trim(), true));\n        } else if (!descriptors.isEmpty() && comment.getText().startsWith(\"/*\") && comment.getText().endsWith(\"?*/\") &&\n                    descriptors.get(descriptors.size() - 1).getRange().getEndOffset() == comment.getTextRange().getStartOffset()) {\n            int nextExpression = comment.getText().lastIndexOf(\"/*?\");\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + 1, comment.getTextOffset() + nextExpression), null, Set.of(comment), true, comment.getText().substring(2, nextExpression).trim(), true));\n            descriptors.add(new FoldingDescriptor(comment.getNode(), new TextRange(comment.getTextOffset() + nextExpression + 1, comment.getTextOffset() + comment.getTextLength()), null, Set.of(comment), true, comment.getText().substring(nextExpression + 3, comment.getTextLength() - 3).trim(), true));\n        }\n    }\n\n    @Override", "    public String getPlaceholderText(ASTNode node) {\n        return \"\";\n    }\n\n    @Override\n    public boolean isCollapsedByDefault(ASTNode node) {\n        return true;\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/ext/EditorMouseClick.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.ext;\n\nimport com.intellij.openapi.actionSystem.ActionManager;\nimport com.intellij.openapi.editor.FoldRegion;\nimport com.intellij.openapi.editor.event.EditorMouseEvent;\nimport com.intellij.openapi.editor.event.EditorMouseListener;\nimport com.intellij.openapi.util.TextRange;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.actions.OpenStonecutterEditorAction;\nimport org.jetbrains.annotations.NotNull;", "import io.shcm.shsupercm.fabric.stonecutter.idea.actions.OpenStonecutterEditorAction;\nimport org.jetbrains.annotations.NotNull;\n\npublic class EditorMouseClick implements EditorMouseListener {\n    @Override\n    public void mouseClicked(@NotNull EditorMouseEvent event) {\n        if (event.getEditor().getProject() == null)\n            return;\n        if (event.getEditor().getProject().getService(StonecutterService.class) == null)\n            return;\n\n        FoldRegion clickedFolding = event.getCollapsedFoldRegion();", "        if (event.getEditor().getProject().getService(StonecutterService.class) == null)\n            return;\n\n        FoldRegion clickedFolding = event.getCollapsedFoldRegion();\n        if (clickedFolding != null) {\n            String text = clickedFolding.getEditor().getDocument().getText(TextRange.create(clickedFolding.getStartOffset() - 1, clickedFolding.getEndOffset()));\n            if (text.startsWith(\"/*?\") && text.endsWith(\"?*/\")) {\n                event.getEditor().getCaretModel().moveToOffset(clickedFolding.getStartOffset());\n                event.consume();\n                ActionManager.getInstance().tryToExecute(ActionManager.getInstance().getAction(OpenStonecutterEditorAction.class.getName()), event.getMouseEvent(), event.getEditor().getComponent(), null, true);\n            } else if (text.startsWith(\"/*\")) {", "            } else if (text.startsWith(\"/*\")) {\n                for (FoldRegion foldRegion : event.getEditor().getFoldingModel().getAllFoldRegions())\n                    if (foldRegion.getEndOffset() + 1 == clickedFolding.getStartOffset()) {\n                        clickedFolding = foldRegion;\n                        text = clickedFolding.getEditor().getDocument().getText(TextRange.create(clickedFolding.getStartOffset(), clickedFolding.getEndOffset()));\n                        if (text.startsWith(\"/*?\") && text.endsWith(\"?*/\")) {\n                            event.getEditor().getCaretModel().moveToOffset(clickedFolding.getStartOffset() + 1);\n                            event.consume();\n                            ActionManager.getInstance().tryToExecute(ActionManager.getInstance().getAction(OpenStonecutterEditorAction.class.getName()), event.getMouseEvent(), event.getEditor().getComponent(), null, true);\n                            return;\n                        }\n                    }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/inspections/UnclosedInspection.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.inspections;\n\nimport com.intellij.codeInspection.AbstractBaseJavaLocalInspectionTool;\nimport com.intellij.codeInspection.ProblemHighlightType;\nimport com.intellij.codeInspection.ProblemsHolder;\nimport com.intellij.psi.JavaElementVisitor;\nimport com.intellij.psi.PsiComment;\nimport com.intellij.psi.PsiElementVisitor;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport org.jetbrains.annotations.NotNull;", "import io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport org.jetbrains.annotations.NotNull;\n\npublic class UnclosedInspection extends AbstractBaseJavaLocalInspectionTool {\n    @Override\n    public @NotNull PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {\n        if (holder.getProject().getService(StonecutterService.class).fromVersionedFile(holder.getFile().getVirtualFile()) == null)\n            return super.buildVisitor(holder, isOnTheFly);\n\n        return new JavaElementVisitor() {\n            @Override", "            public void visitComment(@NotNull PsiComment comment) {\n                if (comment.getText().startsWith(\"/*?\") && !comment.getText().endsWith(\"?*/\")) {\n                    holder.registerProblem(comment, \"Unclosed Stonecutter expression\", ProblemHighlightType.ERROR);\n                }\n            }\n        };\n    }\n}\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/ui/NewTokenDialog.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.ui;\n\nimport com.intellij.lang.Language;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.editor.colors.EditorColors;\nimport com.intellij.openapi.editor.markup.*;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.ui.DialogWrapper;\nimport com.intellij.openapi.ui.ValidationInfo;\nimport com.intellij.ui.LanguageTextField;", "import com.intellij.openapi.ui.ValidationInfo;\nimport com.intellij.ui.LanguageTextField;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterSetup;\nimport org.jetbrains.annotations.Nullable;\n\nimport javax.swing.*;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.regex.Pattern;\n\npublic class NewTokenDialog extends DialogWrapper {\n    private final Project project;\n    private final Editor editor;\n    private final StonecutterSetup stonecutter;\n", "import java.util.regex.Pattern;\n\npublic class NewTokenDialog extends DialogWrapper {\n    private final Project project;\n    private final Editor editor;\n    private final StonecutterSetup stonecutter;\n\n    public final Collection<RangeHighlighter> highlighters;\n\n    public JPanel root;\n    public JCheckBox cEnableByDefault;", "    public JPanel root;\n    public JCheckBox cEnableByDefault;\n    public LanguageTextField tIdentifier;\n    public LanguageTextField tReader;\n    public LanguageTextField tWriter;\n\n    public NewTokenDialog(Project project, Editor editor, StonecutterSetup stonecutter) {\n        super(project);\n        this.project = project;\n        this.editor = editor;\n        this.stonecutter = stonecutter;\n        this.highlighters = new ArrayList<>();\n\n        setTitle(\"Create New Stonecutter Token\");\n        init();\n        initValidation();\n    }\n\n    private void createUIComponents() {\n        this.tIdentifier = new LanguageTextField(Language.findLanguageByID(\"TEXT\"), project, \"\", true);\n        this.tReader = new LanguageTextField(Language.findLanguageByID(\"RegExp\"), project, \"\", true);\n        this.tWriter = new LanguageTextField(Language.findLanguageByID(\"TEXT\"), project, \"\", true);\n\n        tIdentifier.setText(stonecutter.tokenCache().missingTokens.isEmpty() ? \"\" : stonecutter.tokenCache().missingTokens.iterator().next());\n    }\n\n    @Override\n    protected @Nullable ValidationInfo doValidate() {", "        if (!tIdentifier.getText().trim().matches(\"^[-_a-z0-9]+$\"))\n            return new ValidationInfo(\"Token identifiers should only contain a-z, 0-9, dashes and underscores.\", tIdentifier).withOKEnabled();\n        if (stonecutter.tokenCache().commonTokens.contains(tIdentifier.getText().trim()))\n            return new ValidationInfo(\"Token already exists in this version.\", tIdentifier);\n\n        for (RangeHighlighter highlighter : highlighters)\n            editor.getMarkupModel().removeHighlighter(highlighter);\n        highlighters.clear();\n\n        try {\n            Pattern readerPattern = Pattern.compile(tReader.getText());\n\n            final var matches = new Object() {", "        try {\n            Pattern readerPattern = Pattern.compile(tReader.getText());\n\n            final var matches = new Object() {\n                public int total = 0, errored = 0;\n            };\n\n            readerPattern.matcher(editor.getDocument().getText()).results().forEach(result -> {\n                final boolean reconstructs; {\n                    String original = result.group(),\n                           replaced = readerPattern.matcher(original).replaceFirst(tWriter.getText());\n                    reconstructs = original.equals(replaced);\n                }\n\n                matches.total++;", "                if (!reconstructs)\n                    matches.errored++;\n\n                highlighters.add(editor.getMarkupModel().addRangeHighlighter(\n                        reconstructs ? EditorColors.TEXT_SEARCH_RESULT_ATTRIBUTES : EditorColors.WRITE_SEARCH_RESULT_ATTRIBUTES,\n                        result.start(), result.end(),\n                        HighlighterLayer.SELECTION + 2, HighlighterTargetArea.EXACT_RANGE));\n            });\n\n            if (matches.errored > 0)\n                return new ValidationInfo(matches.errored + \"/\" + matches.total + \" matches in the current file would not be written correctly\", tWriter).withOKEnabled();\n        } catch (Exception ignored) { }\n\n        return null;\n    }\n\n    @Override\n    protected void dispose() {\n        super.dispose();", "            if (matches.errored > 0)\n                return new ValidationInfo(matches.errored + \"/\" + matches.total + \" matches in the current file would not be written correctly\", tWriter).withOKEnabled();\n        } catch (Exception ignored) { }\n\n        return null;\n    }\n\n    @Override\n    protected void dispose() {\n        super.dispose();\n        try {", "        try {\n            for (RangeHighlighter highlighter : highlighters)\n                editor.getMarkupModel().removeHighlighter(highlighter);\n            highlighters.clear();\n        } catch (Exception ignored) { }\n    }\n\n    @Override\n    protected @Nullable JComponent createCenterPanel() {\n        return root;\n    }\n", "    public void execute() {\n\n    }\n}\n\n"]}
{"filename": "src/idea-integration/java/io/shcm/shsupercm/fabric/stonecutter/idea/ui/StonecutterEditorPopup.java", "chunked_list": ["package io.shcm.shsupercm.fabric.stonecutter.idea.ui;\n\nimport com.google.common.collect.Lists;\nimport com.intellij.openapi.command.WriteCommandAction;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.editor.FoldRegion;\nimport com.intellij.openapi.fileEditor.FileEditorManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.ui.popup.ActiveIcon;\nimport com.intellij.openapi.ui.popup.ComponentPopupBuilder;", "import com.intellij.openapi.ui.popup.ActiveIcon;\nimport com.intellij.openapi.ui.popup.ComponentPopupBuilder;\nimport com.intellij.openapi.ui.popup.JBPopupFactory;\nimport com.intellij.openapi.ui.popup.StackingPopupDispatcher;\nimport com.intellij.openapi.util.TextRange;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.openapi.vfs.VirtualFileManager;\nimport com.intellij.psi.codeStyle.CodeStyleManager;\nimport com.intellij.ui.CollectionComboBoxModel;\nimport com.intellij.ui.table.JBTable;", "import com.intellij.ui.CollectionComboBoxModel;\nimport com.intellij.ui.table.JBTable;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterService;\nimport io.shcm.shsupercm.fabric.stonecutter.idea.StonecutterSetup;\n\nimport javax.swing.*;\nimport javax.swing.table.AbstractTableModel;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.File;", "import java.awt.event.*;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class StonecutterEditorPopup {\n    private static final ActiveIcon ICON = new ActiveIcon(StonecutterService.ICON);\n\n    private final Project project;\n    private final Editor editor;\n    private final VirtualFile file;\n    private final StonecutterSetup stonecutter;\n\n    private TextRange mainSyntaxRange = null;\n", "    public JPanel root;\n    public JButton bVersions;\n    public JButton bTokens;\n\n    public static ComponentPopupBuilder builder(Project project, Editor editor, VirtualFile file) {\n        return builder(new StonecutterEditorPopup(project, editor, file));\n    }\n\n    private static ComponentPopupBuilder builder(StonecutterEditorPopup popup) {\n        return JBPopupFactory.getInstance()\n                .createComponentPopupBuilder(popup.root, popup.root)\n                .setCancelOnClickOutside(true)\n                .setCancelOnOtherWindowOpen(true)\n                .setCancelOnWindowDeactivation(true)\n                .setRequestFocus(true)\n                .setDimensionServiceKey(popup.project, StonecutterEditorPopup.class.getName(), false)\n                .setTitle(\"Stonecutter\")\n                .setTitleIcon(ICON);\n    }\n\n    private StonecutterEditorPopup(Project project, Editor editor, VirtualFile file) {\n        this.project = project;\n        this.editor = editor;\n        this.file = file;\n        this.stonecutter = project.getService(StonecutterService.class).fromVersionedFile(file);\n\n        SwingUtilities.invokeLater(() -> bVersions.requestFocusInWindow());\n", "        for (Component component : new Component[] { bVersions, bTokens }) {\n            component.setFocusTraversalKeysEnabled(false);\n            component.addKeyListener(new KeyAdapter() {\n                @Override\n                public void keyPressed(KeyEvent e) {\n                    if (e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {\n                        if (bVersions.isFocusOwner())\n                            bTokens.requestFocusInWindow();\n                        else if (bTokens.isFocusOwner())\n                            bVersions.requestFocusInWindow();\n                        e.consume();", "                        else if (bTokens.isFocusOwner())\n                            bVersions.requestFocusInWindow();\n                        e.consume();\n                    } else if (e.getKeyCode() == KeyEvent.VK_TAB) {\n                        if (bVersions.isFocusOwner() || bTokens.isFocusOwner()) {\n                            Component centerComponent = ((BorderLayout) root.getLayout()).getLayoutComponent(BorderLayout.CENTER);\n                            if (centerComponent != null)\n                                (centerComponent instanceof JPanel && ((JPanel) centerComponent).getComponents().length > 0 ? ((JPanel) centerComponent).getComponent(0) : centerComponent).requestFocusInWindow();\n\n                            e.consume();\n                        }\n                    }\n                }\n            });\n        }\n\n        bVersions.addActionListener(this::clickVersions);\n        bTokens.addActionListener(this::clickTokens);\n\n        bVersions.setText(stonecutter.currentActive());\n", "        for (FoldRegion foldRegion : editor.getFoldingModel().getAllFoldRegions()) {\n            if (foldRegion.getStartOffset() == editor.getCaretModel().getOffset()) {\n                TextRange commentRange = TextRange.create(foldRegion.getStartOffset() - 1, foldRegion.getEndOffset());\n                String text = foldRegion.getDocument().getText(commentRange);\n                if (text.startsWith(\"/*?\") && text.endsWith(\"?*/\")) {\n                    this.mainSyntaxRange = commentRange;\n                    break;\n                }\n            }\n        }\n", "        if (this.mainSyntaxRange != null) {\n            root.add(new EditSyntax().tabRoot, BorderLayout.CENTER);\n        } else if (editor.getSelectionModel().hasSelection()) {\n            root.add(new NewConstraint().tabRoot, BorderLayout.CENTER);\n        }\n    }\n\n    private void clickVersions(ActionEvent e) {\n        JBPopupFactory.getInstance()\n                .createPopupChooserBuilder(Lists.newArrayList(stonecutter.versions()))\n                .setTitle(\"Switch Stonecutter Active Version\")\n                .setSelectionMode(ListSelectionModel.SINGLE_SELECTION)\n                .setItemChosenCallback(version -> project.getService(StonecutterService.class).switchActive(version))\n                .createPopup().showInBestPositionFor(editor);\n    }\n\n    private void clickTokens(ActionEvent e) {\n        editor.getSelectionModel().removeSelection();\n        StackingPopupDispatcher.getInstance().closeActivePopup();\n\n        StonecutterEditorPopup popup = new StonecutterEditorPopup(project, editor, file);\n        popup.root.add(popup.new Tokens().tabRoot, BorderLayout.CENTER);\n        builder(popup).setMinSize(new Dimension(300, 200)).setResizable(true).createPopup().showInBestPositionFor(editor);\n    }\n", "    public class NewConstraint {\n        public JPanel tabRoot;\n        public JButton bNewConstraint;\n        public JButton bNewElse;\n\n        public NewConstraint() {\n            bNewConstraint.addActionListener(this::clickNewConstraint);\n\n            int start = editor.getSelectionModel().getSelectionStart();\n            bNewElse.setEnabled(start > 4 && editor.getDocument().getText(TextRange.create(start - 4, start)).equals(\"}?*/\"));\n            if (bNewElse.isEnabled())\n                bNewElse.addActionListener(this::clickNewElse);\n\n            SwingUtilities.invokeLater(() -> bNewConstraint.requestFocusInWindow());\n", "            if (bNewElse.isEnabled())\n                bNewElse.addActionListener(this::clickNewElse);\n\n            SwingUtilities.invokeLater(() -> bNewConstraint.requestFocusInWindow());\n\n            for (Component component : tabRoot.getComponents()) {\n                component.setFocusTraversalKeysEnabled(false);\n                component.addKeyListener(new KeyAdapter() {\n                    @Override\n                    public void keyPressed(KeyEvent e) {\n                        if (e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {", "                    public void keyPressed(KeyEvent e) {\n                        if (e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {\n                            if (bNewConstraint.isFocusOwner() && bNewElse.isEnabled())\n                                bNewElse.requestFocusInWindow();\n                            else if (bNewElse.isFocusOwner())\n                                bNewConstraint.requestFocusInWindow();\n                            e.consume();\n                        } else if (e.getKeyCode() == KeyEvent.VK_TAB) {\n                            if (bNewConstraint.isFocusOwner() || bNewElse.isFocusOwner()) {\n                                bVersions.requestFocusInWindow();\n                                e.consume();\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        private void clickNewConstraint(ActionEvent e) {\n            StackingPopupDispatcher.getInstance().closeActivePopup();\n            String selectionText = editor.getSelectionModel().getSelectedText();", "                            if (bNewConstraint.isFocusOwner() || bNewElse.isFocusOwner()) {\n                                bVersions.requestFocusInWindow();\n                                e.consume();\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        private void clickNewConstraint(ActionEvent e) {\n            StackingPopupDispatcher.getInstance().closeActivePopup();\n            String selectionText = editor.getSelectionModel().getSelectedText();", "            if (selectionText == null)\n                return;\n            WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                int selectionStart = editor.getSelectionModel().getSelectionStart(),\n                        selectionEnd = editor.getSelectionModel().getSelectionEnd(),\n                        startLine = editor.getDocument().getLineNumber(selectionStart), startLineStartOffset = editor.getDocument().getLineStartOffset(startLine), startLineEndOffset = editor.getDocument().getLineEndOffset(startLine),\n                        endLine = editor.getDocument().getLineNumber(selectionEnd), endLineStartOffset = editor.getDocument().getLineStartOffset(endLine), endLineEndOffset = editor.getDocument().getLineEndOffset(endLine);\n                editor.getSelectionModel().removeSelection();\n                if (editor.getDocument().getText(TextRange.create(selectionEnd, endLineEndOffset)).isBlank()) {\n                    String newLine = \"\\n\" + CodeStyleManager.getInstance(project).getLineIndent(editor.getDocument(), endLineEndOffset);\n                    editor.getDocument().insertString(selectionEnd, newLine);\n                    selectionEnd += newLine.length();\n                }\n                editor.getDocument().insertString(selectionEnd, \"/*?}?*/\");", "                if (editor.getDocument().getText(TextRange.create(selectionEnd, endLineEndOffset)).isBlank()) {\n                    String newLine = \"\\n\" + CodeStyleManager.getInstance(project).getLineIndent(editor.getDocument(), endLineEndOffset);\n                    editor.getDocument().insertString(selectionEnd, newLine);\n                    selectionEnd += newLine.length();\n                }\n                editor.getDocument().insertString(selectionEnd, \"/*?}?*/\");\n                if (editor.getDocument().getText(TextRange.create(startLineStartOffset, selectionStart)).isBlank()) {\n                    String newLine = CodeStyleManager.getInstance(project).getLineIndent(editor.getDocument(), startLineStartOffset) + \"\\n\";\n                    editor.getDocument().insertString(startLineStartOffset, newLine);\n                    selectionStart = startLineStartOffset + newLine.length() - 1;\n                }\n                editor.getDocument().insertString(selectionStart, \"/*?\" + stonecutter.currentActive() + \" {?*/\");\n                editor.getCaretModel().moveToOffset(selectionStart + 1);\n            });\n        }\n\n        private void clickNewElse(ActionEvent e) {\n            StackingPopupDispatcher.getInstance().closeActivePopup();\n            String selectionText = editor.getSelectionModel().getSelectedText();", "            if (selectionText == null)\n                return;\n            WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                int selectionStart = editor.getSelectionModel().getSelectionStart(),\n                        selectionEnd = editor.getSelectionModel().getSelectionEnd(),\n                        endLine = editor.getDocument().getLineNumber(selectionEnd), endLineStartOffset = editor.getDocument().getLineStartOffset(endLine), endLineEndOffset = editor.getDocument().getLineEndOffset(endLine);\n                editor.getSelectionModel().removeSelection();\n                if (editor.getDocument().getText(TextRange.create(selectionEnd, endLineEndOffset)).isBlank()) {\n                    String newLine = \"\\n\" + CodeStyleManager.getInstance(project).getLineIndent(editor.getDocument(), endLineEndOffset);\n                    editor.getDocument().insertString(selectionEnd, newLine);\n                    selectionEnd += newLine.length();\n                }\n                editor.getDocument().insertString(selectionEnd, \"/*?}?*/\");\n                editor.getDocument().insertString(selectionStart - 3, \" else {\");\n                editor.getCaretModel().moveToOffset(selectionStart - 6);\n            });\n        }\n    }\n", "    public class EditSyntax {\n        public JPanel tabRoot;\n        public JTextField tSyntax;\n\n        public EditSyntax() {\n            editor.getSelectionModel().removeSelection();\n\n            String syntax = editor.getDocument().getText(mainSyntaxRange);\n            syntax = syntax.substring(3, syntax.length() - 3).trim();\n            tSyntax.setText(syntax);\n            tSyntax.addActionListener(e -> {\n                WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                    String newSyntax = tSyntax.getText();\n                    newSyntax = newSyntax.isBlank() ? \"\" : \"/*?\" + newSyntax + \"?*/\";\n                    editor.getDocument().replaceString(mainSyntaxRange.getStartOffset(), mainSyntaxRange.getEndOffset(), newSyntax);\n                });\n                StackingPopupDispatcher.getInstance().closeActivePopup();\n            });\n\n            SwingUtilities.invokeLater(() -> tSyntax.requestFocusInWindow());\n\n            tSyntax.setFocusTraversalKeysEnabled(false);\n            tSyntax.addKeyListener(new KeyAdapter() {\n                @Override", "                public void keyPressed(KeyEvent e) {\n                    if (e.getKeyCode() == KeyEvent.VK_TAB) {\n                        if (tSyntax.hasFocus())\n                            bVersions.requestFocusInWindow();\n\n                        e.consume();\n                    }\n                }\n            });\n        }\n    }\n", "    public class Tokens extends AbstractTableModel {\n        public JPanel tabRoot;\n        public JBTable tTokens;\n        public JComboBox<String> cVersion;\n        public JButton bNewToken;\n        public JButton bCreateFlag;\n\n        public List<StonecutterSetup.TokenMapper.Token> loadedTokens;\n\n        public Tokens() {\n            bTokens.setEnabled(false);\n\n            tTokens.setModel(this);\n            tTokens.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n            tTokens.addMouseListener(new MouseAdapter() {\n                @Override", "                public void mousePressed(MouseEvent e) {\n                    int row = tTokens.rowAtPoint(e.getPoint());\n                    if (e.getClickCount() == 2 && row != -1) {\n                        try {\n                            //noinspection SuspiciousMethodCalls\n                            File tokensFile = new File(stonecutter.gradleProject().getChildProjects().get(cVersion.getSelectedItem()).getProjectDir(), \"tokens.gradle\");\n                            if (!tokensFile.exists())\n                                throw new Exception();\n\n                            FileEditorManager.getInstance(project).openFile(Objects.requireNonNull(VirtualFileManager.getInstance().findFileByNioPath(tokensFile.toPath())), true);\n                            Editor newEditor = Objects.requireNonNull(FileEditorManager.getInstance(project).getSelectedTextEditor());\n                            newEditor.getCaretModel().moveToOffset(newEditor.getDocument().getText().indexOf((String) tTokens.getModel().getValueAt(row, 0)));\n                        } catch (Exception ignored) { }\n                    }\n                }\n            });\n\n            CollectionComboBoxModel<String> versionModel = new CollectionComboBoxModel<>();", "            for (String version : stonecutter.versions())\n                versionModel.add(version);\n            versionModel.setSelectedItem(stonecutter.currentActive());\n            cVersion.setModel(versionModel);\n            cVersion.addActionListener(this::versionChanged);\n\n            tTokens.getSelectionModel().addListSelectionListener(e -> bCreateFlag.setEnabled(tTokens.getSelectedRow() != -1));\n\n            bCreateFlag.addActionListener(this::clickCreateFlag);\n            bNewToken.addActionListener(this::clickNewToken);\n\n            refreshTable();\n        }\n\n        private void clickCreateFlag(ActionEvent actionEvent) {\n            int tokenRow = tTokens.getSelectedRow();", "            if (tokenRow == -1)\n                return;\n\n            String token = (String) tTokens.getModel().getValueAt(tokenRow, 0);\n\n            JBPopupFactory.getInstance()\n                    .createPopupChooserBuilder(List.of(\"/*?$token enable \" + token + \"?*/\", \"/*?$token disable \" + token + \"?*/\"))\n                    .setTitle(\"Create Flag for Token: \" + token)\n                    .setSelectionMode(ListSelectionModel.SINGLE_SELECTION)\n                    .setItemChosenCallback(flag -> {\n                        WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                            editor.getDocument().replaceString(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd(), flag);\n                        });\n                    })\n                    .createPopup().showInBestPositionFor(editor);\n        }\n\n        private void clickNewToken(ActionEvent actionEvent) {\n            StackingPopupDispatcher.getInstance().closeActivePopup();\n\n            NewTokenDialog dialog = new NewTokenDialog(project, editor, stonecutter);", "            if (dialog.showAndGet())\n                WriteCommandAction.runWriteCommandAction(project, null, null, dialog::execute);\n        }\n\n        private void refreshTable() {\n            //noinspection SuspiciousMethodCalls\n            loadedTokens = new ArrayList<>(stonecutter.tokenCache().tokensByVersion.get(cVersion.getSelectedItem()).values());\n            tTokens.revalidate();\n            tTokens.repaint();\n        }\n\n        private void versionChanged(ActionEvent actionEvent) {\n            refreshTable();\n        }\n\n        @Override", "        public boolean isCellEditable(int rowIndex, int columnIndex) {\n            return false;\n        }\n\n        @Override\n        public String getColumnName(int column) {\n            return new String[] {\n                    \"Identifier\", \"Reader\", \"Writer\"\n            }[column];\n        }\n\n        @Override", "        public int getRowCount() {\n            return loadedTokens.size();\n        }\n\n        @Override\n        public int getColumnCount() {\n            return 3;\n        }\n\n        @Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            StonecutterSetup.TokenMapper.Token token = loadedTokens.get(rowIndex);\n            switch (columnIndex) {\n                case 0:\n                    return token.id;\n                case 1:\n                    return token.read.pattern();\n                case 2:\n                    return token.write;\n            }\n            return \"\";\n        }\n    }\n}\n", "        public Object getValueAt(int rowIndex, int columnIndex) {\n            StonecutterSetup.TokenMapper.Token token = loadedTokens.get(rowIndex);\n            switch (columnIndex) {\n                case 0:\n                    return token.id;\n                case 1:\n                    return token.read.pattern();\n                case 2:\n                    return token.write;\n            }\n            return \"\";\n        }\n    }\n}\n"]}
