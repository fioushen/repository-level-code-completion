{"filename": "src/test/java/org/lunifera/gpt/commands/minimalhint/WebSearchCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.minimalhint;\n\nimport org.lunifera.gpt.commands.impl.AbstractCommand;\n\npublic class WebSearchCommand extends AbstractCommand {\n\n\tpublic static final String NAME = \"WEB_SEARCH\";\n\tpublic static final String HINT = \"Ask the web\";\n\n\tpublic WebSearchCommand() {\n\t\tsuper(NAME, HINT);\n\t}\n\n}\n"]}
{"filename": "src/test/java/org/lunifera/gpt/commands/minimalhint/AskYourFriendsCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.minimalhint;\n\nimport org.lunifera.gpt.commands.impl.AbstractCommand;\n\npublic class AskYourFriendsCommand extends AbstractCommand {\n\n\tpublic static final String NAME = \"ASK_YOUR_FRIENDS\";\n\tpublic static final String HINT = \"Ask your friends\";\n\n\tpublic AskYourFriendsCommand() {\n\t\tsuper(NAME, HINT);\n\t}\n\n}\n"]}
{"filename": "src/test/java/org/lunifera/gpt/commands/minimalhint/AskYourDoctorCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.minimalhint;\n\nimport org.lunifera.gpt.commands.impl.AbstractCommand;\n\npublic class AskYourDoctorCommand extends AbstractCommand {\n\n\tpublic static final String NAME = \"ASK_YOUR_DOCTOR\";\n\tpublic static final String HINT = \"Ask your doctor\";\n\n\tpublic AskYourDoctorCommand() {\n\t\tsuper(NAME, HINT);\n\t}\n\n}\n"]}
{"filename": "src/test/java/org/lunifera/gpt/commands/minimalhint/CommandTest.java", "chunked_list": ["package org.lunifera.gpt.commands.minimalhint;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Test;\nimport org.lunifera.gpt.commands.api.ICommand;\nimport org.lunifera.gpt.commands.impl.CommandApi;", "import org.lunifera.gpt.commands.api.ICommand;\nimport org.lunifera.gpt.commands.impl.CommandApi;\n\npublic class CommandTest {\n\n\tprivate final String OPENAI_KEY = System.getProperty(\"OPENAI_KEY\");\n\n\t@Test\n\tpublic void testCommandExecution() {\n\t\tCommandApi api = new CommandApi(OPENAI_KEY);\n\n\t\t// Register commands at the API\n\t\t// AskYourBossCommand\n\t\t// AskYourFriendsCommand\n\t\t// AskYourDoctorCommand\n\t\t// WebSearchCommand\n\t\tapi.setCommands(this::createCommands);\n\n\t\t// Test different queries and their expected commands\n\n\t\t// Need more money --> Ask your boss\n\t\ttestCommand(api, \"Need more money\", AskYourBossCommand.NAME);\n\n\t\t// Info about quantum physics --> Ask the Web\n\t\ttestCommand(api, \"Info about quantum physics.\", WebSearchCommand.NAME);\n\n\t\t// I need some one to talk --> Ask your friends\n\t\ttestCommand(api, \"I need some one to talk.\", AskYourFriendsCommand.NAME);\n\n\t\t// My friend is physicist. I need some info about quantum physics --> Ask your\n\t\t// friends\n\t\ttestCommand(api, \"My friend is physicist. I need some info about quantum physics.\", AskYourFriendsCommand.NAME);\n\n\t\t// My head feels hot --> Ask your doctor\n\t\ttestCommand(api, \"My head feels hot\", AskYourDoctorCommand.NAME);\n\t}\n\n\tprivate void testCommand(CommandApi api, String query, String expectedCommandName) {\n\t\tICommand command = api.queryCommand(query);\n\t\tassertEquals(expectedCommandName, command.getName());\n\t}\n\n\t/**\n\t * Creates and returns a list of commands.\n\t */\n\tprivate List<ICommand> createCommands() {\n\t\tList<ICommand> commands = new ArrayList<>();\n\t\tcommands.add(new AskYourBossCommand());\n\t\tcommands.add(new AskYourFriendsCommand());\n\t\tcommands.add(new AskYourDoctorCommand());\n\t\tcommands.add(new WebSearchCommand());\n\t\treturn commands;\n\t}\n}\n", "\tpublic void testCommandExecution() {\n\t\tCommandApi api = new CommandApi(OPENAI_KEY);\n\n\t\t// Register commands at the API\n\t\t// AskYourBossCommand\n\t\t// AskYourFriendsCommand\n\t\t// AskYourDoctorCommand\n\t\t// WebSearchCommand\n\t\tapi.setCommands(this::createCommands);\n\n\t\t// Test different queries and their expected commands\n\n\t\t// Need more money --> Ask your boss\n\t\ttestCommand(api, \"Need more money\", AskYourBossCommand.NAME);\n\n\t\t// Info about quantum physics --> Ask the Web\n\t\ttestCommand(api, \"Info about quantum physics.\", WebSearchCommand.NAME);\n\n\t\t// I need some one to talk --> Ask your friends\n\t\ttestCommand(api, \"I need some one to talk.\", AskYourFriendsCommand.NAME);\n\n\t\t// My friend is physicist. I need some info about quantum physics --> Ask your\n\t\t// friends\n\t\ttestCommand(api, \"My friend is physicist. I need some info about quantum physics.\", AskYourFriendsCommand.NAME);\n\n\t\t// My head feels hot --> Ask your doctor\n\t\ttestCommand(api, \"My head feels hot\", AskYourDoctorCommand.NAME);\n\t}\n\n\tprivate void testCommand(CommandApi api, String query, String expectedCommandName) {\n\t\tICommand command = api.queryCommand(query);\n\t\tassertEquals(expectedCommandName, command.getName());\n\t}\n\n\t/**\n\t * Creates and returns a list of commands.\n\t */\n\tprivate List<ICommand> createCommands() {\n\t\tList<ICommand> commands = new ArrayList<>();\n\t\tcommands.add(new AskYourBossCommand());\n\t\tcommands.add(new AskYourFriendsCommand());\n\t\tcommands.add(new AskYourDoctorCommand());\n\t\tcommands.add(new WebSearchCommand());\n\t\treturn commands;\n\t}\n}\n"]}
{"filename": "src/test/java/org/lunifera/gpt/commands/minimalhint/AskYourBossCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.minimalhint;\n\nimport org.lunifera.gpt.commands.impl.AbstractCommand;\n\npublic class AskYourBossCommand extends AbstractCommand {\n\n\tpublic static final String NAME = \"ASK_YOUR_BOSS\";\n\tpublic static final String HINT = \"Ask your boss\";\n\n\tpublic AskYourBossCommand() {\n\t\tsuper(NAME, HINT);\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/ErrorCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\npublic class ErrorCommand implements ICommand {\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"__ERROR_COMMAND\";\n\t}\n\n\t@Override\n\tpublic String toPrompt(ICommandWrapper delimiter) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n}\n", "\tpublic String toPrompt(ICommandWrapper delimiter) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/ICommandWrapper.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\n/**\n * Describes how to wrap the command. By default, the command will be wrapped\n * following the format \"PREFIX%sPOSTFIX\". This is required, to ensure that\n * gpt-4 can recognize the raw command part properly.\n * <p>\n * Eg: WEB_SEARCH to {WEB_SEARCH}, if pre- and postfix is { and } and vies\n * versa.\n */\npublic interface ICommandWrapper {\n\n\tDefaultCommandWrapper DEFAULT = new DefaultCommandWrapper(\"{\", \"}\");\n\n\tString getPrefix();\n\n\tString getPostfix();\n\n\t/**\n\t * WEB_SEARCH to {WEB_SEARCH}, if pre- and postfix is { and }.\n\t * \n\t * @param command\n\t * @return\n\t */\n\tString wrapCommand(String command);\n\n\t/**\n\t * {WEB_SEARCH} to WEB_SEARCH, if pre- and postfix is { and }.\n\t * \n\t * @param wrappedCommand\n\t * @return\n\t */\n\tString unwrapCommand(String wrappedCommand);\n\n\t/**\n\t * Describes how to wrap the command. By default, the command will be wrapped\n\t * following the format \"{%s}\". This is required, to ensure that gpt-4 can\n\t * recognize the raw command part properly.\n\t * <p>\n\t * Eg: {SEARCH_WEB} - in cases you need more information.\n\t */", " * versa.\n */\npublic interface ICommandWrapper {\n\n\tDefaultCommandWrapper DEFAULT = new DefaultCommandWrapper(\"{\", \"}\");\n\n\tString getPrefix();\n\n\tString getPostfix();\n\n\t/**\n\t * WEB_SEARCH to {WEB_SEARCH}, if pre- and postfix is { and }.\n\t * \n\t * @param command\n\t * @return\n\t */\n\tString wrapCommand(String command);\n\n\t/**\n\t * {WEB_SEARCH} to WEB_SEARCH, if pre- and postfix is { and }.\n\t * \n\t * @param wrappedCommand\n\t * @return\n\t */\n\tString unwrapCommand(String wrappedCommand);\n\n\t/**\n\t * Describes how to wrap the command. By default, the command will be wrapped\n\t * following the format \"{%s}\". This is required, to ensure that gpt-4 can\n\t * recognize the raw command part properly.\n\t * <p>\n\t * Eg: {SEARCH_WEB} - in cases you need more information.\n\t */", "\tpublic static class DefaultCommandWrapper implements ICommandWrapper {\n\n\t\tprivate final String prefix;\n\t\tprivate final String postfix;\n\n\t\tpublic DefaultCommandWrapper(String preFix, String postFix) {\n\t\t\tsuper();\n\t\t\tthis.prefix = preFix;\n\t\t\tthis.postfix = postFix;\n\t\t}\n\n\t\t@Override", "\t\tpublic String getPrefix() {\n\t\t\treturn prefix;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPostfix() {\n\t\t\treturn postfix;\n\t\t}\n\n\t\t@Override\n\t\tpublic String wrapCommand(String command) {", "\t\tpublic String wrapCommand(String command) {\n\t\t\tif (prefix == null) {\n\t\t\t\treturn command;\n\t\t\t}\n\n\t\t\treturn prefix + command + postfix;\n\t\t}\n\n\t\t@Override\n\t\tpublic String unwrapCommand(String wrappedCommand) {\n\t\t\tif (prefix == null) {\n\t\t\t\treturn wrappedCommand;\n\t\t\t}\n\t\t\tString command = wrappedCommand.trim();\n", "\t\tpublic String unwrapCommand(String wrappedCommand) {\n\t\t\tif (prefix == null) {\n\t\t\t\treturn wrappedCommand;\n\t\t\t}\n\t\t\tString command = wrappedCommand.trim();\n\n\t\t\tif (wrappedCommand.startsWith(prefix)) {\n\t\t\t\tcommand = wrappedCommand.substring(1, wrappedCommand.length());\n\t\t\t}\n\n\t\t\tif (command.endsWith(postfix)) {\n\t\t\t\tcommand = command.substring(0, command.length() - 1);\n\t\t\t}\n\n\t\t\treturn command;\n\t\t}\n\n\t}\n}", "\t\t\tif (command.endsWith(postfix)) {\n\t\t\t\tcommand = command.substring(0, command.length() - 1);\n\t\t\t}\n\n\t\t\treturn command;\n\t\t}\n\n\t}\n}"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/IPrompter.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\nimport java.util.List;\nimport java.util.function.Supplier;\n\n/**\n * An interface with the responsibility to create prompts. And to convert the\n * received command string to a proper command.\n * \n * @author Florian", " * \n * @author Florian\n */\npublic interface IPrompter {\n\n\tpublic static final String PREFIX_TEMPLATE = \"\\\\{___PREFIX___}\";\n\tpublic static final String POSTFIX_TEMPLATE = \"\\\\{___POSTFIX___}\";\n\tpublic static final String COMMAND_LIST_TEMPLATE = \"\\\\{___COMMAND_LIST___}\";\n\n\t/**\n\t * Parts of this prompt are copied and/or modified from \"[Auto-GPT\"](https://github.com/Torantulino/Auto-GPT).\n\t *\n\t * {___PREFIX___}, {___POSTFIX___} and {___COMMAND_LIST___} need to be replaced\n\t * later.\n\t */", "\tpublic static final String DEFAULT_SYSTEM_PROMPT = //\n\t\t\t\"You are a CommandEngine. Your only task is to deliver the best matching {___PREFIX___}COMMAND{___POSTFIX___} from a list of COMMANDS as a response.\\n\" //\n\t\t\t\t\t+ \"\\n\" //\n\t\t\t\t\t+ \"To make your decision, you receive a text. Based on this text, you choose the best matching {___PREFIX___}COMMAND{___POSTFIX___} and respond with it.\\n\" //\n\t\t\t\t\t+ \"\\n\" //\n\t\t\t\t\t+ \"\\n\" //\n\t\t\t\t\t+ \"COMMANDS:\\n\" //\n\t\t\t\t\t+ \"{___COMMAND_LIST___}\" //\n\t\t\t\t\t+ \"\\n\" //\n\t\t\t\t\t+ \"You will never ask a follow-up question!\\n\" + \"\\n\" //\n\t\t\t\t\t+ \"And you MUST only answer the {COMMAND}!\"; //\n\n\t/**\n\t * Returns the DEFAULT_SYSTEM_PROMPT but replaces the pre- and postfix.\n\t * \n\t * @return\n\t */\n\tdefault String getDefaultSystemPromptTemplate(ICommandWrapper delimiter) {\n\t\treturn DEFAULT_SYSTEM_PROMPT.replaceAll(PREFIX_TEMPLATE, delimiter.getPrefix())//\n\t\t\t\t.replaceAll(POSTFIX_TEMPLATE, delimiter.getPostfix());\n\t}\n\n\t/**\n\t * Returns the \"system\" prompt to be used in the OpenAI Chat API.\n\t * \n\t * @param see {@link ICommandApi#setCommands(Supplier)}\n\t * \n\t * @return\n\t */\n\tString getSystemPrompt(Supplier<List<? extends ICommand>> commands);\n\n\t/**\n\t * Returns a proper command for the given commandString in respect to the system\n\t * prompt.\n\t * \n\t * @param commandString\n\t * @param commands\n\t * @return\n\t */\n\tICommand findCommand(String commandString, Supplier<List<? extends ICommand>> commands);\n\n\t/**\n\t * Sets the command delimiter. See {@link ICommandWrapper}.\n\t * \n\t * @param wrapper\n\t */\n\tvoid setCommandWrapper(ICommandWrapper wrapper);\n\n\t/**\n\t * Returns the command delimiter. See {@link ICommandWrapper}.\n\t * \n\t * @return\n\t */\n\tdefault ICommandWrapper getCommandWrapper() {\n\t\treturn ICommandWrapper.DEFAULT;\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/ICommand.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\n/**\n * A command is responsible, to provide the {@link IPrompter} with required\n * information, to integrate the commands properly into the prompt.\n * \n * @author Florian\n */\npublic interface ICommand {\n\n\t/**\n\t * Returns the name of the command. Eg. WEB_SEARCH.\n\t * @return\n\t */\n\tString getName();\n\t\n\t/**\n\t * Returns a String representation of this command to be used by the\n\t * {@link IPrompter}. It is important, to wrap the command inside the delimiter\n\t * pre- and postfix, if they are not blank.\n\t * <p>\n\t * Eg command WEB_SEARCH. Prefix = { and postfix = }. So the command needs to be\n\t * wrapped inside {WEB_SEARCH}. Pre- and postfix allow gpt to recognize the\n\t * command properly. They are also part of the general description in the in system prompt.\n\t * \n\t * @return\n\t */\n\tString toPrompt(ICommandWrapper wrapper);\n\n}\n", "public interface ICommand {\n\n\t/**\n\t * Returns the name of the command. Eg. WEB_SEARCH.\n\t * @return\n\t */\n\tString getName();\n\t\n\t/**\n\t * Returns a String representation of this command to be used by the\n\t * {@link IPrompter}. It is important, to wrap the command inside the delimiter\n\t * pre- and postfix, if they are not blank.\n\t * <p>\n\t * Eg command WEB_SEARCH. Prefix = { and postfix = }. So the command needs to be\n\t * wrapped inside {WEB_SEARCH}. Pre- and postfix allow gpt to recognize the\n\t * command properly. They are also part of the general description in the in system prompt.\n\t * \n\t * @return\n\t */\n\tString toPrompt(ICommandWrapper wrapper);\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/InvalidCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\npublic class InvalidCommand implements ICommand {\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"__INVALID_COMMAND\";\n\t}\n\n\t@Override\n\tpublic String toPrompt(ICommandWrapper delimiter) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n}\n", "\tpublic String toPrompt(ICommandWrapper delimiter) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/api/ICommandApi.java", "chunked_list": ["package org.lunifera.gpt.commands.api;\n\nimport java.util.List;\nimport java.util.function.Supplier;\n\n/**\n * The command api builds the prompts for a given input and sends them to\n * https://platform.openai.com/docs/api-reference/chat/create, to get a proper\n * command.\n * ", " * command.\n * \n * @author Florian\n *\n */\npublic interface ICommandApi {\n\n\t/**\n\t * Sets the commands supplier to the api. These {@link ICommand commands} will\n\t * be used by the {@link IPrompter} to create prompts.\n\t * \n\t * @param commands\n\t */\n\tvoid setCommands(Supplier<List<? extends ICommand>> commands);\n\n\t/**\n\t * Sets the {@link IPrompter prompter} to be used to api. The {@link IPrompter\n\t * prompter} is responsible to create the required prompts.\n\t * \n\t * @param prompter\n\t */\n\tvoid setPrompter(IPrompter prompter);\n\n\t/**\n\t * Tries to query a command for the given userInput.\n\t * \n\t * @param userInput\n\t * @return\n\t */\n\tICommand queryCommand(String userInput);\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/impl/AbstractCommand.java", "chunked_list": ["package org.lunifera.gpt.commands.impl;\n\nimport org.lunifera.gpt.commands.api.ICommand;\nimport org.lunifera.gpt.commands.api.ICommandWrapper;\n\npublic abstract class AbstractCommand implements ICommand {\n\n\tprotected final String name;\n\tprotected final String hints;\n\n\tpublic AbstractCommand(String name, String hints) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.hints = hints;\n\t}\n\n\t@Override", "\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toPrompt(ICommandWrapper wrapper) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(wrapper.wrapCommand(name));\n\n\t\tif (hints != null && !hints.isEmpty()) {\n\t\t\tsb.append(\" - \");\n\t\t\tsb.append(hints);\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\t@Override", "\t\tif (hints != null && !hints.isEmpty()) {\n\t\t\tsb.append(\" - \");\n\t\t\tsb.append(hints);\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"AbstractCommand [name=\" + name + \", hints=\" + hints + \"]\";\n\t}\n\n}\n", "\tpublic String toString() {\n\t\treturn \"AbstractCommand [name=\" + name + \", hints=\" + hints + \"]\";\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/impl/CommandApi.java", "chunked_list": ["/**\n * \n */\npackage org.lunifera.gpt.commands.impl;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.lunifera.gpt.commands.api.ICommand;", "\nimport org.lunifera.gpt.commands.api.ICommand;\nimport org.lunifera.gpt.commands.api.ICommandApi;\nimport org.lunifera.gpt.commands.api.IPrompter;\n\nimport com.theokanning.openai.completion.chat.ChatCompletionChoice;\nimport com.theokanning.openai.completion.chat.ChatCompletionRequest;\nimport com.theokanning.openai.completion.chat.ChatMessage;\nimport com.theokanning.openai.completion.chat.ChatMessageRole;\nimport com.theokanning.openai.service.OpenAiService;", "import com.theokanning.openai.completion.chat.ChatMessageRole;\nimport com.theokanning.openai.service.OpenAiService;\n\n/**\n * \n */\npublic class CommandApi implements ICommandApi {\n\n\tprivate static final String GPT_4 = \"gpt-4\";\n\n\tprivate final String OPENAI_KEY;\n\n\tprivate IPrompter prompter = new Prompter();\n\tprivate Supplier<List<? extends ICommand>> commands;\n\n\tpublic CommandApi(String OPENAI_KEY) {\n\t\tthis.OPENAI_KEY = OPENAI_KEY;\n\t}\n", "\tpublic void setPrompter(IPrompter prompter) {\n\t\tthis.prompter = prompter;\n\t}\n\n\t/**\n\t * Returns the {@link IPrompter}.\n\t * \n\t * @return\n\t */\n\tpublic IPrompter getPrompter() {\n\t\treturn prompter;\n\t}\n", "\tpublic IPrompter getPrompter() {\n\t\treturn prompter;\n\t}\n\n\tpublic void setCommands(Supplier<List<? extends ICommand>> commands) {\n\t\tthis.commands = commands;\n\t}\n\n\t/**\n\t * Returns the supplier of commands.\n\t * \n\t * @return\n\t */\n\tpublic Supplier<List<? extends ICommand>> getCommands() {\n\t\treturn commands;\n\t}\n\n\t@Override", "\tpublic ICommand queryCommand(String userInput) {\n\t\tList<ChatMessage> messages = createMessages(userInput);\n\n\t\tChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder().model(GPT_4).messages(messages)\n\t\t\t\t.n(1).temperature(0d).maxTokens(50).build();\n\n\t\tOpenAiService service = new OpenAiService(OPENAI_KEY);\n\t\tList<ChatCompletionChoice> choices = service.createChatCompletion(chatCompletionRequest).getChoices();\n\t\tString commandText = choices.get(0).getMessage().getContent();\n\n\t\treturn prompter.findCommand(commandText, commands);\n\t}\n\n\tprotected List<ChatMessage> createMessages(String userInput) {\n\t\tList<ChatMessage> messages = new ArrayList<>();\n\t\tChatMessage systemMessage = new ChatMessage(ChatMessageRole.SYSTEM.value(), prompter.getSystemPrompt(commands));\n\t\tmessages.add(systemMessage);\n\t\tChatMessage userMessage = new ChatMessage(ChatMessageRole.USER.value(), userInput);\n\t\tmessages.add(userMessage);\n\t\treturn messages;\n\t}\n\n}\n"]}
{"filename": "src/main/java/org/lunifera/gpt/commands/impl/Prompter.java", "chunked_list": ["package org.lunifera.gpt.commands.impl;\n\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.lunifera.gpt.commands.api.ErrorCommand;\nimport org.lunifera.gpt.commands.api.ICommand;\nimport org.lunifera.gpt.commands.api.ICommandWrapper;\nimport org.lunifera.gpt.commands.api.IPrompter;\nimport org.lunifera.gpt.commands.api.InvalidCommand;", "import org.lunifera.gpt.commands.api.IPrompter;\nimport org.lunifera.gpt.commands.api.InvalidCommand;\n\npublic class Prompter implements IPrompter {\n\n\tprivate ICommandWrapper commandWrapper = ICommandWrapper.DEFAULT;\n\n\t@Override\n\tpublic String getSystemPrompt(Supplier<List<? extends ICommand>> commands) {\n\t\tString template = getDefaultSystemPromptTemplate(commandWrapper);\n\n\t\tString prompt = template.replaceFirst(COMMAND_LIST_TEMPLATE, createCommdansPromptSection(commands));\n\t\treturn prompt;\n\t}\n\n\t@Override", "\tpublic String getSystemPrompt(Supplier<List<? extends ICommand>> commands) {\n\t\tString template = getDefaultSystemPromptTemplate(commandWrapper);\n\n\t\tString prompt = template.replaceFirst(COMMAND_LIST_TEMPLATE, createCommdansPromptSection(commands));\n\t\treturn prompt;\n\t}\n\n\t@Override\n\tpublic void setCommandWrapper(ICommandWrapper commandWrapper) {\n\t\tthis.commandWrapper = commandWrapper;\n\t}\n\n\t/**\n\t * Returns the commands text to be included in the prompt.\n\t * \n\t * @param commands\n\t * @return\n\t */\n\tprivate String createCommdansPromptSection(Supplier<List<? extends ICommand>> commands) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tcommands.get().forEach(c -> {\n\t\t\tsb.append(\"- \");\n\t\t\tsb.append(c.toPrompt(ICommandWrapper.DEFAULT));\n\t\t\tsb.append(\"\\n\");\n\t\t});\n\t\treturn sb.toString();\n\t}\n\n\t@Override", "\tpublic void setCommandWrapper(ICommandWrapper commandWrapper) {\n\t\tthis.commandWrapper = commandWrapper;\n\t}\n\n\t/**\n\t * Returns the commands text to be included in the prompt.\n\t * \n\t * @param commands\n\t * @return\n\t */\n\tprivate String createCommdansPromptSection(Supplier<List<? extends ICommand>> commands) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tcommands.get().forEach(c -> {\n\t\t\tsb.append(\"- \");\n\t\t\tsb.append(c.toPrompt(ICommandWrapper.DEFAULT));\n\t\t\tsb.append(\"\\n\");\n\t\t});\n\t\treturn sb.toString();\n\t}\n\n\t@Override", "\tpublic ICommand findCommand(String commandString, Supplier<List<? extends ICommand>> commands) {\n\t\tString unwrappedCommandString = unwrapRawCommand(commandString);\n\t\tif (unwrappedCommandString.isEmpty()) {\n\t\t\treturn createErrorCommand(\"No response\");\n\t\t}\n\n\t\tICommand command = commands.get().stream().filter(c -> c.getName().equals(unwrappedCommandString)).findFirst()\n\t\t\t\t.orElse(null);\n\t\tif (command == null) {\n\t\t\tcommand = createInvalidCommand();\n\t\t}\n\n\t\treturn command;\n\t}\n\n\tprotected ICommand createErrorCommand(String text) {\n\t\treturn new ErrorCommand();\n\t}\n\n\tprotected InvalidCommand createInvalidCommand() {\n\t\treturn new InvalidCommand();\n\t}\n\n\t/**\n\t * GPT will return the command in the form {Prefix}COMMAND{POSTFIX}.\n\t * <p>\n\t * Eg. {WEB_SEARCH}. So we will remove the pre- and postfix here to get the raw\n\t * command WEB_SEARCH.\n\t * \n\t * @param commandString\n\t * @return\n\t */\n\tprotected String unwrapRawCommand(String commandString) {\n\t\treturn commandWrapper.unwrapCommand(commandString);\n\t}\n\n}\n", "\t\tif (command == null) {\n\t\t\tcommand = createInvalidCommand();\n\t\t}\n\n\t\treturn command;\n\t}\n\n\tprotected ICommand createErrorCommand(String text) {\n\t\treturn new ErrorCommand();\n\t}\n\n\tprotected InvalidCommand createInvalidCommand() {\n\t\treturn new InvalidCommand();\n\t}\n\n\t/**\n\t * GPT will return the command in the form {Prefix}COMMAND{POSTFIX}.\n\t * <p>\n\t * Eg. {WEB_SEARCH}. So we will remove the pre- and postfix here to get the raw\n\t * command WEB_SEARCH.\n\t * \n\t * @param commandString\n\t * @return\n\t */\n\tprotected String unwrapRawCommand(String commandString) {\n\t\treturn commandWrapper.unwrapCommand(commandString);\n\t}\n\n}\n"]}
