{"filename": "dagger-java-sdk/src/test/java/org/chelonix/dagger/client/ClientIT.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.chelonix.dagger.client.Container.ExecArguments;\nimport org.chelonix.dagger.client.Client.ContainerArguments;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;", "\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.assertj.core.api.Assertions.*;\n\npublic class ClientIT {\n\n    @BeforeAll\n    public static void setLoggerConfig() {\n        System.setProperty(\"org.slf4j.simpleLogger.log.org.chelonix.dagger\", \"debug\");\n        System.setProperty(\"org.slf4j.simpleLogger.showShortLogName\", \"true\");\n    }\n\n    @Test", "    public void testDirectory() throws Exception {\n        try (Client client = Dagger.connect()) {\n            Directory dir = client.directory();\n            String content = dir\n                    .withNewFile(\"/hello.txt\", \"world\")\n                    .file(\"/hello.txt\")\n                    .contents();\n            assertEquals(\"world\", content);\n        }\n    }\n\n    @Test", "    public void testGit() throws Exception {\n        try (Client client = Dagger.connect()) {\n            Directory tree = client.git(\"github.com/dagger/dagger\")\n                    .branch(\"main\")\n                    .tree();\n            List<String> files = tree.entries();\n            assertTrue(files.contains(\"README.md\"));\n\n            File readmeFile = tree.file(\"README.md\");\n\n            String readme = readmeFile.contents();\n            assertFalse(readme.isEmpty());\n            assertTrue(readme.contains(\"Dagger\"));\n\n            FileID readmeID = readmeFile.id();\n            String otherReadme = client.file(readmeID).contents();\n            assertEquals(readme, otherReadme);\n        }\n    }\n\n    @Test", "    public void testContainer() throws Exception {\n        try (Client client = Dagger.connect()) {\n            Container alpine = client.container().from(\"alpine:3.16.2\");\n            String contents = alpine.fs().file(\"/etc/alpine-release\").contents();\n            assertEquals(\"3.16.2\\n\", contents);\n\n            String stdout = alpine.exec(new ExecArguments()\n                        .withArgs(List.of(\"cat\", \"/etc/alpine-release\")))\n                    .stdout();\n            assertEquals(\"3.16.2\\n\", stdout);\n\n            // Ensure we can grab the container ID back and re-run the same query\n            ContainerID id = alpine.id();\n            contents = client.container(new ContainerArguments().withId(id))\n                    .fs()\n                    .file(\"/etc/alpine-release\")\n                    .contents();\n            assertEquals(\"3.16.2\\n\", contents);\n        }\n    }\n\n    @Test", "    public void testError() throws Exception {\n        try (Client client = Dagger.connect()) {\n            try {\n                client.container().from(\"fake.invalid:latest\").id();\n            } catch (DaggerQueryException dqe) {\n                assertThat(dqe.getErrors()).hasSizeGreaterThan(0);\n            }\n\n            try {\n                client.container().from(\"alpine:3.16.2\").withExec(List.of(\"false\")).sync();\n            } catch (DaggerQueryException dqe) {\n                assertThat(dqe.getErrors()).hasSizeGreaterThan(0);\n                assertThat(dqe.getErrors()[0].getExtensions()).containsEntry(\"_type\", \"EXEC_ERROR\");\n            }\n        }\n    }\n\n    @Test", "            try {\n                client.container().from(\"alpine:3.16.2\").withExec(List.of(\"false\")).sync();\n            } catch (DaggerQueryException dqe) {\n                assertThat(dqe.getErrors()).hasSizeGreaterThan(0);\n                assertThat(dqe.getErrors()[0].getExtensions()).containsEntry(\"_type\", \"EXEC_ERROR\");\n            }\n        }\n    }\n\n    @Test\n    public void testList() throws Exception {\n        try (Client client = Dagger.connect()) {\n            List<EnvVariable> envs = client.container().from(\"alpine:3.16.2\")\n                    .withEnvVariable(\"FOO\", \"BAR\")\n                    .withEnvVariable(\"BAR\", \"BAZ\")\n                    .envVariables();\n\n            assertThat(envs).hasSizeGreaterThanOrEqualTo(3);\n\n            String envName = envs.get(1).name();\n            String envValue = envs.get(1).value();\n            assertThat(envName).isEqualTo(\"FOO\");\n            assertThat(envValue).isEqualTo(\"BAR\");\n\n            envName = envs.get(2).name();\n            envValue = envs.get(2).value();\n            assertThat(envName).isEqualTo(\"BAR\");\n            assertThat(envValue).isEqualTo(\"BAZ\");\n        }\n    }\n}\n", "    public void testList() throws Exception {\n        try (Client client = Dagger.connect()) {\n            List<EnvVariable> envs = client.container().from(\"alpine:3.16.2\")\n                    .withEnvVariable(\"FOO\", \"BAR\")\n                    .withEnvVariable(\"BAR\", \"BAZ\")\n                    .envVariables();\n\n            assertThat(envs).hasSizeGreaterThanOrEqualTo(3);\n\n            String envName = envs.get(1).name();\n            String envValue = envs.get(1).value();\n            assertThat(envName).isEqualTo(\"FOO\");\n            assertThat(envValue).isEqualTo(\"BAR\");\n\n            envName = envs.get(2).name();\n            envValue = envs.get(2).value();\n            assertThat(envName).isEqualTo(\"BAR\");\n            assertThat(envValue).isEqualTo(\"BAZ\");\n        }\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/test/java/org/chelonix/dagger/client/QueryBuilderTest.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport io.smallrye.graphql.client.core.Document;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.mock;", "import static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.mock;\n\npublic class QueryBuilderTest {\n\n    @Test\n    public void query_should_be_marshalled() throws Exception {\n        DynamicGraphQLClient client = mock(DynamicGraphQLClient.class);\n        QueryBuilder qb = new QueryBuilder(client);\n        qb = qb.chain(\"core\")\n                .chain(\"image\", Arguments.newBuilder().add(\"ref\", \"alpine\").build())\n                .chain(\"file\", Arguments.newBuilder().add(\"path\", \"/etc/alpine-release\").build());\n        Document query = qb.buildDocument();\n        assertThat(query.build()).isEqualTo(\"query {core{image(ref:\\\"alpine\\\"){file(path:\\\"/etc/alpine-release\\\")}}}\");\n    }\n\n    @Test", "    public void query_for_list_should_be_marshalled() throws Exception {\n        DynamicGraphQLClient client = mock(DynamicGraphQLClient.class);\n        QueryBuilder qb = new QueryBuilder(client);\n        qb = qb.chain(\"core\")\n                .chain(\"env\", List.of(\"name\", \"value\"));\n        String query = qb.buildDocument().build();\n        assertThat(query).isEqualTo(\"query {core{env{name value}}}\");\n    }\n\n    @Test\n    public void chaining_with_leave_is_final() throws Exception {\n        DynamicGraphQLClient client = mock(DynamicGraphQLClient.class);\n        QueryBuilder qb = new QueryBuilder(client);", "    public void chaining_with_leave_is_final() throws Exception {\n        DynamicGraphQLClient client = mock(DynamicGraphQLClient.class);\n        QueryBuilder qb = new QueryBuilder(client);\n        try {\n            qb = qb.chain(\"core\")\n                    .chain(\"env\", List.of(\"name\", \"value\"))\n                    .chain(\"failure\");\n        } catch (IllegalStateException iae) {\n            assertThat(iae.getMessage()).isEqualTo(\"A new field cannot be chained\");\n        }\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/test/java/org/chelonix/dagger/client/ArgumentsTest.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport io.smallrye.graphql.client.core.Argument;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.assertj.core.api.Assertions.assertThat;", "\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.*;\n\npublic class ArgumentsTest {\n\n    public static class SimpleId extends Scalar<String> {\n        public SimpleId(String value) {\n            super(value);\n        }\n    }\n", "    public static enum SimpleEnum {\n        ENUM1, ENUM2, ENUM3\n    }\n\n    @Test\n    public void testNullArguments() throws Exception {\n        List<Argument> args = Arguments.newBuilder().add(\"foo\", (String) null).build().toList();\n        assertThat(args.get(0).build()).isEqualTo(\"foo:null\");\n    }\n\n    @Test", "    public void testEmptyArguments() throws Exception {\n        List<Argument> args = Arguments.noArgs().toList();\n        assertThat(args).isEmpty();\n    }\n\n    @Test\n    public void testStringArgument() throws Exception {\n        List<Argument> args = Arguments.newBuilder().add(\"foo\", \"bar\").build().toList();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"foo:\\\"bar\\\"\");\n    }\n\n    @Test", "    public void testIntArgument() throws Exception {\n        List<Argument> args = Arguments.newBuilder().add(\"foo\", 1234).build().toList();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"foo:1234\");\n    }\n\n    @Test\n    public void testScalarArgument() throws Exception {\n        List<Argument> args = Arguments.newBuilder().add(\"foo\", new SimpleId(\"bar\")).build().toList();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"foo:\\\"bar\\\"\");\n    }\n\n    @Test", "    public void testEnumArgument() throws Exception {\n        List<Argument> args = Arguments.newBuilder().add(\"foo\", SimpleEnum.ENUM2).build().toList();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"foo:\\\"ENUM2\\\"\");\n    }\n\n    @Test\n    public void testIdArgument() throws Exception {\n        IdProvider<SimpleId> idProvider = mock(IdProvider.class);\n        SimpleId id = new SimpleId(\"baz\");\n        when(idProvider.id()).thenReturn(id);\n        List<Argument> args = Arguments.newBuilder().add(\"bar\", idProvider).build().toList();\n        verify(idProvider).id();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"bar:\\\"baz\\\"\");\n    }\n\n    @Test", "    public void testInputValueArgument() throws Exception {\n        InputValue inputValue = mock(InputValue.class);\n        Map map = new HashMap<String, Object>() {{\n            put(\"foo\", \"bar\");\n            put(\"bar\", 1234);\n            put(\"baz\", true);\n        }};\n        when(inputValue.toMap()).thenReturn(map);\n        List<Argument> args = Arguments.newBuilder().add(\"obj\", inputValue).build().toList();\n        verify(inputValue).toMap();\n        assertThat(args).hasSize(1);\n        assertThat(args.get(0).build()).isEqualTo(\"obj:{bar:1234, foo:\\\"bar\\\", baz:true}\");\n    }\n}\n\n"]}
{"filename": "dagger-java-sdk/src/test/java/org/chelonix/dagger/client/engineconn/ConnectionTest.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport uk.org.webcompere.systemstubs.environment.EnvironmentVariables;\nimport uk.org.webcompere.systemstubs.jupiter.SystemStub;\nimport uk.org.webcompere.systemstubs.jupiter.SystemStubsExtension;\n\nimport java.io.IOException;\nimport java.util.Optional;", "import java.io.IOException;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(SystemStubsExtension.class)\npublic class ConnectionTest {\n    @SystemStub\n    private EnvironmentVariables environmentVariables;\n\n    @Test", "public class ConnectionTest {\n    @SystemStub\n    private EnvironmentVariables environmentVariables;\n\n    @Test\n    public void should_return_from_env_connection() throws Exception {\n        environmentVariables.set(\"DAGGER_SESSION_PORT\", \"52037\");\n        environmentVariables.set(\"DAGGER_SESSION_TOKEN\", \"189de95f-07df-415d-b42a-7851c731359d\");\n        Optional<Connection> conn = Connection.fromEnv();\n        assertThat(conn).isPresent();\n    }\n\n    @Test", "    public void should_return_empty_connection_when_env_not_set() throws Exception {\n        Optional<Connection> conn;\n\n        environmentVariables.set(\"DAGGER_SESSION_PORT\", null);\n        environmentVariables.set(\"DAGGER_SESSION_TOKEN\", null);\n        conn = Connection.fromEnv();\n        assertThat(conn).isEmpty();\n\n        environmentVariables.set(\"DAGGER_SESSION_PORT\", \"52037\");\n        environmentVariables.set(\"DAGGER_SESSION_TOKEN\", null);\n        conn = Connection.fromEnv();\n        assertThat(conn).isEmpty();\n\n        environmentVariables.set(\"DAGGER_SESSION_PORT\", null);\n        environmentVariables.set(\"DAGGER_SESSION_TOKEN\", \"189de95f-07df-415d-b42a-7851c731359d\");\n        conn = Connection.fromEnv();\n        assertThat(conn).isEmpty();\n    }\n\n    @Test", "    public void should_return_connection_from_dynamic_provisioning() throws Exception {\n        CLIRunner runner = mock(CLIRunner.class);\n        when(runner.getConnectionParams()).thenReturn(new ConnectParams(57535, \"6fb6d80b-5e7a-42f7-913c-31a6e50c140d\"));\n        Connection conn = Connection.fromCLI(runner);\n        verify(runner, times(1)).getConnectionParams();\n        conn.close();\n        verify(runner, times(1)).shutdown();\n    }\n\n    @Test\n    public void should_fail_when_clirunner_fails() throws Exception {\n        CLIRunner runner = mock(CLIRunner.class);\n        when(runner.getConnectionParams()).thenThrow(new IOException(\"FAILED\"));\n        assertThatThrownBy(() -> Connection.fromCLI(runner)).isInstanceOf(IOException.class).hasMessage(\"FAILED\");\n    }\n}\n", "    public void should_fail_when_clirunner_fails() throws Exception {\n        CLIRunner runner = mock(CLIRunner.class);\n        when(runner.getConnectionParams()).thenThrow(new IOException(\"FAILED\"));\n        assertThatThrownBy(() -> Connection.fromCLI(runner)).isInstanceOf(IOException.class).hasMessage(\"FAILED\");\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/QueryBuilder.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport com.jayway.jsonpath.JsonPath;\nimport io.smallrye.graphql.client.GraphQLError;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.core.Document;\nimport io.smallrye.graphql.client.core.Field;\nimport io.smallrye.graphql.client.core.FieldOrFragment;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\nimport jakarta.json.JsonArray;", "import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\nimport jakarta.json.JsonArray;\nimport jakarta.json.JsonObject;\nimport jakarta.json.bind.Jsonb;\nimport jakarta.json.bind.JsonbBuilder;\nimport jakarta.json.bind.JsonbConfig;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport static io.smallrye.graphql.client.core.Document.document;\nimport static io.smallrye.graphql.client.core.Field.field;", "import static io.smallrye.graphql.client.core.Document.document;\nimport static io.smallrye.graphql.client.core.Field.field;\nimport static io.smallrye.graphql.client.core.Operation.operation;\n\nclass QueryBuilder {\n\n    static final Logger LOG = LoggerFactory.getLogger(QueryBuilder.class);\n\n    private final DynamicGraphQLClient client;\n    private final Deque<QueryPart> parts;", "    private final DynamicGraphQLClient client;\n    private final Deque<QueryPart> parts;\n    private final List<QueryPart> leaves;\n\n    QueryBuilder(DynamicGraphQLClient client) {\n        this(client, new LinkedList<>());\n    }\n\n    private QueryBuilder(DynamicGraphQLClient client, Deque<QueryPart> parts) {\n        this(client, parts, new ArrayList<>());", "    private QueryBuilder(DynamicGraphQLClient client, Deque<QueryPart> parts) {\n        this(client, parts, new ArrayList<>());\n    }\n\n    private QueryBuilder(DynamicGraphQLClient client, Deque<QueryPart> parts, List<String> finalFields) {\n        this.client = client;\n        this.parts = parts;\n        this.leaves = finalFields.stream().map(QueryPart::new).toList();\n    }\n", "    }\n\n    QueryBuilder chain(String operation) {\n        return chain(operation, Arguments.noArgs());\n    }\n\n    QueryBuilder chain(String operation, Arguments arguments) {\n        if (leaves != null && !leaves.isEmpty()) {\n            throw new IllegalStateException(\"A new field cannot be chained\");\n        }\n        Deque<QueryPart> list = new LinkedList<>();\n        list.addAll(this.parts);\n        list.push(new QueryPart(operation, arguments));\n        return new QueryBuilder(client, list);\n    }\n\n    QueryBuilder chain(String operation, List<String> leaves) {", "        if (!this.leaves.isEmpty()) {\n            throw new IllegalStateException(\"A new field cannot be chained\");\n        }\n        Deque<QueryPart> list = new LinkedList<>();\n        list.addAll(this.parts);\n        list.push(new QueryPart(operation));\n        return new QueryBuilder(client, list, leaves);\n    }\n\n    QueryBuilder chain(List<String> leaves) {\n        if (!this.leaves.isEmpty()) {\n            throw new IllegalStateException(\"A new field cannot be chained\");\n        }\n        Deque<QueryPart> list = new LinkedList<>();\n        list.addAll(this.parts);\n        return new QueryBuilder(client, list, leaves);\n    }\n\n    private void handleErrors(Response response) throws DaggerQueryException {", "        if (!this.leaves.isEmpty()) {\n            throw new IllegalStateException(\"A new field cannot be chained\");\n        }\n        Deque<QueryPart> list = new LinkedList<>();\n        list.addAll(this.parts);\n        return new QueryBuilder(client, list, leaves);\n    }\n\n    private void handleErrors(Response response) throws DaggerQueryException {\n        if (! response.hasError()) {\n            return;\n        }\n        LOG.debug(String.format(\"Query execution failed: %s\",response.getErrors().stream()\n                .map(GraphQLError::toString)\n                .collect(Collectors.joining(\", \"))));", "        if (! response.hasError()) {\n            return;\n        }\n        LOG.debug(String.format(\"Query execution failed: %s\",response.getErrors().stream()\n                .map(GraphQLError::toString)\n                .collect(Collectors.joining(\", \"))));\n        if (response.getErrors().isEmpty()) {\n            throw new DaggerQueryException();\n        }\n        // GraphQLError error = response.getErrors().get(0);\n        // error.getExtensions().get(\"_type\");\n        throw new DaggerQueryException(response.getErrors().toArray(new GraphQLError[0]));\n    }\n\n    Document buildDocument() throws ExecutionException, InterruptedException, DaggerQueryException {\n        Field leafField = parts.pop().toField();\n        leafField.setFields(leaves.stream().<FieldOrFragment>map(qp -> field(qp.getOperation())).toList());\n        List<Field> fields = new ArrayList<>();", "        for (QueryPart qp: parts) {\n            fields.add(qp.toField());\n        }\n        Field operation = fields.stream().reduce(leafField, (acc, field) -> {\n            field.setFields(List.of(acc));\n            return field;\n        });\n        Document query = document(operation(operation));\n        return query;\n    }\n\n    Response executeQuery(Document document) throws ExecutionException, InterruptedException, DaggerQueryException {\n        LOG.debug(\"Executing query: {}\", document.build());\n        Response response = client.executeSync(document);\n        handleErrors(response);\n        LOG.debug(\"Received response: {}\", response.getData());\n        return response;\n    }\n\n    /**\n     * Execute a query and discord the response.\n     *\n     * @throws ExecutionException\n     * @throws InterruptedException\n     * @throws DaggerQueryException\n     */\n    void executeQuery() throws ExecutionException, InterruptedException, DaggerQueryException {\n        Document query = buildDocument();\n        executeQuery(query);\n    }\n\n    <T> T executeQuery(Class<T> klass) throws ExecutionException, InterruptedException, DaggerQueryException {\n        String path = StreamSupport.stream(Spliterators.spliteratorUnknownSize(parts.descendingIterator(), 0), false)\n                .map(QueryPart::getOperation)\n                .collect(Collectors.joining(\".\"));\n        Document query = buildDocument();\n        Response response = executeQuery(query);", "        if (Scalar.class.isAssignableFrom(klass)) {\n            // FIXME scalar could be other types than String in the future\n            String value = JsonPath.parse(response.getData().toString()).read(path, String.class);\n            try {\n                return klass.getDeclaredConstructor(String.class).newInstance(value);\n            } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException nsme) {\n                // FIXME - This may not happen\n                throw new RuntimeException(nsme);\n            }\n        } else {\n            return JsonPath.parse(response.getData().toString()).read(path, klass);\n        }\n    }\n\n    <T> List<T> executeListQuery(Class<T> klass) throws ExecutionException, InterruptedException, DaggerQueryException {\n        List<String> pathElts = StreamSupport.stream(Spliterators.spliteratorUnknownSize(parts.descendingIterator(), 0), false)\n                .map(QueryPart::getOperation)\n                .toList();\n        Document document = buildDocument();\n        Response response = executeQuery(document);\n        JsonObject obj = response.getData();", "        for (int i = 0; i < pathElts.size() - 1; i++) {\n            obj = obj.getJsonObject(pathElts.get(i));\n        }\n        JsonArray array = obj.getJsonArray(pathElts.get(pathElts.size() - 1));\n        JsonbConfig config = new JsonbConfig().withPropertyVisibilityStrategy(new PrivateVisibilityStrategy());\n        Jsonb jsonb = JsonbBuilder.newBuilder().withConfig(config).build();\n        List<T> rv = jsonb.fromJson(array.toString(), TypeUtils.parameterize(List.class, klass));\n        return rv;\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/Dagger.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport org.chelonix.dagger.client.engineconn.Connection;\n\nimport java.io.IOException;\n\npublic class Dagger {\n\n    /**\n     * Opens connection with a Dagger engine.\n     * @return The Dagger API entrypoint\n     * @throws IOException\n     */", "    public static Client connect() throws IOException {\n        return connect(System.getProperty(\"user.dir\"));\n    }\n\n    /**\n     * Opens connection with a Dagger engine.\n     * @param workingDir the host working directory\n     * @return The Dagger API entrypoint\n     * @throws IOException\n     */\n    public static Client connect(String workingDir) throws IOException {\n        return new Client(Connection.get(workingDir));\n    }\n}\n", "    public static Client connect(String workingDir) throws IOException {\n        return new Client(Connection.get(workingDir));\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/Scalar.java", "chunked_list": ["package org.chelonix.dagger.client;\n\npublic class Scalar<T> {\n\n    private final T value;\n\n    public Scalar(T value) {\n        this.value = value;\n    }\n\n    T convert() {\n        return value;\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/InputValue.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport java.util.Map;\n\ninterface InputValue {\n    Map<String, Object> toMap();\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/IdProvider.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport java.util.concurrent.ExecutionException;\n\npublic interface IdProvider<S> {\n\n    S id() throws ExecutionException, InterruptedException, DaggerQueryException;\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/PrivateVisibilityStrategy.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport jakarta.json.bind.config.PropertyVisibilityStrategy;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nclass PrivateVisibilityStrategy implements PropertyVisibilityStrategy {\n\n    @Override\n    public boolean isVisible(Field field) {\n        return true;\n    }\n\n    @Override", "\n    @Override\n    public boolean isVisible(Field field) {\n        return true;\n    }\n\n    @Override\n    public boolean isVisible(Method method) {\n        return true;\n    }\n\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/Arguments.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport io.smallrye.graphql.client.core.Argument;\nimport io.smallrye.graphql.client.core.InputObjectField;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;", "import java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\nimport static io.smallrye.graphql.client.core.Argument.arg;\nimport static io.smallrye.graphql.client.core.InputObject.inputObject;\nimport static io.smallrye.graphql.client.core.InputObjectField.prop;\n\npublic class Arguments {\n\n    private Map<String, Object> args;\n\n    static Arguments noArgs() {\n        return new Arguments();\n    }\n", "    public static Builder newBuilder() {\n        return new Arguments().new Builder();\n    }\n\n    private Arguments() {\n        this(new HashMap<>());\n    }\n\n    private Arguments(Map<String, Object> args) {\n        this.args = args;\n    }\n\n    private Builder builder() {\n        return new Builder();\n    }\n\n    Arguments merge(Arguments other) {\n        HashMap<String, Object> newMap = new HashMap<>(this.args);\n        newMap.putAll(other.args);\n        return new Arguments(newMap);\n    }\n\n    List<Argument> toList() throws ExecutionException, InterruptedException, DaggerQueryException {\n        List<Argument> argList = new ArrayList<>();", "        for (Map.Entry<String, Object> entry: args.entrySet()) {\n            argList.add(arg(entry.getKey(), toArgumentValue(entry.getValue())));\n        }\n        return argList;\n    }\n\n    private Object toArgumentValue(Object value) throws ExecutionException, InterruptedException, DaggerQueryException {\n        if (value == null) {\n            return null;\n        } else if (value instanceof Scalar<?>) {\n            return ((Scalar<?>) value).convert();", "        } else if (value instanceof Scalar<?>) {\n            return ((Scalar<?>) value).convert();\n        } else if (value instanceof IdProvider<?>) {\n            Object id = ((IdProvider<?>) value).id();\n            if (id instanceof Scalar<?>) {\n                return ((Scalar<?>) id).convert();\n            } else {\n                return id;\n            }\n        } else if (value instanceof InputValue) {\n            return inputObject(((InputValue) value).toMap().entrySet().stream().map(e -> prop(e.getKey(), e.getValue())).toArray(InputObjectField[]::new));", "        } else if (value instanceof InputValue) {\n            return inputObject(((InputValue) value).toMap().entrySet().stream().map(e -> prop(e.getKey(), e.getValue())).toArray(InputObjectField[]::new));\n        } else if (value instanceof String || value instanceof Integer || value instanceof Long || value instanceof Boolean ) {\n            return value;\n        } else if (value instanceof List<?>) {\n            List list = new ArrayList();\n            for (Object o: (List)value) {\n                list.add(toArgumentValue(o));\n            }\n            return list;\n        } else if (value instanceof Enum<?>) {\n            return ((Enum<?>) value).toString();\n        } else {\n            throw new IllegalStateException(\n                    String.format(\n                            \"Argument is not an authorized argument type. Found type is %s\",\n                            value.getClass()));\n        }\n    }\n", "        } else if (value instanceof Enum<?>) {\n            return ((Enum<?>) value).toString();\n        } else {\n            throw new IllegalStateException(\n                    String.format(\n                            \"Argument is not an authorized argument type. Found type is %s\",\n                            value.getClass()));\n        }\n    }\n\n    public class Builder {\n        private Builder() {\n        }\n", "    public class Builder {\n        private Builder() {\n        }\n\n        public Builder add(String name, String value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public Builder add(String name, String... value) {\n            args.put(name, value);\n            return this;\n        }\n", "        public Builder add(String name, String... value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public Builder add(String name, boolean value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public Builder add(String name, int value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T> Builder add(String name, Scalar<T> value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T extends Scalar<?>> Builder add(String name, IdProvider<T> value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T> Builder add(String name, List<T> value) {\n            args.put(name, value);\n            return this;\n        }\n", "        public Builder add(String name, int value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T> Builder add(String name, Scalar<T> value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T extends Scalar<?>> Builder add(String name, IdProvider<T> value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public <T> Builder add(String name, List<T> value) {\n            args.put(name, value);\n            return this;\n        }\n", "        public Builder add(String name, InputValue value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public Builder add(String name, Enum value) {\n            args.put(name, value);\n            return this;\n        }\n\n        public Arguments build() {\n            return Arguments.this;\n        }\n    }\n}\n", "        public Arguments build() {\n            return Arguments.this;\n        }\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/DaggerQueryException.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport io.smallrye.graphql.client.GraphQLError;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class DaggerQueryException extends Exception {\n\n    private GraphQLError[] errors;\n\n    public DaggerQueryException() {\n        super(\"An unexpected error occured with no error details\");\n        this.errors = new GraphQLError[0];\n    }\n\n    public DaggerQueryException(GraphQLError... errors) {\n        super(Arrays.stream(errors).map(GraphQLError::getMessage).collect(Collectors.joining(\"\\n\")));\n        this.errors = errors;\n    }\n\n    public GraphQLError[] getErrors() {\n        return errors;\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/QueryPart.java", "chunked_list": ["package org.chelonix.dagger.client;\n\nimport io.smallrye.graphql.client.core.Field;\n\nimport java.util.concurrent.ExecutionException;\n\nimport static io.smallrye.graphql.client.core.Field.field;\n\nclass QueryPart {\n", "class QueryPart {\n\n    private String fieldName;\n    private Arguments arguments;\n\n    QueryPart(String fieldName) {\n        this(fieldName, Arguments.noArgs());\n    }\n\n    QueryPart(String fieldName, Arguments arguments) {", "\n    QueryPart(String fieldName, Arguments arguments) {\n        this.fieldName = fieldName;\n        this.arguments = arguments;\n    }\n\n    String getOperation() {\n        return fieldName;\n    }\n", "    }\n\n    Field toField() throws ExecutionException, InterruptedException, DaggerQueryException {\n        //List<Argument> argList = arguments.entrySet().stream().map(e -> arg(e.getKey(), e.getValue().serialize())).toList();\n        return field(fieldName, arguments.toList());\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/engineconn/FileFetcher.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n@FunctionalInterface\ninterface FileFetcher {\n\n    InputStream fetch(String url) throws IOException;\n}", "    InputStream fetch(String url) throws IOException;\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/engineconn/Connection.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\nimport io.smallrye.graphql.client.vertx.dynamic.VertxDynamicGraphQLClientBuilder;\nimport io.vertx.core.Vertx;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;", "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Optional;\n\npublic final class Connection {\n\n    static final Logger LOG = LoggerFactory.getLogger(Connection.class);\n\n    private final DynamicGraphQLClient graphQLClient;\n    private final Vertx vertx;\n    private final Optional<CLIRunner> daggerRunner;\n\n    Connection(DynamicGraphQLClient graphQLClient, Vertx vertx, Optional<CLIRunner> daggerRunner) {\n        this.graphQLClient = graphQLClient;\n        this.vertx = vertx;\n        this.daggerRunner = daggerRunner;\n    }\n", "    public DynamicGraphQLClient getGraphQLClient() {\n        return this.graphQLClient;\n    }\n\n    public void close() throws Exception {\n        this.graphQLClient.close();\n        this.vertx.close();\n        this.daggerRunner.ifPresent(CLIRunner::shutdown);\n    }\n\n    static Optional<Connection> fromEnv() {\n        LOG.info(\"Trying initializing connection with engine from environment variables...\");\n        String portStr = System.getenv(\"DAGGER_SESSION_PORT\");\n        String sessionToken = System.getenv(\"DAGGER_SESSION_TOKEN\");", "        if (portStr != null && sessionToken != null) {\n            try {\n                int port = Integer.parseInt(portStr);\n                return Optional.of(getConnection(port, sessionToken, Optional.empty()));\n            } catch (NumberFormatException nfe) {\n                LOG.error(\"invalid port value in DAGGER_SESSION_PORT\", nfe);\n            }\n        } else if (portStr == null) {\n            LOG.error(\"DAGGER_SESSION_TOKEN is required when using DAGGER_SESSION_PORT\");\n        } else if (sessionToken == null) {\n            LOG.error(\"DAGGER_SESSION_PORT is required when using DAGGER_SESSION_TOKEN\");\n        }\n        return Optional.empty();\n    }\n\n    static Connection fromCLI(CLIRunner cliRunner) throws IOException {\n        LOG.info(\"Trying initializing connection with engine from automatic provisioning...\");", "        } else if (sessionToken == null) {\n            LOG.error(\"DAGGER_SESSION_PORT is required when using DAGGER_SESSION_TOKEN\");\n        }\n        return Optional.empty();\n    }\n\n    static Connection fromCLI(CLIRunner cliRunner) throws IOException {\n        LOG.info(\"Trying initializing connection with engine from automatic provisioning...\");\n        try {\n            cliRunner.start();\n            ConnectParams connectParams = cliRunner.getConnectionParams();\n            return getConnection(connectParams.getPort(), connectParams.getSessionToken(), Optional.of(cliRunner));\n        } catch (IOException ioe) {\n            cliRunner.shutdown();\n            throw ioe;\n        }\n    }\n", "        try {\n            cliRunner.start();\n            ConnectParams connectParams = cliRunner.getConnectionParams();\n            return getConnection(connectParams.getPort(), connectParams.getSessionToken(), Optional.of(cliRunner));\n        } catch (IOException ioe) {\n            cliRunner.shutdown();\n            throw ioe;\n        }\n    }\n\n    public static Connection get(String workingDir) throws IOException {\n        return fromEnv().orElse(fromCLI(new CLIRunner(workingDir)));\n    }\n\n    private static Connection getConnection(int port, String token, Optional<CLIRunner> runner) {\n        Vertx vertx = Vertx.vertx();\n        String encodedToken = Base64.getEncoder().encodeToString((token + \":\").getBytes(StandardCharsets.UTF_8));\n        DynamicGraphQLClient dynamicGraphQLClient = new VertxDynamicGraphQLClientBuilder()\n                .vertx(vertx)\n                .url(String.format(\"http://127.0.0.1:%d/query\", port))\n                .header(\"authorization\", \"Basic \" + encodedToken)\n                .build();\n        return new Connection(dynamicGraphQLClient, vertx, runner);\n    }\n}\n", "    public static Connection get(String workingDir) throws IOException {\n        return fromEnv().orElse(fromCLI(new CLIRunner(workingDir)));\n    }\n\n    private static Connection getConnection(int port, String token, Optional<CLIRunner> runner) {\n        Vertx vertx = Vertx.vertx();\n        String encodedToken = Base64.getEncoder().encodeToString((token + \":\").getBytes(StandardCharsets.UTF_8));\n        DynamicGraphQLClient dynamicGraphQLClient = new VertxDynamicGraphQLClientBuilder()\n                .vertx(vertx)\n                .url(String.format(\"http://127.0.0.1:%d/query\", port))\n                .header(\"authorization\", \"Basic \" + encodedToken)\n                .build();\n        return new Connection(dynamicGraphQLClient, vertx, runner);\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/engineconn/CLIRunner.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nimport com.ongres.process.FluentProcess;\nimport jakarta.json.Json;\nimport jakarta.json.JsonObject;\nimport jakarta.json.JsonReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass CLIRunner implements Runnable {\n\n    static final Logger LOG = LoggerFactory.getLogger(CLIRunner.class);\n", "    static final Logger LOG = LoggerFactory.getLogger(CLIRunner.class);\n\n    private final FluentProcess process;\n    private ConnectParams params;\n    private boolean failed = false;\n    private final ExecutorService executorService;\n\n    private static String getCLIPath() throws IOException {\n        String cliBinPath = System.getenv(\"_EXPERIMENTAL_DAGGER_CLI_BIN\");\n        if (cliBinPath == null) {\n            cliBinPath = new CLIDownloader().downloadCLI();\n        }\n        return cliBinPath;\n    }\n\n    public CLIRunner(String workingDir) throws IOException {\n        String bin = getCLIPath();\n        this.process = FluentProcess.start(bin, \"session\",\n                        \"--workdir\", workingDir,\n                        \"--label\", \"dagger.io/sdk.name:java\",\n                        \"--label\", \"dagger.io/sdk.version:\" + CLIDownloader.CLI_VERSION)\n                .withAllowedExitCodes(137);\n        this.executorService = Executors.newSingleThreadExecutor(r -> new Thread(r, \"dagger-runner\"));\n\n    }\n\n    synchronized ConnectParams getConnectionParams() throws IOException {", "        String cliBinPath = System.getenv(\"_EXPERIMENTAL_DAGGER_CLI_BIN\");\n        if (cliBinPath == null) {\n            cliBinPath = new CLIDownloader().downloadCLI();\n        }\n        return cliBinPath;\n    }\n\n    public CLIRunner(String workingDir) throws IOException {\n        String bin = getCLIPath();\n        this.process = FluentProcess.start(bin, \"session\",\n                        \"--workdir\", workingDir,\n                        \"--label\", \"dagger.io/sdk.name:java\",\n                        \"--label\", \"dagger.io/sdk.version:\" + CLIDownloader.CLI_VERSION)\n                .withAllowedExitCodes(137);\n        this.executorService = Executors.newSingleThreadExecutor(r -> new Thread(r, \"dagger-runner\"));\n\n    }\n\n    synchronized ConnectParams getConnectionParams() throws IOException {", "        while (params == null) {\n            try {\n                if (failed) {\n                    throw new IOException(\"Could not connect to Dagger engine\");\n                }\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n        return params;\n    }\n\n    private synchronized void setFailed() {\n        this.failed = true;\n        notifyAll();\n    }\n\n\n    synchronized void setParams(ConnectParams params) {\n        this.params = params;\n        notifyAll();\n    }\n", "    public void start() {\n        executorService.execute(this);\n    }\n\n    @Override\n    public void run() {\n        try {\n            process.streamOutputLines().forEach(line -> {\n                if (line.isStdout() && line.line().contains(\"session_token\")) {\n                    try (JsonReader reader = Json.createReader(new StringReader(line.line()))) {\n                        JsonObject obj = reader.readObject();\n                        int port = obj.getInt(\"port\");\n                        String sessionToken = obj.getString(\"session_token\");\n                        setParams(new ConnectParams(port, sessionToken));\n                    }\n                } else {\n                    LOG.info(line.line());\n                }\n            });\n        } catch (RuntimeException e) {", "                if (line.isStdout() && line.line().contains(\"session_token\")) {\n                    try (JsonReader reader = Json.createReader(new StringReader(line.line()))) {\n                        JsonObject obj = reader.readObject();\n                        int port = obj.getInt(\"port\");\n                        String sessionToken = obj.getString(\"session_token\");\n                        setParams(new ConnectParams(port, sessionToken));\n                    }\n                } else {\n                    LOG.info(line.line());\n                }\n            });\n        } catch (RuntimeException e) {", "            if (!(e.getCause() instanceof IOException\n                    && \"Stream closed\".equals(e.getCause().getMessage()))) {\n                LOG.error(e.getMessage(), e);\n                setFailed();\n                throw e;\n            }\n        }\n    }\n\n    public void shutdown() {\n        executorService.shutdown();\n        process.close();\n    }\n}\n", "    public void shutdown() {\n        executorService.shutdown();\n        process.close();\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/engineconn/CLIDownloader.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\nimport org.freedesktop.BaseDirectory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestInputStream;", "import java.nio.file.Paths;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.HexFormat;\nimport java.util.Map;\n\nclass CLIDownloader {\n", "class CLIDownloader {\n\n    static final Logger LOG = LoggerFactory.getLogger(CLIDownloader.class);\n\n    private static final File CACHE_DIR = Paths.get(BaseDirectory.get(BaseDirectory.XDG_CACHE_HOME), \"dagger\").toFile();\n\n    public static final String CLI_VERSION = \"0.6.2\";\n\n    private static final String DAGGER_CLI_BIN_PREFIX = \"dagger-\";\n\n    private final FileFetcher fetcher;\n\n    public CLIDownloader(FileFetcher fetcher) {\n        this.fetcher = fetcher;\n    }\n\n    public CLIDownloader() {\n        this(url -> new URL(url).openStream());\n    }\n", "    public String downloadCLI(String version) throws IOException {\n        CACHE_DIR.mkdirs();\n        CACHE_DIR.setExecutable(true, true);\n        CACHE_DIR.setReadable(true, true);\n        CACHE_DIR.setWritable(true, true);\n\n        String binName = DAGGER_CLI_BIN_PREFIX + version;\n        if (isWindows()) {\n            binName += \".exe\";\n        }\n        Path binPath = Paths.get(CACHE_DIR.getPath(), binName);\n", "        if (!binPath.toFile().exists()) {\n            downloadCLI(version, binPath);\n        }\n\n        return binPath.toString();\n    }\n\n    public String downloadCLI() throws IOException {\n        return downloadCLI(CLI_VERSION);\n    }\n\n    private void downloadCLI(String version, Path binPath) throws IOException {\n        String binName = binPath.getFileName().toString();\n        Path tmpBin = Files.createTempFile(CACHE_DIR.toPath(), \"tmp-\" + binName, null);", "        try {\n            String archiveName = getDefaultCLIArchiveName(version);\n            String expectedChecksum = expectedChecksum(version, archiveName);\n            if (expectedChecksum == null) {\n                throw new IOException(\"Could not find checksum for \" + archiveName);\n            }\n            String actualChecksum = extractCLI(archiveName, version, tmpBin);\n            if (!actualChecksum.equals(expectedChecksum)) {\n                throw new IOException(\"Checksum validation failed\");\n            }\n            tmpBin.toFile().setExecutable(true);\n            Files.move(tmpBin, binPath);\n        } finally {\n            Files.deleteIfExists(tmpBin);\n        }\n    }\n\n    private String expectedChecksum(String version, String archiveName) throws IOException {\n        Map<String, String> checksums = fetchChecksumMap(version);\n        return checksums.get(archiveName);\n    }\n\n    private String getDefaultCLIArchiveName(String version) {\n        String ext = isWindows() ? \"zip\" : \"tar.gz\";\n        return String.format(\"dagger_v%s_%s_%s.%s\", version, getOS(), getArch(), ext);\n    }\n\n    private Map<String, String> fetchChecksumMap(String version) throws IOException {\n        Map<String, String> checksums = new HashMap<>();\n        String checksumMapURL = String.format(\"https://dl.dagger.io/dagger/releases/%s/checksums.txt\", version);\n        try (BufferedInputStream in = new BufferedInputStream(fetcher.fetch(checksumMapURL))) {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            byte[] dataBuffer = new byte[1024];\n            int bytesRead;", "            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                out.write(dataBuffer, 0, bytesRead);\n            }\n            BufferedReader reader = new BufferedReader(new StringReader(out.toString(StandardCharsets.UTF_8)));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] arr = line.split(\"\\\\s+\");\n                checksums.put(arr[1], arr[0]);\n            }\n            return checksums;\n        }\n    }\n\n    private String extractCLI(String archiveName, String version, Path dest) throws IOException {\n        String cliArchiveURL = String.format(\"https://dl.dagger.io/dagger/releases/%s/%s\", version, archiveName);\n        LOG.info(\"Downloading Dagger CLI from \" + cliArchiveURL);\n        MessageDigest sha256;", "        try {\n            sha256 = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IOException(\"Could not instantiate SHA-256 digester\", nsae);\n        }\n        LOG.info(\"Extracting archive...\");\n        try (InputStream in = new BufferedInputStream(new DigestInputStream(fetcher.fetch(cliArchiveURL), sha256))) {\n            if (isWindows()) {\n                extractZip(in, dest);\n            } else {\n                extractTarGZ(in, dest);\n            }\n            byte[] checksum = sha256.digest();\n            return HexFormat.of().formatHex(checksum);\n        }\n    }\n\n    private void extractZip(InputStream in, Path dest) throws IOException {\n        try (ZipArchiveInputStream zipIn = new ZipArchiveInputStream(in)) {\n            extractCLIBin(zipIn, \"dagger.exe\", dest);\n        }\n    }\n\n    private static void extractCLIBin(ArchiveInputStream in, String binName, Path dest) throws IOException {\n        boolean found = false;\n        ArchiveEntry entry;", "        while ((entry = in.getNextEntry()) != null) {\n            if (entry.isDirectory() || !binName.equals(entry.getName())) {\n                continue;\n            }\n            int count;\n            byte[] data = new byte[4096];\n            FileOutputStream fos = new FileOutputStream(dest.toFile());\n            try (BufferedOutputStream out = new BufferedOutputStream(fos, 4096)) {\n                while ((count = in.read(data, 0, 4096)) != -1) {\n                    out.write(data, 0, count);\n                }\n            }\n            found = true;\n            break;\n        }", "                while ((count = in.read(data, 0, 4096)) != -1) {\n                    out.write(data, 0, count);\n                }\n            }\n            found = true;\n            break;\n        }\n        if (!found) {\n            throw new IOException(\"Could not find dagger binary in CLI archive\");\n        }\n    }\n\n    private void extractTarGZ(InputStream in, Path dest) throws IOException {\n        boolean found = false;\n        try (GzipCompressorInputStream gzipIn = new GzipCompressorInputStream(in);\n             TarArchiveInputStream tarIn = new TarArchiveInputStream(gzipIn)) {\n            extractCLIBin(tarIn, \"dagger\", dest);\n        }\n    }\n\n    private static boolean isWindows() {\n        return System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n    }\n\n    private static String getOS() {\n        String os = System.getProperty(\"os.name\").toLowerCase();", "        if (os.contains(\"win\")) {\n            return \"windows\";\n        } else if (os.contains(\"linux\")) {\n            return \"linux\";\n        } else if (os.contains(\"darwin\") || os.contains(\"mac\")) {\n            return \"darwin\";\n        } else {\n            return \"unknown\";\n        }\n    }\n\n    private static String getArch() {\n        String arch = System.getProperty(\"os.arch\").toLowerCase();", "        if (arch.contains(\"x86_64\") || arch.contains(\"amd64\")) {\n            return \"amd64\";\n        } else if (arch.contains(\"x86\")) {\n            return \"x86\";\n        } else if (arch.contains(\"arm\")) {\n            return \"armv7\";\n        } else if (arch.contains(\"aarch64\")) {\n        \treturn \"arm64\";\n        } else {\n            return \"unknown\";\n        }\n    }\n}\n"]}
{"filename": "dagger-java-sdk/src/main/java/org/chelonix/dagger/client/engineconn/ConnectParams.java", "chunked_list": ["package org.chelonix.dagger.client.engineconn;\n\nclass ConnectParams {\n    private int port;\n\n    private String sessionToken;\n\n    public ConnectParams(int port, String sessionToken) {\n        this.port = port;\n        this.sessionToken = sessionToken;", "        this.port = port;\n        this.sessionToken = sessionToken;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public String toString() {\n        return \"ConnectParams{\" +\n                \"port=\" + port +\n                \", sessionToken='\" + sessionToken + '\\'' +\n                '}';\n    }\n", "    public String toString() {\n        return \"ConnectParams{\" +\n                \"port=\" + port +\n                \", sessionToken='\" + sessionToken + '\\'' +\n                '}';\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n", "    public String getSessionToken() {\n        return sessionToken;\n    }\n\n    public void setSessionToken(String sessionToken) {\n        this.sessionToken = sessionToken;\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/DaggerCodegenMojo.java", "chunked_list": ["package org.chelonix.dagger.codegen;\n\nimport com.ongres.process.FluentProcess;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;", "import org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\nimport org.apache.maven.project.MavenProject;\nimport org.chelonix.dagger.codegen.introspection.CodegenVisitor;\nimport org.chelonix.dagger.codegen.introspection.Schema;\nimport org.chelonix.dagger.codegen.introspection.SchemaVisitor;\nimport org.chelonix.dagger.codegen.introspection.Type;\n\nimport java.io.*;\nimport java.net.URL;", "import java.io.*;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\n\n@Mojo(name = \"codegen\",\n        defaultPhase = LifecyclePhase.GENERATE_SOURCES,\n        requiresDependencyResolution = ResolutionScope.COMPILE,", "        defaultPhase = LifecyclePhase.GENERATE_SOURCES,\n        requiresDependencyResolution = ResolutionScope.COMPILE,\n        threadSafe = true)\npublic class DaggerCodegenMojo extends AbstractMojo {\n\n    /**\n     * specify output file encoding; defaults to source encoding\n     */\n    @Parameter(property = \"project.build.sourceEncoding\")\n    protected String outputEncoding;\n\n    /**\n     * The current Maven project.\n     */\n    @Parameter(property = \"project\", required = true, readonly = true)\n    protected MavenProject project;\n\n    @Parameter(property = \"dagger.bin\", defaultValue = \"dagger\")\n    protected String bin;\n\n    @Parameter(property = \"dagger.version\", required = true)\n    protected String version;\n\n    @Parameter(property = \"dagger.introspectionQuertyURL\")\n    protected String introspectionQuertyURL;\n\n    @Parameter(property = \"dagger.introspectionQuertyPath\")\n    protected String introspectionQuertyPath;\n\n    @Parameter(property = \"dagger.regenerateSchema\", defaultValue = \"false\")\n    protected boolean online;\n\n\n    /**\n     * Specify output directory where the Java files are generated.\n     */\n    @Parameter(defaultValue = \"${project.build.directory}/generated-sources/dagger\")\n    private File outputDirectory;\n\n    @Override", "    public void execute() throws MojoExecutionException, MojoFailureException {\n        outputEncoding = validateEncoding(outputEncoding);\n\n        // Ensure that the output directory path is all in tact so that\n        // ANTLR can just write into it.\n        //\n        File outputDir = getOutputDirectory();\n\n        if (!outputDir.exists()) {\n            outputDir.mkdirs();\n        }\n\n        Path dest = outputDir.toPath();\n        try (InputStream in = daggerSchema()) {\n            Schema schema = Schema.initialize(in);\n            SchemaVisitor codegen = new CodegenVisitor(schema, dest, Charset.forName(outputEncoding));\n            schema.visit(new SchemaVisitor() {\n                @Override", "        if (!outputDir.exists()) {\n            outputDir.mkdirs();\n        }\n\n        Path dest = outputDir.toPath();\n        try (InputStream in = daggerSchema()) {\n            Schema schema = Schema.initialize(in);\n            SchemaVisitor codegen = new CodegenVisitor(schema, dest, Charset.forName(outputEncoding));\n            schema.visit(new SchemaVisitor() {\n                @Override\n                public void visitScalar(Type type) {\n                    getLog().info(String.format(\"Generating scala %s\", type.getName()));\n                    codegen.visitScalar(type);\n                }\n\n                @Override", "                public void visitScalar(Type type) {\n                    getLog().info(String.format(\"Generating scala %s\", type.getName()));\n                    codegen.visitScalar(type);\n                }\n\n                @Override\n                public void visitObject(Type type) {\n                    getLog().info(String.format(\"Generating object %s\", type.getName()));\n                    codegen.visitObject(type);\n                }\n\n                @Override", "                public void visitInput(Type type) {\n                    getLog().info(String.format(\"Generating input %s\", type.getName()));\n                    codegen.visitInput(type);\n\n                }\n\n                @Override\n                public void visitEnum(Type type) {\n                    getLog().info(String.format(\"Generating enum %s\", type.getName()));\n                    codegen.visitEnum(type);\n                }\n            });\n        } catch (IOException ioe) {\n            throw new MojoFailureException(ioe);\n        } catch (InterruptedException ie) {\n            throw new MojoFailureException(ie);\n        }\n", "        if (project != null) {\n            // Tell Maven that there are some new source files underneath the output directory.\n            project.addCompileSourceRoot(getOutputDirectory().getPath());\n        }\n    }\n\n    private InputStream daggerSchema() throws IOException, InterruptedException, MojoFailureException {\n        if (!online) {\n            InputStream in = getClass().getClassLoader().getResourceAsStream(String.format(\"schemas/schema-v%s.json\", version));\n            if (in == null) {\n                throw new MojoFailureException(String.format(\"GraphQL schema not available for version %s\", version));\n            }\n            return in;\n        }", "            if (in == null) {\n                throw new MojoFailureException(String.format(\"GraphQL schema not available for version %s\", version));\n            }\n            return in;\n        }\n        if (introspectionQuertyPath != null) {\n            return new FileInputStream(introspectionQuertyPath);\n        }\n        InputStream in;\n        if (introspectionQuertyPath != null) {\n            return new FileInputStream(introspectionQuertyPath);", "        if (introspectionQuertyPath != null) {\n            return new FileInputStream(introspectionQuertyPath);\n        } else if (introspectionQuertyURL == null) {\n            in = new URL(String.format(\"https://raw.githubusercontent.com/dagger/dagger/v%s/codegen/introspection/introspection.graphql\", version)).openStream();\n        } else if (introspectionQuertyURL != null) {\n            in = new URL(introspectionQuertyURL).openStream();\n        } else {\n            throw new MojoFailureException(\"Could not locate, download or generate GraphQL schema\");\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        FluentProcess.start(bin, \"query\")\n                .withTimeout(Duration.of(60, ChronoUnit.SECONDS))\n                .inputStream(in)\n                .writeToOutputStream(out);\n        return new ByteArrayInputStream(out.toByteArray());\n    }\n", "    public File getOutputDirectory() {\n        return outputDirectory;\n    }\n\n    /**\n     * Validates the given encoding.\n     *\n     * @return  the validated encoding. If {@code null} was provided, returns the platform default encoding.\n     */\n    private String validateEncoding(String encoding) {\n        return (encoding == null) ? Charset.defaultCharset().name() : Charset.forName(encoding.trim()).name();\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/Scalar.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\npublic enum Scalar {\n    ScalarInt(\"Int\"),\n    ScalarFloat(\"Float\"),\n    ScalarString(\"String\"),\n    ScalarBoolean(\"Boolean\");\n\n    private String type;\n\n    Scalar(String scalarType) {\n        this.type = scalarType;\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/InputValue.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\npublic class InputValue {\n\n    private String name;\n    private String description;\n    private String defaultValue; // isDeprecated\n    private TypeRef type;\n\n    public String getName() {\n        return name;\n    }\n", "    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n", "    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description.replace(\"\\n\", \"<br/>\");\n    }\n\n    public String getDefaultValue() {\n        return defaultValue;\n    }\n", "    public String getDefaultValue() {\n        return defaultValue;\n    }\n\n    public void setDefaultValue(String defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n\n    public TypeRef getType() {\n        return type;\n    }\n", "    public TypeRef getType() {\n        return type;\n    }\n\n    public void setType(TypeRef type) {\n        this.type = type;\n    }\n\n    @Override\n    public String toString() {\n        return \"InputValue{\" +\n                \"name='\" + name + '\\'' +\n                // \", Description='\" + Description + '\\'' +\n                \", defaultValue='\" + defaultValue + '\\'' +\n                \", type=\" + type +\n                '}';\n    }\n}\n", "    public String toString() {\n        return \"InputValue{\" +\n                \"name='\" + name + '\\'' +\n                // \", Description='\" + Description + '\\'' +\n                \", defaultValue='\" + defaultValue + '\\'' +\n                \", type=\" + type +\n                '}';\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/SchemaVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\npublic interface SchemaVisitor {\n\n    void visitScalar(Type type);\n\n    void visitObject(Type type);\n\n    void visitInput(Type type);\n\n    void visitEnum(Type type);\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/Type.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport java.util.List;\n\nimport static java.util.Comparator.comparing;\n\npublic class Type {\n    private TypeKind kind;\n    private String name;\n    private String description;\n    private List<Field> fields;\n    private List<InputValue> inputFields;\n    private List<EnumValue> enumValues;\n", "    public TypeKind getKind() {\n        return kind;\n    }\n\n    public void setKind(TypeKind kind) {\n        this.kind = kind;\n    }\n\n    public String getName() {\n        return name;\n    }\n", "    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n", "    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description.replace(\"\\n\", \"<br/>\");\n    }\n\n    public List<EnumValue> getEnumValues() {\n        return enumValues;\n    }\n", "    public void setEnumValues(List<EnumValue> enumValues) {\n        this.enumValues = enumValues;\n    }\n\n    public List<InputValue> getInputFields() {\n        return inputFields;\n    }\n\n    public void setInputFields(List<InputValue> inputFields) {\n        this.inputFields = inputFields == null ? null : inputFields.stream().sorted(comparing(InputValue::getName)).toList();\n        // this.inputFields = inputFields;\n    }\n\n    public List<Field> getFields() {\n        return fields;\n    }\n", "    public void setInputFields(List<InputValue> inputFields) {\n        this.inputFields = inputFields == null ? null : inputFields.stream().sorted(comparing(InputValue::getName)).toList();\n        // this.inputFields = inputFields;\n    }\n\n    public List<Field> getFields() {\n        return fields;\n    }\n\n    public void setFields(List<Field> fields) {\n        this.fields = fields == null ? null : fields.stream().sorted(comparing(Field::getName)).toList();\n        //this.fields = fields;\n    }\n\n    @Override", "    public void setFields(List<Field> fields) {\n        this.fields = fields == null ? null : fields.stream().sorted(comparing(Field::getName)).toList();\n        //this.fields = fields;\n    }\n\n    @Override\n    public String toString() {\n        return \"Type{\" +\n                \"kind=\" + kind +\n                \", name='\" + name + '\\'' +\n                \", description='\" + description + '\\'' +\n                \", fields=\" + fields +\n                \", inputFields=\" + inputFields +\n                \", enumValues=\" + enumValues +\n                '}';\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/EnumVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.*;\n\nimport javax.lang.model.element.Modifier;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\n\npublic class EnumVisitor extends AbstractVisitor {\n\n    public EnumVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);\n    }\n\n    @Override\n    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.enumBuilder(Helpers.formatName(type))\n                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC);\n", "public class EnumVisitor extends AbstractVisitor {\n\n    public EnumVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);\n    }\n\n    @Override\n    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.enumBuilder(Helpers.formatName(type))\n                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC);\n", "        for (EnumValue enumValue: type.getEnumValues()) {\n            TypeSpec.Builder enumTypeBuilder = TypeSpec.anonymousClassBuilder(\"\")\n                    .addJavadoc(enumValue.getDescription());\n            if (enumValue.isDeprecated()) {\n                enumTypeBuilder.addAnnotation(Deprecated.class);\n            }\n            classBuilder.addEnumConstant(enumValue.getName(), enumTypeBuilder.build());\n        }\n\n        return classBuilder.build();\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/ScalarVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.*;\n\nimport javax.lang.model.element.Modifier;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\n\nclass ScalarVisitor extends AbstractVisitor {\n    public ScalarVisitor(Schema schema, Path targetDirectory, Charset encoding) {", "class ScalarVisitor extends AbstractVisitor {\n    public ScalarVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);\n    }\n\n    @Override\n    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(Helpers.formatName(type))\n                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC)", "                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC)\n                .superclass(ParameterizedTypeName.get(\n                        ClassName.bestGuess(\"Scalar\"),\n                        ClassName.get(String.class)));\n\n        MethodSpec constructor = MethodSpec.constructorBuilder()\n                .addParameter(ClassName.get(String.class), \"value\")\n                .addStatement(\"super(value)\").build();\n", "                .addStatement(\"super(value)\").build();\n\n        classBuilder.addMethod(constructor);\n\n        return classBuilder.build();\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/AbstractVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.TypeSpec;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\n\nabstract class AbstractVisitor {", "\nabstract class AbstractVisitor {\n\n    private Schema schema;\n    private Charset encoding;\n    private Path targetDirectory;\n\n    public AbstractVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        this.schema = schema;\n        this.targetDirectory = targetDirectory;", "        this.schema = schema;\n        this.targetDirectory = targetDirectory;\n        this.encoding = encoding;\n    }\n\n    void visit(Type type) throws IOException {\n        TypeSpec typeSpec = generateType(type);\n        JavaFile javaFile = JavaFile.builder(\"org.chelonix.dagger.client\", typeSpec)\n                .addFileComment(\"This class has been generated by dagger-java-sdk. DO NOT EDIT.\")\n                .indent(\"    \")", "                .addFileComment(\"This class has been generated by dagger-java-sdk. DO NOT EDIT.\")\n                .indent(\"    \")\n                .build();\n        javaFile.writeTo(targetDirectory, encoding);\n    }\n\n    public Schema getSchema() {\n        return schema;\n    }\n\n    abstract TypeSpec generateType(Type type);\n\n}"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/ObjectVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.*;\n\nimport javax.lang.model.element.Modifier;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.function.UnaryOperator;", "import java.util.concurrent.ExecutionException;\nimport java.util.function.UnaryOperator;\n\nimport static org.apache.commons.lang3.StringUtils.capitalize;\nimport static org.chelonix.dagger.codegen.introspection.Helpers.*;\nimport static org.chelonix.dagger.codegen.introspection.Helpers.isIdToConvert;\n\nclass ObjectVisitor extends AbstractVisitor {\n    public ObjectVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);", "    public ObjectVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);\n    }\n\n    private static MethodSpec withMethod(String var, TypeName type, TypeName returnType, String doc) {\n        return MethodSpec.methodBuilder(\"with\" + capitalize(var))\n                .addModifiers(Modifier.PUBLIC)\n                .addParameter(type, var)\n                .returns(returnType)\n                .addStatement(\"this.$1L = $1L\", var)", "                .returns(returnType)\n                .addStatement(\"this.$1L = $1L\", var)\n                .addStatement(\"return this\")\n                .addJavadoc(escapeJavadoc(doc))\n                .build();\n    }\n\n    @Override\n    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(Helpers.formatName(type))", "    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(Helpers.formatName(type))\n                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC)\n                //.addSuperinterface(ClassName.bestGuess(\"IdProvider\"))\n                .addField(FieldSpec.builder(ClassName.bestGuess(\"QueryBuilder\"), \"queryBuilder\",Modifier.PRIVATE).build());\n\n        if (\"Query\".equals(type.getName())) {\n            MethodSpec constructor = MethodSpec.constructorBuilder()\n                    .addParameter(ClassName.bestGuess(\"org.chelonix.dagger.client.engineconn.Connection\"), \"connection\")\n                    .addStatement(\"this.connection = connection\")\n                    .addStatement(\"this.queryBuilder = new QueryBuilder(connection.getGraphQLClient())\")\n                    .build();\n            classBuilder.addMethod(constructor);\n            classBuilder.addField(FieldSpec.builder(\n                    ClassName.bestGuess(\"org.chelonix.dagger.client.engineconn.Connection\"),\n                    \"connection\",Modifier.PRIVATE).build());\n            // AutoCloseable implementation\n            classBuilder.addSuperinterface(AutoCloseable.class);\n            MethodSpec closeMethod = MethodSpec.methodBuilder(\"close\")\n                    .addException(Exception.class)\n                    .addModifiers(Modifier.PUBLIC)\n                    .addStatement(\"this.connection.close()\")\n                    .build();\n            classBuilder.addMethod(closeMethod);\n        } else {\n            // Object constructor for JSON deserialization\n            MethodSpec constructor = MethodSpec.constructorBuilder()\n                    .addModifiers(Modifier.PROTECTED)\n                    .addJavadoc(\"Empty constructor for JSON-B deserialization\")\n                    .build();\n            classBuilder.addMethod(constructor);\n", "            for (Field scalarField : type.getFields().stream().filter(f -> f.getTypeRef().isScalar()).toList()) {\n                // If Object has an \"id\" field, implement IdProvider interface\n                if (\"id\".equals(scalarField.getName())) {\n                    classBuilder.addSuperinterface(ParameterizedTypeName.get(\n                            ClassName.bestGuess(\"IdProvider\"),\n                            scalarField.getTypeRef().formatOutput()));\n                }\n                classBuilder.addField(scalarField.getTypeRef().formatOutput(), scalarField.getName(), Modifier.PRIVATE);\n            }\n        }\n\n        // Object constructor for query building\n        MethodSpec constructor = MethodSpec.constructorBuilder()\n                .addParameter(ClassName.bestGuess(\"QueryBuilder\"), \"queryBuilder\")\n                .addCode(\"this.queryBuilder = queryBuilder;\")\n                .build();\n        classBuilder.addMethod(constructor);\n", "        for (Field field: type.getFields())\n        {\n            if (field.hasOptionalArgs()) {\n                buildFieldArgumentsHelpers(classBuilder, field, type);\n                buildFieldMethod(classBuilder, field, true);\n            }\n\n            buildFieldMethod(classBuilder, field, false);\n        }\n\n        if (List.of(\"Container\", \"Directoy\").contains(type.getName())) {\n            ClassName thisType = ClassName.bestGuess(Helpers.formatName(type));\n            String argName = type.getName().toLowerCase() + \"Func\";\n            classBuilder.addMethod(MethodSpec.methodBuilder(\"with\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class), thisType), argName)\n                    .returns(thisType)\n                    .addStatement(\"return $L.apply(this)\", argName)\n                    .build());\n        }\n        return classBuilder.build();\n    }\n\n    private void buildFieldMethod(TypeSpec.Builder classBuilder, Field field, boolean withOptionalArgs) {\n        MethodSpec.Builder fieldMethodBuilder = MethodSpec.methodBuilder(formatName(field)).addModifiers(Modifier.PUBLIC);\n        TypeName returnType = \"id\".equals(field.getName()) ? field.getTypeRef().formatOutput() : field.getTypeRef().formatInput();\n        fieldMethodBuilder.returns(returnType);\n        List<ParameterSpec> mandatoryParams = field.getRequiredArgs().stream()\n                .map(arg -> ParameterSpec.builder(\n                        \"Query\".equals(field.getParentObject().getName()) && \"id\".equals(arg.getName()) ?\n                                arg.getType().formatOutput() :\n                                arg.getType().formatInput(),\n                        arg.getName())\n                        .addJavadoc(arg.getDescription())\n                        .build())\n                .toList();\n        fieldMethodBuilder.addParameters(mandatoryParams);", "        if (List.of(\"Container\", \"Directoy\").contains(type.getName())) {\n            ClassName thisType = ClassName.bestGuess(Helpers.formatName(type));\n            String argName = type.getName().toLowerCase() + \"Func\";\n            classBuilder.addMethod(MethodSpec.methodBuilder(\"with\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class), thisType), argName)\n                    .returns(thisType)\n                    .addStatement(\"return $L.apply(this)\", argName)\n                    .build());\n        }\n        return classBuilder.build();\n    }\n\n    private void buildFieldMethod(TypeSpec.Builder classBuilder, Field field, boolean withOptionalArgs) {\n        MethodSpec.Builder fieldMethodBuilder = MethodSpec.methodBuilder(formatName(field)).addModifiers(Modifier.PUBLIC);\n        TypeName returnType = \"id\".equals(field.getName()) ? field.getTypeRef().formatOutput() : field.getTypeRef().formatInput();\n        fieldMethodBuilder.returns(returnType);\n        List<ParameterSpec> mandatoryParams = field.getRequiredArgs().stream()\n                .map(arg -> ParameterSpec.builder(\n                        \"Query\".equals(field.getParentObject().getName()) && \"id\".equals(arg.getName()) ?\n                                arg.getType().formatOutput() :\n                                arg.getType().formatInput(),\n                        arg.getName())\n                        .addJavadoc(arg.getDescription())\n                        .build())\n                .toList();\n        fieldMethodBuilder.addParameters(mandatoryParams);", "        if (withOptionalArgs && field.hasOptionalArgs()) {\n            fieldMethodBuilder.addParameter(ParameterSpec.builder(ClassName.bestGuess(capitalize(formatName(field)) + \"Arguments\"), \"optArgs\")\n                    .addJavadoc(\"$L optional arguments\", formatName(field))\n                    .build()\n            );\n        }\n        fieldMethodBuilder.addJavadoc(escapeJavadoc(field.getDescription()));\n        //field.getRequiredArgs().forEach(arg -> fieldMethodBuilder.addJavadoc(\"\\n@param $L $L\", arg.getName(), arg.getDescription()));\n\n        if (field.getTypeRef().isScalar() && !isIdToConvert(field) && !\"Query\".equals(field.getParentObject().getName())) {\n            fieldMethodBuilder.beginControlFlow(\"if (this.$L != null)\", formatName(field));\n            fieldMethodBuilder.addStatement(\"return $L\", formatName(field));\n            fieldMethodBuilder.endControlFlow();\n        }", "        if (field.getTypeRef().isScalar() && !isIdToConvert(field) && !\"Query\".equals(field.getParentObject().getName())) {\n            fieldMethodBuilder.beginControlFlow(\"if (this.$L != null)\", formatName(field));\n            fieldMethodBuilder.addStatement(\"return $L\", formatName(field));\n            fieldMethodBuilder.endControlFlow();\n        }\n        if (field.hasArgs()) {\n            fieldMethodBuilder.addStatement(\"Arguments.Builder builder = Arguments.newBuilder()\");\n        }\n        field.getRequiredArgs().forEach(arg -> fieldMethodBuilder.addStatement(\"builder.add($1S, $1L)\", arg.getName()));\n        if (field.hasArgs()) {\n            fieldMethodBuilder.addStatement(\"Arguments fieldArgs = builder.build()\");\n        }", "        if (field.hasArgs()) {\n            fieldMethodBuilder.addStatement(\"Arguments fieldArgs = builder.build()\");\n        }\n        if (withOptionalArgs && field.hasOptionalArgs()) {\n            fieldMethodBuilder.addStatement(\"fieldArgs = fieldArgs.merge(optArgs.toArguments())\");\n        }\n        if (field.hasArgs()) {\n            fieldMethodBuilder.addStatement(\"QueryBuilder nextQueryBuilder = this.queryBuilder.chain($S, fieldArgs)\", field.getName());\n        } else {\n            fieldMethodBuilder.addStatement(\"QueryBuilder nextQueryBuilder = this.queryBuilder.chain($S)\", field.getName());\n        }\n", "        if (field.getTypeRef().isListOfObject()) {\n            List<Field> arrayFields = getArrayField(field, getSchema());\n            CodeBlock block = arrayFields.stream().map(f -> CodeBlock.of(\"$S\", f.getName())).collect(CodeBlock.joining(\",\", \"List.of(\", \")\"));\n            fieldMethodBuilder.addStatement(\"nextQueryBuilder = nextQueryBuilder.chain($L)\", block);\n            fieldMethodBuilder.addStatement(\"return nextQueryBuilder.executeListQuery($L.class)\",\n                    field.getTypeRef().getListElementType().getName());\n            fieldMethodBuilder\n                    .addException(InterruptedException.class)\n                    .addException(ExecutionException.class)\n                    .addException(ClassName.bestGuess(\"DaggerQueryException\"));\n        } else if (field.getTypeRef().isList()) {\n            fieldMethodBuilder.addStatement(\"return nextQueryBuilder.executeListQuery($L.class)\",\n                    field.getTypeRef().getListElementType().getName());\n            fieldMethodBuilder\n                    .addException(InterruptedException.class)\n                    .addException(ExecutionException.class)\n                    .addException(ClassName.bestGuess(\"DaggerQueryException\"));", "        } else if (field.getTypeRef().isList()) {\n            fieldMethodBuilder.addStatement(\"return nextQueryBuilder.executeListQuery($L.class)\",\n                    field.getTypeRef().getListElementType().getName());\n            fieldMethodBuilder\n                    .addException(InterruptedException.class)\n                    .addException(ExecutionException.class)\n                    .addException(ClassName.bestGuess(\"DaggerQueryException\"));\n        } else if (isIdToConvert(field)) {\n            fieldMethodBuilder.addStatement(\"nextQueryBuilder.executeQuery()\");\n            fieldMethodBuilder.addStatement(\"return this\");\n            fieldMethodBuilder\n                    .addException(InterruptedException.class)\n                    .addException(ExecutionException.class)\n                    .addException(ClassName.bestGuess(\"DaggerQueryException\"));", "        } else if (field.getTypeRef().isObject()) {\n            fieldMethodBuilder.addStatement(\"return new $L(nextQueryBuilder)\", returnType);\n        } else {\n            fieldMethodBuilder.addStatement(\"return nextQueryBuilder.executeQuery($L.class)\", returnType);\n            fieldMethodBuilder\n                    .addException(InterruptedException.class)\n                    .addException(ExecutionException.class)\n                    .addException(ClassName.bestGuess(\"DaggerQueryException\"));\n        }\n\n        if (field.isDeprecated()) {\n            fieldMethodBuilder.addAnnotation(Deprecated.class);\n            fieldMethodBuilder.addJavadoc(\"\\n@deprecated $L\", field.getDeprecationReason());\n        }\n\n        classBuilder.addMethod(fieldMethodBuilder.build());\n    }\n\n    /**\n     * Builds the class containing the optional arguments.\n     * @param classBuilder\n     * @param field\n     * @param type\n     */\n    private void buildFieldArgumentsHelpers(TypeSpec.Builder classBuilder, Field field, Type type) {\n        String fieldArgumentsClassName = capitalize(formatName(field))+\"Arguments\";\n\n        /* Inner class XXXArguments */\n        TypeSpec.Builder fieldArgumentsClassBuilder = TypeSpec\n                .classBuilder(fieldArgumentsClassName)\n                .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n        List<FieldSpec> optionalArgFields = field.getOptionalArgs().stream()\n                .map(arg -> FieldSpec.builder(\n                        \"id\".equals(arg.getName()) && \"Query\".equals(field.getParentObject().getName()) ?\n                                arg.getType().formatOutput() : arg.getType().formatInput(),\n                        arg.getName(),\n                        Modifier.PRIVATE).build())\n                .toList();\n        fieldArgumentsClassBuilder.addFields(optionalArgFields);\n\n        List<MethodSpec> optionalArgFieldWithMethods = field.getOptionalArgs().stream()\n                .map(arg -> withMethod(\n                        arg.getName(),\n                        \"id\".equals(arg.getName()) && \"Query\".equals(field.getParentObject().getName()) ?\n                                arg.getType().formatOutput() : arg.getType().formatInput(),\n                        ClassName.bestGuess(fieldArgumentsClassName),\n                        arg.getDescription()))\n                .toList();\n        fieldArgumentsClassBuilder.addMethods(optionalArgFieldWithMethods);\n\n        List<CodeBlock> blocks = field.getOptionalArgs().stream()\n                .map(arg -> CodeBlock.builder()", "        if (field.isDeprecated()) {\n            fieldMethodBuilder.addAnnotation(Deprecated.class);\n            fieldMethodBuilder.addJavadoc(\"\\n@deprecated $L\", field.getDeprecationReason());\n        }\n\n        classBuilder.addMethod(fieldMethodBuilder.build());\n    }\n\n    /**\n     * Builds the class containing the optional arguments.\n     * @param classBuilder\n     * @param field\n     * @param type\n     */\n    private void buildFieldArgumentsHelpers(TypeSpec.Builder classBuilder, Field field, Type type) {\n        String fieldArgumentsClassName = capitalize(formatName(field))+\"Arguments\";\n\n        /* Inner class XXXArguments */\n        TypeSpec.Builder fieldArgumentsClassBuilder = TypeSpec\n                .classBuilder(fieldArgumentsClassName)\n                .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n        List<FieldSpec> optionalArgFields = field.getOptionalArgs().stream()\n                .map(arg -> FieldSpec.builder(\n                        \"id\".equals(arg.getName()) && \"Query\".equals(field.getParentObject().getName()) ?\n                                arg.getType().formatOutput() : arg.getType().formatInput(),\n                        arg.getName(),\n                        Modifier.PRIVATE).build())\n                .toList();\n        fieldArgumentsClassBuilder.addFields(optionalArgFields);\n\n        List<MethodSpec> optionalArgFieldWithMethods = field.getOptionalArgs().stream()\n                .map(arg -> withMethod(\n                        arg.getName(),\n                        \"id\".equals(arg.getName()) && \"Query\".equals(field.getParentObject().getName()) ?\n                                arg.getType().formatOutput() : arg.getType().formatInput(),\n                        ClassName.bestGuess(fieldArgumentsClassName),\n                        arg.getDescription()))\n                .toList();\n        fieldArgumentsClassBuilder.addMethods(optionalArgFieldWithMethods);\n\n        List<CodeBlock> blocks = field.getOptionalArgs().stream()\n                .map(arg -> CodeBlock.builder()", "                        .beginControlFlow(\"if ($1L != null)\", arg.getName())\n                        .addStatement(\"builder.add($1S, this.$1L)\", arg.getName())\n                        .endControlFlow()\n                        .build()).toList();\n        MethodSpec toArguments = MethodSpec.methodBuilder(\"toArguments\")\n                .returns(ClassName.bestGuess(\"Arguments\"))\n                .addStatement(\"Arguments.Builder builder = Arguments.newBuilder()\")\n                .addCode(CodeBlock.join(blocks, \"\\n\"))\n                .addStatement(\"\\nreturn builder.build()\")\n                .build();\n        fieldArgumentsClassBuilder.addMethod(toArguments);\n        fieldArgumentsClassBuilder.addJavadoc(\"Optional arguments for {@link $L#$L}\\n\\n\", ClassName.bestGuess(Helpers.formatName(type)), formatName(field));\n        // fieldArgumentsClassBuilder.addJavadoc(\"@see $T\", ClassName.bestGuess(fieldArgumentsBuilderClassName));\n        classBuilder.addType(fieldArgumentsClassBuilder.build());\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/QueryType.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\npublic class QueryType {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override", "    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/Field.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport jakarta.json.bind.annotation.JsonbProperty;\nimport jakarta.json.bind.annotation.JsonbTransient;\n\nimport java.util.List;\n\npublic class Field {\n\n    private String name;\n    private String description;\n    @JsonbProperty(\"type\")\n    private TypeRef typeRef;\n    private List<InputValue> args;\n    @JsonbProperty(\"isDeprecated\")\n    private boolean deprecated; // isDeprecated\n    private String DeprecationReason;\n\n    @JsonbTransient\n    private List<InputValue> optionalArgs;\n\n    private Type parentObject;\n", "    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n", "    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = \"<p>\" + description.replace(\"\\n\", \"<br/>\") + \"</p>\";\n    }\n\n    public TypeRef getTypeRef() {\n        return typeRef;\n    }\n", "    public TypeRef getTypeRef() {\n        return typeRef;\n    }\n\n    public void setTypeRef(TypeRef typeRef) {\n        this.typeRef = typeRef;\n    }\n\n    public List<InputValue> getArgs() {\n        return args;\n    }\n", "    public void setArgs(List<InputValue> args) {\n        this.args = args;\n    }\n\n    public boolean isDeprecated() {\n        return deprecated;\n    }\n\n    public void setDeprecated(boolean deprecated) {\n        this.deprecated = deprecated;\n    }\n", "    public void setDeprecated(boolean deprecated) {\n        this.deprecated = deprecated;\n    }\n\n    public String getDeprecationReason() {\n        return DeprecationReason;\n    }\n\n    public void setDeprecationReason(String deprecationReason) {\n        DeprecationReason = deprecationReason;\n    }\n", "    public void setDeprecationReason(String deprecationReason) {\n        DeprecationReason = deprecationReason;\n    }\n\n    public Type getParentObject() {\n        return parentObject;\n    }\n\n    public void setParentObject(Type parentObject) {\n        this.parentObject = parentObject;\n    }\n\n    boolean hasArgs() {\n        return getArgs().size() > 0;\n    }\n\n    boolean hasOptionalArgs() {\n        return getArgs().stream().filter(arg -> arg.getType().isOptional()).count() > 0;\n    }\n\n    /**\n     * Returns the list of optional argument of this field\n     */\n    List<InputValue> getOptionalArgs() {", "    public void setParentObject(Type parentObject) {\n        this.parentObject = parentObject;\n    }\n\n    boolean hasArgs() {\n        return getArgs().size() > 0;\n    }\n\n    boolean hasOptionalArgs() {\n        return getArgs().stream().filter(arg -> arg.getType().isOptional()).count() > 0;\n    }\n\n    /**\n     * Returns the list of optional argument of this field\n     */\n    List<InputValue> getOptionalArgs() {", "        if (optionalArgs == null) {\n            optionalArgs = args.stream().filter(arg -> arg.getType().isOptional()).toList();\n        }\n        return optionalArgs;\n    }\n\n    List<InputValue> getRequiredArgs() {\n        return args.stream().filter(arg -> !arg.getType().isOptional()).toList();\n    }\n\n    @Override", "    public String toString() {\n        return \"Field{\" +\n                \"name='\" + name + '\\'' +\n                // \", description='\" + description + '\\'' +\n                \", args=\" + args +\n                \", deprecated=\" + deprecated +\n                // \", DeprecationReason='\" + DeprecationReason + '\\'' +\n                '}';\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/CodegenVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\n\npublic class CodegenVisitor implements SchemaVisitor {\n\n    private final ScalarVisitor scalarVisitor;\n    private final InputVisitor inputVisitor;\n    private final EnumVisitor enumVisitor;\n    private final ObjectVisitor objectVisitor;\n\n    public CodegenVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        this.scalarVisitor = new ScalarVisitor(schema, targetDirectory, encoding);\n        this.inputVisitor = new InputVisitor(schema, targetDirectory, encoding);\n        this.enumVisitor = new EnumVisitor(schema, targetDirectory, encoding);\n        this.objectVisitor = new ObjectVisitor(schema, targetDirectory, encoding);\n    }\n\n    @Override", "    public void visitScalar(Type type) {\n        try {\n            scalarVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void visitObject(Type type) {\n        try {\n            objectVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n\n    @Override", "    public void visitObject(Type type) {\n        try {\n            objectVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n\n    @Override", "    public void visitInput(Type type) {\n        try {\n            inputVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void visitEnum(Type type) {\n        try {\n            enumVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "    public void visitEnum(Type type) {\n        try {\n            enumVisitor.visit(type);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/Helpers.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.TypeName;\n\nimport javax.lang.model.element.Modifier;\nimport java.util.HashMap;\nimport java.util.List;", "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.apache.commons.lang3.StringUtils.capitalize;\n\npublic class Helpers {\n\n    private static final Map<String, String> CUSTOM_SCALARS = new HashMap<>() {{\n        put(\"ContainerID\", \"Container\");\n        put(\"FileID\", \"File\");\n        put(\"DirectoryID\", \"Directory\");\n        put(\"SecretID\", \"Secret\");\n        put(\"SocketID\",\"Socket\");\n        put(\"CacheID\",\"CacheVolume\");\n        put(\"ProjectID\",\"Project\");\n        put(\"ProjectCommandID\", \"ProjectCommand\");\n    }};\n\n    static boolean isScalar(String typeName) {\n        return CUSTOM_SCALARS.containsKey(typeName) || \"Platform\".equals(typeName);\n    }\n\n    static ClassName convertScalarToObject(String typeName) {", "        if (\"Platform\".equals(typeName)) {\n            return ClassName.bestGuess(typeName);\n        }\n        if (CUSTOM_SCALARS.containsKey(typeName)) {\n                return ClassName.bestGuess(CUSTOM_SCALARS.get(typeName));\n        }\n        throw new IllegalArgumentException(String.format(\"Unsupported Scalar type: %s\", typeName));\n    }\n\n    /**\n     * returns true if the field returns an ID that should be converted into an object.\n     */\n    static boolean isIdToConvert(Field field) {\n        return !\"id\".equals(field.getName()) &&\n                field.getTypeRef().isScalar() &&\n                field.getParentObject().getName().equals(CUSTOM_SCALARS.get(field.getTypeRef().getTypeName()));\n    }\n\n    static List<Field> getArrayField(Field field, Schema schema) {\n        TypeRef fieldType = field.getTypeRef();", "        if (! fieldType.isOptional()) {\n            fieldType = fieldType.getOfType();\n        }\n        if (! fieldType.isList()) {\n            throw new IllegalArgumentException(\"field is not a list\");\n        }\n        fieldType = fieldType.getOfType();\n        if (! fieldType.isOptional()) {\n            fieldType = fieldType.getOfType();\n        }\n        final String typeName = fieldType.getName();\n        Type schemaType = schema.getTypes().stream()\n                .filter(t -> typeName.equals(t.getName()))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\n                        String.format(\"Schema type %s not found\", typeName)));\n        return schemaType.getFields().stream().filter(f -> f.getTypeRef().isScalar()).toList();\n    }\n\n    static String formatName(Type type) {", "        if (\"Query\".equals(type.getName())) {\n            return \"Client\";\n        } else {\n            return capitalize(type.getName());\n        }\n    }\n\n    static String formatName(Field field) {\n        if (\"Container\".equals(field.getParentObject().getName()) && \"import\".equals(field.getName())) {\n            return \"importTarball\";\n        } else {\n            return field.getName();\n        }\n    }\n\n    static MethodSpec getter(String var, TypeName type) {\n        String prefix = (TypeName.BOOLEAN.equals(type) || ClassName.get(Boolean.class).equals(type)) ? \"is\" : \"get\";\n        return MethodSpec.methodBuilder(prefix + capitalize(var))\n                .addModifiers(Modifier.PUBLIC)\n                .returns(type)\n                .addStatement(\"return this.$L\", var)\n                .build();\n    }\n\n    static MethodSpec setter(String var, TypeName type) {\n        return MethodSpec.methodBuilder(\"set\" + capitalize(var))\n                .addModifiers(Modifier.PUBLIC)\n                .addParameter(ParameterSpec.builder(type, var).build())\n                .addStatement(\"this.$1L = $1L\", var)\n                .build();\n    }\n\n    /**\n     * Fix using '$' char in javadoc\n      */\n    static String escapeJavadoc(String str) {\n        return str.replace(\"$\", \"$$\");\n    }\n}\n", "        if (\"Container\".equals(field.getParentObject().getName()) && \"import\".equals(field.getName())) {\n            return \"importTarball\";\n        } else {\n            return field.getName();\n        }\n    }\n\n    static MethodSpec getter(String var, TypeName type) {\n        String prefix = (TypeName.BOOLEAN.equals(type) || ClassName.get(Boolean.class).equals(type)) ? \"is\" : \"get\";\n        return MethodSpec.methodBuilder(prefix + capitalize(var))\n                .addModifiers(Modifier.PUBLIC)\n                .returns(type)\n                .addStatement(\"return this.$L\", var)\n                .build();\n    }\n\n    static MethodSpec setter(String var, TypeName type) {\n        return MethodSpec.methodBuilder(\"set\" + capitalize(var))\n                .addModifiers(Modifier.PUBLIC)\n                .addParameter(ParameterSpec.builder(type, var).build())\n                .addStatement(\"this.$1L = $1L\", var)\n                .build();\n    }\n\n    /**\n     * Fix using '$' char in javadoc\n      */\n    static String escapeJavadoc(String str) {\n        return str.replace(\"$\", \"$$\");\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/EnumValue.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport jakarta.json.bind.annotation.JsonbProperty;\n\npublic class EnumValue {\n\n    private String name;\n    private String description;\n\n    @JsonbProperty(\"isDeprecated\")\n    private boolean deprecated; // isDeprecated\n    private String DeprecationReason;\n", "    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n", "    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description.replace(\"\\n\", \"<br/>\");\n    }\n\n    public boolean isDeprecated() {\n        return deprecated;\n    }\n", "    public boolean isDeprecated() {\n        return deprecated;\n    }\n\n    public void setDeprecated(boolean deprecated) {\n        this.deprecated = deprecated;\n    }\n\n    public String getDeprecationReason() {\n        return DeprecationReason;\n    }\n", "    public String getDeprecationReason() {\n        return DeprecationReason;\n    }\n\n    public void setDeprecationReason(String deprecationReason) {\n        DeprecationReason = deprecationReason;\n    }\n\n    @Override\n    public String toString() {\n        return \"EnumValue{\" +\n                \"name='\" + name + '\\'' +\n                // \", Description='\" + Description + '\\'' +\n                \", deprecated=\" + deprecated +\n                // \", DeprecationReason='\" + DeprecationReason + '\\'' +\n                '}';\n    }\n}\n", "    public String toString() {\n        return \"EnumValue{\" +\n                \"name='\" + name + '\\'' +\n                // \", Description='\" + Description + '\\'' +\n                \", deprecated=\" + deprecated +\n                // \", DeprecationReason='\" + DeprecationReason + '\\'' +\n                '}';\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/Schema.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport jakarta.json.bind.JsonbBuilder;\nimport jakarta.json.bind.annotation.JsonbProperty;\n\nimport static java.util.Comparator.comparing;", "\nimport static java.util.Comparator.comparing;\n\npublic class Schema {\n\n    public static class SchemaContainer {\n\n        @JsonbProperty(\"__schema\")\n        private Schema schema;\n\n        protected SchemaContainer() {}\n", "        public Schema getSchema() {\n            return schema;\n        }\n\n        public void setSchema(Schema schema) {\n            this.schema = schema;\n        }\n    }\n\n    public static Schema initialize(InputStream in) throws IOException {\n        JsonbBuilder builder = JsonbBuilder.newBuilder();\n        String str = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n        // System.out.println(str);\n        Schema schema = builder.build().fromJson(str, SchemaContainer.class).getSchema();\n        schema.types.forEach(type -> {", "    public static Schema initialize(InputStream in) throws IOException {\n        JsonbBuilder builder = JsonbBuilder.newBuilder();\n        String str = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n        // System.out.println(str);\n        Schema schema = builder.build().fromJson(str, SchemaContainer.class).getSchema();\n        schema.types.forEach(type -> {\n            if (type.getFields() != null) {\n                type.getFields().stream().forEach(field -> field.setParentObject(type));\n            }\n        });\n        return schema;\n        //Json.createReader(schema.getJsonObject(\"__schema\").)\n    }\n\n    private QueryType queryType;\n\n    private List<Type> types;\n", "    public QueryType getQueryType() {\n        return queryType;\n    }\n\n    public void setQueryType(QueryType queryType) {\n        this.queryType = queryType;\n    }\n\n    public List<Type> getTypes() {\n        return types;\n    }\n", "    public void setTypes(List<Type> types) {\n        this.types = types.stream().sorted(comparing(Type::getName)).toList();\n    }\n\n    public Type query() {\n        return types.stream().filter(type -> queryType.getName().equals(type.getName())).findFirst().get();\n    }\n\n    public void visit(SchemaVisitor visitor) {\n        List<Type> filteredTypes = types.stream().filter(t -> !t.getName().startsWith(\"__\")).toList();\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.SCALAR)\n                .filter(t -> !List.of(\"Boolean\", \"String\", \"Float\", \"Int\", \"DateTime\", \"ID\").contains(t.getName()))\n                .forEach(visitor::visitScalar);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.INPUT_OBJECT)\n                .forEach(visitor::visitInput);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.OBJECT)\n                .forEach(visitor::visitObject);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.ENUM)\n                .forEach(visitor::visitEnum);\n    }\n\n    @Override", "    public void visit(SchemaVisitor visitor) {\n        List<Type> filteredTypes = types.stream().filter(t -> !t.getName().startsWith(\"__\")).toList();\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.SCALAR)\n                .filter(t -> !List.of(\"Boolean\", \"String\", \"Float\", \"Int\", \"DateTime\", \"ID\").contains(t.getName()))\n                .forEach(visitor::visitScalar);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.INPUT_OBJECT)\n                .forEach(visitor::visitInput);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.OBJECT)\n                .forEach(visitor::visitObject);\n\n        filteredTypes.stream()\n                .filter(t -> t.getKind() == TypeKind.ENUM)\n                .forEach(visitor::visitEnum);\n    }\n\n    @Override", "    public String toString() {\n        return \"Schema{\" +\n                \"queryType=\" + queryType +\n                \", types=\" + types +\n                '}';\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/InputVisitor.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.*;\n\nimport javax.lang.model.element.Modifier;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\n", "import java.util.Map;\n\nclass InputVisitor extends AbstractVisitor {\n\n    public InputVisitor(Schema schema, Path targetDirectory, Charset encoding) {\n        super(schema, targetDirectory, encoding);\n    }\n\n    @Override\n    TypeSpec generateType(Type type) {", "    @Override\n    TypeSpec generateType(Type type) {\n        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(Helpers.formatName(type))\n                .addJavadoc(type.getDescription())\n                .addModifiers(Modifier.PUBLIC)\n                .addSuperinterface(ClassName.bestGuess(\"InputValue\"));\n\n        for (InputValue inputValue: type.getInputFields()) {\n\n            classBuilder.addField(FieldSpec.builder(\n                    inputValue.getType().formatInput(),\n                    inputValue.getName(),\n                    Modifier.PRIVATE).build());\n\n            classBuilder.addMethod(Helpers.getter(inputValue.getName(), inputValue.getType().formatInput()));\n            classBuilder.addMethod(Helpers.setter(inputValue.getName(), inputValue.getType().formatOutput()));\n        }\n\n        MethodSpec.Builder toMapMethod = MethodSpec.methodBuilder(\"toMap\")\n                .addModifiers(Modifier.PUBLIC)\n                .addAnnotation(Override.class)\n                .returns(ParameterizedTypeName.get(Map.class, String.class, Object.class))\n                .addStatement(\"$1T map = new $1T()\", ParameterizedTypeName.get(\n                        HashMap.class, String.class, Object.class));", "        for (InputValue inputValue: type.getInputFields()) {\n            toMapMethod.addStatement(\"map.put(\\\"$1L\\\", this.$1L)\", inputValue.getName());\n        }\n        toMapMethod.addStatement(\"return map\");\n        classBuilder.addMethod(toMapMethod.build());\n\n        return classBuilder.build();\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/TypeRef.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\n\nimport java.util.List;\n\npublic class TypeRef {\n\n    private TypeKind kind;\n    private String name;\n    private TypeRef ofType;\n", "public class TypeRef {\n\n    private TypeKind kind;\n    private String name;\n    private TypeRef ofType;\n\n    public TypeKind getKind() {\n        return kind;\n    }\n\n    public void setKind(TypeKind kind) {\n        this.kind = kind;\n    }\n", "    public void setKind(TypeKind kind) {\n        this.kind = kind;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n", "    public void setName(String name) {\n        this.name = name;\n    }\n\n    public TypeRef getOfType() {\n        return ofType;\n    }\n\n    public void setOfType(TypeRef ofType) {\n        this.ofType = ofType;\n    }\n", "    public void setOfType(TypeRef ofType) {\n        this.ofType = ofType;\n    }\n\n    public boolean isOptional() {\n        return kind != TypeKind.NON_NULL;\n    }\n\n    public boolean isScalar() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n       return ref.kind == TypeKind.SCALAR || ref.kind == TypeKind.ENUM;\n    }\n", "    public boolean isScalar() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n       return ref.kind == TypeKind.SCALAR || ref.kind == TypeKind.ENUM;\n    }\n\n    public boolean isObject() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.kind == TypeKind.OBJECT;\n    }\n", "    public boolean isObject() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.kind == TypeKind.OBJECT;\n    }\n\n    public boolean isList() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.kind == TypeKind.LIST;\n    }\n", "    public boolean isList() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.kind == TypeKind.LIST;\n    }\n\n    public boolean isListOfObject() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }", "    public boolean isListOfObject() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        if (ref.kind != TypeKind.LIST) {\n            return false;\n        }\n        ref = ref.getOfType();\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.isObject();\n    }\n", "        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ref.ofType;\n        }\n        return ref.isObject();\n    }\n\n    public TypeRef getListElementType() {\n        if (!isList()) {\n            throw new IllegalArgumentException(\"Type is not a list\");\n        }\n        TypeRef ref = this;", "        while (ref.kind == TypeKind.NON_NULL || ref.kind == TypeKind.LIST) {\n            ref = ref.ofType;\n        }\n        return ref;\n    }\n\n    public TypeName formatOutput() {\n        return formatType(false);\n    }\n\n    public TypeName formatInput() {\n        return formatType( true);\n    }\n\n    private TypeName formatType(boolean isInput) {", "    public TypeName formatInput() {\n        return formatType( true);\n    }\n\n    private TypeName formatType(boolean isInput) {\n        // if (typeRef == null) {\n        //    return \"void\";\n        //}\n        if (\"Query\".equals(getName())) {\n            return ClassName.bestGuess(\"Client\");\n        }\n        switch (getKind()) {\n            case SCALAR -> {\n                switch (getName()) {\n                    case \"String\" -> {\n                        return ClassName.get(String.class);\n                    }\n                    case \"Boolean\" -> {\n                        return ClassName.get(Boolean.class);\n                    }\n                    case \"Int\" -> {\n                        return ClassName.get(Integer.class);\n                    }\n                    default -> {", "        if (\"Query\".equals(getName())) {\n            return ClassName.bestGuess(\"Client\");\n        }\n        switch (getKind()) {\n            case SCALAR -> {\n                switch (getName()) {\n                    case \"String\" -> {\n                        return ClassName.get(String.class);\n                    }\n                    case \"Boolean\" -> {\n                        return ClassName.get(Boolean.class);\n                    }\n                    case \"Int\" -> {\n                        return ClassName.get(Integer.class);\n                    }\n                    default -> {", "                        if (!isInput) {\n                            return ClassName.bestGuess(getName());\n                        }\n                        return Helpers.convertScalarToObject(getName());\n//                        if (getName().endsWith(\"ID\") && isInput) {\n//                            return getName().substring(0, getName().length() - 2);\n//                        }\n//                        return getName();\n                    }\n                }\n            }\n            case OBJECT, ENUM, INPUT_OBJECT -> {\n                return ClassName.bestGuess(getName());\n            }\n            case LIST -> {\n                return ParameterizedTypeName.get(ClassName.get(List.class), getOfType().formatType(isInput));\n                // return String.format(\"List<%s>\", getOfType().formatType(isInput));\n            }\n            default -> {\n                return getOfType().formatType(isInput);\n            }\n        }\n    }\n", "    public String getTypeName() {\n        TypeRef ref = this;\n        if (ref.kind == TypeKind.NON_NULL) {\n            ref = ofType;\n        }\n        return ref.getName();\n    }\n}\n"]}
{"filename": "dagger-codegen-maven-plugin/src/main/java/org/chelonix/dagger/codegen/introspection/TypeKind.java", "chunked_list": ["package org.chelonix.dagger.codegen.introspection;\n\npublic enum TypeKind {\n\n    SCALAR(\"SCALAR\"),\n    OBJECT(\"OBJECT\"),\n    INTERFACE(\"INTERFACE\"),\n    UNION(\"UNION\"),\n    ENUM(\"ENUM\"),\n    INPUT_OBJECT(\"INPUT_OBJECT\"),\n    LIST(\"LIST\"),\n    NON_NULL(\"NON_NULL\");\n\n    private final String kind;\n    TypeKind(String kind) {\n        this.kind = kind;\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/TestWithDatabase.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Container;\nimport org.chelonix.dagger.client.Dagger;\n\nimport java.util.List;\n\npublic class TestWithDatabase {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n\n            // get MariaDB base image\n            Container mariadb = client.container()\n                    .from(\"mariadb:10.11.2\")\n                    .withEnvVariable(\"MARIADB_USER\", \"user\")\n                    .withEnvVariable(\"MARIADB_PASSWORD\", \"password\")\n                    .withEnvVariable(\"MARIADB_DATABASE\", \"drupal\")\n                    .withEnvVariable(\"MARIADB_ROOT_PASSWORD\", \"root\")\n                    .withExposedPort(3306);\n\n            // get Drupal base image\n            // install additional dependencies\n            Container drupal = client.container()\n                    .from(\"drupal:10.0.7-php8.2-fpm\")\n                    .withExec(List.of(\"composer\", \"require\", \"drupal/core-dev\", \"--dev\", \"--update-with-all-dependencies\"));\n\n            // add service binding for MariaDB\n            // run kernel tests using PHPUnit\n            String test = drupal\n                    .withServiceBinding(\"db\", mariadb)\n                    .withEnvVariable(\"SIMPLETEST_DB\", \"mysql://user:password@db/drupal\")\n                    .withEnvVariable(\"SYMFONY_DEPRECATIONS_HELPER\", \"disabled\")\n                    .withWorkdir(\"/opt/drupal/web/core\")\n                    .withExec(List.of(\"../../vendor/bin/phpunit\", \"-v\", \"--group\", \"KernelTests\"))\n                    .stdout();\n\n            System.out.println(test);\n        }\n    }\n}\n\n", "public class TestWithDatabase {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n\n            // get MariaDB base image\n            Container mariadb = client.container()\n                    .from(\"mariadb:10.11.2\")\n                    .withEnvVariable(\"MARIADB_USER\", \"user\")\n                    .withEnvVariable(\"MARIADB_PASSWORD\", \"password\")\n                    .withEnvVariable(\"MARIADB_DATABASE\", \"drupal\")\n                    .withEnvVariable(\"MARIADB_ROOT_PASSWORD\", \"root\")\n                    .withExposedPort(3306);\n\n            // get Drupal base image\n            // install additional dependencies\n            Container drupal = client.container()\n                    .from(\"drupal:10.0.7-php8.2-fpm\")\n                    .withExec(List.of(\"composer\", \"require\", \"drupal/core-dev\", \"--dev\", \"--update-with-all-dependencies\"));\n\n            // add service binding for MariaDB\n            // run kernel tests using PHPUnit\n            String test = drupal\n                    .withServiceBinding(\"db\", mariadb)\n                    .withEnvVariable(\"SIMPLETEST_DB\", \"mysql://user:password@db/drupal\")\n                    .withEnvVariable(\"SYMFONY_DEPRECATIONS_HELPER\", \"disabled\")\n                    .withWorkdir(\"/opt/drupal/web/core\")\n                    .withExec(List.of(\"../../vendor/bin/phpunit\", \"-v\", \"--group\", \"KernelTests\"))\n                    .stdout();\n\n            System.out.println(test);\n        }\n    }\n}\n\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/Main.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Main {\n\n    private static final Class[] SAMPLES = new Class[] {\n            RunContainer.class,\n            GetDaggerWebsite.class,\n            ListEnvVars.class,\n            MountHostDirectoryInContainer.class,\n            ListHostDirectoryContents.class,\n            ReadFileInGitRepository.class,\n            GetGitVersion.class,\n            CreateAndUseSecret.class,\n            TestWithDatabase.class\n    };\n", "    public static void main(String... args) {\n        System.console().printf(\"=== Dagger.io Java SDK samples ===\\n\");\n        while (true) {\n            for (int i = 0; i < SAMPLES.length; i++) {\n                System.console().printf(\"  %d - %s\\n\", i+1, SAMPLES[i].getName());\n            }\n            System.console().printf(\"  q - exit\\n\");\n            String input = System.console().readLine(\"\\nSelect sample: \");\n            try {\n                if (\"q\".equals(input)) {\n                    System.exit(0);\n                }\n                int index = Integer.parseInt(input);", "            try {\n                if (\"q\".equals(input)) {\n                    System.exit(0);\n                }\n                int index = Integer.parseInt(input);\n                if (index < 1 || index > SAMPLES.length) {\n                    continue;\n                }\n                Class klass = SAMPLES[index-1];\n                Method m = klass.getMethod(\"main\", new String[0].getClass());\n                m.invoke(klass, new Object[] {new String[0]});\n                System.console().printf(\"\\n\");\n            } catch (NumberFormatException nfe) {\n            } catch (NoSuchMethodException e) {\n            } catch (InvocationTargetException e) {\n            } catch (IllegalAccessException e) {\n            }\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/GetGitVersion.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.*;\n\nimport java.util.List;\n\npublic class GetGitVersion {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            Directory dir = client.git(\"https://github.com/dagger/dagger\").tag(\"v0.6.2\").tree();\n\n            Container daggerImg = client.container().build(dir);\n\n            String stdout = daggerImg.withExec(List.of(\"version\")).stdout();\n            System.out.println(stdout);\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/CreateAndUseSecret.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.*;\n\nimport java.util.List;\n\npublic class CreateAndUseSecret {\n    public static void main(String... args) throws Exception {\n        String token = System.getenv(\"GH_API_TOKEN\");\n        if (token == null) {\n            token = new String(System.console().readPassword(\"GithHub API token: \"));\n        }\n        try(Client client = Dagger.connect()) {\n            Secret secret = client.setSecret(\"ghApiToken\", token);\n\n            // use secret in container environment\n            String out = client.container()\n                    .from(\"alpine:3.17\")\n                    .withSecretVariable(\"GITHUB_API_TOKEN\", secret)\n                    .withExec(List.of(\"apk\", \"add\", \"curl\"))\n                    .withExec(List.of(\"sh\", \"-c\", \"curl \\\"https://api.github.com/repos/dagger/dagger/issues\\\" --header \\\"Accept: application/vnd.github+json\\\" --header \\\"Authorization: Bearer $GITHUB_API_TOKEN\\\"\"))\n                    .stdout();\n\n            // print result\n            System.out.println(out);\n        }\n    }\n}\n", "        if (token == null) {\n            token = new String(System.console().readPassword(\"GithHub API token: \"));\n        }\n        try(Client client = Dagger.connect()) {\n            Secret secret = client.setSecret(\"ghApiToken\", token);\n\n            // use secret in container environment\n            String out = client.container()\n                    .from(\"alpine:3.17\")\n                    .withSecretVariable(\"GITHUB_API_TOKEN\", secret)\n                    .withExec(List.of(\"apk\", \"add\", \"curl\"))\n                    .withExec(List.of(\"sh\", \"-c\", \"curl \\\"https://api.github.com/repos/dagger/dagger/issues\\\" --header \\\"Accept: application/vnd.github+json\\\" --header \\\"Authorization: Bearer $GITHUB_API_TOKEN\\\"\"))\n                    .stdout();\n\n            // print result\n            System.out.println(out);\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/GetDaggerWebsite.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Dagger;\n\nimport java.util.List;\n\npublic class GetDaggerWebsite {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String output = client.pipeline(\"test\")\n                    .container()\n                    .from(\"alpine\")\n                    .withExec(List.of(\"apk\", \"add\", \"curl\"))\n                    .withExec(List.of(\"curl\", \"https://dagger.io\"))\n                    .stdout();\n\n            System.out.println(output.substring(0, 300));\n        }\n    }\n}\n", "    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String output = client.pipeline(\"test\")\n                    .container()\n                    .from(\"alpine\")\n                    .withExec(List.of(\"apk\", \"add\", \"curl\"))\n                    .withExec(List.of(\"curl\", \"https://dagger.io\"))\n                    .stdout();\n\n            System.out.println(output.substring(0, 300));\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/ListHostDirectoryContents.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Dagger;\nimport org.chelonix.dagger.client.EnvVariable;\n\nimport java.util.List;\n\npublic class ListHostDirectoryContents {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            List<String> entries = client.host().directory(\".\").entries();\n            entries.stream().forEach(System.out::println);\n        }\n    }\n}\n", "public class ListHostDirectoryContents {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            List<String> entries = client.host().directory(\".\").entries();\n            entries.stream().forEach(System.out::println);\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/MountHostDirectoryInContainer.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Dagger;\n\nimport java.util.List;\n\npublic class MountHostDirectoryInContainer {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String contents = client.container().from(\"alpine\").\n                    withDirectory(\"/host\", client.host().directory(\".\")).\n                    withExec(List.of(\"ls\", \"/host\")).\n                    stdout();\n\n            System.out.println(contents);\n        }\n    }\n}\n", "    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String contents = client.container().from(\"alpine\").\n                    withDirectory(\"/host\", client.host().directory(\".\")).\n                    withExec(List.of(\"ls\", \"/host\")).\n                    stdout();\n\n            System.out.println(contents);\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/ReadFileInGitRepository.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Dagger;\n\nimport java.io.BufferedReader;\nimport java.io.StringReader;\n\npublic class ReadFileInGitRepository {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String readme = client.git(\"https://github.com/dagger/dagger\")\n                    .tag(\"v0.3.0\")\n                    .tree()\n                    .file(\"README.md\")\n                    .contents();\n\n            System.out.println(new BufferedReader(new StringReader(readme)).readLine());\n\n            // Output: ## What is Dagger?\n        }\n    }\n}", "public class ReadFileInGitRepository {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            String readme = client.git(\"https://github.com/dagger/dagger\")\n                    .tag(\"v0.3.0\")\n                    .tree()\n                    .file(\"README.md\")\n                    .contents();\n\n            System.out.println(new BufferedReader(new StringReader(readme)).readLine());\n\n            // Output: ## What is Dagger?\n        }\n    }\n}"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/RunContainer.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.Client;\nimport org.chelonix.dagger.client.Container;\nimport org.chelonix.dagger.client.Dagger;\n\nimport java.util.List;\n\npublic class RunContainer {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            Container container = client.container()\n                    .from(\"maven:3.9.2\")\n                    .withExec(List.of(\"mvn\", \"--version\"));\n\n            String version = container.stdout();\n            System.out.println(\"Hello from Dagger and \" + version);\n        }\n    }\n}\n", "public class RunContainer {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            Container container = client.container()\n                    .from(\"maven:3.9.2\")\n                    .withExec(List.of(\"mvn\", \"--version\"));\n\n            String version = container.stdout();\n            System.out.println(\"Hello from Dagger and \" + version);\n        }\n    }\n}\n"]}
{"filename": "dagger-java-samples/src/main/java/org/chelonix/dagger/sample/ListEnvVars.java", "chunked_list": ["package org.chelonix.dagger.sample;\n\nimport org.chelonix.dagger.client.*;\n\nimport java.util.List;\n\npublic class ListEnvVars {\n    public static void main(String... args) throws Exception {\n        try(Client client = Dagger.connect()) {\n            List<EnvVariable> env = client.container()\n                    .from(\"alpine\")\n                    .withEnvVariable(\"MY_VAR\", \"some_value\")\n                    .envVariables();", "            for (EnvVariable var : env) {\n                System.out.printf(\"%s = %s\\n\", var.name(), var.value());\n            }\n        }\n    }\n}\n"]}
