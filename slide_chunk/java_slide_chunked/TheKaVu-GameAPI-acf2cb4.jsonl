{"filename": "src/main/java/dev/kavu/gameapi/GameStateInterruptException.java", "chunked_list": ["package dev.kavu.gameapi;\n\n/**\n * Thrown when uninterruptible is ended in an unnatural way. This includes:\n * <ul>\n * <li>Initializing new game state over this state</li>\n * <li>Terminating this state by hand when state is still running</li>\n * </ul>\n */\npublic class GameStateInterruptException extends Exception {\n\n    /**\n     * Creates new instance of <tt>GameStateInterruptException</tt> with no detail message.\n     */\n    public GameStateInterruptException() {\n        super(\"Tried to interrupt an uninterruptible state\");\n    }\n\n    /**\n     * Creates new instance of <tt>GameStateInterruptException</tt> with specified message.\n     */\n    public GameStateInterruptException(String message) {\n        super(message);\n    }\n}\n", " */\npublic class GameStateInterruptException extends Exception {\n\n    /**\n     * Creates new instance of <tt>GameStateInterruptException</tt> with no detail message.\n     */\n    public GameStateInterruptException() {\n        super(\"Tried to interrupt an uninterruptible state\");\n    }\n\n    /**\n     * Creates new instance of <tt>GameStateInterruptException</tt> with specified message.\n     */\n    public GameStateInterruptException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/GameState.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.apache.commons.lang.Validate;\n\n/**\n * Representation of the particular state of the game, split into sections operated by {@link GameStateTimer}. <br/>\n *\n * As this class is abstract, it can be instantiated directly. It is recommended to initialize it as an anonymous subclass, <i>final</i> and <i>static</i>: <pre>\n * public static final GameState gameState = new GameState(\"Game State\", 60, 1000, true, true) {\n *     &#64Override;\n *     public void onInit() {\n *         // Code here...\n *     }\n * }\n * </pre>\n */", " * public static final GameState gameState = new GameState(\"Game State\", 60, 1000, true, true) {\n *     &#64Override;\n *     public void onInit() {\n *         // Code here...\n *     }\n * }\n * </pre>\n */\npublic abstract class GameState {\n\n    // Constants\n    /**\n     * Plain, interruptible state with no functionality; replacement for the {@code null} value.\n     */", "public abstract class GameState {\n\n    // Constants\n    /**\n     * Plain, interruptible state with no functionality; replacement for the {@code null} value.\n     */\n    public static final GameState EMPTY = new GameState(\"\",0, false) {\n        @Override\n        public void onInit() {\n        }\n\n        @Override", "        public void onInit() {\n        }\n\n        @Override\n        public void onEnd() {\n        }\n\n        @Override\n        public void tick() {\n\n        }\n\n        @Override", "        public void tick() {\n\n        }\n\n        @Override\n        public boolean shouldEnd() {\n            return false;\n        }\n    };\n\n    // Fields\n    private final long duration;\n\n    private final int period;\n\n    private final boolean reverseTimer;\n\n    private final boolean interruptible;\n\n    private final String name;\n\n    // Constructors\n\n    /**\n     * Creates the new instance of <tt>GameState</tt> class with specific name and duration expressed in milliseconds, interruptible by default. As period is not specified, it is equal to {@code 1}.\n     * @param name Name of this state\n     * @param duration Duration of this state expressed in milliseconds\n     * @param reverseTimer If {@code true}, timer will count back from the duration down to {@code 0}\n     */\n    public GameState(String name, long duration, boolean reverseTimer) {\n        Validate.notNull(name, \"name cannot be null\");\n\n        this.name = name;\n        this.duration = duration;\n        this.period = 1;\n        this.reverseTimer = reverseTimer;\n        this.interruptible = true;\n    }\n\n    /**\n     * Creates the new instance of <tt>GameState</tt> class with specific name and duration of periods of specific length expressed in milliseconds.\n     * @param name Name of this state\n     * @param duration Duration of this state expressed periods\n     * @param period Period duration expressed in milliseconds, time between two following timer iterations\n     * @param reverseTimer If {@code true}, timer will count back from the duration down to {@code 0}\n     * @param interruptible Determines if this state can be interrupted (ex. when other state is initialized meanwhile)\n     */\n    public GameState(String name, long duration, int period, boolean reverseTimer, boolean interruptible) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.isTrue(period > 0, \"period must be greater than 0\");\n\n        this.name = name;\n        this.duration = duration;\n        this.period = period;\n        this.reverseTimer = reverseTimer;\n        this.interruptible = interruptible;\n    }\n\n    // Getters\n\n    /**\n     * @return Name of this state\n     */", "    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return Duration of this state expressed in periods\n     */\n    public long getDuration() {\n        return duration;\n    }\n\n    /**\n     * @return Duration of single period, time between two following timer iterations\n     */", "    public int getPeriod() {\n        return period;\n    }\n\n    /**\n     * @return {@code true} if the timer counting type shall be reversed\n     */\n    public boolean doesReverseTimer() {\n        return reverseTimer;\n    }\n\n    /**\n     * @return {@code true} if the state can be interrupted\n     */", "    public boolean isInterruptible() {\n        return interruptible;\n    }\n\n    // Functionality\n\n    /**\n     * An action to be performed when the state is initialized.\n     */\n    public void onInit() { }\n\n    /**\n     * An action to be performed on each timer iteration.\n     */", "    public void onInit() { }\n\n    /**\n     * An action to be performed on each timer iteration.\n     */\n    public void tick() { }\n\n    /**\n     * An action to be performed any time the state is ended.\n     */\n    public void onEnd() { }\n\n    /**\n     * Called on each timer iteration, determines if state should be ended or not.\n     * @return {@code true} if current state should be terminated, {@code false} by default\n     */", "    public void onEnd() { }\n\n    /**\n     * Called on each timer iteration, determines if state should be ended or not.\n     * @return {@code true} if current state should be terminated, {@code false} by default\n     */\n    public boolean shouldEnd() {\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/GstSchedule.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.apache.commons.lang.Validate;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This class is used to define a schedule for {@link GameStateTimer}. Schedule behaves similar to queue of {@link GameState} objects, but the index of element can be warped backwards.\n * States will be initialized automatically after natural end; when interrupted, they won't unless specified.", " * This class is used to define a schedule for {@link GameStateTimer}. Schedule behaves similar to queue of {@link GameState} objects, but the index of element can be warped backwards.\n * States will be initialized automatically after natural end; when interrupted, they won't unless specified.\n */\npublic class GstSchedule {\n\n    private final List<GameState> schedule;\n    private int index = -1;\n\n    /**\n     * Creates new instance of GstSchedule with no states.\n     */\n    public GstSchedule(){\n        schedule = new ArrayList<>();\n    }\n\n    /**\n     * Creates new instance of GstSchedule with initial order of states. First element in the list is the first element in the schedule.\n     *\n     * @param schedule Initial order of game states\n     */\n    public GstSchedule(List<GameState> schedule) {\n        Validate.notNull(schedule, \"schedule cannot be null\");\n        this.schedule = schedule;\n    }\n\n    /**\n     * Adds specified game state at the end of the schedule.\n     *\n     * @param gameState State to be added\n     */", "    public void addState(GameState gameState){\n        Validate.notNull(gameState, \"gameState cannot be null\");\n        schedule.add(gameState);\n    }\n    /**\n     * Adds specified game states at the end of the schedule in listed order.\n     *\n     * @param gameStates States to be added\n     */\n    public void addStates(List<GameState> gameStates){\n        schedule.addAll(gameStates);\n    }\n    /**\n     * @return State the iterator is at currently\n     */", "    public void addStates(List<GameState> gameStates){\n        schedule.addAll(gameStates);\n    }\n    /**\n     * @return State the iterator is at currently\n     */\n    public GameState getCurrent() {\n        if(index < schedule.size()) {\n            return schedule.get(index);\n        }\n        return GameState.EMPTY;\n    }\n\n    /**\n     * Increments the iterator and returns the state it is at.\n     *\n     * @return Next game state in the schedule, {@link GameState#EMPTY} if such doesn't exist\n     */", "    public GameState next() {\n        GameState state;\n        if(index + 1 < schedule.size()) {\n            index++;\n            state = schedule.get(index);\n        } else {\n            state = GameState.EMPTY;\n        }\n        return state;\n    }\n\n    /**\n     * @return {@code true} if the schedule reached the end, {@code false} otherwise\n     */", "    public boolean isDone(){\n        return index >= schedule.size();\n    }\n\n    /**\n     * Sets iterator to the first element of the schedule.\n     */\n    public void redo(){\n        index = 0;\n    }\n\n    /**\n     * Sets iterator to the nonexistent element at the end of the schedule.\n     */", "    public void skip(){\n        index = schedule.size();\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/GameEngine.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.bukkit.plugin.java.JavaPlugin;\n\n/**\n * The abstract class being the root for all the game engine plugins. It works as the {@link JavaPlugin} class, but provides some additional methods significant for the game.\n */\npublic abstract class GameEngine extends JavaPlugin {\n\n    /**\n     * @return Game info represented by {@link Game} object\n     */", "    public abstract Game getGame();\n\n    /**\n     * @return {@link GameManager} object, which controls the whole game\n     */\n    public abstract GameManager getGameManager();\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/GameManager.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport dev.kavu.gameapi.statistic.Statistic;\nimport dev.kavu.gameapi.statistic.RegisteredStatistic;\nimport dev.kavu.gameapi.world.MapManager;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\n\nimport java.util.*;", "\nimport java.util.*;\n\n/**\n * This class contains all the game controls and dynamic data. Also, it stores the registry of statistics for specific game. Moreover, it keeps the rules of the game. <br/>\n * The {@code GameManager} class does not have specific functionality. It consists of smaller managers and controls and associates them together.\n *\n * @see GameStateTimer\n * @see MapManager\n * @see RuleSet", " * @see MapManager\n * @see RuleSet\n * @see Statistic\n */\npublic class GameManager {\n\n    // Fields\n\n    private final Plugin plugin;\n\n    private final GameStateTimer gameStateTimer;\n\n    private final HashSet<UUID> players = new HashSet<>();\n\n    private final HashMap<Class<? extends Statistic>, RegisteredStatistic<?>> statistics = new HashMap<>();\n\n    private final RuleSet rules = new RuleSet();\n\n    private final MapManager mapManager;\n\n    // Constructors\n\n    /**\n     * Creates the new instance of <tt>GameManager</tt> class in the most minimalistic way, basing just on the {@link Plugin} object.\n     * @param plugin Plugin this manager runs for\n     */\n    public GameManager(Plugin plugin) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.plugin = plugin;\n        gameStateTimer = new GameStateTimer(plugin);\n        mapManager = new MapManager();\n    }\n\n    /**\n     * Creates the new instance of <tt>GameManager</tt> class with the custom {@link GameStateTimer}.\n     * @param plugin Plugin this manager runs for\n     * @param gameStateTimer Custom dedicated <tt>GameStateTimer</tt>\n     */\n    public GameManager(Plugin plugin, GameStateTimer gameStateTimer) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n        Validate.notNull(gameStateTimer, \"gameStateTimer cannot be null\");\n\n        this.plugin = plugin;\n        this.gameStateTimer = gameStateTimer;\n        mapManager = new MapManager();\n    }\n\n    /**\n     * Creates the new instance of <tt>GameManager</tt> class with the custom {@link MapManager}. Although, it is instantiated with no-args constructor, thus it is the option for its subclasses.\n     * @param plugin Plugin this manager runs for\n     * @param mapManager Custom dedicated map manager\n     */\n    public GameManager(Plugin plugin, MapManager mapManager) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n        Validate.notNull(mapManager, \"mapManager cannot be null\");\n\n        this.plugin = plugin;\n        gameStateTimer = new GameStateTimer(plugin);\n        this.mapManager = mapManager;\n    }\n\n    /**\n     * Creates the new instance of <tt>GameManager</tt> class with initial collection of players. Passed collection contains players considered as taking part in this game.\n     * The following collection will be mapped to the {@code HashSet&lt;UUID&gt;}, where {@link UUID} object is the uuid of the player.\n     * @param plugin Plugin this manager runs for\n     * @param players Players playing this game\n     */\n    public GameManager(Plugin plugin, Collection<? extends Player> players) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n        Validate.notNull(players, \"players cannot be null\");\n\n        this.plugin = plugin;\n        gameStateTimer = new GameStateTimer(plugin);\n        mapManager = new MapManager();", "        for(Player p : players){\n            this.players.add(p.getUniqueId());\n        }\n    }\n\n    /**\n     * Creates the new instance of <tt>GameManager</tt> class in the most explicit way, as allows a lot of customization.It accepts custom {@link GameStateTimer}, {@link MapManager} and the initial players' collection.\n     * The following collection will be mapped to the {@code HashSet&lt;UUID&gt;}, where {@link UUID} object is the uuid of the player.\n     * @param plugin Plugin this manager runs for\n     * @param gameStateTimer Custom dedicated timer\n     * @param mapManager Custom dedicated map manager\n     * @param players Players playing this game\n     */\n    public GameManager(Plugin plugin, GameStateTimer gameStateTimer, MapManager mapManager, Collection<? extends Player> players) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n        Validate.notNull(gameStateTimer, \"gameStateTimer cannot be null\");\n        Validate.notNull(mapManager, \"mapManager cannot be null\");\n        Validate.notNull(players, \"players cannot be null\");\n\n        this.plugin = plugin;\n        this.gameStateTimer = gameStateTimer;\n        this.mapManager = mapManager;", "        for(Player p : players){\n            this.players.add(p.getUniqueId());\n        }\n    }\n\n    // Getters\n\n    /**\n     * @return Plugin this manager runs for\n     */\n    public Plugin getPlugin() {\n        return plugin;\n    }\n\n    /**\n     * @return Associated {@link GameStateTimer} object\n     */", "    public Plugin getPlugin() {\n        return plugin;\n    }\n\n    /**\n     * @return Associated {@link GameStateTimer} object\n     */\n    public GameStateTimer getGameStateTimer() {\n        return gameStateTimer;\n    }\n\n    /**\n     * @return {@link MapManager} object controlling the map actions in this game\n     */", "    public MapManager getMapManager() {\n        return mapManager;\n    }\n\n    /**\n     * @return {@link MapManager} object controlling the map actions in this game\n     */\n    public HashSet<UUID> getPlayers() {\n        return players;\n    }\n\n    /**\n     * @return Rules of this game represented by {@link RuleSet} object\n     */", "    public RuleSet getRules() {\n        return rules;\n    }\n\n    /**\n     * Registers the specified statistic by mapping its class to automatically created {@link RegisteredStatistic} object. Same statistic <b>cannot</b> be registered more than once. Future attempts will have no effect.\n     * @param statistic Statistic base represented by {@link Statistic} object\n     */\n    public void registerStatistic(Statistic<?> statistic){\n        Validate.notNull(statistic, \"statistic cannot be null\");\n\n        statistics.putIfAbsent(statistic.getClass(), new RegisteredStatistic<>(statistic, plugin));\n    }\n\n    /**\n     * Registers the specified statistic by mapping its class to automatically created {@link RegisteredStatistic} object. Same statistic <b>cannot</b> be registered more than once. Future attempts will have no effect.\n     * @param statistic Statistic base represented by {@link Statistic} object\n     * @param initialMembers Initial collection of members for this statistic\n     */", "    public void registerStatistic(Statistic<?> statistic){\n        Validate.notNull(statistic, \"statistic cannot be null\");\n\n        statistics.putIfAbsent(statistic.getClass(), new RegisteredStatistic<>(statistic, plugin));\n    }\n\n    /**\n     * Registers the specified statistic by mapping its class to automatically created {@link RegisteredStatistic} object. Same statistic <b>cannot</b> be registered more than once. Future attempts will have no effect.\n     * @param statistic Statistic base represented by {@link Statistic} object\n     * @param initialMembers Initial collection of members for this statistic\n     */", "    public void registerStatistic(Statistic<?> statistic, Collection<UUID> initialMembers){\n        Validate.notNull(statistic, \"statistic cannot be null\");\n\n        statistics.putIfAbsent(statistic.getClass(), new RegisteredStatistic<>(statistic, initialMembers, plugin));\n    }\n\n    /**\n     * Returns the registered statistic by its class represented by {@link RegisteredStatistic} object.\n     * @param clazz Class of desired statistic\n     * @param <N> Numeric type; class or subclass of {@link Number}\n     * @param <E> Statistic type; class or subclass of {@link Statistic}\n     * @return If registry exists, <tt>RegisteredStatistic</tt> object of this statistic, otherwise {@code null}\n     */\n    public <N extends Number, E extends Statistic<N>> RegisteredStatistic<N> getRegisteredStatistic(Class<E> clazz){\n        Validate.notNull(clazz, \"clazz cannot be null\");\n\n        return (RegisteredStatistic<N>) statistics.get(clazz);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/Await.java", "chunked_list": ["package dev.kavu.gameapi;\n\n/**\n * Subclass of {@link GameState} class used to create a time gap between separate states. As this class is in fact a <tt>GameState</tt>, it can be also added to the schedule.\n */\npublic final class Await extends GameState{\n\n    /**\n     * Creates new instance of <tt>Await</tt> class with specific duration.\n     * @param duration Duration of this state expressed in milliseconds\n     */\n    public Await(long duration) {\n        super(\"await\", duration, false);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/Game.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.apache.commons.lang.Validate;\n\nimport java.util.Properties;\n\n/**\n * Abstract class being the base for any game. Contains major information about the game. Games can also be categorized using {@link Category} interface.\n */\npublic abstract class Game {\n\n    // Fields\n    private final String name;\n\n    private final String systemName;\n\n    private final String prefix;\n\n    private final int minPlayers;\n\n    private final int maxPlayers;\n\n    private final Properties properties;\n\n    // Constructors\n\n    /**\n     * Creates the new instance of <tt>Game</tt> class with following values.\n     * @param name Name of the game for the display use\n     * @param systemName Systematic name of the game, without spaces and capital letters\n     * @param prefix The prefix referencing to this game\n     * @param minPlayers Minimum number of players needed to start the game\n     * @param maxPlayers Maximum number of players able to play the same game\n     */\n    public Game(String name, String systemName, String prefix, int minPlayers, int maxPlayers) {\n        this(name, systemName, prefix, minPlayers, maxPlayers, new Properties());\n    }\n\n    /**\n     * Creates the new instance of <tt>Game</tt> class with following values.\n     * @param name Name of the game for the display use\n     * @param systemName Systematic name of the game, without spaces and capital letters\n     * @param prefix The prefix referencing to this game\n     * @param minPlayers Minimum number of players needed to start the game\n     * @param maxPlayers Maximum number of players able to play the same game\n     * @param properties Additional properties for the game\n     */\n    public Game(String name, String systemName, String prefix, int minPlayers, int maxPlayers, Properties properties) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.notNull(systemName, \"systemName cannot be null\");\n        Validate.notNull(prefix, \"prefix cannot be null\");\n        Validate.isTrue(minPlayers <= maxPlayers, \"minPlayers cannot be greater that maxPlayers\");\n\n        this.name = name;\n        this.systemName = systemName;\n        this.prefix = prefix;\n        this.minPlayers = minPlayers;\n        this.maxPlayers = maxPlayers;\n        this.properties = properties;\n        properties.setProperty(\"min_players\", String.valueOf(minPlayers));\n        properties.setProperty(\"max_players\", String.valueOf(maxPlayers));\n    }\n\n    // Getters\n\n    /**\n     * @return Name of this game\n     */", " */\npublic abstract class Game {\n\n    // Fields\n    private final String name;\n\n    private final String systemName;\n\n    private final String prefix;\n\n    private final int minPlayers;\n\n    private final int maxPlayers;\n\n    private final Properties properties;\n\n    // Constructors\n\n    /**\n     * Creates the new instance of <tt>Game</tt> class with following values.\n     * @param name Name of the game for the display use\n     * @param systemName Systematic name of the game, without spaces and capital letters\n     * @param prefix The prefix referencing to this game\n     * @param minPlayers Minimum number of players needed to start the game\n     * @param maxPlayers Maximum number of players able to play the same game\n     */\n    public Game(String name, String systemName, String prefix, int minPlayers, int maxPlayers) {\n        this(name, systemName, prefix, minPlayers, maxPlayers, new Properties());\n    }\n\n    /**\n     * Creates the new instance of <tt>Game</tt> class with following values.\n     * @param name Name of the game for the display use\n     * @param systemName Systematic name of the game, without spaces and capital letters\n     * @param prefix The prefix referencing to this game\n     * @param minPlayers Minimum number of players needed to start the game\n     * @param maxPlayers Maximum number of players able to play the same game\n     * @param properties Additional properties for the game\n     */\n    public Game(String name, String systemName, String prefix, int minPlayers, int maxPlayers, Properties properties) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.notNull(systemName, \"systemName cannot be null\");\n        Validate.notNull(prefix, \"prefix cannot be null\");\n        Validate.isTrue(minPlayers <= maxPlayers, \"minPlayers cannot be greater that maxPlayers\");\n\n        this.name = name;\n        this.systemName = systemName;\n        this.prefix = prefix;\n        this.minPlayers = minPlayers;\n        this.maxPlayers = maxPlayers;\n        this.properties = properties;\n        properties.setProperty(\"min_players\", String.valueOf(minPlayers));\n        properties.setProperty(\"max_players\", String.valueOf(maxPlayers));\n    }\n\n    // Getters\n\n    /**\n     * @return Name of this game\n     */", "    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return Systematic name of this game\n     */\n    public String getSystemName() {\n        return systemName;\n    }\n\n    /**\n     * @return Prefix associated with this game\n     */", "    public String getPrefix() {\n        return prefix;\n    }\n\n    /**\n     * @return Minimum number of players\n     */\n    public int getMinPlayers() {\n        return minPlayers;\n    }\n\n    /**\n     * @return Maximum number of players\n     */", "    public int getMaxPlayers() {\n        return maxPlayers;\n    }\n\n    /**\n     * @return Properties of this game\n     */\n    public Properties getProperties() {\n        return properties;\n    }\n\n\n    /**\n     * Returns the category of this game represented by {@link Category} interface. The category can be separate object or the Game subclass itself.\n     * @return Category of this game\n     */", "    public abstract Class<? extends Game> getCategory();\n\n    /**\n     * @return String representation of this object\n     */\n    @Override\n    public String toString(){\n        return name;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/BoolState.java", "chunked_list": ["package dev.kavu.gameapi;\n\n/**\n * An enum representing {@code boolean} value.\n */\npublic enum BoolState {\n\n    /**\n     * Represents {@code false} value\n     */\n    FALSE (false),\n\n    /**\n     * Represents {@code true} value\n     */\n    TRUE (true);\n\n    private final boolean value;\n\n    BoolState(boolean value) {\n        this.value = value;\n    }\n\n    /**\n     * @return {@code true} if equal to {@link #FALSE}, {@code false} otherwise\n     */", "    public boolean isFalse() {\n        return !value;\n    }\n\n    /**\n     * @return {@code true} if equal to {@link #TRUE}, {@code false} otherwise\n     */\n    public boolean isTrue() {\n        return value;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/Rule.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.apache.commons.lang.Validate;\n\nimport java.io.Serializable;\n\n/**\n * Dynamic enum property of any game influencing its specific behaviour.\n * @param <E> Enumeration type declaring this rule's values\n */\npublic class Rule<E extends Enum<E>> implements Serializable {\n\n    private final String name;\n    private E status;\n\n    /**\n     * Creates new instance of <tt>Rule</tt> class with given name and initial status.\n     * @param name Name of this rule\n     * @param status Status this rule is going to be set\n     */\n    public Rule(String name, E status) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.notNull(status, \"status cannot be null\");\n\n        this.name = name;\n        this.status = status;\n    }\n\n    /**\n     * @return Name of this rule\n     */", " * @param <E> Enumeration type declaring this rule's values\n */\npublic class Rule<E extends Enum<E>> implements Serializable {\n\n    private final String name;\n    private E status;\n\n    /**\n     * Creates new instance of <tt>Rule</tt> class with given name and initial status.\n     * @param name Name of this rule\n     * @param status Status this rule is going to be set\n     */\n    public Rule(String name, E status) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.notNull(status, \"status cannot be null\");\n\n        this.name = name;\n        this.status = status;\n    }\n\n    /**\n     * @return Name of this rule\n     */", "    public String getName() {\n        return name;\n    }\n    /**\n     * @return Current status of this rule\n     */\n    public E getStatus(){\n        return status;\n    }\n\n    /**\n     * Checks if current status matches the specified one.\n     * @param status Status to be checked\n     * @return {@code true} if both statuses match, {@code false} otherwise\n     */", "    public boolean check(E status) {\n        Validate.notNull(status, \"status cannot be null\");\n        return this.status.equals(status);\n    }\n\n    /**\n     * Sets status of this rule to specified one.\n     * @param status New status value\n     */\n    public void setStatus(E status) {\n        Validate.notNull(status, \"status cannot be null\");\n        this.status = status;\n    }\n}\n", "    public void setStatus(E status) {\n        Validate.notNull(status, \"status cannot be null\");\n        this.status = status;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/Category.java", "chunked_list": ["package dev.kavu.gameapi;\n\n/**\n * The interface representing game category.\n * @param <T> Class implementing this interface\n */\npublic interface Category<T extends Category<T>> {\n\n    /**\n     * @return Name of this category\n     */\n    String getName();\n\n    /**\n     * @return Class of this category\n     */\n    Class<? extends T> getCategory();\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/RuleSet.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport org.apache.commons.lang.Validate;\n\nimport java.util.HashSet;\nimport java.util.Objects;\n\n/**\n * Set of {@link Rule} objects, used to store the rules for a game. Those can be found by their name. <br/>\n * <b>Note:</b> There cannot be two or more rules of the same name, even if they are two different objects.", " * Set of {@link Rule} objects, used to store the rules for a game. Those can be found by their name. <br/>\n * <b>Note:</b> There cannot be two or more rules of the same name, even if they are two different objects.\n */\npublic class RuleSet extends HashSet<Rule<?>> {\n\n    /**\n     * Fetches the rule of given name.\n     * @param name Name of the desired rule\n     * @return {@link Rule} object of unknown type, {@code null} if no matches found\n     */\n    public Rule<?> getRule(String name) {\n        Validate.notNull(name, \"name cannot be null\");\n", "        for (Rule<?> rule : this) {\n            if (Objects.equals(rule.getName(), name)) return rule;\n        }\n        return null;\n    }\n\n    /**\n     * Fetches the rule of given name and tries to cast it to parametrized {@link Rule} object.\n     * @param name Name of the desired rule\n     * @param clazz Enum class of {@link E} type\n     * @param <E> Type of enum returned <tt>Rule</tt> object will be parametrized with\n     * @return {@link Rule} object of unknown type, {@code null} if no matches found\n     */\n    public <E extends Enum<E>> Rule<E> getRule(String name, Class<E> clazz) {\n        Validate.notNull(name, \"name cannot be null\");\n        Validate.notNull(clazz, \"clazz cannot be null\");\n\n        return (Rule<E>) getRule(name);\n    }\n\n    /**\n     * Adds new rule to the set if it is not already present and no of equal name exists.\n     * @param rule {@link Rule} object to be added\n     * @return {@code true} if the rule was added successfully, {@code false} if it is already present or there is a rule of similar name\n     */\n    @Override", "    public boolean add(Rule<?> rule) {\n        Validate.notNull(rule, \"rule cannot be null\");\n\n        if(getRule(rule.getName()) != null) return false;\n        return super.add(rule);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/GameStateTimer.java", "chunked_list": ["package dev.kavu.gameapi;\n\nimport dev.kavu.gameapi.event.GameStateEndEvent;\nimport dev.kavu.gameapi.event.GameStateInitEvent;\nimport dev.kavu.gameapi.event.GstScheduleEndEvent;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.plugin.Plugin;\n\nimport java.util.Timer;\nimport java.util.TimerTask;", "import java.util.Timer;\nimport java.util.TimerTask;\n\n/**\n * This class is a special timer that allows to split game timeline into sections called game states. It allows precise operation and control on game flow.\n */\npublic class GameStateTimer {\n\n    // Fields\n    private Timer timer = new Timer();\n\n    private TimerTask task;\n\n    private GameState currentState;\n\n    private final GstSchedule schedule;\n\n    private final Plugin plugin;\n\n    private long stateTime = 0;\n\n    private boolean timerReversed;\n\n    private boolean running = false;\n\n    // Constructors\n\n    /**\n     * Creates new instance of <tt>GameStateTimer</tt> class for the specific plugin.\n     * @param plugin Plugin this timer is created for\n     */\n    public GameStateTimer(Plugin plugin){\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        schedule = null;\n        this.plugin = plugin;\n        force(GameState.EMPTY);\n    }\n\n    /**\n     * Creates new instance of <tt>GameStateTimer</tt> class for the specific plugin and immediately initializes given state.\n     * @param initialState State to be initialized\n     * @param plugin Plugin this timer is created for\n     */\n    public GameStateTimer(GameState initialState, Plugin plugin) {\n        Validate.notNull(initialState, \"initialState cannot be null\");\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        schedule = null;\n        this.plugin = plugin;\n        force(initialState);\n    }\n\n    /**\n     * Creates new instance of <tt>GameStateTimer</tt> class for the specific plugin with the given schedule.\n     * @param schedule Timer schedule represented by {@link GstSchedule} object\n     * @param plugin Plugin this timer is created for\n     */\n    public GameStateTimer(GstSchedule schedule, Plugin plugin) {\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.schedule = schedule;\n        this.plugin = plugin;\n        force(GameState.EMPTY);\n    }\n\n    /**\n     * Creates new instance of <tt>GameStateTimer</tt> class for the specific plugin with the given schedule and immediately initializes given state.\n     * @param initialState State to be initialized\n     * @param schedule Timer schedule represented by {@link GstSchedule} object\n     * @param plugin Plugin this timer is created for\n     */\n    public GameStateTimer(GameState initialState, GstSchedule schedule, Plugin plugin) {\n        Validate.notNull(initialState, \"initialState cannot be null\");\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.schedule = schedule;\n        this.plugin = plugin;\n        force(initialState);\n    }\n\n    // Getters & Setters\n\n    /**\n     * @return Game state this timer is currently running, {@link GameState#EMPTY} stands for no state running\n     */", "    public GameState getCurrentState() {\n        return currentState;\n    }\n\n    /**\n     * @return Current schedule of this timer, {@code null} if there is no schedule\n     */\n    public GstSchedule getSchedule() {\n        return schedule;\n    }\n\n    /**\n     * @return Plugin this timer is associated with\n     */", "    public Plugin getPlugin() {\n        return plugin;\n    }\n\n    /**\n     * @return Time lasted for current state expressed in milliseconds\n     */\n    public long getStateTime() {\n        return stateTime;\n    }\n\n    /**\n     * Sets current state time to specified value. If the value overpasses the state's time bound, the timer will automatically terminate that state.\n     * @param stateTime New state time value\n     */", "    public void setStateTime(long stateTime) {\n        this.stateTime = stateTime;\n    }\n\n    /**\n     * @return {@code true} if timer counts back, {@code false} otherwise\n     */\n    public boolean isTimerReversed() {\n        return timerReversed;\n    }\n\n    /**\n     * @return {@code true} if timer is running, {@code false} otherwise\n     */", "    public boolean isRunning(){\n        return running;\n    }\n\n    // Functionality\n\n    /**\n     * Initializes specified game state - starts a counting cycle. If the timer reaches the end, it will terminate this state automatically. Provided timer is stopped, it will be resumed.\n     * @param gameState Game state to be initialized\n     * @throws GameStateInterruptException When current game state is uninterruptible\n     */", "    public void initialize(GameState gameState) throws GameStateInterruptException {\n        Validate.notNull(gameState, \"gameState cannot be null\");\n\n        if(!currentState.isInterruptible()) {\n            throw new GameStateInterruptException();\n        }\n\n        force(gameState);\n    }\n\n    /**\n     * Terminates current game state. Has no effect if timer runs no state (runs {@link GameState#EMPTY}).\n     * @param runNext If set {@code true}, initializes next state in the schedule, if it exists.\n     * @throws GameStateInterruptException When current game state is uninterruptible\n     */", "    public void terminate(boolean runNext) throws GameStateInterruptException {\n        if (currentState == GameState.EMPTY) return;\n\n        if (!currentState.isInterruptible()) {\n            throw new GameStateInterruptException();\n        }\n\n        plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, schedule != null ? schedule.next() : null, false));\n        currentState.onEnd();\n        if(runNext && schedule != null) {\n            plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, schedule.next(), false));\n            force(schedule.getCurrent());\n        } else {\n            plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, GameState.EMPTY, false));\n            force(GameState.EMPTY);\n        }\n    }\n\n    /**\n     * If timer is running, prompts the timer - executes one independent iteration without counting up a time.\n     */", "        if(runNext && schedule != null) {\n            plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, schedule.next(), false));\n            force(schedule.getCurrent());\n        } else {\n            plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, GameState.EMPTY, false));\n            force(GameState.EMPTY);\n        }\n    }\n\n    /**\n     * If timer is running, prompts the timer - executes one independent iteration without counting up a time.\n     */", "    public void prompt(){\n        if(running) shouldCancel();\n    }\n\n    /**\n     * Pauses the timer, if it's running. Stopped timer won't perform any actions on game state, thus cannot be prompted.\n     */\n    public void pause(){\n        running = false;\n    }\n\n    /**\n     * Resumes the timer, if it's paused.\n     */", "    public void resume(){\n        running = true;\n    }\n\n    /**\n     * Forcefully initializes the specified game state, no matter current one is interruptible or not.\n     */\n    protected final void force(GameState gameState) {\n        running = true;\n        plugin.getServer().getPluginManager().callEvent(new GameStateInitEvent(this, currentState, gameState));\n        currentState = gameState;\n        currentState.onInit();\n        timerReversed = currentState.doesReverseTimer();\n\n        stateTime = timerReversed ? currentState.getDuration() : 0;\n", "        if (task != null) task.cancel();\n        task = new TimerTask() {\n            @Override\n            public void run() {\n                if(!running) return;\n                if (shouldCancel()) {\n                    cancel();\n                }\n                if (currentState.getDuration() >= 0) {\n                    currentState.tick();\n                    stateTime += timerReversed ? -1 : 1;\n                }\n            }\n        };\n\n        timer.cancel();\n        timer.purge();\n        timer = new Timer();\n        timer.schedule(task, 0, currentState.getPeriod());\n    }\n\n    private boolean shouldCancel(){\n\n        boolean timerOvercount = (timerReversed ? (stateTime <= 0) : (stateTime >= currentState.getDuration())) && currentState.getDuration() >= 0;\n", "                if (currentState.getDuration() >= 0) {\n                    currentState.tick();\n                    stateTime += timerReversed ? -1 : 1;\n                }\n            }\n        };\n\n        timer.cancel();\n        timer.purge();\n        timer = new Timer();\n        timer.schedule(task, 0, currentState.getPeriod());\n    }\n\n    private boolean shouldCancel(){\n\n        boolean timerOvercount = (timerReversed ? (stateTime <= 0) : (stateTime >= currentState.getDuration())) && currentState.getDuration() >= 0;\n", "        if (timerOvercount || currentState.shouldEnd()) {\n            plugin.getServer().getPluginManager().callEvent(new GameStateEndEvent(this, currentState, schedule != null ? schedule.next() : null, true));\n\n            if(schedule != null) {\n                if (schedule.isDone()) {\n                    plugin.getServer().getPluginManager().callEvent(new GstScheduleEndEvent(this, currentState));\n                }\n                currentState.onEnd();\n                force(schedule.getCurrent());\n            } else {\n                currentState.onEnd();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/LockableStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic;\n\nimport org.apache.commons.lang.Validate;\n\nimport java.util.HashMap;\nimport java.util.UUID;\n\n/**\n * An abstract class providing the locking mechanic to {@link Statistic} interface. <br/>\n * To classify <tt>LockableStatistic</tt> as one of predefined ones, generic parameters has to be equal, as shown below:", " * An abstract class providing the locking mechanic to {@link Statistic} interface. <br/>\n * To classify <tt>LockableStatistic</tt> as one of predefined ones, generic parameters has to be equal, as shown below:\n * <pre>\n *      class IntLockable extends LockableStatistic&#60;Integer&#62; implements IntStatistic {\n *\n *      }\n * </pre>\n * @param <T> Numeric type of this statistic\n */\npublic abstract class LockableStatistic<T extends Number> implements Statistic<T>{\n\n    private boolean locked;\n\n    private final HashMap<UUID, Boolean> locks = new HashMap<>();\n\n    /**\n     * Locks or unlocks whole statistic.\n     * @param locked {@code true} to lock, {@code false} to unlock this statistic\n     */", " */\npublic abstract class LockableStatistic<T extends Number> implements Statistic<T>{\n\n    private boolean locked;\n\n    private final HashMap<UUID, Boolean> locks = new HashMap<>();\n\n    /**\n     * Locks or unlocks whole statistic.\n     * @param locked {@code true} to lock, {@code false} to unlock this statistic\n     */", "    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    /**\n     * Locks or unlocks statistic for single member. Locked statistic's value cannot be altered in any way.\n     * @param locked {@code true} to lock, {@code false} to unlock this statistic\n     * @param member Member this statistic is going to be locked for\n     */\n    public void setLocked(UUID member, boolean locked){\n        Validate.notNull(member, \"member cannot be null\");\n\n        locks.replace(member, locked);\n    }\n\n    /**\n     * @return {@code true} if this statistic is locked, {@code false} otherwise\n     */\n    @Condition(negate = true)", "    public void setLocked(UUID member, boolean locked){\n        Validate.notNull(member, \"member cannot be null\");\n\n        locks.replace(member, locked);\n    }\n\n    /**\n     * @return {@code true} if this statistic is locked, {@code false} otherwise\n     */\n    @Condition(negate = true)\n    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Checks if statistic is locked for particular member.\n     * @param member Member this statistic can be locked for\n     * @return {@code true} if statistic is locked for specified member, {@code false} otherwise\n     */\n    @Condition(negate = true)", "    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Checks if statistic is locked for particular member.\n     * @param member Member this statistic can be locked for\n     * @return {@code true} if statistic is locked for specified member, {@code false} otherwise\n     */\n    @Condition(negate = true)\n    public boolean isLocked(UUID member) {\n        Validate.notNull(member, \"member cannot be null\");\n\n        return locks.getOrDefault(member, true);\n    }\n}\n", "    public boolean isLocked(UUID member) {\n        Validate.notNull(member, \"member cannot be null\");\n\n        return locks.getOrDefault(member, true);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/Condition.java", "chunked_list": ["package dev.kavu.gameapi.statistic;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Classifies the method as a condition/\n */", " * Classifies the method as a condition/\n */\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n    // Determines if the function or field should be treated as a condition\n\n    /**\n     * @return {@code true} if the result of condition should be negated\n     */", "     * @return {@code true} if the result of condition should be negated\n     */\n    boolean negate() default false;\n\n    /**\n     * Determines if condition should be treated as an alternative one. If one of the non-alternative conditions fails, any passed alternative condition will make the whole test pass.\n     * @return {@code true} if the condition should be treated as alternative\n     */\n    boolean alternative() default false;\n}", "    boolean alternative() default false;\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/Trigger.java", "chunked_list": ["package dev.kavu.gameapi.statistic;\n\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.event.Event;\n\nimport java.util.UUID;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\n/**", "\n/**\n * Representation of automatic statistic trigger. It is used to detect event calls and perform specific action on statistics dependently on which one is called.\n * @param <E> Event to be caught if called\n */\npublic class Trigger<E extends Event> {\n\n    private final Class<E> eventClass;\n    private final Function<E, UUID> mapper;\n    private final Predicate<E> validator;\n    private final Function<? extends Number, ? extends Number> response;\n\n    /**\n     * Creates new instance of <tt>Trigger</tt> class.\n     * @param eventClass Event to be caught\n     * @param mapper Mapping function retrieving {@link UUID} object form {@link E} object, which will represent statistic member\n     */\n    public Trigger(Class<E> eventClass, Function<E, UUID> mapper) {\n        Validate.notNull(eventClass, \"eventClass cannot be null\");\n        Validate.notNull(mapper, \"mapper cannot be null\");\n\n        this.eventClass = eventClass;\n        this.mapper = mapper;\n        validator = event -> true;\n        response = n -> n;\n    }\n\n    /**\n     * Creates new instance of <tt>Trigger</tt> class with event validator.\n     * @param eventClass Event to be caught\n     * @param mapper Mapping function retrieving {@link UUID} object form {@link E} object, which will represent statistic member\n     * @param validator Validating function which tests the caught event; trigger will be run if returns {@code true}\n     */\n    public Trigger(Class<E> eventClass, Function<E, UUID> mapper, Predicate<E> validator) {\n        Validate.notNull(eventClass, \"eventClass cannot be null\");\n        Validate.notNull(mapper, \"mapper cannot be null\");\n        Validate.notNull(validator, \"validator cannot be null\");\n\n        this.eventClass = eventClass;\n        this.mapper = mapper;\n        this.validator = validator;\n        response = n -> n;\n    }\n\n    /**\n     * Creates new instance of <tt>Trigger</tt> class with event response.\n     * @param eventClass Event to be caught\n     * @param mapper Mapping function retrieving {@link UUID} object form {@link E} object, which will represent statistic member\n     * @param response Function to be executed on member retrieved for event using mapper\n     */\n    public <T extends Number> Trigger(Class<E> eventClass, Function<E, UUID> mapper, Function<T, T> response) {\n        Validate.notNull(eventClass, \"eventClass cannot be null\");\n        Validate.notNull(mapper, \"mapper cannot be null\");\n        Validate.notNull(response, \"response cannot be null\");\n\n        this.eventClass = eventClass;\n        this.mapper = mapper;\n        this.response = response;\n        validator = e -> true;\n    }\n\n    /**\n     * Creates new instance of <tt>Trigger</tt> class with event validator and response.\n     * @param eventClass Event to be caught\n     * @param mapper Mapping function retrieving {@link UUID} object form {@link E} object, which will represent statistic member\n     * @param validator Validating function which tests the caught event; trigger will be run if returns {@code true}\n     * @param response Function to be executed on member retrieved for event using mapper\n     */\n    public <T extends Number> Trigger(Class<E> eventClass, Function<E, UUID> mapper, Predicate<E> validator, Function<T, T> response) {\n        Validate.notNull(eventClass, \"eventClass cannot be null\");\n        Validate.notNull(mapper, \"mapper cannot be null\");\n        Validate.notNull(validator, \"validator cannot be null\");\n        Validate.notNull(response, \"response cannot be null\");\n\n        this.eventClass = eventClass;\n        this.mapper = mapper;\n        this.validator = validator;\n        this.response = response;\n    }\n\n    /**\n     * @return Monitored event's class\n     */\n    public Class<E> getEventClass(){\n        return eventClass;\n    }\n\n    /**\n     * Retrieves {@link UUID} object from event using mapper, representing a member\n     * @param event Incoming event\n     * @return {@link UUID} representation of member\n     */", "    public UUID compute(Event event){\n        Validate.notNull(event, \"event cannot be null\");\n\n        return mapper.apply(eventClass.cast(event));\n    }\n\n    /**\n     * Validates event with validator, if set.\n     * @param event Incoming event\n     * @return {@link true} if event passed the test, {@link false} otherwise\n     */", "    public boolean validate(Event event){\n        Validate.notNull(event, \"event cannot be null\");\n\n        return validator.test(eventClass.cast(event));\n    }\n\n    /**\n     * @return Function to be performed on specific member\n     */\n    public <T extends Number> Function<T, T> getResponse() {\n        return (Function<T, T>) response;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/RegisteredStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic;\n\nimport dev.kavu.gameapi.event.StatisticTriggerEvent;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.plugin.Plugin;\n\nimport java.lang.reflect.InvocationTargetException;", "\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.function.Function;\n\n/**\n * Representation of registered {@link Statistic} containing values mapped to members of following statistic. Statistic registered using {@link dev.kavu.gameapi.GameManager GameManager}\n * will create an object of this class and associate it with registered statistic.\n * @param <T> Numeric type of wrapped statistic", " * will create an object of this class and associate it with registered statistic.\n * @param <T> Numeric type of wrapped statistic\n */\npublic class RegisteredStatistic<T extends Number> {\n\n    // Fields\n    private final Statistic<T> statistic;\n    private final HashMap<UUID, T> members = new HashMap<>();\n    private final Plugin plugin;\n\n\n    // Constructors\n\n    /**\n     * Creates new instance of <tt>RegisteredStatistic</tt> with base of specified statistic.\n     * @param statistic Registered statistic\n     * @param plugin Plugin the statistic is registered for\n     */\n    public RegisteredStatistic(Statistic<T> statistic, Plugin plugin){\n        Validate.notNull(statistic, \"statistic cannot be null\");\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.statistic = statistic;\n        this.plugin = plugin;", "        for(Trigger<?> t : statistic.getTriggers()){\n            plugin.getServer().getPluginManager().registerEvent(t.getEventClass(), new Listener() { }, EventPriority.NORMAL, (listener, event) -> onEventCall(event), plugin);\n        }\n    }\n\n    /**\n     * Creates new instance of <tt>RegisteredStatistic</tt> with base of specified statistic with initial members.\n     * @param statistic Registered statistic\n     * @param initialMembers Collection if members that will be instantly added to the statistic members\n     * @param plugin Plugin the statistic is registered for\n     */\n    public RegisteredStatistic(Statistic<T> statistic, Collection<UUID> initialMembers, Plugin plugin){\n        Validate.notNull(statistic, \"statistic cannot be null\");\n        Validate.notNull(initialMembers, \"initialMembers cannot be null\");\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.statistic = statistic;\n        this.plugin = plugin;", "        for(UUID member : initialMembers){\n            addMember(member);\n        }\n        for(Trigger<?> t : statistic.getTriggers()){\n            plugin.getServer().getPluginManager().registerEvent(t.getEventClass(), new Listener() { }, EventPriority.NORMAL, (listener, event) -> onEventCall(event), plugin);\n        }\n    }\n\n    // Getters\n\n    /**\n     * @return Registered statistic\n     */\n    public Statistic<T> getStatistic() {\n        return statistic;\n    }\n\n    /**\n     * @return Map of members represented by {@link UUID} objects associated with their values\n     */\n    public HashMap<UUID, T> getMembers() {\n        return members;\n    }\n\n    /**\n     * @return Plugin the statistic is registered for\n     */", "    public Plugin getPlugin() {\n        return plugin;\n    }\n\n    // Functionality\n\n    /**\n     * Adds member to the statistic if it is not yet present.\n     * @param member Member to be added represented by {@link UUID} object\n     */\n    public void addMember(UUID member){\n        Validate.notNull(member, \"member cannot be null\");\n\n        members.putIfAbsent(member, statistic.getDefault());\n    }\n\n    /**\n     * Triggers this statistic if its possible thus calls {@link StatisticTriggerEvent} with no parent {@link Trigger} object.\n     * @param member Member the statistic will be triggered for\n     */", "    public void addMember(UUID member){\n        Validate.notNull(member, \"member cannot be null\");\n\n        members.putIfAbsent(member, statistic.getDefault());\n    }\n\n    /**\n     * Triggers this statistic if its possible thus calls {@link StatisticTriggerEvent} with no parent {@link Trigger} object.\n     * @param member Member the statistic will be triggered for\n     */\n    public void trigger(UUID member){\n        Validate.notNull(member, \"member cannot be null\");\n", "    public void trigger(UUID member){\n        Validate.notNull(member, \"member cannot be null\");\n\n        if(checkConditions(member)) {\n            plugin.getServer().getPluginManager().callEvent(new StatisticTriggerEvent(this, member, members.get(member)));\n        }\n    }\n\n    /**\n     * Executes the function for all members of the statistic.\n     * @param function Function to be called\n     * @return {@code true} if all actions were done, {@code false} otherwise\n     */", "    public boolean exec(Function<T, T> function) {\n        if(members.isEmpty()) return false;\n        if(function == null) return false;\n\n        boolean result = true;\n\n        for (Map.Entry<UUID, T> e : members.entrySet()){\n            result = execFor(e.getKey(), function) && result;\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes the function for specific member of the statistic.\n     * @param member Member the function fill be called for, represented by {@link UUID} object\n     * @param function Function to be called\n     * @return {@code true} if the action was done, {@code false} otherwise\n     */", "    public boolean execFor(UUID member, Function<T, T> function) {\n        Validate.notNull(member, \"member cannot be null\");\n\n        if(members.isEmpty()) return false;\n        if(function == null) return false;\n\n        return members.replace(member, function.apply(members.get(member))) == null;\n    }\n\n    private boolean checkConditions(UUID targetMember) {\n        boolean result = true;\n        boolean alternativeResult = false;\n", "        for(Method method : statistic.getClass().getDeclaredMethods()){\n\n            if(!method.isAnnotationPresent(Condition.class)) continue;\n            if(!method.getReturnType().equals(boolean.class))\n            if(method.getParameterCount() > 1) continue;\n            method.setAccessible(true);\n\n            Condition condition = method.getAnnotation(Condition.class);\n\n            boolean invokeResult = false;\n            try {", "            try {\n                if (method.getParameterCount() == 0) {\n                    invokeResult = (boolean) method.invoke(statistic);\n                } else {\n                    invokeResult = (boolean) method.invoke(statistic, targetMember);\n                }\n            } catch (InvocationTargetException | IllegalAccessException ignored) {\n            }\n\n            if(!condition.alternative()) {\n                result = (invokeResult == !condition.negate()) && result;\n            } else {\n                alternativeResult = (invokeResult && !condition.negate()) || alternativeResult;\n            }\n        }\n        return result || alternativeResult;\n    }\n\n    private void onEventCall(Event event){", "            if(!condition.alternative()) {\n                result = (invokeResult == !condition.negate()) && result;\n            } else {\n                alternativeResult = (invokeResult && !condition.negate()) || alternativeResult;\n            }\n        }\n        return result || alternativeResult;\n    }\n\n    private void onEventCall(Event event){\n        for(Trigger<?> trigger : statistic.getTriggers()){\n            Class<? extends Event> clazz = trigger.getEventClass();", "        for(Trigger<?> trigger : statistic.getTriggers()){\n            Class<? extends Event> clazz = trigger.getEventClass();\n            if(clazz.equals(event.getClass())){\n                if(!trigger.validate(clazz.cast(event))) continue;\n                UUID uuid = trigger.compute(clazz.cast(event));\n                if(checkConditions(uuid)) {\n                    execFor(uuid, trigger.getResponse());\n                    plugin.getServer().getPluginManager().callEvent(new StatisticTriggerEvent(this, uuid, members.get(uuid), event));\n                    return;\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/Statistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic;\n\nimport java.util.Set;\n\n/**\n * This interface is the base for any statistic. It classifies the triggers this statistic will be counted with as well as its default value. <br/>\n * There are predefined subinterfaces of this interface for every numeric type in {@link dev.kavu.gameapi.statistic.common .common} package. <p/>\n * <b>Note: </b> For statistic to work it has to be registered using {@link dev.kavu.gameapi.GameManager GameManager}.\n *\n * @param <T> Numeric type of this statistic", " *\n * @param <T> Numeric type of this statistic\n *\n * @see LockableStatistic\n * @see RegisteredStatistic\n */\npublic interface Statistic<T extends Number> {\n\n    /**\n     * @return Default value of this statistic\n     */\n    T getDefault();\n\n    /**\n     * @return Set of {@link Trigger} objects this statistic will be counted with\n     */\n    Set<Trigger<?>> getTriggers();\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/IntStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>int</tt> type\n */\npublic interface IntStatistic extends Statistic<Integer> {\n\n    /**\n     * Incrementor for <tt>int</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static int increment(int a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>int</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static int decrement(int a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/DoubleStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>double</tt> type\n */\npublic interface DoubleStatistic extends Statistic<Double> {\n\n    /**\n     * Incrementor for <tt>double</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static double increment(double a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>double</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static double decrement(double a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/LongStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>long</tt> type\n */\npublic interface LongStatistic extends Statistic<Long> {\n\n    /**\n     * Incrementor for <tt>long</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static long increment(long a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>long</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static long decrement(long a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/FloatStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>float</tt> type\n */\npublic interface FloatStatistic extends Statistic<Float> {\n\n    /**\n     * Incrementor for <tt>float</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static float increment(float a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>float</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static float decrement(float a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/ByteStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>byte</tt> type\n */\npublic interface ByteStatistic extends Statistic<Byte> {\n\n    /**\n     * Incrementor for <tt>byte</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static byte increment(byte a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>byte</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static byte decrement(byte a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/statistic/common/ShortStatistic.java", "chunked_list": ["package dev.kavu.gameapi.statistic.common;\n\nimport dev.kavu.gameapi.statistic.Statistic;\n\n/**\n * Subinterface of {@link Statistic} interface of <tt>short</tt> type\n */\npublic interface ShortStatistic extends Statistic<Short> {\n\n    /**\n     * Incrementor for <tt>short</tt> numbers\n     * @param a Number to be incremented\n     * @return Incremented number\n     */\n    static short increment(short a){\n        return ++a;\n    }\n\n    /**\n     * Decrementor for <tt>short</tt> numbers\n     * @param a Number to be decremented\n     * @return Decremented number\n     */\n    static short decrement(short a){\n        return --a;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/GameMap.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport org.bukkit.World;\n\nimport java.io.File;\n\n/**\n * Representation of minecraft game map.\n *\n * @see MapManager", " *\n * @see MapManager\n */\npublic interface GameMap {\n\n    /**\n     * Called when map is loaded.\n     * @param world Map world\n     */\n    void onLoad(World world);\n\n    /**\n     * @return Name of the map\n     */\n    String getName();\n\n    /**\n     * @return Source directory origin map is located in\n     */\n    File getSource();\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/MapCreationException.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\n/**\n * Thrown where game map cannot be created with given data.\n */\npublic class MapCreationException extends Exception{\n\n    public MapCreationException(){\n        super(\"Couldn't successfully create new map\");\n    }\n\n    public MapCreationException(String message){\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/Area.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\n\nimport java.util.function.Supplier;\n\n/**\n * Representation of 3-dimensional space in particular world. This space can be checked if a location or player is inside or not. Area shape is defined using {@link AreaShape} object.", "/**\n * Representation of 3-dimensional space in particular world. This space can be checked if a location or player is inside or not. Area shape is defined using {@link AreaShape} object.\n *\n * @see PlainArea\n */\npublic abstract class Area {\n\n    // Fields\n    private double sizeX;\n    private double sizeY;\n    private double sizeZ;\n    private final Supplier<Location> center;\n    private final AreaShape shape;\n\n    // Constructors\n\n    /**\n     * Creates new instance of <tt>Area</tt> class with specific size and shape and dynamic center. {@link Supplier} object allows moving the area in a particular manner. <p/>\n     * <b>Note: </b> All sizes are treated as radius, what makes the real size two times bigger.\n     * @param center Center of the area\n     * @param x Size of the area on X axis\n     * @param y Size of the area on Y axis\n     * @param z Size of the area on Z axis\n     * @param shape Shape of the area represented by {@link AreaShape} object\n     */\n    public Area(Supplier<Location> center, double x, double y, double z, AreaShape shape) {\n        Validate.notNull(center, \"center cannot be null\");\n        Validate.notNull(shape, \"shape cannot be null\");\n        Validate.isTrue(x >= 0, \"x must be greater or equal to 0; x: \", x);\n        Validate.isTrue(y >= 0, \"y must be greater or equal to 0; y: \", y);\n        Validate.isTrue(z >= 0, \"z must be greater or equal to 0; z: \", z);\n\n        this.center = center;\n        this.sizeX = x;\n        this.sizeY = y;\n        this.sizeZ = z;\n        this.shape = shape;\n\n    }\n    /**\n     * Creates new instance of <tt>Area</tt> class with specific size and shape and static center. <p/>\n     *      * <b>Note: </b> All sizes are treated as radius, what makes the real size two times bigger.\n     * @param center Center of the area\n     * @param x Size of the area on X axis\n     * @param y Size of the area on Y axis\n     * @param z Size of the area on Z axis\n     * @param shape Shape of the area represented by {@link AreaShape} object\n     */\n    public Area(Location center, double x, double y, double z, AreaShape shape) {\n        this(() -> center, x, y, z, shape);\n    }\n\n    // Getters & Setters\n\n    /**\n     * @return Size of the area on X axis\n     */", "    public double getSizeX() {\n        return sizeX;\n    }\n\n    /**\n     * @return Size of the area on X axis\n     */\n    public double getSizeY() {\n        return sizeY;\n    }\n\n    /**\n     * @return Size of the area on X axis\n     */", "    public double getSizeZ() {\n        return sizeZ;\n    }\n\n    /**\n     * @return Current center of the area\n     */\n    public Location getCenter() {\n        return center.get();\n    }\n\n    /**\n     * @return Shape of the area represented by {@link AreaShape} object\n     */", "    public AreaShape getShape() {\n        return shape;\n    }\n\n    // Functionality\n\n    /**\n     * Changes each size of the area and returns itself\n     * @param x New x size\n     * @param y New y size\n     * @param z New z size\n     * @return Resized area\n     *\n     * @see #scale\n     */", "    public Area resize(double x, double y, double z){\n        Validate.isTrue(x >= 0, \"x must be greater or equal to 0; x: \", x);\n        Validate.isTrue(y >= 0, \"y must be greater or equal to 0; y: \", y);\n        Validate.isTrue(z >= 0, \"z must be greater or equal to 0; z: \", z);\n\n        this.sizeX = x;\n        this.sizeY = y;\n        this.sizeZ = z;\n        return this;\n    }\n\n    /**\n     * Scales whole area by multiplying each size of the area by specific scale and returns itself\n     * @param scaleX X size multiplier\n     * @param scaleY Y size multiplier\n     * @param scaleZ Z size multiplier\n     * @return Scaled area\n     *\n     * @see #resize\n     */", "    public Area scale(double scaleX, double scaleY, double scaleZ){\n        Validate.isTrue(scaleX >= 0, \"scaleX must be greater or equal to 0; scaleX: \", scaleX);\n        Validate.isTrue(scaleY >= 0, \"scaleY must be greater or equal to 0; scaleY: \", scaleY);\n        Validate.isTrue(scaleZ >= 0, \"scaleZ must be greater or equal to 0; scaleZ: \", scaleZ);\n\n        sizeX *= scaleX;\n        sizeY *= scaleY;\n        sizeZ *= scaleZ;\n        return this;\n    }\n\n    /**\n     * Scales whole area with single multiplier\n     * @param scale Size multiplier\n     * @return Scaled area\n     *\n     * @see #resize\n     */", "    public Area scale(double scale){\n        Validate.isTrue(scale >= 0, \"scale must be greater or equal to 0; scale: \", scale);\n\n        return scale(scale, scale, scale);\n    }\n\n    /**\n     * Indicates if location is within the bounds of the area\n     * @param location Location to be checked\n     * @return {@code true} if location is in the area; {@code false} if is not\n     */", "    public boolean hasLocation(Location location){\n        Validate.notNull(location, \"location cannot be null\");\n\n        if(location.getWorld() != getCenter().getWorld()) return false;\n\n        return shape.compute(this, getCenter());\n    }\n\n    /**\n     * Indicates if player is within the bounds of the area. That includes player's location and eye location.\n     * @param player Players to be checked\n     * @return {@code true} if players is in the area; {@code false} if is not\n     */", "    public boolean hasPlayer(Player player){\n        Validate.notNull(player, \"player cannot be null\");\n\n        return hasLocation(player.getLocation()) || hasLocation(player.getEyeLocation());\n    }\n\n    /**\n     * Called when player enters this area.\n     * @param player Player that entered the area\n     */\n    public abstract void onEnter(Player player);\n\n    /**\n     * Called when player moves inside this area.\n     * @param player Player that moved in the area\n     */", "    public abstract void onEnter(Player player);\n\n    /**\n     * Called when player moves inside this area.\n     * @param player Player that moved in the area\n     */\n    public abstract void onMove(Player player);\n\n    /**\n     * Called when player leaves this area, no matter if enters new one or not.\n     * @param player Player that left the area\n     */", "    public abstract void onLeave(Player player);\n}"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/AreaPickEquivocationException.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\n/**\n * Thrown when area choice for specific location is ambiguous - when two overlapping areas have same priority.\n */\npublic class AreaPickEquivocationException extends RuntimeException{\n\n    public AreaPickEquivocationException(){\n        super(\"Equivocation while picking the most prioritized area\");\n    }\n\n    public AreaPickEquivocationException(String message){\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/PlainArea.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\n\nimport java.util.function.Supplier;\n\n/**\n * Simple area with no enter, move and leave events. In other cases it behaves in the same way any other area does.\n *", " * Simple area with no enter, move and leave events. In other cases it behaves in the same way any other area does.\n *\n * @see Area\n */\npublic class PlainArea extends Area {\n\n    /**\n     * Creates new instance of <tt>PlainArea</tt> in the same way as in {@link Area} class.\n     * @param center Center of the area\n     * @param x Size of the area on X axis\n     * @param y Size of the area on Y axis\n     * @param z Size of the area on Z axis\n     * @param shape Shape of the area represented by {@link AreaShape} object\n     *\n     * @see Area#Area(Supplier, double, double, double, AreaShape)\n     */\n    public PlainArea(Supplier<Location> center, double x, double y, double z, AreaShape shape) {\n        super(center, x, y, z, shape);\n    }\n\n    /**\n     * Creates new instance of <tt>PlainArea</tt> in the same way as in {@link Area} class.\n     * @param center Center of the area\n     * @param x Size of the area on X axis\n     * @param y Size of the area on Y axis\n     * @param z Size of the area on Z axis\n     * @param shape Shape of the area represented by {@link AreaShape} object\n     *\n     * @see Area#Area(Location, double, double, double, AreaShape)\n     */\n    public PlainArea(Location center, double x, double y, double z, AreaShape shape) {\n        super(center, x, y, z, shape);\n    }\n\n    @Override", "    public void onEnter(Player player) {\n\n    }\n\n    @Override\n    public void onMove(Player player) {\n\n    }\n\n    @Override\n    public void onLeave(Player player) {\n\n    }\n}\n", "    public void onLeave(Player player) {\n\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/AreaShape.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport javafx.geometry.Point2D;\nimport javafx.geometry.Point3D;\nimport org.bukkit.Location;\n\n/**\n * Representation of 3-Dimensional shape created using {@link Area} object. <br/>\n * This interface contains predefined, usually used shapes.\n *", " * This interface contains predefined, usually used shapes.\n *\n * @see #SPHERE\n * @see #CYLINDER\n * @see #CUBOID\n */\npublic interface AreaShape {\n\n    /**\n     * Determines if specific location shall be in the specific area\n     * @param area {@link Area} object to depend on\n     * @param pos Location to be checked\n     * @return {@code true} if location shall be in the specified area; {@code false} if shall not\n     */\n    boolean compute(Area area, Location pos);\n\n    /**\n     * Ellipsoid shape with each radius equal to area's <i>x</i>, <i>y</i> and <i>z</i> size\n     */\n    AreaShape SPHERE = (area, pos) -> {\n        Location center = area.getCenter();\n        Point3D centerPoint = new Point3D(center.getX(), center.getY(), center.getZ());\n        Point3D posPoint = new Point3D(pos.getX(), pos.getY(), pos.getZ());\n\n        return (posPoint.getX() - centerPoint.getX()) / area.getSizeX() + (posPoint.getY() - centerPoint.getY()) / area.getSizeY() + (posPoint.getZ() - centerPoint.getZ()) / area.getSizeZ() <= 1;\n    };\n\n    /**\n     * Vertical cylinder shape with base of ellipse with radius equal to area's <i>x</i> and <i>z</i> size, and height equal to doubled <i>z</i> size\n     */\n    AreaShape CYLINDER= (area, pos) -> {\n        Location center = area.getCenter();\n        Point2D centerPoint = new Point2D(center.getX(), center.getZ());\n        Point2D posPoint = new Point2D(pos.getX(), pos.getZ());\n\n        return (posPoint.getX() - centerPoint.getX()) / area.getSizeX() + (posPoint.getY() - centerPoint.getY()) / area.getSizeZ() <= 1 && Math.abs(center.getY() - pos.getY()) <= area.getSizeY();\n    };\n\n    /**\n     * Cuboid shape with borders' size equal to doubled area's <i>x</i>, <i>y</i> and <i>z</i> size\n     */\n    AreaShape CUBOID = (area, pos) -> {\n        Location center = area.getCenter();\n        Point3D centerPoint = new Point3D(center.getX(), center.getY(), center.getZ());\n        Point3D posPoint = new Point3D(pos.getX(), pos.getY(), pos.getZ());\n        Point3D diff = centerPoint.subtract(posPoint);\n        return Math.abs(diff.getX()) <= area.getSizeX() && Math.abs(diff.getY()) <= area.getSizeY() && Math.abs(diff.getZ()) <= area.getSizeZ();\n    };\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/AreaController.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport dev.kavu.gameapi.event.ConditionalListener;\nimport dev.kavu.gameapi.event.AreaEnterEvent;\nimport dev.kavu.gameapi.event.AreaLeaveEvent;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;", "import org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerMoveEvent;\nimport org.bukkit.plugin.Plugin;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**", "\n/**\n * Controller class designated to manage all areas present in the world. It is necessary for area to work.\n */\npublic class AreaController {\n\n    private final HashMap<Area, Integer> areas;\n\n    private final HashMap<Player, Area> players = new HashMap<>();\n\n    private final Plugin plugin;\n\n    private boolean running = true;\n\n    /**\n     * Creates new instance of <tt>AreaController</tt> just with {@link Plugin} object.\n     * @param plugin Plugin this controller is bound to\n     */\n    public AreaController(Plugin plugin){\n        this(new HashMap<>(), plugin);\n    }\n\n    /**\n     * Creates new instance of <tt>AreaController</tt> with initial set of prioritized areas.\n     * @param areas Map of {@link Area} objects associated with its priority represented by <tt>int</tt> value\n     * @param plugin Plugin this controller is bound to\n     */\n    public AreaController(HashMap<Area, Integer> areas, Plugin plugin){\n        Validate.notNull(areas, \"areas cannot be null\");\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        this.areas = areas;\n        this.plugin = plugin;\n\n        ConditionalListener conditionalListener = new ConditionalListener(new AreaMoveListener(), this::isRunning);\n        conditionalListener.register(plugin);\n    }\n\n    /**\n     * Adds new {@link Area} object with its priority if it does not exist yet.\n     * @param area Area to be added\n     * @param priority Area's priority\n     * @return {@code true} if area was successfully added; {@code false} otherwise\n     */", "    public boolean addArea(Area area, int priority){\n        Validate.notNull(area, \"area cannot be null\");\n\n        return areas.putIfAbsent(area, priority) == null;\n    }\n\n    /**\n     * Gets the most prioritized area specified player is in. <p/>\n     * <b>Warning: </b> If there are two or more overlapping areas with same priority, when having specified player, {@link AreaPickEquivocationException} will be thrown.\n     * @param player Player to be checked\n     * @return {@link Area} object with the highest priority containing specified player; {@code null} if there is no such area\n     *\n     * @see #getAreas\n     */", "    public Area getArea(Player player){\n        Validate.notNull(player, \"player cannot be null\");\n\n        int lastPriority = Integer.MIN_VALUE;\n        AtomicReference<Area> currentArea = new AtomicReference<>(null);\n\n        areas.forEach((area, priority) -> {\n            if(area.hasPlayer(player) && priority == lastPriority) throw new AreaPickEquivocationException();\n            if(area.hasPlayer(player) && priority > lastPriority) {\n                currentArea.set(area);\n            }\n        });\n\n        return currentArea.get();\n    }\n\n    /**\n     * Gets the most prioritized area containing specified location. <p/>\n     * <b>Warning: </b> If there are two or more overlapping areas with same priority, when having specified location, {@link AreaPickEquivocationException} will be thrown.\n     * @param location Designated location\n     * @return {@link Area} object with the highest priority containing specified location; {@code null} if there is no such area\n     *\n     * @see #getAreas\n     */", "            if(area.hasPlayer(player) && priority > lastPriority) {\n                currentArea.set(area);\n            }\n        });\n\n        return currentArea.get();\n    }\n\n    /**\n     * Gets the most prioritized area containing specified location. <p/>\n     * <b>Warning: </b> If there are two or more overlapping areas with same priority, when having specified location, {@link AreaPickEquivocationException} will be thrown.\n     * @param location Designated location\n     * @return {@link Area} object with the highest priority containing specified location; {@code null} if there is no such area\n     *\n     * @see #getAreas\n     */", "    public Area getArea(Location location){\n        Validate.notNull(location, \"location cannot be null\");\n\n        int lastPriority = Integer.MIN_VALUE;\n        AtomicReference<Area> currentArea = new AtomicReference<>(null);\n\n        areas.forEach((area, priority) -> {\n            if(area.hasLocation(location) && priority == lastPriority) throw new AreaPickEquivocationException();\n            if(area.hasLocation(location) && priority > lastPriority) {\n                currentArea.set(area);\n            }\n        });\n\n        return currentArea.get();\n    }\n\n    /**\n     * Gets all areas containing specified location.\n     * @param location Designated location\n     * @return HashSet of {@link Area} objects having all areas containing specified location; {@code null} if there is no such area\n     *\n     * @see #getArea\n     */\n\n    public HashSet<Area> getAreas(Location location) {\n        Validate.notNull(location, \"location cannot be null\");\n\n        HashSet<Area> areaSet = new HashSet<>();\n        areas.forEach((area, priority) -> {", "            if(area.hasLocation(location) && priority > lastPriority) {\n                currentArea.set(area);\n            }\n        });\n\n        return currentArea.get();\n    }\n\n    /**\n     * Gets all areas containing specified location.\n     * @param location Designated location\n     * @return HashSet of {@link Area} objects having all areas containing specified location; {@code null} if there is no such area\n     *\n     * @see #getArea\n     */\n\n    public HashSet<Area> getAreas(Location location) {\n        Validate.notNull(location, \"location cannot be null\");\n\n        HashSet<Area> areaSet = new HashSet<>();\n        areas.forEach((area, priority) -> {", "            if(area.hasLocation(location)) {\n                areaSet.add(area);\n            }\n        });\n        return areaSet;\n    }\n\n    /**\n     * Gets all areas containing specified location.\n     * @param player Player to be checked\n     * @return HashSet of {@link Area} objects having all areas specified player is in; {@code null} if there is no such area\n     *\n     * @see #getArea\n     */\n    public HashSet<Area> getAreas(Player player) {\n        Validate.notNull(player, \"player cannot be null\");\n\n        HashSet<Area> areaSet = new HashSet<>();\n        areas.forEach((area, priority) -> {", "            if(area.hasPlayer(player)) {\n                areaSet.add(area);\n            }\n        });\n        return areaSet;\n    }\n\n    /**\n     * @return {@code true} if controller is running; {@code false} if is not\n     */\n    public boolean isRunning(){\n        return running;\n    }\n\n    /**\n     * @return Associated plugin\n     */", "    public boolean isRunning(){\n        return running;\n    }\n\n    /**\n     * @return Associated plugin\n     */\n    public Plugin getPlugin() {\n        return plugin;\n    }\n\n    /**\n     * Starts or resumes the controller\n     */", "    public void start(){\n        running = true;\n    }\n\n    /**\n     * Stops the controller\n     */\n    public void stop(){\n        running = false;\n    }\n\n    private final class AreaMoveListener implements Listener {\n        @EventHandler", "        public void onPlayerMove(PlayerMoveEvent event) {\n            Player player = event.getPlayer();\n            Area newArea = getArea(event.getPlayer());\n            Area lastArea = players.get(player);\n            if(lastArea != newArea){\n                if(lastArea != null) {\n                    lastArea.onLeave(player);\n                    plugin.getServer().getPluginManager().callEvent(new AreaLeaveEvent(lastArea, player));\n                }\n                if(newArea != null) {\n                    newArea.onEnter(player);\n                    plugin.getServer().getPluginManager().callEvent(new AreaEnterEvent(newArea, lastArea, player));\n                }\n                players.put(player, newArea);\n            } else {", "                if(newArea != null) {\n                    newArea.onEnter(player);\n                    plugin.getServer().getPluginManager().callEvent(new AreaEnterEvent(newArea, lastArea, player));\n                }\n                players.put(player, newArea);\n            } else {\n                if (newArea != null) {\n                    newArea.onMove(player);\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/world/MapManager.java", "chunked_list": ["package dev.kavu.gameapi.world;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.Bukkit;\nimport org.bukkit.World;\nimport org.bukkit.WorldCreator;\n\nimport java.io.File;\nimport java.io.IOException;", "import java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\n/**\n * This class manages all maps of one game. It allows loading, unloading and restoring maps for the game. It operates on {@link GameMap} objects which are representation of single game maps.\n */\npublic class MapManager {\n\n    // Fields\n    private File activeWorldFolder;\n\n    private World world;\n\n    private GameMap currentMap;\n\n    // Constructor\n\n    /**\n     * Creates new instance of <tt>MapManager</tt> class.\n     */\n    public MapManager() {\n\n    }\n\n    // Getters & setters\n\n    /**\n     * @return Current loaded map; {@code null} if no map is loaded\n     */", "    public GameMap getCurrentMap() {\n        return currentMap;\n    }\n\n    /**\n     * @return World of currently loaded map\n     */\n    public World getWorld() {\n        return world;\n    }\n\n    // Functionality\n\n    /**\n     * Loads specified map. If any map is loaded already, new map won't be loaded<br/>\n     * Loading process consists in creating <i>new world</i> by copying its insides from source stored in {@link GameMap} object.\n     * Player won't be warped to this world automatically, thus it has to be done by hand.\n     * You can see how to do it in <a href=\"https://github.com/TheKaVu/GameAPI/wiki/World-Management\">GameAPI wiki</a>\n     * @param gameMap Game map to be loaded\n     * @return {@code true} if map was loaded; {@code false} otherwise\n     */", "    public boolean load(GameMap gameMap){\n        return load(gameMap, gameMap.getName() + \"_\" + System.currentTimeMillis());\n    }\n\n    /**\n     * Loads specified map and designates the world name. If any map is loaded already, new map won't be loaded<br/>\n     *      * Loading process consists in creating <i>new world</i> by copying its insides from source stored in {@link GameMap} object.\n     *      * Player won't be warped to this world automatically, thus it has to be done by hand.\n     *      * You can see how to do it in <a href=\"https://github.com/TheKaVu/GameAPI/wiki/World-Management\">GameAPI wiki</a>\n     *      * @param gameMap Game map to be loaded\n     *      * @return {@code true} if map was loaded; {@code false} otherwise\n     */", "    public boolean load(GameMap gameMap, String worldName){\n        Validate.notNull(gameMap, \"map cannot be null\");\n        Validate.notNull(worldName, \"worldName cannot be null\");\n\n        if(isLoaded()) return true;\n\n        this.currentMap = gameMap;\n        this.activeWorldFolder = new File(Bukkit.getWorldContainer().getParentFile(), worldName);\n\n        try {\n            FileUtils.copyDirectory(gameMap.getSource(), activeWorldFolder);\n        } catch (IOException ignored) {\n            return false;\n        }\n\n        world = Bukkit.getServer().createWorld(new WorldCreator(activeWorldFolder.getName()));\n", "        try {\n            FileUtils.copyDirectory(gameMap.getSource(), activeWorldFolder);\n        } catch (IOException ignored) {\n            return false;\n        }\n\n        world = Bukkit.getServer().createWorld(new WorldCreator(activeWorldFolder.getName()));\n\n        if(world != null) world.setAutoSave(false);\n\n        gameMap.onLoad(world);\n\n        return isLoaded();\n    }\n\n    /**\n     * Unloads currently loaded map. That includes unloading and removing associated world and its directory.\n     */", "        if(world != null) world.setAutoSave(false);\n\n        gameMap.onLoad(world);\n\n        return isLoaded();\n    }\n\n    /**\n     * Unloads currently loaded map. That includes unloading and removing associated world and its directory.\n     */\n    public void unload() {\n", "    public void unload() {\n\n        if(world != null) {\n            Bukkit.getServer().unloadWorld(world, false);\n        }\n\n        if(activeWorldFolder != null) {\n            try {\n                FileUtils.deleteDirectory(activeWorldFolder);\n            } catch (IOException ignored) {\n            }\n        }\n\n        world = null;\n        activeWorldFolder = null;\n    }\n\n    /**\n     * Restores - unloads and loads, currently stored map.\n     * @return {@code true} if map was successfully restored; {@code false} if not\n     */", "    public boolean restore() {\n        return restore(currentMap);\n    }\n\n    /**\n     * Unloads currently stored map and loads new one.\n     * @return {@code true} if map was successfully restored; {@code false} if not\n     */\n    public boolean restore(GameMap gameMap){\n        Validate.notNull(gameMap, \"map cannot be null\");\n        unload();\n        return load(gameMap);\n    }\n\n    /**\n     * @return {@code true} if any map is already loaded; {@code false} otherwise\n     */", "    public boolean restore(GameMap gameMap){\n        Validate.notNull(gameMap, \"map cannot be null\");\n        unload();\n        return load(gameMap);\n    }\n\n    /**\n     * @return {@code true} if any map is already loaded; {@code false} otherwise\n     */\n    public boolean isLoaded() {\n        return world != null && activeWorldFolder != null && currentMap != null;\n    }\n\n    /**\n     * Creates new game map represented by {@link GameMap} object.\n     * @param sourceFolder Directory map is located in\n     * @param mapName Name of the map and directory containing world data\n     * @param autoLoad Determines if map should be loaded automatically\n     * @return New game map\n     * @throws MapCreationException When map cannot be created due to improper data passed in arguments\n     */", "    public boolean isLoaded() {\n        return world != null && activeWorldFolder != null && currentMap != null;\n    }\n\n    /**\n     * Creates new game map represented by {@link GameMap} object.\n     * @param sourceFolder Directory map is located in\n     * @param mapName Name of the map and directory containing world data\n     * @param autoLoad Determines if map should be loaded automatically\n     * @return New game map\n     * @throws MapCreationException When map cannot be created due to improper data passed in arguments\n     */", "    public GameMap createMap(File sourceFolder, String mapName, boolean autoLoad) throws MapCreationException{\n        Validate.notNull(sourceFolder, \"sourceFolder cannot be null\");\n        Validate.isTrue(sourceFolder.isDirectory(), \"sourceFolder has to be a directory\");\n        Validate.notNull(mapName, \"mapName cannot be null\");\n\n        File file = new File(sourceFolder, mapName);\n\n        if(!file.exists()) throw new MapCreationException(\"Following directory does not exist: \" + file.getAbsolutePath());\n        if(!file.isDirectory()) throw new MapCreationException(\"Subdirectory of given name is not a directory\");\n\n        GameMap map = new GameMap() {\n\n            private final File source = file;\n\n            @Override", "        if(!file.isDirectory()) throw new MapCreationException(\"Subdirectory of given name is not a directory\");\n\n        GameMap map = new GameMap() {\n\n            private final File source = file;\n\n            @Override\n            public void onLoad(World world) {}\n\n            @Override\n            public String getName() {\n                return mapName;\n            }\n\n            @Override", "            public String getName() {\n                return mapName;\n            }\n\n            @Override\n            public File getSource() {\n                return source;\n            }\n\n        };\n        if(autoLoad) load(map);\n\n        return map;\n    }\n\n    /**\n     * Randomly picks and creates a map from specified directory.\n     * @param sourceFolder Directory desired maps are located in\n     * @param autoLoad Determines if picked map should be loaded automatically\n     * @return New and randomized game map\n     * @throws MapCreationException When there is no subdirectory containing a map data\n     */", "        if(autoLoad) load(map);\n\n        return map;\n    }\n\n    /**\n     * Randomly picks and creates a map from specified directory.\n     * @param sourceFolder Directory desired maps are located in\n     * @param autoLoad Determines if picked map should be loaded automatically\n     * @return New and randomized game map\n     * @throws MapCreationException When there is no subdirectory containing a map data\n     */", "    public GameMap randomizeMap(File sourceFolder, boolean autoLoad) throws MapCreationException {\n        Validate.isTrue(sourceFolder.isDirectory(), \"sourceFolder has to be a directory\");\n\n        Random random = new Random();\n        File[] files = sourceFolder.listFiles(file -> file.isDirectory());\n        if(files == null) throw new MapCreationException();\n        if (files.length == 0) throw new MapCreationException(\"There are no subdirectories in path: \" + sourceFolder.getAbsolutePath());\n\n        return createMap(sourceFolder, files[random.nextInt(files.length)].getName(), autoLoad) ;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameEndEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.Set;\n\n/**", "\n/**\n * Represents a game end event.\n */\npublic class GameEndEvent extends GameEvent implements Cancellable {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final Set<Player> players;\n    private boolean cancelled;\n\n    public GameEndEvent(Game game, Set<Player> players) {\n        super(game);\n        this.players = players;\n    }\n\n    /**\n     * @return Set of players present in the game\n     */\n    public Set<Player> getPlayers() {\n        return players;\n    }\n\n    @Override", "    public boolean isCancelled() {\n        return cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancel) {\n        this.cancelled = cancel;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameStartEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.Set;\n\n/**", "\n/**\n * Represents a game start event.\n */\npublic class GameStartEvent extends GameEvent implements Cancellable {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final Set<Player> players;\n    private boolean cancelled;\n\n    public GameStartEvent(Game game, Set<Player> players) {\n        super(game);\n        this.players = players;\n    }\n\n    /**\n     * @return Set of players the game has started with\n     */\n    public Set<Player> getPlayers() {\n        return players;\n    }\n\n    @Override", "    public boolean isCancelled() {\n        return cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancel) {\n        this.cancelled = cancel;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/ConditionalListener.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.plugin.EventExecutor;\nimport org.bukkit.plugin.Plugin;\n", "import org.bukkit.plugin.Plugin;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.Predicate;\n\n/**\n * This class is the special listener that can be surrounded with a condition that determines whether event will be passed forward or not.", "/**\n * This class is the special listener that can be surrounded with a condition that determines whether event will be passed forward or not.\n * <tt>ConditionalListener</tt> is the wrapping for any Bukkit {@link Listener} object.\n */\npublic class ConditionalListener {\n\n    // Fields\n    private final Listener handledListener;\n\n    private final BooleanSupplier noArgsCondition;\n    private final Predicate<Event> condition;\n\n    // Constructor\n\n    /**\n     * Creates new instance of Conditional listener with condition consuming no args.\n     * @param handledListener Listener to wrap\n     * @param noArgsCondition Condition with no arguments to be checked on event call\n     */\n    public ConditionalListener(Listener handledListener, BooleanSupplier noArgsCondition) {\n        this.noArgsCondition = (noArgsCondition == null) ? () -> true : noArgsCondition;\n        this.condition = event -> true;", "        if(handledListener == null){\n            throw new NullPointerException();\n        }\n        this.handledListener = handledListener;\n    }\n\n    /**\n     * Creates new instance of Conditional listener with argument condition.\n     * @param handledListener Listener to wrap\n     * @param condition Condition to be checked on event call\n     */\n    public ConditionalListener(Listener handledListener, Predicate<Event> condition) {\n        this.condition = (condition == null) ? event -> true : condition;\n        this.noArgsCondition = () -> true;", "        if(handledListener == null){\n            throw new NullPointerException();\n        }\n        this.handledListener = handledListener;\n    }\n\n    /**\n     * Creates new instance of Conditional listener with both no argument and argument conditions.\n     * @param handledListener Listener to wrap\n     * @param noArgsCondition Condition with no arguments to be checked on event call\n     * @param condition Condition to be checked on event call\n     */\n    public ConditionalListener(Listener handledListener, BooleanSupplier noArgsCondition, Predicate<Event> condition) {\n        this.condition = (condition == null) ? event -> true : condition;\n        this.noArgsCondition = (noArgsCondition == null) ? () -> true : noArgsCondition;", "        if(handledListener == null){\n            throw new NullPointerException();\n        }\n        this.handledListener = handledListener;\n    }\n\n    // Getters\n\n    /**\n     * @return Wrapped {@link Listener}\n     */", "    public Listener getHandledListener() {\n        return handledListener;\n    }\n\n    // Functionality\n\n    /**\n     * Registers this listener in specified plugin.\n     * @param plugin Plugin to register this listener in\n     */\n    public void register(Plugin plugin){\n        Validate.notNull(plugin, \"plugin cannot be null\");\n", "    public void register(Plugin plugin){\n        Validate.notNull(plugin, \"plugin cannot be null\");\n\n        for(Method method : handledListener.getClass().getDeclaredMethods()){\n            method.setAccessible(true);\n            if(!method.isAnnotationPresent(EventHandler.class)) continue;\n            if(!Modifier.isPublic(method.getModifiers())) continue;\n            if(method.getParameterCount() != 1) continue;\n            if(!Event.class.isAssignableFrom(method.getParameterTypes()[0])) continue;\n\n            System.out.println(\"Proper event handler\");\n", "            if(!Event.class.isAssignableFrom(method.getParameterTypes()[0])) continue;\n\n            System.out.println(\"Proper event handler\");\n\n            try {\n\n                BooleanSupplier finalNoArgsCondition = noArgsCondition;\n                Predicate<Event> finalCondition = condition;\n                Class<? extends Event> eventClass = (Class<? extends Event>) method.getParameterTypes()[0];\n                EventExecutor executor = (listener, event) -> {\n                    try {", "                    try {\n                        if(finalNoArgsCondition.getAsBoolean() && finalCondition.test(event)){\n                            System.out.println(\"condition check passed\");\n                            method.invoke(listener, event);\n                            System.out.println(\"event passed down to listener\");\n                        }\n                    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | ClassCastException ex) {\n                        ex.printStackTrace();\n                    }\n                };\n                System.out.println(\"executor assigned\");\n\n                plugin.getServer().getPluginManager().registerEvent(eventClass, handledListener, EventPriority.NORMAL, executor, plugin);\n                System.out.println(\"executor registered\");\n            } catch (ClassCastException ignored) {\n            }\n        }\n    }\n}"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameStateInitEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.GameState;\nimport dev.kavu.gameapi.GameStateTimer;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents a game state initialization event.\n */\npublic class GameStateInitEvent extends GameStateTimerEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameState previousState;\n\n    public GameStateInitEvent(GameStateTimer timer, GameState gameState, GameState previousState) {\n        super(timer, gameState);\n        this.previousState = previousState;\n    }\n\n    /**\n     * @return {@link GameState} the new state was initialized over\n     */", " */\npublic class GameStateInitEvent extends GameStateTimerEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameState previousState;\n\n    public GameStateInitEvent(GameStateTimer timer, GameState gameState, GameState previousState) {\n        super(timer, gameState);\n        this.previousState = previousState;\n    }\n\n    /**\n     * @return {@link GameState} the new state was initialized over\n     */", "    public GameState getPreviousState() {\n        return previousState;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n", "    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/AreaEnterEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.world.Area;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents an area enter event.\n */\npublic class AreaEnterEvent extends AreaEvent {\n\n    private static final HandlerList handlerList = new HandlerList();\n\n    private final Area previousArea;\n    private final Player player;\n\n    public AreaEnterEvent(Area area, Area previousArea, Player player) {\n        super(area);\n        this.player = player;\n        this.previousArea = previousArea;\n    }\n\n    /**\n     * @return The area player left by entering following area; {@code null} if wasn't in any\n     */", " */\npublic class AreaEnterEvent extends AreaEvent {\n\n    private static final HandlerList handlerList = new HandlerList();\n\n    private final Area previousArea;\n    private final Player player;\n\n    public AreaEnterEvent(Area area, Area previousArea, Player player) {\n        super(area);\n        this.player = player;\n        this.previousArea = previousArea;\n    }\n\n    /**\n     * @return The area player left by entering following area; {@code null} if wasn't in any\n     */", "    public Area getPreviousArea() {\n        return previousArea;\n    }\n\n    /**\n     * @return Player that entered following area\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    @Override", "    public HandlerList getHandlers() {\n        return handlerList;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlerList;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/AreaEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.world.Area;\nimport org.bukkit.event.Event;\n\n/**\n * Represents an area event.\n */\npublic abstract class AreaEvent extends Event {\n\n    private final Area area;\n\n    public AreaEvent(Area area) {\n        this.area = area;\n    }\n\n    /**\n     * @return The area this event applies to\n     */", "public abstract class AreaEvent extends Event {\n\n    private final Area area;\n\n    public AreaEvent(Area area) {\n        this.area = area;\n    }\n\n    /**\n     * @return The area this event applies to\n     */", "    public Area getArea() {\n        return area;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameStateEndEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.GameState;\nimport dev.kavu.gameapi.GameStateTimer;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents a game state end event.\n */\npublic class GameStateEndEvent extends GameStateTimerEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameState nextState;\n    private final boolean natural;\n\n    public GameStateEndEvent(GameStateTimer timer, GameState gameState, GameState nextState, boolean natural) {\n        super(timer, gameState);\n        this.nextState = nextState;\n        this.natural = natural;\n    }\n\n    /**\n     * @return Next {@link GameState} if scheduled; {@code null} if not\n     */", " */\npublic class GameStateEndEvent extends GameStateTimerEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameState nextState;\n    private final boolean natural;\n\n    public GameStateEndEvent(GameStateTimer timer, GameState gameState, GameState nextState, boolean natural) {\n        super(timer, gameState);\n        this.nextState = nextState;\n        this.natural = natural;\n    }\n\n    /**\n     * @return Next {@link GameState} if scheduled; {@code null} if not\n     */", "    public GameState getNextState() {\n        return nextState;\n    }\n\n    /**\n     * @return Was the following {@link GameState} terminated automatically or by hand\n     */\n    public boolean isNatural() {\n        return natural;\n    }\n\n    @Override", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/PlayerJoinGameEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.Set;\n\n/**", "\n/**\n * Represents player join game event.\n */\npublic class PlayerJoinGameEvent extends PlayerGameEvent implements Cancellable {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final Set<Player> players;\n    private boolean cancelled;\n\n    public PlayerJoinGameEvent(Game game, Player player, Set<Player> players) {\n        super(game, player);\n        this.players = players;\n    }\n\n    /**\n     * @return Set of players present in the game\n     */\n    public Set<Player> getPlayers() {\n        return players;\n    }\n\n    @Override", "    public boolean isCancelled() {\n        return cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancel) {\n        this.cancelled = cancel;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/PlayerLeaveGameEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.Set;\n/**\n * Represents player leave game event.\n */\npublic class PlayerLeaveGameEvent extends PlayerGameEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final Set<Player> players;\n\n    public PlayerLeaveGameEvent(Game game, Player player, Set<Player> players) {\n        super(game, player);\n        this.players = players;\n    }\n\n    /**\n     * @return Set of players present in the game\n     */\n    public Set<Player> getPlayers() {\n        return players;\n    }\n\n    @Override", " * Represents player leave game event.\n */\npublic class PlayerLeaveGameEvent extends PlayerGameEvent {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final Set<Player> players;\n\n    public PlayerLeaveGameEvent(Game game, Player player, Set<Player> players) {\n        super(game, player);\n        this.players = players;\n    }\n\n    /**\n     * @return Set of players present in the game\n     */\n    public Set<Player> getPlayers() {\n        return players;\n    }\n\n    @Override", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/AreaLeaveEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.world.Area;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents an area leave event.\n */\npublic class AreaLeaveEvent extends AreaEvent{\n\n    private static final HandlerList handlerList = new HandlerList();\n\n    private final Player player;\n\n    public AreaLeaveEvent(Area area, Player player) {\n        super(area);\n        this.player = player;\n    }\n\n    /**\n     * @return Player that left the area\n     */", " */\npublic class AreaLeaveEvent extends AreaEvent{\n\n    private static final HandlerList handlerList = new HandlerList();\n\n    private final Player player;\n\n    public AreaLeaveEvent(Area area, Player player) {\n        super(area);\n        this.player = player;\n    }\n\n    /**\n     * @return Player that left the area\n     */", "    public Player getPlayer() {\n        return player;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlerList;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlerList;\n    }\n}\n", "    public static HandlerList getHandlerList() {\n        return handlerList;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.event.Event;\n\n/**\n * Represents a game event.\n */\npublic abstract class GameEvent extends Event {\n\n    private final Game game;\n\n    public GameEvent(Game game) {\n        this.game = game;\n    }\n\n    /**\n     * @return Game this event happened in\n     */", "public abstract class GameEvent extends Event {\n\n    private final Game game;\n\n    public GameEvent(Game game) {\n        this.game = game;\n    }\n\n    /**\n     * @return Game this event happened in\n     */", "    public Game getGame() {\n        return game;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/PlayerGameEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.Game;\nimport org.bukkit.entity.Player;\n\n/**\n * Represents a player game event.\n */\npublic abstract class PlayerGameEvent extends GameEvent{\n\n    private final Player player;\n\n    public PlayerGameEvent(Game game, Player player) {\n        super(game);\n        this.player = player;\n    }\n\n    /**\n     * @return Player involved in this event\n     */", "public abstract class PlayerGameEvent extends GameEvent{\n\n    private final Player player;\n\n    public PlayerGameEvent(Game game, Player player) {\n        super(game);\n        this.player = player;\n    }\n\n    /**\n     * @return Player involved in this event\n     */", "    public Player getPlayer() {\n        return player;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GstScheduleEndEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.GameState;\nimport dev.kavu.gameapi.GameStateTimer;\nimport dev.kavu.gameapi.GstSchedule;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents game state timer schedule event.\n */\npublic class GstScheduleEndEvent extends GameStateTimerEvent{\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GstSchedule schedule;\n\n    public GstScheduleEndEvent(GameStateTimer timer, GameState gameState) {\n        super(timer, gameState);\n        this.schedule = timer.getSchedule();\n    }\n\n    /**\n     * @return {@link GstSchedule} involved in this event\n     */", " * Represents game state timer schedule event.\n */\npublic class GstScheduleEndEvent extends GameStateTimerEvent{\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GstSchedule schedule;\n\n    public GstScheduleEndEvent(GameStateTimer timer, GameState gameState) {\n        super(timer, gameState);\n        this.schedule = timer.getSchedule();\n    }\n\n    /**\n     * @return {@link GstSchedule} involved in this event\n     */", "    public GstSchedule getSchedule() {\n        return schedule;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n", "    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/StatisticTriggerEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.statistic.RegisteredStatistic;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.UUID;\n\n/**\n * Represents a statistic trigger event.", "/**\n * Represents a statistic trigger event.\n */\npublic class StatisticTriggerEvent extends Event {\n\n    // Fields\n    private static final HandlerList handlers = new HandlerList();\n\n    private final RegisteredStatistic<?> registeredStatistic;\n    private final UUID member;\n    private final Number value;\n    private final Event triggerEvent;\n\n    public StatisticTriggerEvent(RegisteredStatistic<?> registeredStatistic, UUID member, Number value) {\n        this.registeredStatistic = registeredStatistic;\n        this.member = member;\n        this.value = value;\n        this.triggerEvent = null;\n    }\n\n    public StatisticTriggerEvent(RegisteredStatistic<?> registeredStatistic, UUID member, Number value, Event triggerEvent) {\n        this.registeredStatistic = registeredStatistic;\n        this.member = member;\n        this.value = value;\n        this.triggerEvent = triggerEvent;\n    }\n\n    /**\n     * @return Triggered statistic represented by {@link RegisteredStatistic} object\n     */\n    public RegisteredStatistic<?> getRegisteredStatistic() {\n        return registeredStatistic;\n    }\n\n    /**\n     * @return Member the statistic was triggered for\n     */", "    public UUID getMember() {\n        return member;\n    }\n\n    /**\n     * @return Value of the statistic associated with member the statistic was triggered for\n     */\n    public Number getValue() {\n        return value;\n    }\n\n    /**\n     * @return Event that caused a trigger; {@code null} if trigger was manual\n     *\n     * @see RegisteredStatistic#trigger\n     */", "    public Event getTriggerEvent(){\n        return triggerEvent;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n", "    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n"]}
{"filename": "src/main/java/dev/kavu/gameapi/event/GameStateTimerEvent.java", "chunked_list": ["package dev.kavu.gameapi.event;\n\nimport dev.kavu.gameapi.GameState;\nimport dev.kavu.gameapi.GameStateTimer;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.HandlerList;\n\n/**\n * Represents a game state timer event.\n */\npublic class GameStateTimerEvent extends Event {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameStateTimer timer;\n    private final GameState gameState;\n\n    public GameStateTimerEvent(GameStateTimer timer, GameState gameState) {\n        this.timer = timer;\n        this.gameState = gameState;\n    }\n\n    /**\n     * @return {@link GameStateTimer} involved in this event\n     */", " * Represents a game state timer event.\n */\npublic class GameStateTimerEvent extends Event {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final GameStateTimer timer;\n    private final GameState gameState;\n\n    public GameStateTimerEvent(GameStateTimer timer, GameState gameState) {\n        this.timer = timer;\n        this.gameState = gameState;\n    }\n\n    /**\n     * @return {@link GameStateTimer} involved in this event\n     */", "    public GameStateTimer getTimer() {\n        return timer;\n    }\n\n    /**\n     * @return {@link GameState} this event relates to\n     */\n    public GameState getGameState() {\n        return gameState;\n    }\n\n    @Override", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList(){\n        return handlers;\n    }\n}\n"]}
