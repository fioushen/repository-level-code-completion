{"filename": "src/main/java/com/mrivanplays/papisigns/loader/PapiSignsLoader.java", "chunked_list": ["package com.mrivanplays.papisigns.loader;\n\nimport io.papermc.paper.plugin.loader.PluginClasspathBuilder;\nimport io.papermc.paper.plugin.loader.PluginLoader;\nimport io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver;\nimport java.io.IOException;\nimport java.util.jar.JarFile;\nimport java.util.jar.Manifest;\nimport org.eclipse.aether.artifact.DefaultArtifact;\nimport org.eclipse.aether.graph.Dependency;", "import org.eclipse.aether.artifact.DefaultArtifact;\nimport org.eclipse.aether.graph.Dependency;\nimport org.eclipse.aether.repository.RemoteRepository;\nimport org.jetbrains.annotations.NotNull;\n\npublic class PapiSignsLoader implements PluginLoader {\n\n  @Override\n  public void classloader(@NotNull PluginClasspathBuilder classpathBuilder) {\n    Manifest manifest;\n    try {\n      var jar = new JarFile(classpathBuilder.getContext().getPluginSource().toFile());\n      manifest = jar.getManifest();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    var cloudVersion = manifest.getMainAttributes().getValue(\"cloudVersion\");\n    var annotatedConfigVersion = manifest.getMainAttributes().getValue(\"acVersion\");\n\n    var resolver = new MavenLibraryResolver();\n    resolver.addRepository(\n        new RemoteRepository.Builder(\n                \"ivan\", \"default\", \"https://repo.mrivanplays.com/repository/ivan/\")\n            .build());\n    resolver.addRepository(\n        new RemoteRepository.Builder(\"central\", \"default\", \"https://repo.maven.apache.org/maven2\")\n            .build());\n\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\n                \"com.mrivanplays:annotationconfig-yaml:%s\".formatted(annotatedConfigVersion)),\n            null));\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\"cloud.commandframework:cloud-paper:%s\".formatted(cloudVersion)),\n            null));\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\n                \"cloud.commandframework:cloud-minecraft-extras:%s\".formatted(cloudVersion)),\n            null));\n\n    classpathBuilder.addLibrary(resolver);\n  }\n}\n", "  public void classloader(@NotNull PluginClasspathBuilder classpathBuilder) {\n    Manifest manifest;\n    try {\n      var jar = new JarFile(classpathBuilder.getContext().getPluginSource().toFile());\n      manifest = jar.getManifest();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    var cloudVersion = manifest.getMainAttributes().getValue(\"cloudVersion\");\n    var annotatedConfigVersion = manifest.getMainAttributes().getValue(\"acVersion\");\n\n    var resolver = new MavenLibraryResolver();\n    resolver.addRepository(\n        new RemoteRepository.Builder(\n                \"ivan\", \"default\", \"https://repo.mrivanplays.com/repository/ivan/\")\n            .build());\n    resolver.addRepository(\n        new RemoteRepository.Builder(\"central\", \"default\", \"https://repo.maven.apache.org/maven2\")\n            .build());\n\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\n                \"com.mrivanplays:annotationconfig-yaml:%s\".formatted(annotatedConfigVersion)),\n            null));\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\"cloud.commandframework:cloud-paper:%s\".formatted(cloudVersion)),\n            null));\n    resolver.addDependency(\n        new Dependency(\n            new DefaultArtifact(\n                \"cloud.commandframework:cloud-minecraft-extras:%s\".formatted(cloudVersion)),\n            null));\n\n    classpathBuilder.addLibrary(resolver);\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/loader/PapiSigns.java", "chunked_list": ["package com.mrivanplays.papisigns.loader;\n\nimport cloud.commandframework.bukkit.CloudBukkitCapabilities;\nimport cloud.commandframework.execution.CommandExecutionCoordinator;\nimport cloud.commandframework.minecraft.extras.MinecraftHelp;\nimport cloud.commandframework.minecraft.extras.MinecraftHelp.HelpColors;\nimport cloud.commandframework.paper.PaperCommandManager;\nimport com.mrivanplays.annotationconfig.core.resolver.settings.ACDefaultSettings;\nimport com.mrivanplays.annotationconfig.core.resolver.settings.NullReadHandleOption;\nimport com.mrivanplays.annotationconfig.core.resolver.settings.Settings;", "import com.mrivanplays.annotationconfig.core.resolver.settings.NullReadHandleOption;\nimport com.mrivanplays.annotationconfig.core.resolver.settings.Settings;\nimport com.mrivanplays.annotationconfig.core.serialization.SerializerRegistry;\nimport com.mrivanplays.annotationconfig.yaml.YamlConfig;\nimport com.mrivanplays.papisigns.command.BaseCommand;\nimport com.mrivanplays.papisigns.data.PSConfig;\nimport com.mrivanplays.papisigns.listener.PlaceholderUpdateListener;\nimport com.mrivanplays.papisigns.provider.MiniPlaceholdersProvider;\nimport com.mrivanplays.papisigns.provider.PlaceholderAPIProvider;\nimport com.mrivanplays.papisigns.provider.PlaceholderProvider;", "import com.mrivanplays.papisigns.provider.PlaceholderAPIProvider;\nimport com.mrivanplays.papisigns.provider.PlaceholderProvider;\nimport java.io.File;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.stream.Stream;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.NamespacedKey;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.plugin.java.JavaPlugin;", "import org.bukkit.command.CommandSender;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class PapiSigns extends JavaPlugin {\n\n  public static final NamespacedKey TAGGED_SIGNS_KEY =\n      new NamespacedKey(\"papisigns\", \"tagged-sign\");\n\n  private static final Settings CONFIG_SETTINGS =\n      new Settings()\n          .put(ACDefaultSettings.NULL_READ_HANDLER, NullReadHandleOption.USE_DEFAULT_VALUE)\n          .put(ACDefaultSettings.SHOULD_REVERSE_FIELDS, true)\n          .put(ACDefaultSettings.GENERATE_NEW_OPTIONS, true)\n          .put(ACDefaultSettings.FIND_PARENT_FIELDS, false);\n\n  private PSConfig config;\n  private MinecraftHelp<CommandSender> helpMenu;\n  private PlaceholderProvider placeholderProvider;\n\n  @Override", "  public void onEnable() {\n    this.placeholderProvider =\n        Stream.of(new MiniPlaceholdersProvider(), new PlaceholderAPIProvider())\n            .filter(PlaceholderProvider::available)\n            .findFirst()\n            .orElse(null);\n\n    if (placeholderProvider == null) {\n      getLogger().info(\"No compatible placeholder provider plugin found; disabling plugin.\");\n      getServer().getPluginManager().disablePlugin(this);\n      return;\n    } else {\n      getLogger().info(\"Using \" + placeholderProvider.name() + \" as PlaceholderProvider\");\n    }\n", "    if (!getDataFolder().exists()) {\n      getDataFolder().mkdirs();\n    }\n    SerializerRegistry serializerRegistry = SerializerRegistry.INSTANCE;\n    if (!serializerRegistry.hasSerializer(Component.class)) {\n      serializerRegistry.registerSerializer(Component.class, new PSConfig.ComponentSerializer());\n    }\n    if (!serializerRegistry.hasSerializer(HelpColors.class)) {\n      serializerRegistry.registerSerializer(HelpColors.class, new PSConfig.HelpColorsSerializer());\n    }\n    config = new PSConfig();\n    YamlConfig.getConfigResolver()\n        .loadOrDump(config, new File(getDataFolder(), \"config.yml\"), CONFIG_SETTINGS);\n", "    try {\n      PaperCommandManager<CommandSender> commandManager =\n          new PaperCommandManager<>(\n              this,\n              CommandExecutionCoordinator.simpleCoordinator(),\n              Function.identity(),\n              Function.identity());\n\n      if (commandManager.hasCapability(CloudBukkitCapabilities.BRIGADIER)) {\n        commandManager.registerBrigadier();\n      }", "      if (commandManager.hasCapability(CloudBukkitCapabilities.BRIGADIER)) {\n        commandManager.registerBrigadier();\n      }\n      if (commandManager.hasCapability(CloudBukkitCapabilities.ASYNCHRONOUS_COMPLETION)) {\n        commandManager.registerAsynchronousCompletions();\n      }\n\n      BaseCommand.register(this, commandManager);\n\n      this.helpMenu = new MinecraftHelp<>(\"/papisigns help\", sender -> sender, commandManager);\n\n      this.helpMenu.messageProvider(\n          (sender, key, args) -> config.getMessages().getHelpCmd().getMessage(key));\n      this.helpMenu.setHelpColors(config.getMessages().getHelpCmd().getHelpColors());\n    } catch (Exception e) {\n      getLogger()\n          .log(\n              Level.SEVERE,\n              \"Something went wrong with command manager initialization, shutting down\",\n              e);\n      getServer().getPluginManager().disablePlugin(this);\n      return;\n    }\n    getServer().getPluginManager().registerEvents(new PlaceholderUpdateListener(this), this);\n    getLogger().info(\"Enabled\");\n  }\n\n  @Override", "  public void onDisable() {\n    getLogger().info(\"Disabled\");\n  }\n\n  public void reload() {\n    YamlConfig.getConfigResolver()\n        .loadOrDump(config, new File(getDataFolder(), \"config.yml\"), CONFIG_SETTINGS);\n  }\n\n  public PSConfig getPSConfig() {\n    return this.config;\n  }\n\n  public MinecraftHelp<CommandSender> getHelpMenu() {\n    return this.helpMenu;\n  }\n", "  public PSConfig getPSConfig() {\n    return this.config;\n  }\n\n  public MinecraftHelp<CommandSender> getHelpMenu() {\n    return this.helpMenu;\n  }\n\n  public PlaceholderProvider provider() {\n    return this.placeholderProvider;\n  }\n}\n", "  public PlaceholderProvider provider() {\n    return this.placeholderProvider;\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/data/SignDataType.java", "chunked_list": ["package com.mrivanplays.papisigns.data;\n\nimport com.google.common.io.ByteArrayDataInput;\nimport com.google.common.io.ByteArrayDataOutput;\nimport com.google.common.io.ByteStreams;\nimport java.util.HashMap;\nimport java.util.Map;\nimport net.kyori.adventure.text.format.TextColor;\nimport org.bukkit.block.sign.Side;\nimport org.bukkit.persistence.PersistentDataAdapterContext;", "import org.bukkit.block.sign.Side;\nimport org.bukkit.persistence.PersistentDataAdapterContext;\nimport org.bukkit.persistence.PersistentDataType;\nimport org.jetbrains.annotations.NotNull;\n\npublic class SignDataType implements PersistentDataType<byte[], SignData> {\n\n  public static final SignDataType INSTANCE = new SignDataType();\n\n  public static final int VERSION = 101;\n\n  private SignDataType() {}\n\n  @Override\n  public @NotNull Class<byte[]> getPrimitiveType() {\n    return byte[].class;\n  }\n\n  @Override\n  public @NotNull Class<SignData> getComplexType() {\n    return SignData.class;\n  }\n\n  @Override\n  public byte @NotNull [] toPrimitive(\n      @NotNull SignData complex, @NotNull PersistentDataAdapterContext context) {\n    var out = ByteStreams.newDataOutput();\n    // since 1.0.0's format read starts with an integer too, make this also an integer, in order\n    // for 1.0.1's read method to determine whether it's dealing with the old or the new format\n    // and since the line numbers on signs can't go over 4, a number above 4 is suitable for a mark\n    out.writeInt(VERSION);\n    var twoSidesOccupied = complex.areTwoSidesOccupied();\n    out.writeBoolean(twoSidesOccupied);\n    var frontSideMap = complex.data().get(Side.FRONT);", "  public static final int VERSION = 101;\n\n  private SignDataType() {}\n\n  @Override\n  public @NotNull Class<byte[]> getPrimitiveType() {\n    return byte[].class;\n  }\n\n  @Override\n  public @NotNull Class<SignData> getComplexType() {\n    return SignData.class;\n  }\n\n  @Override\n  public byte @NotNull [] toPrimitive(\n      @NotNull SignData complex, @NotNull PersistentDataAdapterContext context) {\n    var out = ByteStreams.newDataOutput();\n    // since 1.0.0's format read starts with an integer too, make this also an integer, in order\n    // for 1.0.1's read method to determine whether it's dealing with the old or the new format\n    // and since the line numbers on signs can't go over 4, a number above 4 is suitable for a mark\n    out.writeInt(VERSION);\n    var twoSidesOccupied = complex.areTwoSidesOccupied();\n    out.writeBoolean(twoSidesOccupied);\n    var frontSideMap = complex.data().get(Side.FRONT);", "    if (frontSideMap != null && !frontSideMap.isEmpty()) {\n      if (!twoSidesOccupied) {\n        out.writeUTF(\"FRONT\");\n      }\n      this.writeEntries(frontSideMap, out);\n    }\n    var backSideMap = complex.data().get(Side.BACK);\n    if (backSideMap != null && !backSideMap.isEmpty()) {\n      if (!twoSidesOccupied) {\n        out.writeUTF(\"BACK\");\n      }\n      this.writeEntries(backSideMap, out);\n    }\n    return out.toByteArray();\n  }\n\n  private void writeEntries(Map<Integer, SingleSignData> map, ByteArrayDataOutput out) {\n    out.writeInt(map.size());", "      if (!twoSidesOccupied) {\n        out.writeUTF(\"BACK\");\n      }\n      this.writeEntries(backSideMap, out);\n    }\n    return out.toByteArray();\n  }\n\n  private void writeEntries(Map<Integer, SingleSignData> map, ByteArrayDataOutput out) {\n    out.writeInt(map.size());\n    for (var entry : map.entrySet()) {\n      out.writeInt(entry.getKey());\n      out.writeBoolean(entry.getValue().placeholder() != null);", "    for (var entry : map.entrySet()) {\n      out.writeInt(entry.getKey());\n      out.writeBoolean(entry.getValue().placeholder() != null);\n      if (entry.getValue().placeholder() != null) {\n        out.writeUTF(entry.getValue().placeholder());\n      }\n      out.writeBoolean(entry.getValue().color() != null);\n      if (entry.getValue().color() != null) {\n        out.writeUTF(entry.getValue().color().asHexString());\n      }\n    }\n  }\n\n  @Override\n  public @NotNull SignData fromPrimitive(\n      byte @NotNull [] primitive, @NotNull PersistentDataAdapterContext context) {\n    var in = ByteStreams.newDataInput(primitive);\n    var version = in.readInt();", "    if (version == VERSION) {\n      // new format\n      Map<Side, Map<Integer, SingleSignData>> map = new HashMap<>();\n      if (in.readBoolean()) {\n        // when both sides are occupied, Side is not sent, as the front side is always written\n        // first, and then the back side\n        var frontSize = in.readInt();\n        map.put(Side.FRONT, this.readSignData(in, frontSize));\n        var backSize = in.readInt();\n        map.put(Side.BACK, this.readSignData(in, backSize));\n      } else {\n        var side = Side.valueOf(in.readUTF());\n        var size = in.readInt();\n        map.put(side, this.readSignData(in, size));\n      }\n      return new SignData(map);\n    } else {\n      // old format\n      Map<Side, Map<Integer, SingleSignData>> map = new HashMap<>();\n      map.put(Side.FRONT, this.readSignData(in, version));\n      return new SignData(map);\n    }\n  }\n\n  private Map<Integer, SingleSignData> readSignData(ByteArrayDataInput in, int size) {\n    Map<Integer, SingleSignData> map = new HashMap<>(size);", "    for (int i = 0; i < size; i++) {\n      var line = in.readInt();\n      String placeholder = null;\n      if (in.readBoolean()) {\n        placeholder = in.readUTF();\n      }\n      TextColor color = null;\n      if (in.readBoolean()) {\n        color = TextColor.fromHexString(in.readUTF());\n      }\n      map.put(line, new SingleSignData(placeholder, color));\n    }\n    return map;\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/data/SignData.java", "chunked_list": ["package com.mrivanplays.papisigns.data;\n\nimport java.util.Map;\nimport org.bukkit.block.sign.Side;\n\npublic record SignData(Map<Side, Map<Integer, SingleSignData>> data) {\n\n  public boolean areTwoSidesOccupied() {\n    return this.data.containsKey(Side.FRONT) && this.data.containsKey(Side.BACK);\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/data/SingleSignData.java", "chunked_list": ["package com.mrivanplays.papisigns.data;\n\nimport net.kyori.adventure.text.format.TextColor;\n\npublic record SingleSignData(String placeholder, TextColor color) {}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/data/PSConfig.java", "chunked_list": ["package com.mrivanplays.papisigns.data;\n\nimport cloud.commandframework.minecraft.extras.MinecraftHelp;\nimport cloud.commandframework.minecraft.extras.MinecraftHelp.HelpColors;\nimport com.mrivanplays.annotationconfig.core.annotations.ConfigObject;\nimport com.mrivanplays.annotationconfig.core.annotations.Ignore;\nimport com.mrivanplays.annotationconfig.core.annotations.Key;\nimport com.mrivanplays.annotationconfig.core.annotations.comment.Comment;\nimport com.mrivanplays.annotationconfig.core.serialization.AnnotationAccessor;\nimport com.mrivanplays.annotationconfig.core.serialization.DataObject;", "import com.mrivanplays.annotationconfig.core.serialization.AnnotationAccessor;\nimport com.mrivanplays.annotationconfig.core.serialization.DataObject;\nimport com.mrivanplays.annotationconfig.core.serialization.FieldTypeSerializer;\nimport com.mrivanplays.annotationconfig.core.serialization.SerializationContext;\nimport com.mrivanplays.annotationconfig.core.utils.AnnotationUtils;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;", "import java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport net.kyori.adventure.text.format.TextColor;\nimport net.kyori.adventure.text.minimessage.MiniMessage;", "import net.kyori.adventure.text.format.TextColor;\nimport net.kyori.adventure.text.minimessage.MiniMessage;\nimport net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;\n\n@Comment(\"PAPISigns configuration\")\npublic class PSConfig {\n\n  public static class ComponentSerializer implements FieldTypeSerializer<Component> {\n\n    @Override\n    public Component deserialize(\n        DataObject data, SerializationContext<Component> context, AnnotationAccessor annotations) {", "    public Component deserialize(\n        DataObject data, SerializationContext<Component> context, AnnotationAccessor annotations) {\n      if (annotations.getAnnotation(PlainComponent.class).isPresent()) {\n        return PlainTextComponentSerializer.plainText().deserialize(data.getAsString());\n      }\n      return MiniMessage.miniMessage().deserialize(data.getAsString());\n    }\n\n    @Override\n    public DataObject serialize(\n        Component value, SerializationContext<Component> context, AnnotationAccessor annotations) {", "    public DataObject serialize(\n        Component value, SerializationContext<Component> context, AnnotationAccessor annotations) {\n      if (annotations.getAnnotation(PlainComponent.class).isPresent()) {\n        return new DataObject(PlainTextComponentSerializer.plainText().serialize(value));\n      }\n      return new DataObject(MiniMessage.miniMessage().serialize(value));\n    }\n  }\n\n  public static class HelpColorsSerializer implements FieldTypeSerializer<HelpColors> {\n\n    @Override", "  public static class HelpColorsSerializer implements FieldTypeSerializer<HelpColors> {\n\n    @Override\n    public HelpColors deserialize(\n        DataObject data, SerializationContext<HelpColors> context, AnnotationAccessor annotations) {\n      if (!data.has(\"primary\")\n          || !data.has(\"highlight\")\n          || !data.has(\"alternateHighlight\")\n          || !data.has(\"text\")\n          || !data.has(\"accent\")) {\n        throw new IllegalArgumentException(\n            \"Missing help colors ; cannot parse config ; please delete this section of the config (it will automatically regenerate)\");\n      }\n      var primaryStr = data.get(\"primary\").getAsString();\n      var highlightStr = data.get(\"highlight\").getAsString();\n      var alternateHighlightStr = data.get(\"alternateHighlight\").getAsString();\n      var textStr = data.get(\"text\").getAsString();\n      var accentStr = data.get(\"accent\").getAsString();\n      return HelpColors.of(\n          toTextColor(primaryStr),\n          toTextColor(highlightStr),\n          toTextColor(alternateHighlightStr),\n          toTextColor(textStr),\n          toTextColor(accentStr));\n    }\n\n    private TextColor toTextColor(String str) {", "      if (str.contains(\"#\")) {\n        return TextColor.fromHexString(str);\n      }\n      return NamedTextColor.NAMES.value(str);\n    }\n\n    @Override\n    public DataObject serialize(\n        HelpColors value,\n        SerializationContext<HelpColors> context,\n        AnnotationAccessor annotations) {\n      var ret = new DataObject();", "      for (var field : value.getClass().getDeclaredFields()) {\n        var key = field.getName();\n        field.setAccessible(true);\n        TextColor color;\n        try {\n          color = (TextColor) field.get(value);\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n        String serialized;\n        if (color instanceof NamedTextColor named) {\n          serialized = named.toString();\n        } else {\n          serialized = color.asHexString();\n        }\n        ret.put(key, serialized);\n      }\n      return ret;\n    }\n  }\n\n  @Documented\n  @Retention(RetentionPolicy.RUNTIME)\n  @Target(ElementType.FIELD)\n  public @interface PlainComponent {}\n\n  @Comment(\"The maximum distance to be searched for a sign.\")\n  @Comment(\"Making this value very high can result in lag\")\n  private int maxDistance = 5;\n\n  @Comment(\"Placeholders which shall not be replaced\")\n  private List<String> forbiddenPlaceholders = Arrays.asList(\"%balance%\", \"%balance_MrIvanPlays%\");\n\n  @ConfigObject private Messages messages = new Messages();\n\n  @Comment(\"All configurable messages\")\n  @Comment(\"MiniMessage format is supported, LEGACY FORMAT IS NOT\")", "        if (color instanceof NamedTextColor named) {\n          serialized = named.toString();\n        } else {\n          serialized = color.asHexString();\n        }\n        ret.put(key, serialized);\n      }\n      return ret;\n    }\n  }\n\n  @Documented\n  @Retention(RetentionPolicy.RUNTIME)\n  @Target(ElementType.FIELD)\n  public @interface PlainComponent {}\n\n  @Comment(\"The maximum distance to be searched for a sign.\")\n  @Comment(\"Making this value very high can result in lag\")\n  private int maxDistance = 5;\n\n  @Comment(\"Placeholders which shall not be replaced\")\n  private List<String> forbiddenPlaceholders = Arrays.asList(\"%balance%\", \"%balance_MrIvanPlays%\");\n\n  @ConfigObject private Messages messages = new Messages();\n\n  @Comment(\"All configurable messages\")\n  @Comment(\"MiniMessage format is supported, LEGACY FORMAT IS NOT\")", "  public static class Messages {\n\n    @Key(\"not-a-sign\")\n    private Component notASign =\n        Component.text(\"The block you're facing is not a sign!\", NamedTextColor.RED);\n\n    @Key(\"forbidden-placeholder\")\n    private Component forbiddenPlaceholder =\n        Component.text(\"That placeholder is forbidden!\", NamedTextColor.RED);\n\n    @Key(\"line-change-success\")\n    private Component lineChangedSuccess =\n        Component.text(\"Line changed successfully!\", NamedTextColor.GREEN);\n\n    @Key(\"color-changed-success\")\n    private Component colorChangedSuccess =\n        Component.text(\"Color changed successfully!\", NamedTextColor.GREEN);\n\n    @Key(\"warning-placeholder-not-set\")\n    private Component warningNotSet =\n        Component.text(\n            \"WARNING: Placeholder not set. You may want to set a placeholder, otherwise the changes won't affect the sign in any way.\");\n\n    @Key(\"reload-success\")\n    private Component reloadSuccess =\n        Component.text(\"Configuration reloaded successfully!\", NamedTextColor.GREEN);\n\n    @ConfigObject\n    @Key(\"help-command\")\n    private HelpMessages helpCmd = new HelpMessages();\n\n    @Comment(\"Messages of the /papisigns help command\")\n    @Comment(\"Colors are NOT supported\")", "    public static class HelpMessages {\n\n      @PlainComponent private Component help = Component.text(\"Help\");\n\n      @PlainComponent private Component command = Component.text(\"Command\");\n\n      @PlainComponent private Component description = Component.text(\"Description\");\n\n      @PlainComponent\n      @Key(\"no_description\")\n      private Component noDescription = Component.text(\"No Description\");\n\n      @PlainComponent private Component arguments = Component.text(\"Arguments\");\n\n      @PlainComponent private Component optional = Component.text(\"Optional\");\n\n      @PlainComponent\n      @Key(\"showing_results_for_query\")\n      private Component showingResultsForQuery = Component.text(\"Showing results for query\");\n\n      @PlainComponent\n      @Key(\"no_results_for_query\")\n      private Component noResultsForQuery = Component.text(\"No results for query\");\n\n      @PlainComponent\n      @Key(\"available_commands\")\n      private Component availableCommands = Component.text(\"Available Commands\");\n\n      @PlainComponent\n      @Key(\"click_to_show_help\")\n      private Component clickToShowHelp = Component.text(\"Click to show help for this command\");\n\n      @PlainComponent\n      @Key(\"page_out_of_range\")\n      private Component pageOutOfRange =\n          Component.text(\"Error: Page <page> is not in range. Must be in range [1, <max_pages>]\");\n\n      @PlainComponent\n      @Key(\"click_for_next_page\")\n      private Component clickForNextPage = Component.text(\"Click for next page\");\n\n      @PlainComponent\n      @Key(\"click_for_previous_page\")\n      private Component clickForPreviousPage = Component.text(\"Click for previous page\");\n\n      @Comment(\"The colors of the /papisigns help are controlled here\")\n      private HelpColors helpColors = MinecraftHelp.DEFAULT_HELP_COLORS;\n\n      @Ignore private Map<String, Component> cachedMessages;\n", "      public Component getMessage(String key) {\n        if (cachedMessages == null) {\n          cachedMessages = new HashMap<>();\n          for (var field : this.getClass().getDeclaredFields()) {\n            if (!Component.class.isAssignableFrom(field.getType())) {\n              continue;\n            }\n            var fieldKey = AnnotationUtils.getKey(field);\n            field.setAccessible(true);\n            try {\n              cachedMessages.put(fieldKey, (Component) field.get(this));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n        return cachedMessages.get(key);\n      }\n", "            try {\n              cachedMessages.put(fieldKey, (Component) field.get(this));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n        return cachedMessages.get(key);\n      }\n\n      public HelpColors getHelpColors() {\n        return helpColors;\n      }\n    }\n", "      public HelpColors getHelpColors() {\n        return helpColors;\n      }\n    }\n\n    public Component getNotASign() {\n      return notASign;\n    }\n\n    public Component getForbiddenPlaceholder() {\n      return forbiddenPlaceholder;\n    }\n", "    public Component getForbiddenPlaceholder() {\n      return forbiddenPlaceholder;\n    }\n\n    public Component getLineChangedSuccess() {\n      return lineChangedSuccess;\n    }\n\n    public Component getColorChangedSuccess() {\n      return colorChangedSuccess;\n    }\n", "    public Component getColorChangedSuccess() {\n      return colorChangedSuccess;\n    }\n\n    public Component getWarningNotSet() {\n      return warningNotSet;\n    }\n\n    public Component getReloadSuccess() {\n      return reloadSuccess;\n    }\n", "    public Component getReloadSuccess() {\n      return reloadSuccess;\n    }\n\n    public HelpMessages getHelpCmd() {\n      return helpCmd;\n    }\n  }\n\n  public int getMaxDistance() {\n    return this.maxDistance;\n  }\n\n  public List<String> getForbiddenPlaceholders() {\n    return this.forbiddenPlaceholders;\n  }\n", "  public int getMaxDistance() {\n    return this.maxDistance;\n  }\n\n  public List<String> getForbiddenPlaceholders() {\n    return this.forbiddenPlaceholders;\n  }\n\n  public Messages getMessages() {\n    return messages;\n  }\n}\n", "  public Messages getMessages() {\n    return messages;\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/command/BaseCommand.java", "chunked_list": ["package com.mrivanplays.papisigns.command;\n\nimport cloud.commandframework.ArgumentDescription;\nimport cloud.commandframework.CommandHelpHandler;\nimport cloud.commandframework.arguments.standard.EnumArgument;\nimport cloud.commandframework.arguments.standard.IntegerArgument;\nimport cloud.commandframework.arguments.standard.StringArgument;\nimport cloud.commandframework.context.CommandContext;\nimport cloud.commandframework.minecraft.extras.TextColorArgument;\nimport cloud.commandframework.paper.PaperCommandManager;", "import cloud.commandframework.minecraft.extras.TextColorArgument;\nimport cloud.commandframework.paper.PaperCommandManager;\nimport com.mrivanplays.papisigns.data.PSConfig;\nimport com.mrivanplays.papisigns.data.SignData;\nimport com.mrivanplays.papisigns.data.SignDataType;\nimport com.mrivanplays.papisigns.data.SingleSignData;\nimport com.mrivanplays.papisigns.loader.PapiSigns;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;", "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.stream.Collectors;\nimport net.kyori.adventure.text.format.TextColor;\nimport org.bukkit.block.Sign;\nimport org.bukkit.block.sign.Side;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;", "import org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\npublic class BaseCommand {\n\n  public static void register(PapiSigns plugin, PaperCommandManager<CommandSender> manager) {\n    PSConfig config = plugin.getPSConfig();\n    manager.command(\n        manager\n            .commandBuilder(\"papisign\", ArgumentDescription.of(\"Base PAPISigns command\"))\n            .literal(\n                \"set\", ArgumentDescription.of(\"Set placeholder/color of a line of a facing sign\"))\n            .permission(\"papisign.set\")\n            .literal(\n                \"placeholder\",\n                ArgumentDescription.of(\"Set a line of a facing sign to the placeholder inputted\"))\n            .senderType(Player.class)\n            .argument(\n                EnumArgument.<CommandSender, Side>builder(Side.class, \"Side\").asRequired().build(),\n                ArgumentDescription.of(\n                    \"The side of the sign of which you want the placeholder to apply\"))\n            .argument(\n                IntegerArgument.<CommandSender>builder(\"line\")\n                    .withMin(1)\n                    .withMax(4)\n                    .withSuggestionsProvider(lineSuggestions())\n                    .asRequired()\n                    .build(),\n                ArgumentDescription.of(\"The line to manipulate\"))\n            .argument(\n                StringArgument.<CommandSender>builder(\"placeholder\").greedy().asRequired().build(),\n                ArgumentDescription.of(\"The placeholder you want to be displayed\"))\n            .handler(\n                context -> {\n                  var player = (Player) context.getSender();\n                  Side signSide = context.get(\"Side\");\n                  var block = player.getTargetBlockExact(config.getMaxDistance());", "                  if (!(block.getState() instanceof Sign sign)) {\n                    player.sendMessage(plugin.getPSConfig().getMessages().getNotASign());\n                    return;\n                  }\n                  int lineRaw = context.get(\"line\");\n                  var line = lineRaw - 1;\n                  String placeholder = context.get(\"placeholder\");\n                  if (config.getForbiddenPlaceholders().contains(placeholder)) {\n                    player.sendMessage(\n                        plugin.getPSConfig().getMessages().getForbiddenPlaceholder());\n                    return;\n                  }\n\n                  var dataContainer = sign.getPersistentDataContainer();", "                  if (dataContainer.has(PapiSigns.TAGGED_SIGNS_KEY)) {\n                    var signData =\n                        dataContainer.get(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE);\n                    if (signData.data().containsKey(signSide)) {\n                      var signDataData = signData.data().get(signSide);\n                      if (signDataData.containsKey(line)) {\n                        var singleSignData = signDataData.get(line);\n                        signDataData.replace(\n                            line, new SingleSignData(placeholder, singleSignData.color()));\n                      } else {\n                        signDataData.put(line, new SingleSignData(placeholder, null));\n                      }\n                      signData.data().replace(signSide, signDataData);\n                    } else {\n                      Map<Integer, SingleSignData> map = new HashMap<>();\n                      map.put(line, new SingleSignData(placeholder, null));\n                      signData.data().put(signSide, map);\n                    }\n                    dataContainer.set(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE, signData);\n                  } else {\n                    Map<Integer, SingleSignData> map = new HashMap<>();\n                    map.put(line, new SingleSignData(placeholder, null));\n                    Map<Side, Map<Integer, SingleSignData>> mapRet = new HashMap<>();\n                    mapRet.put(signSide, map);\n                    dataContainer.set(\n                        PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE, new SignData(mapRet));\n                  }\n                  sign.update();\n\n                  player.sendMessage(plugin.getPSConfig().getMessages().getLineChangedSuccess());\n                }));\n\n    manager.command(\n        manager\n            .commandBuilder(\"papisign\", ArgumentDescription.of(\"Base PAPISigns command\"))\n            .literal(\n                \"set\", ArgumentDescription.of(\"Set placeholder/color of a line of a facing sign\"))\n            .permission(\"papisign.set\")\n            .literal(\n                \"color\",\n                ArgumentDescription.of(\"Set the specified line's color of the facing sign\"))\n            .senderType(Player.class)\n            .argument(\n                EnumArgument.<CommandSender, Side>builder(Side.class, \"Side\").asRequired().build(),\n                ArgumentDescription.of(\n                    \"The side of the sign of which you want the placeholder to apply\"))\n            .argument(\n                IntegerArgument.<CommandSender>builder(\"line\")\n                    .withMin(1)\n                    .withMax(4)\n                    .withSuggestionsProvider(lineSuggestions())\n                    .asRequired()\n                    .build(),\n                ArgumentDescription.of(\"The line to manipulate\"))\n            .argument(TextColorArgument.of(\"color\"), ArgumentDescription.of(\"The color to set\"))\n            .handler(\n                context -> {\n                  var player = (Player) context.getSender();\n                  Side signSide = context.get(\"Side\");\n                  var block = player.getTargetBlockExact(config.getMaxDistance());", "                  if (!(block.getState() instanceof Sign sign)) {\n                    player.sendMessage(plugin.getPSConfig().getMessages().getNotASign());\n                    return;\n                  }\n                  int lineRaw = context.get(\"line\");\n                  var line = lineRaw - 1;\n                  TextColor textColor = context.get(\"color\");\n\n                  var dataContainer = sign.getPersistentDataContainer();\n                  if (dataContainer.has(PapiSigns.TAGGED_SIGNS_KEY)) {\n                    var signData =\n                        dataContainer.get(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE);", "                  if (dataContainer.has(PapiSigns.TAGGED_SIGNS_KEY)) {\n                    var signData =\n                        dataContainer.get(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE);\n                    if (signData.data().containsKey(signSide)) {\n                      var signDataData = signData.data().get(signSide);\n                      if (signDataData.containsKey(line)) {\n                        var singleSignData = signDataData.get(line);\n                        signDataData.replace(\n                            line, new SingleSignData(singleSignData.placeholder(), textColor));\n                      } else {\n                        player.sendMessage(plugin.getPSConfig().getMessages().getWarningNotSet());\n                        signDataData.put(line, new SingleSignData(null, textColor));\n                      }\n                      signData.data().replace(signSide, signDataData);\n                    } else {\n                      player.sendMessage(plugin.getPSConfig().getMessages().getWarningNotSet());\n                      Map<Integer, SingleSignData> map = new HashMap<>();\n                      map.put(line, new SingleSignData(null, textColor));\n                      signData.data().put(signSide, map);\n                    }\n                    dataContainer.set(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE, signData);\n                  } else {\n                    player.sendMessage(plugin.getPSConfig().getMessages().getWarningNotSet());\n                    Map<Integer, SingleSignData> map = new HashMap<>();\n                    map.put(line, new SingleSignData(null, textColor));\n                    Map<Side, Map<Integer, SingleSignData>> mapRet = new HashMap<>();\n                    mapRet.put(signSide, map);\n                    dataContainer.set(\n                        PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE, new SignData(mapRet));\n                  }\n                  sign.update();\n\n                  player.sendMessage(plugin.getPSConfig().getMessages().getColorChangedSuccess());\n                }));\n\n    manager.command(\n        manager\n            .commandBuilder(\"papisign\", ArgumentDescription.of(\"Base PAPISigns command\"))\n            .literal(\"reload\", ArgumentDescription.of(\"Reload the configuration\"))\n            .permission(\"papisign.reload\")\n            .handler(\n                context -> {\n                  plugin.reload();\n                  context\n                      .getSender()\n                      .sendMessage(plugin.getPSConfig().getMessages().getReloadSuccess());\n                }));\n\n    manager.command(\n        manager\n            .commandBuilder(\"papisign\", ArgumentDescription.of(\"Base PAPISigns command\"))\n            .literal(\"help\")\n            .permission(\"papisign.help\")\n            .argument(\n                StringArgument.<CommandSender>builder(\"query\")\n                    .greedy()\n                    .asOptionalWithDefault(\"\")\n                    .withSuggestionsProvider(\n                        (context, input) ->\n                            manager\n                                .createCommandHelpHandler()\n                                .queryRootIndex(context.getSender())\n                                .getEntries()\n                                .stream()\n                                .map(CommandHelpHandler.VerboseHelpEntry::getSyntaxString)\n                                .collect(Collectors.toList()))\n                    .build())\n            .handler(\n                context ->\n                    plugin\n                        .getHelpMenu()\n                        .queryCommands(context.getOrDefault(\"query\", \"\"), context.getSender())));\n  }\n\n  private static BiFunction<CommandContext<CommandSender>, String, List<String>> lineSuggestions() {\n    return (context, input) -> {\n      var possible = Arrays.asList(\"1\", \"2\", \"3\", \"4\");", "      if (input.isEmpty()) {\n        return possible;\n      }\n      return possible.stream()\n          .filter(value -> value.toLowerCase().startsWith(input.toLowerCase()))\n          .collect(Collectors.toList());\n    };\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/util/SignUpdates.java", "chunked_list": ["package com.mrivanplays.papisigns.util;\n\nimport java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.Map;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;\nimport net.minecraft.world.item.DyeColor;\nimport net.minecraft.world.level.block.entity.SignBlockEntity;\nimport net.minecraft.world.level.block.entity.SignText;", "import net.minecraft.world.level.block.entity.SignBlockEntity;\nimport net.minecraft.world.level.block.entity.SignText;\nimport org.bukkit.Location;\nimport org.bukkit.block.Sign;\nimport org.bukkit.block.sign.Side;\nimport org.bukkit.block.sign.SignSide;\nimport org.bukkit.craftbukkit.v1_20_R1.block.CraftSign;\nimport org.bukkit.craftbukkit.v1_20_R1.block.sign.CraftSignSide;\nimport org.bukkit.craftbukkit.v1_20_R1.entity.CraftPlayer;\nimport org.bukkit.craftbukkit.v1_20_R1.util.CraftChatMessage;", "import org.bukkit.craftbukkit.v1_20_R1.entity.CraftPlayer;\nimport org.bukkit.craftbukkit.v1_20_R1.util.CraftChatMessage;\nimport org.bukkit.craftbukkit.v1_20_R1.util.CraftLocation;\nimport org.bukkit.entity.Player;\n\npublic class SignUpdates {\n\n  private static final Field signTextField;\n\n  static {\n    try {\n      signTextField = CraftSignSide.class.getDeclaredField(\"signText\");\n    } catch (NoSuchFieldException e) {\n      throw new RuntimeException(e);\n    }\n    signTextField.setAccessible(true);\n  }\n", "    try {\n      signTextField = CraftSignSide.class.getDeclaredField(\"signText\");\n    } catch (NoSuchFieldException e) {\n      throw new RuntimeException(e);\n    }\n    signTextField.setAccessible(true);\n  }\n\n  public static void sendSignChange(\n      Player player, Map<Side, List<Component>> updatesMap, Location location, Sign bukkitSign) {\n    var craft = (CraftPlayer) player;", "  public static void sendSignChange(\n      Player player, Map<Side, List<Component>> updatesMap, Location location, Sign bukkitSign) {\n    var craft = (CraftPlayer) player;\n    if (craft.getHandle().connection != null) {\n      var sign =\n          new SignBlockEntity(\n              CraftLocation.toBlockPosition(location),\n              ((CraftSign) bukkitSign)\n                  .getBlock()\n                  .getHandle()\n                  .getBlockState(CraftLocation.toBlockPosition(location)));\n      Side modifiedSide = null;", "      for (Map.Entry<Side, List<Component>> entry : updatesMap.entrySet()) {\n        var side = entry.getKey();\n        SignText modifiedSignText;\n        if (side == Side.FRONT) {\n          modifiedSignText = sign.getFrontText();\n        } else {\n          modifiedSignText = sign.getBackText();\n        }\n        var components = sanitizeToInternalComponents(entry.getValue());\n        modifiedSignText = modifiedSignText.setColor(DyeColor.BLACK);\n        modifiedSignText = modifiedSignText.setHasGlowingText(false);", "        for (int i = 0; i < components.length; i++) {\n          modifiedSignText = modifiedSignText.setMessage(i, components[i]);\n        }\n        sign.setText(modifiedSignText, side == Side.FRONT);\n        if (updatesMap.size() == 1) {\n          modifiedSide = side;\n        }\n      }\n      if (modifiedSide != null) {\n        var unmodifiedSide = modifiedSide == Side.FRONT ? Side.BACK : Side.FRONT;\n        sign.setText(getSignText(bukkitSign.getSide(unmodifiedSide)), unmodifiedSide == Side.FRONT);\n      }\n      craft.getHandle().connection.send(sign.getUpdatePacket());\n    }\n  }\n\n  private static SignText getSignText(SignSide signSide) {", "      if (modifiedSide != null) {\n        var unmodifiedSide = modifiedSide == Side.FRONT ? Side.BACK : Side.FRONT;\n        sign.setText(getSignText(bukkitSign.getSide(unmodifiedSide)), unmodifiedSide == Side.FRONT);\n      }\n      craft.getHandle().connection.send(sign.getUpdatePacket());\n    }\n  }\n\n  private static SignText getSignText(SignSide signSide) {\n    try {\n      return (SignText) signTextField.get(((CraftSignSide) signSide));\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static net.minecraft.network.chat.Component[] sanitizeToInternalComponents(\n      List<Component> lines) {\n    var components = new net.minecraft.network.chat.Component[4];", "    try {\n      return (SignText) signTextField.get(((CraftSignSide) signSide));\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static net.minecraft.network.chat.Component[] sanitizeToInternalComponents(\n      List<Component> lines) {\n    var components = new net.minecraft.network.chat.Component[4];\n    if (lines.isEmpty()) {", "    if (lines.isEmpty()) {\n      for (int i = 0; i < 4; i++) {\n        components[i] = net.minecraft.network.chat.Component.empty();\n      }\n    } else {\n      for (int i = 0; i < 4; i++) {\n        if (i < lines.size() && lines.get(i) != null) {\n          components[i] =\n              CraftChatMessage.fromJSON(GsonComponentSerializer.gson().serialize(lines.get(i)));\n        } else {\n          components[i] = net.minecraft.network.chat.Component.empty();\n        }\n      }\n    }\n    return components;\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/listener/PlaceholderUpdateListener.java", "chunked_list": ["package com.mrivanplays.papisigns.listener;\n\nimport com.mrivanplays.papisigns.data.SignDataType;\nimport com.mrivanplays.papisigns.loader.PapiSigns;\nimport com.mrivanplays.papisigns.util.SignUpdates;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport net.kyori.adventure.text.Component;", "import java.util.Map;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.block.Sign;\nimport org.bukkit.block.sign.Side;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerMoveEvent;\n\npublic class PlaceholderUpdateListener implements Listener {\n\n  private final PapiSigns plugin;\n\n  public PlaceholderUpdateListener(PapiSigns plugin) {\n    this.plugin = plugin;\n  }\n\n  @EventHandler", "public class PlaceholderUpdateListener implements Listener {\n\n  private final PapiSigns plugin;\n\n  public PlaceholderUpdateListener(PapiSigns plugin) {\n    this.plugin = plugin;\n  }\n\n  @EventHandler\n  public void onMove(PlayerMoveEvent event) {\n    var player = event.getPlayer();\n    var loc = event.getTo();", "  public void onMove(PlayerMoveEvent event) {\n    var player = event.getPlayer();\n    var loc = event.getTo();\n    for (var state : loc.getChunk().getTileEntities()) {\n      if (!(state instanceof Sign sign)) {\n        continue;\n      }\n      var stateLoc = state.getBlock().getLocation();\n      if (loc.distance(stateLoc) > plugin.getPSConfig().getMaxDistance()) {\n        continue;\n      }\n      var dataContainer = sign.getPersistentDataContainer();", "      if (loc.distance(stateLoc) > plugin.getPSConfig().getMaxDistance()) {\n        continue;\n      }\n      var dataContainer = sign.getPersistentDataContainer();\n      if (!dataContainer.has(PapiSigns.TAGGED_SIGNS_KEY)) {\n        continue;\n      }\n      var signData = dataContainer.get(PapiSigns.TAGGED_SIGNS_KEY, SignDataType.INSTANCE);\n      Map<Side, List<Component>> updatesMap = new HashMap<>();\n      for (var entry : signData.data().entrySet()) {\n        var signSide = sign.getSide(entry.getKey());\n        var lines = new ArrayList<>(signSide.lines());", "      for (var entry : signData.data().entrySet()) {\n        var signSide = sign.getSide(entry.getKey());\n        var lines = new ArrayList<>(signSide.lines());\n        for (var signDataEntry : entry.getValue().entrySet()) {\n          var singleData = signDataEntry.getValue();\n          if (singleData.placeholder() == null) {\n            continue;\n          }\n          var toSet = plugin.provider().parse(player, singleData);\n          lines.set(signDataEntry.getKey(), toSet);\n        }\n        updatesMap.put(entry.getKey(), lines);\n      }\n      SignUpdates.sendSignChange(player, updatesMap, stateLoc, sign);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/provider/PlaceholderProvider.java", "chunked_list": ["package com.mrivanplays.papisigns.provider;\n\nimport com.mrivanplays.papisigns.data.SingleSignData;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\n\npublic interface PlaceholderProvider {\n\n  String name();\n\n  default boolean available() {\n    return Bukkit.getPluginManager().isPluginEnabled(name());\n  }\n\n  Component parse(Player player, SingleSignData data);\n\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/provider/MiniPlaceholdersProvider.java", "chunked_list": ["package com.mrivanplays.papisigns.provider;\n\nimport static net.kyori.adventure.text.minimessage.MiniMessage.miniMessage;\n\nimport com.mrivanplays.papisigns.data.SingleSignData;\nimport io.github.miniplaceholders.api.MiniPlaceholders;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.entity.Player;\n\npublic final class MiniPlaceholdersProvider implements PlaceholderProvider {\n  @Override", "\npublic final class MiniPlaceholdersProvider implements PlaceholderProvider {\n  @Override\n  public String name() {\n    return \"MiniPlaceholders\";\n  }\n\n  @Override\n  public Component parse(final Player player, final SingleSignData data) {\n    final var resolver = MiniPlaceholders.getAudienceGlobalPlaceholders(player);\n    final Component result = miniMessage().deserialize(data.placeholder(), resolver);", "  public Component parse(final Player player, final SingleSignData data) {\n    final var resolver = MiniPlaceholders.getAudienceGlobalPlaceholders(player);\n    final Component result = miniMessage().deserialize(data.placeholder(), resolver);\n    if (data.color() == null) {\n      return result;\n    } else {\n      return result.applyFallbackStyle(data.color());\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/mrivanplays/papisigns/provider/PlaceholderAPIProvider.java", "chunked_list": ["package com.mrivanplays.papisigns.provider;\n\nimport com.mrivanplays.papisigns.data.SingleSignData;\nimport me.clip.placeholderapi.PlaceholderAPI;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;\nimport org.bukkit.entity.Player;\n\npublic final class PlaceholderAPIProvider implements PlaceholderProvider {\n\n  @Override", "public final class PlaceholderAPIProvider implements PlaceholderProvider {\n\n  @Override\n  public String name() {\n    return \"PlaceholderAPI\";\n  }\n\n  @Override\n  public Component parse(final Player player, final SingleSignData data) {\n    final String parsed = PlaceholderAPI.setPlaceholders(player, data.placeholder());\n    final Component result = LegacyComponentSerializer.legacyAmpersand().deserialize(parsed);", "  public Component parse(final Player player, final SingleSignData data) {\n    final String parsed = PlaceholderAPI.setPlaceholders(player, data.placeholder());\n    final Component result = LegacyComponentSerializer.legacyAmpersand().deserialize(parsed);\n    if (data.color() == null) {\n      return result;\n    } else {\n      return result.applyFallbackStyle(data.color());\n    }\n  }\n}\n"]}
