{"filename": ".mvn/wrapper/MavenWrapperDownloader.java", "chunked_list": ["/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;", "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = \"0.5.6\";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = \"https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/\"\n        + WRAPPER_VERSION + \"/maven-wrapper-\" + WRAPPER_VERSION + \".jar\";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            \".mvn/wrapper/maven-wrapper.properties\";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            \".mvn/wrapper/maven-wrapper.jar\";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = \"wrapperUrl\";\n", "    public static void main(String args[]) {\n        System.out.println(\"- Downloader started\");\n        File baseDirectory = new File(args[0]);\n        System.out.println(\"- Using base directory: \" + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if(mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;", "        if(mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n            } finally {\n                try {", "                try {\n                    if(mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println(\"- Downloading from: \" + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);", "        if(!outputFile.getParentFile().exists()) {\n            if(!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        \"- ERROR creating output directory '\" + outputFile.getParentFile().getAbsolutePath() + \"'\");\n            }\n        }\n        System.out.println(\"- Downloading to: \" + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println(\"Done\");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println(\"- Error downloading\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {", "        if (System.getenv(\"MVNW_USERNAME\") != null && System.getenv(\"MVNW_PASSWORD\") != null) {\n            String username = System.getenv(\"MVNW_USERNAME\");\n            char[] password = System.getenv(\"MVNW_PASSWORD\").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n"]}
{"filename": "src/test/java/software/coley/treemap/DemoChangingProperties.java", "chunked_list": ["package software.coley.treemap;\n\nimport javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\n", "import javafx.stage.Stage;\n\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class DemoChangingProperties extends Application {\n\tprivate static final int WIDTH = 300;\n\tprivate static final int HEIGHT = 200;\n\tprivate static final Random r = new Random(1);\n\n\t@Override", "import java.util.stream.Stream;\n\npublic class DemoChangingProperties extends Application {\n\tprivate static final int WIDTH = 300;\n\tprivate static final int HEIGHT = 200;\n\tprivate static final Random r = new Random(1);\n\n\t@Override\n\tpublic void start(Stage stage) {\n\t\t// The tree-map pane can represent any 'T' value, so long as you provide two things:\n\t\t//  1. ToDoubleFunction<T> to compute the 'size' or 'weight' of values\n\t\t//  2. Function<T, Node> to create Node representations of 'T' values\n\t\t//\n\t\t// In this example we'll represent a list of strings (of integers)\n\t\tList<String> values = Stream.of(1, 1, 1, 1, 2, 2, 2, 2, 2, 3,\n\t\t\t\t\t\t3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 7, 7, 14, 16, 30, 80)\n\t\t\t\t.map(String::valueOf)\n\t\t\t\t.collect(Collectors.toList());\n\n\t\t// The 'size' conversion is a simple 'parseInt' on the string.\n\t\t// The Node mapping creates a label that shows the number, and a random background color to differentiate boxes\n\t\tTreeMapPane<String> pane = new TreeMapPane<>(Integer::parseInt, text -> {\n\t\t\tLabel label = new Label(text);\n\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\"-fx-background-radius: 0; -fx-border-width: 0.5; -fx-border-color: black;\");\n\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\treturn label;\n\t\t});\n\n\t\t// Add the values to the tree-map\n\t\tpane.valueListProperty().addAll(values);\n\n\t\t// Show that properties can be changed on the fly without issues\n\t\tdemoPropertyChangesOnInterval(pane);\n\n\t\t// Create basic layout and show it\n\t\tBorderPane root = new BorderPane(pane);\n\t\troot.setStyle(\"-fx-background-color: black\");\n\t\tScene scene = new Scene(root, WIDTH, HEIGHT);\n\t\tstage.setScene(scene);\n\t\tstage.show();\n\t}\n\n\tprivate static void demoPropertyChangesOnInterval(TreeMapPane<String> pane) {\n\t\tScheduledExecutorService pool = Executors.newScheduledThreadPool(1);\n\t\tint interval = 5;\n\t\tint seconds = interval;\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.nodeFactoryProperty().set(text -> {\n\t\t\t\tLabel label = new Label(text);\n\t\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\t\"-fx-background-radius: 20; -fx-border-width: 0.5; -fx-border-color: black;\");\n\t\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\t\treturn label;\n\t\t\t});\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.nodeFactoryProperty().set(text -> {\n\t\t\t\tLabel label = new Label(text);\n\t\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\t\"-fx-background-radius: 0; -fx-border-width: 3; -fx-border-color: black;\");\n\t\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\t\treturn label;\n\t\t\t});\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.sizeFunctionProperty().set(text -> Integer.parseInt(text) % 40);\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.sizeFunctionProperty().set(text -> Integer.parseInt(text) % 15);\n\t\t});\n\t}\n\n\tprivate static void runScheduledFx(ScheduledExecutorService service, int i, Runnable r) {\n\t\tservice.schedule(() -> {\n\t\t\tPlatform.runLater(r);\n\t\t}, i, TimeUnit.SECONDS);\n\t}\n}\n", "\tpublic void start(Stage stage) {\n\t\t// The tree-map pane can represent any 'T' value, so long as you provide two things:\n\t\t//  1. ToDoubleFunction<T> to compute the 'size' or 'weight' of values\n\t\t//  2. Function<T, Node> to create Node representations of 'T' values\n\t\t//\n\t\t// In this example we'll represent a list of strings (of integers)\n\t\tList<String> values = Stream.of(1, 1, 1, 1, 2, 2, 2, 2, 2, 3,\n\t\t\t\t\t\t3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 7, 7, 14, 16, 30, 80)\n\t\t\t\t.map(String::valueOf)\n\t\t\t\t.collect(Collectors.toList());\n\n\t\t// The 'size' conversion is a simple 'parseInt' on the string.\n\t\t// The Node mapping creates a label that shows the number, and a random background color to differentiate boxes\n\t\tTreeMapPane<String> pane = new TreeMapPane<>(Integer::parseInt, text -> {\n\t\t\tLabel label = new Label(text);\n\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\"-fx-background-radius: 0; -fx-border-width: 0.5; -fx-border-color: black;\");\n\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\treturn label;\n\t\t});\n\n\t\t// Add the values to the tree-map\n\t\tpane.valueListProperty().addAll(values);\n\n\t\t// Show that properties can be changed on the fly without issues\n\t\tdemoPropertyChangesOnInterval(pane);\n\n\t\t// Create basic layout and show it\n\t\tBorderPane root = new BorderPane(pane);\n\t\troot.setStyle(\"-fx-background-color: black\");\n\t\tScene scene = new Scene(root, WIDTH, HEIGHT);\n\t\tstage.setScene(scene);\n\t\tstage.show();\n\t}\n\n\tprivate static void demoPropertyChangesOnInterval(TreeMapPane<String> pane) {\n\t\tScheduledExecutorService pool = Executors.newScheduledThreadPool(1);\n\t\tint interval = 5;\n\t\tint seconds = interval;\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.nodeFactoryProperty().set(text -> {\n\t\t\t\tLabel label = new Label(text);\n\t\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\t\"-fx-background-radius: 20; -fx-border-width: 0.5; -fx-border-color: black;\");\n\t\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\t\treturn label;\n\t\t\t});\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.nodeFactoryProperty().set(text -> {\n\t\t\t\tLabel label = new Label(text);\n\t\t\t\tlabel.setStyle(\"-fx-background-color: \" + String.format(\"#%06x\", r.nextInt(0xffffff + 1)) + \"; \" +\n\t\t\t\t\t\t\"-fx-background-radius: 0; -fx-border-width: 3; -fx-border-color: black;\");\n\t\t\t\tlabel.setAlignment(Pos.CENTER);\n\t\t\t\treturn label;\n\t\t\t});\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.sizeFunctionProperty().set(text -> Integer.parseInt(text) % 40);\n\t\t});\n\t\trunScheduledFx(pool, seconds += interval, () -> {\n\t\t\tpane.sizeFunctionProperty().set(text -> Integer.parseInt(text) % 15);\n\t\t});\n\t}\n\n\tprivate static void runScheduledFx(ScheduledExecutorService service, int i, Runnable r) {\n\t\tservice.schedule(() -> {\n\t\t\tPlatform.runLater(r);\n\t\t}, i, TimeUnit.SECONDS);\n\t}\n}\n"]}
{"filename": "src/test/java/software/coley/treemap/DemoChangingPropertiesStarter.java", "chunked_list": ["package software.coley.treemap;\n\npublic class DemoChangingPropertiesStarter {\n\tpublic static void main(String[] args) {\n\t\tDemoChangingProperties.launch(DemoChangingProperties.class, args);\n\t}\n}\n"]}
{"filename": "src/test/java/software/coley/treemap/DemoHierarchicalContentStarter.java", "chunked_list": ["package software.coley.treemap;\n\npublic class DemoHierarchicalContentStarter {\n\tpublic static void main(String[] args) {\n\t\tDemoChangingProperties.launch(DemoHierarchicalContent.class, args);\n\t}\n}\n"]}
{"filename": "src/test/java/software/coley/treemap/DemoHierarchicalContent.java", "chunked_list": ["package software.coley.treemap;\n\nimport javafx.application.Application;\nimport javafx.beans.property.ListProperty;\nimport javafx.beans.property.SimpleListProperty;\nimport javafx.geometry.Pos;\nimport javafx.scene.Node;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.SplitPane;", "import javafx.scene.control.Label;\nimport javafx.scene.control.SplitPane;\nimport javafx.scene.paint.Color;\nimport javafx.stage.Stage;\nimport software.coley.treemap.content.SimpleHierarchicalTreeContent;\nimport software.coley.treemap.content.TreeContent;\n\nimport javax.annotation.Nonnull;\nimport java.io.IOException;\nimport java.nio.file.*;", "import java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.text.CharacterIterator;\nimport java.text.StringCharacterIterator;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n", "import java.util.Random;\n\nimport static javafx.collections.FXCollections.observableArrayList;\n\npublic class DemoHierarchicalContent extends Application {\n\tprivate static final int WIDTH = 300;\n\tprivate static final int HEIGHT = 200;\n\n\t@Override\n\tpublic void start(Stage stage) {\n\t\tPath src = Paths.get(\"src\");\n\n\t\t// Create two tree-map panes, one with flat modeling and the other with hierarchical\n\t\tTreeMapPane<TreeContent> paneHier = TreeMapPane.forTreeContent();\n\t\tTreeMapPane<TreeContent> paneFlat = TreeMapPane.forTreeContent();\n\t\tpaneHier.valueListProperty().addAll(hierarchyFromPath(src));\n\t\tpaneFlat.valueListProperty().addAll(flatFromPath(src));\n\n\t\t// Create basic layout and show it\n\t\tSplitPane root = (new SplitPane(paneHier, paneFlat));\n\t\troot.setStyle(\"-fx-background-color: black\");\n\t\tScene scene = new Scene(root, WIDTH, HEIGHT);\n\t\tstage.setScene(scene);\n\t\tstage.show();\n\t}\n\n\t@Nonnull\n\tprivate List<TreeContent> flatFromPath(@Nonnull Path path) {\n\t\tList<TreeContent> values = new ArrayList<>();", "\tpublic void start(Stage stage) {\n\t\tPath src = Paths.get(\"src\");\n\n\t\t// Create two tree-map panes, one with flat modeling and the other with hierarchical\n\t\tTreeMapPane<TreeContent> paneHier = TreeMapPane.forTreeContent();\n\t\tTreeMapPane<TreeContent> paneFlat = TreeMapPane.forTreeContent();\n\t\tpaneHier.valueListProperty().addAll(hierarchyFromPath(src));\n\t\tpaneFlat.valueListProperty().addAll(flatFromPath(src));\n\n\t\t// Create basic layout and show it\n\t\tSplitPane root = (new SplitPane(paneHier, paneFlat));\n\t\troot.setStyle(\"-fx-background-color: black\");\n\t\tScene scene = new Scene(root, WIDTH, HEIGHT);\n\t\tstage.setScene(scene);\n\t\tstage.show();\n\t}\n\n\t@Nonnull\n\tprivate List<TreeContent> flatFromPath(@Nonnull Path path) {\n\t\tList<TreeContent> values = new ArrayList<>();", "\t\ttry {\n\t\t\tFiles.walkFileTree(path, new SimpleFileVisitor<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n\t\t\t\t\tlong size = attrs.size();\n\t\t\t\t\tLabel label = createLabel(file.getFileName().toString(), file.getParent(), size);\n\t\t\t\t\tvalues.add(new TreeContent() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic double getValueWeight() {\n\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Nonnull\n\t\t\t\t\t\t@Override", "\t\t\t\t\t\tpublic double getValueWeight() {\n\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Nonnull\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Node getNode() {\n\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Nonnull\n\tprivate List<TreeContent> hierarchyFromPath(@Nonnull Path path) {", "\t\ttry {\n\t\t\tif (Files.isDirectory(path)) {\n\t\t\t\tListProperty<TreeContent> children = new SimpleListProperty<>(observableArrayList(Files.list(path)\n\t\t\t\t\t\t.flatMap(p -> hierarchyFromPath(p).stream())\n\t\t\t\t\t\t.toList()));\n\t\t\t\treturn Collections.singletonList(new SimpleHierarchicalTreeContent(children));\n\t\t\t} else {\n\t\t\t\tlong size = Files.size(path);\n\t\t\t\tLabel label = createLabel(path.getFileName().toString(), path.getParent(), size);\n\t\t\t\treturn Collections.singletonList(new TreeContent() {\n\t\t\t\t\t@Override", "\t\t\t\t\tpublic double getValueWeight() {\n\t\t\t\t\t\treturn size;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Nonnull\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Node getNode() {\n\t\t\t\t\t\treturn label;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n\n\t@Nonnull\n\tprivate Label createLabel(@Nonnull String fileName, @Nonnull Path fileDir, long size) {\n\t\t// Create a label with the file name and size.\n\t\t//  - Background color changes based on directory\n\t\t//  - Background opacity changes based on file size (bigger = more opaque)\n\t\tLabel label = new Label(fileName + \"\\n\" + humanReadableByteCountSI(size));\n\t\tdouble brightness = 0.9;\n\t\tdouble hue = new Random(-fileDir.hashCode()).nextGaussian() * 360;\n\t\tdouble saturation = 0.7;\n\t\tColor hsb = Color.hsb(hue, saturation, brightness);\n\t\tlabel.setStyle(\"-fx-background-color: \" + toRGBCode(hsb) + \"; \" +\n\t\t\t\t\"-fx-background-radius: 0; -fx-border-width: 0.5; -fx-border-color: black;\");\n\t\tlabel.setAlignment(Pos.CENTER);\n\t\treturn label;\n\t}\n\n\t@Nonnull\n\tprivate static String toRGBCode(@Nonnull Color color) {\n\t\treturn String.format(\"#%02X%02X%02X\",\n\t\t\t\t(int) (color.getRed() * 255),\n\t\t\t\t(int) (color.getGreen() * 255),\n\t\t\t\t(int) (color.getBlue() * 255));\n\t}\n\n\t@Nonnull\n\tprivate static String humanReadableByteCountSI(long bytes) {", "\t\tif (-1000 < bytes && bytes < 1000)\n\t\t\treturn bytes + \" B\";\n\t\tCharacterIterator ci = new StringCharacterIterator(\"kMGTPE\");\n\t\twhile (bytes <= -999_950 || bytes >= 999_950) {\n\t\t\tbytes /= 1000;\n\t\t\tci.next();\n\t\t}\n\t\treturn String.format(\"%.1f %cB\", bytes / 1000.0, ci.current());\n\t}\n}\n"]}
{"filename": "src/main/java/software/coley/treemap/TreeMapPane.java", "chunked_list": ["package software.coley.treemap;\n\nimport javafx.application.Platform;\nimport javafx.beans.Observable;\nimport javafx.beans.binding.Bindings;\nimport javafx.beans.binding.ObjectBinding;\nimport javafx.beans.property.*;\nimport javafx.collections.FXCollections;\nimport javafx.collections.MapChangeListener;\nimport javafx.collections.ObservableList;", "import javafx.collections.MapChangeListener;\nimport javafx.collections.ObservableList;\nimport javafx.collections.ObservableMap;\nimport javafx.geometry.HPos;\nimport javafx.geometry.Insets;\nimport javafx.geometry.VPos;\nimport javafx.scene.Node;\nimport javafx.scene.layout.Pane;\nimport software.coley.treemap.content.TreeContent;\nimport software.coley.treemap.squaring.Rectangle;", "import software.coley.treemap.content.TreeContent;\nimport software.coley.treemap.squaring.Rectangle;\nimport software.coley.treemap.squaring.Squarify;\n\nimport javax.annotation.Nonnull;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Function;", "import java.util.function.BinaryOperator;\nimport java.util.function.Function;\nimport java.util.function.ToDoubleFunction;\nimport java.util.stream.Collectors;\n\n/**\n * Tree map pane to render weighted values in different sized rectangles.\n * <p>\n * To add content to the pane, you need to provide two things:\n * <ol>", " * To add content to the pane, you need to provide two things:\n * <ol>\n *     <li>{@link #sizeFunctionProperty() A conversion of 'T' to double} for calculating 'T' items \"value\"</li>\n *     <li>{@link #nodeFactoryProperty() A conversion of 'T' to nodes} for visualizing 'T' items</li>\n * </ol>\n * The nodes supplied by the node factory are sized according to their \"value\" relative to all other items.\n * More valuable items are given larger nodes.\n * <p>\n * Should you wish to change the {@link #sizeFunctionProperty()} or {@link #nodeFactoryProperty()} you must do so\n * on {@link Platform#runLater(Runnable) the FX thread}.", " * Should you wish to change the {@link #sizeFunctionProperty()} or {@link #nodeFactoryProperty()} you must do so\n * on {@link Platform#runLater(Runnable) the FX thread}.\n *\n * @param <T>\n * \t\tType of content.\n *\n * @author Matt Coley\n */\npublic class TreeMapPane<T> extends Pane {\n\t// Managed properties\n\tprotected final MapProperty<T, Node> valueToNode = new SimpleMapProperty<>();\n\n\t// Configurable properties\n\tprotected final ListProperty<T> valueList = new SimpleListProperty<>(FXCollections.observableArrayList());\n\tprotected final ObjectProperty<ToDoubleFunction<T>> sizeFunction;\n\tprotected final ObjectProperty<Function<T, Node>> nodeFactory;\n\n\t/**\n\t * New tree-map pane.\n\t *\n\t * @param sizeFunction\n\t * \t\tSize computation function for {@code T} values.\n\t * @param nodeFactory\n\t * \t\tNode providing function for {@code T} values.\n\t */\n\tpublic TreeMapPane(@Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\t   @Nonnull Function<T, Node> nodeFactory) {\n\n\t\tthis.sizeFunction = new SimpleObjectProperty<>(sizeFunction);\n\t\tthis.nodeFactory = new SimpleObjectProperty<>(nodeFactory);\n\n\t\t// Create a dummy binding that will fire off a change when any given property is changed.\n\t\tObjectBinding<?> multiSourceBindings = Bindings.createObjectBinding(\n\t\t\t\t() -> this /* Dummy value must not be null */,\n\t\t\t\tgetTreeMapProperties());\n\t\tsetupChangeBindings(multiSourceBindings);\n\n\t\t// Disabled to prevent pixel snapping flickering.\n\t\tsetSnapToPixel(false);\n\t}\n\n\t/**\n\t * Creates a new tree-map pane modeling some {@link TreeContent} data type.\n\t *\n\t * @param <C>\n\t * \t\tTree content implementation type.\n\t *\n\t * @return New tree-map pane for {@link TreeContent} data.\n\t */\n\t@Nonnull\n\tpublic static <C extends TreeContent> TreeMapPane<C> forTreeContent() {\n\t\treturn new TreeMapPane<>(TreeContent::getValueWeight, TreeContent::getNode);\n\t}\n\n\t/**\n\t * Configures UI updates through bindings.\n\t *\n\t * @param multiSourceBindings\n\t * \t\tBinding that wraps properties of this pane.\n\t * \t\tAny change in one property is forwarded to this wrapper property.\n\t */\n\tprotected void setupChangeBindings(@Nonnull ObjectBinding<?> multiSourceBindings) {\n\t\t// When any of the properties change, recompute the nodes displayed.\n\t\tvalueToNode.bind(multiSourceBindings.map(unused -> {\n\t\t\tFunction<T, Node> valueFunction = nodeFactory.get();\n\t\t\tFunction<T, T> keyFunction = Function.identity();\n\t\t\tBinaryOperator<Node> mergeFunction = (a, b) -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t};\n\t\t\tMap<T, Node> map = valueList.stream()\n\t\t\t\t\t.collect(Collectors.toMap(keyFunction,\n\t\t\t\t\t\t\tvalueFunction,\n\t\t\t\t\t\t\tmergeFunction,\n\t\t\t\t\t\t\tIdentityHashMap::new));\n\t\t\treturn FXCollections.observableMap(map);\n\t\t}));\n\n\t\t// Map updates should update the children present on the pane.\n\t\tvalueToNode.addListener((MapChangeListener<T, Node>) change -> {\n\t\t\tObservableList<Node> children = getChildren();", "public class TreeMapPane<T> extends Pane {\n\t// Managed properties\n\tprotected final MapProperty<T, Node> valueToNode = new SimpleMapProperty<>();\n\n\t// Configurable properties\n\tprotected final ListProperty<T> valueList = new SimpleListProperty<>(FXCollections.observableArrayList());\n\tprotected final ObjectProperty<ToDoubleFunction<T>> sizeFunction;\n\tprotected final ObjectProperty<Function<T, Node>> nodeFactory;\n\n\t/**\n\t * New tree-map pane.\n\t *\n\t * @param sizeFunction\n\t * \t\tSize computation function for {@code T} values.\n\t * @param nodeFactory\n\t * \t\tNode providing function for {@code T} values.\n\t */\n\tpublic TreeMapPane(@Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\t   @Nonnull Function<T, Node> nodeFactory) {\n\n\t\tthis.sizeFunction = new SimpleObjectProperty<>(sizeFunction);\n\t\tthis.nodeFactory = new SimpleObjectProperty<>(nodeFactory);\n\n\t\t// Create a dummy binding that will fire off a change when any given property is changed.\n\t\tObjectBinding<?> multiSourceBindings = Bindings.createObjectBinding(\n\t\t\t\t() -> this /* Dummy value must not be null */,\n\t\t\t\tgetTreeMapProperties());\n\t\tsetupChangeBindings(multiSourceBindings);\n\n\t\t// Disabled to prevent pixel snapping flickering.\n\t\tsetSnapToPixel(false);\n\t}\n\n\t/**\n\t * Creates a new tree-map pane modeling some {@link TreeContent} data type.\n\t *\n\t * @param <C>\n\t * \t\tTree content implementation type.\n\t *\n\t * @return New tree-map pane for {@link TreeContent} data.\n\t */\n\t@Nonnull\n\tpublic static <C extends TreeContent> TreeMapPane<C> forTreeContent() {\n\t\treturn new TreeMapPane<>(TreeContent::getValueWeight, TreeContent::getNode);\n\t}\n\n\t/**\n\t * Configures UI updates through bindings.\n\t *\n\t * @param multiSourceBindings\n\t * \t\tBinding that wraps properties of this pane.\n\t * \t\tAny change in one property is forwarded to this wrapper property.\n\t */\n\tprotected void setupChangeBindings(@Nonnull ObjectBinding<?> multiSourceBindings) {\n\t\t// When any of the properties change, recompute the nodes displayed.\n\t\tvalueToNode.bind(multiSourceBindings.map(unused -> {\n\t\t\tFunction<T, Node> valueFunction = nodeFactory.get();\n\t\t\tFunction<T, T> keyFunction = Function.identity();\n\t\t\tBinaryOperator<Node> mergeFunction = (a, b) -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t};\n\t\t\tMap<T, Node> map = valueList.stream()\n\t\t\t\t\t.collect(Collectors.toMap(keyFunction,\n\t\t\t\t\t\t\tvalueFunction,\n\t\t\t\t\t\t\tmergeFunction,\n\t\t\t\t\t\t\tIdentityHashMap::new));\n\t\t\treturn FXCollections.observableMap(map);\n\t\t}));\n\n\t\t// Map updates should update the children present on the pane.\n\t\tvalueToNode.addListener((MapChangeListener<T, Node>) change -> {\n\t\t\tObservableList<Node> children = getChildren();", "\t\t\tif (change.wasAdded()) children.add(change.getValueAdded());\n\t\t\tif (change.wasRemoved()) children.remove(change.getValueRemoved());\n\t\t});\n\t}\n\n\t/**\n\t * @return Array of properties to consider for triggering recalculation of the tree-map display.\n\t */\n\t@Nonnull\n\tprotected Observable[] getTreeMapProperties() {\n\t\treturn new Observable[]{sizeFunction, nodeFactory, valueList};\n\t}\n\n\t/**\n\t * @return Property representing the items to display as a tree-map.\n\t */\n\t@Nonnull\n\tpublic ListProperty<T> valueListProperty() {\n\t\treturn valueList;\n\t}\n\n\t/**\n\t * @return Read-only managed map of value instances to their associated {@link Node} representations.\n\t */\n\t@Nonnull\n\tpublic ObservableMap<T, Node> valueToNodeProperty() {\n\t\treturn FXCollections.unmodifiableObservableMap(valueToNode);\n\t}\n\n\t/**\n\t * @return Property representing the current {@code T} to {@link Node} mapping function.\n\t */\n\t@Nonnull\n\tpublic ObjectProperty<Function<T, Node>> nodeFactoryProperty() {\n\t\treturn nodeFactory;\n\t}\n\n\t/**\n\t * @return Property representing the current {@code T} to {@code double} size mapping function.\n\t */\n\t@Nonnull\n\tpublic ObjectProperty<ToDoubleFunction<T>> sizeFunctionProperty() {\n\t\treturn sizeFunction;\n\t}\n\n\t/**\n\t * @param canvasX\n\t * \t\tX coordinate of rectangle to fill.\n\t * @param canvasY\n\t * \t\tY coordinate of rectangle to fill.\n\t * @param canvasWidth\n\t * \t\tWidth of the rectangle to fill.\n\t * @param canvasHeight\n\t * \t\tHeight of the rectangle to fill.\n\t *\n\t * @return Rectangles of the {@link #valueList values} filling the given space.\n\t */\n\t@Nonnull\n\tprotected List<Rectangle<T>> computeRectangles(double canvasX, double canvasY,\n\t\t\t\t\t\t\t\t\t\t\t\t   double canvasWidth, double canvasHeight) {\n\t\treturn new Squarify<>(valueListProperty().get(), sizeFunctionProperty().get(),\n\t\t\t\tcanvasX, canvasY, canvasWidth, canvasHeight)\n\t\t\t\t.getRectangles();\n\t}\n\n\t@Override\n\tprotected void layoutChildren() {\n\t\t// Get dimensions to pass to the squarify algorithm from the current pane dimensions, minus insets.\n\t\tInsets insets = getInsets();\n\t\tdouble canvasX = insets.getLeft();\n\t\tdouble canvasY = insets.getTop();\n\t\tdouble canvasWidth = getWidth() - canvasX - insets.getRight();\n\t\tdouble canvasHeight = getHeight() - canvasY - insets.getBottom();\n\n\t\t// Skip if width is bogus.", "\t\tif (canvasWidth <= 0 || canvasHeight <= 0)\n\t\t\treturn;\n\n\t\t// Map the values to rectangles.\n\t\tList<Rectangle<T>> rectangles = computeRectangles(canvasX, canvasY, canvasWidth, canvasHeight);\n\n\t\t// Get the associated node for each rectangle's value and update its position/size.\n\t\tMap<T, Node> valueToNode = valueToNodeProperty();\n\t\tfor (Rectangle<T> rectangle : rectangles) {\n\t\t\tT value = rectangle.data();\n\t\t\tNode node = valueToNode.get(value);", "\t\tfor (Rectangle<T> rectangle : rectangles) {\n\t\t\tT value = rectangle.data();\n\t\t\tNode node = valueToNode.get(value);\n\t\t\tif (node == null)\n\t\t\t\tthrow new IllegalStateException(\"Value \" + value + \" had no mapping to a node\");\n\t\t\tlayoutChild(rectangle, node);\n\t\t}\n\t}\n\n\t/**\n\t * @param rectangle\n\t * \t\tSpace to fill.\n\t * @param node\n\t * \t\tNode to assign position/size of to match the rectangle.\n\t */\n\tprotected void layoutChild(@Nonnull Rectangle<T> rectangle, @Nonnull Node node) {\n\t\tdouble x = rectangle.x();\n\t\tdouble y = rectangle.y();\n\t\tdouble w = rectangle.width();\n\t\tdouble h = rectangle.height();\n\t\tnode.resize(w, h);\n\t\tpositionInArea(node, x, y,\n\t\t\t\tw, h, 0,\n\t\t\t\tInsets.EMPTY,\n\t\t\t\tHPos.CENTER,\n\t\t\t\tVPos.CENTER, isSnapToPixel());\n\t}\n}"]}
{"filename": "src/main/java/software/coley/treemap/squaring/SizeInfo.java", "chunked_list": ["package software.coley.treemap.squaring;\n\nimport javax.annotation.Nonnull;\nimport java.util.function.DoubleSupplier;\n\n/**\n * Wrapper of the original value, along with its computed 'size' and a variant normalized to the size of the canvas.\n *\n * @author Matt Coley\n * @see SizeInfoProcessor Processes a {@code List<T>} into {@code List<DataPoint<T>>}.", " * @author Matt Coley\n * @see SizeInfoProcessor Processes a {@code List<T>} into {@code List<DataPoint<T>>}.\n */\npublic class SizeInfo<T> {\n\tprivate final DoubleSupplier ratioProvider;\n\tprivate final double size;\n\tprivate double normalizedValue = -1;\n\tprivate final T value;\n\n\t/**\n\t * Creates a new size info wrapper of a value and its size.\n\t *\n\t * @param value\n\t * \t\tWrapped data value.\n\t * @param size\n\t * \t\tOriginal size of the value.\n\t * @param occupiedSpaceRatio\n\t * \t\tSupplies the ratio of space occupied by all values\n\t * \t\t<i>(Passed to the {@link SizeInfoProcessor})</i> to the total size of the canvas.\n\t */\n\tpublic SizeInfo(@Nonnull T value, double size, @Nonnull DoubleSupplier occupiedSpaceRatio) {\n\t\tthis.value = value;\n\t\tthis.size = size;\n\t\tthis.ratioProvider = occupiedSpaceRatio;\n\t}\n\n\t/**\n\t * Normalizes the value size to the proportion of the canvas.\n\t */", "\tpublic void normalize() {\n\t\tif (normalizedValue < 0)\n\t\t\tnormalizedValue = size * ratioProvider.getAsDouble();\n\t}\n\n\t/**\n\t * @return Original size of the {@link #getValue() wrapped value}.\n\t */\n\tpublic double getSize() {\n\t\treturn size;\n\t}\n\n\t/**\n\t * @return Normalized size of the {@link #getValue() wrapped value}.\n\t */", "\tpublic double getSize() {\n\t\treturn size;\n\t}\n\n\t/**\n\t * @return Normalized size of the {@link #getValue() wrapped value}.\n\t */\n\tpublic double getNormalizedSize() {\n\t\treturn normalizedValue;\n\t}\n\n\t/**\n\t * @return Wrapped data value.\n\t */\n\t@Nonnull", "\tpublic T getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) return true;\n\t\tif (o == null || getClass() != o.getClass()) return false;\n\t\tSizeInfo<?> sizeInfo = (SizeInfo<?>) o;\n\t\tif (Double.compare(sizeInfo.size, size) != 0) return false;\n\t\treturn value.equals(sizeInfo.value);\n\t}\n\n\t@Override", "\t\tif (Double.compare(sizeInfo.size, size) != 0) return false;\n\t\treturn value.equals(sizeInfo.value);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(size);\n\t\tresult = (int) (temp ^ (temp >>> 32));\n\t\tresult = 31 * result + value.hashCode();\n\t\treturn result;\n\t}\n}\n"]}
{"filename": "src/main/java/software/coley/treemap/squaring/Rectangle.java", "chunked_list": ["package software.coley.treemap.squaring;\n\n/**\n * Basic rectangle with associated data.\n *\n * @param data\n * \t\tAssociated data.\n * \t\t<br>\n * \t\tWhile {@code null} may be passed for temporary usage by {@link Squarify},\n * \t\tit is never {@code null} in practice.", " * \t\tWhile {@code null} may be passed for temporary usage by {@link Squarify},\n * \t\tit is never {@code null} in practice.\n * @param x\n * \t\tX coordinate.\n * @param y\n * \t\tY coordinate.\n * @param width\n * \t\tWidth.\n * @param height\n * \t\tHeight.", " * @param height\n * \t\tHeight.\n * @param <T>\n * \t\tAssociated data type.\n *\n * @author Matt coley\n */\npublic record Rectangle<T>(T data, double x, double y, double width, double height) {\n}"]}
{"filename": "src/main/java/software/coley/treemap/squaring/SizeInfoProcessor.java", "chunked_list": ["package software.coley.treemap.squaring;\n\nimport javax.annotation.Nonnull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.function.ToDoubleFunction;\n\n/**", "\n/**\n * Processes some list of input instances, providing normalized sizes for all inputs in the wrapper type {@link SizeInfo}.\n *\n * @param <T>\n * \t\tData value type.\n *\n * @author Matt Coley\n */\npublic class SizeInfoProcessor<T> {\n\tprivate final List<SizeInfo<T>> infos = new ArrayList<>();\n\tprivate final double totalSize;\n\tprivate final double totalArea;\n\n\t/**\n\t * Processes the given values, yielding {@link #getSizeInfos() size information wrappers}.\n\t *\n\t * @param values\n\t * \t\tInput data to process.\n\t * @param sizeFunction\n\t * \t\tFunction to convert {@code T} values to sizes.\n\t * @param width\n\t * \t\tTarget canvas width.\n\t * @param height\n\t * \t\tTarget canvas height.\n\t */\n\tpublic SizeInfoProcessor(@Nonnull List<T> values, @Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\t\t\t double width, double height) {\n\t\t// Map values to info wrappers, providing initial sizes and sorting with larger items appearing first.", " */\npublic class SizeInfoProcessor<T> {\n\tprivate final List<SizeInfo<T>> infos = new ArrayList<>();\n\tprivate final double totalSize;\n\tprivate final double totalArea;\n\n\t/**\n\t * Processes the given values, yielding {@link #getSizeInfos() size information wrappers}.\n\t *\n\t * @param values\n\t * \t\tInput data to process.\n\t * @param sizeFunction\n\t * \t\tFunction to convert {@code T} values to sizes.\n\t * @param width\n\t * \t\tTarget canvas width.\n\t * @param height\n\t * \t\tTarget canvas height.\n\t */\n\tpublic SizeInfoProcessor(@Nonnull List<T> values, @Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\t\t\t double width, double height) {\n\t\t// Map values to info wrappers, providing initial sizes and sorting with larger items appearing first.", "\t\tfor (T value : values)\n\t\t\tinfos.add(new SizeInfo<>(value, sizeFunction.applyAsDouble(value), this::getOccupiedSpaceRatio));\n\t\tinfos.sort(Comparator.comparingDouble(SizeInfo::getSize));\n\t\tCollections.reverse(infos);\n\n\t\t// Compute total size occupied by the values, and the size of the canvas.\n\t\t// Used by the occupied space ratio, which is needed for normalization.\n\t\ttotalSize = infos.stream().mapToDouble(SizeInfo::getSize).sum();\n\t\ttotalArea = width * height;\n\n\t\t// Normalize the values sizes to canvas area.", "\t\tfor (SizeInfo<T> datum : infos)\n\t\t\tdatum.normalize();\n\t}\n\n\t/**\n\t * @return Wrappers of the original input values with additional size information.\n\t */\n\t@Nonnull\n\tpublic List<SizeInfo<T>> getSizeInfos() {\n\t\treturn this.infos;\n\t}\n\n\t/**\n\t * @return Ratio of area covered by the input values to the total size of the canvas.\n\t */\n\tprivate double getOccupiedSpaceRatio() {\n\t\treturn totalArea / totalSize;\n\t}\n}"]}
{"filename": "src/main/java/software/coley/treemap/squaring/Squarify.java", "chunked_list": ["package software.coley.treemap.squaring;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.ToDoubleFunction;\n\n/**", "\n/**\n * A class to generate a squarified treemap layout from a set of values.\n *\n * @param <T>\n * \t\tContent type associated with inputs.\n *\n * @author agatheblues - Reference implementation of squarify algorithm\n * @author Matt Coley - Generic support, modernizations and UI integrations\n */\npublic class Squarify<T> {\n\tprivate final List<Rectangle<T>> rectangles;\n\n\t/**\n\t * @param values\n\t * \t\tValues to represent in a squarified treemap.\n\t * @param sizeFunction\n\t * \t\tFunction to convert {@code T} values to sizes.\n\t * @param x\n\t * \t\tStart X offset into canvas to begin filling into.\n\t * @param y\n\t * \t\tStart Y offset into canvas to begin filling into.\n\t * @param width\n\t * \t\tWidth of the space in the canvas to fill.\n\t * @param height\n\t * \t\tHeight of the space in the canvas to fill.\n\t */\n\tpublic Squarify(@Nonnull List<T> values, @Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\tdouble x, double y, double width, double height) {\n\t\tSizeInfoProcessor<T> processor = new SizeInfoProcessor<>(values, sizeFunction, width, height);\n\t\trectangles = squarify(processor.getSizeInfos(), x, y, width, height);\n\t}\n\n\t/**\n\t * Compute the list of rectangles that fill up the canvas, in proportion to the values.\n\t * Optimized to have rectangles with a ratio closest to 1 to have squares.\n\t *\n\t * @param values\n\t * \t\tThe list of values, normalized to the canvas size, to squarify.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Squarified rectangles of the passes values.\n\t */\n\t@Nonnull\n\tprivate List<Rectangle<T>> squarify(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {\n\t\t// Nothing to squarify, yield empty list.", " * @author Matt Coley - Generic support, modernizations and UI integrations\n */\npublic class Squarify<T> {\n\tprivate final List<Rectangle<T>> rectangles;\n\n\t/**\n\t * @param values\n\t * \t\tValues to represent in a squarified treemap.\n\t * @param sizeFunction\n\t * \t\tFunction to convert {@code T} values to sizes.\n\t * @param x\n\t * \t\tStart X offset into canvas to begin filling into.\n\t * @param y\n\t * \t\tStart Y offset into canvas to begin filling into.\n\t * @param width\n\t * \t\tWidth of the space in the canvas to fill.\n\t * @param height\n\t * \t\tHeight of the space in the canvas to fill.\n\t */\n\tpublic Squarify(@Nonnull List<T> values, @Nonnull ToDoubleFunction<T> sizeFunction,\n\t\t\t\t\tdouble x, double y, double width, double height) {\n\t\tSizeInfoProcessor<T> processor = new SizeInfoProcessor<>(values, sizeFunction, width, height);\n\t\trectangles = squarify(processor.getSizeInfos(), x, y, width, height);\n\t}\n\n\t/**\n\t * Compute the list of rectangles that fill up the canvas, in proportion to the values.\n\t * Optimized to have rectangles with a ratio closest to 1 to have squares.\n\t *\n\t * @param values\n\t * \t\tThe list of values, normalized to the canvas size, to squarify.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Squarified rectangles of the passes values.\n\t */\n\t@Nonnull\n\tprivate List<Rectangle<T>> squarify(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {\n\t\t// Nothing to squarify, yield empty list.", "\t\tif (values.size() == 0)\n\t\t\treturn Collections.emptyList();\n\n\t\t// End of recursion chain.\n\t\tif (values.size() == 1) {\n\t\t\tSizeInfo<T> sizeInfo = values.get(0);\n\t\t\treturn Collections.singletonList(makeRect(sizeInfo.getValue(), x, y, width, height));\n\t\t}\n\n\t\t// Move forward until the ratio changes between the i'th and i+1'th value.\n\t\t// This determines where our layout row/column divisions occur.\n\t\tint i = 1;", "\t\twhile ((i < values.size()) && (worstRatio(values.subList(0, i), x, y, width, height) >= worstRatio(values.subList(0, i + 1), x, y, width, height)))\n\t\t\ti++;\n\n\t\tList<SizeInfo<T>> current = values.subList(0, i);\n\t\tList<SizeInfo<T>> remaining = values.subList(i, values.size());\n\n\t\t// Compute how much space is left in the canvas.\n\t\tRectangle<T> currentLeftover = remainingSpace(current, x, y, width, height);\n\n\t\t// Fill the remaining space with rectangles for the remaining values.\n\t\tList<Rectangle<T>> rectangles = new ArrayList<>(values.size());\n\t\trectangles.addAll(layout(current, x, y, width, height));\n\t\trectangles.addAll(squarify(remaining, currentLeftover.x(), currentLeftover.y(), currentLeftover.width(), currentLeftover.height()));\n\t\treturn rectangles;\n\t}\n\n\t/**\n\t * @return Result of squarification operation.\n\t */\n\t@Nonnull\n\tpublic List<Rectangle<T>> getRectangles() {\n\t\treturn rectangles;\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues to sum the normalized size of.\n\t *\n\t * @return Normalized sum of values.\n\t */\n\tprivate double sumNormalizedSizes(@Nonnull List<SizeInfo<T>> values) {\n\t\tdouble result = 0;", "\t\tfor (SizeInfo<?> info : values)\n\t\t\tresult += info.getNormalizedSize();\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues to generate rectangles for.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Generated rectangles occupying a row <i>(All {@link Rectangle#width()} values will be the same)</i>.\n\t *\n\t * @see #layout(List, double, double, double, double) Calls this method when {@code width >= height}.\n\t */\n\t@Nonnull\n\tprivate List<Rectangle<T>> layoutRow(@Nonnull List<SizeInfo<T>> values, double x, double y, double height) {\n\t\tdouble coveredArea = sumNormalizedSizes(values);\n\t\tdouble width = coveredArea / height;\n\t\tList<Rectangle<T>> rectangles = new ArrayList<>(values.size());", "\t\tfor (SizeInfo<T> value : values) {\n\t\t\trectangles.add(makeRect(value.getValue(), x, y, width, value.getNormalizedSize() / width));\n\t\t\ty += value.getNormalizedSize() / width;\n\t\t}\n\t\treturn rectangles;\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues to generate rectangles for.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t *\n\t * @return Generated rectangles occupying a column <i>(All {@link Rectangle#height()} values will be the same)</i>.\n\t *\n\t * @see #layout(List, double, double, double, double) Calls this method when {@code width < height}.\n\t */\n\t@Nonnull\n\tprivate List<Rectangle<T>> layoutColumn(@Nonnull List<SizeInfo<T>> values, double x, double y, double width) {\n\t\tdouble coveredArea = sumNormalizedSizes(values);\n\t\tdouble height = coveredArea / width;\n\t\tList<Rectangle<T>> rectangles = new ArrayList<>(values.size());", "\t\tfor (SizeInfo<T> value : values) {\n\t\t\trectangles.add(makeRect(value.getValue(), x, y, value.getNormalizedSize() / height, height));\n\t\t\tx += value.getNormalizedSize() / height;\n\t\t}\n\t\treturn rectangles;\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues that have had rectangles already generated.\n\t * \t\tUsed for computing the total current occupied space.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Computed remaining area.\n\t *\n\t * @see #remainingSpace(List, double, double, double, double) Calls this method when {@code width < height}.\n\t */\n\t@Nonnull\n\t@SuppressWarnings(\"UnnecessaryLocalVariable\")\n\tprivate Rectangle<T> remainingRowSpace(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {\n\t\tdouble coveredArea = sumNormalizedSizes(values);\n\t\tdouble coveredHeight = coveredArea / height;\n\t\tdouble leftoverX = x + coveredHeight;\n\t\tdouble leftoverY = y;\n\t\tdouble leftoverWidth = width - coveredHeight;\n\t\tdouble leftoverHeight = height;\n\t\treturn makeRect(null, leftoverX, leftoverY, leftoverWidth, leftoverHeight);\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues that have had rectangles already generated.\n\t * \t\tUsed for computing the total current occupied space.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Computed remaining area.\n\t *\n\t * @see #remainingSpace(List, double, double, double, double) Calls this method when {@code width >= height}.\n\t */\n\t@Nonnull\n\t@SuppressWarnings(\"UnnecessaryLocalVariable\")\n\tprivate Rectangle<T> remainingColumnSpace(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {\n\t\tdouble coveredArea = sumNormalizedSizes(values);\n\t\tdouble coveredWidth = coveredArea / width;\n\t\tdouble leftoverX = x;\n\t\tdouble leftoverY = y + coveredWidth;\n\t\tdouble leftoverWidth = width;\n\t\tdouble leftoverHeight = height - coveredWidth;\n\t\treturn makeRect(null, leftoverX, leftoverY, leftoverWidth, leftoverHeight);\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues that have had rectangles already generated.\n\t * \t\tUsed for computing the total current occupied space.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Computed remaining area.\n\t * <p>\n\t * When the remaining width is greater than <i>(or equal to)</i> the remaining height,\n\t * then the space will represent {@link #remainingRowSpace(List, double, double, double, double) a row}.\n\t * Otherwise, it will represent {@link #remainingColumnSpace(List, double, double, double, double) a column}.\n\t */\n\t@Nonnull\n\tprivate Rectangle<T> remainingSpace(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {", "\t\tif (width >= height)\n\t\t\treturn remainingRowSpace(values, x, y, width, height);\n\t\treturn remainingColumnSpace(values, x, y, width, height);\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues to generate rectangles for.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Generated list of rectangles for the provided values,\n\t * populating a row if the current width is greater than <i>(or equal to)</i> the current height,\n\t * or a column otherwise.\n\t */\n\t@Nonnull\n\tprivate List<Rectangle<T>> layout(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {", "\t\tif (width >= height)\n\t\t\treturn layoutRow(values, x, y, height);\n\t\treturn layoutColumn(values, x, y, width);\n\t}\n\n\t/**\n\t * @param value\n\t * \t\tValue to wrap.\n\t * @param x\n\t * \t\tRect x coordinate.\n\t * @param y\n\t * \t\tRect y coordinate.\n\t * @param width\n\t * \t\tRect width.\n\t * @param height\n\t * \t\tRect height.\n\t *\n\t * @return New rect with the provided dimensions.\n\t */\n\t@Nonnull\n\tprotected Rectangle<T> makeRect(@Nullable T value, double x, double y, double width, double height) {\n\t\treturn new Rectangle<>(value, x, y, width, height);\n\t}\n\n\t/**\n\t * @param values\n\t * \t\tValues to check.\n\t * @param x\n\t * \t\tCurrent x coordinate of leftover canvas.\n\t * \t\tValues below {@code x} have already been filled with rectangles.\n\t * @param y\n\t * \t\tCurrent y coordinate of leftover canvas.\n\t * \t\tValues below {@code y} have already been filled with rectangles.\n\t * @param width\n\t * \t\tCurrent width remaining in the canvas.\n\t * @param height\n\t * \t\tCurrent height remaining in the canvas.\n\t *\n\t * @return Worst ratio among the values <i>(farthest from 1)</i> to form a square.\n\t */\n\tprivate double worstRatio(@Nonnull List<SizeInfo<T>> values, double x, double y, double width, double height) {\n\t\tList<Rectangle<T>> rectangles = layout(values, x, y, width, height);\n\t\tdouble max = 0;", "\t\tfor (Rectangle<T> rectangle : rectangles) {\n\t\t\tdouble rectWidth = rectangle.width();\n\t\t\tdouble rectHeight = rectangle.height();\n\t\t\tdouble maxValue = Math.max(rectWidth / rectHeight, rectHeight / rectWidth);\n\t\t\tmax = Math.max(maxValue, max);\n\t\t}\n\t\treturn max;\n\t}\n}\n"]}
{"filename": "src/main/java/software/coley/treemap/content/SimpleHierarchicalTreeContent.java", "chunked_list": ["package software.coley.treemap.content;\n\nimport javafx.beans.property.ListProperty;\nimport javafx.beans.value.ObservableValue;\nimport software.coley.treemap.TreeMapPane;\n\nimport javax.annotation.Nonnull;\n\n/**\n * Simple implementation of {@link HierarchicalTreeContent}.", "/**\n * Simple implementation of {@link HierarchicalTreeContent}.\n *\n * @author Matt Coley\n */\npublic class SimpleHierarchicalTreeContent implements HierarchicalTreeContent {\n\tprivate final ListProperty<TreeContent> children;\n\tprivate final ObservableValue<Double> weight;\n\tprivate final ObservableValue<TreeMapPane<TreeContent>> node;\n\n\t/**\n\t * @param children\n\t * \t\tList of child content items.\n\t */\n\tpublic SimpleHierarchicalTreeContent(@Nonnull ListProperty<TreeContent> children) {\n\t\tthis.children = children;\n\n\t\t// Simple children --> valueWeight() property mapping.\n\t\tweight = children.map(list ->\n\t\t\t\tlist.stream().mapToDouble(TreeContent::getValueWeight).sum());\n\n\t\t// Reuse the same tree-map pane, but rebind contents when the child list updates.\n\t\tTreeMapPane<TreeContent> treeMapPane = TreeMapPane.forTreeContent();\n\t\tnode = children().map(list -> {\n\t\t\ttreeMapPane.valueListProperty().bindContent(list);\n\t\t\treturn treeMapPane;\n\t\t});\n\t}\n\n\t@Nonnull\n\t@Override\n\tpublic ListProperty<TreeContent> children() {\n\t\treturn children;\n\t}\n\n\t@Override", "\tpublic double getValueWeight() {\n\t\treturn weight.getValue();\n\t}\n\n\t@Nonnull\n\t@Override\n\tpublic TreeMapPane<TreeContent> getNode() {\n\t\treturn node.getValue();\n\t}\n}\n"]}
{"filename": "src/main/java/software/coley/treemap/content/HierarchicalTreeContent.java", "chunked_list": ["package software.coley.treemap.content;\n\nimport javafx.beans.property.ListProperty;\nimport software.coley.treemap.TreeMapPane;\n\nimport javax.annotation.Nonnull;\n\n/**\n * Helper model type to represent hierarchical items to input into a {@link TreeMapPane}.\n *", " * Helper model type to represent hierarchical items to input into a {@link TreeMapPane}.\n *\n * @author Matt Coley\n */\npublic interface HierarchicalTreeContent extends TreeContent {\n\t/**\n\t * @return Child tree content items.\n\t */\n\t@Nonnull\n\tListProperty<TreeContent> children();\n\n\t/**\n\t * @return Visualization of all child values.\n\t */\n\t@Nonnull\n\t@Override\n\tTreeMapPane<TreeContent> getNode();\n}\n"]}
{"filename": "src/main/java/software/coley/treemap/content/TreeContent.java", "chunked_list": ["package software.coley.treemap.content;\n\nimport javafx.scene.Node;\nimport software.coley.treemap.TreeMapPane;\n\nimport javax.annotation.Nonnull;\n\n/**\n * Helper model type to represent items to input into a {@link TreeMapPane}.\n * Primarily useful if you want to cache the {@link #getValueWeight() weight} and {@link #getNode() node} values.", " * Helper model type to represent items to input into a {@link TreeMapPane}.\n * Primarily useful if you want to cache the {@link #getValueWeight() weight} and {@link #getNode() node} values.\n *\n * @author Matt Coley\n * @see SimpleHierarchicalTreeContent Subtype for representing hierarchical data.\n */\npublic interface TreeContent {\n\t/**\n\t * @return Weight of 'this' value.\n\t */\n\tdouble getValueWeight();\n\n\t/**\n\t * @return Visualization of 'this' value.\n\t */\n\t@Nonnull\n\tNode getNode();\n}\n"]}
