{"filename": "src/main/java/com/brokiem/bedrockreplay/BedrockReplay.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.account.AccountManager;\nimport com.brokiem.bedrockreplay.auth.Live;", "import com.brokiem.bedrockreplay.account.AccountManager;\nimport com.brokiem.bedrockreplay.auth.Live;\nimport com.brokiem.bedrockreplay.bedrock.data.BedrockData;\nimport com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.output.OutputWindow;\nimport com.brokiem.bedrockreplay.replay.server.ReplayViewerServer;\nimport com.brokiem.bedrockreplay.utils.FileManager;\n\nimport javax.swing.*;\nimport java.io.File;", "import javax.swing.*;\nimport java.io.File;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.util.Base64;\n\npublic class BedrockReplay {\n\n    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n        SwingUtilities.invokeAndWait(OutputWindow::createAndShowGUI);\n        long startTime = (System.currentTimeMillis() / 1000L);\n        OutputWindow.print(\"Starting BedrockReplay...\");\n\n        OutputWindow.print(\"Loading Bedrock data...\");\n        BedrockData.loadEntityIdentifiers();\n        BedrockData.loadItemEntries();\n        BedrockData.loadBiomeDefinitions();\n        BedrockData.loadCreativeItems();\n\n        File directory = new File(\"./replays\");", "    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n        SwingUtilities.invokeAndWait(OutputWindow::createAndShowGUI);\n        long startTime = (System.currentTimeMillis() / 1000L);\n        OutputWindow.print(\"Starting BedrockReplay...\");\n\n        OutputWindow.print(\"Loading Bedrock data...\");\n        BedrockData.loadEntityIdentifiers();\n        BedrockData.loadItemEntries();\n        BedrockData.loadBiomeDefinitions();\n        BedrockData.loadCreativeItems();\n\n        File directory = new File(\"./replays\");", "        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n\n        File configFile = new File(\"config.json\");\n        if (!configFile.exists()) {\n            String contents = FileManager.getFileResourceAsString(\"config.json\");\n            FileManager.writeToFile(\"config.json\", contents);\n        }\n\n        JSONObject config = JSONObject.parseObject(FileManager.getFileContents(\"config.json\"));\n        String hostname = config.getJSONObject(\"proxy\").getString(\"hostname\");\n        int port = config.getJSONObject(\"proxy\").getInteger(\"port\");\n\n        InetSocketAddress bindAddress = new InetSocketAddress(hostname, port);\n        ProxyServer proxyServer = new ProxyServer(bindAddress);\n        proxyServer.start();\n        OutputWindow.print(\"Proxy server Listening on \" + bindAddress);\n\n        String viewerHostname = config.getJSONObject(\"viewer\").getString(\"hostname\");\n        int viewerPort = config.getJSONObject(\"viewer\").getInteger(\"port\");\n        InetSocketAddress viewerAddress = new InetSocketAddress(viewerHostname, viewerPort);\n        ReplayViewerServer replayViewerServer = new ReplayViewerServer(viewerAddress);\n        replayViewerServer.start();\n        OutputWindow.print(\"Replay viewer server Listening on \" + viewerAddress);\n\n        OutputWindow.print(\"Done (took \" + (System.currentTimeMillis() / 1000L - startTime) + \"s)!\");\n\n        checkAccount();\n    }\n\n    private static void checkAccount() {\n        File accountFile = new File(\".account\");", "        if (accountFile.exists()) {\n            try {\n                OutputWindow.print(\"Successfully loaded your account!\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                OutputWindow.print(\"Failed to load your account, please authenticate with your Microsoft account again.\");\n                startAuth();\n            }\n        } else {\n            OutputWindow.print(\"First time running BedrockReplay, please authenticate with your Microsoft account first.\");\n            startAuth();\n        }\n    }\n\n    private static void startAuth() {\n        Live.getInstance().requestLiveToken(\n                (deviceCode, userCode, verificationUrl, expiresIn, interval) -> {\n                    OutputWindow.print(\"Authenticate with your Microsoft account at \" + verificationUrl + \" using the code: \" + userCode);\n                },\n                (accessToken, refreshToken) -> {\n                    OutputWindow.print(\"Successfully authenticated with your Microsoft account!\");\n", "                    try {\n                        JSONObject json = new JSONObject();\n                        json.put(\"access_token\", Base64.getEncoder().encodeToString(accessToken.getBytes()));\n                        json.put(\"refresh_token\", Base64.getEncoder().encodeToString(refreshToken.getBytes()));\n                        String encrypted = AccountManager.encrypt(json.toJSONString());\n                        FileManager.writeToFile(\".account\", encrypted);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                });\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/auth/Live.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.auth;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.auth.interfaces.DevicePollResult;", "import com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.auth.interfaces.DevicePollResult;\nimport com.brokiem.bedrockreplay.auth.interfaces.LiveTokenResult;\nimport lombok.SneakyThrows;\n\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Timer;", "import java.net.http.HttpResponse;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class Live {\n\n    private static final String LIVE_CONNECT_URL = \"https://login.live.com/oauth20_connect.srf\";\n    private static final String LIVE_TOKEN_URL = \"https://login.live.com/oauth20_token.srf\";\n\n    private static Live instance;\n", "    public static Live getInstance() {\n        if (instance == null) {\n            instance = new Live();\n        }\n\n        return instance;\n    }\n\n    public void requestLiveToken(DevicePollResult devicePollResult, LiveTokenResult callback) {\n        JSONObject deviceAuth = startDeviceAuth();\n\n        devicePollResult.onComplete(\n                deviceAuth.getString(\"device_code\"),\n                deviceAuth.getString(\"user_code\"),\n                deviceAuth.getString(\"verification_uri\"),\n                deviceAuth.getIntValue(\"expires_in\"),\n                deviceAuth.getIntValue(\"interval\")\n        );\n\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override", "    public void requestLiveToken(DevicePollResult devicePollResult, LiveTokenResult callback) {\n        JSONObject deviceAuth = startDeviceAuth();\n\n        devicePollResult.onComplete(\n                deviceAuth.getString(\"device_code\"),\n                deviceAuth.getString(\"user_code\"),\n                deviceAuth.getString(\"verification_uri\"),\n                deviceAuth.getIntValue(\"expires_in\"),\n                deviceAuth.getIntValue(\"interval\")\n        );\n\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override", "            public void run() {\n                try {\n                    JSONObject result = pollDeviceAuth(deviceAuth.getString(\"device_code\"));\n\n                    if (result.containsKey(\"error\")) {\n                        System.out.println(result.getString(\"error_description\"));\n                        return;\n                    }\n\n                    String accessToken = result.getString(\"access_token\");\n                    String refreshToken = result.getString(\"refresh_token\");\n\n                    callback.onComplete(accessToken, refreshToken);\n                    timer.cancel();\n                } catch (Exception ignored) {\n                }\n            }\n        }, 0, deviceAuth.getLong(\"interval\") * 1000);\n    }\n\n    @SneakyThrows", "    public JSONObject startDeviceAuth() {\n        HttpClient httpClient = HttpClient.newBuilder().build();\n\n        String requestBody = String.join(\"&\", new String[]{\n                \"client_id=00000000441cc96b\",\n                \"scope=service::user.auth.xboxlive.com::MBI_SSL\",\n                \"response_type=device_code\"\n        });\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(LIVE_CONNECT_URL))\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n", "        if (response.statusCode() != 200) {\n            throw new Exception(\"Failed to start device auth\");\n        }\n\n        return JSON.parseObject(response.body());\n    }\n\n    public JSONObject pollDeviceAuth(String deviceCode) throws Exception {\n        HttpClient client = HttpClient.newBuilder().build();\n\n        String requestBody = String.join(\"&\", new String[]{\n                \"client_id=00000000441cc96b\",\n                \"grant_type=urn:ietf:params:oauth:grant-type:device_code\",\n                \"device_code=\" + deviceCode\n        });\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(LIVE_TOKEN_URL))\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .build();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n", "        if (response.statusCode() != 200) {\n            throw new Exception(response.body());\n        }\n\n        JSONObject json = JSON.parseObject(response.body());\n        if (json.containsKey(\"error\")) {\n            if (json.getString(\"error\").equals(\"authorization_pending\")) {\n                return null;\n            } else {\n                throw new Exception(\"non-empty unknown poll error: \" + json.getString(\"error\"));\n            }\n        } else {\n            return JSON.parseObject(response.body());\n        }\n    }\n\n    @SneakyThrows", "    public JSONObject refreshToken(String refreshToken) {\n        HttpClient client = HttpClient.newBuilder().build();\n\n        String requestBody = String.join(\"&\", new String[]{\n                \"client_id=00000000441cc96b\",\n                \"scope=service::user.auth.xboxlive.com::MBI_SSL\",\n                \"grant_type=refresh_token\",\n                \"refresh_token=\" + refreshToken\n        });\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(LIVE_TOKEN_URL))\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .build();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n", "        if (response.statusCode() != 200) {\n            throw new Exception(response.body());\n        }\n\n        return JSON.parseObject(response.body());\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/auth/Xbox.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.auth;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.utils.FileManager;", "import com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport com.brokiem.bedrockreplay.utils.JoseUtils;\nimport com.brokiem.bedrockreplay.utils.Utils;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutputStream;\nimport java.math.BigInteger;\nimport java.net.URL;", "import java.math.BigInteger;\nimport java.net.URL;\nimport java.security.Signature;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.time.Instant;\nimport java.util.Base64;\nimport java.util.UUID;\n\n@SuppressWarnings(\"FieldCanBeLocal\")\npublic class Xbox {\n\n    private final String accessToken;\n    private final String xboxDeviceAuthURL = \"https://device.auth.xboxlive.com/device/authenticate\";\n    private final String minecraftAuthURL = \"https://multiplayer.minecraft.net/authentication\";\n    private final String xboxSisuURL = \"https://sisu.xboxlive.com/authorize\";\n\n    public Xbox(String accessToken) {\n        this.accessToken = accessToken;\n    }\n\n    //so sometimes getAffineX/Y toByteArray returns 33 or 31(really rare) bytes we are supposed to get 32 bytes, as said in these stackoverflows, they basically say if byte 0 is 0(33 bytes?) we can remove it\n    //https://stackoverflow.com/questions/57379134/bouncy-castle-ecc-key-pair-generation-produces-different-sizes-for-the-coordinat\n    //https://stackoverflow.com/questions/4407779/biginteger-to-byte\n    private static byte[] bigIntegerToByteArray(BigInteger bigInteger) {\n        byte[] array = bigInteger.toByteArray();", "\n@SuppressWarnings(\"FieldCanBeLocal\")\npublic class Xbox {\n\n    private final String accessToken;\n    private final String xboxDeviceAuthURL = \"https://device.auth.xboxlive.com/device/authenticate\";\n    private final String minecraftAuthURL = \"https://multiplayer.minecraft.net/authentication\";\n    private final String xboxSisuURL = \"https://sisu.xboxlive.com/authorize\";\n\n    public Xbox(String accessToken) {\n        this.accessToken = accessToken;\n    }\n\n    //so sometimes getAffineX/Y toByteArray returns 33 or 31(really rare) bytes we are supposed to get 32 bytes, as said in these stackoverflows, they basically say if byte 0 is 0(33 bytes?) we can remove it\n    //https://stackoverflow.com/questions/57379134/bouncy-castle-ecc-key-pair-generation-produces-different-sizes-for-the-coordinat\n    //https://stackoverflow.com/questions/4407779/biginteger-to-byte\n    private static byte[] bigIntegerToByteArray(BigInteger bigInteger) {\n        byte[] array = bigInteger.toByteArray();", "        if (array[0] == 0) {\n            byte[] newArray = new byte[array.length - 1];\n            System.arraycopy(array, 1, newArray, 0, newArray.length);\n            return newArray;\n        }\n        return array;\n    }\n\n    public String getDeviceToken(ECPublicKey publicKey, ECPrivateKey privateKey) throws Exception {\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        jsonObject.put(\"TokenType\", \"JWT\");\n\n        JSONObject properties = new JSONObject();\n        jsonObject.put(\"Properties\", properties);\n        properties.put(\"AuthMethod\", \"ProofOfPossession\");\n        properties.put(\"DeviceType\", \"Nintendo\");\n        properties.put(\"Id\", UUID.randomUUID().toString());\n        properties.put(\"SerialNumber\", UUID.randomUUID().toString());\n        properties.put(\"Version\", \"0.0.0.0\");\n\n        JSONObject proofKey = new JSONObject();\n        properties.put(\"ProofKey\", proofKey);\n        proofKey.put(\"crv\", \"P-256\");\n        proofKey.put(\"alg\", \"ES256\");\n        proofKey.put(\"use\", \"sig\");\n        proofKey.put(\"kty\", \"EC\");\n        proofKey.put(\"x\", this.getProofKeyX(publicKey));\n        proofKey.put(\"y\", this.getProofKeyY(publicKey));\n\n        URL url = new URL(this.xboxDeviceAuthURL);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"x-xbl-contract-version\", \"1\");\n        this.addSignatureHeader(connection, jsonObject, privateKey);\n\n        this.writeJsonObjectToPost(connection, jsonObject);\n\n        String responce = FileManager.getFileContents(connection.getInputStream());\n        JSONObject responceJsonObject = JSONObject.parseObject(responce);\n\n        return responceJsonObject.getString(\"Token\");\n    }\n", "    public String getDeviceToken(ECPublicKey publicKey, ECPrivateKey privateKey) throws Exception {\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        jsonObject.put(\"TokenType\", \"JWT\");\n\n        JSONObject properties = new JSONObject();\n        jsonObject.put(\"Properties\", properties);\n        properties.put(\"AuthMethod\", \"ProofOfPossession\");\n        properties.put(\"DeviceType\", \"Nintendo\");\n        properties.put(\"Id\", UUID.randomUUID().toString());\n        properties.put(\"SerialNumber\", UUID.randomUUID().toString());\n        properties.put(\"Version\", \"0.0.0.0\");\n\n        JSONObject proofKey = new JSONObject();\n        properties.put(\"ProofKey\", proofKey);\n        proofKey.put(\"crv\", \"P-256\");\n        proofKey.put(\"alg\", \"ES256\");\n        proofKey.put(\"use\", \"sig\");\n        proofKey.put(\"kty\", \"EC\");\n        proofKey.put(\"x\", this.getProofKeyX(publicKey));\n        proofKey.put(\"y\", this.getProofKeyY(publicKey));\n\n        URL url = new URL(this.xboxDeviceAuthURL);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"x-xbl-contract-version\", \"1\");\n        this.addSignatureHeader(connection, jsonObject, privateKey);\n\n        this.writeJsonObjectToPost(connection, jsonObject);\n\n        String responce = FileManager.getFileContents(connection.getInputStream());\n        JSONObject responceJsonObject = JSONObject.parseObject(responce);\n\n        return responceJsonObject.getString(\"Token\");\n    }\n", "    public String getXBLToken(ECPublicKey publicKey, ECPrivateKey privateKey, String deviceToken) throws Exception {\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"AccessToken\", \"t=\" + accessToken);\n        jsonObject.put(\"AppId\", \"00000000441cc96b\");\n        jsonObject.put(\"deviceToken\", deviceToken);\n        jsonObject.put(\"Sandbox\", \"RETAIL\");\n        jsonObject.put(\"UseModernGamertag\", true);\n        jsonObject.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        jsonObject.put(\"RelyingParty\", \"https://multiplayer.minecraft.net/\");\n\n        JSONObject proofKey = new JSONObject();\n        jsonObject.put(\"ProofKey\", proofKey);\n        proofKey.put(\"crv\", \"P-256\");\n        proofKey.put(\"alg\", \"ES256\");\n        proofKey.put(\"use\", \"sig\");\n        proofKey.put(\"kty\", \"EC\");\n        proofKey.put(\"x\", this.getProofKeyX(publicKey));\n        proofKey.put(\"y\", this.getProofKeyY(publicKey));\n\n        URL url = new URL(this.xboxSisuURL);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n        connection.setRequestProperty(\"x-xbl-contract-version\", \"1\");\n\n        this.addSignatureHeader(connection, jsonObject, privateKey);\n        this.writeJsonObjectToPost(connection, jsonObject);\n\n        String response = FileManager.getFileContents(connection.getInputStream());\n        JSONObject responseJsonObject = JSONObject.parseObject(response);\n\n        return responseJsonObject.getJSONObject(\"AuthorizationToken\").toString();\n    }\n", "    public String requestMinecraftChain(String xsts, ECPublicKey publicKey) throws Exception {\n        JSONObject xstsObject = JSONObject.parseObject(xsts);\n\n        String pubKeyData = Base64.getEncoder().encodeToString(publicKey.getEncoded());\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"identityPublicKey\", pubKeyData);\n\n        URL url = new URL(this.minecraftAuthURL);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"Authorization\", \"XBL3.0 x=\" + xstsObject.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\") + \";\" + xstsObject.getString(\"Token\"));\n        connection.setRequestProperty(\"User-Agent\", \"MCPE/UWP\");\n        connection.setRequestProperty(\"Client-Version\", ProxyServer.BEDROCK_CODEC.getMinecraftVersion());\n\n        this.writeJsonObjectToPost(connection, jsonObject);\n\n        return FileManager.getFileContents(connection.getInputStream());\n    }\n\n    private void writeJsonObjectToPost(HttpsURLConnection connection, JSONObject jsonObject) throws Exception {\n        connection.setDoOutput(true);\n\n        DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n        dataOutputStream.writeBytes(jsonObject.toJSONString());\n        dataOutputStream.flush();\n    }\n\n    private String getProofKeyX(ECPublicKey ecPublicKey) {\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(Xbox.bigIntegerToByteArray(ecPublicKey.getW().getAffineX()));\n    }\n\n    private String getProofKeyY(ECPublicKey ecPublicKey) {\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(Xbox.bigIntegerToByteArray(ecPublicKey.getW().getAffineY()));\n    }\n\n    private void addSignatureHeader(HttpsURLConnection httpsURLConnection, JSONObject postData, ECPrivateKey privateKey) throws Exception {\n        long currentTime = this.windowsTimestamp();\n        ByteArrayOutputStream bytesToSign = new ByteArrayOutputStream();\n\n        bytesToSign.write(new byte[]{0, 0, 0, 1, 0});\n        bytesToSign.write(Utils.toByteArray(currentTime));\n        bytesToSign.write(new byte[]{0});\n\n        bytesToSign.write(\"POST\".getBytes());\n        bytesToSign.write(new byte[]{0});\n        String query = httpsURLConnection.getURL().getQuery();", "        if (query == null) {\n            query = \"\";\n        }\n        bytesToSign.write((httpsURLConnection.getURL().getPath() + query).getBytes());\n        bytesToSign.write(new byte[]{0});\n        String authorization = httpsURLConnection.getRequestProperty(\"Authorization\");\n        if (authorization == null) {\n            authorization = \"\";\n        }\n        bytesToSign.write(authorization.getBytes());\n        bytesToSign.write(new byte[]{0});\n        bytesToSign.write(postData.toJSONString().getBytes());\n        bytesToSign.write(new byte[]{0});\n\n        Signature signature = Signature.getInstance(\"SHA256withECDSA\");\n        signature.initSign(privateKey);\n        signature.update(bytesToSign.toByteArray());\n        byte[] signatureBytes = JoseUtils.DERToJOSE(signature.sign(), JoseUtils.AlgorithmType.ECDSA256);\n\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        byteArrayOutputStream.write(new byte[]{0, 0, 0, 1});\n        byteArrayOutputStream.write(Utils.toByteArray(currentTime));\n        byteArrayOutputStream.write(signatureBytes);\n        httpsURLConnection.addRequestProperty(\"Signature\", Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()));\n    }\n\n    // windowsTimestamp returns a Windows specific timestamp. It has a certain offset from Unix time which must be accounted for.\n    private long windowsTimestamp() {\n        return (Instant.now().getEpochSecond() + 11644473600L) * 10000000L;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/auth/interfaces/DevicePollResult.java", "chunked_list": ["package com.brokiem.bedrockreplay.auth.interfaces;\n\npublic interface DevicePollResult {\n    void onComplete(String deviceCode, String userCode, String verificationUrl, int expiresIn, int interval);\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/auth/interfaces/LiveTokenResult.java", "chunked_list": ["package com.brokiem.bedrockreplay.auth.interfaces;\n\npublic interface LiveTokenResult {\n    void onComplete(String accessToken, String refreshToken);\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/replay/ReplayData.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.replay;\n\nimport com.brokiem.bedrockreplay.bedrock.player.cache.PlayerPacketCache;\nimport com.brokiem.bedrockreplay.replay.server.ReplayViewerServer;\nimport com.brokiem.bedrockreplay.utils.Callback;", "import com.brokiem.bedrockreplay.replay.server.ReplayViewerServer;\nimport com.brokiem.bedrockreplay.utils.Callback;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.SneakyThrows;\nimport org.cloudburstmc.protocol.bedrock.codec.BedrockPacketDefinition;\nimport org.cloudburstmc.protocol.bedrock.packet.BedrockPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.PlayerListPacket;", "import org.cloudburstmc.protocol.bedrock.packet.BedrockPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.PlayerListPacket;\nimport org.tukaani.xz.LZMA2Options;\nimport org.tukaani.xz.XZInputStream;\nimport org.tukaani.xz.XZOutputStream;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;", "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class ReplayData {\n\n    @Getter\n    private String replayId;\n    @Getter\n    private int tick = 0;\n    @Setter\n    @Getter\n    private long recorderEntityRuntimeId = -1;\n    private final Queue<BedrockPacket> packets = new ConcurrentLinkedQueue<>();\n    private final Map<Integer, List<BedrockPacket>> packetsByTick = new HashMap<>();\n\n    private ScheduledExecutorService scheduler;\n\n    @Getter\n    private boolean isRecording = false;\n    @Getter\n    @Setter\n    private boolean isPlaying = false;\n    @Getter\n    @Setter\n    private boolean isPaused = false;\n\n    public ReplayData(String replayId) {\n        this.replayId = replayId;\n    }\n", "    public void startRecording() {\n        if (this.isRecording) {\n            return;\n        }\n\n        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n        this.scheduler.scheduleAtFixedRate(() -> {\n            this.packetsByTick.put(this.tick, new ArrayList<>(this.packets));\n            this.packets.clear();\n            ++this.tick;\n        }, 0, 50, TimeUnit.MILLISECONDS);\n        this.isRecording = true;\n    }\n", "    public void addPacket(BedrockPacket packet) {\n        this.packets.add(packet);\n    }\n\n    public void stopRecording() {\n        if (!this.isRecording) {\n            return;\n        }\n\n        this.isRecording = false;\n\n        this.scheduler.shutdown();\n        this.tick = 0;\n\n        List<Integer> ticks = new ArrayList<>(this.packetsByTick.keySet());", "        for (Integer tick : ticks) {\n            if (this.packetsByTick.get(tick).isEmpty()) {\n                this.packetsByTick.remove(tick);\n            }\n        }\n    }\n\n    @SneakyThrows\n    public void saveToFile(String path, Callback callback) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {", "    public void saveToFile(String path, Callback callback) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            try {\n                try (FileOutputStream fos = new FileOutputStream(path + \".replay\");\n                     DataOutputStream dos = new DataOutputStream(new XZOutputStream(fos, new LZMA2Options(LZMA2Options.PRESET_MAX)))) {\n\n                    ByteBuf packetBuffersByTick = Unpooled.buffer();\n\n                    for (Map.Entry<Integer, List<BedrockPacket>> entry : this.packetsByTick.entrySet()) {\n                        int tick = entry.getKey();\n                        List<BedrockPacket> packets = entry.getValue();\n                        ByteBuf serializedPackets = Unpooled.buffer();\n", "                    for (Map.Entry<Integer, List<BedrockPacket>> entry : this.packetsByTick.entrySet()) {\n                        int tick = entry.getKey();\n                        List<BedrockPacket> packets = entry.getValue();\n                        ByteBuf serializedPackets = Unpooled.buffer();\n\n                        for (BedrockPacket packet : packets) {\n                            try {\n                                ByteBuf buf = Unpooled.buffer();\n                                ReplayViewerServer.BEDROCK_CODEC.tryEncode(ReplayViewerServer.CODEC_HELPER, buf, packet);\n                                BedrockPacketDefinition<BedrockPacket> definition = ReplayViewerServer.BEDROCK_CODEC.getPacketDefinition((Class<BedrockPacket>) packet.getClass());\n\n                                serializedPackets.writeShortLE(definition.getId());\n                                serializedPackets.writeIntLE(buf.readableBytes());\n                                serializedPackets.writeBytes(buf);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n\n                        packetBuffersByTick.writeIntLE(tick);\n                        packetBuffersByTick.writeIntLE(serializedPackets.readableBytes());\n                        packetBuffersByTick.writeBytes(serializedPackets);\n                    }\n\n                    dos.writeLong(this.recorderEntityRuntimeId);\n                    dos.writeInt(packetBuffersByTick.readableBytes());\n                    dos.write(packetBuffersByTick.array(), packetBuffersByTick.readerIndex(), packetBuffersByTick.readableBytes());\n                }\n                callback.onSuccess();\n            } catch (Exception e) {\n                callback.onFailure(\"Failed to save replay: \" + e.getMessage());\n            }\n            executor.shutdown();\n        });\n    }\n\n    @SneakyThrows", "    public void loadFromFile(String path, Callback callback) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            try {\n                try (FileInputStream fis = new FileInputStream(path + \".replay\");\n                     DataInputStream dis = new DataInputStream(new XZInputStream(fis))) {\n\n                    this.recorderEntityRuntimeId = dis.readLong();\n                    int packetBuffersByTickLength = dis.readInt();\n                    byte[] packetBuffersByTickBytes = new byte[packetBuffersByTickLength];\n                    dis.read(packetBuffersByTickBytes);\n\n                    ByteBuf packetBuffersByTick = Unpooled.wrappedBuffer(packetBuffersByTickBytes);\n", "                    while (packetBuffersByTick.isReadable()) {\n                        int tick = packetBuffersByTick.readIntLE();\n                        int serializedPacketsLength = packetBuffersByTick.readIntLE();\n\n                        ByteBuf serializedPackets = packetBuffersByTick.readRetainedSlice(serializedPacketsLength);\n                        List<BedrockPacket> packets = new ArrayList<>();\n\n                        while (serializedPackets.isReadable()) {\n                            int packetId = serializedPackets.readShortLE();\n                            int packetLength = serializedPackets.readIntLE();\n\n                            ByteBuf packetBuffer = serializedPackets.readRetainedSlice(packetLength);\n", "                            try {\n                                BedrockPacket packet = ReplayViewerServer.BEDROCK_CODEC.tryDecode(ReplayViewerServer.CODEC_HELPER, packetBuffer, packetId);\n                                packets.add(packet);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n\n                        this.packetsByTick.put(tick, packets);\n                    }\n                }\n                callback.onSuccess();\n            } catch (Exception e) {\n                callback.onFailure(\"Failed to load replay: \" + e.getMessage());\n            }\n            executor.shutdown();\n        });\n    }\n\n    public List<BedrockPacket> getPacketsForTick(int tick) {\n        return this.packetsByTick.getOrDefault(tick, new ArrayList<>());\n    }\n\n    public Map<Integer, List<BedrockPacket>> getRecordedPackets() {\n        return this.packetsByTick;\n    }\n", "    public boolean containsTick(int tick) {\n        return this.packetsByTick.containsKey(tick);\n    }\n\n    public void removeTick(int tick) {\n        this.packetsByTick.remove(tick);\n    }\n    \n    public void addPacketCache(PlayerPacketCache packetCache) {\n        packetCache.getChunkPublisherCache().getPackets().forEach(this::addPacket);\n        packetCache.getLevelChunkCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getSubChunkCache().getPackets().forEach(this::addPacket);\n        packetCache.getUpdateBlockCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddPlayerCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddEntityCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddItemEntityCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getInventoryContentCache().getPackets().forEach(this::addPacket);\n        packetCache.getInventorySlotCache().getPackets().forEach(this::addPacket);\n        packetCache.getMobEquipmentCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getMobArmorEquipmentCache().getPackets().values().forEach(this::addPacket);\n        this.addPacket(packetCache.getSetScoreCache().getPacket());\n        packetCache.getSetDisplayObjectiveCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getPlayerSkinCache().getPackets().values().forEach(this::addPacket);\n        this.addPacket(packetCache.getSetPlayerGameTypeCache().getPacket());\n        packetCache.getPlayerListEntryCache().getEntries().values().stream()\n                .map(entry -> {\n                    PlayerListPacket playerListPacket = new PlayerListPacket();\n                    playerListPacket.setAction(PlayerListPacket.Action.ADD);\n                    playerListPacket.getEntries().add(entry);\n                    return playerListPacket;\n                })\n                .forEach(this::addPacket);\n        packetCache.getSetEntityDataCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getBossEventCache().getPackets().values().forEach(this::addPacket);\n    }\n}\n", "    public void addPacketCache(PlayerPacketCache packetCache) {\n        packetCache.getChunkPublisherCache().getPackets().forEach(this::addPacket);\n        packetCache.getLevelChunkCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getSubChunkCache().getPackets().forEach(this::addPacket);\n        packetCache.getUpdateBlockCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddPlayerCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddEntityCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getAddItemEntityCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getInventoryContentCache().getPackets().forEach(this::addPacket);\n        packetCache.getInventorySlotCache().getPackets().forEach(this::addPacket);\n        packetCache.getMobEquipmentCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getMobArmorEquipmentCache().getPackets().values().forEach(this::addPacket);\n        this.addPacket(packetCache.getSetScoreCache().getPacket());\n        packetCache.getSetDisplayObjectiveCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getPlayerSkinCache().getPackets().values().forEach(this::addPacket);\n        this.addPacket(packetCache.getSetPlayerGameTypeCache().getPacket());\n        packetCache.getPlayerListEntryCache().getEntries().values().stream()\n                .map(entry -> {\n                    PlayerListPacket playerListPacket = new PlayerListPacket();\n                    playerListPacket.setAction(PlayerListPacket.Action.ADD);\n                    playerListPacket.getEntries().add(entry);\n                    return playerListPacket;\n                })\n                .forEach(this::addPacket);\n        packetCache.getSetEntityDataCache().getPackets().values().forEach(this::addPacket);\n        packetCache.getBossEventCache().getPackets().values().forEach(this::addPacket);\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/replay/ReplayManager.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.replay;\n\nimport com.brokiem.bedrockreplay.replay.server.player.ViewerPlayer;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport org.cloudburstmc.math.vector.Vector3f;", "import com.brokiem.bedrockreplay.utils.FileManager;\nimport org.cloudburstmc.math.vector.Vector3f;\nimport org.cloudburstmc.protocol.bedrock.data.GameType;\nimport org.cloudburstmc.protocol.bedrock.data.PlayerPermission;\nimport org.cloudburstmc.protocol.bedrock.data.command.CommandPermission;\nimport org.cloudburstmc.protocol.bedrock.data.entity.EntityDataTypes;\nimport org.cloudburstmc.protocol.bedrock.data.inventory.ItemData;\nimport org.cloudburstmc.protocol.bedrock.data.skin.ImageData;\nimport org.cloudburstmc.protocol.bedrock.data.skin.SerializedSkin;\nimport org.cloudburstmc.protocol.bedrock.packet.*;", "import org.cloudburstmc.protocol.bedrock.data.skin.SerializedSkin;\nimport org.cloudburstmc.protocol.bedrock.packet.*;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.util.*;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class ReplayManager {\n\n    private static ReplayManager instance = null;\n", "import java.util.concurrent.TimeUnit;\n\npublic class ReplayManager {\n\n    private static ReplayManager instance = null;\n\n    public static ReplayManager getInstance() {\n        if (instance == null) {\n            instance = new ReplayManager();\n        }\n\n        return instance;\n    }\n\n    private final Map<String, ReplayData> replays = new HashMap<>();\n    private final Map<String, ArrayList<String>> playerReplayMap = new HashMap<>();\n    private final Map<String, ScheduledExecutorService> replaysScheduler = new HashMap<>();\n", "    public ReplayData createReplay(String recorderUsername, String id) {\n        ReplayData replayData = new ReplayData(id);\n        replays.put(id, replayData);\n\n        ArrayList<String> replayMap = playerReplayMap.get(recorderUsername);\n        if (replayMap == null) {\n            replayMap = new ArrayList<>();\n        }\n        replayMap.add(id);\n        playerReplayMap.put(recorderUsername, replayMap);\n        return replayData;\n    }\n", "    public ReplayData getReplay(String id) {\n        return replays.get(id);\n    }\n\n    public ArrayList<ReplayData> getReplayByPlayer(String player) {\n        ArrayList<ReplayData> replayData = new ArrayList<>();\n        ArrayList<String> replayMap = playerReplayMap.get(player);\n        if (replayMap == null) {\n            return replayData;\n        }\n        for (String id : replayMap) {\n            replayData.add(replays.get(id));\n        }\n        return replayData;\n    }\n", "        for (String id : replayMap) {\n            replayData.add(replays.get(id));\n        }\n        return replayData;\n    }\n\n    public ReplayData getRecordingReplayByPlayer(String player) {\n        ArrayList<String> replayMap = playerReplayMap.get(player);\n        if (replayMap == null) {\n            return null;\n        }", "        if (replayMap == null) {\n            return null;\n        }\n        for (String id : replayMap) {\n            ReplayData replayData = replays.get(id);\n            if (replayData.isRecording()) {\n                return replayData;\n            }\n        }\n        return null;\n    }\n", "    public void playReplay(String id, ViewerPlayer player) {\n        ReplayData replayData = this.replays.get(id);\n        if (replayData == null) {\n            return;\n        }\n\n        replayData.setPlaying(true);\n\n        final boolean[] isTeleportedToRecordedPlayer = {false};\n        final int[] tick = {0};\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        scheduler.scheduleAtFixedRate(() -> {", "            if (replayData.isPaused()) {\n                return;\n            }\n\n            if (tick[0] > replayData.getRecordedPackets().size()) {\n                this.stopReplay(id, player);\n                player.sendMessage(\"\u00a7c[!] Replay '\" + replayData.getReplayId() + \"' has ended!\");\n                return;\n            }\n\n            replayData.getPacketsForTick(tick[0]).forEach(packet -> {\n                boolean send = this.remapPacket(packet, player, replayData, isTeleportedToRecordedPlayer);", "                if (send) {\n                    player.getSession().sendPacket(packet);\n                }\n            });\n            ++tick[0];\n        }, 0, 50, TimeUnit.MILLISECONDS);\n        replaysScheduler.put(id, scheduler);\n    }\n\n    public void unpauseReplay(String id) {\n        ReplayData replayData = replays.get(id);", "    public void unpauseReplay(String id) {\n        ReplayData replayData = replays.get(id);\n        if (replayData == null) {\n            return;\n        }\n\n        replayData.setPaused(false);\n    }\n\n    public void pauseReplay(String id) {\n        ReplayData replayData = replays.get(id);", "    public void pauseReplay(String id) {\n        ReplayData replayData = replays.get(id);\n        if (replayData == null) {\n            return;\n        }\n\n        replayData.setPaused(true);\n    }\n\n    public void stopReplay(String id, ViewerPlayer player) {\n        ReplayData replayData = replays.get(id);", "    public void stopReplay(String id, ViewerPlayer player) {\n        ReplayData replayData = replays.get(id);\n        if (replayData == null) {\n            return;\n        }\n\n        ScheduledExecutorService scheduler = replaysScheduler.get(id);\n        if (scheduler != null) {\n            scheduler.shutdown();\n        }\n", "        for (int i = 0; i < replayData.getRecordedPackets().size(); i++) {\n            replayData.getPacketsForTick(i).forEach(packet -> this.revertPacket(packet, player));\n        }\n\n        this.removeReplay(id);\n    }\n\n    public void removeReplay(String id) {\n        playerReplayMap.values().forEach(replayMap -> replayMap.remove(id));\n        replays.remove(id);\n    }\n\n    public Map<String, ReplayData> getLoadedReplays() {\n        return replays;\n    }\n\n    public List<String> getSavedReplays() {\n        List<String> fileList = new ArrayList<>();\n        File directory = new File(\"./replays\");\n", "        if (directory.isDirectory()) {\n            File[] files = directory.listFiles();\n            for (File file : files) {\n                if (file.isFile()) {\n                    fileList.add(file.getName());\n                }\n            }\n        }\n\n        return fileList;\n    }\n\n    private boolean remapPacket(BedrockPacket packet, ViewerPlayer player, ReplayData replayData, boolean[] isTeleportedToRecordedPlayer) {", "        if (packet instanceof MovePlayerPacket movePlayerPacket) {\n            if (movePlayerPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    if (!isTeleportedToRecordedPlayer[0]) {\n                        movePlayerPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                        movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                        movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);\n                        isTeleportedToRecordedPlayer[0] = true;\n                    } else {\n                        movePlayerPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                    }\n                } else {\n                    movePlayerPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                    movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                    movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);\n                }\n            }\n        }", "        if (packet instanceof MobEquipmentPacket mobEquipmentPacket) {\n            if (mobEquipmentPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    mobEquipmentPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    mobEquipmentPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n        if (packet instanceof MobArmorEquipmentPacket mobArmorEquipmentPacket) {\n            if (mobArmorEquipmentPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {", "        if (packet instanceof MobArmorEquipmentPacket mobArmorEquipmentPacket) {\n            if (mobArmorEquipmentPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    mobArmorEquipmentPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    mobArmorEquipmentPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n        if (packet instanceof AnimatePacket animatePacket) {\n            if (animatePacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {", "        if (packet instanceof AnimatePacket animatePacket) {\n            if (animatePacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    animatePacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    animatePacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n        if (packet instanceof EntityEventPacket entityEventPacket) {\n            if (entityEventPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {", "        if (packet instanceof EntityEventPacket entityEventPacket) {\n            if (entityEventPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    entityEventPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    entityEventPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n        if (packet instanceof SetPlayerGameTypePacket setPlayerGameTypePacket) {\n            player.setLastGamemode(setPlayerGameTypePacket.getGamemode());\n            return !player.isFreeCamera();\n        }", "        if (packet instanceof SetPlayerGameTypePacket setPlayerGameTypePacket) {\n            player.setLastGamemode(setPlayerGameTypePacket.getGamemode());\n            return !player.isFreeCamera();\n        }\n        if (packet instanceof SetEntityDataPacket setEntityDataPacket) {\n            if (setEntityDataPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (setEntityDataPacket.getMetadata().get(EntityDataTypes.NAME) != null) {\n                    player.setLastSetEntityDataPacket(setEntityDataPacket);\n                }\n\n                if (player.isFreeCamera()) {\n                    setEntityDataPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    setEntityDataPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }", "                if (player.isFreeCamera()) {\n                    setEntityDataPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    setEntityDataPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n        if (packet instanceof SetTitlePacket) {\n            return !player.isFreeCamera();\n        }\n        if (packet instanceof SetEntityMotionPacket setEntityMotionPacket) {", "        if (packet instanceof SetEntityMotionPacket setEntityMotionPacket) {\n            if (setEntityMotionPacket.getRuntimeEntityId() == replayData.getRecorderEntityRuntimeId()) {\n                if (player.isFreeCamera()) {\n                    setEntityMotionPacket.setRuntimeEntityId(player.getClonedPlayerId());\n                } else {\n                    setEntityMotionPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private void revertPacket(BedrockPacket packet, ViewerPlayer player) {", "        if (packet instanceof SetScorePacket) {\n            ((SetScorePacket) packet).setAction(SetScorePacket.Action.REMOVE);\n            player.getSession().sendPacket(packet);\n        }\n        if (packet instanceof SetDisplayObjectivePacket) {\n            RemoveObjectivePacket removeObjectivePacket = new RemoveObjectivePacket();\n            removeObjectivePacket.setObjectiveId(((SetDisplayObjectivePacket) packet).getObjectiveId());\n            player.getSession().sendPacket(removeObjectivePacket);\n        }\n        if (packet instanceof BossEventPacket) {\n            ((BossEventPacket) packet).setAction(BossEventPacket.Action.REMOVE);\n            player.getSession().sendPacket(packet);\n        }", "        if (packet instanceof BossEventPacket) {\n            ((BossEventPacket) packet).setAction(BossEventPacket.Action.REMOVE);\n            player.getSession().sendPacket(packet);\n        }\n        if (packet instanceof AddEntityPacket) {\n            RemoveEntityPacket removeEntityPacket = new RemoveEntityPacket();\n            removeEntityPacket.setUniqueEntityId(((AddEntityPacket) packet).getUniqueEntityId());\n            player.getSession().sendPacket(removeEntityPacket);\n        }\n        if (packet instanceof AddItemEntityPacket) {\n            RemoveEntityPacket removeEntityPacket = new RemoveEntityPacket();\n            removeEntityPacket.setUniqueEntityId(((AddItemEntityPacket) packet).getUniqueEntityId());\n            player.getSession().sendPacket(removeEntityPacket);\n        }", "        if (packet instanceof AddItemEntityPacket) {\n            RemoveEntityPacket removeEntityPacket = new RemoveEntityPacket();\n            removeEntityPacket.setUniqueEntityId(((AddItemEntityPacket) packet).getUniqueEntityId());\n            player.getSession().sendPacket(removeEntityPacket);\n        }\n        if (packet instanceof AddPlayerPacket) {\n            RemoveEntityPacket removeEntityPacket = new RemoveEntityPacket();\n            removeEntityPacket.setUniqueEntityId(((AddPlayerPacket) packet).getUniqueEntityId());\n            player.getSession().sendPacket(removeEntityPacket);\n        }\n        if (packet instanceof PlayerListPacket) {\n            ((PlayerListPacket) packet).setAction(PlayerListPacket.Action.REMOVE);\n            player.getSession().sendPacket(packet);\n        }\n    }\n", "        if (packet instanceof PlayerListPacket) {\n            ((PlayerListPacket) packet).setAction(PlayerListPacket.Action.REMOVE);\n            player.getSession().sendPacket(packet);\n        }\n    }\n\n    public void spawnPlayerClone(ViewerPlayer player) {\n        PlayerListPacket playerListPacket = new PlayerListPacket();\n        playerListPacket.setAction(PlayerListPacket.Action.ADD);\n        setClonedPlayerListEntry(player, playerListPacket);\n        player.getSession().sendPacketImmediately(playerListPacket);\n\n        AddPlayerPacket addPlayerPacket = new AddPlayerPacket();\n        addPlayerPacket.setRuntimeEntityId(player.getClonedPlayerId());\n        addPlayerPacket.setUniqueEntityId(player.getClonedPlayerId());\n        addPlayerPacket.setPlatformChatId(\"\");\n        addPlayerPacket.setPosition(Vector3f.ZERO);\n        addPlayerPacket.setRotation(Vector3f.ZERO);\n        addPlayerPacket.setHand(ItemData.AIR);\n        addPlayerPacket.setAbilityLayers(new ArrayList<>());\n        addPlayerPacket.setBuildPlatform(0);\n        addPlayerPacket.setCommandPermission(CommandPermission.OWNER);\n        addPlayerPacket.setDeviceId(\"\");\n        addPlayerPacket.setGameType(GameType.SURVIVAL);\n        addPlayerPacket.setMotion(Vector3f.ZERO);\n        addPlayerPacket.setPlayerPermission(PlayerPermission.OPERATOR);", "        if (player.getLastSetEntityDataPacket() != null) {\n            addPlayerPacket.setUsername(player.getLastSetEntityDataPacket().getMetadata().get(EntityDataTypes.NAME));\n        } else {\n            addPlayerPacket.setUsername(\"\u00a7eYou [RECORDER]\");\n        }\n        addPlayerPacket.setUuid(player.getClonedPlayerUuid());\n        player.getSession().sendPacketImmediately(addPlayerPacket);\n\n    }\n\n    private void setClonedPlayerListEntry(ViewerPlayer player, PlayerListPacket playerListPacket) {\n        BufferedImage skin = FileManager.getFileResourceAsImage(\"skin/steve.png\");\n\n        PlayerListPacket.Entry entry = new PlayerListPacket.Entry(player.getClonedPlayerUuid());\n        entry.setBuildPlatform(0);\n        entry.setHost(false);\n        entry.setXuid(\"\");", "        if (player.getLastSetEntityDataPacket() != null) {\n            entry.setName(player.getLastSetEntityDataPacket().getMetadata().get(EntityDataTypes.NAME));\n        } else {\n            entry.setName(\"\u00a7eYou [RECORDER]\");\n        }\n        entry.setPlatformChatId(\"\");\n        entry.setEntityId(player.getClonedPlayerId());\n        entry.setTrustedSkin(false);\n        entry.setTeacher(false);\n        entry.setSkin(SerializedSkin.of(\n                UUID.randomUUID() + \".Custom\",\n                \"\",\n                ImageData.from(Objects.requireNonNull(skin)),\n                ImageData.EMPTY,\n                \"geometry.humanoid.custom\",\n                FileManager.getFileResourceAsString(\"skin/skin_geometry.json\"),\n                false\n        ));\n        playerListPacket.getEntries().add(entry);\n    }\n", "    public void despawnPlayerClone(ViewerPlayer player) {\n        RemoveEntityPacket removeEntityPacket = new RemoveEntityPacket();\n        removeEntityPacket.setUniqueEntityId(player.getClonedPlayerId());\n        player.getSession().sendPacketImmediately(removeEntityPacket);\n\n        PlayerListPacket playerListPacket = new PlayerListPacket();\n        playerListPacket.setAction(PlayerListPacket.Action.REMOVE);\n        setClonedPlayerListEntry(player, playerListPacket);\n        player.getSession().sendPacketImmediately(playerListPacket);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/replay/server/ReplayViewerServer.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.replay.server;\n\nimport com.brokiem.bedrockreplay.bedrock.data.BedrockData;\nimport com.brokiem.bedrockreplay.bedrock.network.registry.FakeDefinitionRegistry;\nimport com.brokiem.bedrockreplay.replay.server.handler.PacketHandler;", "import com.brokiem.bedrockreplay.bedrock.network.registry.FakeDefinitionRegistry;\nimport com.brokiem.bedrockreplay.replay.server.handler.PacketHandler;\nimport com.brokiem.bedrockreplay.replay.server.player.ViewerPlayer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport it.unimi.dsi.fastutil.ints.IntOpenHashSet;\nimport it.unimi.dsi.fastutil.ints.IntSet;", "import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\nimport it.unimi.dsi.fastutil.ints.IntSet;\nimport lombok.Getter;\nimport lombok.SneakyThrows;\nimport org.cloudburstmc.math.vector.Vector2f;\nimport org.cloudburstmc.math.vector.Vector3f;\nimport org.cloudburstmc.math.vector.Vector3i;\nimport org.cloudburstmc.nbt.NBTOutputStream;\nimport org.cloudburstmc.nbt.NbtMap;\nimport org.cloudburstmc.nbt.NbtUtils;", "import org.cloudburstmc.nbt.NbtMap;\nimport org.cloudburstmc.nbt.NbtUtils;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.cloudburstmc.protocol.bedrock.BedrockPong;\nimport org.cloudburstmc.protocol.bedrock.BedrockServerSession;\nimport org.cloudburstmc.protocol.bedrock.codec.BedrockCodec;\nimport org.cloudburstmc.protocol.bedrock.codec.BedrockCodecHelper;\nimport org.cloudburstmc.protocol.bedrock.codec.v589.Bedrock_v589;\nimport org.cloudburstmc.protocol.bedrock.data.*;", "import org.cloudburstmc.protocol.bedrock.codec.v589.Bedrock_v589;\nimport org.cloudburstmc.protocol.bedrock.data.*;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.ItemDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.inventory.ItemData;\nimport org.cloudburstmc.protocol.bedrock.netty.initializer.BedrockServerInitializer;\nimport org.cloudburstmc.protocol.bedrock.packet.*;\nimport org.cloudburstmc.protocol.common.SimpleDefinitionRegistry;\nimport org.cloudburstmc.protocol.common.util.OptionalBoolean;\n\nimport java.io.ByteArrayOutputStream;", "\nimport java.io.ByteArrayOutputStream;\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.UUID;\n\npublic class ReplayViewerServer {\n\n    @Getter\n    private static ReplayViewerServer instance;\n\n    @Getter\n    private final InetSocketAddress address;\n", "    public static final BedrockCodec BEDROCK_CODEC = Bedrock_v589.CODEC;\n    public static final BedrockCodecHelper CODEC_HELPER = BEDROCK_CODEC.createHelper();\n\n    private boolean isRunning = false;\n\n    public ReplayViewerServer(InetSocketAddress address) {\n        this.address = address;\n        instance = this;\n    }\n\n    public void start() {", "    public void start() {\n        if (isRunning) {\n            return;\n        }\n\n        SimpleDefinitionRegistry.Builder<ItemDefinition> itemRegistry = SimpleDefinitionRegistry.builder();\n        IntSet runtimeIds = new IntOpenHashSet();\n        for (ItemDefinition definition : BedrockData.ITEM_DEFINITIONS) {\n            if (runtimeIds.add(definition.getRuntimeId())) {\n                itemRegistry.add(definition);\n            }\n        }\n        CODEC_HELPER.setItemDefinitions(itemRegistry.build());\n        CODEC_HELPER.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n\n        BedrockPong pong = new BedrockPong()\n                .edition(\"MCPE\")\n                .motd(\"BedrockReplay\")\n                .subMotd(\"Viewer Server\")\n                .playerCount(0)\n                .maximumPlayerCount(1)\n                .gameType(\"Survival\")\n                .protocolVersion(BEDROCK_CODEC.getProtocolVersion())\n                .ipv4Port(address.getPort())\n                .ipv6Port(address.getPort())\n                .version(BEDROCK_CODEC.getMinecraftVersion());\n\n        new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(NioDatagramChannel.class))\n                .option(RakChannelOption.RAK_ADVERTISEMENT, pong.toByteBuf())\n                .group(new NioEventLoopGroup())\n                .childHandler(new BedrockServerInitializer() {\n                    @Override\n                    protected void initSession(BedrockServerSession session) {\n                        session.setCodec(BEDROCK_CODEC);\n                        session.getPeer().getCodecHelper().setItemDefinitions(CODEC_HELPER.getItemDefinitions());\n                        session.getPeer().getCodecHelper().setBlockDefinitions(CODEC_HELPER.getBlockDefinitions());\n\n                        ViewerPlayer player = new ViewerPlayer(session);\n                        session.setPacketHandler(new PacketHandler(player));\n                    }\n                })\n                .bind(address)\n                .syncUninterruptibly();\n\n        isRunning = true;\n    }\n", "            if (runtimeIds.add(definition.getRuntimeId())) {\n                itemRegistry.add(definition);\n            }\n        }\n        CODEC_HELPER.setItemDefinitions(itemRegistry.build());\n        CODEC_HELPER.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n\n        BedrockPong pong = new BedrockPong()\n                .edition(\"MCPE\")\n                .motd(\"BedrockReplay\")\n                .subMotd(\"Viewer Server\")\n                .playerCount(0)\n                .maximumPlayerCount(1)\n                .gameType(\"Survival\")\n                .protocolVersion(BEDROCK_CODEC.getProtocolVersion())\n                .ipv4Port(address.getPort())\n                .ipv6Port(address.getPort())\n                .version(BEDROCK_CODEC.getMinecraftVersion());\n\n        new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(NioDatagramChannel.class))\n                .option(RakChannelOption.RAK_ADVERTISEMENT, pong.toByteBuf())\n                .group(new NioEventLoopGroup())\n                .childHandler(new BedrockServerInitializer() {\n                    @Override\n                    protected void initSession(BedrockServerSession session) {\n                        session.setCodec(BEDROCK_CODEC);\n                        session.getPeer().getCodecHelper().setItemDefinitions(CODEC_HELPER.getItemDefinitions());\n                        session.getPeer().getCodecHelper().setBlockDefinitions(CODEC_HELPER.getBlockDefinitions());\n\n                        ViewerPlayer player = new ViewerPlayer(session);\n                        session.setPacketHandler(new PacketHandler(player));\n                    }\n                })\n                .bind(address)\n                .syncUninterruptibly();\n\n        isRunning = true;\n    }\n", "    public static void spawnPlayer(ViewerPlayer player) {\n        BiomeDefinitionListPacket biomeDefinitionListPacket = new BiomeDefinitionListPacket();\n        biomeDefinitionListPacket.setDefinitions(BedrockData.BIOME_DEFINITIONS);\n        player.getSession().sendPacket(biomeDefinitionListPacket);\n\n        AvailableEntityIdentifiersPacket entityPacket = new AvailableEntityIdentifiersPacket();\n        entityPacket.setIdentifiers(BedrockData.ENTITY_IDENTIFIERS);\n        player.getSession().sendPacket(entityPacket);\n\n        CreativeContentPacket packet = new CreativeContentPacket();\n        packet.setContents(new ItemData[0]);\n        player.getSession().sendPacket(packet);\n\n        PlayStatusPacket playStatusPacket = new PlayStatusPacket();\n        playStatusPacket.setStatus(PlayStatusPacket.Status.PLAYER_SPAWN);\n        player.getSession().sendPacket(playStatusPacket);\n\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        attributesPacket.setRuntimeEntityId(player.getEntityRuntimeId());\n        attributesPacket.setAttributes(Collections.singletonList(new AttributeData(\"minecraft:movement\", 0.0f, 1024f, 0.1f, 0.1f)));\n        player.getSession().sendPacket(attributesPacket);\n\n        GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();\n        gamerulePacket.getGameRules().add(new GameRuleData<>(\"naturalregeneration\", false));\n        player.getSession().sendPacket(gamerulePacket);\n    }\n", "    public static void sendStartGame(ViewerPlayer player) {\n        StartGamePacket startGamePacket = new StartGamePacket();\n        startGamePacket.setUniqueEntityId(player.getEntityRuntimeId());\n        startGamePacket.setRuntimeEntityId(player.getEntityRuntimeId());\n        startGamePacket.setPlayerGameType(GameType.CREATIVE);\n        startGamePacket.setPlayerPosition(Vector3f.from(0, 65, 0));\n        startGamePacket.setRotation(Vector2f.from(1, 1));\n\n        startGamePacket.setSeed(-1);\n        startGamePacket.setDimensionId(0);\n        startGamePacket.setGeneratorId(1);\n        startGamePacket.setLevelGameType(GameType.CREATIVE);\n        startGamePacket.setDifficulty(2);\n        startGamePacket.setDefaultSpawn(Vector3i.from(0, 65, 0));\n        startGamePacket.setAchievementsDisabled(true);\n        startGamePacket.setDayCycleStopTime(-1);\n        startGamePacket.setEduEditionOffers(0);\n        startGamePacket.setEduFeaturesEnabled(false);\n        startGamePacket.setEducationProductionId(\"\");\n        startGamePacket.setRainLevel(0);\n        startGamePacket.setLightningLevel(0);\n        startGamePacket.setPlatformLockedContentConfirmed(false);\n        startGamePacket.setMultiplayerGame(true);\n        startGamePacket.setBroadcastingToLan(true);\n        startGamePacket.setXblBroadcastMode(GamePublishSetting.PUBLIC);\n        startGamePacket.setPlatformBroadcastMode(GamePublishSetting.PUBLIC);\n        startGamePacket.setCommandsEnabled(true);\n        startGamePacket.setTexturePacksRequired(true);\n        startGamePacket.setExperimentsPreviouslyToggled(false);\n        startGamePacket.setBonusChestEnabled(false);\n        startGamePacket.setStartingWithMap(false);\n        startGamePacket.setTrustingPlayers(false);\n        startGamePacket.setDefaultPlayerPermission(PlayerPermission.MEMBER);\n        startGamePacket.setServerChunkTickRange(4);\n        startGamePacket.setBehaviorPackLocked(false);\n        startGamePacket.setResourcePackLocked(false);\n        startGamePacket.setFromLockedWorldTemplate(false);\n        startGamePacket.setUsingMsaGamertagsOnly(false);\n        startGamePacket.setFromWorldTemplate(false);\n        startGamePacket.setWorldTemplateOptionLocked(false);\n        startGamePacket.setOnlySpawningV1Villagers(false);\n        startGamePacket.setVanillaVersion(ReplayViewerServer.BEDROCK_CODEC.getMinecraftVersion());\n        startGamePacket.setLimitedWorldWidth(0);\n        startGamePacket.setLimitedWorldHeight(0);\n        startGamePacket.setNetherType(true);\n        startGamePacket.setEduSharedUriResource(EduSharedUriResource.EMPTY);\n        startGamePacket.setForceExperimentalGameplay(OptionalBoolean.empty());\n        startGamePacket.setChatRestrictionLevel(ChatRestrictionLevel.NONE);\n        startGamePacket.setDisablingPlayerInteractions(false);\n        startGamePacket.setDisablingPersonas(false);\n        startGamePacket.setDisablingCustomSkins(false);\n        startGamePacket.setLevelId(\"\");\n        startGamePacket.setLevelName(\"\u00a7eBedrockReplay Viewer Server\");\n        startGamePacket.setPremiumWorldTemplateId(\"\");\n        startGamePacket.setTrial(false);\n        startGamePacket.setAuthoritativeMovementMode(AuthoritativeMovementMode.CLIENT);\n        startGamePacket.setRewindHistorySize(0);\n        startGamePacket.setServerAuthoritativeBlockBreaking(false);\n        startGamePacket.setCurrentTick(0);\n        startGamePacket.setEnchantmentSeed(0);\n        startGamePacket.setMultiplayerCorrelationId(\"\");\n        startGamePacket.setServerEngine(\"\");\n        startGamePacket.setSpawnBiomeType(SpawnBiomeType.DEFAULT);\n        startGamePacket.setCustomBiomeName(\"\");\n        startGamePacket.setPlayerPropertyData(NbtMap.EMPTY);\n        startGamePacket.setWorldTemplateId(new UUID(0, 0));\n\n        player.getSession().sendPacket(startGamePacket);\n    }\n", "    public static void sendEmptyChunks(ViewerPlayer player) {\n        Vector3i position = Vector3i.from(0, 60, 0);\n        int radius = 0;\n        int chunkX = position.getX() >> 4;\n        int chunkZ = position.getZ() >> 4;\n        for (int x = -radius; x <= radius; x++) {\n            for (int z = -radius; z <= radius; z++) {\n                LevelChunkPacket data = new LevelChunkPacket();\n                data.setChunkX(chunkX + x);\n                data.setChunkZ(chunkZ + z);\n                data.setSubChunksLength(0);\n                data.setData(getEmptyChunkData());\n                data.setCachingEnabled(false);\n                player.getSession().sendPacket(data);\n            }\n        }\n    }\n\n    @SneakyThrows\n    private static ByteBuf getEmptyChunkData() {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        outputStream.write(new byte[258]);\n\n        try (NBTOutputStream stream = NbtUtils.createNetworkWriter(outputStream)) {\n            stream.writeTag(NbtMap.EMPTY);\n        }\n\n        return Unpooled.copiedBuffer(outputStream.toByteArray());\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/replay/server/player/ViewerPlayer.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.replay.server.player;\n\nimport com.brokiem.bedrockreplay.replay.ReplayManager;\nimport lombok.Getter;\nimport lombok.Setter;", "import lombok.Getter;\nimport lombok.Setter;\nimport org.cloudburstmc.protocol.bedrock.BedrockServerSession;\nimport org.cloudburstmc.protocol.bedrock.packet.SetEntityDataPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.SetPlayerGameTypePacket;\nimport org.cloudburstmc.protocol.bedrock.packet.TextPacket;\n\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class ViewerPlayer {\n\n    @Setter\n    @Getter\n    private long entityRuntimeId;\n\n    @Getter\n    private final BedrockServerSession session;\n\n    @Setter\n    @Getter\n    private int viewDistance = 8;\n\n    private boolean freeCamera = false;\n\n    @Getter\n    private final UUID clonedPlayerUuid;\n    @Getter\n    private final long clonedPlayerId;\n\n    @Setter\n    @Getter\n    private int lastGamemode = GameMode.UNKNOWN.ordinal();\n    @Setter\n    @Getter\n    private SetEntityDataPacket lastSetEntityDataPacket;\n", "import java.util.UUID;\n\npublic class ViewerPlayer {\n\n    @Setter\n    @Getter\n    private long entityRuntimeId;\n\n    @Getter\n    private final BedrockServerSession session;\n\n    @Setter\n    @Getter\n    private int viewDistance = 8;\n\n    private boolean freeCamera = false;\n\n    @Getter\n    private final UUID clonedPlayerUuid;\n    @Getter\n    private final long clonedPlayerId;\n\n    @Setter\n    @Getter\n    private int lastGamemode = GameMode.UNKNOWN.ordinal();\n    @Setter\n    @Getter\n    private SetEntityDataPacket lastSetEntityDataPacket;\n", "    public enum GameMode {\n        SURVIVAL,\n        CREATIVE,\n        ADVENTURE,\n        SPECTATOR,\n        UNKNOWN\n    }\n\n    public ViewerPlayer(BedrockServerSession session) {\n        this.clonedPlayerId = new Random().nextLong();\n        this.clonedPlayerUuid = UUID.randomUUID();\n        this.session = session;\n    }\n", "    public void sendMessage(String message) {\n        TextPacket textPacket = new TextPacket();\n        textPacket.setType(TextPacket.Type.RAW);\n        textPacket.setNeedsTranslation(false);\n        textPacket.setSourceName(\"\");\n        textPacket.setXuid(\"\");\n        textPacket.setMessage(message);\n        this.session.sendPacket(textPacket);\n    }\n\n    public void setGamemode(GameMode gamemode) {", "    public void setGamemode(GameMode gamemode) {\n        if (gamemode.ordinal() == GameMode.UNKNOWN.ordinal()) {\n            return;\n        }\n\n        SetPlayerGameTypePacket setPlayerGameTypePacket = new SetPlayerGameTypePacket();\n        setPlayerGameTypePacket.setGamemode(gamemode.ordinal());\n        this.session.sendPacket(setPlayerGameTypePacket);\n    }\n\n    public void setFreeCamera(boolean freeCamera) {\n        this.freeCamera = freeCamera;\n", "    public void setFreeCamera(boolean freeCamera) {\n        this.freeCamera = freeCamera;\n\n        if (freeCamera) {\n            this.setGamemode(GameMode.CREATIVE);\n            ReplayManager.getInstance().spawnPlayerClone(this);\n        } else {\n            ReplayManager.getInstance().despawnPlayerClone(this);\n            this.setGamemode(GameMode.values()[this.lastGamemode]);\n        }\n    }\n", "    public boolean isFreeCamera() {\n        return this.freeCamera;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/replay/server/handler/PacketHandler.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.replay.server.handler;\n\nimport com.brokiem.bedrockreplay.replay.ReplayData;\nimport com.brokiem.bedrockreplay.replay.ReplayManager;\nimport com.brokiem.bedrockreplay.replay.server.ReplayViewerServer;", "import com.brokiem.bedrockreplay.replay.ReplayManager;\nimport com.brokiem.bedrockreplay.replay.server.ReplayViewerServer;\nimport com.brokiem.bedrockreplay.replay.server.player.ViewerPlayer;\nimport com.brokiem.bedrockreplay.utils.Callback;\nimport org.cloudburstmc.protocol.bedrock.data.PacketCompressionAlgorithm;\nimport org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;\nimport org.cloudburstmc.protocol.bedrock.packet.*;\nimport org.cloudburstmc.protocol.common.PacketSignal;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class PacketHandler implements BedrockPacketHandler {\n\n    private final ViewerPlayer player;\n\n    public PacketHandler(ViewerPlayer player) {\n        this.player = player;\n    }\n\n    @Override", "    public PacketSignal handle(RequestNetworkSettingsPacket packet) {\n        NetworkSettingsPacket networkSettingsPacket = new NetworkSettingsPacket();\n        networkSettingsPacket.setCompressionThreshold(1);\n        networkSettingsPacket.setCompressionAlgorithm(PacketCompressionAlgorithm.ZLIB);\n        networkSettingsPacket.setClientThrottleEnabled(false);\n        networkSettingsPacket.setClientThrottleThreshold(0);\n        networkSettingsPacket.setClientThrottleScalar(0);\n        player.getSession().sendPacketImmediately(networkSettingsPacket);\n\n        player.getSession().getPeer().setCompression(PacketCompressionAlgorithm.ZLIB);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LoginPacket packet) {\n        this.player.setEntityRuntimeId((long) (Math.random() * Long.MAX_VALUE));\n\n        PlayStatusPacket status = new PlayStatusPacket();\n        status.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        player.getSession().sendPacket(status);\n\n        ResourcePacksInfoPacket resourcePacksInfoPacket = new ResourcePacksInfoPacket();\n        resourcePacksInfoPacket.setForcingServerPacksEnabled(false);\n        resourcePacksInfoPacket.setScriptingEnabled(false);\n        resourcePacksInfoPacket.setForcedToAccept(false);\n        player.getSession().sendPacket(resourcePacksInfoPacket);\n\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(RequestChunkRadiusPacket packet) {\n        player.setViewDistance(packet.getRadius());\n\n        ChunkRadiusUpdatedPacket chunkRadiusUpdatedPacket = new ChunkRadiusUpdatedPacket();\n        chunkRadiusUpdatedPacket.setRadius(packet.getRadius());\n        player.getSession().sendPacket(chunkRadiusUpdatedPacket);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(ResourcePackClientResponsePacket packet) {", "    public PacketSignal handle(ResourcePackClientResponsePacket packet) {\n        if (packet.getStatus() == ResourcePackClientResponsePacket.Status.HAVE_ALL_PACKS) {\n            ResourcePackStackPacket stack = new ResourcePackStackPacket();\n            stack.setForcedToAccept(false);\n            stack.setGameVersion(ReplayViewerServer.BEDROCK_CODEC.getMinecraftVersion());\n            stack.setExperimentsPreviouslyToggled(false);\n            player.getSession().sendPacket(stack);\n        }\n\n        if (packet.getStatus() == ResourcePackClientResponsePacket.Status.COMPLETED) {\n            ReplayViewerServer.sendEmptyChunks(player);\n            ReplayViewerServer.sendStartGame(player);\n            ReplayViewerServer.spawnPlayer(player);\n        }\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "        if (packet.getStatus() == ResourcePackClientResponsePacket.Status.COMPLETED) {\n            ReplayViewerServer.sendEmptyChunks(player);\n            ReplayViewerServer.sendStartGame(player);\n            ReplayViewerServer.spawnPlayer(player);\n        }\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(SetLocalPlayerAsInitializedPacket packet) {\n        SetEntityDataPacket setEntityDataPacket = new SetEntityDataPacket();\n        setEntityDataPacket.setRuntimeEntityId(packet.getRuntimeEntityId());\n        setEntityDataPacket.setTick(0);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.BREATHING, true);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.HAS_GRAVITY, true);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.NO_AI, true);\n        player.getSession().sendPacketImmediately(setEntityDataPacket);\n\n        SetTimePacket setTimePacket = new SetTimePacket();\n        setTimePacket.setTime(6000);\n        player.getSession().sendPacket(setTimePacket);\n\n        player.sendMessage(\"\u00a7a[!] Welcome to BedrockReplay Viewer Server!\");\n        player.sendMessage(\"\u00a7e[!] Commands:\");\n        player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n        player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n        player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n        player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n        player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetLocalPlayerAsInitializedPacket packet) {\n        SetEntityDataPacket setEntityDataPacket = new SetEntityDataPacket();\n        setEntityDataPacket.setRuntimeEntityId(packet.getRuntimeEntityId());\n        setEntityDataPacket.setTick(0);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.BREATHING, true);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.HAS_GRAVITY, true);\n        setEntityDataPacket.getMetadata().setFlag(EntityFlag.NO_AI, true);\n        player.getSession().sendPacketImmediately(setEntityDataPacket);\n\n        SetTimePacket setTimePacket = new SetTimePacket();\n        setTimePacket.setTime(6000);\n        player.getSession().sendPacket(setTimePacket);\n\n        player.sendMessage(\"\u00a7a[!] Welcome to BedrockReplay Viewer Server!\");\n        player.sendMessage(\"\u00a7e[!] Commands:\");\n        player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n        player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n        player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n        player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n        player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(TextPacket packet) {\n        String message = packet.getMessage();\n\n        if (message.startsWith(\"!\")) {\n            String[] args = message.substring(1).split(\" \");\n            if (args.length > 0) {\n                String command = args[0];\n                String[] commandArgs = new String[args.length - 1];\n                System.arraycopy(args, 1, commandArgs, 0, commandArgs.length);\n\n                if (command.equals(\"replay\")) {", "                if (command.equals(\"replay\")) {\n                    if (commandArgs.length > 0) {\n                        switch (commandArgs[0]) {\n                            case \"play\" -> {\n                                if (commandArgs.length > 1) {\n                                    String replayName = commandArgs[1];\n                                    ReplayData replayData = ReplayManager.getInstance().getReplay(replayName);\n\n                                    if (replayData == null) {\n                                        replayData = ReplayManager.getInstance().createReplay(packet.getSourceName(), replayName);\n                                    }\n", "                                    if (replayData == null) {\n                                        replayData = ReplayManager.getInstance().createReplay(packet.getSourceName(), replayName);\n                                    }\n\n                                    if (replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is already playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    player.sendMessage(\"\u00a7a[!] Loading replay '\" + replayName + \"'...\");\n                                    ReplayData finalReplayData = replayData;\n                                    finalReplayData.loadFromFile(\"./replays/\" + replayName, new Callback() {\n                                        @Override", "                                        public void onSuccess() {\n                                            player.sendMessage(\"\u00a7a[!] Replay loaded and started!\");\n                                            ReplayManager.getInstance().playReplay(replayName, player);\n                                        }\n\n                                        @Override\n                                        public void onFailure(String errorMessage) {\n                                            player.sendMessage(\"\u00a7c[!] Failed to load replay '\" + replayName + \"'! \" + errorMessage);\n                                        }\n                                    });\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Usage: !replay play <replayName>\");\n                                }\n                            }\n                            case \"pause\" -> {", "                                if (commandArgs.length > 1) {\n                                    String replayName = commandArgs[1];\n                                    ReplayData replayData = ReplayManager.getInstance().getReplay(replayName);\n\n                                    if (replayData == null) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n", "                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    if (replayData.isPaused()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is already paused!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    player.sendMessage(\"\u00a7e[!] Replay paused!\");\n                                    ReplayManager.getInstance().pauseReplay(replayName);\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Usage: !replay pause <replayName>\");\n                                }\n                            }\n                            case \"unpause\", \"resume\" -> {", "                                if (commandArgs.length > 1) {\n                                    String replayName = commandArgs[1];\n                                    ReplayData replayData = ReplayManager.getInstance().getReplay(replayName);\n\n                                    if (replayData == null) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n", "                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    if (!replayData.isPaused()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is already resumed!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    player.sendMessage(\"\u00a7e[!] Replay resumed!\");\n                                    ReplayManager.getInstance().unpauseReplay(replayName);\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Usage: !replay resume <replayName>\");\n                                }\n                            }\n                            case \"stop\" -> {", "                                if (commandArgs.length > 1) {\n                                    String replayName = commandArgs[1];\n                                    ReplayData replayData = ReplayManager.getInstance().getReplay(replayName);\n\n                                    if (replayData == null) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    player.sendMessage(\"\u00a7e[!] Replay stopped and cleared!\");\n                                    ReplayManager.getInstance().stopReplay(replayName, player);\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Usage: !replay stop <replayName>\");\n                                }\n                            }\n                            case \"list\" -> {\n                                player.sendMessage(\"\u00a7e[!] Replay list:\");\n\n                                List<String> fileList = ReplayManager.getInstance().getSavedReplays();\n                                StringBuilder sb = new StringBuilder();", "                                    if (!replayData.isPlaying()) {\n                                        player.sendMessage(\"\u00a7c[!] Replay '\" + replayName + \"' is not playing!\");\n                                        return PacketSignal.HANDLED;\n                                    }\n\n                                    player.sendMessage(\"\u00a7e[!] Replay stopped and cleared!\");\n                                    ReplayManager.getInstance().stopReplay(replayName, player);\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Usage: !replay stop <replayName>\");\n                                }\n                            }\n                            case \"list\" -> {\n                                player.sendMessage(\"\u00a7e[!] Replay list:\");\n\n                                List<String> fileList = ReplayManager.getInstance().getSavedReplays();\n                                StringBuilder sb = new StringBuilder();", "                                for (String fileName : fileList) {\n                                    sb.append(\"\u00a7e\").append(fileName.replace(\".replay\", \"\")).append(\"\u00a7r, \");\n                                }\n                                String fileNames = sb.toString();\n                                // Remove the last comma from the string\n                                if (fileNames.length() > 0) {\n                                    fileNames = fileNames.substring(0, fileNames.length() - 1);\n                                    fileNames = fileNames.substring(0, fileNames.length() - 1);\n                                }\n                                player.sendMessage(\"\u00a7a[!] \" + fileNames);\n                            }\n                            default -> {\n                                player.sendMessage(\"\u00a7e[!] Commands:\");\n                                player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n                                player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n                                player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n                                player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n                                player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n                            }\n                        }\n                    } else {\n                        player.sendMessage(\"\u00a7e[!] Commands:\");\n                        player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n                        player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n                        player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n                        player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n                        player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n                    }", "                } else if (command.equals(\"free\")) {\n                    if (player.isFreeCamera()) {\n                        player.setFreeCamera(false);\n                        player.sendMessage(\"\u00a7a[!] Free camera disabled!\");\n                    } else {\n                        player.setFreeCamera(true);\n                        player.sendMessage(\"\u00a7a[!] Free camera enabled!\");\n                    }\n                } else {\n                    player.sendMessage(\"\u00a7e[!] Commands:\");\n                    player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n                    player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n                    player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n                    player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n                    player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n                }\n            }\n        } else {\n            player.sendMessage(\"\u00a7e[!] Commands:\");\n            player.sendMessage(\"\u00a7a[!] !replay play <replayName> - play replay\");\n            player.sendMessage(\"\u00a7a[!] !replay pause/resume <replayName> - pause/resume replay\");\n            player.sendMessage(\"\u00a7a[!] !replay stop <replayName> - stop replay\");\n            player.sendMessage(\"\u00a7a[!] !replay list - list all replays\");\n            player.sendMessage(\"\u00a7a[!] !free - enable/disable free camera mode\");\n        }\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handlePacket(BedrockPacket packet) {\n        //OutputWindow.print(\"IN: \" + packet.toString());\n\n        packet.handle(this);\n        return PacketSignal.HANDLED;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/utils/JwtUtils.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.utils;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.nimbusds.jose.JOSEException;\nimport com.nimbusds.jose.JWSAlgorithm;", "import com.nimbusds.jose.JOSEException;\nimport com.nimbusds.jose.JWSAlgorithm;\nimport com.nimbusds.jose.JWSHeader;\nimport com.nimbusds.jwt.JWTClaimsSet;\nimport com.nimbusds.jwt.SignedJWT;\nimport org.cloudburstmc.protocol.bedrock.util.EncryptionUtils;\n\nimport java.net.URI;\nimport java.security.KeyPair;\nimport java.security.interfaces.ECPrivateKey;", "import java.security.KeyPair;\nimport java.security.interfaces.ECPrivateKey;\nimport java.text.ParseException;\nimport java.util.Base64;\n\npublic class JwtUtils {\n\n    public static SignedJWT encodeJWT(KeyPair keyPair, JSONObject payload) {\n        String publicKeyBase64 = Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded());\n        URI x5u = URI.create(publicKeyBase64);\n        JWSHeader header = new JWSHeader.Builder(JWSAlgorithm.ES384).x509CertURL(x5u).build();\n", "        try {\n            SignedJWT jwt = new SignedJWT(header, JWTClaimsSet.parse(payload.toJSONString()));\n            EncryptionUtils.signJwt(jwt, (ECPrivateKey) keyPair.getPrivate());\n            return jwt;\n        } catch (JOSEException | ParseException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/utils/FileManager.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.utils;\n\nimport com.brokiem.bedrockreplay.BedrockReplay;\n\nimport javax.imageio.ImageIO;", "\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.zip.GZIPInputStream;\n\npublic class FileManager {\n\n    public static InputStream getFileResourceAsInputStream(String name) {\n        return BedrockReplay.class.getClassLoader().getResourceAsStream(name);\n    }\n", "public class FileManager {\n\n    public static InputStream getFileResourceAsInputStream(String name) {\n        return BedrockReplay.class.getClassLoader().getResourceAsStream(name);\n    }\n\n    public static BufferedImage getFileResourceAsImage(String name) {\n        try {\n            URL resource = BedrockReplay.class.getClassLoader().getResource(name);\n            assert resource != null;\n            return ImageIO.read(resource);\n        } catch (IOException ignored) {\n            return null;\n        }\n    }\n", "    public static String getFileResourceAsString(String name) {\n        return getFileContents(getFileResourceAsInputStream(name));\n    }\n\n    public static void writeToFile(String name, String content) {\n        try {\n            FileWriter fileWriter = new FileWriter(name);\n            fileWriter.write(content);\n            fileWriter.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "    public static String getFileContents(String name) {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(name));\n            String line;\n            StringBuilder sb = new StringBuilder();\n\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n\n            String fileContents = sb.toString();\n            reader.close();\n\n            return fileContents;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n", "    public static String getFileContents(InputStream inputStream) {\n        try {\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n\n            int length;\n            while ((length = inputStream.read(buffer)) != -1) {\n                byteArrayOutputStream.write(buffer, 0, length);\n            }\n\n            byteArrayOutputStream.close();\n            inputStream.close();\n\n            return byteArrayOutputStream.toString(StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n", "    public static String decompressGZIP(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        GZIPInputStream gZIPInputStream = new GZIPInputStream(inputStream);\n        byte[] buffer = new byte[1024];\n\n        int length;\n        while ((length = gZIPInputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, length);\n        }\n\n        byteArrayOutputStream.close();\n        inputStream.close();\n        gZIPInputStream.close();\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8);\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/utils/Utils.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.utils;\n\npublic class Utils {\n\n    public static byte[] toByteArray(long value) {\n        byte[] result = new byte[8];", "    public static byte[] toByteArray(long value) {\n        byte[] result = new byte[8];\n        for (int i = 7; i >= 0; i--) {\n            result[i] = (byte) (int) (value & 0xFFL);\n            value >>= 8L;\n        }\n\n        return result;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/utils/JoseUtils.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.utils;\n\nimport java.security.SignatureException;\n\npublic class JoseUtils {\n", "\npublic class JoseUtils {\n\n    public enum AlgorithmType {\n        ECDSA256(32), ECDSA384(48);\n\n        public final int ecNumberSize;\n\n        AlgorithmType(int ecNumberSize) {\n            this.ecNumberSize = ecNumberSize;\n        }\n    }\n", "    public static byte[] DERToJOSE(byte[] derSignature, AlgorithmType algorithmType) throws SignatureException {\n        // DER Structure: http://crypto.stackexchange.com/a/1797\n        boolean derEncoded = derSignature[0] == 0x30 && derSignature.length != algorithmType.ecNumberSize * 2;\n        if (!derEncoded) {\n            throw new SignatureException(\"Invalid DER signature format.\");\n        }\n\n        final byte[] joseSignature = new byte[algorithmType.ecNumberSize * 2];\n\n        //Skip 0x30\n        int offset = 1;", "        if (derSignature[1] == (byte) 0x81) {\n            //Skip sign\n            offset++;\n        }\n\n        //Convert to unsigned. Should match DER length - offset\n        int encodedLength = derSignature[offset++] & 0xff;\n        if (encodedLength != derSignature.length - offset) {\n            throw new SignatureException(\"Invalid DER signature format.\");\n        }\n\n        //Skip 0x02\n        offset++;\n\n        //Obtain R number length (Includes padding) and skip it\n        int rLength = derSignature[offset++];", "        if (rLength > algorithmType.ecNumberSize + 1) {\n            throw new SignatureException(\"Invalid DER signature format.\");\n        }\n        int rPadding = algorithmType.ecNumberSize - rLength;\n        //Retrieve R number\n        System.arraycopy(derSignature, offset + Math.max(-rPadding, 0), joseSignature, Math.max(rPadding, 0), rLength + Math.min(rPadding, 0));\n\n        //Skip R number and 0x02\n        offset += rLength + 1;\n\n        //Obtain S number length. (Includes padding)\n        int sLength = derSignature[offset++];", "        if (sLength > algorithmType.ecNumberSize + 1) {\n            throw new SignatureException(\"Invalid DER signature format.\");\n        }\n        int sPadding = algorithmType.ecNumberSize - sLength;\n        //Retrieve R number\n        System.arraycopy(derSignature, offset + Math.max(-sPadding, 0), joseSignature, algorithmType.ecNumberSize + Math.max(sPadding, 0), sLength + Math.min(sPadding, 0));\n\n        return joseSignature;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/utils/Callback.java", "chunked_list": ["package com.brokiem.bedrockreplay.utils;\n\npublic interface Callback {\n    void onSuccess();\n    void onFailure(String errorMessage);\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/PlayerInfo.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player;\n\npublic record PlayerInfo(String username, String xuid, String uuid) { }\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/ProxiedPlayer.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player;\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.account.AccountManager;", "import com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.account.AccountManager;\nimport com.brokiem.bedrockreplay.auth.Xbox;\nimport com.brokiem.bedrockreplay.bedrock.network.handler.downstream.DownstreamPacketHandler;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.PlayerPacketCache;\nimport com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport com.brokiem.bedrockreplay.utils.JwtUtils;\nimport com.nimbusds.jwt.SignedJWT;\nimport io.netty.bootstrap.Bootstrap;", "import com.nimbusds.jwt.SignedJWT;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.SneakyThrows;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.cloudburstmc.protocol.bedrock.BedrockClientSession;", "import org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.cloudburstmc.protocol.bedrock.BedrockClientSession;\nimport org.cloudburstmc.protocol.bedrock.BedrockServerSession;\nimport org.cloudburstmc.protocol.bedrock.netty.initializer.BedrockClientInitializer;\nimport org.cloudburstmc.protocol.bedrock.packet.BedrockPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.LoginPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.RequestNetworkSettingsPacket;\nimport org.cloudburstmc.protocol.bedrock.packet.TextPacket;\nimport org.cloudburstmc.protocol.bedrock.util.EncryptionUtils;\n", "import org.cloudburstmc.protocol.bedrock.util.EncryptionUtils;\n\nimport java.net.InetSocketAddress;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECGenParameterSpec;\nimport java.time.Instant;\nimport java.util.Base64;", "import java.time.Instant;\nimport java.util.Base64;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProxiedPlayer {\n\n    @Getter\n    private BedrockServerSession session;\n    @Getter\n    private BedrockClientSession downstreamSession = null;\n\n    @Getter\n    @Setter\n    private String accessToken;\n    @Getter\n    private String refreshToken;\n    @Getter\n    private KeyPair keyPair;\n\n    @Getter\n    @Setter\n    private boolean allowSendPacket = false;\n\n    @Getter\n    private PlayerInfo playerInfo;\n    @Getter\n    @Setter\n    private JSONObject skinData;\n    @Setter\n    @Getter\n    private long entityRuntimeId;\n\n    @Getter\n    private PlayerPacketCache packetCache = new PlayerPacketCache();\n\n    @SneakyThrows\n    public ProxiedPlayer(BedrockServerSession session) {\n        String decrypted = AccountManager.decrypt(FileManager.getFileContents(\".account\"));\n        JSONObject json = JSONObject.parseObject(decrypted);\n        assert json != null;\n        this.accessToken = new String(Base64.getDecoder().decode(json.getString(\"access_token\")));\n        this.refreshToken = new String(Base64.getDecoder().decode(json.getString(\"refresh_token\")));\n        this.session = session;\n    }\n\n    /**\n     * Connect to the downstream server\n     * @param address the address of the downstream server\n     * @param port the port of the downstream server\n     */", "    public void connect(String address, int port) {\n        ProxiedPlayer player = this;\n\n        new Bootstrap()\n                .channelFactory(RakChannelFactory.client(NioDatagramChannel.class))\n                .group(new NioEventLoopGroup())\n                .option(RakChannelOption.RAK_PROTOCOL_VERSION, ProxyServer.BEDROCK_CODEC.getRaknetProtocolVersion())\n                .option(RakChannelOption.RAK_ORDERING_CHANNELS, 1)\n                .option(RakChannelOption.RAK_SESSION_TIMEOUT, 10000L)\n                .handler(new BedrockClientInitializer() {\n                    @Override\n                    protected void initSession(BedrockClientSession downstreamSession) {\n                        downstreamSession.setCodec(ProxyServer.BEDROCK_CODEC);\n\n                        RequestNetworkSettingsPacket pk = new RequestNetworkSettingsPacket();\n                        pk.setProtocolVersion(ProxyServer.BEDROCK_CODEC.getProtocolVersion());\n                        downstreamSession.sendPacketImmediately(pk);\n\n                        downstreamSession.setPacketHandler(new DownstreamPacketHandler(player));\n\n                        ProxiedPlayer.this.downstreamSession = downstreamSession;\n                    }\n                })\n                .connect(new InetSocketAddress(address, port))\n                .syncUninterruptibly();\n    }\n\n    /**\n     * Send a packet to the downstream server\n     *\n     * @param packet the packet to send\n     */", "    public void sendDownstreamPacket(BedrockPacket packet) {\n        BedrockClientSession session = this.downstreamSession;\n        if (session != null) {\n            session.sendPacket(packet);\n        }\n    }\n\n    public void disconnect(String reason) {\n        if (this.session.isConnected()) {\n            this.session.disconnect(reason);\n        }", "        if (this.session.isConnected()) {\n            this.session.disconnect(reason);\n        }\n        if (this.downstreamSession != null && this.downstreamSession.isConnected()) {\n            this.downstreamSession.disconnect(reason);\n        }\n    }\n\n    public void sendMessage(String message) {\n        TextPacket pk = new TextPacket();\n        pk.setType(TextPacket.Type.RAW);\n        pk.setPlatformChatId(\"\");\n        pk.setXuid(\"\");\n        pk.setSourceName(\"\");\n        pk.setNeedsTranslation(false);\n        pk.setMessage(message);\n        this.session.sendPacket(pk);\n    }\n", "    public void sendMessage(String message) {\n        TextPacket pk = new TextPacket();\n        pk.setType(TextPacket.Type.RAW);\n        pk.setPlatformChatId(\"\");\n        pk.setXuid(\"\");\n        pk.setSourceName(\"\");\n        pk.setNeedsTranslation(false);\n        pk.setMessage(message);\n        this.session.sendPacket(pk);\n    }\n", "    public LoginPacket getLoginPacket() throws Exception {\n        LoginPacket loginPacket = new LoginPacket();\n\n        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"EC\");\n        keyPairGen.initialize(new ECGenParameterSpec(\"secp256r1\"));\n\n        this.keyPair = keyPairGen.generateKeyPair();\n        Xbox xbox = new Xbox(this.accessToken);\n        String deviceToken = xbox.getDeviceToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate());\n        String xsts = xbox.getXBLToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate(), deviceToken);\n\n        this.keyPair = EncryptionUtils.createKeyPair();\n        String chainData = xbox.requestMinecraftChain(xsts, (ECPublicKey) this.keyPair.getPublic());\n        JSONObject chainDataObject = JSONObject.parseObject(chainData);\n        JSONArray minecraftNetChain = chainDataObject.getJSONArray(\"chain\");\n        String firstChainHeader = minecraftNetChain.getString(0);\n        firstChainHeader = firstChainHeader.split(\"\\\\.\")[0];\n        firstChainHeader = new String(Base64.getDecoder().decode(firstChainHeader.getBytes()));\n        String firstKeyx5u = JSONObject.parseObject(firstChainHeader).getString(\"x5u\");\n\n        JSONObject newFirstChain = new JSONObject();\n        newFirstChain.put(\"certificateAuthority\", true);\n        newFirstChain.put(\"exp\", Instant.now().getEpochSecond() + TimeUnit.HOURS.toSeconds(6));\n        newFirstChain.put(\"identityPublicKey\", firstKeyx5u);\n        newFirstChain.put(\"nbf\", Instant.now().getEpochSecond() - TimeUnit.HOURS.toSeconds(6));\n\n        {\n            SignedJWT jwt = JwtUtils.encodeJWT(this.keyPair, newFirstChain);\n            JSONArray jsonArray = new JSONArray();\n            jsonArray.add(jwt);\n            jsonArray.addAll(minecraftNetChain);\n            chainDataObject.put(\"chain\", jsonArray);\n\n            loginPacket.getChain().add(jwt);", "            for (int i = 0; i < minecraftNetChain.size(); i++) {\n                String chain = minecraftNetChain.getString(i);\n                loginPacket.getChain().add(SignedJWT.parse(chain));\n            }\n        }\n        {\n            String lastChain = minecraftNetChain.getString(minecraftNetChain.size() - 1);\n            String lastChainPayload = lastChain.split(\"\\\\.\")[1];\n            lastChainPayload = new String(Base64.getDecoder().decode(lastChainPayload.getBytes()));\n\n            JSONObject payloadObject = JSONObject.parseObject(lastChainPayload);\n            JSONObject extraData = payloadObject.getJSONObject(\"extraData\");\n\n            playerInfo = new PlayerInfo(\n                    extraData.getString(\"displayName\"),\n                    extraData.getString(\"XUID\"),\n                    extraData.getString(\"identity\")\n            );\n        }\n\n        skinData.put(\"ServerAddress\", ProxyServer.getInstance().getDownstreamAddress() + \":\" + ProxyServer.getInstance().getDownstreamPort());\n        skinData.put(\"ThirdPartyName\", playerInfo.username());\n        skinData.put(\"SelfSignedId\", playerInfo.uuid());\n        loginPacket.setExtra(JwtUtils.encodeJWT(this.keyPair, skinData));\n        loginPacket.setProtocolVersion(ProxyServer.BEDROCK_CODEC.getProtocolVersion());\n        return loginPacket;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/PlayerPacketCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache;\n\nimport com.brokiem.bedrockreplay.bedrock.player.cache.block.UpdateBlockCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.chunk.LevelChunkCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.chunk.NetworkChunkPublisherCache;", "import com.brokiem.bedrockreplay.bedrock.player.cache.chunk.LevelChunkCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.chunk.NetworkChunkPublisherCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.chunk.SubChunkCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.entity.*;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.inventory.InventoryContentCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.inventory.InventorySlotCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.inventory.MobArmorEquipmentCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.inventory.MobEquipmentCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.score.SetDisplayObjectiveCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.score.SetScoreCache;", "import com.brokiem.bedrockreplay.bedrock.player.cache.score.SetDisplayObjectiveCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.score.SetScoreCache;\nimport lombok.Getter;\n\npublic class PlayerPacketCache {\n\n    @Getter\n    private final LevelChunkCache levelChunkCache = new LevelChunkCache();\n    @Getter\n    private final AddPlayerCache addPlayerCache = new AddPlayerCache();\n    @Getter\n    private final SubChunkCache subChunkCache = new SubChunkCache();\n    @Getter\n    private final NetworkChunkPublisherCache chunkPublisherCache = new NetworkChunkPublisherCache();\n    @Getter\n    private final AddItemEntityCache addItemEntityCache = new AddItemEntityCache();\n    @Getter\n    private final AddEntityCache addEntityCache = new AddEntityCache();\n    @Getter\n    private final UpdateBlockCache updateBlockCache = new UpdateBlockCache();\n    @Getter\n    private final InventoryContentCache inventoryContentCache = new InventoryContentCache();\n    @Getter\n    private final InventorySlotCache inventorySlotCache = new InventorySlotCache();\n    @Getter\n    private final MobEquipmentCache mobEquipmentCache = new MobEquipmentCache();\n    @Getter\n    private final MobArmorEquipmentCache mobArmorEquipmentCache = new MobArmorEquipmentCache();\n    @Getter\n    private final SetScoreCache setScoreCache = new SetScoreCache();\n    @Getter\n    private final SetDisplayObjectiveCache setDisplayObjectiveCache = new SetDisplayObjectiveCache();\n    @Getter\n    private final PlayerSkinCache playerSkinCache = new PlayerSkinCache();\n    @Getter\n    private final SetPlayerGameTypeCache setPlayerGameTypeCache = new SetPlayerGameTypeCache();\n    @Getter\n    private final PlayerListEntryCache playerListEntryCache = new PlayerListEntryCache();\n    @Getter\n    private final SetEntityDataCache setEntityDataCache = new SetEntityDataCache();\n    @Getter\n    private final BossEventCache bossEventCache = new BossEventCache();\n\n    public PlayerPacketCache() { }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/inventory/InventoryContentCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.inventory;\n\nimport org.cloudburstmc.protocol.bedrock.packet.InventoryContentPacket;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InventoryContentCache {\n\n    private final List<InventoryContentPacket> packets = new ArrayList<>();\n\n    public void storePacket(InventoryContentPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<InventoryContentPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(InventoryContentPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<InventoryContentPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/inventory/MobEquipmentCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.inventory;\n\nimport org.cloudburstmc.protocol.bedrock.packet.MobEquipmentPacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MobEquipmentCache {\n\n    private final Map<Long, MobEquipmentPacket> packets = new HashMap<>();\n\n    public void storePacket(long runtimeEntityId, MobEquipmentPacket packet) {\n        packets.put(runtimeEntityId, packet);\n    }\n\n    public Map<Long, MobEquipmentPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(long runtimeEntityId, MobEquipmentPacket packet) {\n        packets.put(runtimeEntityId, packet);\n    }\n\n    public Map<Long, MobEquipmentPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/inventory/InventorySlotCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.inventory;\n\nimport org.cloudburstmc.protocol.bedrock.packet.InventorySlotPacket;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InventorySlotCache {\n\n    private final List<InventorySlotPacket> packets = new ArrayList<>();\n\n    public void storePacket(InventorySlotPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<InventorySlotPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(InventorySlotPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<InventorySlotPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/inventory/MobArmorEquipmentCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.inventory;\n\nimport org.cloudburstmc.protocol.bedrock.packet.MobArmorEquipmentPacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MobArmorEquipmentCache {\n\n    private final Map<Long, MobArmorEquipmentPacket> packets = new HashMap<>();\n\n    public void storePacket(long runtimeEntityId, MobArmorEquipmentPacket packet) {\n        packets.put(runtimeEntityId, packet);\n    }\n\n    public Map<Long, MobArmorEquipmentPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(long runtimeEntityId, MobArmorEquipmentPacket packet) {\n        packets.put(runtimeEntityId, packet);\n    }\n\n    public Map<Long, MobArmorEquipmentPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/PlayerSkinCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.PlayerSkinPacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PlayerSkinCache {\n\n    private final Map<String, PlayerSkinPacket> packets = new HashMap<>();\n\n    public void storePacket(String uuid, PlayerSkinPacket packet) {\n        packets.put(uuid, packet);\n    }\n\n    public Map<String, PlayerSkinPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(String uuid, PlayerSkinPacket packet) {\n        packets.put(uuid, packet);\n    }\n\n    public Map<String, PlayerSkinPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/BossEventCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.BossEventPacket;\n\nimport java.util.Map;", "\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class BossEventCache {\n\n    private final Map<Long, BossEventPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(long entityRuntimeId, BossEventPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, BossEventPacket> getPackets() {\n        return packets;\n    }\n", "    public void storePacket(long entityRuntimeId, BossEventPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, BossEventPacket> getPackets() {\n        return packets;\n    }\n\n    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}", "    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/AddPlayerCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.AddPlayerPacket;\n\nimport java.util.Map;", "\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class AddPlayerCache {\n\n    private final Map<Long, AddPlayerPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(long entityRuntimeId, AddPlayerPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddPlayerPacket> getPackets() {\n        return packets;\n    }\n", "    public void storePacket(long entityRuntimeId, AddPlayerPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddPlayerPacket> getPackets() {\n        return packets;\n    }\n\n    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}", "    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/AddItemEntityCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.AddItemEntityPacket;\n\nimport java.util.Map;", "\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class AddItemEntityCache {\n\n    private final Map<Long, AddItemEntityPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(long entityRuntimeId, AddItemEntityPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddItemEntityPacket> getPackets() {\n        return packets;\n    }\n", "    public void storePacket(long entityRuntimeId, AddItemEntityPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddItemEntityPacket> getPackets() {\n        return packets;\n    }\n\n    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}", "    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/SetEntityDataCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.SetEntityDataPacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SetEntityDataCache {\n\n    private final Map<Long, SetEntityDataPacket> packets = new HashMap<>();\n\n    public void storePacket(long entityRuntimeId, SetEntityDataPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n", "    public void storePacket(long entityRuntimeId, SetEntityDataPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public SetEntityDataPacket getPacket(long entityRuntimeId) {\n        return packets.get(entityRuntimeId);\n    }\n\n    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n\n    public Map<Long, SetEntityDataPacket> getPackets() {\n        return packets;\n    }\n\n}", "    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n\n    public Map<Long, SetEntityDataPacket> getPackets() {\n        return packets;\n    }\n\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/AddEntityCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.AddEntityPacket;\n\nimport java.util.Map;", "\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class AddEntityCache {\n\n    private final Map<Long, AddEntityPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(long entityRuntimeId, AddEntityPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddEntityPacket> getPackets() {\n        return packets;\n    }\n", "    public void storePacket(long entityRuntimeId, AddEntityPacket packet) {\n        packets.put(entityRuntimeId, packet);\n    }\n\n    public Map<Long, AddEntityPacket> getPackets() {\n        return packets;\n    }\n\n    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}", "    public void removePacket(long entityRuntimeId) {\n        packets.remove(entityRuntimeId);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/PlayerListEntryCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.PlayerListPacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PlayerListEntryCache {\n\n    private final Map<String, PlayerListPacket.Entry> entries = new HashMap<>();\n\n    public void storeEntry(String uuid, PlayerListPacket.Entry entry) {\n        entries.put(uuid, entry);\n    }\n", "    public void storeEntry(String uuid, PlayerListPacket.Entry entry) {\n        entries.put(uuid, entry);\n    }\n\n    public void removeEntry(String uuid) {\n        entries.remove(uuid);\n    }\n\n    public Map<String, PlayerListPacket.Entry> getEntries() {\n        return entries;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/entity/SetPlayerGameTypeCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.entity;\n\nimport org.cloudburstmc.protocol.bedrock.packet.SetPlayerGameTypePacket;\n\npublic class SetPlayerGameTypeCache {\n\n    private SetPlayerGameTypePacket packet = null;\n", "\npublic class SetPlayerGameTypeCache {\n\n    private SetPlayerGameTypePacket packet = null;\n\n    public void setPacket(SetPlayerGameTypePacket packet) {\n        this.packet = packet;\n    }\n\n    public SetPlayerGameTypePacket getPacket() {\n        return this.packet;\n    }\n}", "    public SetPlayerGameTypePacket getPacket() {\n        return this.packet;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/chunk/SubChunkCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.chunk;\n\nimport org.cloudburstmc.protocol.bedrock.packet.SubChunkPacket;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SubChunkCache {\n\n    private final List<SubChunkPacket> packets = new ArrayList<>();\n\n    public void storePacket(SubChunkPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<SubChunkPacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(SubChunkPacket packet) {\n        packets.add(packet);\n    }\n\n    public List<SubChunkPacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/chunk/LevelChunkCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.chunk;\n\nimport org.cloudburstmc.protocol.bedrock.packet.LevelChunkPacket;\n\nimport java.util.Map;", "\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class LevelChunkCache {\n\n    private final Map<ChunkCoordinate, LevelChunkPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(ChunkCoordinate chunkCoordinate, LevelChunkPacket packet) {\n        packets.put(chunkCoordinate, packet);\n    }\n", "    public void storePacket(ChunkCoordinate chunkCoordinate, LevelChunkPacket packet) {\n        packets.put(chunkCoordinate, packet);\n    }\n\n    public LevelChunkPacket getPacket(ChunkCoordinate chunkCoordinate) {\n        return packets.get(chunkCoordinate);\n    }\n\n    public Map<ChunkCoordinate, LevelChunkPacket> getPackets() {\n        return packets;\n    }\n", "    public boolean containsPacket(ChunkCoordinate chunkCoordinate) {\n        return packets.containsKey(chunkCoordinate);\n    }\n\n    public LevelChunkPacket removePacket(ChunkCoordinate chunkCoordinate) {\n        return packets.remove(chunkCoordinate);\n    }\n\n    public record ChunkCoordinate(int x, int y) {\n        @Override\n            public boolean equals(Object o) {", "    public record ChunkCoordinate(int x, int y) {\n        @Override\n            public boolean equals(Object o) {\n                if (this == o) return true;\n                if (o == null || getClass() != o.getClass()) return false;\n                ChunkCoordinate that = (ChunkCoordinate) o;\n                return x == that.x && y == that.y;\n            }\n\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/chunk/NetworkChunkPublisherCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.chunk;\n\nimport org.cloudburstmc.protocol.bedrock.packet.NetworkChunkPublisherUpdatePacket;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NetworkChunkPublisherCache {\n\n    private final List<NetworkChunkPublisherUpdatePacket> packets = new ArrayList<>();\n\n    public void storePacket(NetworkChunkPublisherUpdatePacket packet) {\n        packets.add(packet);\n    }\n\n    public List<NetworkChunkPublisherUpdatePacket> getPackets() {\n        return packets;\n    }\n}", "    public void storePacket(NetworkChunkPublisherUpdatePacket packet) {\n        packets.add(packet);\n    }\n\n    public List<NetworkChunkPublisherUpdatePacket> getPackets() {\n        return packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/score/SetDisplayObjectiveCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.score;\n\nimport org.cloudburstmc.protocol.bedrock.packet.SetDisplayObjectivePacket;\n\nimport java.util.HashMap;", "\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SetDisplayObjectiveCache {\n\n    private final Map<String, SetDisplayObjectivePacket> packets = new HashMap<>();\n\n    public void storePacket(String objectiveId, SetDisplayObjectivePacket packet) {\n        this.packets.put(objectiveId, packet);\n    }\n", "    public void storePacket(String objectiveId, SetDisplayObjectivePacket packet) {\n        this.packets.put(objectiveId, packet);\n    }\n\n    public void removePacket(String objectiveId) {\n        this.packets.remove(objectiveId);\n    }\n\n    public Map<String, SetDisplayObjectivePacket> getPackets() {\n        return this.packets;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/score/SetScoreCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.score;\n\nimport org.cloudburstmc.protocol.bedrock.packet.SetScorePacket;\n\npublic class SetScoreCache {\n\n    private SetScorePacket packet = null;\n", "\npublic class SetScoreCache {\n\n    private SetScorePacket packet = null;\n\n    public void setPacket(SetScorePacket packet) {\n        this.packet = packet;\n    }\n\n    public SetScorePacket getPacket() {\n        return this.packet;\n    }\n}", "    public SetScorePacket getPacket() {\n        return this.packet;\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/player/cache/block/UpdateBlockCache.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.player.cache.block;\n\nimport org.cloudburstmc.math.vector.Vector3i;\nimport org.cloudburstmc.protocol.bedrock.packet.UpdateBlockPacket;\n", "import org.cloudburstmc.protocol.bedrock.packet.UpdateBlockPacket;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class UpdateBlockCache {\n\n    private final Map<Vector3i, UpdateBlockPacket> packets = new ConcurrentHashMap<>();\n\n    public void storePacket(Vector3i blockPosition, UpdateBlockPacket packet) {\n        packets.put(blockPosition, packet);\n    }\n", "    public void storePacket(Vector3i blockPosition, UpdateBlockPacket packet) {\n        packets.put(blockPosition, packet);\n    }\n\n    public UpdateBlockPacket getPacket(Vector3i blockPosition) {\n        return packets.get(blockPosition);\n    }\n\n    public Map<Vector3i, UpdateBlockPacket> getPackets() {\n        return packets;\n    }\n", "    public boolean containsPacket(Vector3i blockPosition) {\n        return packets.containsKey(blockPosition);\n    }\n\n    public void removePacket(Vector3i blockPosition) {\n        packets.remove(blockPosition);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/data/BedrockData.java", "chunked_list": ["/**\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.data;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.TypeReference;\nimport com.brokiem.bedrockreplay.utils.FileManager;", "import com.alibaba.fastjson.TypeReference;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport lombok.SneakyThrows;\nimport org.cloudburstmc.nbt.NBTInputStream;\nimport org.cloudburstmc.nbt.NbtMap;\nimport org.cloudburstmc.nbt.NbtUtils;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.ItemDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.SimpleItemDefinition;\n\nimport java.io.InputStream;", "\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Map;\n\npublic class BedrockData {\n\n    public static NbtMap BIOME_DEFINITIONS;\n    public static NbtMap ENTITY_IDENTIFIERS;\n    public static ArrayList<ItemDefinition> ITEM_DEFINITIONS = new ArrayList<>();\n\n    @SneakyThrows", "    public static NbtMap ENTITY_IDENTIFIERS;\n    public static ArrayList<ItemDefinition> ITEM_DEFINITIONS = new ArrayList<>();\n\n    @SneakyThrows\n    public static void loadBiomeDefinitions() {\n        InputStream stream = FileManager.getFileResourceAsInputStream(\"bedrock-data/biome_definitions.nbt\");\n\n        NbtMap biomesTag;\n        assert stream != null;\n        try (NBTInputStream biomenbtInputStream = NbtUtils.createNetworkReader(stream)) {\n            biomesTag = (NbtMap) biomenbtInputStream.readTag();\n            BIOME_DEFINITIONS = biomesTag;\n        }\n    }\n", "    public static void loadCreativeItems() {\n    }\n\n    @SneakyThrows\n    public static void loadEntityIdentifiers() {\n        InputStream stream = FileManager.getFileResourceAsInputStream(\"bedrock-data/entity_identifiers.nbt\");\n\n        assert stream != null;\n        try (NBTInputStream nbtInputStream = NbtUtils.createNetworkReader(stream)) {\n            ENTITY_IDENTIFIERS = (NbtMap) nbtInputStream.readTag();\n        }\n    }\n", "    public static void loadItemEntries() {\n        String data = FileManager.getFileResourceAsString(\"bedrock-data/required_item_list.json\");\n\n        Map<String, Map<String, Object>> itemEntries = JSON.parseObject(data, new TypeReference<>() {});\n        assert itemEntries != null;\n        itemEntries.forEach((itemName, val) -> {\n            int id = (int) val.get(\"runtime_id\");\n            boolean componentBased = (boolean) val.get(\"component_based\");\n            ITEM_DEFINITIONS.add(new SimpleItemDefinition(itemName, id, componentBased));\n        });\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/network/registry/FakeDefinitionRegistry.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.network.registry;\n\nimport it.unimi.dsi.fastutil.ints.Int2ObjectFunction;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectMap;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;", "import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\nimport org.cloudburstmc.nbt.NbtMap;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.BlockDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.ItemDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.SimpleBlockDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.SimpleItemDefinition;\nimport org.cloudburstmc.protocol.common.Definition;\nimport org.cloudburstmc.protocol.common.DefinitionRegistry;\n\npublic class FakeDefinitionRegistry<D extends Definition> implements DefinitionRegistry<D> {\n", "import org.cloudburstmc.protocol.common.DefinitionRegistry;\n\npublic class FakeDefinitionRegistry<D extends Definition> implements DefinitionRegistry<D> {\n\n    public static FakeDefinitionRegistry<BlockDefinition> createBlockRegistry() {\n        return new FakeDefinitionRegistry<>(rid -> new SimpleBlockDefinition(\"unknown\", rid, NbtMap.EMPTY));\n    }\n\n    public static FakeDefinitionRegistry<ItemDefinition> createItemRegistry() {\n        return new FakeDefinitionRegistry<>(rid -> new SimpleItemDefinition(\"unknown\", rid, false));\n    }\n\n    private final Int2ObjectMap<D> runtimeMap = new Int2ObjectOpenHashMap<>();\n    private final Int2ObjectFunction<D> factory;\n\n    public FakeDefinitionRegistry(Int2ObjectFunction<D> factory) {\n        this.factory = factory;\n    }\n", "    public static FakeDefinitionRegistry<ItemDefinition> createItemRegistry() {\n        return new FakeDefinitionRegistry<>(rid -> new SimpleItemDefinition(\"unknown\", rid, false));\n    }\n\n    private final Int2ObjectMap<D> runtimeMap = new Int2ObjectOpenHashMap<>();\n    private final Int2ObjectFunction<D> factory;\n\n    public FakeDefinitionRegistry(Int2ObjectFunction<D> factory) {\n        this.factory = factory;\n    }\n", "    public D getDefinition(String identifier) {\n        return null;\n    }\n\n    @Override\n    public D getDefinition(int runtimeId) {\n        D definition = this.runtimeMap.get(runtimeId);\n        if (definition == null) {\n            this.runtimeMap.put(runtimeId, definition = this.factory.get(runtimeId));\n        }\n        return definition;\n    }\n\n    @Override", "    public boolean isRegistered(D definition) {\n        return this.runtimeMap.get(definition.getRuntimeId()) == definition;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/network/handler/downstream/DownstreamPacketHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.network.handler.downstream;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.account.AccountManager;\nimport com.brokiem.bedrockreplay.auth.Live;", "import com.brokiem.bedrockreplay.account.AccountManager;\nimport com.brokiem.bedrockreplay.auth.Live;\nimport com.brokiem.bedrockreplay.bedrock.network.registry.FakeDefinitionRegistry;\nimport com.brokiem.bedrockreplay.bedrock.player.ProxiedPlayer;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.chunk.LevelChunkCache;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.entity.SetEntityDataCache;\nimport com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.output.OutputWindow;\nimport com.brokiem.bedrockreplay.replay.ReplayData;\nimport com.brokiem.bedrockreplay.replay.ReplayManager;", "import com.brokiem.bedrockreplay.replay.ReplayData;\nimport com.brokiem.bedrockreplay.replay.ReplayManager;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport com.nimbusds.jwt.SignedJWT;\nimport it.unimi.dsi.fastutil.ints.IntOpenHashSet;\nimport it.unimi.dsi.fastutil.ints.IntSet;\nimport lombok.SneakyThrows;\nimport org.cloudburstmc.protocol.bedrock.codec.BedrockCodecHelper;\nimport org.cloudburstmc.protocol.bedrock.data.definitions.ItemDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.entity.EntityDataTypes;", "import org.cloudburstmc.protocol.bedrock.data.definitions.ItemDefinition;\nimport org.cloudburstmc.protocol.bedrock.data.entity.EntityDataTypes;\nimport org.cloudburstmc.protocol.bedrock.packet.*;\nimport org.cloudburstmc.protocol.bedrock.util.EncryptionUtils;\nimport org.cloudburstmc.protocol.common.PacketSignal;\nimport org.cloudburstmc.protocol.common.SimpleDefinitionRegistry;\n\nimport javax.crypto.SecretKey;\nimport java.net.URI;\nimport java.security.interfaces.ECPublicKey;", "import java.net.URI;\nimport java.security.interfaces.ECPublicKey;\nimport java.util.Base64;\n\npublic class DownstreamPacketHandler implements BedrockPacketHandler {\n\n    protected final ProxiedPlayer player;\n\n    public DownstreamPacketHandler(ProxiedPlayer player) {\n        this.player = player;\n    }\n\n    @SneakyThrows\n    @Override", "    public PacketSignal handle(NetworkSettingsPacket packet) {\n        player.getDownstreamSession().getPeer().setCodec(ProxyServer.BEDROCK_CODEC);\n        player.getDownstreamSession().getPeer().setCompression(packet.getCompressionAlgorithm());\n        player.getDownstreamSession().getPeer().setCompressionLevel(packet.getCompressionThreshold());\n\n        try {\n            player.getDownstreamSession().sendPacketImmediately(player.getLoginPacket());\n        } catch (Exception ignored) {\n            String newAccessToken = Live.getInstance().refreshToken(player.getRefreshToken()).getString(\"access_token\");\n            player.setAccessToken(newAccessToken);\n\n            JSONObject json = new JSONObject();\n            json.put(\"access_token\", Base64.getEncoder().encodeToString(newAccessToken.getBytes()));\n            json.put(\"refresh_token\", Base64.getEncoder().encodeToString(player.getRefreshToken().getBytes()));\n            String encrypted = AccountManager.encrypt(json.toJSONString());\n            FileManager.writeToFile(\".account\", encrypted);\n\n            player.getDownstreamSession().sendPacketImmediately(player.getLoginPacket());\n        }\n\n        player.setAllowSendPacket(true);\n        return PacketSignal.HANDLED;\n    }\n\n    @SneakyThrows\n    @Override", "    public PacketSignal handle(ServerToClientHandshakePacket packet) {\n        SignedJWT saltJwt = SignedJWT.parse(packet.getJwt());\n        URI x5u = saltJwt.getHeader().getX509CertURL();\n        ECPublicKey serverKey = EncryptionUtils.generateKey(x5u.toASCIIString());\n        SecretKey key = EncryptionUtils.getSecretKey(this.player.getKeyPair().getPrivate(), serverKey, Base64.getDecoder().decode(saltJwt.getJWTClaimsSet().getStringClaim(\"salt\")));\n        this.player.getDownstreamSession().enableEncryption(key);\n\n        ClientToServerHandshakePacket clientToServerHandshake = new ClientToServerHandshakePacket();\n        player.getDownstreamSession().sendPacket(clientToServerHandshake);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(StartGamePacket packet) {\n        SetPlayerGameTypePacket setPlayerGameTypePacket = new SetPlayerGameTypePacket();\n        setPlayerGameTypePacket.setGamemode(packet.getPlayerGameType().ordinal());\n        player.getPacketCache().getSetPlayerGameTypeCache().setPacket(setPlayerGameTypePacket);\n\n        BedrockCodecHelper upstreamCodecHelper = player.getSession().getPeer().getCodecHelper();\n        BedrockCodecHelper downstreamCodecHelper = player.getDownstreamSession().getPeer().getCodecHelper();\n        SimpleDefinitionRegistry.Builder<ItemDefinition> itemRegistry = SimpleDefinitionRegistry.builder();\n        IntSet runtimeIds = new IntOpenHashSet();\n        for (ItemDefinition definition : packet.getItemDefinitions()) {\n            if (runtimeIds.add(definition.getRuntimeId())) {\n                itemRegistry.add(definition);\n            }\n        }\n        upstreamCodecHelper.setItemDefinitions(itemRegistry.build());\n        downstreamCodecHelper.setItemDefinitions(itemRegistry.build());\n        upstreamCodecHelper.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n        downstreamCodecHelper.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n\n        player.setEntityRuntimeId(packet.getRuntimeEntityId());\n        player.getSession().sendPacket(packet);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "        for (ItemDefinition definition : packet.getItemDefinitions()) {\n            if (runtimeIds.add(definition.getRuntimeId())) {\n                itemRegistry.add(definition);\n            }\n        }\n        upstreamCodecHelper.setItemDefinitions(itemRegistry.build());\n        downstreamCodecHelper.setItemDefinitions(itemRegistry.build());\n        upstreamCodecHelper.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n        downstreamCodecHelper.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());\n\n        player.setEntityRuntimeId(packet.getRuntimeEntityId());\n        player.getSession().sendPacket(packet);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MovePlayerPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LevelChunkPacket packet) {\n        // retain data so it doesn't get released\n        packet.getData().retain();\n\n        int x = packet.getChunkX();\n        int y = packet.getChunkZ();\n\n        ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replayData != null) {\n            if (replayData.isRecording()) {\n                replayData.addPacket(packet);\n            }\n        }\n\n        LevelChunkCache.ChunkCoordinate chunkCoordinate = new LevelChunkCache.ChunkCoordinate(x, y);\n        player.getPacketCache().getLevelChunkCache().storePacket(chunkCoordinate, packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "        if (replayData != null) {\n            if (replayData.isRecording()) {\n                replayData.addPacket(packet);\n            }\n        }\n\n        LevelChunkCache.ChunkCoordinate chunkCoordinate = new LevelChunkCache.ChunkCoordinate(x, y);\n        player.getPacketCache().getLevelChunkCache().storePacket(chunkCoordinate, packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SubChunkPacket packet) {\n        ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replayData != null) {\n            if (replayData.isRecording()) {\n                replayData.addPacket(packet);\n            }\n        }\n\n        player.getPacketCache().getSubChunkCache().storePacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(AddPlayerPacket packet) {\n        ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replayData != null) {\n            if (replayData.isRecording()) {\n                replayData.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getAddPlayerCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(RemoveEntityPacket packet) {\n        ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replayData != null) {\n            if (replayData.isRecording()) {\n                replayData.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getAddPlayerCache().removePacket(packet.getUniqueEntityId());\n        player.getPacketCache().getAddItemEntityCache().removePacket(packet.getUniqueEntityId());\n        player.getPacketCache().getAddEntityCache().removePacket(packet.getUniqueEntityId());\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MoveEntityAbsolutePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(NetworkChunkPublisherUpdatePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getChunkPublisherCache().storePacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(UpdateBlockPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getUpdateBlockCache().storePacket(packet.getBlockPosition(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(AddEntityPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getAddEntityCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(AddItemEntityPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getAddItemEntityCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(InventoryContentPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getInventoryContentCache().storePacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(InventorySlotPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getInventorySlotCache().storePacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MobEquipmentPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getMobEquipmentCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MobArmorEquipmentPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getMobArmorEquipmentCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetScorePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getSetScoreCache().setPacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetDisplayObjectivePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getSetDisplayObjectiveCache().storePacket(packet.getObjectiveId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LevelSoundEventPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LevelSoundEvent1Packet packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LevelSoundEvent2Packet packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(TakeItemEntityPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null && replay.isRecording()) {\n            replay.addPacket(packet);\n        }\n        player.getPacketCache().getAddItemEntityCache().removePacket(packet.getItemRuntimeEntityId());\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(LevelEventPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());", "    public PacketSignal handle(LevelEventPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(AnimatePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(RemoveObjectivePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getSetDisplayObjectiveCache().removePacket(packet.getObjectiveId());\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(TextPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(PlayerSkinPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getPlayerSkinCache().storePacket(packet.getUuid().toString(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(PlaySoundPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(EntityEventPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetPlayerGameTypePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getSetPlayerGameTypeCache().setPacket(packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(StopSoundPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(PlayerListPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        if (packet.getAction().ordinal() == PlayerListPacket.Action.ADD.ordinal()) {\n            for (PlayerListPacket.Entry entry : packet.getEntries()) {\n                player.getPacketCache().getPlayerListEntryCache().storeEntry(entry.getUuid().toString(), entry);\n            }", "            for (PlayerListPacket.Entry entry : packet.getEntries()) {\n                player.getPacketCache().getPlayerListEntryCache().storeEntry(entry.getUuid().toString(), entry);\n            }\n        } else if (packet.getAction().ordinal() == PlayerListPacket.Action.REMOVE.ordinal()) {\n            for (PlayerListPacket.Entry entry : packet.getEntries()) {\n                player.getPacketCache().getPlayerListEntryCache().removeEntry(entry.getUuid().toString());\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetEntityDataPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        SetEntityDataCache setEntityDataCache = player.getPacketCache().getSetEntityDataCache();\n        if (packet.getRuntimeEntityId() == player.getEntityRuntimeId()) {\n            if (packet.getMetadata().get(EntityDataTypes.NAME) != null || setEntityDataCache.getPacket(packet.getRuntimeEntityId()) == null) {\n                setEntityDataCache.storePacket(packet.getRuntimeEntityId(), packet);\n            } else {\n                String nametag = setEntityDataCache.getPacket(packet.getRuntimeEntityId()).getMetadata().get(EntityDataTypes.NAME);", "        if (packet.getRuntimeEntityId() == player.getEntityRuntimeId()) {\n            if (packet.getMetadata().get(EntityDataTypes.NAME) != null || setEntityDataCache.getPacket(packet.getRuntimeEntityId()) == null) {\n                setEntityDataCache.storePacket(packet.getRuntimeEntityId(), packet);\n            } else {\n                String nametag = setEntityDataCache.getPacket(packet.getRuntimeEntityId()).getMetadata().get(EntityDataTypes.NAME);\n                if (nametag != null) {\n                    packet.getMetadata().put(EntityDataTypes.NAME, nametag);\n                }\n                setEntityDataCache.storePacket(packet.getRuntimeEntityId(), packet);\n            }\n        } else {\n            setEntityDataCache.storePacket(packet.getRuntimeEntityId(), packet);\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetEntityMotionPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(BlockEventPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(BossEventPacket packet) {\n        if (packet.getPlayerUniqueEntityId() != player.getEntityRuntimeId()) {\n            return PacketSignal.UNHANDLED;\n        }\n\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getBossEventCache().storePacket(packet.getPlayerUniqueEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetTitlePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetTimePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handlePacket(BedrockPacket packet) {\n        //OutputWindow.print(\"DOWNSTREAM -> UP: \" + packet.toString());\n\n        PacketSignal packetSignal = packet.handle(this);\n        if (packetSignal == PacketSignal.HANDLED) {\n            return packetSignal;\n        }\n\n        player.getSession().sendPacket(packet);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(DisconnectPacket packet) {\n        OutputWindow.print(\"Disconnected from downstream server: \" + packet.getKickMessage());\n        player.disconnect(packet.getKickMessage());\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public void onDisconnect(String reason) {\n        OutputWindow.print(\"Disconnected from downstream server: \" + reason);\n        player.disconnect(reason);\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/network/handler/upstream/UpstreamPacketHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.network.handler.upstream;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.bedrock.player.ProxiedPlayer;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.PlayerPacketCache;", "import com.brokiem.bedrockreplay.bedrock.player.ProxiedPlayer;\nimport com.brokiem.bedrockreplay.bedrock.player.cache.PlayerPacketCache;\nimport com.brokiem.bedrockreplay.bedrock.server.ProxyServer;\nimport com.brokiem.bedrockreplay.output.OutputWindow;\nimport com.brokiem.bedrockreplay.replay.ReplayData;\nimport com.brokiem.bedrockreplay.replay.ReplayManager;\nimport com.brokiem.bedrockreplay.utils.Callback;\nimport org.cloudburstmc.protocol.bedrock.data.PacketCompressionAlgorithm;\nimport org.cloudburstmc.protocol.bedrock.packet.*;\nimport org.cloudburstmc.protocol.common.PacketSignal;", "import org.cloudburstmc.protocol.bedrock.packet.*;\nimport org.cloudburstmc.protocol.common.PacketSignal;\n\nimport java.util.Base64;\n\npublic class UpstreamPacketHandler implements BedrockPacketHandler {\n\n    protected final ProxiedPlayer player;\n\n    public UpstreamPacketHandler(ProxiedPlayer player) {\n        this.player = player;\n    }\n\n    @Override", "    public PacketSignal handle(RequestNetworkSettingsPacket packet) {\n        NetworkSettingsPacket networkSettingsPacket = new NetworkSettingsPacket();\n        networkSettingsPacket.setCompressionThreshold(1);\n        networkSettingsPacket.setCompressionAlgorithm(PacketCompressionAlgorithm.ZLIB);\n        networkSettingsPacket.setClientThrottleEnabled(false);\n        networkSettingsPacket.setClientThrottleThreshold(0);\n        networkSettingsPacket.setClientThrottleScalar(0);\n        player.getSession().sendPacketImmediately(networkSettingsPacket);\n\n        player.getSession().getPeer().setCompression(PacketCompressionAlgorithm.ZLIB);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(LoginPacket packet) {\n        String extraData = packet.getExtra().getParsedString();\n        String downstreamAddress = ProxyServer.getInstance().getDownstreamAddress();\n        int downstreamPort = ProxyServer.getInstance().getDownstreamPort();\n\n        player.setSkinData(JSONObject.parseObject(new String(Base64.getUrlDecoder().decode(extraData.split(\"\\\\.\")[1]))));\n\n        PlayStatusPacket playStatusPacket = new PlayStatusPacket();\n        playStatusPacket.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        player.getSession().sendPacket(playStatusPacket);\n\n        // Connect to downstream server\n        player.connect(downstreamAddress, downstreamPort);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(ClientCacheStatusPacket packet) {\n        if (player.isAllowSendPacket()) {\n            player.sendDownstreamPacket(packet);\n        }\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(SetLocalPlayerAsInitializedPacket packet) {\n        player.sendMessage(\"\u00a7c[!] You are joined through BedrockReplay proxy!\");\n        player.sendMessage(\"\u00a7e[!] Replay commands:\");\n        player.sendMessage(\"\u00a7a[!] !replay record <replayName> - start recording replay\");\n        player.sendMessage(\"\u00a7a[!] !replay stop - stop replay from recording\");\n        player.sendMessage(\"\u00a7a\\n\");\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(SetLocalPlayerAsInitializedPacket packet) {\n        player.sendMessage(\"\u00a7c[!] You are joined through BedrockReplay proxy!\");\n        player.sendMessage(\"\u00a7e[!] Replay commands:\");\n        player.sendMessage(\"\u00a7a[!] !replay record <replayName> - start recording replay\");\n        player.sendMessage(\"\u00a7a[!] !replay stop - stop replay from recording\");\n        player.sendMessage(\"\u00a7a\\n\");\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(TextPacket packet) {\n        String message = packet.getMessage();\n", "    public PacketSignal handle(TextPacket packet) {\n        String message = packet.getMessage();\n\n        if (message.startsWith(\"!\")) {\n            String[] args = message.substring(1).split(\" \");\n            if (args.length > 0) {\n                String command = args[0];\n                String[] commandArgs = new String[args.length - 1];\n                System.arraycopy(args, 1, commandArgs, 0, commandArgs.length);\n\n                if (command.equals(\"replay\")) {", "                if (command.equals(\"replay\")) {\n                    if (commandArgs.length > 0) {\n                        switch (commandArgs[0]) {\n                            case \"record\" -> {\n                                if (commandArgs.length > 1) {\n                                    String replayName = commandArgs[1];\n                                    ReplayData replayData = ReplayManager.getInstance().getReplay(replayName);\n                                    if (replayData == null) {\n                                        replayData = ReplayManager.getInstance().createReplay(player.getPlayerInfo().username(), replayName);\n                                    }\n                                    if (replayData != null && !replayData.isRecording()) {\n                                        replayData.setRecorderEntityRuntimeId(player.getEntityRuntimeId());\n                                        // add cached packets to replay data\n                                        PlayerPacketCache packetCache = player.getPacketCache();\n                                        replayData.addPacketCache(packetCache);\n                                        // start recording\n                                        replayData.startRecording();\n                                        player.sendMessage(\"\u00a7a[!] Replay started recording! (ID: \" + replayName + \")\");\n                                    } else {\n                                        player.sendMessage(\"\u00a7c[!] You are already started recording a replay!\");\n                                    }\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Please enter a replay name!\");\n                                }\n                                return PacketSignal.HANDLED;\n                            }\n                            case \"stop\" -> {\n                                ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());", "                                    if (replayData != null && !replayData.isRecording()) {\n                                        replayData.setRecorderEntityRuntimeId(player.getEntityRuntimeId());\n                                        // add cached packets to replay data\n                                        PlayerPacketCache packetCache = player.getPacketCache();\n                                        replayData.addPacketCache(packetCache);\n                                        // start recording\n                                        replayData.startRecording();\n                                        player.sendMessage(\"\u00a7a[!] Replay started recording! (ID: \" + replayName + \")\");\n                                    } else {\n                                        player.sendMessage(\"\u00a7c[!] You are already started recording a replay!\");\n                                    }\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] Please enter a replay name!\");\n                                }\n                                return PacketSignal.HANDLED;\n                            }\n                            case \"stop\" -> {\n                                ReplayData replayData = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());", "                                if (replayData != null) {\n                                    player.sendMessage(\"\u00a7a[!] Saving replay '\" + replayData.getReplayId() + \"'...\");\n                                    replayData.stopRecording();\n                                    replayData.saveToFile(\"./replays/\" + replayData.getReplayId(), new Callback() {\n                                        @Override\n                                        public void onSuccess() {\n                                            player.sendMessage(\"\u00a7a[!] Replay saved! (ID: \" + replayData.getReplayId() + \")\");\n                                            ReplayManager.getInstance().removeReplay(replayData.getReplayId());\n                                        }\n\n                                        @Override", "                                        public void onFailure(String errorMessage) {\n                                            player.sendMessage(\"\u00a7c[!] Failed to save replay: \" + errorMessage);\n                                        }\n                                    });\n                                } else {\n                                    player.sendMessage(\"\u00a7c[!] You are not started recording a replay yet!\");\n                                }\n                                return PacketSignal.HANDLED;\n                            }\n                        }\n                    } else {\n                        player.sendMessage(\"\u00a7cUsage: !replay <record|stop> [replayName]\");\n                        return PacketSignal.HANDLED;\n                    }\n                } else {\n                    player.sendMessage(\"\u00a7cCommand list: !replay\");\n                    return PacketSignal.HANDLED;\n                }\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(PlayerAuthInputPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                MovePlayerPacket pk = new MovePlayerPacket();\n                pk.setRuntimeEntityId(replay.getRecorderEntityRuntimeId());\n                pk.setPosition(packet.getPosition());\n                pk.setRotation(packet.getRotation());\n                pk.setOnGround(false);\n                pk.setTick(replay.getTick());\n                pk.setMode(MovePlayerPacket.Mode.NORMAL);\n                pk.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);\n                pk.setEntityType(0);\n                pk.setRidingRuntimeEntityId(0);\n                replay.addPacket(pk);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MobEquipmentPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getMobEquipmentCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(MobArmorEquipmentPacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        player.getPacketCache().getMobArmorEquipmentCache().storePacket(packet.getRuntimeEntityId(), packet);\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(AnimatePacket packet) {\n        ReplayData replay = ReplayManager.getInstance().getRecordingReplayByPlayer(player.getPlayerInfo().username());\n        if (replay != null) {\n            if (replay.isRecording()) {\n                replay.addPacket(packet);\n            }\n        }\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(InventoryTransactionPacket packet) {\n        // TODO: convert InventoryTransactionPacket to InventorySlotPacket/InventoryContentPacket\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override\n    public PacketSignal handle(ItemStackRequestPacket packet) {\n        // TODO: convert ItemStackRequestPacket to InventorySlotPacket/InventoryContentPacket\n        return PacketSignal.UNHANDLED;\n    }\n\n    @Override", "    public PacketSignal handle(PacketViolationWarningPacket packet) {\n        OutputWindow.print(\"Packet violation warning: \" + packet.getContext());\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public PacketSignal handlePacket(BedrockPacket packet) {\n        //OutputWindow.print(\"UPSTREAM -> DOWN: \" + packet.toString());\n\n        PacketSignal packetSignal = packet.handle(this);\n        if (packetSignal == PacketSignal.HANDLED) {\n            return packetSignal;\n        }\n\n        player.getDownstreamSession().sendPacket(packet);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override", "        if (packetSignal == PacketSignal.HANDLED) {\n            return packetSignal;\n        }\n\n        player.getDownstreamSession().sendPacket(packet);\n        return PacketSignal.HANDLED;\n    }\n\n    @Override\n    public void onDisconnect(String reason) {\n        OutputWindow.print(\"Disconnect packet received from upstream server: \" + reason);\n        player.disconnect(reason);\n    }\n}\n", "    public void onDisconnect(String reason) {\n        OutputWindow.print(\"Disconnect packet received from upstream server: \" + reason);\n        player.disconnect(reason);\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/bedrock/server/ProxyServer.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.bedrock.server;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.brokiem.bedrockreplay.bedrock.network.handler.upstream.UpstreamPacketHandler;\nimport com.brokiem.bedrockreplay.bedrock.player.ProxiedPlayer;", "import com.brokiem.bedrockreplay.bedrock.network.handler.upstream.UpstreamPacketHandler;\nimport com.brokiem.bedrockreplay.bedrock.player.ProxiedPlayer;\nimport com.brokiem.bedrockreplay.utils.FileManager;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport lombok.Getter;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.cloudburstmc.protocol.bedrock.BedrockPong;", "import org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.cloudburstmc.protocol.bedrock.BedrockPong;\nimport org.cloudburstmc.protocol.bedrock.BedrockServerSession;\nimport org.cloudburstmc.protocol.bedrock.codec.BedrockCodec;\nimport org.cloudburstmc.protocol.bedrock.codec.v589.Bedrock_v589;\nimport org.cloudburstmc.protocol.bedrock.netty.initializer.BedrockServerInitializer;\n\nimport java.net.InetSocketAddress;\n\npublic class ProxyServer {\n\n    @Getter\n    private static ProxyServer instance;\n\n    private boolean isRunning = false;\n", "\npublic class ProxyServer {\n\n    @Getter\n    private static ProxyServer instance;\n\n    private boolean isRunning = false;\n\n    public static final BedrockCodec BEDROCK_CODEC = Bedrock_v589.CODEC;\n\n    private final InetSocketAddress bindAddress;\n\n    @Getter\n    private final String downstreamAddress;\n    @Getter\n    private final int downstreamPort;\n\n    public ProxyServer(InetSocketAddress address) {\n        bindAddress = address;\n\n        JSONObject config = JSONObject.parseObject(FileManager.getFileContents(\"config.json\"));\n        assert config != null;\n        downstreamAddress = config.getJSONObject(\"server\").getString(\"address\");\n        downstreamPort = config.getJSONObject(\"server\").getIntValue(\"port\");\n\n        instance = this;\n    }\n", "    public static final BedrockCodec BEDROCK_CODEC = Bedrock_v589.CODEC;\n\n    private final InetSocketAddress bindAddress;\n\n    @Getter\n    private final String downstreamAddress;\n    @Getter\n    private final int downstreamPort;\n\n    public ProxyServer(InetSocketAddress address) {\n        bindAddress = address;\n\n        JSONObject config = JSONObject.parseObject(FileManager.getFileContents(\"config.json\"));\n        assert config != null;\n        downstreamAddress = config.getJSONObject(\"server\").getString(\"address\");\n        downstreamPort = config.getJSONObject(\"server\").getIntValue(\"port\");\n\n        instance = this;\n    }\n", "    public void start() {\n        if (isRunning) {\n            return;\n        }\n\n        BedrockPong pong = new BedrockPong()\n                .edition(\"MCPE\")\n                .motd(\"BedrockReplay\")\n                .subMotd(\"Proxy Server\")\n                .playerCount(0)\n                .maximumPlayerCount(1)\n                .gameType(\"Survival\")\n                .protocolVersion(BEDROCK_CODEC.getProtocolVersion())\n                .ipv4Port(bindAddress.getPort())\n                .ipv6Port(bindAddress.getPort())\n                .version(BEDROCK_CODEC.getMinecraftVersion());\n\n        new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(NioDatagramChannel.class))\n                .option(RakChannelOption.RAK_ADVERTISEMENT, pong.toByteBuf())\n                .group(new NioEventLoopGroup())\n                .childHandler(new BedrockServerInitializer() {\n                    @Override\n                    protected void initSession(BedrockServerSession session) {\n                        ProxiedPlayer proxiedPlayer = new ProxiedPlayer(session);\n\n                        session.setCodec(BEDROCK_CODEC);\n                        session.setPacketHandler(new UpstreamPacketHandler(proxiedPlayer));\n                    }\n                })\n                .bind(bindAddress)\n                .syncUninterruptibly();\n\n        isRunning = true;\n    }\n}\n"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/output/OutputWindow.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.output;\n\nimport lombok.Getter;\n\nimport javax.swing.*;", "\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.net.URI;\n\npublic class OutputWindow {\n\n    @Getter\n    private static JTextArea textArea;\n", "    public static void createAndShowGUI() {\n        JFrame frame = new JFrame(\"BedrockReplay Output\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setUndecorated(true);\n\n        // Set the look and feel\n        try {\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {\n            e.printStackTrace();\n        }\n\n        JPanel panel = new JPanel();\n        JTextArea textArea = new JTextArea(15, 80);\n        Font currentFont = textArea.getFont();\n        Font newFont = new Font(currentFont.getFamily(), currentFont.getStyle(), 16);\n        textArea.setFont(newFont);\n        textArea.setLineWrap(true);\n        textArea.setWrapStyleWord(true);\n        textArea.setEditable(false);\n        textArea.addMouseListener(new MouseAdapter() {\n            @Override", "            public void mouseClicked(MouseEvent e) {\n                int x = e.getX();\n                int y = e.getY();\n\n                int startOffset = textArea.viewToModel2D(new Point(x, y));\n                String text = textArea.getText();\n                int searchHttp;\n                int wordEndIndex;\n                String[] words = text.split(\"\\\\s\");\n\n                for (String word : words) {", "                for (String word : words) {\n                    if (word.startsWith(\"https://\") || word.startsWith(\"http://\")) {\n                        searchHttp = text.indexOf(word);\n                        wordEndIndex = searchHttp + word.length();\n                        if (startOffset >= searchHttp && startOffset <= wordEndIndex) {\n                            try {\n                                textArea.select(searchHttp, wordEndIndex);\n                                Desktop.getDesktop().browse(new URI(word));\n                            } catch (Exception ignored) {}\n                        }\n                    }\n                }\n            }\n        });\n        OutputWindow.textArea = textArea;\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        panel.add(scrollPane);\n        frame.add(panel, BorderLayout.CENTER);\n\n        // Create the close button and add it to the frame\n        JButton closeButton = new JButton(\"Exit\");\n        closeButton.addActionListener(e -> System.exit(0));\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.add(closeButton);\n        frame.add(buttonPanel, BorderLayout.SOUTH);\n\n        final Point[] mouseOffset = new Point[1];\n        // Add a mouse listener to the panel to make it draggable\n        frame.addMouseListener(new MouseAdapter() {\n            @Override", "            public void mousePressed(MouseEvent e) {\n                mouseOffset[0] = e.getPoint();\n            }\n\n            @Override\n            public void mouseReleased(MouseEvent e) {\n                mouseOffset[0] = null;\n            }\n        });\n        frame.addMouseMotionListener(new MouseAdapter() {\n            @Override", "            public void mouseDragged(MouseEvent e) {\n                Point currentLocation = frame.getLocation();\n                frame.setLocation(currentLocation.x + e.getX() - mouseOffset[0].x, currentLocation.y + e.getY() - mouseOffset[0].y);\n            }\n        });\n\n        frame.pack();\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n", "    public static void print(String text) {\n        textArea.append(\"> \" + text + \"\\n\");\n        System.out.println(text);\n    }\n}"]}
{"filename": "src/main/java/com/brokiem/bedrockreplay/account/AccountManager.java", "chunked_list": ["/*\n * Copyright (c) 2023 brokiem\n * This project is licensed under the MIT License\n */\n\npackage com.brokiem.bedrockreplay.account;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;", "import javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class AccountManager {\n    private static final String ENCRYPTION_ALGORITHM = \"AES\";\n    private static final String HASH_ALGORITHM = \"SHA-256\";\n    private static final String SECRET_KEY = \"d'&?,(U&b[m098-Qngm96)>$7w7aA=\";\n\n    public static String encrypt(String plaintext) throws Exception {\n        SecretKey secretKey = generateSecretKey();\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n", "    public static String encrypt(String plaintext) throws Exception {\n        SecretKey secretKey = generateSecretKey();\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    public static String decrypt(String ciphertext) throws Exception {\n        SecretKey secretKey = generateSecretKey();\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ciphertext));\n        return new String(decryptedBytes);\n    }\n\n    private static SecretKey generateSecretKey() throws Exception {\n        MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);\n        byte[] keyBytes = digest.digest(AccountManager.SECRET_KEY.getBytes());\n        return new SecretKeySpec(keyBytes, ENCRYPTION_ALGORITHM);\n    }\n}\n", "    public static String decrypt(String ciphertext) throws Exception {\n        SecretKey secretKey = generateSecretKey();\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ciphertext));\n        return new String(decryptedBytes);\n    }\n\n    private static SecretKey generateSecretKey() throws Exception {\n        MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);\n        byte[] keyBytes = digest.digest(AccountManager.SECRET_KEY.getBytes());\n        return new SecretKeySpec(keyBytes, ENCRYPTION_ALGORITHM);\n    }\n}\n"]}
