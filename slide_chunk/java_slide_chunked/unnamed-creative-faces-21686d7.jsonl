{"filename": "src/main/java/team/unnamed/creativefaces/FacesPlugin.java", "chunked_list": ["package team.unnamed.creativefaces;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.plugin.ServicePriority;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.central.CreativeCentral;\nimport team.unnamed.creative.central.CreativeCentralProvider;", "import team.unnamed.creative.central.CreativeCentral;\nimport team.unnamed.creative.central.CreativeCentralProvider;\nimport team.unnamed.creative.central.event.pack.ResourcePackGenerateEvent;\nimport team.unnamed.creativefaces.command.FacesCommand;\nimport team.unnamed.creativefaces.display.MiniPlaceholdersDisplayHook;\nimport team.unnamed.creativefaces.display.PlaceholderAPIDisplayHook;\nimport team.unnamed.creativefaces.listener.ResourcePackGenerateListener;\n\nimport java.util.Objects;\nimport java.util.Set;", "import java.util.Objects;\nimport java.util.Set;\n\npublic class FacesPlugin extends JavaPlugin {\n\n    private final FacesPluginConfig.Ref config = new FacesPluginConfig.Ref();\n    private FaceProvider faceProvider;\n\n    @Override\n    public void onEnable() {\n        saveDefaultConfig();\n        parseConfig();\n\n        faceProvider = new FaceProvider(config);\n        Bukkit.getServicesManager().register(FaceProvider.class, faceProvider, this, ServicePriority.High);\n\n        Objects.requireNonNull(getCommand(\"faces\"), \"Couldn't find command 'faces'. Altered 'plugin.yml'?\")\n                .setExecutor(new FacesCommand(this));\n\n        CreativeCentral central = CreativeCentralProvider.get();\n\n        // register our listener to ResourcePackGenerateEvent\n        central.eventBus().listen(this, ResourcePackGenerateEvent.class, new ResourcePackGenerateListener(config));\n\n        // register our hooks\n        Set.of(\n                new MiniPlaceholdersDisplayHook(faceProvider),\n                new PlaceholderAPIDisplayHook(this, faceProvider)\n        ).forEach(hook -> {\n            Plugin plugin = Bukkit.getPluginManager().getPlugin(hook.plugin());", "    public void onEnable() {\n        saveDefaultConfig();\n        parseConfig();\n\n        faceProvider = new FaceProvider(config);\n        Bukkit.getServicesManager().register(FaceProvider.class, faceProvider, this, ServicePriority.High);\n\n        Objects.requireNonNull(getCommand(\"faces\"), \"Couldn't find command 'faces'. Altered 'plugin.yml'?\")\n                .setExecutor(new FacesCommand(this));\n\n        CreativeCentral central = CreativeCentralProvider.get();\n\n        // register our listener to ResourcePackGenerateEvent\n        central.eventBus().listen(this, ResourcePackGenerateEvent.class, new ResourcePackGenerateListener(config));\n\n        // register our hooks\n        Set.of(\n                new MiniPlaceholdersDisplayHook(faceProvider),\n                new PlaceholderAPIDisplayHook(this, faceProvider)\n        ).forEach(hook -> {\n            Plugin plugin = Bukkit.getPluginManager().getPlugin(hook.plugin());", "            if (plugin != null) {\n                hook.enable(plugin);\n                getLogger().info(\"Successfully hooked into \" + plugin.getName());\n            }\n        });\n    }\n\n    @Override\n    public void onDisable() {\n        config.set(null);\n        faceProvider = null;\n    }\n\n    public FacesPluginConfig.Ref config() {\n        return config;\n    }\n", "    public void onDisable() {\n        config.set(null);\n        faceProvider = null;\n    }\n\n    public FacesPluginConfig.Ref config() {\n        return config;\n    }\n\n    public FaceProvider headProvider() {\n        if (faceProvider == null) {\n            throw new IllegalStateException(\"Plugin not initialized yet!\");\n        }\n        return faceProvider;\n    }\n", "    public FaceProvider headProvider() {\n        if (faceProvider == null) {\n            throw new IllegalStateException(\"Plugin not initialized yet!\");\n        }\n        return faceProvider;\n    }\n\n    public FacesPluginConfig parseConfig() {\n        FacesPluginConfig config = FacesPluginConfig.load(super.getConfig());\n        this.config.set(config);\n        return config;\n    }\n\n    @Override", "    public void reloadConfig() {\n        super.reloadConfig();\n        parseConfig();\n        if (faceProvider != null) {\n            faceProvider.invalidateCache();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * @deprecated Use {@link FacesPlugin#config()} instead\n     */\n    @Override\n    @Deprecated\n    public @NotNull FileConfiguration getConfig() {\n        return super.getConfig();\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/PlayerFaceComponent.java", "chunked_list": ["package team.unnamed.creativefaces;\n\nimport net.kyori.adventure.key.Key;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.ComponentLike;\nimport net.kyori.adventure.text.TextComponent;\nimport net.kyori.adventure.text.format.TextColor;\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.font.Font;\nimport team.unnamed.creativefaces.util.Faces;", "import team.unnamed.creative.font.Font;\nimport team.unnamed.creativefaces.util.Faces;\n\npublic final class PlayerFaceComponent implements ComponentLike {\n\n    private final int[][] pixels;\n    private final Component component; // player face data is duplicated here, hmmm\n\n    private PlayerFaceComponent(int[][] pixels, Component component) {\n        this.pixels = pixels;\n        this.component = component;\n    }\n\n    /**\n     * Returns all the pixels from the player's face\n     * texture. Useful for serialization/storage.\n     * Deserialize using {@link FaceProvider#fromPixels}\n     *\n     * @return The player's face pixels\n     */\n    public int[][] pixels() {\n        return pixels;\n    }\n\n    @Override\n    public @NotNull Component asComponent() {\n        return component;\n    }\n", "    public static PlayerFaceComponent fromPixels(int[][] pixels, FacesPluginConfig.Ref config) {\n        FacesPluginConfig.Characters characters = config.current().characters();\n        TextComponent.Builder component = Component.text();\n        for (int y = 0; y < Faces.FACE_HEIGHT; y++) {\n            if (y != 0) {\n                component.append(Component.text(characters.offsetMinusEight()));\n            }\n            for (int x = 0; x < Faces.FACE_WIDTH; x++) {\n                int color = pixels[y][x];\n                component.append(\n                        Component.text()\n                                .content(characters.pixelsByHeight()[y])\n                                .color(TextColor.color(color))\n                );\n\n                component.append(Component.text(characters.offsetMinusOne()));\n            }\n        }\n        Key font = config.current().font();\n        // this condition may cause issues, check later", "        if (!font.equals(Font.MINECRAFT_DEFAULT)) {\n            component.font(font);\n        }\n        return new PlayerFaceComponent(pixels, component.build());\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/FacesPluginConfig.java", "chunked_list": ["package team.unnamed.creativefaces;\n\nimport net.kyori.adventure.key.InvalidKeyException;\nimport net.kyori.adventure.key.Key;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.intellij.lang.annotations.Subst;\nimport org.jetbrains.annotations.ApiStatus;\n\npublic record FacesPluginConfig(\n        Characters characters,\n        Key font,\n        @Subst(Key.MINECRAFT_NAMESPACE)\n        String namespace\n) {\n", "public record FacesPluginConfig(\n        Characters characters,\n        Key font,\n        @Subst(Key.MINECRAFT_NAMESPACE)\n        String namespace\n) {\n\n    public record Characters(\n            String offsetMinusEight,\n            String offsetMinusOne,\n            String[] pixelsByHeight\n    ) {\n    }\n", "    public static FacesPluginConfig load(ConfigurationSection config) {\n        @Subst(\"minecraft:default\")\n        String fontStr = config.getString(\"font\", \"minecraft:default\");\n        @Subst(\"minecraft\")\n        String namespace = config.getString(\"namespace\", \"creativefaces\");\n        Key font;\n\n        try {\n            font = Key.key(fontStr);\n        } catch (InvalidKeyException e) {\n            throw new IllegalArgumentException(\"Invalid font key!\", e);\n        }\n\n        ConfigurationSection height = config.getConfigurationSection(\"characters.height\");\n", "        if (height == null) {\n            throw new IllegalStateException(\"No height characters specified!\");\n        }\n\n        return new FacesPluginConfig(\n                new Characters(\n                        config.getString(\"characters.offset-8\"),\n                        config.getString(\"characters.offset-1\"),\n                        new String[] { // repetitive thing but i'm lazy to do logic\n                                height.getString(\"0\"),\n                                height.getString(\"1\"),\n                                height.getString(\"2\"),\n                                height.getString(\"3\"),\n                                height.getString(\"4\"),\n                                height.getString(\"5\"),\n                                height.getString(\"6\"),\n                                height.getString(\"7\")\n                        }\n                ),\n                font,\n                namespace\n        );\n    }\n", "    public static class Ref {\n\n        private FacesPluginConfig value;\n\n        @ApiStatus.Internal\n        public void set(FacesPluginConfig value) {\n            this.value = value;\n        }\n\n        /**\n         * Returns the current plugin config, should not be stored\n         * for so much time since it can change when it's reloaded\n         *\n         * @return The current plugin's config\n         */", "        public FacesPluginConfig current() {\n            if (value == null) {\n                throw new IllegalStateException(\"The plugin configuration has not been loaded yet!\");\n            }\n            return value;\n        }\n\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/FaceProvider.java", "chunked_list": ["package team.unnamed.creativefaces;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport org.bukkit.entity.Player;\nimport org.bukkit.profile.PlayerTextures;\nimport org.jetbrains.annotations.Nullable;\nimport team.unnamed.creativefaces.util.Faces;\nimport team.unnamed.creativefaces.util.NewSkins;\n", "import team.unnamed.creativefaces.util.NewSkins;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic final class FaceProvider {\n\n    private static final Object HEAD_PLACEHOLDER = new Object();\n\n    private final FacesPluginConfig.Ref config;\n    private final Cache<UUID, Object> heads = CacheBuilder.newBuilder()\n            .expireAfterWrite(1, TimeUnit.MINUTES)\n            .build();\n\n    public FaceProvider(FacesPluginConfig.Ref config) {\n        this.config = config;\n    }\n", "\npublic final class FaceProvider {\n\n    private static final Object HEAD_PLACEHOLDER = new Object();\n\n    private final FacesPluginConfig.Ref config;\n    private final Cache<UUID, Object> heads = CacheBuilder.newBuilder()\n            .expireAfterWrite(1, TimeUnit.MINUTES)\n            .build();\n\n    public FaceProvider(FacesPluginConfig.Ref config) {\n        this.config = config;\n    }\n", "    public PlayerFaceComponent get(Player player) {\n        PlayerFaceComponent data = getOrFind(player);\n        if (data == null) {\n            data = Faces.getDefaultFace(player.getUniqueId(), NewSkins.available(), config);\n        }\n        return data;\n    }\n\n    public PlayerFaceComponent fromPixels(int[][] pixels) {\n        return PlayerFaceComponent.fromPixels(pixels, config);\n    }\n\n    /**\n     * Finds the head of the player in local cache, if not found,\n     * it fetches it (see {@link FaceProvider#fetch}),\n     * the found head is saved to cache if present. This method\n     * may return null if the head couldn't be found\n     *\n     * @param player The player\n     * @return The player head data, or null if not found\n     */\n    public @Nullable PlayerFaceComponent getOrFind(Player player) {\n        UUID id = player.getUniqueId();\n        // find the cached data\n        PlayerFaceComponent data = getCached(id);", "    public PlayerFaceComponent fromPixels(int[][] pixels) {\n        return PlayerFaceComponent.fromPixels(pixels, config);\n    }\n\n    /**\n     * Finds the head of the player in local cache, if not found,\n     * it fetches it (see {@link FaceProvider#fetch}),\n     * the found head is saved to cache if present. This method\n     * may return null if the head couldn't be found\n     *\n     * @param player The player\n     * @return The player head data, or null if not found\n     */\n    public @Nullable PlayerFaceComponent getOrFind(Player player) {\n        UUID id = player.getUniqueId();\n        // find the cached data\n        PlayerFaceComponent data = getCached(id);", "        if (data == null) {\n            data = fetch(player);\n            heads.put(id, data == null ? HEAD_PLACEHOLDER : data);\n        }\n        return data;\n    }\n\n    /**\n     * Finds the head of the player with the given {@code uuid},\n     * or null if not present\n     *\n     * @param uuid The player's UUID\n     * @return The player head data, or null if not found\n     */\n    public @Nullable PlayerFaceComponent getCached(UUID uuid) {\n        Object head = heads.getIfPresent(uuid);", "        if (head == HEAD_PLACEHOLDER) {\n            return null;\n        } else {\n            return (PlayerFaceComponent) head;\n        }\n    }\n\n    /**\n     * Performs maintenance operations for the internal cache of\n     * head data\n     */", "    public void cleanUp() {\n        heads.cleanUp();\n    }\n\n    /**\n     * Invalidates all the cached player heads\n     */\n    public void invalidateCache() {\n        heads.invalidateAll();\n    }\n\n    /**\n     * Fetches the player head data, returns null if the player does not\n     * have a skin\n     *\n     * @param player The player\n     * @return The player head data\n     */\n    public @Nullable PlayerFaceComponent fetch(Player player) {\n        PlayerTextures textures = player.getPlayerProfile().getTextures();\n        URL skinUrl = textures.getSkin();\n", "        if (skinUrl == null) {\n            return null;\n        }\n\n        BufferedImage skinData;\n\n        // read image\n        try {\n            skinData = ImageIO.read(skinUrl);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Failed to read skin data\", e);\n        }\n\n        int[][] headColors = new int[Faces.FACE_HEIGHT][Faces.FACE_WIDTH];\n\n        // head layer", "        for (int x = 8; x < 16; x++) {\n            for (int y = 8; y < 16; y++) {\n                headColors[y - 8][x - 8] = skinData.getRGB(x, y);\n            }\n        }\n\n        // helmet layer\n        for (int x = 40; x < 48; x++) {\n            for (int y = 8; y < 16; y++) {\n                int rgba = skinData.getRGB(x, y);\n                int alpha = (rgba >> 24) & 0xff;", "            for (int y = 8; y < 16; y++) {\n                int rgba = skinData.getRGB(x, y);\n                int alpha = (rgba >> 24) & 0xff;\n                if ((alpha) == 0xFF) {\n                    headColors[y - 8][x - 40] = rgba;\n                }\n            }\n        }\n\n        return PlayerFaceComponent.fromPixels(headColors, config);\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/display/package-info.java", "chunked_list": ["/**\n * This package provides the classes that are responsible\n * for the display of the faces in the game.\n *\n * <p>At the moment we only support showing faces by using\n * another plugin like MiniPlaceholders (recommended) or\n * PlaceholderAPI</p>\n */\npackage team.unnamed.creativefaces.display;", "package team.unnamed.creativefaces.display;"]}
{"filename": "src/main/java/team/unnamed/creativefaces/display/DisplayHook.java", "chunked_list": ["package team.unnamed.creativefaces.display;\n\nimport org.bukkit.plugin.Plugin;\n\n/**\n * Represents a plugin hook, used to display\n * player faces using a specific plugin\n */\npublic interface DisplayHook {\n\n    /**\n     * The plugin name this hook requires\n     *\n     * @return The hooked plugin name\n     */\n    String plugin();\n\n    /**\n     * Enables the hook\n     *\n     * @param plugin The hooked plugin\n     */\n    void enable(Plugin plugin);\n\n}\n", "public interface DisplayHook {\n\n    /**\n     * The plugin name this hook requires\n     *\n     * @return The hooked plugin name\n     */\n    String plugin();\n\n    /**\n     * Enables the hook\n     *\n     * @param plugin The hooked plugin\n     */\n    void enable(Plugin plugin);\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/display/MiniPlaceholdersDisplayHook.java", "chunked_list": ["package team.unnamed.creativefaces.display;\n\nimport io.github.miniplaceholders.api.Expansion;\nimport net.kyori.adventure.text.minimessage.tag.Tag;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport team.unnamed.creativefaces.FaceProvider;\n\npublic class MiniPlaceholdersDisplayHook implements DisplayHook {\n\n    private final FaceProvider faceProvider;\n\n    public MiniPlaceholdersDisplayHook(FaceProvider faceProvider) {\n        this.faceProvider = faceProvider;\n    }\n\n    @Override", "public class MiniPlaceholdersDisplayHook implements DisplayHook {\n\n    private final FaceProvider faceProvider;\n\n    public MiniPlaceholdersDisplayHook(FaceProvider faceProvider) {\n        this.faceProvider = faceProvider;\n    }\n\n    @Override\n    public String plugin() {\n        return \"MiniPlaceholders\";\n    }\n\n    @Override", "    public String plugin() {\n        return \"MiniPlaceholders\";\n    }\n\n    @Override\n    public void enable(Plugin plugin) {\n        Expansion expansion = Expansion.builder(\"faces\")\n                .filter(Player.class)\n                .audiencePlaceholder(\"player\", (audience, arguments, ctx) ->\n                        Tag.selfClosingInserting(faceProvider.get((Player) audience)))\n                .build();\n        expansion.register();\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/display/PlaceholderAPIDisplayHook.java", "chunked_list": ["package team.unnamed.creativefaces.display;\n\nimport me.clip.placeholderapi.expansion.PlaceholderExpansion;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport team.unnamed.creativefaces.FaceProvider;", "import org.jetbrains.annotations.Nullable;\nimport team.unnamed.creativefaces.FaceProvider;\n\npublic class PlaceholderAPIDisplayHook implements DisplayHook {\n\n    private final Plugin plugin;\n    private final FaceProvider faceProvider;\n    private boolean warnNonDefaultFont = true;\n\n    public PlaceholderAPIDisplayHook(Plugin plugin, FaceProvider faceProvider) {\n        this.plugin = plugin;\n        this.faceProvider = faceProvider;\n    }\n\n    @Override", "    public String plugin() {\n        return \"PlaceholderAPI\";\n    }\n\n    @Override\n    public void enable(Plugin plugin) {\n        new FacesExpansion().register();\n    }\n\n    private class FacesExpansion extends PlaceholderExpansion {\n\n        @Override\n        public @NotNull String getAuthor() {\n            return \"Unnamed Team\";\n        }\n\n        @Override\n        public @NotNull String getIdentifier() {\n            return \"faces\";\n        }\n\n        @Override\n        public @NotNull String getVersion() {\n            return \"1.0.0\";\n        }\n\n        @Override", "        public boolean persist() {\n            return true;\n        }\n\n        @Override\n        public @Nullable String onPlaceholderRequest(Player player, @NotNull String params) {\n            if (player == null) {\n                return null;\n            }\n            if (params.equalsIgnoreCase(\"face\")) {\n                Component component = faceProvider.get(player).asComponent();", "            if (params.equalsIgnoreCase(\"face\")) {\n                Component component = faceProvider.get(player).asComponent();\n                if (component.font() != null) {\n                    // if component uses a custom font, legacy component serializer will\n                    // not work, placeholder api doesn't support this\n                    if (warnNonDefaultFont) {\n                        plugin.getLogger().warning(\"You set a custom font, it cannot be used with PlaceholderAPI!\");\n                        warnNonDefaultFont = false;\n                    }\n                    return null;\n                } else {\n                    return LegacyComponentSerializer.legacySection().serialize(component);\n                }\n            } else {\n                return null;\n            }\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/command/FacesCommand.java", "chunked_list": ["package team.unnamed.creativefaces.command;\n\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport team.unnamed.creative.central.CreativeCentralProvider;\nimport team.unnamed.creativefaces.FacesPlugin;\n", "import team.unnamed.creativefaces.FacesPlugin;\n\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport java.util.logging.Level;\n\npublic final class FacesCommand implements CommandExecutor {\n\n    private final FacesPlugin plugin;\n\n    public FacesCommand(FacesPlugin plugin) {\n        this.plugin = plugin;\n    }\n\n    @Override\n    @ParametersAreNonnullByDefault", "    public boolean onCommand(\n            CommandSender sender,\n            Command command,\n            String label,\n            String[] args\n    ) {\n        sender.sendMessage(Component.text(\"Reloading configuration...\", NamedTextColor.GREEN));\n        long startTime = System.currentTimeMillis();\n        try {\n            plugin.reloadConfig();\n            long duration = System.currentTimeMillis() - startTime;\n            sender.sendMessage(Component.text(\"Done! (\" + duration + \"ms)\\nReloading resource-pack...\", NamedTextColor.GREEN));\n            CreativeCentralProvider.get().generate().whenComplete((ignored, e) -> {", "        try {\n            plugin.reloadConfig();\n            long duration = System.currentTimeMillis() - startTime;\n            sender.sendMessage(Component.text(\"Done! (\" + duration + \"ms)\\nReloading resource-pack...\", NamedTextColor.GREEN));\n            CreativeCentralProvider.get().generate().whenComplete((ignored, e) -> {\n                if (e == null) {\n                    sender.sendMessage(Component.text(\"Done!\", NamedTextColor.GREEN));\n                } else {\n                    sender.sendMessage(Component.text(\"Failed to reload the resource-pack, check logs\", NamedTextColor.RED));\n                    plugin.getLogger().log(Level.SEVERE, \"Failed to reload resource-pack\", e);\n                }\n            });\n        } catch (Throwable e) {\n            sender.sendMessage(Component.text(\"Reload failed, check logs\", NamedTextColor.RED));\n            plugin.getLogger().log(Level.SEVERE, \"Failed to reload configuration\", e);\n        }\n        return true;\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/util/NewSkins.java", "chunked_list": ["package team.unnamed.creativefaces.util;\n\nimport org.bukkit.Material;\n\npublic final class NewSkins { // is this a NewJeans reference?\n\n    private static final boolean AVAILABLE;\n\n    static {\n        boolean available = false;\n        try {\n            // added in 1.19.3\n            Material.valueOf(\"ENDER_DRAGON_SPAWN_EGG\");\n            available = true;\n        } catch (IllegalArgumentException ignored) {\n        }\n        AVAILABLE = available;\n    }\n\n    private NewSkins() {\n    }\n", "        try {\n            // added in 1.19.3\n            Material.valueOf(\"ENDER_DRAGON_SPAWN_EGG\");\n            available = true;\n        } catch (IllegalArgumentException ignored) {\n        }\n        AVAILABLE = available;\n    }\n\n    private NewSkins() {\n    }\n", "    public static boolean available() {\n        return AVAILABLE;\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/util/Faces.java", "chunked_list": ["package team.unnamed.creativefaces.util;\n\nimport team.unnamed.creativefaces.FacesPluginConfig;\nimport team.unnamed.creativefaces.PlayerFaceComponent;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;", "import java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.UUID;\n\npublic final class Faces {\n\n    public static final int FACE_HEIGHT = 8;\n    public static final int FACE_WIDTH = 8;\n\n    private static final String[] OLD_DEFAULT_SKINS = { \"old_steve\", \"old_alex\" };\n    private static final String[] DEFAULT_SKINS = { \"alex\", \"ari\", \"efe\", \"kai\", \"makena\", \"noor\", \"steve\", \"sunny\", \"zuri\" };\n\n    private static final PlayerFaceComponent[] OLD_DEFAULT_FACES_COLORS = new PlayerFaceComponent[OLD_DEFAULT_SKINS.length];\n    private static final PlayerFaceComponent[] DEFAULT_FACES_COLORS = new PlayerFaceComponent[DEFAULT_SKINS.length];\n\n    private Faces() {\n    }\n", "    public static final int FACE_WIDTH = 8;\n\n    private static final String[] OLD_DEFAULT_SKINS = { \"old_steve\", \"old_alex\" };\n    private static final String[] DEFAULT_SKINS = { \"alex\", \"ari\", \"efe\", \"kai\", \"makena\", \"noor\", \"steve\", \"sunny\", \"zuri\" };\n\n    private static final PlayerFaceComponent[] OLD_DEFAULT_FACES_COLORS = new PlayerFaceComponent[OLD_DEFAULT_SKINS.length];\n    private static final PlayerFaceComponent[] DEFAULT_FACES_COLORS = new PlayerFaceComponent[DEFAULT_SKINS.length];\n\n    private Faces() {\n    }\n", "    public static PlayerFaceComponent getDefaultFace(UUID playerId, boolean newSkins, FacesPluginConfig.Ref config) {\n        if (newSkins) {\n            // NEW DEFAULT SKINS\n            int index = getDefaultSkin(playerId);\n            PlayerFaceComponent face = DEFAULT_FACES_COLORS[index];\n            if (face == null) {\n                int[][] pixels = loadFace(DEFAULT_SKINS[index]);\n                face = PlayerFaceComponent.fromPixels(pixels, config);\n                DEFAULT_FACES_COLORS[index] = face;\n            }\n            return face;\n        } else {\n            // OLD DEFAULT SKINS\n            int index = getOldDefaultSkin(playerId);\n            PlayerFaceComponent face = OLD_DEFAULT_FACES_COLORS[index];", "            if (face == null) {\n                int[][] pixels = loadFace(OLD_DEFAULT_SKINS[index]);\n                face = PlayerFaceComponent.fromPixels(pixels, config);\n                OLD_DEFAULT_FACES_COLORS[index] = face;\n            }\n            return face;\n        }\n    }\n\n    private static int[][] loadFace(String skinName) {\n\n        URL faceUrl = Faces.class.getClassLoader().getResource(\"faces/\" + skinName + \".png\");\n", "        if (faceUrl == null) {\n            throw new IllegalStateException(\"No face data found for skin name: '\" + skinName + \"'\");\n        }\n\n        // load image\n        BufferedImage faceData;\n\n        try {\n            faceData = ImageIO.read(faceUrl);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Failed to read face data\", e);\n        }\n\n        int[][] colors = new int[FACE_HEIGHT][FACE_WIDTH];", "        for (int y = 0; y < FACE_HEIGHT; y++) {\n            for (int x = 0; x < FACE_WIDTH; x++) {\n                colors[y][x] = faceData.getRGB(x, y);\n            }\n        }\n\n        return colors;\n    }\n\n    // 1.19.3+: We have nine default skins (Steve, Alex and seven more skins)\n    private static int getDefaultSkin(UUID playerId) {\n        int len = DEFAULT_SKINS.length;\n        int type = Math.floorMod(playerId.hashCode(), len * 2);\n        // We can know if the skin model will be slim using the following code:\n        // boolean slim = type < len;\n        return type % len;\n    }\n\n    // Before 1.19.3: We only have two default skins (Steve & Alex)\n    private static int getOldDefaultSkin(UUID playerId) {\n        // even: Steve, odd: Alex\n        return playerId.hashCode() % 2;\n    }\n", "    public static String pixelsToBase64(int[][] pixels) {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        try (DataOutputStream base64Output = new DataOutputStream(Base64.getEncoder().wrap(output))) {\n            for (int y = 0; y < FACE_HEIGHT; y++) {\n                for (int x = 0; x < FACE_WIDTH; x++) {\n                    base64Output.writeInt(pixels[y][x]);\n                }\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return output.toString();\n    }\n", "    public static int[][] base64ToPixels(String base64String) {\n        ByteArrayInputStream input = new ByteArrayInputStream(base64String.getBytes(StandardCharsets.UTF_8));\n        int[][] pixels = new int[FACE_HEIGHT][FACE_HEIGHT];\n        try (DataInputStream base64Input = new DataInputStream(Base64.getDecoder().wrap(input))) {\n            for (int y = 0; y < FACE_HEIGHT; y++) {\n                for (int x = 0; x < FACE_WIDTH; x++) {\n                    int pixel = base64Input.readInt();\n                    pixels[y][x] = pixel;\n                }\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return pixels;\n    }\n\n}\n"]}
{"filename": "src/main/java/team/unnamed/creativefaces/listener/ResourcePackGenerateListener.java", "chunked_list": ["package team.unnamed.creativefaces.listener;\n\nimport net.kyori.adventure.key.Key;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.base.Writable;\nimport team.unnamed.creative.central.event.EventListener;\nimport team.unnamed.creative.central.event.pack.ResourcePackGenerateEvent;\nimport team.unnamed.creative.font.Font;\nimport team.unnamed.creative.font.FontProvider;\nimport team.unnamed.creative.texture.Texture;", "import team.unnamed.creative.font.FontProvider;\nimport team.unnamed.creative.texture.Texture;\nimport team.unnamed.creativefaces.FacesPluginConfig;\nimport team.unnamed.creativefaces.util.Faces;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ResourcePackGenerateListener implements EventListener<ResourcePackGenerateEvent> {\n\n    private final FacesPluginConfig.Ref config;\n\n    public ResourcePackGenerateListener(FacesPluginConfig.Ref config) {\n        this.config = config;\n    }\n\n    @Override", "public class ResourcePackGenerateListener implements EventListener<ResourcePackGenerateEvent> {\n\n    private final FacesPluginConfig.Ref config;\n\n    public ResourcePackGenerateListener(FacesPluginConfig.Ref config) {\n        this.config = config;\n    }\n\n    @Override\n    public void on(ResourcePackGenerateEvent event) {\n\n        FacesPluginConfig currentConfig = config.current();\n        FacesPluginConfig.Characters characters = currentConfig.characters();\n        ResourcePack resourcePack = event.resourcePack();\n\n        Font font = resourcePack.font(currentConfig.font());\n        List<FontProvider> fontProviders = font == null ? new ArrayList<>() : new ArrayList<>(font.providers());\n\n        Texture pixelTexture = Texture.builder()\n                .key(Key.key(currentConfig.namespace(), \"textures/font/_px\"))\n                .data(Writable.resource(getClass().getClassLoader(), \"pixel.png\"))\n                .build();\n\n        // write pixel texture\n        resourcePack.texture(pixelTexture);\n\n        // write pixel font providers", "    public void on(ResourcePackGenerateEvent event) {\n\n        FacesPluginConfig currentConfig = config.current();\n        FacesPluginConfig.Characters characters = currentConfig.characters();\n        ResourcePack resourcePack = event.resourcePack();\n\n        Font font = resourcePack.font(currentConfig.font());\n        List<FontProvider> fontProviders = font == null ? new ArrayList<>() : new ArrayList<>(font.providers());\n\n        Texture pixelTexture = Texture.builder()\n                .key(Key.key(currentConfig.namespace(), \"textures/font/_px\"))\n                .data(Writable.resource(getClass().getClassLoader(), \"pixel.png\"))\n                .build();\n\n        // write pixel texture\n        resourcePack.texture(pixelTexture);\n\n        // write pixel font providers", "        for (int height = 0; height < Faces.FACE_HEIGHT; height++) {\n            fontProviders.add(\n                    FontProvider.bitMap()\n                            .file(pixelTexture.key())\n                            .height(8)\n                            .ascent(Faces.FACE_HEIGHT - height - 1)\n                            .characters(characters.pixelsByHeight()[height])\n                            .build()\n            );\n        }\n\n        // write offset font provider\n        fontProviders.add(\n                FontProvider.space()\n                        .advance(characters.offsetMinusOne(), -1)\n                        .advance(characters.offsetMinusEight(), -8)\n                        .build()\n        );\n\n        resourcePack.font(Font.of(currentConfig.font(), fontProviders));\n    }\n\n}\n"]}
