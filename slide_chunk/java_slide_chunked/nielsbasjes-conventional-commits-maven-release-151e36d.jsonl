{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/ConventionalCommitsVersionPolicyTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\n\nclass ConventionalCommitsVersionPolicyTest extends AbstractNextVersionTest {", "\nclass ConventionalCommitsVersionPolicyTest extends AbstractNextVersionTest {\n\n    @Test\n    void testDefaultVersionRules() throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        String normal = \"Did something\";\n        String patch = \"fix(core): Another fix.\";\n        String minor = \"feat(core): New thingy.\";\n        String major = \"fix(core)!: Breaking improvement\";\n", "        String major = \"fix(core)!: Breaking improvement\";\n\n        String versionRulesConfig = \"\";\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", normal); // No Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", patch);  // No Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.2.0\", \"1.2.1-SNAPSHOT\", minor);  // No Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"2.0.0\", \"2.0.1-SNAPSHOT\", major);  // No Tag - Major Comments\n\n        // The default tag pattern will look at the \"2.3.4\" tag\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"2.3.5\", \"2.3.6-SNAPSHOT\", normal, \"2.3.4\", \"v3.4.5\"); // Tag - No CC Comments", "        // The default tag pattern will look at the \"2.3.4\" tag\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"2.3.5\", \"2.3.6-SNAPSHOT\", normal, \"2.3.4\", \"v3.4.5\"); // Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"2.3.5\", \"2.3.6-SNAPSHOT\", patch,  \"2.3.4\", \"v3.4.5\"); // Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"2.4.0\", \"2.4.1-SNAPSHOT\", minor,  \"2.3.4\", \"v3.4.5\"); // Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"3.0.0\", \"3.0.1-SNAPSHOT\", major,  \"2.3.4\", \"v3.4.5\"); // Tag - Major Comments\n\n        // Too many valid version tags on one commit\n        verifyNextVersionMustFail(versionRulesConfig, \"1.1.1-SNAPSHOT\", major, \"1.1.1\", \"2.2.2\");\n    }\n", "    }\n\n    @Test\n    void testCustomTagPattern() throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        String normal = \"Did something\";\n        String patch = \"fix(core): Another fix.\";\n        String minor = \"feat(core): New thingy.\";\n        String major = \"fix(core)!: Breaking improvement\";\n\n        String versionRulesConfig = \"\"", "\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + \"<versionTag>^v([0-9]+\\\\.[0-9]+\\\\.[0-9]+)$</versionTag>\"\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", normal); // No Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", patch);  // No Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.2.0\", \"1.2.1-SNAPSHOT\", minor);  // No Tag - Minor Comments", "        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", patch);  // No Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.2.0\", \"1.2.1-SNAPSHOT\", minor);  // No Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"2.0.0\", \"2.0.1-SNAPSHOT\", major);  // No Tag - Major Comments\n\n        // The custom tag pattern will look at the \"v3.4.5\" tag\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"3.4.6\", \"3.4.7-SNAPSHOT\", normal, \"2.3.4\", \"v3.4.5\"); // Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"3.4.6\", \"3.4.7-SNAPSHOT\", patch,  \"2.3.4\", \"v3.4.5\"); // Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"3.5.0\", \"3.5.1-SNAPSHOT\", minor,  \"2.3.4\", \"v3.4.5\"); // Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"4.0.0\", \"4.0.1-SNAPSHOT\", major,  \"2.3.4\", \"v3.4.5\"); // Tag - Major Comments\n", "        verifyNextVersion(versionRulesConfig, \"0.0.1-SNAPSHOT\", \"4.0.0\", \"4.0.1-SNAPSHOT\", major,  \"2.3.4\", \"v3.4.5\"); // Tag - Major Comments\n\n        // Too many valid version tags on one commit\n        verifyNextVersionMustFail(versionRulesConfig, \"1.1.1-SNAPSHOT\", minor, \"v1.1.1\", \"v2.2.2\");\n    }\n\n    @Test\n    void testCustomVersionRules() throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        String normal = \"This is a different commit.\";\n        String patch = \"This is a No Change commit.\";", "        String normal = \"This is a different commit.\";\n        String patch = \"This is a No Change commit.\";\n        String minor = \"This is a Nice Change commit.\";\n        String major = \"This is a Big Change commit.\";\n\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + \"  <versionTag>^The awesome ([0-9]+\\\\.[0-9]+\\\\.[0-9]+) release$</versionTag>\"\n            + \"  <majorRules>\"\n            + \"    <majorRule>^.*Big Change.*$</majorRule>\"", "            + \"  <majorRules>\"\n            + \"    <majorRule>^.*Big Change.*$</majorRule>\"\n            + \"  </majorRules>\"\n            + \"  <minorRules>\"\n            + \"    <minorRule>^.*Nice Change.*$</minorRule>\"\n            + \"  </minorRules>\"\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", normal); // No Tag - No CC Comments", "\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", normal); // No Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.1.1\", \"1.1.2-SNAPSHOT\", patch);  // No Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"1.2.0\", \"1.2.1-SNAPSHOT\", minor);  // No Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"2.0.0\", \"2.0.1-SNAPSHOT\", major);  // No Tag - Major Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"3.4.6\", \"3.4.7-SNAPSHOT\", normal, \"2.3.4\", \"The awesome 3.4.5 release\"); // Tag - No CC Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"3.4.6\", \"3.4.7-SNAPSHOT\", patch,  \"2.3.4\", \"The awesome 3.4.5 release\"); // Tag - Patch Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"3.5.0\", \"3.5.1-SNAPSHOT\", minor,  \"2.3.4\", \"The awesome 3.4.5 release\"); // Tag - Minor Comments\n        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"4.0.0\", \"4.0.1-SNAPSHOT\", major,  \"2.3.4\", \"The awesome 3.4.5 release\"); // Tag - Major Comments\n", "        verifyNextVersion(versionRulesConfig, \"1.1.1-SNAPSHOT\", \"4.0.0\", \"4.0.1-SNAPSHOT\", major,  \"2.3.4\", \"The awesome 3.4.5 release\"); // Tag - Major Comments\n\n        // Too many valid version tags on one commit\n        verifyNextVersionMustFail(versionRulesConfig, \"1.1.1-SNAPSHOT\", minor, \"The awesome 1.1.1 release\", \"The awesome 2.2.2 release\");\n    }\n\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/NextVersionSpecificationTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.semver.Version.Element.MAJOR;\nimport static org.semver.Version.Element.MINOR;\nimport static org.semver.Version.Element.PATCH;\n\nclass NextVersionSpecificationTest extends AbstractNextVersionTest {\n", "class NextVersionSpecificationTest extends AbstractNextVersionTest {\n\n    @Test\n    void testConventionalCommitsExamples() {\n        //Verifying the examples show on https://www.conventionalcommits.org/en/v1.0.0/#examples\n        VersionRules rules = DEFAULT_VERSION_RULES;\n\n        // Commit message with description and breaking change footer\n        assertNextVersion(\n            rules,", "        assertNextVersion(\n            rules,\n            \"feat: allow provided config object to extend other configs\\n\" +\n            \"\\n\" +\n            \"BREAKING CHANGE: `extends` key in config file is now used for extending other config files\\n\",\n            MAJOR);\n\n        // Commit message with `!` to draw attention to breaking change\n        assertNextVersion(\n            rules,", "        assertNextVersion(\n            rules,\n            \"feat!: send an email to the customer when a product is shipped\",\n            MAJOR);\n\n        // Commit message with scope and `!` to draw attention to breaking change\n        assertNextVersion(\n            rules,\n            \"feat(api)!: send an email to the customer when a product is shipped\",\n            MAJOR);", "            \"feat(api)!: send an email to the customer when a product is shipped\",\n            MAJOR);\n\n        // Commit message with both `!` and BREAKING CHANGE footer\n        assertNextVersion(\n            rules,\n            \"chore!: drop support for Node 6\\n\" +\n            \"\\n\" +\n            \"BREAKING CHANGE: use JavaScript features not available in Node 6.\\n\",\n            MAJOR);", "            \"BREAKING CHANGE: use JavaScript features not available in Node 6.\\n\",\n            MAJOR);\n\n        // Commit message with no body\n        assertNextVersion(\n            rules,\n            \"docs: correct spelling of CHANGELOG\",\n            PATCH);\n\n        // Commit message with scope", "\n        // Commit message with scope\n        assertNextVersion(\n            rules,\n            \"feat(lang): add Polish language\",\n            MINOR);\n\n        // Commit message with multi-paragraph body and multiple footers\n        assertNextVersion(\n            rules,", "        assertNextVersion(\n            rules,\n            \"fix: prevent racing of requests\\n\" +\n            \"\\n\" +\n            \"Introduce a request id and a reference to latest request. Dismiss\\n\" +\n            \"incoming responses other than from latest request.\\n\" +\n            \"\\n\" +\n            \"    Remove timeouts which were used to mitigate the racing issue but are\\n\" +\n            \"obsolete now.\\n\" +\n            \"\\n\" +", "            \"obsolete now.\\n\" +\n            \"\\n\" +\n            \"Reviewed-by: Z\\n\" +\n            \"Refs: #123\\n\",\n            PATCH);\n    }\n\n\n}\n", "}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/ConventionalCommitsVersionConfigTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass ConventionalCommitsVersionConfigTest {", "\nclass ConventionalCommitsVersionConfigTest {\n\n    String versionRulesConfig = \"\"\n        + \"<projectVersionPolicyConfig>\"\n        + \"  <minorRules>\"\n        + \"    <minorRule>Minor One</minorRule>\"\n        + \"    <minorRule>Minor Two</minorRule>\"\n        + \"    <minorRule>Minor Three</minorRule>\"\n        + \"  </minorRules>\"", "        + \"    <minorRule>Minor Three</minorRule>\"\n        + \"  </minorRules>\"\n        + \"  <majorRules>\"\n        + \"    <majorRule>Major One</majorRule>\"\n        + \"    <majorRule>Major Two</majorRule>\"\n        + \"    <majorRule>Major Three</majorRule>\"\n        + \"  </majorRules>\"\n        + \"  <versionTag>My Version Tag</versionTag>\"\n        + \"</projectVersionPolicyConfig>\";\n", "        + \"</projectVersionPolicyConfig>\";\n\n    @Test\n    void readXMLTest() {\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        assertEquals(\"My Version Tag\", config.getVersionTag());\n        assertEquals(Arrays.asList(\"Minor One\", \"Minor Two\", \"Minor Three\"), config.getMinorRules());\n        assertEquals(Arrays.asList(\"Major One\", \"Major Two\", \"Major Three\"), config.getMajorRules());\n    }\n", "    }\n\n    @Test\n    void createAndSerdeLoopTest() throws JsonProcessingException {\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        ConventionalCommitsVersionConfig config1 = new ConventionalCommitsVersionConfig();\n\n        config1.setVersionTag(\"My Version Tag\")\n            .addMinorRule(\"Minor One\")\n            .addMinorRule(\"Minor Two\")", "            .addMinorRule(\"Minor One\")\n            .addMinorRule(\"Minor Two\")\n            .addMinorRule(\"Minor Three\")\n            .addMajorRule(\"Major One\")\n            .addMajorRule(\"Major Two\")\n            .addMajorRule(\"Major Three\");\n\n        assertEquals(config.toString(), config1.toString());\n\n        String configXml = config1.toXml();", "\n        String configXml = config1.toXml();\n\n        ConventionalCommitsVersionConfig config2 = ConventionalCommitsVersionConfig.fromXml(configXml);\n\n        assertEquals(config1.toString(), config2.toString());\n    }\n}\n", ""]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/ConfigParsingTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage nl.basjes.maven.release.version.conventionalcommits;", "\npackage nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.regex.Pattern;", "import java.util.List;\nimport java.util.regex.Pattern;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass ConfigParsingTest {\n", "class ConfigParsingTest {\n\n    private static final Logger LOG = LogManager.getLogger();\n\n    private final VersionRules defaultVersionRules = new VersionRules(null);\n\n    private final String customVersionTagRegex = \"^The awesome ([0-9]+\\\\.[0-9]+\\\\.[0-9]+) release$\";\n    private final String customMajorRulesRegex = \"^.*Big Change.*$\";\n    private final String customMinorRulesRegex = \"^.*Nice Change.*$\";\n", "    private final String customMinorRulesRegex = \"^.*Nice Change.*$\";\n\n    private final String customVersionTagXML = \"<versionTag>\"+ customVersionTagRegex +\"</versionTag>\";\n    private final String customMajorRulesXML = \"<majorRules><majorRule>\"+ customMajorRulesRegex +\"</majorRule></majorRules>\";\n    private final String customMinorRulesXML = \"<minorRules><minorRule>\"+ customMinorRulesRegex +\"</minorRule></minorRules>\";\n\n    private final int patternFlags = Pattern.MULTILINE | Pattern.DOTALL | Pattern.UNIX_LINES;\n\n    private final Pattern customVersionTagPattern =\n        Pattern.compile(customVersionTagRegex, patternFlags);", "    private final Pattern customVersionTagPattern =\n        Pattern.compile(customVersionTagRegex, patternFlags);\n    private final List<Pattern> customMajorRulesPatterns =\n        Collections.singletonList(Pattern.compile(customMajorRulesRegex, patternFlags));\n    private final List<Pattern> customMinorRulesPatterns =\n        Collections.singletonList(Pattern.compile(customMinorRulesRegex, patternFlags));\n\n    private void assertTagPatternIsDefault(VersionRules versionRules) {\n        assertEquals(defaultVersionRules.getTagPattern().toString(), versionRules.getTagPattern().toString());\n    }", "        assertEquals(defaultVersionRules.getTagPattern().toString(), versionRules.getTagPattern().toString());\n    }\n\n    private void assertTagPatternIsCustom(VersionRules versionRules) {\n        assertEquals(customVersionTagPattern.toString(), versionRules.getTagPattern().toString());\n    }\n\n    private void assertMajorIsDefault(VersionRules versionRules) {\n        assertEquals(\n            defaultVersionRules.getMajorUpdatePatterns().toString(),", "        assertEquals(\n            defaultVersionRules.getMajorUpdatePatterns().toString(),\n            versionRules.getMajorUpdatePatterns().toString()\n        );\n    }\n\n    private void assertMajorIsCustom(VersionRules versionRules) {\n        assertEquals(\n            customMajorRulesPatterns.toString(),\n            versionRules.getMajorUpdatePatterns().toString()", "            customMajorRulesPatterns.toString(),\n            versionRules.getMajorUpdatePatterns().toString()\n        );\n    }\n\n    private void assertMajorIsEmpty(VersionRules versionRules) {\n        assertTrue(versionRules.getMajorUpdatePatterns().isEmpty());\n    }\n\n", "\n\n    private void assertMinorIsDefault(VersionRules versionRules) {\n        assertEquals(\n            defaultVersionRules.getMinorUpdatePatterns().toString(),\n            versionRules.getMinorUpdatePatterns().toString()\n        );\n    }\n\n    private void assertMinorIsCustom(VersionRules versionRules) {", "\n    private void assertMinorIsCustom(VersionRules versionRules) {\n        assertEquals(\n            customMinorRulesPatterns.toString(),\n            versionRules.getMinorUpdatePatterns().toString()\n        );\n    }\n\n    private void assertMinorIsEmpty(VersionRules versionRules) {\n        assertTrue(versionRules.getMinorUpdatePatterns().isEmpty());", "    private void assertMinorIsEmpty(VersionRules versionRules) {\n        assertTrue(versionRules.getMinorUpdatePatterns().isEmpty());\n    }\n\n    // ====================================================\n\n    @Test\n    void testVersionRulesToString() {\n        String string = defaultVersionRules.toString();\n        assertTrue(string.contains(\"Conventional Commits config:\"));", "        String string = defaultVersionRules.toString();\n        assertTrue(string.contains(\"Conventional Commits config:\"));\n    }\n\n    @Test\n    void testParseNull() {\n        assertNull(ConventionalCommitsVersionConfig.fromXml(null));\n    }\n\n    @Test", "\n    @Test\n    void testParseReallyEmpty() {\n        assertNull(ConventionalCommitsVersionConfig.fromXml(\"\"));\n    }\n\n    @Test\n    void testParseEmptyValid() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"", "        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertNull(config.getVersionTag());\n        assertEquals(0, config.getMajorRules().size());", "        assertNull(config.getVersionTag());\n        assertEquals(0, config.getMajorRules().size());\n        assertEquals(0, config.getMinorRules().size());\n\n        VersionRules versionRules = new VersionRules(config);\n\n        assertTagPatternIsDefault(versionRules);\n        assertMajorIsDefault(versionRules);\n        assertMinorIsDefault(versionRules);\n    }", "        assertMinorIsDefault(versionRules);\n    }\n\n    @Test\n    void testParseValidTag() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customVersionTagXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";", "            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertEquals(customVersionTagRegex, config.getVersionTag());\n        assertEquals(0, config.getMajorRules().size());\n        assertEquals(0, config.getMinorRules().size());\n", "        assertEquals(0, config.getMinorRules().size());\n\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsCustom(versionRules);\n        assertMajorIsDefault(versionRules);\n        assertMinorIsDefault(versionRules);\n    }\n\n    @Test\n    void testParseValidTagMinor() {", "    @Test\n    void testParseValidTagMinor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customVersionTagXML\n            + customMinorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);", "\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertEquals(customVersionTagRegex, config.getVersionTag());\n        assertEquals(0, config.getMajorRules().size());\n        assertEquals(1, config.getMinorRules().size());\n        assertEquals(customMinorRulesRegex, config.getMinorRules().get(0));\n\n        VersionRules versionRules = new VersionRules(config);", "\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsCustom(versionRules);\n        assertMajorIsEmpty(versionRules);\n        assertMinorIsCustom(versionRules);\n    }\n\n    @Test\n    void testParseValidTagMajor() {\n        String versionRulesConfig = \"\"", "    void testParseValidTagMajor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customVersionTagXML\n            + customMajorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);", "        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertEquals(customVersionTagRegex, config.getVersionTag());\n        assertEquals(1, config.getMajorRules().size());\n        assertEquals(customMajorRulesRegex, config.getMajorRules().get(0));\n        assertEquals(0, config.getMinorRules().size());\n\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsCustom(versionRules);", "        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsCustom(versionRules);\n        assertMajorIsCustom(versionRules);\n        assertMinorIsEmpty(versionRules);\n    }\n\n    @Test\n    void testParseValidTagMinorMajor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"", "        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customVersionTagXML\n            + customMajorRulesXML\n            + customMinorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);", "        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertEquals(customVersionTagRegex, config.getVersionTag());\n        assertEquals(1, config.getMajorRules().size());\n        assertEquals(customMajorRulesRegex, config.getMajorRules().get(0));\n        assertEquals(1, config.getMinorRules().size());\n        assertEquals(customMinorRulesRegex, config.getMinorRules().get(0));\n\n        VersionRules versionRules = new VersionRules(config);", "\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsCustom(versionRules);\n        assertMajorIsCustom(versionRules);\n        assertMinorIsCustom(versionRules);\n    }\n\n    @Test\n    void testParseValidMinor() {\n        String versionRulesConfig = \"\"", "    void testParseValidMinor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customMinorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n", "        LOG.info(\"Tested config: {}\", config);\n\n        assertNull(config.getVersionTag());\n        assertEquals(0, config.getMajorRules().size());\n        assertEquals(1, config.getMinorRules().size());\n        assertEquals(customMinorRulesRegex, config.getMinorRules().get(0));\n\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsDefault(versionRules);\n        assertMajorIsEmpty(versionRules);", "        assertTagPatternIsDefault(versionRules);\n        assertMajorIsEmpty(versionRules);\n        assertMinorIsCustom(versionRules);\n    }\n\n    @Test\n    void testParseValidMajor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customMajorRulesXML", "            + \"<projectVersionPolicyConfig>\"\n            + customMajorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertNull(config.getVersionTag());\n        assertEquals(1, config.getMajorRules().size());", "        assertNull(config.getVersionTag());\n        assertEquals(1, config.getMajorRules().size());\n        assertEquals(customMajorRulesRegex, config.getMajorRules().get(0));\n        assertEquals(0, config.getMinorRules().size());\n\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsDefault(versionRules);\n        assertMajorIsCustom(versionRules);\n        assertMinorIsEmpty(versionRules);\n    }", "        assertMinorIsEmpty(versionRules);\n    }\n\n    @Test\n    void testParseValidMinorMajor() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            + customMajorRulesXML\n            + customMinorRulesXML\n            + \"</projectVersionPolicyConfig>\" +", "            + customMinorRulesXML\n            + \"</projectVersionPolicyConfig>\" +\n            \"\";\n\n        ConventionalCommitsVersionConfig config = ConventionalCommitsVersionConfig.fromXml(versionRulesConfig);\n        LOG.info(\"Tested config: {}\", config);\n\n        assertNull(config.getVersionTag());\n        assertEquals(1, config.getMajorRules().size());\n        assertEquals(customMajorRulesRegex, config.getMajorRules().get(0));", "        assertEquals(1, config.getMajorRules().size());\n        assertEquals(customMajorRulesRegex, config.getMajorRules().get(0));\n        assertEquals(1, config.getMinorRules().size());\n        assertEquals(customMinorRulesRegex, config.getMinorRules().get(0));\n\n        VersionRules versionRules = new VersionRules(config);\n        assertTagPatternIsDefault(versionRules);\n        assertMajorIsCustom(versionRules);\n        assertMinorIsCustom(versionRules);\n    }", "        assertMinorIsCustom(versionRules);\n    }\n\n    @Test\n    void testParseBadXmlUnknownTags() {\n        String versionRulesConfig = \"\"\n            + \"<Something><Unexpected></Unexpected></Something>\";\n\n        assertThrows(ConventionalCommitsConfigException.class, () ->\n            ConventionalCommitsVersionConfig.fromXml(versionRulesConfig));", "        assertThrows(ConventionalCommitsConfigException.class, () ->\n            ConventionalCommitsVersionConfig.fromXml(versionRulesConfig));\n    }\n\n    @Test\n    void testParseBadXmlUnbalanced() {\n        String versionRulesConfig = \"\"\n            + \"<projectVersionPolicyConfig>\"\n            // Unbalanced XML tag\n            + \"  <versionTag>^The awesome ([0-9]+\\\\.[0-9]+\\\\.[0-9]+) release$\";", "            // Unbalanced XML tag\n            + \"  <versionTag>^The awesome ([0-9]+\\\\.[0-9]+\\\\.[0-9]+) release$\";\n\n        assertThrows(ConventionalCommitsConfigException.class, () ->\n            ConventionalCommitsVersionConfig.fromXml(versionRulesConfig));\n    }\n\n    @Test\n    void testVersionRulesIgnoreNullTag(){\n        ConventionalCommitsVersionConfig config = new ConventionalCommitsVersionConfig();", "    void testVersionRulesIgnoreNullTag(){\n        ConventionalCommitsVersionConfig config = new ConventionalCommitsVersionConfig();\n        config.setVersionTag(null);\n        VersionRules versionRules = new VersionRules(config);\n        assertEquals(\n            defaultVersionRules.getTagPattern().toString(),\n            versionRules.getTagPattern().toString());\n    }\n\n    @Test", "\n    @Test\n    void testVersionRulesIgnoreBlankTag(){\n        ConventionalCommitsVersionConfig config = new ConventionalCommitsVersionConfig();\n        config.setVersionTag(\"       \");\n        VersionRules versionRules = new VersionRules(config);\n        assertEquals(\n            defaultVersionRules.getTagPattern().toString(),\n            versionRules.getTagPattern().toString());\n    }", "            versionRules.getTagPattern().toString());\n    }\n\n\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/AbstractNextVersionTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport nl.basjes.maven.release.version.conventionalcommits.mockscm.MockScmProvider;\nimport nl.basjes.maven.release.version.conventionalcommits.mockscm.MockScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.policy.version.VersionPolicy;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.semver.Version;", "import org.apache.maven.shared.release.versions.VersionParseException;\nimport org.semver.Version;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\npublic abstract class AbstractNextVersionTest {\n\n    public static final VersionRules DEFAULT_VERSION_RULES = new VersionRules(null);\n\n    public void assertNextVersion(VersionRules versionRules, String input, Version.Element element) {\n        switch (element) {\n            case MAJOR:\n                assertTrue(versionRules.isMajorUpdate(input));\n                // We do not care about minor and patch\n                break;\n            case MINOR:\n                assertFalse(versionRules.isMajorUpdate(input));\n                assertTrue(versionRules.isMinorUpdate(input));\n                // We do not care about patch\n                break;\n            case PATCH:\n                assertFalse(versionRules.isMajorUpdate(input));\n                assertFalse(versionRules.isMinorUpdate(input));\n                break;\n            default:\n                fail(\"Unsupported element type:\" + element);\n        }\n    }\n", "    public void assertNextVersion(VersionRules versionRules, String input, Version.Element element) {\n        switch (element) {\n            case MAJOR:\n                assertTrue(versionRules.isMajorUpdate(input));\n                // We do not care about minor and patch\n                break;\n            case MINOR:\n                assertFalse(versionRules.isMajorUpdate(input));\n                assertTrue(versionRules.isMinorUpdate(input));\n                // We do not care about patch\n                break;\n            case PATCH:\n                assertFalse(versionRules.isMajorUpdate(input));\n                assertFalse(versionRules.isMinorUpdate(input));\n                break;\n            default:\n                fail(\"Unsupported element type:\" + element);\n        }\n    }\n", "    public void verifyNextVersion(String configXml,\n                                  String currentPomVersion,\n                                  String expectedReleaseVersion,\n                                  String expectedDevelopmentVersion,\n                                  String comment,\n                                  String... tags) throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        verifyNextVersion(currentPomVersion,\n            singletonList(comment),\n            Arrays.asList(tags),\n            configXml,\n            expectedReleaseVersion,\n            expectedDevelopmentVersion);\n    }\n", "    public void verifyNextVersion(String currentPomVersion,\n                                  List<String> comments,\n                                  String tag,\n                                  String expectedReleaseVersion) throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        verifyNextVersion(currentPomVersion,\n            comments,\n            singletonList(tag),\n            \"\", // Default config\n            expectedReleaseVersion,\n            null);\n    }", "    public void verifyNextVersion(String currentPomVersion,\n                                  List<String> comments,\n                                  List<String> tags,\n                                  String configXml,\n                                  String expectedReleaseVersion,\n                                  String expectedDevelopmentVersion) throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(currentPomVersion);\n\n        request.setWorkingDirectory(\"/tmp\");\n\n        MockScmProvider scmProvider = new MockScmProvider(comments, tags);\n        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));\n\n        request.setConfig(configXml);\n\n        VersionPolicy versionPolicy = new ConventionalCommitsVersionPolicy();\n\n        String suggestedVersion = versionPolicy.getReleaseVersion(request).getVersion();\n        assertEquals(expectedReleaseVersion, suggestedVersion);\n", "        if (expectedDevelopmentVersion != null) {\n            request.setVersion(suggestedVersion);\n            String suggestedDevelopmentVersion = versionPolicy.getDevelopmentVersion(request).getVersion();\n            assertEquals(expectedDevelopmentVersion, suggestedDevelopmentVersion);\n        }\n\n    }\n\n    public void verifyNextVersionMustFail(\n        String versionRulesConfig,\n        String pomVersion,\n        String comments,\n        String... tags\n    ) throws PolicyException, IOException, ScmRepositoryException {", "    public void verifyNextVersionMustFail(\n        String versionRulesConfig,\n        String pomVersion,\n        String comments,\n        String... tags\n    ) throws PolicyException, IOException, ScmRepositoryException {\n        try {\n            verifyNextVersion(\n                pomVersion,\n                singletonList(comments),\n                Arrays.asList(tags),\n                versionRulesConfig,\n                \"ignore\",\n                \"ignore\");\n        } catch (VersionParseException vpe) {\n            // Success !\n            return;\n        }\n        fail(\"Should have failed\");\n    }\n\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/EdgeCasesTests.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage nl.basjes.maven.release.version.conventionalcommits;", "\npackage nl.basjes.maven.release.version.conventionalcommits;\n\nimport nl.basjes.maven.release.version.conventionalcommits.mockscm.MockScmRepository;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.provider.git.gitexe.GitExeScmProvider;\nimport org.apache.maven.scm.provider.git.util.GitUtil;\nimport org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.policy.version.VersionPolicy;", "import org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.policy.version.VersionPolicy;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass EdgeCasesTests {", "\nclass EdgeCasesTests {\n\n    @Test\n    void noScmPresent() throws ScmException, VersionParseException, PolicyException {\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(\"1.2.3-SNAPSHOT\");\n        request.setWorkingDirectory(\"/tmp\");\n        ScmProvider scmProvider = new GitExeScmProvider();\n        GitUtil.getSettings().setGitCommand(\"false\");", "        ScmProvider scmProvider = new GitExeScmProvider();\n        GitUtil.getSettings().setGitCommand(\"false\");\n\n        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));\n\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));\n        assertTrue(commitHistory.getChanges().isEmpty());\n\n        VersionPolicy versionPolicy = new ConventionalCommitsVersionPolicy();", "\n        VersionPolicy versionPolicy = new ConventionalCommitsVersionPolicy();\n\n        String suggestedVersion = versionPolicy.getReleaseVersion(request).getVersion();\n        assertEquals(\"1.2.3\", suggestedVersion);\n    }\n\n}\n", ""]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/NextVersionCalculationTest.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.maven.scm.repository.ScmRepositoryException;\nimport org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n", "import org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.semver.Version.Element.MAJOR;\nimport static org.semver.Version.Element.MINOR;\nimport static org.semver.Version.Element.PATCH;\n\npublic class NextVersionCalculationTest extends AbstractNextVersionTest {\n\n    private static ConventionalCommitsVersionPolicy versionPolicy;\n\n    @BeforeAll", "    public static void setUp() {\n        versionPolicy = new ConventionalCommitsVersionPolicy();\n    }\n\n    @AfterAll\n    public static void tearDown() {\n        versionPolicy = null;\n    }\n\n    @Test\n    void testMajorMinorPatchDetection() {\n        VersionRules rules = DEFAULT_VERSION_RULES;\n        // Major\n        assertNextVersion(rules, \"feat(core)!: New feature.\", MAJOR);\n        assertNextVersion(rules, \"feat!: New feature.\", MAJOR);\n        assertNextVersion(rules, \"feat(core): Foo.\\n\\nBREAKING CHANGE: New feature.\\n\", MAJOR);\n        assertNextVersion(rules, \"feat: Foo.\\n\\nBREAKING CHANGE: New feature.\\n\", MAJOR);\n\n        // Minor\n        assertNextVersion(rules, \"feat(core): New feature.\", MINOR);\n        assertNextVersion(rules, \"feat: New feature.\", MINOR);\n\n        // Patch\n        assertNextVersion(rules, \"Does not match any pattern.\", PATCH);\n    }\n\n    @Test\n    void testConvertToSnapshot()\n        throws Exception {\n        String suggestedVersion = versionPolicy.getDevelopmentVersion(new VersionPolicyRequest().setVersion(\"1.0.0\"))\n            .getVersion();\n\n        assertEquals(\"1.0.1-SNAPSHOT\", suggestedVersion);\n    }\n\n    @Test\n    void testConvertToSnapshotBadVersion() {\n        assertThrows(VersionParseException.class, () ->\n            versionPolicy.getDevelopmentVersion(new VersionPolicyRequest().setVersion(\"Really Bad\"))\n        );\n    }\n\n    private static final String PATCH_1 = \"Quick patch\";\n    private static final String PATCH_2 = \"fix(core): Another fix.\";\n    private static final String MINOR_1 = \"feat(core): New thingy.\";\n    private static final String MAJOR_1 = \"fix(core)!: Breaking improvement\";\n\n    private static final List<String> EMPTY = Collections.emptyList();\n    private static final List<String> MAJOR_MESSAGES = Arrays.asList(PATCH_1, PATCH_2, MINOR_1, MAJOR_1);\n    private static final List<String> MINOR_MESSAGES = Arrays.asList(PATCH_1, PATCH_2, MINOR_1);\n    private static final List<String> PATCH_MESSAGES = Arrays.asList(PATCH_1, PATCH_2);\n\n    @Test\n    void testDefaultVersionRules() throws VersionParseException, PolicyException, IOException, ScmRepositoryException {\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", EMPTY,          \"\",      \"1.2.3\"); // No Tag - No CC Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", PATCH_MESSAGES, \"\",      \"1.2.3\"); // No Tag - Patch Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", MINOR_MESSAGES, \"\",      \"1.3.0\"); // No Tag - Minor Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", MAJOR_MESSAGES, \"\",      \"2.0.0\"); // No Tag - Major Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", EMPTY,          \"2.3.4\", \"2.3.5\"); // Tag - No CC Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", PATCH_MESSAGES, \"2.3.4\", \"2.3.5\"); // Tag - Patch Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", MINOR_MESSAGES, \"2.3.4\", \"2.4.0\"); // Tag - Minor Comments\n        verifyNextVersion(\"1.2.3-SNAPSHOT\", MAJOR_MESSAGES, \"2.3.4\", \"3.0.0\"); // Tag - Major Comments\n    }\n\n    @Test\n    void testInvalidPomVersion() {\n        assertThrows(VersionParseException.class, () ->\n            verifyNextVersion(\"Bad\", Collections.singletonList(\"Nothing\"), \"Unmatched value\", \"Should fail\")\n        );\n    }\n\n    @Test\n    void testInvalidTagVersion() {\n        assertThrows(VersionParseException.class, () ->\n            verifyNextVersion(\"1.2.3\",\n                Collections.singletonList(\"Nothing\"),\n                singletonList(\"Bad\"),\n                \"<projectVersionPolicyConfig>\\n\" +\n                \"  <versionTag>^(Bad)$</versionTag>\\n\" +\n                \"</projectVersionPolicyConfig>\",\n                \"Should fail\",\n                null)\n        );\n    }\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/CommitHistoryTests.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage nl.basjes.maven.release.version.conventionalcommits;", "\npackage nl.basjes.maven.release.version.conventionalcommits;\n\nimport nl.basjes.maven.release.version.conventionalcommits.mockscm.MockScmProvider;\nimport nl.basjes.maven.release.version.conventionalcommits.mockscm.MockScmRepository;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;", "import org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n", "import static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass CommitHistoryTests {\n\n    private static final Logger LOG = LogManager.getLogger();\n\n    private ScmProvider createScmProvider() {\n        List<String> comments = new ArrayList<>();\n        comments.add(\"One\");\n        comments.add(\"Two\");", "        comments.add(\"One\");\n        comments.add(\"Two\");\n\n        List<String> tags = new ArrayList<>();\n        tags.add(\"My Tag 1\");\n        return new MockScmProvider(comments, tags);\n    }\n\n    @Test\n    void checkCustomHistory() throws ScmException, VersionParseException {", "    @Test\n    void checkCustomHistory() throws ScmException, VersionParseException {\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(\"1.2.3\");\n\n        request.setWorkingDirectory(\"/tmp\");\n\n        ScmProvider scmProvider = createScmProvider();\n        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));", "        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));\n\n        String commitHistoryString = commitHistory.toString();\n        assertTrue(commitHistoryString.contains(\"Comment: \\\"One\\\"\"));\n        assertTrue(commitHistoryString.contains(\"Comment: \\\"Two\\\"\"));\n        assertTrue(commitHistoryString.contains(\"Tags   : [My Tag 1]\"));\n        LOG.info(\"Commit history: {}\", commitHistoryString);\n    }", "        LOG.info(\"Commit history: {}\", commitHistoryString);\n    }\n\n    @Test\n    void badRequestNoWorkingDirectory() throws ScmException, VersionParseException {\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(\"1.2.3\");\n//        request.setWorkingDirectory(\"/tmp\");\n        ScmProvider scmProvider = createScmProvider();\n        request.setScmProvider(scmProvider);", "        ScmProvider scmProvider = createScmProvider();\n        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));\n\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));\n        assertTrue(commitHistory.getChanges().isEmpty());\n    }\n\n    @Test\n    void badRequestNoScmProvider() throws ScmException, VersionParseException {", "    @Test\n    void badRequestNoScmProvider() throws ScmException, VersionParseException {\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(\"1.2.3\");\n        request.setWorkingDirectory(\"/tmp\");\n        ScmProvider scmProvider = createScmProvider();\n//        request.setScmProvider(scmProvider);\n        request.setScmRepository(new MockScmRepository(scmProvider));\n\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));", "\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));\n        assertTrue(commitHistory.getChanges().isEmpty());\n    }\n\n    @Test\n    void badRequestNoScmRepository() throws ScmException, VersionParseException {\n        VersionPolicyRequest request = new VersionPolicyRequest();\n        request.setVersion(\"1.2.3\");\n        request.setWorkingDirectory(\"/tmp\");", "        request.setVersion(\"1.2.3\");\n        request.setWorkingDirectory(\"/tmp\");\n        ScmProvider scmProvider = createScmProvider();\n        request.setScmProvider(scmProvider);\n//        request.setScmRepository(new MockScmRepository(scmProvider));\n\n        CommitHistory commitHistory = new CommitHistory(request, new VersionRules(null));\n        assertTrue(commitHistory.getChanges().isEmpty());\n    }\n", "    }\n\n\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/mockscm/MockScmRepository.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits.mockscm;\n", "package nl.basjes.maven.release.version.conventionalcommits.mockscm;\n\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\npublic class MockScmRepository extends ScmRepository {\n    public MockScmRepository(ScmProvider provider) throws ScmRepositoryException {\n        super(\"dummy\", provider.makeProviderScmRepository(\"dummy\", ':'));\n    }\n}\n"]}
{"filename": "src/test/java/nl/basjes/maven/release/version/conventionalcommits/mockscm/MockScmProvider.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits.mockscm;\n", "package nl.basjes.maven.release.version.conventionalcommits.mockscm;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;", "import org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class MockScmProvider\n    extends AbstractScmProvider {\n    List<ChangeSet> configuredChangeSets;\n\n    public MockScmProvider(List<String> comments, List<String> tags) {\n        configuredChangeSets = comments.stream().map(this::changeSet).collect(Collectors.toList());\n        configuredChangeSets.add(changeSet(\"Commit for tags\", tags));\n    }\n\n    @Override", "\npublic class MockScmProvider\n    extends AbstractScmProvider {\n    List<ChangeSet> configuredChangeSets;\n\n    public MockScmProvider(List<String> comments, List<String> tags) {\n        configuredChangeSets = comments.stream().map(this::changeSet).collect(Collectors.toList());\n        configuredChangeSets.add(changeSet(\"Commit for tags\", tags));\n    }\n\n    @Override", "    public String getScmType() {\n        return \"dummy\";\n    }\n\n    @Override\n    public ScmProviderRepository makeProviderScmRepository(String scmSpecificUrl, char delimiter) {\n        ScmProviderRepository repository = new ScmProviderRepository() {\n        };\n        repository.setUser(\"someone\");\n        repository.setPassword(\"secret\");\n        repository.setPushChanges(false);\n        return repository;\n    }\n\n    private ChangeSet changeSet(String newComment, String... newTags) {\n        return changeSet(newComment, Arrays.asList(newTags));\n    }\n\n    private ChangeSet changeSet(String newComment, List<String> newTags) {\n        ChangeSet changeSet = new ChangeSet();\n        changeSet.setComment(newComment);\n        changeSet.setAuthor(\"Niels Basjes <niels@basjes.nl>\");\n", "        if (!newTags.isEmpty()) {\n            List<String> tags = new ArrayList<>();\n            for (String newTag : newTags) {\n                if (newTag != null && !newTag.trim().isEmpty()) {\n                    tags.add(newTag);\n                }\n            }\n            if (!tags.isEmpty()) {\n                changeSet.setTags(tags);\n            }\n        }\n        return changeSet;\n    }\n\n    @Override", "    public ChangeLogScmResult changeLog(ChangeLogScmRequest request) throws ScmException {\n        Date from = new Date(39817800000L);\n        Date to   = new Date(1233451620000L);\n\n        List<ChangeSet> fullChangeSetList = new ArrayList<>();\n\n        int tagId = 1;\n\n        for (int i = 0; i < 150; i++) {\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit without tags\"));", "        for (int i = 0; i < 150; i++) {\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit without tags\"));\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit with tags\", \"Dummy tag \" + tagId++, \"Dummy tag \" + tagId++));\n        }\n", "        for (ChangeSet configuredChangeSet : configuredChangeSets) {\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit without tags\"));\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(configuredChangeSet);\n            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit with tags\", \"Dummy tag \"+ tagId++, \"Dummy tag \"+ tagId++));\n        }\n\n        ChangeLogSet changeLogSet = new ChangeLogSet(fullChangeSetList, from, to);\n\n        ScmResult scmResult = new ScmResult(\n            \"No command\",\n            \"Special for CCVersionPolicy testing\",\n            \"No command output\",\n            true\n        );\n        return new ChangeLogScmResult(changeLogSet, scmResult);\n    }\n}\n", "            if (fullChangeSetList.size() >= request.getLimit()) {\n                break;\n            }\n            fullChangeSetList.add(changeSet(\"Dummy Commit with tags\", \"Dummy tag \"+ tagId++, \"Dummy tag \"+ tagId++));\n        }\n\n        ChangeLogSet changeLogSet = new ChangeLogSet(fullChangeSetList, from, to);\n\n        ScmResult scmResult = new ScmResult(\n            \"No command\",\n            \"Special for CCVersionPolicy testing\",\n            \"No command output\",\n            true\n        );\n        return new ChangeLogScmResult(changeLogSet, scmResult);\n    }\n}\n"]}
{"filename": "src/it/setup/maven-scm-provider-dummy/src/main/java/org/apache/maven/scm/provider/dummy/DummyScmProvider.java", "chunked_list": ["package org.apache.maven.scm.provider.dummy;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0", " *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */", " * under the License.\n */\n\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;", "import org.apache.maven.scm.provider.ScmProviderRepository;\nimport org.apache.maven.scm.repository.ScmRepositoryException;\n\n/**\n * A dummy SCM provider used to bypass the {@code ScmCheckModificationsPhase} of the Release Plugin when doing a dry run\n * for integration testing.\n *\n * @author Benjamin Bentmann\n */\n@Singleton", " */\n@Singleton\n@Named( \"dummy\" )\npublic class DummyScmProvider\n    extends AbstractScmProvider\n{\n\n    public String getScmType()\n    {\n        return \"dummy\";\n    }\n", "    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n        return new DummyScmProviderRepository();\n    }\n\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        return new StatusScmResult( \"\", \"\", \"\", true );\n    }\n\n}\n"]}
{"filename": "src/it/setup/maven-scm-provider-dummy/src/main/java/org/apache/maven/scm/provider/dummy/DummyScmProviderRepository.java", "chunked_list": ["package org.apache.maven.scm.provider.dummy;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\n/**\n * A dummy SCM repository used to bypass the {@code ScmCheckModificationsPhase} of the Release Plugin when doing a dry\n * run for integration testing.", " * A dummy SCM repository used to bypass the {@code ScmCheckModificationsPhase} of the Release Plugin when doing a dry\n * run for integration testing.\n * \n * @author Benjamin Bentmann\n */\npublic class DummyScmProviderRepository\n    extends ScmProviderRepository\n{\n\n    // empty by design\n\n}\n"]}
{"filename": "src/it/setup/maven-scm-provider-dummy/src/main/java/org/apache/maven/scm/provider/dummy/DummyTagsScmProvider.java", "chunked_list": ["package org.apache.maven.scm.provider.dummy;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameters;", "import org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.CommandParameters;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.ScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmResult;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.command.status.StatusScmResult;\nimport org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;", "import org.apache.maven.scm.provider.AbstractScmProvider;\nimport org.apache.maven.scm.provider.ScmProviderRepository;\n\nimport java.util.Arrays;\nimport java.util.Date;\n\n/**\n * A dummy SCM provider used to provide commit messages and tags for testing the Conventional Commits Version Policy.\n *\n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"dummytags\"", " *\n * @plexus.component role=\"org.apache.maven.scm.provider.ScmProvider\" role-hint=\"dummytags\"\n * @author Niels Basjes\n */\n@Singleton\n@Named( \"dummytags\" )\npublic class DummyTagsScmProvider\n    extends AbstractScmProvider\n{\n\n    public String getScmType()\n    {\n        return \"dummytags\";\n    }\n", "    public String getScmType()\n    {\n        return \"dummytags\";\n    }\n\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n    {\n        return new DummyScmProviderRepository();\n    }\n\n    @Override\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n    {\n        return new StatusScmResult( \"\", \"\", \"\", true );\n    }\n\n    private ChangeSet changeSet(String comment, String... tags)\n    {\n        ChangeSet changeSet = new ChangeSet();\n        changeSet.setComment( comment );\n        changeSet.setAuthor( \"Someone <someone@example.nl>\" );\n        changeSet.setTags( Arrays.asList( tags ) );\n        return changeSet;\n    }\n\n    @Override", "    public ChangeLogScmResult changeLog(ChangeLogScmRequest request)\n    {\n        Date from = new Date(   39817800000L );\n        Date to   = new Date( 1644768534785L );\n        ChangeLogSet changeLogSet = new ChangeLogSet(\n            Arrays.asList(\n                changeSet( \"Commit 19\" ),\n                changeSet( \"Commit 18\" ),\n                changeSet( \"Commit 17\" ),\n                changeSet( \"Commit 16\" ),\n                changeSet( \"Commit 15\", \"tag 1\", \"tag 2\" ),\n                changeSet( \"feat(it): This is a new feature.\" ), // For Conventional Commits.\n                changeSet( \"Commit 13\" ),\n                changeSet( \"Commit 12\", \"tag 3\" ),\n                changeSet( \"Commit 11\" ),\n                changeSet( \"Commit 10\" ),\n                changeSet( \"Commit  9\" ),\n                changeSet( \"Commit  8\" ),\n                changeSet( \"Commit  7\" ),\n                changeSet( \"Commit  6\", \"tag 4\" ),\n                changeSet( \"Commit  5\" ),\n                changeSet( \"Commit  4\" ),\n                changeSet( \"Commit  3\" ),\n                changeSet( \"Commit  2\", \"v1.2.3\", \"4.5.6\" ), // For Conventional Commits.\n                changeSet( \"Commit  1\" ),\n                changeSet( \"Commit  0\" )\n            ), from, to\n        );\n\n        ScmResult scmResult = new ScmResult(\n            \"No command\",\n            \"Special for CCVersionPolicy testing\",\n            \"No command output\",\n            true\n        );\n        return new ChangeLogScmResult( changeLogSet, scmResult );\n    }\n\n}\n"]}
{"filename": "src/main/java/nl/basjes/maven/release/version/conventionalcommits/ConventionalCommitsVersionConfig.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n", "import java.util.List;\n\n@JacksonXmlRootElement(localName = \"ProjectVersionPolicyConfig\")\npublic class ConventionalCommitsVersionConfig {\n    private static final XmlMapper XML_MAPPER = new XmlMapper();\n\n    public static ConventionalCommitsVersionConfig fromXml(String configXml) {\n        if (configXml == null || configXml.trim().isEmpty()) {\n            return null;\n        }\n        // NOTE: If the provided config still contains the property that should have been\n        // interpolated there is no option to retrieve it. So we simply assume it is an empty string.\n        configXml = configXml.replace(\"${projectVersionPolicyConfig}\", \"\");", "        try {\n            LoggerFactory\n                .getLogger(ConventionalCommitsVersionConfig.class)\n                .debug(\"ConventionalCommitsVersionConfig XML: \\n{}\", configXml);\n            return XML_MAPPER.readValue(configXml, ConventionalCommitsVersionConfig.class);\n        } catch (JsonProcessingException e) {\n            throw new ConventionalCommitsConfigException(\"Unable to read the provided config\", e);\n        }\n    }\n\n    // Only need for tests\n    String toXml() throws JsonProcessingException {\n        return XML_MAPPER.writeValueAsString(this);\n    }\n\n    /**\n     * The regex with exactly 1 capture group that extracts the version from the SCM tag.\n     */\n    private String versionTag;\n\n    /*\n     * The list of regexes that must be classified as \"minor\" version changes.\n     */\n    private final List<String> minorRules = new ArrayList<>();\n\n    /*\n     * The list of regexes that must be classified as \"major\" version changes.\n     */\n    private final List<String> majorRules = new ArrayList<>();\n", "    public String getVersionTag() {\n        return versionTag;\n    }\n\n    public List<String> getMinorRules() {\n        return minorRules;\n    }\n\n    public List<String> getMajorRules() {\n        return majorRules;\n    }\n", "    public ConventionalCommitsVersionConfig setVersionTag(String newVersionTag) {\n        this.versionTag = newVersionTag;\n        return this;\n    }\n\n    public ConventionalCommitsVersionConfig addMinorRule(String newRule) {\n        minorRules.add(newRule);\n        return this;\n    }\n\n    public ConventionalCommitsVersionConfig addMajorRule(String newRule) {\n        majorRules.add(newRule);\n        return this;\n    }\n\n    @Override", "    public ConventionalCommitsVersionConfig addMajorRule(String newRule) {\n        majorRules.add(newRule);\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return \"ConventionalCommitsVersionConfig {\" +\n            \"versionTag='\" + versionTag + '\\'' +\n            \", minorRules=\" + minorRules +\n            \", majorRules=\" + majorRules +\n            '}';\n    }\n}\n"]}
{"filename": "src/main/java/nl/basjes/maven/release/version/conventionalcommits/ConventionalCommitsConfigException.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage nl.basjes.maven.release.version.conventionalcommits;", "\npackage nl.basjes.maven.release.version.conventionalcommits;\n\npublic class ConventionalCommitsConfigException extends RuntimeException {\n    public ConventionalCommitsConfigException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n"]}
{"filename": "src/main/java/nl/basjes/maven/release/version/conventionalcommits/CommitHistory.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.scm.ScmFileSet;\nimport org.apache.maven.scm.command.changelog.ChangeLogScmRequest;\nimport org.apache.maven.scm.command.changelog.ChangeLogSet;\nimport org.apache.maven.scm.provider.ScmProvider;\nimport org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;", "import org.apache.maven.scm.repository.ScmRepository;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;", "import java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.stream.Collectors;\n\n/**\n * Helper class to manage the commit history of the SCM repository.\n */\npublic class CommitHistory {\n    private final List<ChangeSet> changes = new ArrayList<>();\n    private String latestVersionTag = null;\n\n    public List<ChangeSet> getChanges() {\n        return changes;\n    }\n", "public class CommitHistory {\n    private final List<ChangeSet> changes = new ArrayList<>();\n    private String latestVersionTag = null;\n\n    public List<ChangeSet> getChanges() {\n        return changes;\n    }\n\n    public void addChanges(ChangeSet change) {\n        this.changes.add(change);\n    }\n", "    public void addChanges(ChangeSet change) {\n        this.changes.add(change);\n    }\n\n    public String getLastVersionTag() {\n        return latestVersionTag;\n    }\n\n    public CommitHistory(VersionPolicyRequest request, VersionRules versionRules)\n        throws ScmException, VersionParseException {\n        ScmRepository scmRepository = request.getScmRepository();\n        ScmProvider scmProvider = request.getScmProvider();\n        String workingDirectory = request.getWorkingDirectory();\n", "        if (scmRepository == null || scmProvider == null || workingDirectory == null) {\n            // We do not have a commit history so the changes and tags will remain empty\n            return;\n        }\n\n        ChangeLogScmRequest changeLogRequest = new ChangeLogScmRequest(\n            scmRepository,\n            new ScmFileSet(new File(workingDirectory))\n        );\n\n        Logger logger = LoggerFactory.getLogger(CommitHistory.class);\n\n        int limit = 0;", "        while (latestVersionTag == null) {\n            limit += 100; // Read the repository in incremental steps of 100\n            changeLogRequest.setLimit(null);\n            changeLogRequest.setLimit(limit);\n            changes.clear();\n\n            logger.debug(\"Checking the last {} commits.\", limit);\n\n            ChangeLogSet changeLogSet = scmProvider.changeLog(changeLogRequest).getChangeLog();\n            if (changeLogSet == null) {\n                return;\n            }\n            List<ChangeSet> changeSets = changeLogSet.getChangeSets();\n", "            if (changeLogSet == null) {\n                return;\n            }\n            List<ChangeSet> changeSets = changeLogSet.getChangeSets();\n\n            for (ChangeSet changeSet : changeSets) {\n                addChanges(changeSet);\n\n                List<String> changeSetTags = changeSet.getTags();\n                List<String> versionTags = changeSetTags\n                    .stream()\n                    .map(tag -> {\n                        Matcher matcher = versionRules.getTagPattern().matcher(tag);", "                        if (matcher.find()) {\n                            return matcher.group(1);\n                        }\n                        return null;\n                    }\n                    )\n                    .filter(Objects::nonNull)\n                    .collect(Collectors.toList());\n\n                if (!versionTags.isEmpty()) {\n                    // Found the previous release tag", "                if (!versionTags.isEmpty()) {\n                    // Found the previous release tag\n                    if (versionTags.size() > 1) {\n                        throw new VersionParseException(\"Most recent commit with tags has multiple version tags: \"\n                            + versionTags);\n                    }\n                    latestVersionTag = versionTags.get(0);\n                    logger.debug(\"Found tag\");\n                    break; // We have the last version tag\n                }\n            }", "            if (latestVersionTag == null &&\n                changeSets.size() < limit) {\n                // Apparently there are simply no more commits.\n                logger.debug(\"Did not find any tag\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        List<String> logLines = new ArrayList<>();\n\n        logLines.add(\"Filtered commit history:\");", "    public String toString() {\n        List<String> logLines = new ArrayList<>();\n\n        logLines.add(\"Filtered commit history:\");\n        for (ChangeSet changeSet : changes) {\n            logLines.add(\"-- Comment: \\\"\" + changeSet.getComment() + \"\\\"\");\n            logLines.add(\"   Tags   : \" + changeSet.getTags());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String logLine : logLines) {\n            sb.append(logLine).append('\\n');\n        }\n        return sb.toString();\n    }\n}\n", "        for (String logLine : logLines) {\n            sb.append(logLine).append('\\n');\n        }\n        return sb.toString();\n    }\n}\n"]}
{"filename": "src/main/java/nl/basjes/maven/release/version/conventionalcommits/ConventionalCommitsVersionPolicy.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage nl.basjes.maven.release.version.conventionalcommits;\n", "package nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.maven.scm.ScmException;\nimport org.apache.maven.shared.release.policy.PolicyException;\nimport org.apache.maven.shared.release.policy.version.VersionPolicy;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyRequest;\nimport org.apache.maven.shared.release.policy.version.VersionPolicyResult;\nimport org.apache.maven.shared.release.versions.VersionParseException;\nimport org.eclipse.sisu.Description;\nimport org.semver.Version;", "import org.eclipse.sisu.Description;\nimport org.semver.Version;\nimport org.semver.Version.Element;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\n/**", "\n/**\n * Uses SemVer combined with the tags and commit messages to increase the version.\n */\n@Singleton\n@Named(\"ConventionalCommitsVersionPolicy\")\n@Description(\"A VersionPolicy following the SemVer rules and looks at \"\n    + \"the commit messages following the Conventional Commits convention.\")\npublic class ConventionalCommitsVersionPolicy implements VersionPolicy {\n    private static final Logger LOG = LoggerFactory.getLogger(ConventionalCommitsVersionPolicy.class);\n\n    @Override", "public class ConventionalCommitsVersionPolicy implements VersionPolicy {\n    private static final Logger LOG = LoggerFactory.getLogger(ConventionalCommitsVersionPolicy.class);\n\n    @Override\n    public VersionPolicyResult getReleaseVersion(VersionPolicyRequest request) throws VersionParseException, PolicyException {\n        ConventionalCommitsVersionConfig versionConfig = ConventionalCommitsVersionConfig.fromXml(request.getConfig());\n        VersionRules versionRules = new VersionRules(versionConfig);\n        CommitHistory commitHistory;\n        try {\n            commitHistory = new CommitHistory(request, versionRules);\n        } catch (ScmException e) {\n            throw new PolicyException(\"Something went wrong fetching the commit history\", e);\n        }\n\n        boolean usingTag = false;\n\n        String versionString = request.getVersion(); // The current version in the pom\n        Version version;\n\n        LOG.debug(\"--------------------------------------------------------\");\n        LOG.debug(\"Determining next ReleaseVersion\");\n        LOG.debug(\"VersionRules: \\n{}\", versionRules);\n        LOG.debug(\"Pom version             : {}\", versionString);\n\n        LOG.debug(\"Commit History          : \\n{}\", commitHistory);\n\n        Element maxElementSinceLastVersionTag = versionRules.getMaxElementSinceLastVersionTag(commitHistory);\n\n        String latestVersionTag = commitHistory.getLastVersionTag();", "        try {\n            commitHistory = new CommitHistory(request, versionRules);\n        } catch (ScmException e) {\n            throw new PolicyException(\"Something went wrong fetching the commit history\", e);\n        }\n\n        boolean usingTag = false;\n\n        String versionString = request.getVersion(); // The current version in the pom\n        Version version;\n\n        LOG.debug(\"--------------------------------------------------------\");\n        LOG.debug(\"Determining next ReleaseVersion\");\n        LOG.debug(\"VersionRules: \\n{}\", versionRules);\n        LOG.debug(\"Pom version             : {}\", versionString);\n\n        LOG.debug(\"Commit History          : \\n{}\", commitHistory);\n\n        Element maxElementSinceLastVersionTag = versionRules.getMaxElementSinceLastVersionTag(commitHistory);\n\n        String latestVersionTag = commitHistory.getLastVersionTag();", "        if (latestVersionTag != null) {\n            // Use the latest tag we have\n            versionString = latestVersionTag;\n            usingTag = true;\n            LOG.debug(\"Version from tags       : {}\", versionString);\n        } else {\n            LOG.debug(\"Version from tags       : NOT FOUND\");\n        }\n\n        LOG.debug(\"Step from commits       : {}\", maxElementSinceLastVersionTag.name());\n", "        try {\n            version = Version.parse(versionString);\n        } catch (IllegalArgumentException e) {\n            throw new VersionParseException(e.getMessage(), e);\n        }\n\n        LOG.debug(\"Current version         : {}\", version);\n\n\n        // If we have a version from the tag we use that + the calculated update.\n        // If only have the version from the current pom version with -SNAPSHOT removed IF it is only a PATCH.", "        if (!(latestVersionTag == null && maxElementSinceLastVersionTag == Element.PATCH)) {\n            version = version.next(maxElementSinceLastVersionTag);\n        }\n\n        Version releaseVersion = version.toReleaseVersion();\n        LOG.debug(\"Next version            : {}\", releaseVersion);\n        LOG.debug(\"--------------------------------------------------------\");\n\n\n        LOG.info(\"Version and SCM analysis result:\");\n        if (usingTag) {\n            LOG.info(\"- Starting from SCM tag with version {}\", versionString);\n        } else {\n            LOG.info(\"- Starting from project.version {} (because we did not find any valid SCM tags)\", versionString);\n        }\n\n        LOG.info(\"- Doing a {} version increase{}.\",\n            maxElementSinceLastVersionTag,\n            maxElementSinceLastVersionTag == Element.PATCH\n                ? \" (because we did not find any minor/major commit messages)\"\n                : \"\");\n\n        LOG.info(\"- Next release version : {}\", releaseVersion);\n\n        VersionPolicyResult result = new VersionPolicyResult();\n        result.setVersion(releaseVersion.toString());\n        return result;\n    }\n\n    @Override", "        if (usingTag) {\n            LOG.info(\"- Starting from SCM tag with version {}\", versionString);\n        } else {\n            LOG.info(\"- Starting from project.version {} (because we did not find any valid SCM tags)\", versionString);\n        }\n\n        LOG.info(\"- Doing a {} version increase{}.\",\n            maxElementSinceLastVersionTag,\n            maxElementSinceLastVersionTag == Element.PATCH\n                ? \" (because we did not find any minor/major commit messages)\"\n                : \"\");\n\n        LOG.info(\"- Next release version : {}\", releaseVersion);\n\n        VersionPolicyResult result = new VersionPolicyResult();\n        result.setVersion(releaseVersion.toString());\n        return result;\n    }\n\n    @Override", "    public VersionPolicyResult getDevelopmentVersion(VersionPolicyRequest request)\n        throws VersionParseException {\n        Version version;\n        try {\n            version = Version.parse(request.getVersion());\n        } catch (IllegalArgumentException e) {\n            throw new VersionParseException(e.getMessage());\n        }\n\n        version = version.next(Element.PATCH);\n        VersionPolicyResult result = new VersionPolicyResult();\n        result.setVersion(version + \"-SNAPSHOT\");\n        return result;\n    }\n}\n"]}
{"filename": "src/main/java/nl/basjes/maven/release/version/conventionalcommits/VersionRules.java", "chunked_list": ["/*\n * Conventional Commits Version Policy\n * Copyright (C) 2022-2023 Niels Basjes\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *", " *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage nl.basjes.maven.release.version.conventionalcommits;", "\npackage nl.basjes.maven.release.version.conventionalcommits;\n\nimport org.apache.maven.scm.ChangeSet;\nimport org.semver.Version;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;", "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * The set of rules that determine from the commit history what the next version should be.\n */\npublic class VersionRules {\n    private final Pattern tagPattern;\n\n    private final List<Pattern> majorUpdatePatterns = new ArrayList<>();\n    private final List<Pattern> minorUpdatePatterns = new ArrayList<>();\n\n    public VersionRules(ConventionalCommitsVersionConfig config) {\n        int patternFlags = Pattern.MULTILINE | Pattern.DOTALL | Pattern.UNIX_LINES;\n\n        // The default assumes then entire tag is what we need\n        String tagRegex = \"^(\\\\d+\\\\.\\\\d+\\\\.\\\\d+)$\";\n\n        // The default rules following https://www.conventionalcommits.org/en/v1.0.0/\n        majorUpdatePatterns.add(Pattern.compile(\"^[a-zA-Z]+(?:\\\\([a-zA-Z\\\\d_-]+\\\\))?!: .*$\", patternFlags));\n        majorUpdatePatterns.add(Pattern.compile(\"^BREAKING CHANGE:.*$\", patternFlags));\n        minorUpdatePatterns.add(Pattern.compile(\"^feat(?:\\\\([a-zA-Z\\\\d_-]+\\\\))?: .*$\", patternFlags));\n", "        if (config != null) {\n            String semverConfigVersionTag = config.getVersionTag();\n            if (semverConfigVersionTag != null && !semverConfigVersionTag.trim().isEmpty()) {\n                tagRegex = semverConfigVersionTag;\n            }\n\n            if (!config.getMajorRules().isEmpty() || !config.getMinorRules().isEmpty()) {\n                majorUpdatePatterns.clear();\n                for (String majorRule : config.getMajorRules()) {\n                    majorUpdatePatterns.add(Pattern.compile(majorRule, patternFlags));\n                }\n                minorUpdatePatterns.clear();", "                for (String majorRule : config.getMajorRules()) {\n                    majorUpdatePatterns.add(Pattern.compile(majorRule, patternFlags));\n                }\n                minorUpdatePatterns.clear();\n                for (String minorRule : config.getMinorRules()) {\n                    minorUpdatePatterns.add(Pattern.compile(minorRule, patternFlags));\n                }\n            }\n        }\n        tagPattern = Pattern.compile(tagRegex, Pattern.MULTILINE);\n    }\n\n    public Version.Element getMaxElementSinceLastVersionTag(CommitHistory commitHistory) {\n        Version.Element maxElement = Version.Element.PATCH;", "        for (ChangeSet change : commitHistory.getChanges()) {\n            if (isMajorUpdate(change.getComment())) {\n                // This is the highest possible: Immediately done\n                return Version.Element.MAJOR;\n            } else if (isMinorUpdate(change.getComment())) {\n                // Have to wait, there may be another MAJOR one.\n                maxElement = Version.Element.MINOR;\n            }\n        }\n        return maxElement;\n    }\n", "    public boolean isMajorUpdate(String input) {\n        return matchesAny(majorUpdatePatterns, input);\n    }\n\n    public boolean isMinorUpdate(String input) {\n        return matchesAny(minorUpdatePatterns, input);\n    }\n\n    private boolean matchesAny(List<Pattern> patterns, String input) {\n        for (Pattern pattern : patterns) {\n            Matcher matcher = pattern.matcher(input);", "        for (Pattern pattern : patterns) {\n            Matcher matcher = pattern.matcher(input);\n            if (matcher.find()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Pattern getTagPattern() {\n        return tagPattern;\n    }\n\n    public List<Pattern> getMajorUpdatePatterns() {\n        return majorUpdatePatterns;\n    }\n\n    public List<Pattern> getMinorUpdatePatterns() {\n        return minorUpdatePatterns;\n    }\n\n    @Override", "    public Pattern getTagPattern() {\n        return tagPattern;\n    }\n\n    public List<Pattern> getMajorUpdatePatterns() {\n        return majorUpdatePatterns;\n    }\n\n    public List<Pattern> getMinorUpdatePatterns() {\n        return minorUpdatePatterns;\n    }\n\n    @Override", "    public String toString() {\n        StringBuilder result = new StringBuilder();\n        result.append(\"Conventional Commits config:\\n\");\n        result.append(\"  VersionTag:\\n\");\n        result.append(\"    >>>\").append(tagPattern).append(\"<<<\\n\");\n        result.append(\"  Major Rules:\\n\");\n        for (Pattern majorUpdatePattern : majorUpdatePatterns) {\n            result.append(\"    >>>\").append(majorUpdatePattern).append(\"<<<\\n\");\n        }\n        result.append(\"  Minor Rules:\\n\");\n        for (Pattern minorUpdatePattern : minorUpdatePatterns) {\n            result.append(\"    >>>\").append(minorUpdatePattern).append(\"<<<\\n\");\n        }\n        return result.toString();\n    }\n}\n", "        for (Pattern minorUpdatePattern : minorUpdatePatterns) {\n            result.append(\"    >>>\").append(minorUpdatePattern).append(\"<<<\\n\");\n        }\n        return result.toString();\n    }\n}\n"]}
