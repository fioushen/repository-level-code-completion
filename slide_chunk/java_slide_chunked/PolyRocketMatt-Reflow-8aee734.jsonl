{"filename": "reflow-decompiler/src/main/java/module-info.java", "chunked_list": ["module com.gitub.polyrocketmatt.reflow.decompiler {\n    requires org.objectweb.asm;\n    requires org.objectweb.asm.commons;\n    requires org.objectweb.asm.tree;\n    requires org.objectweb.asm.util;\n    requires org.objectweb.asm.tree.analysis;\n\n    exports com.github.polyrocketmatt.reflow.decompiler.decompilers;\n    exports com.github.polyrocketmatt.reflow.decompiler.entity;\n    exports com.github.polyrocketmatt.reflow.decompiler.struct;", "    exports com.github.polyrocketmatt.reflow.decompiler.entity;\n    exports com.github.polyrocketmatt.reflow.decompiler.struct;\n    exports com.github.polyrocketmatt.reflow.decompiler.utils;\n    exports com.github.polyrocketmatt.reflow.decompiler.wrapper;\n    exports com.github.polyrocketmatt.reflow.decompiler;\n}"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/ReflowJarHandler.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler;\n\nimport com.github.polyrocketmatt.reflow.decompiler.utils.ByteUtils;\nimport com.github.polyrocketmatt.reflow.decompiler.wrapper.ClassWrapper;\nimport com.github.polyrocketmatt.reflow.decompiler.wrapper.EntityWrapper;\nimport org.objectweb.asm.tree.ClassNode;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;", "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class ReflowJarHandler {\n\n    private final Map<String, byte[]> resources;\n    private final Map<String, ClassWrapper> classWrappers;\n\n    public ReflowJarHandler() {\n        this.resources = new HashMap<>();\n        this.classWrappers = new HashMap<>();\n    }\n\n    public Map<String, byte[]> getResources() {\n        return resources;\n    }\n\n    public Map<String, ClassWrapper> getClassWrappers() {\n        return classWrappers;\n    }\n", "    public EntityWrapper parseClass(String name, byte[] data) throws IOException {\n        if (name.endsWith(\".class\")) {\n            ClassNode classNode = ByteUtils.parseBytesToClassNode(data);\n            ClassWrapper classWrapper = new ClassWrapper(classNode);\n\n            classWrappers.put(classWrapper.getSimpleName(), classWrapper);\n\n            /*\n                    AsmDependencyDecompiler dependencyDecompiler = ByteUtils.parseDependencies(data);\n                    Set<String> imports = dependencyDecompiler.getImports();\n                    ClassWrapper wrapper = new ClassWrapper(classNode, imports, data, false);\n                    boolean isInnerClass = classNode.name.contains(\"$\");\n\n                    //  If this class is an inner class, we don't want to add it to the list of classes", "                    if (isInnerClass) {\n                        String key = wrapper.getSimpleName().substring(0, wrapper.getSimpleName().indexOf(\"$\"));\n                        Set<ClassWrapper> wrappers = innerClassMap.getOrDefault(key, new HashSet<>());\n                        wrappers.add(wrapper);\n                        innerClassMap.put(key, wrappers);\n                        wrapperMap.put(wrapper.getSimpleName(), wrapper);\n\n                        continue;\n                    }\n\n                    classes.put(wrapper, name);\n                    wrapperMap.put(wrapper.getSimpleName(), wrapper);\n\n                     */\n            return classWrapper;\n        } else {", "            if (name.equals(\"META-INF/MANIFEST.MF\")) {\n                String manifest = new String(data);\n\n                // Place a watermark\n                manifest = manifest.substring(0, manifest.length() - 2);\n                manifest += \"Processed-With: ReFlow-0.0.1\\r\\n\";\n                data = manifest.getBytes();\n            }\n\n            resources.put(name, data);\n\n            return null;\n        }\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/entity/EntityType.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.entity;\n\npublic enum EntityType {\n\n    CLASS,\n    FIELD,\n    METHOD,\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/utils/AsmUtils.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.utils;\n\nimport static org.objectweb.asm.Opcodes.ASM9;\n\npublic class AsmUtils {\n\n    public static final int ASM_VERSION = ASM9;\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/utils/StringUtils.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.utils;\n\npublic class StringUtils {\n\n    public static String getLast(String string, String delimiter) {\n        String[] split = string.split(delimiter);\n        return split[split.length - 1];\n    }\n\n    public static String rgbToHex(int red, int green, int blue) {\n        // Ensure that the RGB values are within the valid range (0-255)\n        red = Math.min(255, Math.max(0, red));\n        green = Math.min(255, Math.max(0, green));\n        blue = Math.min(255, Math.max(0, blue));\n\n        // Convert the RGB values to hexadecimal strings\n        String hexRed = Integer.toHexString(red);\n        String hexGreen = Integer.toHexString(green);\n        String hexBlue = Integer.toHexString(blue);\n\n        // Pad the strings with leading zeros if needed\n        hexRed = padLeftZero(hexRed);\n        hexGreen = padLeftZero(hexGreen);\n        hexBlue = padLeftZero(hexBlue);\n\n        // Combine the RGB values into a single HEX string\n        String hexColor = hexRed + hexGreen + hexBlue;\n\n        return hexColor.toUpperCase(); // Convert to uppercase for consistency\n    }\n", "    public static String rgbToHex(int red, int green, int blue) {\n        // Ensure that the RGB values are within the valid range (0-255)\n        red = Math.min(255, Math.max(0, red));\n        green = Math.min(255, Math.max(0, green));\n        blue = Math.min(255, Math.max(0, blue));\n\n        // Convert the RGB values to hexadecimal strings\n        String hexRed = Integer.toHexString(red);\n        String hexGreen = Integer.toHexString(green);\n        String hexBlue = Integer.toHexString(blue);\n\n        // Pad the strings with leading zeros if needed\n        hexRed = padLeftZero(hexRed);\n        hexGreen = padLeftZero(hexGreen);\n        hexBlue = padLeftZero(hexBlue);\n\n        // Combine the RGB values into a single HEX string\n        String hexColor = hexRed + hexGreen + hexBlue;\n\n        return hexColor.toUpperCase(); // Convert to uppercase for consistency\n    }\n", "    public static String padLeftZero(String hexValue) {\n        return hexValue.length() == 1 ? \"0\" + hexValue : hexValue;\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/utils/ByteUtils.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.utils;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.tree.ClassNode;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;", "import java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.zip.ZipInputStream;\n\npublic class ByteUtils {\n\n    public static byte[] readBytes(ZipInputStream zis) throws IOException {\n        //  Buffer to read bytes into\n        byte[] buffer = new byte[1024];\n\n        //  Byte output stream to write bytes to\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        //  Read bytes from the zip input stream\n        int bytesRead;", "        while ((bytesRead = zis.read(buffer)) != -1)\n            baos.write(buffer, 0, bytesRead);\n\n        //  Close streams\n        zis.closeEntry();\n        baos.close();\n\n        //  Return the bytes\n        return baos.toByteArray();\n    }\n", "    public static byte[] readBytes(String filePath) throws IOException {\n        return Files.readAllBytes(Paths.get(filePath));\n    }\n\n    public static byte[] readBytes(InputStream is) throws IOException {\n        //  Buffer to read bytes into\n        byte[] buffer = new byte[1024];\n\n        //  Byte output stream to write bytes to\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        //  Read bytes from the input stream\n        int bytesRead;", "        while ((bytesRead = is.read(buffer, 0, buffer.length)) != -1)\n            baos.write(buffer, 0, bytesRead);\n\n        //  Close the streams\n        baos.close();\n        is.close();\n\n        //  Return the bytes\n        return baos.toByteArray();\n    }\n", "    public static ClassNode parseBytesToClassNode(byte[] bytes) {\n        ClassReader reader = new ClassReader(bytes);\n        ClassNode node = new ClassNode();\n\n        reader.accept(node, 0);\n\n        return node;\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/utils/FileUtils.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.utils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class FileUtils {\n\n}\n", "import java.util.zip.ZipInputStream;\n\npublic class FileUtils {\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/wrapper/ClassWrapper.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.wrapper;\n\nimport com.github.polyrocketmatt.reflow.decompiler.entity.EntityType;\nimport com.github.polyrocketmatt.reflow.decompiler.utils.StringUtils;\nimport org.objectweb.asm.tree.ClassNode;\n\npublic class ClassWrapper implements EntityWrapper {\n\n    private final ClassNode asmClassNode;\n    private final String simpleName;\n\n    public ClassWrapper(ClassNode asmClassNode) {\n        this.asmClassNode = asmClassNode;\n        this.simpleName = StringUtils.getLast(asmClassNode.name, \"/\");\n    }\n\n    @Override", "    public EntityType getEntityType() {\n        return EntityType.CLASS;\n    }\n\n    @Override\n    public String getName() {\n        return this.asmClassNode.name;\n    }\n\n    public String getSimpleName() {\n        return this.simpleName;\n    }\n\n}\n", "    public String getSimpleName() {\n        return this.simpleName;\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/wrapper/EntityWrapper.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.wrapper;\n\nimport com.github.polyrocketmatt.reflow.decompiler.entity.EntityType;\nimport org.objectweb.asm.Opcodes;\n\npublic interface EntityWrapper extends Opcodes {\n\n    EntityType getEntityType();\n\n    String getName();\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/struct/EntityStructure.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.struct;\n\nimport com.github.polyrocketmatt.reflow.decompiler.wrapper.EntityWrapper;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class EntityStructure<T extends EntityWrapper> {\n\n    private final HashMap<String, ArrayList<String>> pointerTable;\n    private final HashMap<String, T> classTable;\n\n    public EntityStructure(List<T> wrappers) {\n        this.pointerTable = new HashMap<>();\n        this.classTable = new HashMap<>();\n", "        try {\n            buildStructure(wrappers);\n        } catch (RuntimeException | InterruptedException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private void buildStructure(List<T> wrappers) throws RuntimeException, InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        executor.submit(() -> buildPointerTable(wrappers));\n        executor.submit(() -> buildClassTable(wrappers));\n        executor.shutdown();\n", "        if (!executor.awaitTermination(5, TimeUnit.MINUTES))\n            throw new RuntimeException(\"Failed to build entry structure in time\");\n    }\n\n    private void buildPointerTable(List<T> wrappers) {\n        List<String> names = wrappers.stream().map(EntityWrapper::getName).toList();\n        List<String[]> paths = new ArrayList<>(names.stream().map(name -> name.split(\"/\")).toList());\n\n        for (String[] path : paths) {\n            StringBuilder buildPath = new StringBuilder();\n\n            int pathLength = path.length - 1;", "        for (String[] path : paths) {\n            StringBuilder buildPath = new StringBuilder();\n\n            int pathLength = path.length - 1;\n            for (int pathIndex = 0; pathIndex < pathLength; pathIndex++) {\n                String key = path[pathIndex + 1];\n                buildPath.append(path[pathIndex]).append(\"/\");\n\n                //  If the key is not in the pointer table, add it\n                List<String> children = pointerTable.getOrDefault(buildPath.toString(), new ArrayList<>());\n                if (!children.contains(key))\n                    children.add(key);\n                pointerTable.put(buildPath.toString(), new ArrayList<>(children));\n            }\n        }\n    }\n\n    private void buildClassTable(List<T> wrappers) {", "                if (!children.contains(key))\n                    children.add(key);\n                pointerTable.put(buildPath.toString(), new ArrayList<>(children));\n            }\n        }\n    }\n\n    private void buildClassTable(List<T> wrappers) {\n        for (T wrapper : wrappers) {\n            String name = wrapper.getName();\n            String[] splitName = name.split(\"/\");\n            String simpleName = splitName[splitName.length - 1];\n\n            classTable.put(simpleName, wrapper);\n        }\n    }\n\n    public List<String> getAbsoluteParents() {\n        return this.pointerTable.keySet().stream().filter(key -> key.split(\"/\").length == 1).toList();\n    }\n", "        for (T wrapper : wrappers) {\n            String name = wrapper.getName();\n            String[] splitName = name.split(\"/\");\n            String simpleName = splitName[splitName.length - 1];\n\n            classTable.put(simpleName, wrapper);\n        }\n    }\n\n    public List<String> getAbsoluteParents() {\n        return this.pointerTable.keySet().stream().filter(key -> key.split(\"/\").length == 1).toList();\n    }\n", "    public boolean isClass(String name) {\n        return classTable.containsKey(name);\n    }\n\n    public boolean isPackage(String path) {\n        return pointerTable.keySet().stream().anyMatch(pathKey -> pathKey.equals(path));\n    }\n\n    public List<String> getChildren(String name) {\n        return pointerTable.getOrDefault(name, new ArrayList<>());\n    }\n", "    public T getClassWrapper(String name) {\n        return classTable.get(name);\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/decompilers/ClassDependencyDecompiler.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.decompilers;\n\nimport com.github.polyrocketmatt.reflow.decompiler.utils.AsmUtils;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassDependencyDecompiler extends ClassVisitor implements ReflowDecompiler {\n\n    private final List<String> packages;\n    private final List<String> imports;\n\n    public ClassDependencyDecompiler(byte[] bytes) {\n        super(AsmUtils.ASM_VERSION);\n\n        this.packages = new ArrayList<>();\n        this.imports = new ArrayList<>();\n\n    }\n\n    @Override", "\npublic class ClassDependencyDecompiler extends ClassVisitor implements ReflowDecompiler {\n\n    private final List<String> packages;\n    private final List<String> imports;\n\n    public ClassDependencyDecompiler(byte[] bytes) {\n        super(AsmUtils.ASM_VERSION);\n\n        this.packages = new ArrayList<>();\n        this.imports = new ArrayList<>();\n\n    }\n\n    @Override", "    public void decompile(byte[] data) {\n        ClassReader reader = new ClassReader(data);\n        reader.accept(this, 0);\n    }\n\n    public List<String> getPackages() {\n        return packages;\n    }\n\n    public List<String> getImports() {\n        return imports;\n    }\n\n}\n"]}
{"filename": "reflow-decompiler/src/main/java/com/github/polyrocketmatt/reflow/decompiler/decompilers/ReflowDecompiler.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.decompiler.decompilers;\n\n@FunctionalInterface\npublic interface ReflowDecompiler {\n\n    void decompile(byte[] data);\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/module-info.java", "chunked_list": ["module com.gitub.polyrocketmatt.reflow.ui {\n    requires java.desktop;\n    requires javafx.controls;\n    requires javafx.fxml;\n    requires javafx.swing;\n    requires org.controlsfx.controls;\n    requires org.kordamp.ikonli.javafx;\n    requires batik.all;\n    requires com.gitub.polyrocketmatt.reflow.decompiler;\n", "    requires com.gitub.polyrocketmatt.reflow.decompiler;\n\n    opens com.github.polyrocketmatt.reflow to javafx.fxml;\n    exports com.github.polyrocketmatt.reflow;\n    exports com.github.polyrocketmatt.reflow.context;\n    opens com.github.polyrocketmatt.reflow.context to javafx.fxml;\n}"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/InitController.java", "chunked_list": ["package com.github.polyrocketmatt.reflow;\n\nimport com.github.polyrocketmatt.reflow.context.ApplicationContext;\nimport javafx.event.ActionEvent;\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.input.DragEvent;\nimport javafx.scene.input.TransferMode;", "import javafx.scene.input.DragEvent;\nimport javafx.scene.input.TransferMode;\nimport javafx.scene.layout.AnchorPane;\nimport javafx.scene.layout.BorderPane;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.FileChooser;\nimport javafx.stage.Stage;\n\nimport java.io.File;\n\npublic class InitController implements Controller {\n\n    @FXML Label initLabel;\n    @FXML BorderPane initBorderPane;\n    @FXML AnchorPane rootPane;\n\n    public InitController() {}\n\n    @SuppressWarnings(\"ConstantConditions\")", "import java.io.File;\n\npublic class InitController implements Controller {\n\n    @FXML Label initLabel;\n    @FXML BorderPane initBorderPane;\n    @FXML AnchorPane rootPane;\n\n    public InitController() {}\n\n    @SuppressWarnings(\"ConstantConditions\")", "    public void contextSwitch(String context) {\n        //  Try to load decompiler view\n        try {\n            AnchorPane switchedContextPane = FXMLLoader.load(ReflowUI.class.getResource(context));\n            Stage stage = ApplicationContext.CONTEXT.getStage();\n\n            double width = stage.getWidth();\n            double height = stage.getHeight();\n\n            Scene scene = new Scene(switchedContextPane, width, height);\n\n            //  Setting style\n            scene.getStylesheets().add(\"stylesheet.css\");\n\n            stage.setScene(scene);\n            stage.show();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n\n            //  Close the application\n            System.exit(0);\n        }\n    }\n\n    @Override", "    public void onClose(ActionEvent event) {\n        System.exit(0);\n    }\n\n    @FXML\n    public void onDragOver(DragEvent event) {\n        if (event.getDragboard().hasFiles()) {\n            event.acceptTransferModes(TransferMode.ANY);\n        }\n    }\n\n    @FXML", "    public void onDragDropped(DragEvent event) {\n        //  Get the file from the drag-board\n        File file = event.getDragboard().getFiles().get(0);\n        ApplicationContext.CONTEXT.addFile(file);\n\n        contextSwitch(ApplicationContext.DECOMPILER);\n    }\n\n    @FXML\n    public void onOpenFile(ActionEvent event) {\n        //  Create file chooser dialog\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Select JAR/ZIP File\");\n        fileChooser.getExtensionFilters().addAll(\n                new FileChooser.ExtensionFilter(\"Jar Files\", \"*.jar\"),\n                new FileChooser.ExtensionFilter(\"Zip Files\", \"*.zip\")\n        );\n        File selectedFile = fileChooser.showOpenDialog(ApplicationContext.CONTEXT.getStage());", "    public void onOpenFile(ActionEvent event) {\n        //  Create file chooser dialog\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Select JAR/ZIP File\");\n        fileChooser.getExtensionFilters().addAll(\n                new FileChooser.ExtensionFilter(\"Jar Files\", \"*.jar\"),\n                new FileChooser.ExtensionFilter(\"Zip Files\", \"*.zip\")\n        );\n        File selectedFile = fileChooser.showOpenDialog(ApplicationContext.CONTEXT.getStage());\n        if (selectedFile != null) {\n            ApplicationContext.CONTEXT.addFile(selectedFile);\n\n            contextSwitch(ApplicationContext.DECOMPILER);\n        }\n    }\n\n}\n", "        if (selectedFile != null) {\n            ApplicationContext.CONTEXT.addFile(selectedFile);\n\n            contextSwitch(ApplicationContext.DECOMPILER);\n        }\n    }\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/ReflowUI.java", "chunked_list": ["package com.github.polyrocketmatt.reflow;\n\nimport com.github.polyrocketmatt.reflow.context.ApplicationContext;\nimport javafx.application.Application;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.image.Image;\nimport javafx.stage.Stage;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\n\npublic class ReflowUI extends Application {\n\n    @Override\n    public void start(Stage stage) throws IOException {\n        //  Load FXML\n        FXMLLoader loader = new FXMLLoader(ReflowUI.class.getResource(\"reflow-init.fxml\"));\n        Scene scene = new Scene(loader.load(), 800, 600);\n\n        //  Setting style\n        scene.getStylesheets().add(\"stylesheet.css\");\n\n        stage.setTitle(\" Reflow\");\n        stage.getIcons().add(new Image(\"/reflow-32.png\", 32, 32, true, false));\n        stage.setScene(scene);\n        stage.setMaximized(false);\n        stage.show();\n\n        //  Set scene in ApplicationContext\n        ApplicationContext.CONTEXT.setStage(stage);\n        ApplicationContext.CONTEXT.setWidthPenalty(stage.getWidth() - 800);\n        ApplicationContext.CONTEXT.setHeightPenalty(stage.getHeight() - 600);\n    }\n", "    public static void main(String[] args) {\n        launch();\n    }\n\n}"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/DecompilerController.java", "chunked_list": ["package com.github.polyrocketmatt.reflow;\n\nimport com.github.polyrocketmatt.reflow.context.ApplicationContext;\nimport com.github.polyrocketmatt.reflow.decompiler.ReflowJarHandler;\nimport com.github.polyrocketmatt.reflow.decompiler.struct.EntityStructure;\nimport com.github.polyrocketmatt.reflow.decompiler.utils.ByteUtils;\nimport com.github.polyrocketmatt.reflow.decompiler.wrapper.ClassWrapper;\nimport com.github.polyrocketmatt.reflow.decompiler.wrapper.EntityWrapper;\nimport com.github.polyrocketmatt.reflow.processing.SVGIconFactory;\nimport javafx.application.Platform;", "import com.github.polyrocketmatt.reflow.processing.SVGIconFactory;\nimport javafx.application.Platform;\nimport javafx.concurrent.Task;\nimport javafx.event.ActionEvent;\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.fxml.Initializable;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ProgressBar;\nimport javafx.scene.control.TreeItem;", "import javafx.scene.control.ProgressBar;\nimport javafx.scene.control.TreeItem;\nimport javafx.scene.control.TreeView;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.layout.AnchorPane;\nimport javafx.stage.FileChooser;\nimport javafx.stage.Stage;\n\nimport java.io.File;", "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.ExecutorService;", "import java.util.ResourceBundle;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class DecompilerController implements Controller, Initializable {\n\n    private File file;\n    private ReflowJarHandler jarHandler;\n    private EntityStructure<ClassWrapper> classWrapperStructure;\n\n    @FXML AnchorPane rootPane;\n    @FXML ProgressBar mainProgressBar;\n    @FXML TreeView<String> classTreeView;\n\n    public DecompilerController() {}\n\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override", "    public void initialize(URL url, ResourceBundle resourceBundle) {\n        setupClassTreeView();\n    }\n\n    private void setupClassTreeView() {\n        this.file = ApplicationContext.CONTEXT.getQueue().poll();\n        if (this.file == null)\n            throw new RuntimeException(\"No file was found in the queue when initializing the decompiler controller\");\n        this.jarHandler = new ReflowJarHandler();\n        this.classTreeView.setVisible(false);\n        this.loadJarFile();\n        this.classTreeView.setVisible(true);\n        this.classTreeView.setOnMouseClicked(this::decompile);\n    }\n\n    private List<ClassWrapper> handleInputStream(TreeItem<String> root, ZipInputStream zis) throws Exception{\n        ExecutorService executor = Executors.newFixedThreadPool(8);\n        List<ClassWrapper> wrappers = new ArrayList<>();\n        ZipEntry entry;\n", "        while ((entry = zis.getNextEntry()) != null) {\n            String name = entry.getName();\n            byte[] data = ByteUtils.readBytes(zis);\n\n            executor.execute(() -> {\n                try {\n                    EntityWrapper wrapper = this.jarHandler.parseClass(name, data);\n\n                    if (wrapper instanceof ClassWrapper classWrapper)\n                        wrappers.add(classWrapper);\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                }\n            });\n        }\n        executor.shutdown();\n", "                    if (wrapper instanceof ClassWrapper classWrapper)\n                        wrappers.add(classWrapper);\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                }\n            });\n        }\n        executor.shutdown();\n\n        if (!executor.awaitTermination(5, TimeUnit.MINUTES))\n            throw new IllegalStateException(\"Failed to load JAR file\");\n        return wrappers;\n    }\n\n    private void constructTree(TreeItem<String> rootItem) {\n        Task<Void> insertion = new Task<>() {\n            @Override\n            protected Void call() {\n                List<String> parents = classWrapperStructure.getAbsoluteParents();\n\n                //  Get the parents who have more than one child and exactly one child\n                ArrayList<String> packageParents = new ArrayList<>(parents.stream().filter(parent -> classWrapperStructure.isPackage(parent)).toList());\n                ArrayList<String> classParents = new ArrayList<>(parents.stream().filter(parent -> classWrapperStructure.isClass(parent)).toList());\n\n                //  Sort both\n                packageParents.sort(Comparator.comparingInt(o -> classWrapperStructure.getChildren(o).size()));\n                classParents.sort(Comparator.comparingInt(o -> classWrapperStructure.getChildren(o).size()));\n\n                //  Add package parents first, then class parents", "        if (!executor.awaitTermination(5, TimeUnit.MINUTES))\n            throw new IllegalStateException(\"Failed to load JAR file\");\n        return wrappers;\n    }\n\n    private void constructTree(TreeItem<String> rootItem) {\n        Task<Void> insertion = new Task<>() {\n            @Override\n            protected Void call() {\n                List<String> parents = classWrapperStructure.getAbsoluteParents();\n\n                //  Get the parents who have more than one child and exactly one child\n                ArrayList<String> packageParents = new ArrayList<>(parents.stream().filter(parent -> classWrapperStructure.isPackage(parent)).toList());\n                ArrayList<String> classParents = new ArrayList<>(parents.stream().filter(parent -> classWrapperStructure.isClass(parent)).toList());\n\n                //  Sort both\n                packageParents.sort(Comparator.comparingInt(o -> classWrapperStructure.getChildren(o).size()));\n                classParents.sort(Comparator.comparingInt(o -> classWrapperStructure.getChildren(o).size()));\n\n                //  Add package parents first, then class parents", "                for (String parent : packageParents)\n                    insertElement(parent.substring(0, parent.length() - 1), parent, rootItem, true);\n                for (String parent : classParents)\n                    insertElement(parent.substring(0, parent.length() - 1), parent, rootItem, false);\n\n                return null;\n            }\n        };\n\n        Thread insertionThread = new Thread(insertion);\n        insertionThread.setDaemon(true);\n        insertionThread.start();\n    }\n\n    private void insertElement(String element, String path, TreeItem<String> parent, boolean expandable) {\n        boolean isPackage = classWrapperStructure.isPackage(path);\n        ImageView itemIcon = SVGIconFactory.fromSVG((isPackage) ? \"svg/package-item-plain.svg\" : \"svg/class-item-plain.svg\");\n        TreeItem<String> item = new TreeItem<>(element, itemIcon);\n        Platform.runLater(() -> parent.getChildren().add(item));\n\n        item.addEventHandler(TreeItem.branchExpandedEvent(), event -> expand(item, path));\n\n        //  TODO: Work staged (i.e. when expanding, make sure the expanded level is already loaded)\n        //  If the item is not expandable, we do not want to make it expandable currently", "        if (expandable) {\n            //  Expansion item\n            TreeItem<String> expansionItem = new TreeItem<>(\"Loading...\");\n\n            //  Add expansion item to item\n            Platform.runLater(() -> item.getChildren().add(expansionItem));\n        }\n    }\n\n    private void expand(TreeItem<String> item, String path) {\n        //  First check if the item was already loaded by checking if the only item is the expansion item", "        if (item.getChildren().size() == 1 && item.getChildren().get(0).getValue().equals(\"Loading...\")) {\n            System.out.println(\"FFS\");\n\n            //  Remove the expansion item\n            item.getChildren().remove(0);\n\n            //  Get actual children\n            List<String> children = classWrapperStructure.getChildren(path);\n            List<String> packageChildren = new ArrayList<>(children.stream().filter(child -> classWrapperStructure.isPackage(path + child + \"/\")).toList());\n            List<String> classChildren = new ArrayList<>(children.stream().filter(child -> !classWrapperStructure.isPackage(path + child + \"/\")).toList());\n\n            //  Sort packages and classes alphabetically\n            packageChildren.sort(String::compareToIgnoreCase);\n            classChildren.sort(String::compareToIgnoreCase);\n\n            //  Add package parents first, then class parents", "            for (String subParent : packageChildren)\n                insertElement(subParent, path + subParent + \"/\", item, true);\n            for (String subChild : classChildren)\n                //  TODO: In the future, this can be true if we want to add methods/constructors/inner class views\n                insertElement(subChild, path + subChild + \"/\", item, false);\n        }\n    }\n\n    private void expand(TreeItem<String> item) {\n        StringBuilder path = new StringBuilder(item.getValue() + \"/\");\n        TreeItem<String> parent = item.getParent();\n", "        while (parent.getParent() != null) {\n            path.insert(0, parent.getValue() + \"/\");\n            parent = parent.getParent();\n        }\n\n        expand(item, path.toString());\n    }\n\n    private void loadJarFile() {\n        try {\n            ImageView rootIcon = SVGIconFactory.fromSVG(\"svg/jar-item-plain.svg\");\n            TreeItem<String> rootItem = new TreeItem<>(this.file.getName(), rootIcon);\n            ZipInputStream zis = new ZipInputStream(new FileInputStream(this.file));\n            List<ClassWrapper> classWrappers = handleInputStream(rootItem, zis);\n\n            this.classWrapperStructure = new EntityStructure<>(classWrappers);\n            this.classTreeView.setRoot(rootItem);\n            this.constructTree(rootItem);\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override", "        try {\n            ImageView rootIcon = SVGIconFactory.fromSVG(\"svg/jar-item-plain.svg\");\n            TreeItem<String> rootItem = new TreeItem<>(this.file.getName(), rootIcon);\n            ZipInputStream zis = new ZipInputStream(new FileInputStream(this.file));\n            List<ClassWrapper> classWrappers = handleInputStream(rootItem, zis);\n\n            this.classWrapperStructure = new EntityStructure<>(classWrappers);\n            this.classTreeView.setRoot(rootItem);\n            this.constructTree(rootItem);\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override", "    public void onClose(ActionEvent event) {\n        System.exit(0);\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    public void contextSwitch(String context) {\n        //  Try to load decompiler view\n        try {\n            AnchorPane switchedContextPane = FXMLLoader.load(ReflowUI.class.getResource(context));\n            Stage stage = ApplicationContext.CONTEXT.getStage();\n\n            double width = stage.getWidth() - ApplicationContext.CONTEXT.getWidthPenalty();\n            double height = stage.getHeight() - ApplicationContext.CONTEXT.getHeightPenalty();\n\n            Scene scene = new Scene(switchedContextPane, width, height);\n\n            //  Setting style\n            scene.getStylesheets().add(\"stylesheet.css\");\n\n            stage.setScene(scene);\n            stage.show();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n\n            //  Close the application\n            System.exit(0);\n        }\n    }\n\n    @FXML", "    public void onOpenFile(ActionEvent event) {\n        //  Create file chooser dialog\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Open File\");\n        fileChooser.getExtensionFilters().addAll(\n                new FileChooser.ExtensionFilter(\"Jar Files\", \"*.jar\"),\n                new FileChooser.ExtensionFilter(\"Zip Files\", \"*.zip\")\n        );\n\n        //  Update context\n        File selectedFile = fileChooser.showOpenDialog(ApplicationContext.CONTEXT.getStage());\n        ApplicationContext.CONTEXT.addFile(selectedFile);\n\n        //  We do not want to switch context here, as we are already in the decompiler context", "        try {\n            setupClassTreeView();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @FXML\n    public void decompile(MouseEvent event) {\n        try {\n            TreeView<String> treeView = (TreeView<String>) event.getSource();\n            TreeItem<String> selectedItem = treeView.getSelectionModel().getSelectedItem();\n            String value = selectedItem.getValue();\n\n            //  Check if the value is a class", "    public void decompile(MouseEvent event) {\n        try {\n            TreeView<String> treeView = (TreeView<String>) event.getSource();\n            TreeItem<String> selectedItem = treeView.getSelectionModel().getSelectedItem();\n            String value = selectedItem.getValue();\n\n            //  Check if the value is a class\n            if (this.classWrapperStructure.isClass(value)) {\n            } else {\n                //  Expansion\n                expand(selectedItem);\n            }\n        } catch (Exception ex) {\n            //  Ignore\n            System.out.println(event.getSource().getClass().getSimpleName());\n        }\n    }\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/Controller.java", "chunked_list": ["package com.github.polyrocketmatt.reflow;\n\nimport javafx.event.ActionEvent;\nimport javafx.fxml.FXML;\n\npublic interface Controller {\n\n    void contextSwitch(String context);\n\n    @FXML\n    default void onClose(ActionEvent event) {\n        System.exit(0);\n    }\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/context/ApplicationContext.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.context;\n\nimport javafx.stage.Stage;\n\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ApplicationContext {\n", "\npublic class ApplicationContext {\n\n    public static final String INIT = \"reflow-init.fxml\";\n    public static final String DECOMPILER = \"reflow-decompiler.fxml\";\n    public static final String SYSTEM_SEPARATOR = System.getProperty(\"file.separator\");\n    public static final ApplicationContext CONTEXT = new ApplicationContext();\n\n    private final Queue<File> queue;\n    private Stage stage = null;\n    private double widthPenalty = 0.0;\n    private double heightPenalty = 0.0;\n\n    private ApplicationContext() {\n        this.queue = new LinkedList<>();\n    }\n", "    public void addFile(File file) {\n        queue.add(file);\n    }\n\n    public Queue<File> getQueue() {\n        return queue;\n    }\n\n    public Stage getStage() {\n        return stage;\n    }\n", "    public Stage getStage() {\n        return stage;\n    }\n\n    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    public double getWidthPenalty() {\n        return widthPenalty;\n    }\n", "    public double getWidthPenalty() {\n        return widthPenalty;\n    }\n\n    public void setWidthPenalty(double widthPenalty) {\n        this.widthPenalty = widthPenalty;\n    }\n\n    public double getHeightPenalty() {\n        return heightPenalty;\n    }\n", "    public double getHeightPenalty() {\n        return heightPenalty;\n    }\n\n    public void setHeightPenalty(double heightPenalty) {\n        this.heightPenalty = heightPenalty;\n    }\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/processing/Scalr.java", "chunked_list": ["/**\n * Copyright 2011 The Buzz Media, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.polyrocketmatt.reflow.processing;\n\nimport java.awt.Color;", "\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.RenderingHints;\nimport java.awt.Transparency;\nimport java.awt.color.ColorSpace;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Rectangle2D;", "import java.awt.geom.AffineTransform;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.AreaAveragingScaleFilter;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.BufferedImageOp;\nimport java.awt.image.ColorConvertOp;\nimport java.awt.image.ColorModel;\nimport java.awt.image.ConvolveOp;\nimport java.awt.image.ImagingOpException;\nimport java.awt.image.IndexColorModel;", "import java.awt.image.ImagingOpException;\nimport java.awt.image.IndexColorModel;\nimport java.awt.image.Kernel;\nimport java.awt.image.RasterFormatException;\nimport java.awt.image.RescaleOp;\n\nimport javax.imageio.ImageIO;\n\n/**\n * Class used to implement performant, high-quality and intelligent image", "/**\n * Class used to implement performant, high-quality and intelligent image\n * scaling and manipulation algorithms in native Java 2D.\n * <p/>\n * This class utilizes the Java2D \"best practices\" for image manipulation,\n * ensuring that all operations (even most user-provided {@link BufferedImageOp}\n * s) are hardware accelerated if provided by the platform and host-VM.\n * <p/>\n * <h3>Image Quality</h3>\n * This class implements a few different methods for scaling an image, providing", " * <h3>Image Quality</h3>\n * This class implements a few different methods for scaling an image, providing\n * either the best-looking result, the fastest result or a balanced result\n * between the two depending on the scaling hint provided (see {@link Method}).\n * <p/>\n * This class also implements an optimized version of the incremental scaling\n * algorithm presented by Chris Campbell in his <a href=\"http://today.java\n * .net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html\">Perils of\n * Image.getScaledInstance()</a> article in order to give the best-looking image\n * resize results (e.g. generating thumbnails that aren't blurry or jagged).", " * Image.getScaledInstance()</a> article in order to give the best-looking image\n * resize results (e.g. generating thumbnails that aren't blurry or jagged).\n * <p>\n * The results generated by imgscalr using this method, as compared to a single\n * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} scale operation look much\n * better, especially when using the {@link Method#ULTRA_QUALITY} method.\n * <p/>\n * Only when scaling using the {@link Method#AUTOMATIC} method will this class\n * look at the size of the image before selecting an approach to scaling the\n * image. If {@link Method#QUALITY} is specified, the best-looking algorithm", " * look at the size of the image before selecting an approach to scaling the\n * image. If {@link Method#QUALITY} is specified, the best-looking algorithm\n * possible is always used.\n * <p/>\n * Minor modifications are made to Campbell's original implementation in the\n * form of:\n * <ol>\n * <li>Instead of accepting a user-supplied interpolation method,\n * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} interpolation is always\n * used. This was done after A/B comparison testing with large images", " * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} interpolation is always\n * used. This was done after A/B comparison testing with large images\n * down-scaled to thumbnail sizes showed noticeable \"blurring\" when BILINEAR\n * interpolation was used. Given that Campbell's algorithm is only used in\n * QUALITY mode when down-scaling, it was determined that the user's expectation\n * of a much less blurry picture would require that BICUBIC be the default\n * interpolation in order to meet the QUALITY expectation.</li>\n * <li>After each iteration of the do-while loop that incrementally scales the\n * source image down, an explicit effort is made to call\n * {@link BufferedImage#flush()} on the interim temporary {@link BufferedImage}", " * source image down, an explicit effort is made to call\n * {@link BufferedImage#flush()} on the interim temporary {@link BufferedImage}\n * instances created by the algorithm in an attempt to ensure a more complete GC\n * cycle by the VM when cleaning up the temporary instances (this is in addition\n * to disposing of the temporary {@link Graphics2D} references as well).</li>\n * <li>Extensive comments have been added to increase readability of the code.</li>\n * <li>Variable names have been expanded to increase readability of the code.</li>\n * </ol>\n * <p/>\n * <strong>NOTE</strong>: This class does not call {@link BufferedImage#flush()}", " * <p/>\n * <strong>NOTE</strong>: This class does not call {@link BufferedImage#flush()}\n * on any of the <em>source images</em> passed in by calling code; it is up to\n * the original caller to dispose of their source images when they are no longer\n * needed so the VM can most efficiently GC them.\n * <h3>Image Proportions</h3>\n * All scaling operations implemented by this class maintain the proportions of\n * the original image unless a mode of {@link Mode#FIT_EXACT} is specified; in\n * which case the orientation and proportion of the source image is ignored and\n * the image is stretched (if necessary) to fit the exact dimensions given.", " * which case the orientation and proportion of the source image is ignored and\n * the image is stretched (if necessary) to fit the exact dimensions given.\n * <p/>\n * When not using {@link Mode#FIT_EXACT}, in order to maintain the\n * proportionality of the original images, this class implements the following\n * behavior:\n * <ol>\n * <li>If the image is LANDSCAPE-oriented or SQUARE, treat the\n * <code>targetWidth</code> as the primary dimension and re-calculate the\n * <code>targetHeight</code> regardless of what is passed in.</li>", " * <code>targetWidth</code> as the primary dimension and re-calculate the\n * <code>targetHeight</code> regardless of what is passed in.</li>\n * <li>If image is PORTRAIT-oriented, treat the <code>targetHeight</code> as the\n * primary dimension and re-calculate the <code>targetWidth</code> regardless of\n * what is passed in.</li>\n * <li>If a {@link Mode} value of {@link Mode#FIT_TO_WIDTH} or\n * {@link Mode#FIT_TO_HEIGHT} is passed in to the <code>resize</code> method,\n * the image's orientation is ignored and the scaled image is fit to the\n * preferred dimension by using the value passed in by the user for that\n * dimension and recalculating the other (regardless of image orientation). This", " * preferred dimension by using the value passed in by the user for that\n * dimension and recalculating the other (regardless of image orientation). This\n * is useful, for example, when working with PORTRAIT oriented images that you\n * need to all be the same width or visa-versa (e.g. showing user profile\n * pictures in a directory listing).</li>\n * </ol>\n * <h3>Optimized Image Handling</h3>\n * Java2D provides support for a number of different image types defined as\n * <code>BufferedImage.TYPE_*</code> variables, unfortunately not all image\n * types are supported equally in the Java2D rendering pipeline.", " * <code>BufferedImage.TYPE_*</code> variables, unfortunately not all image\n * types are supported equally in the Java2D rendering pipeline.\n * <p/>\n * Some more obscure image types either have poor or no support, leading to\n * severely degraded quality and processing performance when an attempt is made\n * by imgscalr to create a scaled instance <em>of the same type</em> as the\n * source image. In many cases, especially when applying {@link BufferedImageOp}\n * s, using poorly supported image types can even lead to exceptions or total\n * corruption of the image (e.g. solid black image).\n * <p/>", " * corruption of the image (e.g. solid black image).\n * <p/>\n * imgscalr specifically accounts for and automatically hands\n * <strong>ALL</strong> of these pain points for you internally by shuffling all\n * images into one of two types:\n * <ol>\n * <li>{@link BufferedImage#TYPE_INT_RGB}</li>\n * <li>{@link BufferedImage#TYPE_INT_ARGB}</li>\n * </ol>\n * depending on if the source image utilizes transparency or not. This is a", " * </ol>\n * depending on if the source image utilizes transparency or not. This is a\n * recommended approach by the Java2D team for dealing with poorly (or non)\n * supported image types. More can be read about this issue <a href=\n * \"http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html\"\n * >here</a>.\n * <p/>\n * This is also the reason we recommend using\n * {@link #apply(BufferedImage, BufferedImageOp...)} to apply your own ops to\n * images even if you aren't using imgscalr for anything else.", " * {@link #apply(BufferedImage, BufferedImageOp...)} to apply your own ops to\n * images even if you aren't using imgscalr for anything else.\n * <h3>GIF Transparency</h3>\n * Unfortunately in Java 6 and earlier, support for GIF's\n * {@link IndexColorModel} is sub-par, both in accurate color-selection and in\n * maintaining transparency when moving to an image of type\n * {@link BufferedImage#TYPE_INT_ARGB}; because of this issue when a GIF image\n * is processed by imgscalr and the result saved as a GIF file (instead of PNG),\n * it is possible to lose the alpha channel of a transparent image or in the\n * case of applying an optional {@link BufferedImageOp}, lose the entire picture", " * it is possible to lose the alpha channel of a transparent image or in the\n * case of applying an optional {@link BufferedImageOp}, lose the entire picture\n * all together in the result (long standing JDK bugs are filed for all of these\n * issues).\n * <p/>\n * imgscalr currently does nothing to work around this manually because it is a\n * defect in the native platform code itself. Fortunately it looks like the\n * issues are half-fixed in Java 7 and any manual workarounds we could attempt\n * internally are relatively expensive, in the form of hand-creating and setting\n * RGB values pixel-by-pixel with a custom {@link ColorModel} in the scaled", " * internally are relatively expensive, in the form of hand-creating and setting\n * RGB values pixel-by-pixel with a custom {@link ColorModel} in the scaled\n * image. This would lead to a very measurable negative impact on performance\n * without the caller understanding why.\n * <p>\n * <strong>Workaround</strong>: A workaround to this issue with all version of\n * Java is to simply save a GIF as a PNG; no change to your code needs to be\n * made except when the image is saved out, e.g. using {@link ImageIO}.\n * <p>\n * When a file type of \"PNG\" is used, both the transparency and high color", " * <p>\n * When a file type of \"PNG\" is used, both the transparency and high color\n * quality will be maintained as the PNG code path in Java2D is superior to the\n * GIF implementation.\n * <p>\n * If the issue with optional {@link BufferedImageOp}s destroying GIF image\n * content is ever fixed in the platform, saving out resulting images as GIFs\n * should suddenly start working.\n * <p>\n * More can be read about the issue <a", " * <p>\n * More can be read about the issue <a\n * href=\"http://gman.eichberger.de/2007/07/transparent-gifs-in-java.html\"\n * >here</a> and <a\n * href=\"http://ubuntuforums.org/archive/index.php/t-1060128.html\">here</a>.\n * <h3>Thread Safety</h3>\n * The {@link Scalr} class is <strong>thread-safe</strong> (as all the methods\n * are <code>static</code>); this class maintains no internal state while\n * performing any of the provided operations and is safe to call simultaneously\n * from multiple threads.", " * performing any of the provided operations and is safe to call simultaneously\n * from multiple threads.\n * <h3>Logging</h3>\n * This class implements all its debug logging via the\n * {@link #log(int, String, Object...)} method. At this time logging is done\n * directly to <code>System.out</code> via the <code>printf</code> method. This\n * allows the logging to be light weight and easy to capture (every imgscalr log\n * message is prefixed with the {@link #LOG_PREFIX} string) while adding no\n * dependencies to the library.\n * <p/>", " * dependencies to the library.\n * <p/>\n * Implementation of logging in this class is as efficient as possible; avoiding\n * any calls to the logger method or passing of arguments if logging is not\n * enabled to avoid the (hidden) cost of constructing the Object[] argument for\n * the varargs-based method call.\n *\n * @author Riyad Kalla (software@thebuzzmedia.com)\n * @since 1.1\n */\npublic class Scalr {\n    /**\n     * System property name used to define the debug boolean flag.\n     * <p/>\n     * Value is \"<code>imgscalr.debug</code>\".\n     */", " * @since 1.1\n */\npublic class Scalr {\n    /**\n     * System property name used to define the debug boolean flag.\n     * <p/>\n     * Value is \"<code>imgscalr.debug</code>\".\n     */\n    public static final String DEBUG_PROPERTY_NAME = \"imgscalr.debug\";\n\n    /**\n     * System property name used to define a custom log prefix.\n     * <p/>\n     * Value is \"<code>imgscalr.logPrefix</code>\".\n     */", "    public static final String DEBUG_PROPERTY_NAME = \"imgscalr.debug\";\n\n    /**\n     * System property name used to define a custom log prefix.\n     * <p/>\n     * Value is \"<code>imgscalr.logPrefix</code>\".\n     */\n    public static final String LOG_PREFIX_PROPERTY_NAME = \"imgscalr.logPrefix\";\n\n    /**\n     * Flag used to indicate if debugging output has been enabled by setting the\n     * \"<code>imgscalr.debug</code>\" system property to <code>true</code>. This\n     * value will be <code>false</code> if the \"<code>imgscalr.debug</code>\"\n     * system property is undefined or set to <code>false</code>.\n     * <p/>\n     * This property can be set on startup with:<br/>\n     * <code>\n     * -Dimgscalr.debug=true\n     * </code> or by calling {@link System#setProperty(String, String)} to set a\n     * new property value for {@link #DEBUG_PROPERTY_NAME} before this class is\n     * loaded.\n     * <p/>\n     * Default value is <code>false</code>.\n     */", "    public static final boolean DEBUG = Boolean.getBoolean(DEBUG_PROPERTY_NAME);\n\n    /**\n     * Prefix to every log message this library logs. Using a well-defined\n     * prefix helps make it easier both visually and programmatically to scan\n     * log files for messages produced by this library.\n     * <p/>\n     * This property can be set on startup with:<br/>\n     * <code>\n     * -Dimgscalr.logPrefix=&lt;YOUR PREFIX HERE&gt;\n     * </code> or by calling {@link System#setProperty(String, String)} to set a\n     * new property value for {@link #LOG_PREFIX_PROPERTY_NAME} before this\n     * class is loaded.\n     * <p/>\n     * Default value is \"<code>[imgscalr] </code>\" (including the space).\n     */", "    public static final String LOG_PREFIX = System.getProperty(\n            LOG_PREFIX_PROPERTY_NAME, \"[imgscalr] \");\n\n    /**\n     * A {@link ConvolveOp} using a very light \"blur\" kernel that acts like an\n     * anti-aliasing filter (softens the image a bit) when applied to an image.\n     * <p/>\n     * A common request by users of the library was that they wished to \"soften\"\n     * resulting images when scaling them down drastically. After quite a bit of\n     * A/B testing, the kernel used by this Op was selected as the closest match\n     * for the target which was the softer results from the deprecated\n     * {@link AreaAveragingScaleFilter} (which is used internally by the\n     * deprecated {@link Image#getScaledInstance(int, int, int)} method in the\n     * JDK that imgscalr is meant to replace).\n     * <p/>\n     * This ConvolveOp uses a 3x3 kernel with the values:\n     * <table cellpadding=\"4\" border=\"1\">\n     * <tr>\n     * <td>.0f</td>\n     * <td>.08f</td>\n     * <td>.0f</td>\n     * </tr>\n     * <tr>\n     * <td>.08f</td>\n     * <td>.68f</td>\n     * <td>.08f</td>\n     * </tr>\n     * <tr>\n     * <td>.0f</td>\n     * <td>.08f</td>\n     * <td>.0f</td>\n     * </tr>\n     * </table>\n     * <p/>\n     * For those that have worked with ConvolveOps before, this Op uses the\n     * {@link ConvolveOp#EDGE_NO_OP} instruction to not process the pixels along\n     * the very edge of the image (otherwise EDGE_ZERO_FILL would create a\n     * black-border around the image). If you have not worked with a ConvolveOp\n     * before, it just means this default OP will \"do the right thing\" and not\n     * give you garbage results.\n     * <p/>\n     * This ConvolveOp uses no {@link RenderingHints} values as internally the\n     * {@link ConvolveOp} class only uses hints when doing a color conversion\n     * between the source and destination {@link BufferedImage} targets.\n     * imgscalr allows the {@link ConvolveOp} to create its own destination\n     * image every time, so no color conversion is ever needed and thus no\n     * hints.\n     * <h3>Performance</h3>\n     * Use of this (and other) {@link ConvolveOp}s are hardware accelerated when\n     * possible. For more information on if your image op is hardware\n     * accelerated or not, check the source code of the underlying JDK class\n     * that actually executes the Op code, <a href=\n     * \"http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html\"\n     * >sun.awt.image.ImagingLib</a>.\n     * <h3>Known Issues</h3>\n     * In all versions of Java (tested up to Java 7 preview Build 131), running\n     * this op against a GIF with transparency and attempting to save the\n     * resulting image as a GIF results in a corrupted/empty file. The file must\n     * be saved out as a PNG to maintain the transparency.\n     *\n     * @since 3.0\n     */", "    public static final ConvolveOp OP_ANTIALIAS = new ConvolveOp(\n            new Kernel(3, 3, new float[] { .0f, .08f, .0f, .08f, .68f, .08f,\n                    .0f, .08f, .0f }), ConvolveOp.EDGE_NO_OP, null);\n\n    /**\n     * A {@link RescaleOp} used to make any input image 10% darker.\n     * <p/>\n     * This operation can be applied multiple times in a row if greater than 10%\n     * changes in brightness are desired.\n     *\n     * @since 4.0\n     */", "    public static final RescaleOp OP_DARKER = new RescaleOp(0.9f, 0, null);\n\n    /**\n     * A {@link RescaleOp} used to make any input image 10% brighter.\n     * <p/>\n     * This operation can be applied multiple times in a row if greater than 10%\n     * changes in brightness are desired.\n     *\n     * @since 4.0\n     */\n    public static final RescaleOp OP_BRIGHTER = new RescaleOp(1.1f, 0, null);\n\n    /**\n     * A {@link ColorConvertOp} used to convert any image to a grayscale color\n     * palette.\n     * <p/>\n     * Applying this op multiple times to the same image has no compounding\n     * effects.\n     *\n     * @since 4.0\n     */", "    public static final RescaleOp OP_BRIGHTER = new RescaleOp(1.1f, 0, null);\n\n    /**\n     * A {@link ColorConvertOp} used to convert any image to a grayscale color\n     * palette.\n     * <p/>\n     * Applying this op multiple times to the same image has no compounding\n     * effects.\n     *\n     * @since 4.0\n     */", "    public static final ColorConvertOp OP_GRAYSCALE = new ColorConvertOp(\n            ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n\n    /**\n     * Static initializer used to prepare some of the variables used by this\n     * class.\n     */\n    static {\n        log(0, \"Debug output ENABLED\");\n    }\n\n    /**\n     * Used to define the different scaling hints that the algorithm can use.\n     *\n     * @author Riyad Kalla (software@thebuzzmedia.com)\n     * @since 1.1\n     */", "    public static enum Method {\n        /**\n         * Used to indicate that the scaling implementation should decide which\n         * method to use in order to get the best looking scaled image in the\n         * least amount of time.\n         * <p/>\n         * The scaling algorithm will use the\n         * {@link Scalr#THRESHOLD_QUALITY_BALANCED} or\n         * {@link Scalr#THRESHOLD_BALANCED_SPEED} thresholds as cut-offs to\n         * decide between selecting the <code>QUALITY</code>,\n         * <code>BALANCED</code> or <code>SPEED</code> scaling algorithms.\n         * <p/>\n         * By default the thresholds chosen will give nearly the best looking\n         * result in the fastest amount of time. We intend this method to work\n         * for 80% of people looking to scale an image quickly and get a good\n         * looking result.\n         */\n        AUTOMATIC,\n        /**\n         * Used to indicate that the scaling implementation should scale as fast\n         * as possible and return a result. For smaller images (800px in size)\n         * this can result in noticeable aliasing but it can be a few magnitudes\n         * times faster than using the QUALITY method.\n         */\n        SPEED,\n        /**\n         * Used to indicate that the scaling implementation should use a scaling\n         * operation balanced between SPEED and QUALITY. Sometimes SPEED looks\n         * too low quality to be useful (e.g. text can become unreadable when\n         * scaled using SPEED) but using QUALITY mode will increase the\n         * processing time too much. This mode provides a \"better than SPEED\"\n         * quality in a \"less than QUALITY\" amount of time.\n         */\n        BALANCED,\n        /**\n         * Used to indicate that the scaling implementation should do everything\n         * it can to create as nice of a result as possible. This approach is\n         * most important for smaller pictures (800px or smaller) and less\n         * important for larger pictures as the difference between this method\n         * and the SPEED method become less and less noticeable as the\n         * source-image size increases. Using the AUTOMATIC method will\n         * automatically prefer the QUALITY method when scaling an image down\n         * below 800px in size.\n         */\n        QUALITY,\n        /**\n         * Used to indicate that the scaling implementation should go above and\n         * beyond the work done by {@link Method#QUALITY} to make the image look\n         * exceptionally good at the cost of more processing time. This is\n         * especially evident when generating thumbnails of images that look\n         * jagged with some of the other {@link Method}s (even\n         * {@link Method#QUALITY}).\n         */\n        ULTRA_QUALITY;\n    }\n\n    /**\n     * Used to define the different modes of resizing that the algorithm can\n     * use.\n     *\n     * @author Riyad Kalla (software@thebuzzmedia.com)\n     * @since 3.1\n     */", "    public static enum Mode {\n        /**\n         * Used to indicate that the scaling implementation should calculate\n         * dimensions for the resultant image by looking at the image's\n         * orientation and generating proportional dimensions that best fit into\n         * the target width and height given\n         *\n         * See \"Image Proportions\" in the {@link Scalr} class description for\n         * more detail.\n         */\n        AUTOMATIC,\n        /**\n         * Used to fit the image to the exact dimensions given regardless of the\n         * image's proportions. If the dimensions are not proportionally\n         * correct, this will introduce vertical or horizontal stretching to the\n         * image.\n         * <p/>\n         * It is recommended that you use one of the other <code>FIT_TO</code>\n         * modes or {@link Mode#AUTOMATIC} if you want the image to look\n         * correct, but if dimension-fitting is the #1 priority regardless of\n         * how it makes the image look, that is what this mode is for.\n         */\n        FIT_EXACT,\n        /**\n         * Used to indicate that the scaling implementation should calculate\n         * dimensions for the largest image that fit within the bounding box,\n         * without cropping or distortion, retaining the original proportions.\n         */\n        BEST_FIT_BOTH,\n        /**\n         * Used to indicate that the scaling implementation should calculate\n         * dimensions for the resultant image that best-fit within the given\n         * width, regardless of the orientation of the image.\n         */\n        FIT_TO_WIDTH,\n        /**\n         * Used to indicate that the scaling implementation should calculate\n         * dimensions for the resultant image that best-fit within the given\n         * height, regardless of the orientation of the image.\n         */\n        FIT_TO_HEIGHT;\n    }\n\n    /**\n     * Used to define the different types of rotations that can be applied to an\n     * image during a resize operation.\n     *\n     * @author Riyad Kalla (software@thebuzzmedia.com)\n     * @since 3.2\n     */", "    public static enum Rotation {\n        /**\n         * 90-degree, clockwise rotation (to the right). This is equivalent to a\n         * quarter-turn of the image to the right; moving the picture on to its\n         * right side.\n         */\n        CW_90,\n        /**\n         * 180-degree, clockwise rotation (to the right). This is equivalent to\n         * 1 half-turn of the image to the right; rotating the picture around\n         * until it is upside down from the original position.\n         */\n        CW_180,\n        /**\n         * 270-degree, clockwise rotation (to the right). This is equivalent to\n         * a quarter-turn of the image to the left; moving the picture on to its\n         * left side.\n         */\n        CW_270,\n        /**\n         * Flip the image horizontally by reflecting it around the y axis.\n         * <p/>\n         * This is not a standard rotation around a center point, but instead\n         * creates the mirrored reflection of the image horizontally.\n         * <p/>\n         * More specifically, the vertical orientation of the image stays the\n         * same (the top stays on top, and the bottom on bottom), but the right\n         * and left sides flip. This is different than a standard rotation where\n         * the top and bottom would also have been flipped.\n         */\n        FLIP_HORZ,\n        /**\n         * Flip the image vertically by reflecting it around the x axis.\n         * <p/>\n         * This is not a standard rotation around a center point, but instead\n         * creates the mirrored reflection of the image vertically.\n         * <p/>\n         * More specifically, the horizontal orientation of the image stays the\n         * same (the left stays on the left and the right stays on the right),\n         * but the top and bottom sides flip. This is different than a standard\n         * rotation where the left and right would also have been flipped.\n         */\n        FLIP_VERT;\n    }\n\n    /**\n     * Threshold (in pixels) at which point the scaling operation using the\n     * {@link Method#AUTOMATIC} method will decide if a {@link Method#BALANCED}\n     * method will be used (if smaller than or equal to threshold) or a\n     * {@link Method#SPEED} method will be used (if larger than threshold).\n     * <p/>\n     * The bigger the image is being scaled to, the less noticeable degradations\n     * in the image becomes and the faster algorithms can be selected.\n     * <p/>\n     * The value of this threshold (1600) was chosen after visual, by-hand, A/B\n     * testing between different types of images scaled with this library; both\n     * photographs and screenshots. It was determined that images below this\n     * size need to use a {@link Method#BALANCED} scale method to look decent in\n     * most all cases while using the faster {@link Method#SPEED} method for\n     * images bigger than this threshold showed no noticeable degradation over a\n     * <code>BALANCED</code> scale.\n     */", "    public static final int THRESHOLD_BALANCED_SPEED = 1600;\n\n    /**\n     * Threshold (in pixels) at which point the scaling operation using the\n     * {@link Method#AUTOMATIC} method will decide if a {@link Method#QUALITY}\n     * method will be used (if smaller than or equal to threshold) or a\n     * {@link Method#BALANCED} method will be used (if larger than threshold).\n     * <p/>\n     * The bigger the image is being scaled to, the less noticeable degradations\n     * in the image becomes and the faster algorithms can be selected.\n     * <p/>\n     * The value of this threshold (800) was chosen after visual, by-hand, A/B\n     * testing between different types of images scaled with this library; both\n     * photographs and screenshots. It was determined that images below this\n     * size need to use a {@link Method#QUALITY} scale method to look decent in\n     * most all cases while using the faster {@link Method#BALANCED} method for\n     * images bigger than this threshold showed no noticeable degradation over a\n     * <code>QUALITY</code> scale.\n     */", "    public static final int THRESHOLD_QUALITY_BALANCED = 800;\n\n    /**\n     * Used to apply, in the order given, 1 or more {@link BufferedImageOp}s to\n     * a given {@link BufferedImage} and return the result.\n     * <p/>\n     * <strong>Feature</strong>: This implementation works around <a\n     * href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606\">a\n     * decade-old JDK bug</a> that can cause a {@link RasterFormatException}\n     * when applying a perfectly valid {@link BufferedImageOp}s to images.\n     * <p/>\n     * <strong>Feature</strong>: This implementation also works around\n     * {@link BufferedImageOp}s failing to apply and throwing\n     * {@link ImagingOpException}s when run against a <code>src</code> image\n     * type that is poorly supported. Unfortunately using {@link ImageIO} and\n     * standard Java methods to load images provides no consistency in getting\n     * images in well-supported formats. This method automatically accounts and\n     * corrects for all those problems (if necessary).\n     * <p/>\n     * It is recommended you always use this method to apply any\n     * {@link BufferedImageOp}s instead of relying on directly using the\n     * {@link BufferedImageOp#filter(BufferedImage, BufferedImage)} method.\n     * <p/>\n     * <strong>Performance</strong>: Not all {@link BufferedImageOp}s are\n     * hardware accelerated operations, but many of the most popular (like\n     * {@link ConvolveOp}) are. For more information on if your image op is\n     * hardware accelerated or not, check the source code of the underlying JDK\n     * class that actually executes the Op code, <a href=\n     * \"http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html\"\n     * >sun.awt.image.ImagingLib</a>.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will have the ops applied to it.\n     * @param ops\n     *            <code>1</code> or more ops to apply to the image.\n     *\n     * @return a new {@link BufferedImage} that represents the <code>src</code>\n     *         with all the given operations applied to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>ops</code> is <code>null</code> or empty.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage apply(BufferedImage src, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        long t = -1;\n        if (DEBUG)\n            t = System.currentTimeMillis();\n\n        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (ops == null || ops.length == 0)\n            throw new IllegalArgumentException(\"ops cannot be null or empty\");\n\n        int type = src.getType();\n\n        /*\n         * Ensure the src image is in the best supported image type before we\n         * continue, otherwise it is possible our calls below to getBounds2D and\n         * certainly filter(...) may fail if not.\n         *\n         * Java2D makes an attempt at applying most BufferedImageOps using\n         * hardware acceleration via the ImagingLib internal library.\n         *\n         * Unfortunately may of the BufferedImageOp are written to simply fail\n         * with an ImagingOpException if the operation cannot be applied with no\n         * additional information about what went wrong or attempts at\n         * re-applying it in different ways.\n         *\n         * This is assuming the failing BufferedImageOp even returns a null\n         * image after failing to apply; some simply return a corrupted/black\n         * image that result in no exception and it is up to the user to\n         * discover this.\n         *\n         * In internal testing, EVERY failure I've ever seen was the result of\n         * the source image being in a poorly-supported BufferedImage Type like\n         * BGR or ABGR (even though it was loaded with ImageIO).\n         *\n         * To avoid this nasty/stupid surprise with BufferedImageOps, we always\n         * ensure that the src image starts in an optimally supported format\n         * before we try and apply the filter.\n         */", "        if (ops == null || ops.length == 0)\n            throw new IllegalArgumentException(\"ops cannot be null or empty\");\n\n        int type = src.getType();\n\n        /*\n         * Ensure the src image is in the best supported image type before we\n         * continue, otherwise it is possible our calls below to getBounds2D and\n         * certainly filter(...) may fail if not.\n         *\n         * Java2D makes an attempt at applying most BufferedImageOps using\n         * hardware acceleration via the ImagingLib internal library.\n         *\n         * Unfortunately may of the BufferedImageOp are written to simply fail\n         * with an ImagingOpException if the operation cannot be applied with no\n         * additional information about what went wrong or attempts at\n         * re-applying it in different ways.\n         *\n         * This is assuming the failing BufferedImageOp even returns a null\n         * image after failing to apply; some simply return a corrupted/black\n         * image that result in no exception and it is up to the user to\n         * discover this.\n         *\n         * In internal testing, EVERY failure I've ever seen was the result of\n         * the source image being in a poorly-supported BufferedImage Type like\n         * BGR or ABGR (even though it was loaded with ImageIO).\n         *\n         * To avoid this nasty/stupid surprise with BufferedImageOps, we always\n         * ensure that the src image starts in an optimally supported format\n         * before we try and apply the filter.\n         */", "        if (!(type == BufferedImage.TYPE_INT_RGB || type == BufferedImage.TYPE_INT_ARGB))\n            src = copyToOptimalImage(src);\n\n        if (DEBUG)\n            log(0, \"Applying %d BufferedImageOps...\", ops.length);\n\n        boolean hasReassignedSrc = false;\n\n        for (int i = 0; i < ops.length; i++) {\n            long subT = -1;\n            if (DEBUG)\n                subT = System.currentTimeMillis();\n            BufferedImageOp op = ops[i];\n\n            // Skip null ops instead of throwing an exception.", "        for (int i = 0; i < ops.length; i++) {\n            long subT = -1;\n            if (DEBUG)\n                subT = System.currentTimeMillis();\n            BufferedImageOp op = ops[i];\n\n            // Skip null ops instead of throwing an exception.\n            if (op == null)\n                continue;\n\n            if (DEBUG)\n                log(1, \"Applying BufferedImageOp [class=%s, toString=%s]...\",\n                        op.getClass(), op.toString());\n\n            /*\n             * Must use op.getBounds instead of src.getWidth and src.getHeight\n             * because we are trying to create an image big enough to hold the\n             * result of this operation (which may be to scale the image\n             * smaller), in that case the bounds reported by this op and the\n             * bounds reported by the source image will be different.\n             */\n            Rectangle2D resultBounds = op.getBounds2D(src);\n\n            // Watch out for flaky/misbehaving ops that fail to work right.", "            if (DEBUG)\n                log(1, \"Applying BufferedImageOp [class=%s, toString=%s]...\",\n                        op.getClass(), op.toString());\n\n            /*\n             * Must use op.getBounds instead of src.getWidth and src.getHeight\n             * because we are trying to create an image big enough to hold the\n             * result of this operation (which may be to scale the image\n             * smaller), in that case the bounds reported by this op and the\n             * bounds reported by the source image will be different.\n             */\n            Rectangle2D resultBounds = op.getBounds2D(src);\n\n            // Watch out for flaky/misbehaving ops that fail to work right.", "            if (resultBounds == null)\n                throw new ImagingOpException(\n                        \"BufferedImageOp [\"\n                                + op.toString()\n                                + \"] getBounds2D(src) returned null bounds for the target image; this should not happen and indicates a problem with application of this type of op.\");\n\n            /*\n             * We must manually create the target image; we cannot rely on the\n             * null-destination filter() method to create a valid destination\n             * for us thanks to this JDK bug that has been filed for almost a\n             * decade:\n             * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606\n             */\n            BufferedImage dest = createOptimalImage(src,\n                    (int) Math.round(resultBounds.getWidth()),\n                    (int) Math.round(resultBounds.getHeight()));\n\n            // Perform the operation, update our result to return.\n            BufferedImage result = op.filter(src, dest);\n\n            /*\n             * Flush the 'src' image ONLY IF it is one of our interim temporary\n             * images being used when applying 2 or more operations back to\n             * back. We never want to flush the original image passed in.\n             */", "            if (hasReassignedSrc)\n                src.flush();\n\n            /*\n             * Incase there are more operations to perform, update what we\n             * consider the 'src' reference to our last result so on the next\n             * iteration the next op is applied to this result and not back\n             * against the original src passed in.\n             */\n            src = result;\n\n            /*\n             * Keep track of when we re-assign 'src' to an interim temporary\n             * image, so we know when we can explicitly flush it and clean up\n             * references on future iterations.\n             */\n            hasReassignedSrc = true;\n", "            if (DEBUG)\n                log(1,\n                        \"Applied BufferedImageOp in %d ms, result [width=%d, height=%d]\",\n                        System.currentTimeMillis() - subT, result.getWidth(),\n                        result.getHeight());\n        }\n\n        if (DEBUG)\n            log(0, \"All %d BufferedImageOps applied in %d ms\", ops.length,\n                    System.currentTimeMillis() - t);\n\n        return src;\n    }\n\n    /**\n     * Used to crop the given <code>src</code> image from the top-left corner\n     * and applying any optional {@link BufferedImageOp}s to the result before\n     * returning it.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image to crop.\n     * @param width\n     *            The width of the bounding cropping box.\n     * @param height\n     *            The height of the bounding cropping box.\n     * @param ops\n     *            <code>0</code> or more ops to apply to the image. If\n     *            <code>null</code> or empty then <code>src</code> is return\n     *            unmodified.\n     *\n     * @return a new {@link BufferedImage} representing the cropped region of\n     *         the <code>src</code> image with any optional operations applied\n     *         to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if any coordinates of the bounding crop box is invalid within\n     *             the bounds of the <code>src</code> image (e.g. negative or\n     *             too big).\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage crop(BufferedImage src, int width, int height,\n                                     BufferedImageOp... ops) throws IllegalArgumentException,\n            ImagingOpException {\n        return crop(src, 0, 0, width, height, ops);\n    }\n\n    /**\n     * Used to crop the given <code>src</code> image and apply any optional\n     * {@link BufferedImageOp}s to it before returning the result.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image to crop.\n     * @param x\n     *            The x-coordinate of the top-left corner of the bounding box\n     *            used for cropping.\n     * @param y\n     *            The y-coordinate of the top-left corner of the bounding box\n     *            used for cropping.\n     * @param width\n     *            The width of the bounding cropping box.\n     * @param height\n     *            The height of the bounding cropping box.\n     * @param ops\n     *            <code>0</code> or more ops to apply to the image. If\n     *            <code>null</code> or empty then <code>src</code> is return\n     *            unmodified.\n     *\n     * @return a new {@link BufferedImage} representing the cropped region of\n     *         the <code>src</code> image with any optional operations applied\n     *         to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if any coordinates of the bounding crop box is invalid within\n     *             the bounds of the <code>src</code> image (e.g. negative or\n     *             too big).\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage crop(BufferedImage src, int x, int y,\n                                     int width, int height, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        long t = -1;\n        if (DEBUG)\n            t = System.currentTimeMillis();\n\n        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (x < 0 || y < 0 || width < 0 || height < 0)\n            throw new IllegalArgumentException(\"Invalid crop bounds: x [\" + x\n                    + \"], y [\" + y + \"], width [\" + width + \"] and height [\"\n                    + height + \"] must all be >= 0\");\n\n        int srcWidth = src.getWidth();\n        int srcHeight = src.getHeight();\n", "        if (x < 0 || y < 0 || width < 0 || height < 0)\n            throw new IllegalArgumentException(\"Invalid crop bounds: x [\" + x\n                    + \"], y [\" + y + \"], width [\" + width + \"] and height [\"\n                    + height + \"] must all be >= 0\");\n\n        int srcWidth = src.getWidth();\n        int srcHeight = src.getHeight();\n\n        if ((x + width) > srcWidth)\n            throw new IllegalArgumentException(\n                    \"Invalid crop bounds: x + width [\" + (x + width)\n                            + \"] must be <= src.getWidth() [\" + srcWidth + \"]\");", "        if ((x + width) > srcWidth)\n            throw new IllegalArgumentException(\n                    \"Invalid crop bounds: x + width [\" + (x + width)\n                            + \"] must be <= src.getWidth() [\" + srcWidth + \"]\");\n        if ((y + height) > srcHeight)\n            throw new IllegalArgumentException(\n                    \"Invalid crop bounds: y + height [\" + (y + height)\n                            + \"] must be <= src.getHeight() [\" + srcHeight\n                            + \"]\");\n\n        if (DEBUG)\n            log(0,\n                    \"Cropping Image [width=%d, height=%d] to [x=%d, y=%d, width=%d, height=%d]...\",\n                    srcWidth, srcHeight, x, y, width, height);\n\n        // Create a target image of an optimal type to render into.\n        BufferedImage result = createOptimalImage(src, width, height);\n        Graphics g = result.getGraphics();\n\n        /*\n         * Render the region specified by our crop bounds from the src image\n         * directly into our result image (which is the exact size of the crop\n         * region).\n         */\n        g.drawImage(src, 0, 0, width, height, x, y, (x + width), (y + height),\n                null);\n        g.dispose();\n", "        if (DEBUG)\n            log(0,\n                    \"Cropping Image [width=%d, height=%d] to [x=%d, y=%d, width=%d, height=%d]...\",\n                    srcWidth, srcHeight, x, y, width, height);\n\n        // Create a target image of an optimal type to render into.\n        BufferedImage result = createOptimalImage(src, width, height);\n        Graphics g = result.getGraphics();\n\n        /*\n         * Render the region specified by our crop bounds from the src image\n         * directly into our result image (which is the exact size of the crop\n         * region).\n         */\n        g.drawImage(src, 0, 0, width, height, x, y, (x + width), (y + height),\n                null);\n        g.dispose();\n", "        if (DEBUG)\n            log(0, \"Cropped Image in %d ms\", System.currentTimeMillis() - t);\n\n        // Apply any optional operations (if specified).\n        if (ops != null && ops.length > 0)\n            result = apply(result, ops);\n\n        return result;\n    }\n\n    /**\n     * Used to apply padding around the edges of an image using\n     * {@link Color#BLACK} to fill the extra padded space and then return the\n     * result.\n     * <p/>\n     * The amount of <code>padding</code> specified is applied to all sides;\n     * more specifically, a <code>padding</code> of <code>2</code> would add 2\n     * extra pixels of space (filled by the given <code>color</code>) on the\n     * top, bottom, left and right sides of the resulting image causing the\n     * result to be 4 pixels wider and 4 pixels taller than the <code>src</code>\n     * image.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image the padding will be added to.\n     * @param padding\n     *            The number of pixels of padding to add to each side in the\n     *            resulting image. If this value is <code>0</code> then\n     *            <code>src</code> is returned unmodified.\n     * @param ops\n     *            <code>0</code> or more ops to apply to the image. If\n     *            <code>null</code> or empty then <code>src</code> is return\n     *            unmodified.\n     *\n     * @return a new {@link BufferedImage} representing <code>src</code> with\n     *         the given padding applied to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>padding</code> is &lt; <code>1</code>.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage pad(BufferedImage src, int padding,\n                                    BufferedImageOp... ops) throws IllegalArgumentException,\n            ImagingOpException {\n        return pad(src, padding, Color.BLACK);\n    }\n\n    /**\n     * Used to apply padding around the edges of an image using the given color\n     * to fill the extra padded space and then return the result. {@link Color}s\n     * using an alpha channel (i.e. transparency) are supported.\n     * <p/>\n     * The amount of <code>padding</code> specified is applied to all sides;\n     * more specifically, a <code>padding</code> of <code>2</code> would add 2\n     * extra pixels of space (filled by the given <code>color</code>) on the\n     * top, bottom, left and right sides of the resulting image causing the\n     * result to be 4 pixels wider and 4 pixels taller than the <code>src</code>\n     * image.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image the padding will be added to.\n     * @param padding\n     *            The number of pixels of padding to add to each side in the\n     *            resulting image. If this value is <code>0</code> then\n     *            <code>src</code> is returned unmodified.\n     * @param color\n     *            The color to fill the padded space with. {@link Color}s using\n     *            an alpha channel (i.e. transparency) are supported.\n     * @param ops\n     *            <code>0</code> or more ops to apply to the image. If\n     *            <code>null</code> or empty then <code>src</code> is return\n     *            unmodified.\n     *\n     * @return a new {@link BufferedImage} representing <code>src</code> with\n     *         the given padding applied to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>padding</code> is &lt; <code>1</code>.\n     * @throws IllegalArgumentException\n     *             if <code>color</code> is <code>null</code>.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage pad(BufferedImage src, int padding,\n                                    Color color, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        long t = -1;\n        if (DEBUG)\n            t = System.currentTimeMillis();\n\n        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (padding < 1)\n            throw new IllegalArgumentException(\"padding [\" + padding\n                    + \"] must be > 0\");", "        if (padding < 1)\n            throw new IllegalArgumentException(\"padding [\" + padding\n                    + \"] must be > 0\");\n        if (color == null)\n            throw new IllegalArgumentException(\"color cannot be null\");\n\n        int srcWidth = src.getWidth();\n        int srcHeight = src.getHeight();\n\n        /*\n         * Double the padding to account for all sides of the image. More\n         * specifically, if padding is \"1\" we add 2 pixels to width and 2 to\n         * height, so we have 1 new pixel of padding all the way around our\n         * image.\n         */\n        int sizeDiff = (padding * 2);\n        int newWidth = srcWidth + sizeDiff;\n        int newHeight = srcHeight + sizeDiff;\n", "        if (DEBUG)\n            log(0,\n                    \"Padding Image from [originalWidth=%d, originalHeight=%d, padding=%d] to [newWidth=%d, newHeight=%d]...\",\n                    srcWidth, srcHeight, padding, newWidth, newHeight);\n\n        boolean colorHasAlpha = (color.getAlpha() != 255);\n        boolean imageHasAlpha = (src.getTransparency() != BufferedImage.OPAQUE);\n\n        BufferedImage result;\n\n        /*\n         * We need to make sure our resulting image that we render into contains\n         * alpha if either our original image OR the padding color we are using\n         * contain it.\n         */", "        if (colorHasAlpha || imageHasAlpha) {\n            if (DEBUG)\n                log(1,\n                        \"Transparency FOUND in source image or color, using ARGB image type...\");\n\n            result = new BufferedImage(newWidth, newHeight,\n                    BufferedImage.TYPE_INT_ARGB);\n        } else {\n            if (DEBUG)\n                log(1,\n                        \"Transparency NOT FOUND in source image or color, using RGB image type...\");\n\n            result = new BufferedImage(newWidth, newHeight,\n                    BufferedImage.TYPE_INT_RGB);\n        }\n\n        Graphics g = result.getGraphics();\n\n        // Draw the border of the image in the color specified.\n        g.setColor(color);\n        g.fillRect(0, 0, newWidth, padding);\n        g.fillRect(0, padding, padding, newHeight);\n        g.fillRect(padding, newHeight - padding, newWidth, newHeight);\n        g.fillRect(newWidth - padding, padding, newWidth, newHeight - padding);\n\n        // Draw the image into the center of the new padded image.\n        g.drawImage(src, padding, padding, null);\n        g.dispose();\n", "            if (DEBUG)\n                log(1,\n                        \"Transparency NOT FOUND in source image or color, using RGB image type...\");\n\n            result = new BufferedImage(newWidth, newHeight,\n                    BufferedImage.TYPE_INT_RGB);\n        }\n\n        Graphics g = result.getGraphics();\n\n        // Draw the border of the image in the color specified.\n        g.setColor(color);\n        g.fillRect(0, 0, newWidth, padding);\n        g.fillRect(0, padding, padding, newHeight);\n        g.fillRect(padding, newHeight - padding, newWidth, newHeight);\n        g.fillRect(newWidth - padding, padding, newWidth, newHeight - padding);\n\n        // Draw the image into the center of the new padded image.\n        g.drawImage(src, padding, padding, null);\n        g.dispose();\n", "        if (DEBUG)\n            log(0, \"Padding Applied in %d ms\", System.currentTimeMillis() - t);\n\n        // Apply any optional operations (if specified).\n        if (ops != null && ops.length > 0)\n            result = apply(result, ops);\n\n        return result;\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to a width and\n     * height no bigger than <code>targetSize</code> and apply the given\n     * {@link BufferedImageOp}s (if any) to the result before returning it.\n     * <p/>\n     * A scaling method of {@link Method#AUTOMATIC} and mode of\n     * {@link Mode#AUTOMATIC} are used.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param targetSize\n     *            The target width and height (square) that you wish the image\n     *            to fit within.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetSize</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage resize(BufferedImage src, int targetSize,\n                                       BufferedImageOp... ops) throws IllegalArgumentException,\n            ImagingOpException {\n        return resize(src, Method.AUTOMATIC, Mode.AUTOMATIC, targetSize,\n                targetSize, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to a width and\n     * height no bigger than <code>targetSize</code> using the given scaling\n     * method and apply the given {@link BufferedImageOp}s (if any) to the\n     * result before returning it.\n     * <p/>\n     * A mode of {@link Mode#AUTOMATIC} is used.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param scalingMethod\n     *            The method used for scaling the image; preferring speed to\n     *            quality or a balance of both.\n     * @param targetSize\n     *            The target width and height (square) that you wish the image\n     *            to fit within.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>scalingMethod</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetSize</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Method\n     */", "    public static BufferedImage resize(BufferedImage src, Method scalingMethod,\n                                       int targetSize, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        return resize(src, scalingMethod, Mode.AUTOMATIC, targetSize,\n                targetSize, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to a width and\n     * height no bigger than <code>targetSize</code> (or fitting the image to\n     * the given WIDTH or HEIGHT explicitly, depending on the {@link Mode}\n     * specified) and apply the given {@link BufferedImageOp}s (if any) to the\n     * result before returning it.\n     * <p/>\n     * A scaling method of {@link Method#AUTOMATIC} is used.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param resizeMode\n     *            Used to indicate how imgscalr should calculate the final\n     *            target size for the image, either fitting the image to the\n     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image\n     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If\n     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate\n     *            proportional dimensions for the scaled image based on its\n     *            orientation (landscape, square or portrait). Unless you have\n     *            very specific size requirements, most of the time you just\n     *            want to use {@link Mode#AUTOMATIC} to \"do the right thing\".\n     * @param targetSize\n     *            The target width and height (square) that you wish the image\n     *            to fit within.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>resizeMode</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetSize</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Mode\n     */", "    public static BufferedImage resize(BufferedImage src, Mode resizeMode,\n                                       int targetSize, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        return resize(src, Method.AUTOMATIC, resizeMode, targetSize,\n                targetSize, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to a width and\n     * height no bigger than <code>targetSize</code> (or fitting the image to\n     * the given WIDTH or HEIGHT explicitly, depending on the {@link Mode}\n     * specified) using the given scaling method and apply the given\n     * {@link BufferedImageOp}s (if any) to the result before returning it.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param scalingMethod\n     *            The method used for scaling the image; preferring speed to\n     *            quality or a balance of both.\n     * @param resizeMode\n     *            Used to indicate how imgscalr should calculate the final\n     *            target size for the image, either fitting the image to the\n     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image\n     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If\n     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate\n     *            proportional dimensions for the scaled image based on its\n     *            orientation (landscape, square or portrait). Unless you have\n     *            very specific size requirements, most of the time you just\n     *            want to use {@link Mode#AUTOMATIC} to \"do the right thing\".\n     * @param targetSize\n     *            The target width and height (square) that you wish the image\n     *            to fit within.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>scalingMethod</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>resizeMode</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetSize</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Method\n     * @see Mode\n     */", "    public static BufferedImage resize(BufferedImage src, Method scalingMethod,\n                                       Mode resizeMode, int targetSize, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        return resize(src, scalingMethod, resizeMode, targetSize, targetSize,\n                ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to the target\n     * width and height and apply the given {@link BufferedImageOp}s (if any) to\n     * the result before returning it.\n     * <p/>\n     * A scaling method of {@link Method#AUTOMATIC} and mode of\n     * {@link Mode#AUTOMATIC} are used.\n     * <p/>\n     * <strong>TIP</strong>: See the class description to understand how this\n     * class handles recalculation of the <code>targetWidth</code> or\n     * <code>targetHeight</code> depending on the image's orientation in order\n     * to maintain the original proportion.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param targetWidth\n     *            The target width that you wish the image to have.\n     * @param targetHeight\n     *            The target height that you wish the image to have.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetWidth</code> is &lt; 0 or if\n     *             <code>targetHeight</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     */", "    public static BufferedImage resize(BufferedImage src, int targetWidth,\n                                       int targetHeight, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        return resize(src, Method.AUTOMATIC, Mode.AUTOMATIC, targetWidth,\n                targetHeight, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to the target\n     * width and height using the given scaling method and apply the given\n     * {@link BufferedImageOp}s (if any) to the result before returning it.\n     * <p/>\n     * A mode of {@link Mode#AUTOMATIC} is used.\n     * <p/>\n     * <strong>TIP</strong>: See the class description to understand how this\n     * class handles recalculation of the <code>targetWidth</code> or\n     * <code>targetHeight</code> depending on the image's orientation in order\n     * to maintain the original proportion.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param scalingMethod\n     *            The method used for scaling the image; preferring speed to\n     *            quality or a balance of both.\n     * @param targetWidth\n     *            The target width that you wish the image to have.\n     * @param targetHeight\n     *            The target height that you wish the image to have.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>scalingMethod</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetWidth</code> is &lt; 0 or if\n     *             <code>targetHeight</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Method\n     */", "    public static BufferedImage resize(BufferedImage src, Method scalingMethod,\n                                       int targetWidth, int targetHeight, BufferedImageOp... ops) {\n        return resize(src, scalingMethod, Mode.AUTOMATIC, targetWidth,\n                targetHeight, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to the target\n     * width and height (or fitting the image to the given WIDTH or HEIGHT\n     * explicitly, depending on the {@link Mode} specified) and apply the given\n     * {@link BufferedImageOp}s (if any) to the result before returning it.\n     * <p/>\n     * A scaling method of {@link Method#AUTOMATIC} is used.\n     * <p/>\n     * <strong>TIP</strong>: See the class description to understand how this\n     * class handles recalculation of the <code>targetWidth</code> or\n     * <code>targetHeight</code> depending on the image's orientation in order\n     * to maintain the original proportion.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param resizeMode\n     *            Used to indicate how imgscalr should calculate the final\n     *            target size for the image, either fitting the image to the\n     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image\n     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If\n     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate\n     *            proportional dimensions for the scaled image based on its\n     *            orientation (landscape, square or portrait). Unless you have\n     *            very specific size requirements, most of the time you just\n     *            want to use {@link Mode#AUTOMATIC} to \"do the right thing\".\n     * @param targetWidth\n     *            The target width that you wish the image to have.\n     * @param targetHeight\n     *            The target height that you wish the image to have.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>resizeMode</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetWidth</code> is &lt; 0 or if\n     *             <code>targetHeight</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Mode\n     */", "    public static BufferedImage resize(BufferedImage src, Mode resizeMode,\n                                       int targetWidth, int targetHeight, BufferedImageOp... ops)\n            throws IllegalArgumentException, ImagingOpException {\n        return resize(src, Method.AUTOMATIC, resizeMode, targetWidth,\n                targetHeight, ops);\n    }\n\n    /**\n     * Resize a given image (maintaining its original proportion) to the target\n     * width and height (or fitting the image to the given WIDTH or HEIGHT\n     * explicitly, depending on the {@link Mode} specified) using the given\n     * scaling method and apply the given {@link BufferedImageOp}s (if any) to\n     * the result before returning it.\n     * <p/>\n     * <strong>TIP</strong>: See the class description to understand how this\n     * class handles recalculation of the <code>targetWidth</code> or\n     * <code>targetHeight</code> depending on the image's orientation in order\n     * to maintain the original proportion.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param scalingMethod\n     *            The method used for scaling the image; preferring speed to\n     *            quality or a balance of both.\n     * @param resizeMode\n     *            Used to indicate how imgscalr should calculate the final\n     *            target size for the image, either fitting the image to the\n     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image\n     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If\n     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate\n     *            proportional dimensions for the scaled image based on its\n     *            orientation (landscape, square or portrait). Unless you have\n     *            very specific size requirements, most of the time you just\n     *            want to use {@link Mode#AUTOMATIC} to \"do the right thing\".\n     * @param targetWidth\n     *            The target width that you wish the image to have.\n     * @param targetHeight\n     *            The target height that you wish the image to have.\n     * @param ops\n     *            <code>0</code> or more optional image operations (e.g.\n     *            sharpen, blur, etc.) that can be applied to the final result\n     *            before returning the image.\n     *\n     * @return a new {@link BufferedImage} representing the scaled\n     *         <code>src</code> image.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>scalingMethod</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>resizeMode</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>targetWidth</code> is &lt; 0 or if\n     *             <code>targetHeight</code> is &lt; 0.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Method\n     * @see Mode\n     */", "    public static BufferedImage resize(BufferedImage src, Method scalingMethod,\n                                       Mode resizeMode, int targetWidth, int targetHeight,\n                                       BufferedImageOp... ops) throws IllegalArgumentException,\n            ImagingOpException {\n        long t = -1;\n        if (DEBUG)\n            t = System.currentTimeMillis();\n\n        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (targetWidth < 0)\n            throw new IllegalArgumentException(\"targetWidth must be >= 0\");", "        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (targetWidth < 0)\n            throw new IllegalArgumentException(\"targetWidth must be >= 0\");\n        if (targetHeight < 0)\n            throw new IllegalArgumentException(\"targetHeight must be >= 0\");\n        if (scalingMethod == null)\n            throw new IllegalArgumentException(\n                    \"scalingMethod cannot be null. A good default value is Method.AUTOMATIC.\");\n        if (resizeMode == null)\n            throw new IllegalArgumentException(\n                    \"resizeMode cannot be null. A good default value is Mode.AUTOMATIC.\");\n\n        BufferedImage result = null;\n\n        int currentWidth = src.getWidth();\n        int currentHeight = src.getHeight();\n\n        // <= 1 is a square or landscape-oriented image, > 1 is a portrait.\n        float ratio = ((float) currentHeight / (float) currentWidth);\n", "        if (resizeMode == null)\n            throw new IllegalArgumentException(\n                    \"resizeMode cannot be null. A good default value is Mode.AUTOMATIC.\");\n\n        BufferedImage result = null;\n\n        int currentWidth = src.getWidth();\n        int currentHeight = src.getHeight();\n\n        // <= 1 is a square or landscape-oriented image, > 1 is a portrait.\n        float ratio = ((float) currentHeight / (float) currentWidth);\n", "        if (DEBUG)\n            log(0,\n                    \"Resizing Image [size=%dx%d, resizeMode=%s, orientation=%s, ratio(H/W)=%f] to [targetSize=%dx%d]\",\n                    currentWidth, currentHeight, resizeMode,\n                    (ratio <= 1 ? \"Landscape/Square\" : \"Portrait\"), ratio,\n                    targetWidth, targetHeight);\n\n        /*\n         * First determine if ANY size calculation needs to be done, in the case\n         * of FIT_EXACT, ignore image proportions and orientation and just use\n         * what the user sent in, otherwise the proportion of the picture must\n         * be honored.\n         *\n         * The way that is done is to figure out if the image is in a\n         * LANDSCAPE/SQUARE or PORTRAIT orientation and depending on its\n         * orientation, use the primary dimension (width for LANDSCAPE/SQUARE\n         * and height for PORTRAIT) to recalculate the alternative (height and\n         * width respectively) value that adheres to the existing ratio.\n         *\n         * This helps make life easier for the caller as they don't need to\n         * pre-compute proportional dimensions before calling the API, they can\n         * just specify the dimensions they would like the image to roughly fit\n         * within and it will do the right thing without mangling the result.\n         */", "        if (resizeMode == Mode.FIT_EXACT) {\n            if (DEBUG)\n                log(1,\n                        \"Resize Mode FIT_EXACT used, no width/height checking or re-calculation will be done.\");\n        } else if (resizeMode == Mode.BEST_FIT_BOTH) {\n            float requestedHeightScaling = ((float) targetHeight / (float) currentHeight);\n            float requestedWidthScaling = ((float) targetWidth / (float) currentWidth);\n            float actualScaling = Math.min(requestedHeightScaling, requestedWidthScaling);\n\n            targetHeight = Math.round((float) currentHeight * actualScaling);\n            targetWidth = Math.round((float) currentWidth * actualScaling);\n", "            if (targetHeight == currentHeight && targetWidth == currentWidth)\n                return src;\n\n            if (DEBUG)\n                log(1, \"Auto-Corrected width and height based on scalingRatio %d.\", actualScaling);\n        } else {\n            if ((ratio <= 1 && resizeMode == Mode.AUTOMATIC)\n                    || (resizeMode == Mode.FIT_TO_WIDTH)) {\n                // First make sure we need to do any work in the first place\n                if (targetWidth == src.getWidth())\n                    return src;\n\n                // Save for detailed logging (this is cheap).\n                int originalTargetHeight = targetHeight;\n\n                /*\n                 * Landscape or Square Orientation: Ignore the given height and\n                 * re-calculate a proportionally correct value based on the\n                 * targetWidth.\n                 */\n                targetHeight = (int)Math.ceil((float) targetWidth * ratio);\n", "                if (targetWidth == src.getWidth())\n                    return src;\n\n                // Save for detailed logging (this is cheap).\n                int originalTargetHeight = targetHeight;\n\n                /*\n                 * Landscape or Square Orientation: Ignore the given height and\n                 * re-calculate a proportionally correct value based on the\n                 * targetWidth.\n                 */\n                targetHeight = (int)Math.ceil((float) targetWidth * ratio);\n", "                if (DEBUG && originalTargetHeight != targetHeight)\n                    log(1,\n                            \"Auto-Corrected targetHeight [from=%d to=%d] to honor image proportions.\",\n                            originalTargetHeight, targetHeight);\n            } else {\n                // First make sure we need to do any work in the first place\n                if (targetHeight == src.getHeight())\n                    return src;\n\n                // Save for detailed logging (this is cheap).\n                int originalTargetWidth = targetWidth;\n\n                /*\n                 * Portrait Orientation: Ignore the given width and re-calculate\n                 * a proportionally correct value based on the targetHeight.\n                 */\n                targetWidth = Math.round((float) targetHeight / ratio);\n", "                if (DEBUG && originalTargetWidth != targetWidth)\n                    log(1,\n                            \"Auto-Corrected targetWidth [from=%d to=%d] to honor image proportions.\",\n                            originalTargetWidth, targetWidth);\n            }\n        }\n\n        // If AUTOMATIC was specified, determine the real scaling method.\n        if (scalingMethod == Scalr.Method.AUTOMATIC)\n            scalingMethod = determineScalingMethod(targetWidth, targetHeight,\n                    ratio);\n", "        if (scalingMethod == Scalr.Method.AUTOMATIC)\n            scalingMethod = determineScalingMethod(targetWidth, targetHeight,\n                    ratio);\n\n        if (DEBUG)\n            log(1, \"Using Scaling Method: %s\", scalingMethod);\n\n        // Now we scale the image\n        if (scalingMethod == Scalr.Method.SPEED) {\n            result = scaleImage(src, targetWidth, targetHeight,\n                    RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);", "        if (scalingMethod == Scalr.Method.SPEED) {\n            result = scaleImage(src, targetWidth, targetHeight,\n                    RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        } else if (scalingMethod == Scalr.Method.BALANCED) {\n            result = scaleImage(src, targetWidth, targetHeight,\n                    RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n        } else if (scalingMethod == Scalr.Method.QUALITY\n                || scalingMethod == Scalr.Method.ULTRA_QUALITY) {\n            /*\n             * If we are scaling up (in either width or height - since we know\n             * the image will stay proportional we just check if either are\n             * being scaled up), directly using a single BICUBIC will give us\n             * better results then using Chris Campbell's incremental scaling\n             * operation (and take a lot less time).\n             *\n             * If we are scaling down, we must use the incremental scaling\n             * algorithm for the best result.\n             */", "            if (targetWidth > currentWidth || targetHeight > currentHeight) {\n                if (DEBUG)\n                    log(1,\n                            \"QUALITY scale-up, a single BICUBIC scale operation will be used...\");\n\n                /*\n                 * BILINEAR and BICUBIC look similar the smaller the scale jump\n                 * upwards is, if the scale is larger BICUBIC looks sharper and\n                 * less fuzzy. But most importantly we have to use BICUBIC to\n                 * match the contract of the QUALITY rendering scalingMethod.\n                 * This note is just here for anyone reading the code and\n                 * wondering how they can speed their own calls up.\n                 */\n                result = scaleImage(src, targetWidth, targetHeight,\n                        RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n            } else {", "                if (DEBUG)\n                    log(1,\n                            \"QUALITY scale-down, incremental scaling will be used...\");\n\n                /*\n                 * Originally we wanted to use BILINEAR interpolation here\n                 * because it takes 1/3rd the time that the BICUBIC\n                 * interpolation does, however, when scaling large images down\n                 * to most sizes bigger than a thumbnail we witnessed noticeable\n                 * \"softening\" in the resultant image with BILINEAR that would\n                 * be unexpectedly annoying to a user expecting a \"QUALITY\"\n                 * scale of their original image. Instead BICUBIC was chosen to\n                 * honor the contract of a QUALITY scale of the original image.\n                 */\n                result = scaleImageIncrementally(src, targetWidth,\n                        targetHeight, scalingMethod,\n                        RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n            }\n        }\n", "        if (DEBUG)\n            log(0, \"Resized Image in %d ms\", System.currentTimeMillis() - t);\n\n        // Apply any optional operations (if specified).\n        if (ops != null && ops.length > 0)\n            result = apply(result, ops);\n\n        return result;\n    }\n\n    /**\n     * Used to apply a {@link Rotation} and then <code>0</code> or more\n     * {@link BufferedImageOp}s to a given image and return the result.\n     * <p/>\n     * <strong>TIP</strong>: This operation leaves the original <code>src</code>\n     * image unmodified. If the caller is done with the <code>src</code> image\n     * after getting the result of this operation, remember to call\n     * {@link BufferedImage#flush()} on the <code>src</code> to free up native\n     * resources and make it easier for the GC to collect the unused image.\n     *\n     * @param src\n     *            The image that will have the rotation applied to it.\n     * @param rotation\n     *            The rotation that will be applied to the image.\n     * @param ops\n     *            Zero or more optional image operations (e.g. sharpen, blur,\n     *            etc.) that can be applied to the final result before returning\n     *            the image.\n     *\n     * @return a new {@link BufferedImage} representing <code>src</code> rotated\n     *         by the given amount and any optional ops applied to it.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     * @throws IllegalArgumentException\n     *             if <code>rotation</code> is <code>null</code>.\n     * @throws ImagingOpException\n     *             if one of the given {@link BufferedImageOp}s fails to apply.\n     *             These exceptions bubble up from the inside of most of the\n     *             {@link BufferedImageOp} implementations and are explicitly\n     *             defined on the imgscalr API to make it easier for callers to\n     *             catch the exception (if they are passing along optional ops\n     *             to be applied). imgscalr takes detailed steps to avoid the\n     *             most common pitfalls that will cause {@link BufferedImageOp}s\n     *             to fail, even when using straight forward JDK-image\n     *             operations.\n     *\n     * @see Rotation\n     */", "    public static BufferedImage rotate(BufferedImage src, Rotation rotation,\n                                       BufferedImageOp... ops) throws IllegalArgumentException,\n            ImagingOpException {\n        long t = -1;\n        if (DEBUG)\n            t = System.currentTimeMillis();\n\n        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n        if (rotation == null)\n            throw new IllegalArgumentException(\"rotation cannot be null\");\n", "        if (rotation == null)\n            throw new IllegalArgumentException(\"rotation cannot be null\");\n\n        if (DEBUG)\n            log(0, \"Rotating Image [%s]...\", rotation);\n\n        /*\n         * Setup the default width/height values from our image.\n         *\n         * In the case of a 90 or 270 (-90) degree rotation, these two values\n         * flip-flop and we will correct those cases down below in the switch\n         * statement.\n         */\n        int newWidth = src.getWidth();\n        int newHeight = src.getHeight();\n\n        /*\n         * We create a transform per operation request as (oddly enough) it ends\n         * up being faster for the VM to create, use and destroy these instances\n         * than it is to re-use a single AffineTransform per-thread via the\n         * AffineTransform.setTo(...) methods which was my first choice (less\n         * object creation); after benchmarking this explicit case and looking\n         * at just how much code gets run inside of setTo() I opted for a new AT\n         * for every rotation.\n         *\n         * Besides the performance win, trying to safely reuse AffineTransforms\n         * via setTo(...) would have required ThreadLocal instances to avoid\n         * race conditions where two or more resize threads are manipulating the\n         * same transform before applying it.\n         *\n         * Misusing ThreadLocals are one of the #1 reasons for memory leaks in\n         * server applications and since we have no nice way to hook into the\n         * init/destroy Servlet cycle or any other initialization cycle for this\n         * library to automatically call ThreadLocal.remove() to avoid the\n         * memory leak, it would have made using this library *safely* on the\n         * server side much harder.\n         *\n         * So we opt for creating individual transforms per rotation op and let\n         * the VM clean them up in a GC. I only clarify all this reasoning here\n         * for anyone else reading this code and being tempted to reuse the AT\n         * instances of performance gains; there aren't any AND you get a lot of\n         * pain along with it.\n         */\n        AffineTransform tx = new AffineTransform();\n\n        switch (rotation) {\n            case CW_90:\n                /*\n                 * A 90 or -90 degree rotation will cause the height and width to\n                 * flip-flop from the original image to the rotated one.\n                 */\n                newWidth = src.getHeight();\n                newHeight = src.getWidth();\n\n                // Reminder: newWidth == result.getHeight() at this point\n                tx.translate(newWidth, 0);\n                tx.quadrantRotate(1);\n\n                break;\n\n            case CW_270:\n                /*\n                 * A 90 or -90 degree rotation will cause the height and width to\n                 * flip-flop from the original image to the rotated one.\n                 */\n                newWidth = src.getHeight();\n                newHeight = src.getWidth();\n\n                // Reminder: newHeight == result.getWidth() at this point\n                tx.translate(0, newHeight);\n                tx.quadrantRotate(3);\n                break;\n\n            case CW_180:\n                tx.translate(newWidth, newHeight);\n                tx.quadrantRotate(2);\n                break;\n\n            case FLIP_HORZ:\n                tx.translate(newWidth, 0);\n                tx.scale(-1.0, 1.0);\n                break;\n\n            case FLIP_VERT:\n                tx.translate(0, newHeight);\n                tx.scale(1.0, -1.0);\n                break;\n        }\n\n        // Create our target image we will render the rotated result to.\n        BufferedImage result = createOptimalImage(src, newWidth, newHeight);\n        Graphics2D g2d = (Graphics2D) result.createGraphics();\n\n        /*\n         * Render the resultant image to our new rotatedImage buffer, applying\n         * the AffineTransform that we calculated above during rendering so the\n         * pixels from the old position are transposed to the new positions in\n         * the resulting image correctly.\n         */\n        g2d.drawImage(src, tx, null);\n        g2d.dispose();\n", "        if (DEBUG)\n            log(0, \"Rotation Applied in %d ms, result [width=%d, height=%d]\",\n                    System.currentTimeMillis() - t, result.getWidth(),\n                    result.getHeight());\n\n        // Apply any optional operations (if specified).\n        if (ops != null && ops.length > 0)\n            result = apply(result, ops);\n\n        return result;\n    }\n\n    /**\n     * Used to write out a useful and well-formatted log message by any piece of\n     * code inside of the imgscalr library.\n     * <p/>\n     * If a message cannot be logged (logging is disabled) then this method\n     * returns immediately.\n     * <p/>\n     * <strong>NOTE</strong>: Because Java will auto-box primitive arguments\n     * into Objects when building out the <code>params</code> array, care should\n     * be taken not to call this method with primitive values unless\n     * {@link Scalr#DEBUG} is <code>true</code>; otherwise the VM will be\n     * spending time performing unnecessary auto-boxing calculations.\n     *\n     * @param depth\n     *            The indentation level of the log message.\n     * @param message\n     *            The log message in <a href=\n     *            \"http://download.oracle.com/javase/6/docs/api/java/util/Formatter.html#syntax\"\n     *            >format string syntax</a> that will be logged.\n     * @param params\n     *            The parameters that will be swapped into all the place holders\n     *            in the original messages before being logged.\n     *\n     * @see Scalr#LOG_PREFIX\n     * @see Scalr#LOG_PREFIX_PROPERTY_NAME\n     */\n    protected static void log(int depth, String message, Object... params) {", "        if (Scalr.DEBUG) {\n            System.out.print(Scalr.LOG_PREFIX);\n\n            for (int i = 0; i < depth; i++)\n                System.out.print(\"\\t\");\n\n            System.out.printf(message, params);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Used to create a {@link BufferedImage} with the most optimal RGB TYPE (\n     * {@link BufferedImage#TYPE_INT_RGB} or {@link BufferedImage#TYPE_INT_ARGB}\n     * ) capable of being rendered into from the given <code>src</code>. The\n     * width and height of both images will be identical.\n     * <p/>\n     * This does not perform a copy of the image data from <code>src</code> into\n     * the result image; see {@link #copyToOptimalImage(BufferedImage)} for\n     * that.\n     * <p/>\n     * We force all rendering results into one of these two types, avoiding the\n     * case where a source image is of an unsupported (or poorly supported)\n     * format by Java2D causing the rendering result to end up looking terrible\n     * (common with GIFs) or be totally corrupt (e.g. solid black image).\n     * <p/>\n     * Originally reported by Magnus Kvalheim from Movellas when scaling certain\n     * GIF and PNG images.\n     *\n     * @param src\n     *            The source image that will be analyzed to determine the most\n     *            optimal image type it can be rendered into.\n     *\n     * @return a new {@link BufferedImage} representing the most optimal target\n     *         image type that <code>src</code> can be rendered into.\n     *\n     * @see <a\n     *      href=\"http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html\">How\n     *      Java2D handles poorly supported image types</a>\n     * @see <a\n     *      href=\"http://code.google.com/p/java-image-scaling/source/browse/trunk/src/main/java/com/mortennobel/imagescaling/MultiStepRescaleOp.java\">Thanks\n     *      to Morten Nobel for implementation hint</a>\n     */\n    protected static BufferedImage createOptimalImage(BufferedImage src) {\n        return createOptimalImage(src, src.getWidth(), src.getHeight());\n    }\n\n    /**\n     * Used to create a {@link BufferedImage} with the given dimensions and the\n     * most optimal RGB TYPE ( {@link BufferedImage#TYPE_INT_RGB} or\n     * {@link BufferedImage#TYPE_INT_ARGB} ) capable of being rendered into from\n     * the given <code>src</code>.\n     * <p/>\n     * This does not perform a copy of the image data from <code>src</code> into\n     * the result image; see {@link #copyToOptimalImage(BufferedImage)} for\n     * that.\n     * <p/>\n     * We force all rendering results into one of these two types, avoiding the\n     * case where a source image is of an unsupported (or poorly supported)\n     * format by Java2D causing the rendering result to end up looking terrible\n     * (common with GIFs) or be totally corrupt (e.g. solid black image).\n     * <p/>\n     * Originally reported by Magnus Kvalheim from Movellas when scaling certain\n     * GIF and PNG images.\n     *\n     * @param src\n     *            The source image that will be analyzed to determine the most\n     *            optimal image type it can be rendered into.\n     * @param width\n     *            The width of the newly created resulting image.\n     * @param height\n     *            The height of the newly created resulting image.\n     *\n     * @return a new {@link BufferedImage} representing the most optimal target\n     *         image type that <code>src</code> can be rendered into.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>width</code> or <code>height</code> are &lt; 0.\n     *\n     * @see <a\n     *      href=\"http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html\">How\n     *      Java2D handles poorly supported image types</a>\n     * @see <a\n     *      href=\"http://code.google.com/p/java-image-scaling/source/browse/trunk/src/main/java/com/mortennobel/imagescaling/MultiStepRescaleOp.java\">Thanks\n     *      to Morten Nobel for implementation hint</a>\n     */\n    protected static BufferedImage createOptimalImage(BufferedImage src,\n                                                      int width, int height) throws IllegalArgumentException {", "        if (width <= 0 || height <= 0)\n            throw new IllegalArgumentException(\"width [\" + width\n                    + \"] and height [\" + height + \"] must be > 0\");\n\n        return new BufferedImage(\n                width,\n                height,\n                (src.getTransparency() == Transparency.OPAQUE ? BufferedImage.TYPE_INT_RGB\n                        : BufferedImage.TYPE_INT_ARGB));\n    }\n\n    /**\n     * Used to copy a {@link BufferedImage} from a non-optimal type into a new\n     * {@link BufferedImage} instance of an optimal type (RGB or ARGB). If\n     * <code>src</code> is already of an optimal type, then it is returned\n     * unmodified.\n     * <p/>\n     * This method is meant to be used by any calling code (imgscalr's or\n     * otherwise) to convert any inbound image from a poorly supported image\n     * type into the 2 most well-supported image types in Java2D (\n     * {@link BufferedImage#TYPE_INT_RGB} or {@link BufferedImage#TYPE_INT_ARGB}\n     * ) in order to ensure all subsequent graphics operations are performed as\n     * efficiently and correctly as possible.\n     * <p/>\n     * When using Java2D to work with image types that are not well supported,\n     * the results can be anything from exceptions bubbling up from the depths\n     * of Java2D to images being completely corrupted and just returned as solid\n     * black.\n     *\n     * @param src\n     *            The image to copy (if necessary) into an optimally typed\n     *            {@link BufferedImage}.\n     *\n     * @return a representation of the <code>src</code> image in an optimally\n     *         typed {@link BufferedImage}, otherwise <code>src</code> if it was\n     *         already of an optimal type.\n     *\n     * @throws IllegalArgumentException\n     *             if <code>src</code> is <code>null</code>.\n     */\n    protected static BufferedImage copyToOptimalImage(BufferedImage src)\n            throws IllegalArgumentException {", "        if (src == null)\n            throw new IllegalArgumentException(\"src cannot be null\");\n\n        // Calculate the type depending on the presence of alpha.\n        int type = (src.getTransparency() == Transparency.OPAQUE ? BufferedImage.TYPE_INT_RGB\n                : BufferedImage.TYPE_INT_ARGB);\n        BufferedImage result = new BufferedImage(src.getWidth(),\n                src.getHeight(), type);\n\n        // Render the src image into our new optimal source.\n        Graphics g = result.getGraphics();\n        g.drawImage(src, 0, 0, null);\n        g.dispose();\n\n        return result;\n    }\n\n    /**\n     * Used to determine the scaling {@link Method} that is best suited for\n     * scaling the image to the targeted dimensions.\n     * <p/>\n     * This method is intended to be used to select a specific scaling\n     * {@link Method} when a {@link Method#AUTOMATIC} method is specified. This\n     * method utilizes the {@link Scalr#THRESHOLD_QUALITY_BALANCED} and\n     * {@link Scalr#THRESHOLD_BALANCED_SPEED} thresholds when selecting which\n     * method should be used by comparing the primary dimension (width or\n     * height) against the threshold and seeing where the image falls. The\n     * primary dimension is determined by looking at the orientation of the\n     * image: landscape or square images use their width and portrait-oriented\n     * images use their height.\n     *\n     * @param targetWidth\n     *            The target width for the scaled image.\n     * @param targetHeight\n     *            The target height for the scaled image.\n     * @param ratio\n     *            A height/width ratio used to determine the orientation of the\n     *            image so the primary dimension (width or height) can be\n     *            selected to test if it is greater than or less than a\n     *            particular threshold.\n     *\n     * @return the fastest {@link Method} suited for scaling the image to the\n     *         specified dimensions while maintaining a good-looking result.\n     */\n    protected static Method determineScalingMethod(int targetWidth,\n                                                   int targetHeight, float ratio) {\n        // Get the primary dimension based on the orientation of the image\n        int length = (ratio <= 1 ? targetWidth : targetHeight);\n\n        // Default to speed\n        Method result = Method.SPEED;\n\n        // Figure out which scalingMethod should be used", "        if (length <= Scalr.THRESHOLD_QUALITY_BALANCED)\n            result = Method.QUALITY;\n        else if (length <= Scalr.THRESHOLD_BALANCED_SPEED)\n            result = Method.BALANCED;\n\n        if (DEBUG)\n            log(2, \"AUTOMATIC scaling method selected: %s\", result.name());\n\n        return result;\n    }\n\n    /**\n     * Used to implement a straight-forward image-scaling operation using Java\n     * 2D.\n     * <p/>\n     * This method uses the Oracle-encouraged method of\n     * <code>Graphics2D.drawImage(...)</code> to scale the given image with the\n     * given interpolation hint.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param targetWidth\n     *            The target width for the scaled image.\n     * @param targetHeight\n     *            The target height for the scaled image.\n     * @param interpolationHintValue\n     *            The {@link RenderingHints} interpolation value used to\n     *            indicate the method that {@link Graphics2D} should use when\n     *            scaling the image.\n     *\n     * @return the result of scaling the original <code>src</code> to the given\n     *         dimensions using the given interpolation method.\n     */\n    protected static BufferedImage scaleImage(BufferedImage src,\n                                              int targetWidth, int targetHeight, Object interpolationHintValue) {\n        // Setup the rendering resources to match the source image's\n        BufferedImage result = createOptimalImage(src, targetWidth,\n                targetHeight);\n        Graphics2D resultGraphics = result.createGraphics();\n\n        // Scale the image to the new buffer using the specified rendering hint.\n        resultGraphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,\n                interpolationHintValue);\n        resultGraphics.drawImage(src, 0, 0, targetWidth, targetHeight, null);\n\n        // Just to be clean, explicitly dispose our temporary graphics object\n        resultGraphics.dispose();\n\n        // Return the scaled image to the caller.\n        return result;\n    }\n\n    /**\n     * Used to implement Chris Campbell's incremental-scaling algorithm: <a\n     * href=\"http://today.java.net/pub/a/today/2007/04/03/perils\n     * -of-image-getscaledinstance\n     * .html\">http://today.java.net/pub/a/today/2007/04/03/perils\n     * -of-image-getscaledinstance.html</a>.\n     * <p/>\n     * Modifications to the original algorithm are variable names and comments\n     * added for clarity and the hard-coding of using BICUBIC interpolation as\n     * well as the explicit \"flush()\" operation on the interim BufferedImage\n     * instances to avoid resource leaking.\n     *\n     * @param src\n     *            The image that will be scaled.\n     * @param targetWidth\n     *            The target width for the scaled image.\n     * @param targetHeight\n     *            The target height for the scaled image.\n     * @param scalingMethod\n     *            The scaling method specified by the user (or calculated by\n     *            imgscalr) to use for this incremental scaling operation.\n     * @param interpolationHintValue\n     *            The {@link RenderingHints} interpolation value used to\n     *            indicate the method that {@link Graphics2D} should use when\n     *            scaling the image.\n     *\n     * @return an image scaled to the given dimensions using the given rendering\n     *         hint.\n     */\n    protected static BufferedImage scaleImageIncrementally(BufferedImage src,\n                                                           int targetWidth, int targetHeight, Method scalingMethod,\n                                                           Object interpolationHintValue) {\n        boolean hasReassignedSrc = false;\n        int incrementCount = 0;\n        int currentWidth = src.getWidth();\n        int currentHeight = src.getHeight();\n\n        /*\n         * The original QUALITY mode, representing Chris Campbell's algorithm,\n         * is to step down by 1/2s every time when scaling the image\n         * incrementally. Users pointed out that using this method to scale\n         * images with noticeable straight lines left them really jagged in\n         * smaller thumbnail format.\n         *\n         * After investigation it was discovered that scaling incrementally by\n         * smaller increments was the ONLY way to make the thumbnail sized\n         * images look less jagged and more accurate; almost matching the\n         * accuracy of Mac's built in thumbnail generation which is the highest\n         * quality resize I've come across (better than GIMP Lanczos3 and\n         * Windows 7).\n         *\n         * A divisor of 7 was chose as using 5 still left some jaggedness in the\n         * image while a divisor of 8 or higher made the resulting thumbnail too\n         * soft; like our OP_ANTIALIAS convolve op had been forcibly applied to\n         * the result even if the user didn't want it that soft.\n         *\n         * Using a divisor of 7 for the ULTRA_QUALITY seemed to be the sweet\n         * spot.\n         *\n         * NOTE: Below when the actual fraction is used to calculate the small\n         * portion to subtract from the current dimension, this is a\n         * progressively smaller and smaller chunk. When the code was changed to\n         * do a linear reduction of the image of equal steps for each\n         * incremental resize (e.g. say 50px each time) the result was\n         * significantly worse than the progressive approach used below; even\n         * when a very high number of incremental steps (13) was tested.\n         */\n        int fraction = (scalingMethod == Method.ULTRA_QUALITY ? 7 : 2);\n\n        do {\n            int prevCurrentWidth = currentWidth;\n            int prevCurrentHeight = currentHeight;\n\n            /*\n             * If the current width is bigger than our target, cut it in half\n             * and sample again.\n             */", "            if (currentWidth > targetWidth) {\n                currentWidth -= (currentWidth / fraction);\n\n                /*\n                 * If we cut the width too far it means we are on our last\n                 * iteration. Just set it to the target width and finish up.\n                 */\n                if (currentWidth < targetWidth)\n                    currentWidth = targetWidth;\n            }\n\n            /*\n             * If the current height is bigger than our target, cut it in half\n             * and sample again.\n             */\n", "            if (currentHeight > targetHeight) {\n                currentHeight -= (currentHeight / fraction);\n\n                /*\n                 * If we cut the height too far it means we are on our last\n                 * iteration. Just set it to the target height and finish up.\n                 */\n\n                if (currentHeight < targetHeight)\n                    currentHeight = targetHeight;\n            }\n\n            /*\n             * Stop when we cannot incrementally step down anymore.\n             *\n             * This used to use a || condition, but that would cause problems\n             * when using FIT_EXACT such that sometimes the width OR height\n             * would not change between iterations, but the other dimension\n             * would (e.g. resizing 500x500 to 500x250).\n             *\n             * Now changing this to an && condition requires that both\n             * dimensions do not change between a resize iteration before we\n             * consider ourselves done.\n             */", "                if (currentHeight < targetHeight)\n                    currentHeight = targetHeight;\n            }\n\n            /*\n             * Stop when we cannot incrementally step down anymore.\n             *\n             * This used to use a || condition, but that would cause problems\n             * when using FIT_EXACT such that sometimes the width OR height\n             * would not change between iterations, but the other dimension\n             * would (e.g. resizing 500x500 to 500x250).\n             *\n             * Now changing this to an && condition requires that both\n             * dimensions do not change between a resize iteration before we\n             * consider ourselves done.\n             */", "            if (prevCurrentWidth == currentWidth\n                    && prevCurrentHeight == currentHeight)\n                break;\n\n            if (DEBUG)\n                log(2, \"Scaling from [%d x %d] to [%d x %d]\", prevCurrentWidth,\n                        prevCurrentHeight, currentWidth, currentHeight);\n\n            // Render the incremental scaled image.\n            BufferedImage incrementalImage = scaleImage(src, currentWidth,\n                    currentHeight, interpolationHintValue);\n\n            /*\n             * Before re-assigning our interim (partially scaled)\n             * incrementalImage to be the new src image before we iterate around\n             * again to process it down further, we want to flush() the previous\n             * src image IF (and only IF) it was one of our own temporary\n             * BufferedImages created during this incremental down-sampling\n             * cycle. If it wasn't one of ours, then it was the original\n             * caller-supplied BufferedImage in which case we don't want to\n             * flush() it and just leave it alone.\n             */", "            if (hasReassignedSrc)\n                src.flush();\n\n            /*\n             * Now treat our incremental partially scaled image as the src image\n             * and cycle through our loop again to do another incremental\n             * scaling of it (if necessary).\n             */\n            src = incrementalImage;\n\n            /*\n             * Keep track of us re-assigning the original caller-supplied source\n             * image with one of our interim BufferedImages so we know when to\n             * explicitly flush the interim \"src\" on the next cycle through.\n             */\n            hasReassignedSrc = true;\n\n            // Track how many times we go through this cycle to scale the image.\n            incrementCount++;", "        } while (currentWidth != targetWidth || currentHeight != targetHeight);\n\n        if (DEBUG)\n            log(2, \"Incrementally Scaled Image in %d steps.\", incrementCount);\n\n        /*\n         * Once the loop has exited, the src image argument is now our scaled\n         * result image that we want to return.\n         */\n        return src;\n    }\n}"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/processing/SVGIconFactory.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.processing;\n\nimport com.github.polyrocketmatt.reflow.DecompilerController;\nimport javafx.embed.swing.SwingFXUtils;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport org.apache.batik.transcoder.TranscoderException;\nimport org.apache.batik.transcoder.TranscoderInput;\n\nimport java.awt.image.BufferedImage;", "\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SVGIconFactory {\n\n    @SuppressWarnings(\"ConstantConditions\")\n    public static ImageView fromSVG(String path) {\n        try {\n            ImageView imageView = new ImageView();\n\n            imageView.setFitWidth(20);\n            imageView.setFitHeight(20);\n\n            InputStream is = DecompilerController.class.getResource(path).openStream();\n            BufferedImageTranscoder transcoder = new BufferedImageTranscoder();\n            TranscoderInput transcoderInput = new TranscoderInput(is);", "    public static ImageView fromSVG(String path) {\n        try {\n            ImageView imageView = new ImageView();\n\n            imageView.setFitWidth(20);\n            imageView.setFitHeight(20);\n\n            InputStream is = DecompilerController.class.getResource(path).openStream();\n            BufferedImageTranscoder transcoder = new BufferedImageTranscoder();\n            TranscoderInput transcoderInput = new TranscoderInput(is);\n            try {\n                transcoder.transcode(transcoderInput, null);\n                BufferedImage image = transcoder.getBufferedImage();\n                BufferedImage processedImage = Scalr.resize(image, Scalr.Method.ULTRA_QUALITY, 64, 64, Scalr.OP_ANTIALIAS);\n                Image img = SwingFXUtils.toFXImage(processedImage, null);\n\n                imageView.setImage(img);\n            } catch (TranscoderException ex) {\n                ex.printStackTrace();\n            }\n\n            is.close();\n\n            return imageView;\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n}\n", "            try {\n                transcoder.transcode(transcoderInput, null);\n                BufferedImage image = transcoder.getBufferedImage();\n                BufferedImage processedImage = Scalr.resize(image, Scalr.Method.ULTRA_QUALITY, 64, 64, Scalr.OP_ANTIALIAS);\n                Image img = SwingFXUtils.toFXImage(processedImage, null);\n\n                imageView.setImage(img);\n            } catch (TranscoderException ex) {\n                ex.printStackTrace();\n            }\n\n            is.close();\n\n            return imageView;\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/processing/BufferedImageTranscoder.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.processing;\n\nimport org.apache.batik.transcoder.TranscoderException;\nimport org.apache.batik.transcoder.TranscoderOutput;\nimport org.apache.batik.transcoder.image.ImageTranscoder;\n\nimport java.awt.image.BufferedImage;\n\npublic class BufferedImageTranscoder extends ImageTranscoder {\n\n    private BufferedImage image = null;\n\n    @Override", "public class BufferedImageTranscoder extends ImageTranscoder {\n\n    private BufferedImage image = null;\n\n    @Override\n    public BufferedImage createImage(int width, int height) {\n        return new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n\n    @Override\n    public void writeImage(BufferedImage img, TranscoderOutput to) throws TranscoderException {\n        this.image = img;\n    }\n", "    public void writeImage(BufferedImage img, TranscoderOutput to) throws TranscoderException {\n        this.image = img;\n    }\n\n    public BufferedImage getBufferedImage() {\n        return image;\n    }\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/palette/ReflowPalette.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.palette;\n\npublic class ReflowPalette {\n\n    public static final ReflowColor BLUE_ACCENT = new ReflowColor(56, 189, 216);\n    public static final ReflowColor GREEN_ACCENT = new ReflowColor(181, 228, 160);\n\n}\n"]}
{"filename": "reflow-ui/src/main/java/com/github/polyrocketmatt/reflow/palette/ReflowColor.java", "chunked_list": ["package com.github.polyrocketmatt.reflow.palette;\n\nimport com.github.polyrocketmatt.reflow.decompiler.utils.StringUtils;\n\npublic record ReflowColor(\n        int red,\n        int green,\n        int blue\n) {\n\n    public int r() {\n        return red;\n    }\n", "    public int r() {\n        return red;\n    }\n\n    public int g() {\n        return green;\n    }\n\n    public int b() {\n        return blue;\n    }\n", "    public int b() {\n        return blue;\n    }\n\n    public int rgb() {\n        return (red << 16) | (green << 8) | blue;\n    }\n\n    public int argb() {\n        return (0xFF << 24) | (red << 16) | (green << 8) | blue;\n    }\n", "    public int argb() {\n        return (0xFF << 24) | (red << 16) | (green << 8) | blue;\n    }\n\n    public String hex() {\n        return StringUtils.rgbToHex(red, green, blue);\n    }\n\n    public static ReflowColor lerp(ReflowColor first, ReflowColor second, double t) {\n        return new ReflowColor(\n                (int) (first.red * (1 - t) + second.red * t),\n                (int) (first.green * (1 - t) + second.green * t),\n                (int) (first.blue * (1 - t) + second.blue * t)\n        );\n    }\n\n}\n", "    public static ReflowColor lerp(ReflowColor first, ReflowColor second, double t) {\n        return new ReflowColor(\n                (int) (first.red * (1 - t) + second.red * t),\n                (int) (first.green * (1 - t) + second.green * t),\n                (int) (first.blue * (1 - t) + second.blue * t)\n        );\n    }\n\n}\n"]}
