{"filename": "uitests/src/com/android/traceur/uitest/TraceurAppTests.java", "chunked_list": ["/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.traceur.uitest;\n", "package com.android.traceur.uitest;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.os.RemoteException;\nimport android.os.SystemClock;", "import android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.platform.test.annotations.Presubmit;\nimport android.support.test.uiautomator.By;\nimport android.support.test.uiautomator.UiDevice;\nimport android.support.test.uiautomator.UiObject2;\nimport android.support.test.uiautomator.UiObjectNotFoundException;\nimport android.support.test.uiautomator.UiSelector;\nimport android.support.test.uiautomator.UiScrollable;\nimport android.support.test.uiautomator.Until;", "import android.support.test.uiautomator.UiScrollable;\nimport android.support.test.uiautomator.Until;\n\nimport androidx.test.InstrumentationRegistry;\nimport androidx.test.runner.AndroidJUnit4;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;", "import org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n@RunWith(AndroidJUnit4.class)\npublic class TraceurAppTests {\n\n    private static final String TRACEUR_PACKAGE = \"com.android.traceur\";\n    private static final int LAUNCH_TIMEOUT_MS = 10000;\n    private static final int UI_TIMEOUT_MS = 7500;\n    private static final int SHORT_PAUSE_MS = 1000;\n\n    private UiDevice mDevice;\n\n    @Before", "    public void setUp() throws Exception {\n        mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());\n\n        try {\n            if (!mDevice.isScreenOn()) {\n                mDevice.wakeUp();\n            }\n\n            // Press Menu to skip the lock screen.\n            // In case we weren't on the lock screen, press Home to return to a clean launcher.\n            mDevice.pressMenu();\n            mDevice.pressHome();\n\n            mDevice.setOrientationNatural();\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failed to freeze device orientation.\", e);\n        }\n\n        mDevice.waitForIdle();\n\n        Context context = InstrumentationRegistry.getContext();\n        Intent intent = context.getPackageManager().getLaunchIntentForPackage(TRACEUR_PACKAGE);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);    // Clear out any previous instances\n        context.startActivity(intent);\n\n        // Wait for the app to appear.\n        assertTrue(mDevice.wait(Until.hasObject(By.pkg(TRACEUR_PACKAGE).depth(0)),\n                  LAUNCH_TIMEOUT_MS));\n        // Default trace categories are restored in case a previous test modified them and\n        // terminated early.\n        restoreDefaultCategories();\n    }\n\n    @After", "    public void tearDown() throws Exception {\n        mDevice.unfreezeRotation();\n        // Finish Traceur activity.\n        mDevice.pressBack();\n        mDevice.pressHome();\n    }\n\n    /**\n     * Verifies that the main page contains the correct UI elements.\n     * If the main page is scrollable, the test checks that all expected elements are found while\n     * scrolling. Otherwise, it checks that the expected elements are already on the page.\n     */\n    @Presubmit\n    @Test", "    public void testElementsOnMainScreen() throws Exception {\n        UiScrollable scrollableMainScreen = new UiScrollable(new UiSelector().scrollable(true));\n\n        if (scrollableMainScreen.exists()) {\n            scrollableMainScreen.setAsVerticalList();\n            scrollableMainScreen.setMaxSearchSwipes(10);\n\n            boolean recordFound = scrollableMainScreen.scrollTextIntoView(\"Record trace\");\n            assertTrue(\"Record trace switch not found.\", recordFound);\n\n            boolean applicationsFound =\n                    scrollableMainScreen.scrollTextIntoView(\"Trace debuggable applications\");\n            assertTrue(\"Applications element not found.\", applicationsFound);\n\n            boolean categoriesFound = scrollableMainScreen.scrollTextIntoView(\"Categories\");\n            assertTrue(\"Categories element not found.\", categoriesFound);\n\n            boolean restoreFound = scrollableMainScreen.scrollTextIntoView(\"Restore default categories\");\n            assertTrue(\"Restore default categories element not found.\", restoreFound);\n\n            boolean bufferSizeFound = scrollableMainScreen.scrollTextIntoView(\"Per-CPU buffer size\");\n            assertTrue(\"Per-CPU buffer size element not found.\", bufferSizeFound);\n\n            boolean clearFound = scrollableMainScreen.scrollTextIntoView(\"Clear saved traces\");\n            assertTrue(\"Clear saved traces element not found.\", clearFound);\n\n            boolean longTraceFound = scrollableMainScreen.scrollTextIntoView(\"Long traces\");\n            assertTrue(\"Long traces element not found.\", longTraceFound);\n\n            boolean maxTraceSizeFound = scrollableMainScreen.scrollTextIntoView(\"Maximum long trace size\");\n            assertTrue(\"Maximum long trace size element not found.\", maxTraceSizeFound);\n\n            boolean maxTraceDurationFound =\n                    scrollableMainScreen.scrollTextIntoView(\"Maximum long trace duration\");\n            assertTrue(\"Maximum long trace duration element not found.\", maxTraceDurationFound);\n\n            boolean quickSettingsFound = scrollableMainScreen.scrollTextIntoView(\"Show Quick Settings tile\");\n            assertTrue(\"Show Quick Settings tile switch not found.\", quickSettingsFound);\n        } else {\n            assertNotNull(\"Record trace switch not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Record trace\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Applications element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Trace debuggable applications\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Categories element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Categories\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Restore default categories element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Restore default categories\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Per-CPU buffer size element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Per-CPU buffer size\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Clear saved traces element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Clear saved traces\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Long traces element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Long traces\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Maximum long trace size element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Maximum long trace size\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Maximum long trace duration element not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Maximum long trace duration\")),\n                    UI_TIMEOUT_MS));\n            assertNotNull(\"Show Quick Settings tile switch not found.\",\n                    mDevice.wait(Until.findObject(By.text(\"Show Quick Settings tile\")),\n                    UI_TIMEOUT_MS));\n        }\n    }\n\n    /**\n     * Checks that a trace can be recorded and shared.\n     * This test records a trace by toggling 'Record trace' in the UI, taps on the share\n     * notification once the trace is saved, then (on non-AOSP) verifies that a share dialog\n     * appears.\n     */\n    @Presubmit\n    @Test", "    public void testSuccessfulTracing() throws Exception {\n        UiObject2 recordTraceSwitch = mDevice.wait(Until.findObject(By.text(\"Record trace\")),\n                UI_TIMEOUT_MS);\n        assertNotNull(\"Record trace switch not found.\", recordTraceSwitch);\n        recordTraceSwitch.click();\n\n        mDevice.waitForIdle();\n\n        mDevice.wait(Until.hasObject(By.text(\"Trace is being recorded\")), UI_TIMEOUT_MS);\n        mDevice.wait(Until.gone(By.text(\"Trace is being recorded\")), UI_TIMEOUT_MS);\n\n        recordTraceSwitch = mDevice.wait(Until.findObject(By.text(\"Record trace\")), UI_TIMEOUT_MS);\n        assertNotNull(\"Record trace switch not found.\", recordTraceSwitch);\n        recordTraceSwitch.click();\n\n        mDevice.waitForIdle();\n\n        // Wait for the popover notification to appear and then disappear,\n        // so we can reliably click the notification in the notification shade.\n        mDevice.wait(Until.hasObject(By.text(\"Tap to share your trace\")), UI_TIMEOUT_MS);\n        mDevice.wait(Until.gone(By.text(\"Tap to share your trace\")), UI_TIMEOUT_MS);\n\n        mDevice.openNotification();\n        UiObject2 shareNotification = mDevice.wait(Until.findObject(\n                By.text(\"Tap to share your trace\")),\n                UI_TIMEOUT_MS);\n        assertNotNull(\"Share notification not found.\", shareNotification);\n        shareNotification.click();\n\n        mDevice.waitForIdle();\n\n        UiObject2 shareDialog = mDevice.wait(Until.findObject(\n                By.textContains(\"Only share system traces with people and apps you trust.\")),\n                UI_TIMEOUT_MS);\n        assertNotNull(\"Share dialog not found.\", shareDialog);\n\n        // The buttons on dialogs sometimes have their capitalization manipulated by themes.\n        UiObject2 shareButton = mDevice.wait(Until.findObject(\n                By.text(Pattern.compile(\"share\", Pattern.CASE_INSENSITIVE))), UI_TIMEOUT_MS);\n        assertNotNull(\"Share button not found.\", shareButton);\n        shareButton.click();\n\n        // The share sheet will not appear on AOSP builds, as there are no apps available to share\n        // traces with. This checks if Gmail is installed (i.e. if the build is non-AOSP) before\n        // verifying that the share sheet exists.", "        try {\n            Context context = InstrumentationRegistry.getContext();\n            context.getPackageManager().getApplicationInfo(\"com.google.android.gm\", 0);\n            UiObject2 shareSheet = mDevice.wait(Until.findObject(\n                    By.res(\"android:id/profile_tabhost\")), UI_TIMEOUT_MS);\n            assertNotNull(\"Share sheet not found.\", shareSheet);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Gmail is not installed, so the device is on an AOSP build.\n        }\n    }\n\n    /**\n     * Checks that trace categories are displayed after tapping on the 'Categories' button.\n     */\n    @Presubmit\n    @Test", "    public void testTraceCategoriesExist() {\n        openTraceCategories();\n        List<UiObject2> categories = getTraceCategories();\n        assertNotNull(\"List of categories not found.\", categories);\n        assertTrue(\"No available trace categories.\", categories.size() > 0);\n    }\n\n    /**\n     * Checks that the 'Categories' summary updates when trace categories are selected.\n     * This test checks that the summary for the 'Categories' button changes from 'Default' to 'N\n     * selected' when a trace category is clicked, then back to 'Default' when the same category is\n     * clicked again.\n     */\n    @Presubmit\n    @Test", "    public void testCorrectCategoriesSummary() {\n        UiObject2 summary = getCategoriesSummary();\n        assertTrue(\"Expected 'Default' summary not found on startup.\",\n                summary.getText().contains(\"Default\"));\n\n        openTraceCategories();\n        toggleFirstTraceCategory();\n\n        // The summary must be reset after each toggle because the reference will be stale.\n        summary = getCategoriesSummary();\n        assertTrue(\"Expected 'N selected' summary not found.\",\n                summary.getText().contains(\"selected\"));\n\n        openTraceCategories();\n        toggleFirstTraceCategory();\n\n        summary = getCategoriesSummary();\n        assertTrue(\"Expected 'Default' summary not found after changing categories.\",\n                summary.getText().contains(\"Default\"));\n    }\n\n    /**\n     * Checks that the 'Restore default categories' button resets the trace categories summary.\n     * This test changes the set of selected trace categories from the default, then checks that the\n     * 'Categories' summary resets to 'Default' when the restore button is clicked.\n     */\n    @Presubmit\n    @Test", "    public void testRestoreDefaultCategories() {\n        openTraceCategories();\n        toggleFirstTraceCategory();\n\n        UiObject2 summary = getCategoriesSummary();\n        assertTrue(\"Expected 'N selected' summary not found.\",\n                summary.getText().contains(\"selected\"));\n\n        restoreDefaultCategories();\n\n        // The summary must be reset after the toggle because the reference will be stale.\n        summary = getCategoriesSummary();\n        assertTrue(\"Expected 'Default' summary not found after restoring categories.\",\n                summary.getText().contains(\"Default\"));\n    }\n\n    /**\n     * Taps on the 'Categories' button.\n     */\n    private void openTraceCategories() {\n        UiObject2 categoriesButton = mDevice.wait(Until.findObject(\n                By.text(\"Categories\")), UI_TIMEOUT_MS);\n        assertNotNull(\"Categories button not found.\", categoriesButton);\n        categoriesButton.click();\n\n        mDevice.waitForIdle();\n    }\n\n    /**\n     * Taps on the 'Restore default categories' button.\n     */\n    private void restoreDefaultCategories() {\n        UiObject2 restoreButton = mDevice.wait(Until.findObject(\n                By.text(\"Restore default categories\")), UI_TIMEOUT_MS);\n        assertNotNull(\"'Restore default categories' button not found.\", restoreButton);\n        restoreButton.click();\n\n        mDevice.waitForIdle();\n        // This pause is necessary because the trace category restoration takes time to propagate to\n        // the main page.\n        SystemClock.sleep(SHORT_PAUSE_MS);\n    }\n\n    /**\n     * Returns the UiObject2 of the summary for 'Categories'.\n     * This must only be used on Traceur's main page.\n     */\n    private UiObject2 getCategoriesSummary() {\n        UiObject2 categoriesButton = mDevice.wait(Until.findObject(\n                By.text(\"Categories\")), UI_TIMEOUT_MS);\n        assertNotNull(\"Categories button not found.\", categoriesButton);\n        // The summary text is a sibling view of 'Categories' and can be found through their parent.\n        UiObject2 categoriesSummary = categoriesButton.getParent().wait(Until.findObject(\n                By.res(\"android:id/summary\")), UI_TIMEOUT_MS);\n        assertNotNull(\"Categories summary not found.\", categoriesSummary);\n        return categoriesSummary;\n    }\n\n    /**\n     * Returns the list of available trace categories.\n     * This must only be used after openTraceCategories() has been called.\n     */\n    private List<UiObject2> getTraceCategories() {\n        UiObject2 categoriesListView = mDevice.wait(Until.findObject(\n                By.res(\"android:id/select_dialog_listview\")), UI_TIMEOUT_MS);\n        assertNotNull(\"List of categories not found.\", categoriesListView);\n        return categoriesListView.getChildren();\n    }\n\n    /**\n     * Toggles the first checkbox in the list of trace categories.\n     * This must only be used after openTraceCategories() has been called.\n     */\n    private void toggleFirstTraceCategory() {\n        getTraceCategories().get(0).click();\n\n        mDevice.waitForIdle();\n\n        UiObject2 confirmButton = mDevice.wait(Until.findObject(\n                By.res(\"android:id/button1\")), UI_TIMEOUT_MS);\n        assertNotNull(\"'OK' button not found under trace categories list.\", confirmButton);\n        confirmButton.click();\n\n        mDevice.waitForIdle();\n        // This pause is necessary because the trace category selection takes time to propagate to\n        // the main page.\n        SystemClock.sleep(SHORT_PAUSE_MS);\n    }\n\n}\n"]}
{"filename": "src/com/android/traceur/PerfettoUtils.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.system.Os;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.List;", "import java.util.Collection;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.TimeUnit;\n\nimport perfetto.protos.DataSourceDescriptorOuterClass.DataSourceDescriptor;\nimport perfetto.protos.FtraceDescriptorOuterClass.FtraceDescriptor.AtraceCategory;\nimport perfetto.protos.TracingServiceStateOuterClass.TracingServiceState;\nimport perfetto.protos.TracingServiceStateOuterClass.TracingServiceState.DataSource;\n", "import perfetto.protos.TracingServiceStateOuterClass.TracingServiceState.DataSource;\n\n/**\n * Utility functions for calling Perfetto\n */\npublic class PerfettoUtils implements TraceUtils.TraceEngine {\n\n    static final String TAG = \"Traceur\";\n    public static final String NAME = \"PERFETTO\";\n\n    private static final String OUTPUT_EXTENSION = \"perfetto-trace\";\n    private static final String TEMP_DIR= \"/data/local/traces/\";\n    private static final String TEMP_TRACE_LOCATION = \"/data/local/traces/.trace-in-progress.trace\";\n\n    private static final String PERFETTO_TAG = \"traceur\";\n    private static final String MARKER = \"PERFETTO_ARGUMENTS\";\n    private static final int LIST_TIMEOUT_MS = 10000;\n    private static final int STARTUP_TIMEOUT_MS = 10000;\n    private static final int STOP_TIMEOUT_MS = 30000;\n    private static final long MEGABYTES_TO_BYTES = 1024L * 1024L;\n    private static final long MINUTES_TO_MILLISECONDS = 60L * 1000L;\n\n    private static final String CAMERA_TAG = \"camera\";\n    private static final String GFX_TAG = \"gfx\";\n    private static final String MEMORY_TAG = \"memory\";\n    private static final String POWER_TAG = \"power\";\n    private static final String SCHED_TAG = \"sched\";\n    private static final String WEBVIEW_TAG = \"webview\";\n", "    public static final String NAME = \"PERFETTO\";\n\n    private static final String OUTPUT_EXTENSION = \"perfetto-trace\";\n    private static final String TEMP_DIR= \"/data/local/traces/\";\n    private static final String TEMP_TRACE_LOCATION = \"/data/local/traces/.trace-in-progress.trace\";\n\n    private static final String PERFETTO_TAG = \"traceur\";\n    private static final String MARKER = \"PERFETTO_ARGUMENTS\";\n    private static final int LIST_TIMEOUT_MS = 10000;\n    private static final int STARTUP_TIMEOUT_MS = 10000;\n    private static final int STOP_TIMEOUT_MS = 30000;\n    private static final long MEGABYTES_TO_BYTES = 1024L * 1024L;\n    private static final long MINUTES_TO_MILLISECONDS = 60L * 1000L;\n\n    private static final String CAMERA_TAG = \"camera\";\n    private static final String GFX_TAG = \"gfx\";\n    private static final String MEMORY_TAG = \"memory\";\n    private static final String POWER_TAG = \"power\";\n    private static final String SCHED_TAG = \"sched\";\n    private static final String WEBVIEW_TAG = \"webview\";\n", "    public String getName() {\n        return NAME;\n    }\n\n    public String getOutputExtension() {\n        return OUTPUT_EXTENSION;\n    }\n\n    public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean attachToBugreport, boolean longTrace, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes) {", "    public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean attachToBugreport, boolean longTrace, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes) {\n        if (isTracingOn()) {\n            Log.e(TAG, \"Attempting to start perfetto trace but trace is already in progress\");\n            return false;\n        } else {\n            // Ensure the temporary trace file is cleared.\n            try {\n                Files.deleteIfExists(Paths.get(TEMP_TRACE_LOCATION));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        // The user chooses a per-CPU buffer size due to atrace limitations.\n        // So we use this to ensure that we reserve the correctly-sized buffer.\n        int numCpus = Runtime.getRuntime().availableProcessors();\n\n        // Build the perfetto config that will be passed on the command line.\n        StringBuilder config = new StringBuilder()\n            .append(\"write_into_file: true\\n\")\n            // Ensure that we flush ftrace data every 30s even if cpus are idle.\n            .append(\"flush_period_ms: 30000\\n\");\n\n            // If the user has flagged that in-progress trace sessions should be grabbed\n            // during bugreports, and BetterBug is present.", "            try {\n                Files.deleteIfExists(Paths.get(TEMP_TRACE_LOCATION));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        // The user chooses a per-CPU buffer size due to atrace limitations.\n        // So we use this to ensure that we reserve the correctly-sized buffer.\n        int numCpus = Runtime.getRuntime().availableProcessors();\n\n        // Build the perfetto config that will be passed on the command line.\n        StringBuilder config = new StringBuilder()\n            .append(\"write_into_file: true\\n\")\n            // Ensure that we flush ftrace data every 30s even if cpus are idle.\n            .append(\"flush_period_ms: 30000\\n\");\n\n            // If the user has flagged that in-progress trace sessions should be grabbed\n            // during bugreports, and BetterBug is present.", "            if (attachToBugreport) {\n                config.append(\"bugreport_score: 500\\n\");\n            }\n\n            // Indicates that perfetto should notify Traceur if the tracing session's status\n            // changes.\n            config.append(\"notify_traceur: true\\n\");\n\n            if (longTrace) {\n                if (maxLongTraceSizeMb != 0) {\n                    config.append(\"max_file_size_bytes: \"\n                        + (maxLongTraceSizeMb * MEGABYTES_TO_BYTES) + \"\\n\");\n                }\n", "            if (longTrace) {\n                if (maxLongTraceSizeMb != 0) {\n                    config.append(\"max_file_size_bytes: \"\n                        + (maxLongTraceSizeMb * MEGABYTES_TO_BYTES) + \"\\n\");\n                }\n\n                if (maxLongTraceDurationMinutes != 0) {\n                    config.append(\"duration_ms: \"\n                        + (maxLongTraceDurationMinutes * MINUTES_TO_MILLISECONDS)\n                        + \"\\n\");\n                }\n\n                // Default value for long traces to write to file.\n                config.append(\"file_write_period_ms: 1000\\n\");\n            } else {\n                // For short traces, we don't write to the file.\n                // So, always use the maximum value here: 7 days.\n                config.append(\"file_write_period_ms: 604800000\\n\");\n            }\n\n        config.append(\"incremental_state_config {\\n\")\n            .append(\"  clear_period_ms: 15000\\n\")\n            .append(\"} \\n\")\n            // This is target_buffer: 0, which is used for ftrace and the ftrace-derived\n            // android.gpu.memory.\n            .append(\"buffers {\\n\")\n            .append(\"  size_kb: \" + bufferSizeKb * numCpus + \"\\n\")\n            .append(\"  fill_policy: RING_BUFFER\\n\")\n            .append(\"} \\n\")\n            // This is target_buffer: 1, which is used for additional data sources.\n            .append(\"buffers {\\n\")\n            .append(\"  size_kb: 2048\\n\")\n            .append(\"  fill_policy: RING_BUFFER\\n\")\n            .append(\"} \\n\")\n            .append(\"data_sources {\\n\")\n            .append(\"  config {\\n\")\n            .append(\"    name: \\\"linux.ftrace\\\"\\n\")\n            .append(\"    target_buffer: 0\\n\")\n            .append(\"    ftrace_config {\\n\")\n            .append(\"      symbolize_ksyms: true\\n\");\n", "        for (String tag : tags) {\n            // Tags are expected to be only letters, numbers, and underscores.\n            String cleanTag = tag.replaceAll(\"[^a-zA-Z0-9_]\", \"\");\n            if (!cleanTag.equals(tag)) {\n                Log.w(TAG, \"Attempting to use an invalid tag: \" + tag);\n            }\n            config.append(\"      atrace_categories: \\\"\" + cleanTag + \"\\\"\\n\");\n        }\n\n        if (apps) {\n            config.append(\"      atrace_apps: \\\"*\\\"\\n\");\n        }\n\n        // Request a dense encoding of the common sched events (sched_switch, sched_waking).", "        if (apps) {\n            config.append(\"      atrace_apps: \\\"*\\\"\\n\");\n        }\n\n        // Request a dense encoding of the common sched events (sched_switch, sched_waking).\n        if (tags.contains(SCHED_TAG)) {\n            config.append(\"      compact_sched {\\n\");\n            config.append(\"        enabled: true\\n\");\n            config.append(\"      }\\n\");\n        }\n\n        // These parameters affect only the kernel trace buffer size and how\n        // frequently it gets moved into the userspace buffer defined above.\n        config.append(\"      buffer_size_kb: 8192\\n\")\n            .append(\"      drain_period_ms: 1000\\n\")\n            .append(\"    }\\n\")\n            .append(\"  }\\n\")\n            .append(\"}\\n\")\n            .append(\" \\n\");\n\n        // Captures initial counter values, updates are captured in ftrace.", "        if (tags.contains(MEMORY_TAG) || tags.contains(GFX_TAG)) {\n             config.append(\"data_sources: {\\n\")\n                .append(\"  config { \\n\")\n                .append(\"    name: \\\"android.gpu.memory\\\"\\n\")\n                .append(\"    target_buffer: 0\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\");\n        }\n\n        // For process association. If the memory tag is enabled,\n        // poll periodically instead of just once at the beginning.\n        config.append(\"data_sources {\\n\")\n            .append(\"  config {\\n\")\n            .append(\"    name: \\\"linux.process_stats\\\"\\n\")\n            .append(\"    target_buffer: 1\\n\");", "        if (tags.contains(MEMORY_TAG)) {\n            config.append(\"    process_stats_config {\\n\")\n                .append(\"      proc_stats_poll_ms: 60000\\n\")\n                .append(\"    }\\n\");\n        }\n        config.append(\"  }\\n\")\n            .append(\"} \\n\");\n\n        if (tags.contains(POWER_TAG)) {\n            config.append(\"data_sources: {\\n\")\n                .append(\"  config { \\n\")\n                .append(\"    name: \\\"android.power\\\"\\n\")\n                .append(\"    target_buffer: 1\\n\")\n                .append(\"    android_power_config {\\n\");", "        if (tags.contains(POWER_TAG)) {\n            config.append(\"data_sources: {\\n\")\n                .append(\"  config { \\n\")\n                .append(\"    name: \\\"android.power\\\"\\n\")\n                .append(\"    target_buffer: 1\\n\")\n                .append(\"    android_power_config {\\n\");\n            if (longTrace) {\n                config.append(\"      battery_poll_ms: 5000\\n\");\n            } else {\n                config.append(\"      battery_poll_ms: 1000\\n\");\n            }\n            config.append(\"      collect_power_rails: true\\n\")\n                .append(\"      battery_counters: BATTERY_COUNTER_CAPACITY_PERCENT\\n\")\n                .append(\"      battery_counters: BATTERY_COUNTER_CHARGE\\n\")\n                .append(\"      battery_counters: BATTERY_COUNTER_CURRENT\\n\")\n                .append(\"    }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\");\n        }\n", "        if (tags.contains(MEMORY_TAG)) {\n            config.append(\"data_sources: {\\n\")\n                .append(\"  config { \\n\")\n                .append(\"    name: \\\"android.sys_stats\\\"\\n\")\n                .append(\"    target_buffer: 1\\n\")\n                .append(\"    sys_stats_config {\\n\")\n                .append(\"      vmstat_period_ms: 1000\\n\")\n                .append(\"    }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\");\n        }\n", "        if (tags.contains(GFX_TAG)) {\n          config.append(\"data_sources: {\\n\")\n              .append(\"  config { \\n\")\n              .append(\"    name: \\\"android.surfaceflinger.frametimeline\\\"\\n\")\n              .append(\"  }\\n\")\n              .append(\"}\\n\");\n        }\n\n        if (tags.contains(CAMERA_TAG)) {\n          config.append(\"data_sources: {\\n\")\n              .append(\"  config { \\n\")\n              .append(\"    name: \\\"android.hardware.camera\\\"\\n\")\n              .append(\"    target_buffer: 1\\n\")\n              .append(\"  }\\n\")\n              .append(\"}\\n\");\n        }\n\n        // Also enable Chrome events when the WebView tag is enabled.", "        if (tags.contains(CAMERA_TAG)) {\n          config.append(\"data_sources: {\\n\")\n              .append(\"  config { \\n\")\n              .append(\"    name: \\\"android.hardware.camera\\\"\\n\")\n              .append(\"    target_buffer: 1\\n\")\n              .append(\"  }\\n\")\n              .append(\"}\\n\");\n        }\n\n        // Also enable Chrome events when the WebView tag is enabled.\n        if (tags.contains(WEBVIEW_TAG)) {\n            String chromeTraceConfig =  \"{\" +\n                \"\\\\\\\"record_mode\\\\\\\":\\\\\\\"record-continuously\\\\\\\",\" +\n                \"\\\\\\\"included_categories\\\\\\\":[\\\\\\\"*\\\\\\\"]\" +\n                \"}\";\n            config.append(\"data_sources: {\\n\")\n                .append(\"  config {\\n\")\n                .append(\"    name: \\\"org.chromium.trace_event\\\"\\n\")\n                .append(\"    chrome_config {\\n\")\n                .append(\"      trace_config: \\\"\" + chromeTraceConfig + \"\\\"\\n\")\n                .append(\"    }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\")\n                .append(\"data_sources: {\\n\")\n                .append(\"  config {\\n\")\n                .append(\"    name: \\\"org.chromium.trace_metadata\\\"\\n\")\n                .append(\"      chrome_config {\\n\")\n                .append(\"        trace_config: \\\"\" + chromeTraceConfig + \"\\\"\\n\")\n                .append(\"      }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\");\n        }\n\n        String configString = config.toString();\n\n        // If the here-doc ends early, within the config string, exit immediately.\n        // This should never happen.", "        if (tags.contains(WEBVIEW_TAG)) {\n            String chromeTraceConfig =  \"{\" +\n                \"\\\\\\\"record_mode\\\\\\\":\\\\\\\"record-continuously\\\\\\\",\" +\n                \"\\\\\\\"included_categories\\\\\\\":[\\\\\\\"*\\\\\\\"]\" +\n                \"}\";\n            config.append(\"data_sources: {\\n\")\n                .append(\"  config {\\n\")\n                .append(\"    name: \\\"org.chromium.trace_event\\\"\\n\")\n                .append(\"    chrome_config {\\n\")\n                .append(\"      trace_config: \\\"\" + chromeTraceConfig + \"\\\"\\n\")\n                .append(\"    }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\")\n                .append(\"data_sources: {\\n\")\n                .append(\"  config {\\n\")\n                .append(\"    name: \\\"org.chromium.trace_metadata\\\"\\n\")\n                .append(\"      chrome_config {\\n\")\n                .append(\"        trace_config: \\\"\" + chromeTraceConfig + \"\\\"\\n\")\n                .append(\"      }\\n\")\n                .append(\"  }\\n\")\n                .append(\"}\\n\");\n        }\n\n        String configString = config.toString();\n\n        // If the here-doc ends early, within the config string, exit immediately.\n        // This should never happen.", "        if (configString.contains(MARKER)) {\n            throw new RuntimeException(\"The arguments to the Perfetto command are malformed.\");\n        }\n\n        String cmd = \"perfetto --detach=\" + PERFETTO_TAG\n            + \" -o \" + TEMP_TRACE_LOCATION\n            + \" -c - --txt\"\n            + \" <<\" + MARKER +\"\\n\" + configString + \"\\n\" + MARKER;\n\n        Log.v(TAG, \"Starting perfetto trace.\");\n        try {\n            Process process = TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);", "        try {\n            Process process = TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);\n            if (process == null) {\n                return false;\n            } else if (process.exitValue() != 0) {\n                Log.e(TAG, \"perfetto traceStart failed with: \" + process.exitValue());\n                return false;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        Log.v(TAG, \"perfetto traceStart succeeded!\");\n        return true;\n    }\n", "    public void traceStop() {\n        Log.v(TAG, \"Stopping perfetto trace.\");\n\n        if (!isTracingOn()) {\n            Log.w(TAG, \"No trace appears to be in progress. Stopping perfetto trace may not work.\");\n        }\n\n        String cmd = \"perfetto --stop --attach=\" + PERFETTO_TAG;\n        try {\n            Process process = TraceUtils.execWithTimeout(cmd, null, STOP_TIMEOUT_MS);\n            if (process != null && process.exitValue() != 0) {\n                Log.e(TAG, \"perfetto traceStop failed with: \" + process.exitValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "        try {\n            Process process = TraceUtils.execWithTimeout(cmd, null, STOP_TIMEOUT_MS);\n            if (process != null && process.exitValue() != 0) {\n                Log.e(TAG, \"perfetto traceStop failed with: \" + process.exitValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean traceDump(File outFile) {\n        traceStop();\n\n        // Short-circuit if a trace was not stopped.", "    public boolean traceDump(File outFile) {\n        traceStop();\n\n        // Short-circuit if a trace was not stopped.\n        if (isTracingOn()) {\n            Log.e(TAG, \"Trace was not stopped successfully, aborting trace dump.\");\n            return false;\n        }\n\n        // Short-circuit if the file we're trying to dump to doesn't exist.\n        if (!Files.exists(Paths.get(TEMP_TRACE_LOCATION))) {\n            Log.e(TAG, \"In-progress trace file doesn't exist, aborting trace dump.\");\n            return false;\n        }\n\n        Log.v(TAG, \"Saving perfetto trace to \" + outFile);\n", "        if (!Files.exists(Paths.get(TEMP_TRACE_LOCATION))) {\n            Log.e(TAG, \"In-progress trace file doesn't exist, aborting trace dump.\");\n            return false;\n        }\n\n        Log.v(TAG, \"Saving perfetto trace to \" + outFile);\n\n        try {\n            Os.rename(TEMP_TRACE_LOCATION, outFile.getCanonicalPath());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        outFile.setReadable(true, false); // (readable, ownerOnly)\n        outFile.setWritable(true, false); // (readable, ownerOnly)\n        return true;\n    }\n", "    public boolean isTracingOn() {\n        String cmd = \"perfetto --is_detached=\" + PERFETTO_TAG;\n\n        try {\n            Process process = TraceUtils.exec(cmd);\n\n            // 0 represents a detached process exists with this name\n            // 2 represents no detached process with this name\n            // 1 (or other error code) represents an error\n            int result = process.waitFor();\n            if (result == 0) {\n                return true;", "            if (result == 0) {\n                return true;\n            } else if (result == 2) {\n                return false;\n            } else {\n                throw new RuntimeException(\"Perfetto error: \" + result);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "    public static TreeMap<String,String> perfettoListCategories() {\n        String cmd = \"perfetto --query-raw\";\n\n        Log.v(TAG, \"Listing tags: \" + cmd);\n        try {\n\n            TreeMap<String, String> result = new TreeMap<>();\n\n            // execWithTimeout() cannot be used because stdout must be consumed before the process\n            // is terminated.\n            Process perfetto = TraceUtils.exec(cmd, null, false);\n            TracingServiceState serviceState =\n                    TracingServiceState.parseFrom(perfetto.getInputStream());\n\n            // Destroy the perfetto process if it times out.", "            if (!perfetto.waitFor(LIST_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n                Log.e(TAG, \"perfettoListCategories timed out after \" + LIST_TIMEOUT_MS + \" ms.\");\n                perfetto.destroyForcibly();\n                return result;\n            }\n\n            // The perfetto process completed and failed, but does not need to be destroyed.\n            if (perfetto.exitValue() != 0) {\n                Log.e(TAG, \"perfettoListCategories failed with: \" + perfetto.exitValue());\n            }\n\n            List<AtraceCategory> categories = null;\n", "            for (DataSource dataSource : serviceState.getDataSourcesList()) {\n                DataSourceDescriptor dataSrcDescriptor = dataSource.getDsDescriptor();\n                if (dataSrcDescriptor.getName().equals(\"linux.ftrace\")){\n                    categories = dataSrcDescriptor.getFtraceDescriptor().getAtraceCategoriesList();\n                    break;\n                }\n            }\n\n            if (categories != null) {\n                for (AtraceCategory category : categories) {\n                    result.put(category.getName(), category.getDescription());\n                }\n            }\n            return result;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "            if (categories != null) {\n                for (AtraceCategory category : categories) {\n                    result.put(category.getName(), category.getDescription());\n                }\n            }\n            return result;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/UserConsentActivityDialog.java", "chunked_list": ["/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ActivityNotFoundException;\nimport android.content.SharedPreferences;", "import android.content.ActivityNotFoundException;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.preference.PreferenceManager;\nimport android.view.LayoutInflater;\nimport android.widget.CheckBox;\nimport android.widget.Toast;\n\nimport java.io.File;", "\nimport java.io.File;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\n\n/**\n * Dialog that warns about contents of a trace.\n * Adapted from fw/base/packages/Shell's BugreportWarningActivity.\n */\npublic class UserConsentActivityDialog extends AlertActivity\n        implements DialogInterface.OnClickListener {\n\n    private static final String TAG = \"Traceur\";\n\n    private static final String PREF_KEY_SHOW_DIALOG = \"show-dialog\";\n    private static final int PREF_STATE_SHOW = 0;\n    private static final int PREF_STATE_HIDE = 1;\n\n    private Intent mNextIntent;\n    private CheckBox mDontShowAgain;\n\n    @Override", " * Adapted from fw/base/packages/Shell's BugreportWarningActivity.\n */\npublic class UserConsentActivityDialog extends AlertActivity\n        implements DialogInterface.OnClickListener {\n\n    private static final String TAG = \"Traceur\";\n\n    private static final String PREF_KEY_SHOW_DIALOG = \"show-dialog\";\n    private static final int PREF_STATE_SHOW = 0;\n    private static final int PREF_STATE_HIDE = 1;\n\n    private Intent mNextIntent;\n    private CheckBox mDontShowAgain;\n\n    @Override", "    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n\n        this.getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        mNextIntent = getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n\n        // If the user has previously indicated to never show this dialog again,\n        // go ahead and start the target intent and finish this activity.\n        if (getShowDialogState(this) == PREF_STATE_HIDE) {\n            startActivity(mNextIntent);\n            finish();\n        }\n\n        final AlertController.AlertParams params = mAlertParams;\n        params.mView = LayoutInflater.from(this).inflate(\n            R.layout.consent_dialog_checkbox, null);\n        params.mTitle = getString(R.string.share_trace);\n        params.mMessage = getString(R.string.system_trace_sensitive_data);\n        params.mPositiveButtonText = getString(R.string.share);\n        params.mNegativeButtonText = getString(android.R.string.cancel);\n        params.mPositiveButtonListener = this;\n        params.mNegativeButtonListener = this;\n\n        mDontShowAgain = (CheckBox) params.mView.findViewById(android.R.id.checkbox);\n\n        setupAlert();\n    }\n\n    @Override", "        if (getShowDialogState(this) == PREF_STATE_HIDE) {\n            startActivity(mNextIntent);\n            finish();\n        }\n\n        final AlertController.AlertParams params = mAlertParams;\n        params.mView = LayoutInflater.from(this).inflate(\n            R.layout.consent_dialog_checkbox, null);\n        params.mTitle = getString(R.string.share_trace);\n        params.mMessage = getString(R.string.system_trace_sensitive_data);\n        params.mPositiveButtonText = getString(R.string.share);\n        params.mNegativeButtonText = getString(android.R.string.cancel);\n        params.mPositiveButtonListener = this;\n        params.mNegativeButtonListener = this;\n\n        mDontShowAgain = (CheckBox) params.mView.findViewById(android.R.id.checkbox);\n\n        setupAlert();\n    }\n\n    @Override", "    public void onClick(DialogInterface dialog, int which) {\n        if (which == AlertDialog.BUTTON_POSITIVE) {\n            if (mDontShowAgain.isChecked()) {\n                setShowDialogState(this, PREF_STATE_HIDE);\n            }\n            try {\n                startActivity(mNextIntent);\n            } catch (ActivityNotFoundException e) {\n                Toast toast = Toast.makeText(getApplicationContext(),\n                        \"There are no apps available to share a trace with.\", Toast.LENGTH_LONG);\n                toast.show();\n                Log.e(TAG, \"Sharing trace failed: No apps available.\");\n            }\n        }\n\n        finish();\n    }\n\n    private int getShowDialogState(Context context) {\n        final SharedPreferences prefs =\n            PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getInt(PREF_KEY_SHOW_DIALOG, PREF_STATE_SHOW);\n    }\n\n    private void setShowDialogState(Context context, int value) {\n        final SharedPreferences prefs =\n            PreferenceManager.getDefaultSharedPreferences(context);\n        prefs.edit().putInt(PREF_KEY_SHOW_DIALOG, value).apply();\n    }\n}\n"]}
{"filename": "src/com/android/traceur/TraceurBackupAgent.java", "chunked_list": ["package com.android.traceur;\n\nimport android.app.backup.BackupAgentHelper;\nimport android.app.backup.SharedPreferencesBackupHelper;\nimport android.preference.PreferenceManager;\nimport com.android.traceur.Receiver;\n\npublic class TraceurBackupAgent extends BackupAgentHelper {\n\n    private static final String PREFS_BACKUP_KEY = \"traceur_backup_prefs\";\n\n    @Override", "    public void onCreate() {\n        SharedPreferencesBackupHelper helper = new SharedPreferencesBackupHelper(\n                this, PreferenceManager.getDefaultSharedPreferencesName(this));\n        addHelper(PREFS_BACKUP_KEY, helper);\n    }\n\n    @Override\n    public void onRestoreFinished() {\n        Receiver.updateQuickSettings(this);\n    }\n}\n"]}
{"filename": "src/com/android/traceur/StopTraceService.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.os.UserManager;\nimport android.preference.PreferenceManager;\nimport android.provider.Settings;\nimport android.util.EventLog;", "import android.provider.Settings;\nimport android.util.EventLog;\nimport android.util.Log;\n\npublic class StopTraceService extends TraceService {\n    private static final String TAG = \"Traceur\";\n\n    public StopTraceService() {\n        super(\"StopTraceService\");\n        setIntentRedelivery(true);\n    }\n\n    /* If we stop a trace using this entrypoint, we must also reset the preference and the\n     * Quick Settings UI, since this may be the only indication that the user wants to stop the\n     * trace.\n    */\n    @Override", "    public void onHandleIntent(Intent intent) {\n        Context context = getApplicationContext();\n        // Checks that developer options are enabled and the user is an admin before continuing.\n        boolean developerOptionsEnabled =\n                Settings.Global.getInt(context.getContentResolver(),\n                        Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n        if (!developerOptionsEnabled) {\n            // Refer to b/204992293.\n            EventLog.writeEvent(0x534e4554, \"204992293\", -1, \"\");\n            return;\n        }\n        UserManager userManager = context.getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);", "        if (!isAdminUser || debuggingDisallowed) {\n            return;\n        }\n        // Ensures that only intents that pertain to stopping a trace and need to be accessed from\n        // outside Traceur are passed to TraceService through StopTraceService.\n        String intentAction = intent.getAction();\n        if (!intentAction.equals(TraceService.INTENT_ACTION_NOTIFY_SESSION_STOLEN) &&\n            !intentAction.equals(TraceService.INTENT_ACTION_NOTIFY_SESSION_STOPPED)) {\n            return;\n        }\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        boolean prefsTracingOn =\n            prefs.getBoolean(context.getString(R.string.pref_key_tracing_on), false);\n\n        // If the user thinks tracing is off and the trace processor agrees, we have no work to do.\n        // We must still start a foreground service, but let's log as an FYI.", "        if (!prefsTracingOn && !TraceUtils.isTracingOn()) {\n            Log.i(TAG, \"StopTraceService does not see a trace to stop.\");\n        }\n\n        PreferenceManager.getDefaultSharedPreferences(context)\n                .edit().putBoolean(context.getString(R.string.pref_key_tracing_on),\n                        false).commit();\n        context.sendBroadcast(new Intent(MainFragment.ACTION_REFRESH_TAGS));\n        QsService.updateTile();\n        super.onHandleIntent(intent);\n    }\n}\n"]}
{"filename": "src/com/android/traceur/QsService.java", "chunked_list": ["/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.content.SharedPreferences;\nimport android.graphics.drawable.Icon;\nimport android.preference.PreferenceManager;\nimport android.service.quicksettings.Tile;\nimport android.service.quicksettings.TileService;\n\npublic class QsService extends TileService {\n\n    private static QsService sListeningInstance;\n", "public class QsService extends TileService {\n\n    private static QsService sListeningInstance;\n\n    public static void updateTile() {\n        if (sListeningInstance != null) {\n            sListeningInstance.update();\n        }\n    }\n\n    @Override", "    public void onStartListening() {\n        sListeningInstance = this;\n        update();\n    }\n\n    @Override\n    public void onStopListening() {\n        if (sListeningInstance == this) {\n            sListeningInstance = null;\n        }\n    }\n\n    private void update() {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n        boolean tracingOn = prefs.getBoolean(getString(R.string.pref_key_tracing_on), false);\n\n        String titleString = getString(tracingOn ? R.string.stop_tracing: R.string.record_trace);\n\n        getQsTile().setIcon(Icon.createWithResource(this, R.drawable.bugfood_icon));\n        getQsTile().setState(tracingOn ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE);\n        getQsTile().setLabel(titleString);\n        getQsTile().updateTile();\n        Receiver.updateDeveloperOptionsWatcher(this);\n    }\n\n    /** When we click the tile, toggle tracing state.\n     *  If tracing is being turned off, dump and offer to share. */\n    @Override", "    public void onClick() {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n        boolean newTracingState = !prefs.getBoolean(getString(R.string.pref_key_tracing_on), false);\n        prefs.edit().putBoolean(getString(R.string.pref_key_tracing_on), newTracingState).commit();\n\n        Receiver.updateTracing(this);\n    }\n}\n"]}
{"filename": "src/com/android/traceur/MainActivity.java", "chunked_list": ["package com.android.traceur;\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *", " *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport android.app.Activity;", "\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.os.UserManager;\nimport android.provider.Settings;\n\nimport com.android.settingslib.collapsingtoolbar.CollapsingToolbarBaseActivity;\n\npublic class MainActivity extends CollapsingToolbarBaseActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        boolean developerOptionsIsEnabled =\n            Settings.Global.getInt(getApplicationContext().getContentResolver(),\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n\n        UserManager userManager = getApplicationContext()\n                .getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);\n", "public class MainActivity extends CollapsingToolbarBaseActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        boolean developerOptionsIsEnabled =\n            Settings.Global.getInt(getApplicationContext().getContentResolver(),\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n\n        UserManager userManager = getApplicationContext()\n                .getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);\n", "        if (!developerOptionsIsEnabled || !isAdminUser || debuggingDisallowed) {\n            finish();\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/StorageProvider.java", "chunked_list": ["/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.traceur;\n\nimport android.database.Cursor;", "\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.FileUtils;\nimport android.os.CancellationSignal;\nimport android.os.ParcelFileDescriptor;\nimport android.os.UserManager;\nimport android.provider.DocumentsContract;", "import android.os.UserManager;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Settings;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport java.io.File;", "\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\n/**\n * Adds an entry for traces in the file picker.\n */\npublic class StorageProvider extends FileSystemProvider{\n\n    public static final String TAG = StorageProvider.class.getName();\n    public static final String AUTHORITY = \"com.android.traceur.documents\";\n\n    private static final String DOC_ID_ROOT = \"traces\";\n    private static final String ROOT_DIR = \"/data/local/traces\";\n    private static final String MIME_TYPE = \"application/vnd.android.systrace\";\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID,\n            Root.COLUMN_ICON,\n            Root.COLUMN_TITLE,\n            Root.COLUMN_FLAGS,\n            Root.COLUMN_DOCUMENT_ID,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID,\n            Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_MIME_TYPE,\n            Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n            Document.COLUMN_LAST_MODIFIED,\n    };\n\n    @Override", "    public static final String TAG = StorageProvider.class.getName();\n    public static final String AUTHORITY = \"com.android.traceur.documents\";\n\n    private static final String DOC_ID_ROOT = \"traces\";\n    private static final String ROOT_DIR = \"/data/local/traces\";\n    private static final String MIME_TYPE = \"application/vnd.android.systrace\";\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID,\n            Root.COLUMN_ICON,\n            Root.COLUMN_TITLE,\n            Root.COLUMN_FLAGS,\n            Root.COLUMN_DOCUMENT_ID,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID,\n            Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_MIME_TYPE,\n            Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n            Document.COLUMN_LAST_MODIFIED,\n    };\n\n    @Override", "    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        return true;\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n\n        boolean developerOptionsIsEnabled =\n            Settings.Global.getInt(getContext().getContentResolver(),\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n        UserManager userManager = getContext().getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);\n\n        // If developer options is not enabled or the user is not an admin, return an empty root\n        // cursor. This removes the provider from the list entirely.", "        if (!developerOptionsIsEnabled || !isAdminUser || debuggingDisallowed) {\n            return null;\n        }\n\n        final MatrixCursor.RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY);\n        row.add(Root.COLUMN_MIME_TYPES, MIME_TYPE);\n        row.add(Root.COLUMN_ICON, R.drawable.bugfood_icon_green);\n        row.add(Root.COLUMN_TITLE,\n            getContext().getString(R.string.system_traces_storage_title));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        return result;\n    }\n\n    @Override", "    public Cursor queryDocument(String documentId, String[] projection)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n        final MatrixCursor.RowBuilder row = result.newRow();\n        File file;\n        String mimeType;\n\n        if (DOC_ID_ROOT.equals(documentId)) {\n            file = new File(ROOT_DIR);\n            mimeType = Document.MIME_TYPE_DIR;\n        } else {\n            file = getFileForDocId(documentId);\n            mimeType = MIME_TYPE;\n        }\n\n        row.add(Document.COLUMN_DOCUMENT_ID, documentId);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_DISPLAY_NAME, file.getName());\n        row.add(Document.COLUMN_LAST_MODIFIED, file.lastModified());\n        row.add(Document.COLUMN_SIZE, file.length());\n        row.add(Document.COLUMN_FLAGS, Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_SUPPORTS_DELETE);\n        return result;\n    }\n\n    @Override", "    public Cursor queryChildDocuments(\n            String parentDocumentId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        Cursor result = super.queryChildDocuments(parentDocumentId, projection, sortOrder);\n\n        Bundle bundle = new Bundle();\n        bundle.putString(DocumentsContract.EXTRA_INFO,\n            getContext().getResources().getString(R.string.system_trace_sensitive_data));\n        result.setExtras(bundle);\n\n        return result;\n    }\n\n\n    @Override", "    public ParcelFileDescriptor openDocument(\n            String documentId, String mode, CancellationSignal signal)\n            throws FileNotFoundException, UnsupportedOperationException {\n        if (ParcelFileDescriptor.parseMode(mode) != ParcelFileDescriptor.MODE_READ_ONLY) {\n            throw new UnsupportedOperationException(\n                \"Attempt to open read-only file \" + documentId + \" in mode \" + mode);\n        }\n        return ParcelFileDescriptor.open(getFileForDocId(documentId),\n                ParcelFileDescriptor.MODE_READ_ONLY);\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) {\n        return DOC_ID_ROOT + \":\" + file.getName();\n    }\n\n    @Override\n    protected File getFileForDocId(String documentId, boolean visible)\n            throws FileNotFoundException {", "        if (DOC_ID_ROOT.equals(documentId)) {\n            return new File(ROOT_DIR);\n        } else {\n            final int splitIndex = documentId.indexOf(':', 1);\n            final String name = documentId.substring(splitIndex + 1);\n            if (splitIndex == -1 || !DOC_ID_ROOT.equals(documentId.substring(0, splitIndex)) ||\n                    !FileUtils.isValidExtFilename(name)) {\n                throw new FileNotFoundException(\"Invalid document ID: \" + documentId);\n            }\n            final File file = new File(ROOT_DIR, name);\n            if (!file.exists()) {\n                throw new FileNotFoundException(\"File not found: \" + documentId);\n            }\n            return file;\n        }\n    }\n\n}\n", "            if (!file.exists()) {\n                throw new FileNotFoundException(\"File not found: \" + documentId);\n            }\n            return file;\n        }\n    }\n\n}\n"]}
{"filename": "src/com/android/traceur/InternalReceiver.java", "chunked_list": ["/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\n\npublic class InternalReceiver extends BroadcastReceiver {\n\n    public static final String START_ACTION = \"com.android.traceur.START\";\n\n    @Override", "public class InternalReceiver extends BroadcastReceiver {\n\n    public static final String START_ACTION = \"com.android.traceur.START\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n\n        if (START_ACTION.equals(intent.getAction())) {\n            prefs.edit().putBoolean(\n                    context.getString(R.string.pref_key_tracing_on), true).commit();\n            Receiver.updateTracing(context);\n        }\n    }\n}\n", "        if (START_ACTION.equals(intent.getAction())) {\n            prefs.edit().putBoolean(\n                    context.getString(R.string.pref_key_tracing_on), true).commit();\n            Receiver.updateTracing(context);\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/Receiver.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;", "import android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.database.ContentObserver;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;", "import android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.UserManager;\nimport android.preference.PreferenceManager;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.Log;\n\nimport com.android.internal.statusbar.IStatusBarService;", "\nimport com.android.internal.statusbar.IStatusBarService;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Receiver extends BroadcastReceiver {\n\n    public static final String STOP_ACTION = \"com.android.traceur.STOP\";\n    public static final String OPEN_ACTION = \"com.android.traceur.OPEN\";", "    public static final String STOP_ACTION = \"com.android.traceur.STOP\";\n    public static final String OPEN_ACTION = \"com.android.traceur.OPEN\";\n    public static final String BUGREPORT_STARTED =\n            \"com.android.internal.intent.action.BUGREPORT_STARTED\";\n\n    public static final String NOTIFICATION_CHANNEL_TRACING = \"trace-is-being-recorded\";\n    public static final String NOTIFICATION_CHANNEL_OTHER = \"system-tracing\";\n\n    private static final List<String> TRACE_TAGS = Arrays.asList(\n            \"aidl\", \"am\", \"binder_driver\", \"camera\", \"dalvik\", \"disk\", \"freq\",\n            \"gfx\", \"hal\", \"idle\", \"input\", \"memory\", \"memreclaim\", \"network\", \"power\",\n            \"res\", \"sched\", \"sync\", \"thermal\", \"view\", \"webview\", \"wm\", \"workq\");\n\n    /* The user list doesn't include workq or sync, because the user builds don't have\n     * permissions for them. */\n    private static final List<String> TRACE_TAGS_USER = Arrays.asList(\n            \"aidl\", \"am\", \"binder_driver\", \"camera\", \"dalvik\", \"disk\", \"freq\",\n            \"gfx\", \"hal\", \"idle\", \"input\", \"memory\", \"memreclaim\", \"network\", \"power\",\n            \"res\", \"sched\", \"thermal\", \"view\", \"webview\", \"wm\");\n\n    private static final String TAG = \"Traceur\";\n\n    private static final String BETTERBUG_PACKAGE_NAME =\n            \"com.google.android.apps.internal.betterbug\";\n\n    private static Set<String> mDefaultTagList = null;\n    private static ContentObserver mDeveloperOptionsObserver;\n\n    @Override", "    public void onReceive(Context context, Intent intent) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n\n        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {\n            Log.i(TAG, \"Received BOOT_COMPLETE\");\n            createNotificationChannels(context);\n            updateDeveloperOptionsWatcher(context);\n            // We know that Perfetto won't be tracing already at boot, so pass the\n            // tracingIsOff argument to avoid the Perfetto check.\n            updateTracing(context, /* assumeTracingIsOff= */ true);\n        } else if (Intent.ACTION_USER_FOREGROUND.equals(intent.getAction())) {\n            boolean developerOptionsEnabled = (1 ==\n                Settings.Global.getInt(context.getContentResolver(),\n                    Settings.Global.DEVELOPMENT_SETTINGS_ENABLED , 0));\n            UserManager userManager = context.getSystemService(UserManager.class);\n            boolean isAdminUser = userManager.isAdminUser();\n            boolean debuggingDisallowed = userManager.hasUserRestriction(\n                    UserManager.DISALLOW_DEBUGGING_FEATURES);\n            updateStorageProvider(context,\n                    developerOptionsEnabled && isAdminUser && !debuggingDisallowed);", "        } else if (Intent.ACTION_USER_FOREGROUND.equals(intent.getAction())) {\n            boolean developerOptionsEnabled = (1 ==\n                Settings.Global.getInt(context.getContentResolver(),\n                    Settings.Global.DEVELOPMENT_SETTINGS_ENABLED , 0));\n            UserManager userManager = context.getSystemService(UserManager.class);\n            boolean isAdminUser = userManager.isAdminUser();\n            boolean debuggingDisallowed = userManager.hasUserRestriction(\n                    UserManager.DISALLOW_DEBUGGING_FEATURES);\n            updateStorageProvider(context,\n                    developerOptionsEnabled && isAdminUser && !debuggingDisallowed);\n        } else if (STOP_ACTION.equals(intent.getAction())) {\n            prefs.edit().putBoolean(\n                    context.getString(R.string.pref_key_tracing_on), false).commit();\n            updateTracing(context);", "        } else if (STOP_ACTION.equals(intent.getAction())) {\n            prefs.edit().putBoolean(\n                    context.getString(R.string.pref_key_tracing_on), false).commit();\n            updateTracing(context);\n        } else if (OPEN_ACTION.equals(intent.getAction())) {\n            context.sendBroadcast(new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS));\n            context.startActivity(new Intent(context, MainActivity.class)\n                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        } else if (BUGREPORT_STARTED.equals(intent.getAction())) {\n            // If stop_on_bugreport is set and attach_to_bugreport is not, stop tracing.\n            // Otherwise, if attach_to_bugreport is set perfetto will end the session,\n            // and we should not take action on the Traceur side.", "        } else if (BUGREPORT_STARTED.equals(intent.getAction())) {\n            // If stop_on_bugreport is set and attach_to_bugreport is not, stop tracing.\n            // Otherwise, if attach_to_bugreport is set perfetto will end the session,\n            // and we should not take action on the Traceur side.\n            if (prefs.getBoolean(context.getString(R.string.pref_key_stop_on_bugreport), false) &&\n                !prefs.getBoolean(context.getString(\n                        R.string.pref_key_attach_to_bugreport), true)) {\n                Log.d(TAG, \"Bugreport started, ending trace.\");\n                prefs.edit().putBoolean(context.getString(R.string.pref_key_tracing_on), false).commit();\n                updateTracing(context);\n            }\n        }\n    }\n\n    /*\n     * Updates the current tracing state based on the current state of preferences.\n     */", "    public static void updateTracing(Context context) {\n        updateTracing(context, false);\n    }\n\n    public static void updateTracing(Context context, boolean assumeTracingIsOff) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        boolean prefsTracingOn =\n                prefs.getBoolean(context.getString(R.string.pref_key_tracing_on), false);\n\n        boolean traceUtilsTracingOn = assumeTracingIsOff ? false : TraceUtils.isTracingOn();\n", "        if (prefsTracingOn != traceUtilsTracingOn) {\n            if (prefsTracingOn) {\n                // Show notification if the tags in preferences are not all actually available.\n                Set<String> activeAvailableTags = getActiveTags(context, prefs, true);\n                Set<String> activeTags = getActiveTags(context, prefs, false);\n\n                if (!activeAvailableTags.equals(activeTags)) {\n                    postCategoryNotification(context, prefs);\n                }\n\n                int bufferSize = Integer.parseInt(\n                    prefs.getString(context.getString(R.string.pref_key_buffer_size),\n                        context.getString(R.string.default_buffer_size)));\n\n                boolean appTracing = prefs.getBoolean(context.getString(R.string.pref_key_apps), true);\n                boolean longTrace = prefs.getBoolean(context.getString(R.string.pref_key_long_traces), true);\n\n                int maxLongTraceSize = Integer.parseInt(\n                    prefs.getString(context.getString(R.string.pref_key_max_long_trace_size),\n                        context.getString(R.string.default_long_trace_size)));\n\n                int maxLongTraceDuration = Integer.parseInt(\n                    prefs.getString(context.getString(R.string.pref_key_max_long_trace_duration),\n                        context.getString(R.string.default_long_trace_duration)));\n\n                TraceService.startTracing(context, activeAvailableTags, bufferSize,\n                    appTracing, longTrace, maxLongTraceSize, maxLongTraceDuration);\n            } else {\n                TraceService.stopTracing(context);\n            }\n        }\n\n        // Update the main UI and the QS tile.\n        context.sendBroadcast(new Intent(MainFragment.ACTION_REFRESH_TAGS));\n        QsService.updateTile();\n    }\n\n    /*\n     * Updates the current Quick Settings tile state based on the current state\n     * of preferences.\n     */", "    public static void updateQuickSettings(Context context) {\n        boolean quickSettingsEnabled =\n            PreferenceManager.getDefaultSharedPreferences(context)\n              .getBoolean(context.getString(R.string.pref_key_quick_setting), false);\n\n        ComponentName name = new ComponentName(context, QsService.class);\n        context.getPackageManager().setComponentEnabledSetting(name,\n            quickSettingsEnabled\n                ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n            PackageManager.DONT_KILL_APP);\n\n        IStatusBarService statusBarService = IStatusBarService.Stub.asInterface(\n            ServiceManager.checkService(Context.STATUS_BAR_SERVICE));\n", "        try {\n            if (statusBarService != null) {\n                if (quickSettingsEnabled) {\n                    statusBarService.addTile(name);\n                } else {\n                    statusBarService.remTile(name);\n                }\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Failed to modify QS tile for Traceur.\", e);\n        }\n\n        QsService.updateTile();\n    }\n\n    /*\n     * When Developer Options are toggled, also toggle the Storage Provider that\n     * shows \"System traces\" in Files.\n     * When Developer Options are turned off, reset the Show Quick Settings Tile\n     * preference to false to hide the tile. The user will need to re-enable the\n     * preference if they decide to turn Developer Options back on again.\n     */\n    static void updateDeveloperOptionsWatcher(Context context) {", "        if (mDeveloperOptionsObserver == null) {\n            Uri settingUri = Settings.Global.getUriFor(\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);\n\n            mDeveloperOptionsObserver =\n                new ContentObserver(new Handler()) {\n                    @Override\n                    public void onChange(boolean selfChange) {\n                        super.onChange(selfChange);\n\n                        boolean developerOptionsEnabled = (1 ==\n                            Settings.Global.getInt(context.getContentResolver(),\n                                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED , 0));\n                        UserManager userManager = context.getSystemService(UserManager.class);\n                        boolean isAdminUser = userManager.isAdminUser();\n                        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                                UserManager.DISALLOW_DEBUGGING_FEATURES);\n                        updateStorageProvider(context,\n                                developerOptionsEnabled && isAdminUser && !debuggingDisallowed);\n", "                        if (!developerOptionsEnabled) {\n                            SharedPreferences prefs =\n                                PreferenceManager.getDefaultSharedPreferences(context);\n                            prefs.edit().putBoolean(\n                                context.getString(R.string.pref_key_quick_setting), false)\n                                .commit();\n                            updateQuickSettings(context);\n                            // Stop an ongoing trace if one exists.\n                            if (TraceUtils.isTracingOn()) {\n                                TraceService.stopTracingWithoutSaving(context);\n                            }\n                        }\n                    }\n                };\n\n            context.getContentResolver().registerContentObserver(settingUri,\n                false, mDeveloperOptionsObserver);\n            mDeveloperOptionsObserver.onChange(true);\n        }\n    }\n\n    // Enables/disables the System Traces storage component. enableProvider should be true iff\n    // developer options are enabled and the current user is an admin user.\n    static void updateStorageProvider(Context context, boolean enableProvider) {\n        ComponentName name = new ComponentName(context, StorageProvider.class);\n        context.getPackageManager().setComponentEnabledSetting(name,\n                enableProvider\n                        ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                PackageManager.DONT_KILL_APP);\n    }\n\n    private static void postCategoryNotification(Context context, SharedPreferences prefs) {\n        Intent sendIntent = new Intent(context, MainActivity.class);\n\n        String title = context.getString(R.string.tracing_categories_unavailable);\n        String msg = TextUtils.join(\", \", getActiveUnavailableTags(context, prefs));\n        final Notification.Builder builder =\n            new Notification.Builder(context, NOTIFICATION_CHANNEL_OTHER)\n                .setSmallIcon(R.drawable.bugfood_icon)\n                .setContentTitle(title)\n                .setTicker(title)\n                .setContentText(msg)\n                .setContentIntent(PendingIntent.getActivity(\n                        context, 0, sendIntent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT\n                                | PendingIntent.FLAG_IMMUTABLE))\n                .setAutoCancel(true)\n                .setLocalOnly(true)\n                .setColor(context.getColor(\n                        com.android.internal.R.color.system_notification_accent_color));\n", "                            if (TraceUtils.isTracingOn()) {\n                                TraceService.stopTracingWithoutSaving(context);\n                            }\n                        }\n                    }\n                };\n\n            context.getContentResolver().registerContentObserver(settingUri,\n                false, mDeveloperOptionsObserver);\n            mDeveloperOptionsObserver.onChange(true);\n        }\n    }\n\n    // Enables/disables the System Traces storage component. enableProvider should be true iff\n    // developer options are enabled and the current user is an admin user.\n    static void updateStorageProvider(Context context, boolean enableProvider) {\n        ComponentName name = new ComponentName(context, StorageProvider.class);\n        context.getPackageManager().setComponentEnabledSetting(name,\n                enableProvider\n                        ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                PackageManager.DONT_KILL_APP);\n    }\n\n    private static void postCategoryNotification(Context context, SharedPreferences prefs) {\n        Intent sendIntent = new Intent(context, MainActivity.class);\n\n        String title = context.getString(R.string.tracing_categories_unavailable);\n        String msg = TextUtils.join(\", \", getActiveUnavailableTags(context, prefs));\n        final Notification.Builder builder =\n            new Notification.Builder(context, NOTIFICATION_CHANNEL_OTHER)\n                .setSmallIcon(R.drawable.bugfood_icon)\n                .setContentTitle(title)\n                .setTicker(title)\n                .setContentText(msg)\n                .setContentIntent(PendingIntent.getActivity(\n                        context, 0, sendIntent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT\n                                | PendingIntent.FLAG_IMMUTABLE))\n                .setAutoCancel(true)\n                .setLocalOnly(true)\n                .setColor(context.getColor(\n                        com.android.internal.R.color.system_notification_accent_color));\n", "        if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {\n            builder.extend(new Notification.TvExtender());\n        }\n\n        context.getSystemService(NotificationManager.class)\n            .notify(Receiver.class.getName(), 0, builder.build());\n    }\n\n    private static void createNotificationChannels(Context context) {\n        NotificationChannel tracingChannel = new NotificationChannel(\n            NOTIFICATION_CHANNEL_TRACING,\n            context.getString(R.string.trace_is_being_recorded),\n            NotificationManager.IMPORTANCE_HIGH);\n        tracingChannel.setBypassDnd(true);\n        tracingChannel.enableVibration(true);\n        tracingChannel.setSound(null, null);\n\n        NotificationChannel saveTraceChannel = new NotificationChannel(\n            NOTIFICATION_CHANNEL_OTHER,\n            context.getString(R.string.saving_trace),\n            NotificationManager.IMPORTANCE_HIGH);\n        saveTraceChannel.setBypassDnd(true);\n        saveTraceChannel.enableVibration(true);\n        saveTraceChannel.setSound(null, null);\n\n        NotificationManager notificationManager =\n            context.getSystemService(NotificationManager.class);\n        notificationManager.createNotificationChannel(tracingChannel);\n        notificationManager.createNotificationChannel(saveTraceChannel);\n    }\n", "    public static Set<String> getActiveTags(Context context, SharedPreferences prefs, boolean onlyAvailable) {\n        Set<String> tags = prefs.getStringSet(context.getString(R.string.pref_key_tags),\n                getDefaultTagList());\n        Set<String> available = TraceUtils.listCategories().keySet();\n\n        if (onlyAvailable) {\n            tags.retainAll(available);\n        }\n\n        Log.v(TAG, \"getActiveTags(onlyAvailable=\" + onlyAvailable + \") = \\\"\" + tags.toString() + \"\\\"\");\n        return tags;\n    }\n", "    public static Set<String> getActiveUnavailableTags(Context context, SharedPreferences prefs) {\n        Set<String> tags = prefs.getStringSet(context.getString(R.string.pref_key_tags),\n                getDefaultTagList());\n        Set<String> available = TraceUtils.listCategories().keySet();\n\n        tags.removeAll(available);\n\n        Log.v(TAG, \"getActiveUnavailableTags() = \\\"\" + tags.toString() + \"\\\"\");\n        return tags;\n    }\n", "    public static Set<String> getDefaultTagList() {\n        if (mDefaultTagList == null) {\n            mDefaultTagList = new ArraySet<String>(Build.TYPE.equals(\"user\")\n                ? TRACE_TAGS_USER : TRACE_TAGS);\n        }\n\n        return mDefaultTagList;\n    }\n}\n"]}
{"filename": "src/com/android/traceur/AtraceUtils.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.sysprop.TraceProperties;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.List;\n\nimport com.android.traceur.TraceUtils.Streamer;\n\n/**", "\n/**\n * Utility functions for calling atrace\n */\npublic class AtraceUtils implements TraceUtils.TraceEngine {\n\n    static final String TAG = \"Traceur\";\n\n    private static final String DEBUG_TRACING_FILE = \"/sys/kernel/debug/tracing/tracing_on\";\n    private static final String TRACING_FILE = \"/sys/kernel/tracing/tracing_on\";\n", "    public static String NAME = \"ATRACE\";\n    private static String OUTPUT_EXTENSION = \"ctrace\";\n\n    public String getName() {\n        return NAME;\n    }\n\n    public String getOutputExtension() {\n        return OUTPUT_EXTENSION;\n    }\n\n    /* Note: attachToBugreport, longTrace, maxLongTrace* parameters are ignored in atrace mode. */", "    public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean attachToBugreport, boolean longTrace, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes) {\n        String appParameter = apps ? \"-a '*' \" : \"\";\n        String cmd = \"atrace --async_start -c -b \" + bufferSizeKb + \" \"\n            + appParameter + TextUtils.join(\" \", tags);\n\n        Log.v(TAG, \"Starting async atrace: \" + cmd);\n        try {\n            Process atrace = TraceUtils.exec(cmd);\n            if (atrace.waitFor() != 0) {\n                Log.e(TAG, \"atraceStart failed with: \" + atrace.exitValue());\n                return false;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return true;\n    }\n", "        try {\n            Process atrace = TraceUtils.exec(cmd);\n            if (atrace.waitFor() != 0) {\n                Log.e(TAG, \"atraceStart failed with: \" + atrace.exitValue());\n                return false;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return true;\n    }\n", "    public void traceStop() {\n        String cmd = \"atrace --async_stop > /dev/null\";\n\n        Log.v(TAG, \"Stopping async atrace: \" + cmd);\n        try {\n            Process atrace = TraceUtils.exec(cmd);\n\n            if (atrace.waitFor() != 0) {\n                Log.e(TAG, \"atraceStop failed with: \" + atrace.exitValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "    public boolean traceDump(File outFile) {\n        String cmd = \"atrace --async_stop -z -c -o \" + outFile;\n\n        Log.v(TAG, \"Dumping async atrace: \" + cmd);\n        try {\n            Process atrace = TraceUtils.exec(cmd);\n\n            if (atrace.waitFor() != 0) {\n                Log.e(TAG, \"atraceDump failed with: \" + atrace.exitValue());\n                return false;\n            }\n\n            Process ps = TraceUtils.exec(\"ps -AT\", null, false);\n\n            new Streamer(\"atraceDump:ps:stdout\",\n                    ps.getInputStream(), new FileOutputStream(outFile, true /* append */));\n", "            if (ps.waitFor() != 0) {\n                Log.e(TAG, \"atraceDump:ps failed with: \" + ps.exitValue());\n                return false;\n            }\n\n            // Set the new file world readable to allow it to be adb pulled.\n            outFile.setReadable(true, false); // (readable, ownerOnly)\n            outFile.setWritable(true, false); // (readable, ownerOnly)\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return true;\n    }\n", "    public boolean isTracingOn() {\n        boolean userInitiatedTracingFlag =\n            TraceProperties.user_initiated().orElse(false);\n\n        if (!userInitiatedTracingFlag) {\n            return false;\n        }\n\n        boolean tracingOnFlag = false;\n\n        try {\n            List<String> tracingOnContents;\n\n            Path debugTracingOnPath = Paths.get(DEBUG_TRACING_FILE);\n            Path tracingOnPath = Paths.get(TRACING_FILE);\n", "        try {\n            List<String> tracingOnContents;\n\n            Path debugTracingOnPath = Paths.get(DEBUG_TRACING_FILE);\n            Path tracingOnPath = Paths.get(TRACING_FILE);\n\n            if (Files.isReadable(debugTracingOnPath)) {\n                tracingOnContents = Files.readAllLines(debugTracingOnPath);\n            } else if (Files.isReadable(tracingOnPath)) {\n                tracingOnContents = Files.readAllLines(tracingOnPath);\n            } else {\n                return false;\n            }\n\n            tracingOnFlag = !tracingOnContents.get(0).equals(\"0\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        return userInitiatedTracingFlag && tracingOnFlag;\n    }\n}\n", "            } else if (Files.isReadable(tracingOnPath)) {\n                tracingOnContents = Files.readAllLines(tracingOnPath);\n            } else {\n                return false;\n            }\n\n            tracingOnFlag = !tracingOnContents.get(0).equals(\"0\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        return userInitiatedTracingFlag && tracingOnFlag;\n    }\n}\n"]}
{"filename": "src/com/android/traceur/SearchProvider.java", "chunked_list": ["/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport static android.provider.SearchIndexablesContract.NON_INDEXABLES_KEYS_COLUMNS;\nimport static android.provider.SearchIndexablesContract.INDEXABLES_RAW_COLUMNS;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_KEY;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_TITLE;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_SUMMARY_ON;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_KEYWORDS;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_INTENT_ACTION;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_INTENT_TARGET_PACKAGE;", "import static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_INTENT_ACTION;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_INTENT_TARGET_PACKAGE;\nimport static android.provider.SearchIndexablesContract.COLUMN_INDEX_RAW_INTENT_TARGET_CLASS;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.os.UserManager;\nimport android.provider.SearchIndexablesProvider;", "import android.os.UserManager;\nimport android.provider.SearchIndexablesProvider;\nimport android.provider.Settings;\n\npublic class SearchProvider extends SearchIndexablesProvider {\n\n    @Override\n    public boolean onCreate() {\n        return true;\n    }\n\n    @Override", "    public Cursor queryXmlResources(String[] projection) {\n        return null;\n    }\n\n    @Override\n    public Cursor queryRawData(String[] projection) {\n        MatrixCursor cursor = new MatrixCursor(INDEXABLES_RAW_COLUMNS);\n        Context context = getContext();\n\n        Object[] ref = new Object[INDEXABLES_RAW_COLUMNS.length];\n        ref[COLUMN_INDEX_RAW_KEY] = context.getString(R.string.system_tracing);\n        ref[COLUMN_INDEX_RAW_TITLE] = context.getString(R.string.system_tracing);\n        ref[COLUMN_INDEX_RAW_SUMMARY_ON] = context.getString(R.string.record_system_activity);\n        ref[COLUMN_INDEX_RAW_KEYWORDS] = context.getString(R.string.keywords);\n        ref[COLUMN_INDEX_RAW_INTENT_ACTION] = Intent.ACTION_MAIN;\n        ref[COLUMN_INDEX_RAW_INTENT_TARGET_PACKAGE] = getContext().getApplicationInfo().packageName;\n        ref[COLUMN_INDEX_RAW_INTENT_TARGET_CLASS] = MainActivity.class.getName();\n\n        cursor.addRow(ref);\n        return cursor;\n    }\n\n    @Override", "    public Cursor queryNonIndexableKeys(String[] projection) {\n        boolean developerOptionsIsEnabled =\n            Settings.Global.getInt(getContext().getContentResolver(),\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n        UserManager userManager = getContext().getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);\n\n        // System Tracing shouldn't be searchable if developer options are not enabled or if the\n        // user is not an admin.", "        if (!developerOptionsIsEnabled || !isAdminUser || debuggingDisallowed) {\n            MatrixCursor cursor = new MatrixCursor(NON_INDEXABLES_KEYS_COLUMNS);\n            Object[] row = new Object[] {getContext().getString(R.string.system_tracing)};\n            cursor.addRow(row);\n            return cursor;\n        } else {\n            return null;\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/MainFragment.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.annotation.Nullable;\nimport android.app.AlertDialog;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;", "import android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageManager;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.icu.text.MessageFormat;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport androidx.preference.MultiSelectListPreference;\nimport androidx.preference.ListPreference;", "import androidx.preference.MultiSelectListPreference;\nimport androidx.preference.ListPreference;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceFragment;\nimport androidx.preference.PreferenceManager;\nimport androidx.preference.SwitchPreference;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Menu;", "import android.view.ViewGroup;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.widget.Toast;\n\nimport com.android.settingslib.HelpUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;", "import java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.TreeMap;\n\npublic class MainFragment extends PreferenceFragment {\n\n    static final String TAG = TraceUtils.TAG;\n", "    public static final String ACTION_REFRESH_TAGS = \"com.android.traceur.REFRESH_TAGS\";\n\n    private static final String BETTERBUG_PACKAGE_NAME =\n            \"com.google.android.apps.internal.betterbug\";\n\n    private static final String ROOT_MIME_TYPE = \"vnd.android.document/root\";\n    private static final String STORAGE_URI = \"content://com.android.traceur.documents/root\";\n\n    private SwitchPreference mTracingOn;\n\n    private AlertDialog mAlertDialog;\n    private SharedPreferences mPrefs;\n\n    private MultiSelectListPreference mTags;\n\n    private boolean mRefreshing;\n\n    private BroadcastReceiver mRefreshReceiver;\n\n    OnSharedPreferenceChangeListener mSharedPreferenceChangeListener =\n        new OnSharedPreferenceChangeListener () {", "              public void onSharedPreferenceChanged(\n                      SharedPreferences sharedPreferences, String key) {\n                  refreshUi();\n              }\n        };\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Receiver.updateDeveloperOptionsWatcher(getContext());\n\n        mPrefs = PreferenceManager.getDefaultSharedPreferences(\n                getActivity().getApplicationContext());\n\n        mTracingOn = (SwitchPreference) findPreference(getActivity().getString(R.string.pref_key_tracing_on));\n        mTracingOn.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {\n            @Override", "            public boolean onPreferenceClick(Preference preference) {\n              Receiver.updateTracing(getContext());\n              return true;\n            }\n        });\n\n        mTags = (MultiSelectListPreference) findPreference(getContext().getString(R.string.pref_key_tags));\n        mTags.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {\n            @Override\n            public boolean onPreferenceChange(Preference preference, Object newValue) {\n                if (mRefreshing) {\n                    return true;\n                }\n                Set<String> set = (Set<String>) newValue;\n                TreeMap<String, String> available = TraceUtils.listCategories();\n                ArrayList<String> clean = new ArrayList<>(set.size());\n", "            public boolean onPreferenceChange(Preference preference, Object newValue) {\n                if (mRefreshing) {\n                    return true;\n                }\n                Set<String> set = (Set<String>) newValue;\n                TreeMap<String, String> available = TraceUtils.listCategories();\n                ArrayList<String> clean = new ArrayList<>(set.size());\n\n                for (String s : set) {\n                    if (available.containsKey(s)) {\n                        clean.add(s);\n                    }\n                }\n                set.clear();\n                set.addAll(clean);\n                return true;\n            }\n        });\n\n        findPreference(\"restore_default_tags\").setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override", "                for (String s : set) {\n                    if (available.containsKey(s)) {\n                        clean.add(s);\n                    }\n                }\n                set.clear();\n                set.addAll(clean);\n                return true;\n            }\n        });\n\n        findPreference(\"restore_default_tags\").setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override", "                    public boolean onPreferenceClick(Preference preference) {\n                        refreshUi(/* restoreDefaultTags =*/ true);\n                        Toast.makeText(getContext(),\n                            getContext().getString(R.string.default_categories_restored),\n                                Toast.LENGTH_SHORT).show();\n                        return true;\n                    }\n                });\n\n        findPreference(getString(R.string.pref_key_quick_setting))\n            .setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override", "                    public boolean onPreferenceClick(Preference preference) {\n                        Receiver.updateQuickSettings(getContext());\n                        return true;\n                    }\n                });\n\n        findPreference(\"clear_saved_traces\").setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override\n                    public boolean onPreferenceClick(Preference preference) {\n                        new AlertDialog.Builder(getContext())\n                            .setTitle(R.string.clear_saved_traces_question)\n                            .setMessage(R.string.all_traces_will_be_deleted)\n                            .setPositiveButton(R.string.clear,\n                                new DialogInterface.OnClickListener() {", "                    public boolean onPreferenceClick(Preference preference) {\n                        new AlertDialog.Builder(getContext())\n                            .setTitle(R.string.clear_saved_traces_question)\n                            .setMessage(R.string.all_traces_will_be_deleted)\n                            .setPositiveButton(R.string.clear,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        TraceUtils.clearSavedTraces();\n                                    }\n                                })\n                            .setNegativeButton(android.R.string.no,\n                                new DialogInterface.OnClickListener() {", "                                    public void onClick(DialogInterface dialog, int which) {\n                                        dialog.dismiss();\n                                    }\n                                })\n                            .create()\n                            .show();\n                        return true;\n                    }\n                });\n\n        findPreference(\"trace_link_button\")\n            .setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override", "                    public boolean onPreferenceClick(Preference preference) {\n                        Intent intent = buildTraceFileViewIntent();\n                        try {\n                            startActivity(intent);\n                        } catch (ActivityNotFoundException e) {\n                            return false;\n                        }\n                        return true;\n                    }\n                });\n\n        // This disables \"Attach to bugreports\" when long traces are enabled. This cannot be done in\n        // main.xml because there are some other settings there that are enabled with long traces.\n        SwitchPreference attachToBugreport = findPreference(\n            getString(R.string.pref_key_attach_to_bugreport));\n        findPreference(getString(R.string.pref_key_long_traces))\n            .setOnPreferenceClickListener(\n                new Preference.OnPreferenceClickListener() {\n                    @Override", "                    public boolean onPreferenceClick(Preference preference) {\n                        if (((SwitchPreference) preference).isChecked()) {\n                            attachToBugreport.setEnabled(false);\n                        } else {\n                            attachToBugreport.setEnabled(true);\n                        }\n                        return true;\n                    }\n                });\n\n        refreshUi();\n\n        mRefreshReceiver = new BroadcastReceiver() {\n            @Override", "            public void onReceive(Context context, Intent intent) {\n                refreshUi();\n            }\n        };\n\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        setHasOptionsMenu(true);\n        return super.onCreateView(inflater, container, savedInstanceState);\n    }\n\n    @Override", "    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        setHasOptionsMenu(true);\n        return super.onCreateView(inflater, container, savedInstanceState);\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        getPreferenceScreen().getSharedPreferences()\n            .registerOnSharedPreferenceChangeListener(mSharedPreferenceChangeListener);\n        getActivity().registerReceiver(mRefreshReceiver, new IntentFilter(ACTION_REFRESH_TAGS));\n        Receiver.updateTracing(getContext());\n    }\n\n    @Override", "    public void onStop() {\n        getPreferenceScreen().getSharedPreferences()\n            .unregisterOnSharedPreferenceChangeListener(mSharedPreferenceChangeListener);\n        getActivity().unregisterReceiver(mRefreshReceiver);\n\n        if (mAlertDialog != null) {\n            mAlertDialog.cancel();\n            mAlertDialog = null;\n        }\n\n        super.onStop();\n    }\n\n    @Override", "    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {\n        addPreferencesFromResource(R.xml.main);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        HelpUtils.prepareHelpMenuItem(getActivity(), menu, R.string.help_url,\n            this.getClass().getName());\n    }\n\n    private Intent buildTraceFileViewIntent() {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setDataAndType(Uri.parse(STORAGE_URI), ROOT_MIME_TYPE);\n        return intent;\n    }\n\n    private void refreshUi() {\n        refreshUi(/* restoreDefaultTags =*/ false);\n    }\n\n    /*\n     * Refresh the preferences UI to make sure it reflects the current state of the preferences and\n     * system.\n     */\n    private void refreshUi(boolean restoreDefaultTags) {\n        Context context = getContext();\n\n        // Make sure the Record Trace toggle matches the preference value.\n        mTracingOn.setChecked(mTracingOn.getPreferenceManager().getSharedPreferences().getBoolean(\n                mTracingOn.getKey(), false));\n\n        SwitchPreference stopOnReport =\n                (SwitchPreference) findPreference(getString(R.string.pref_key_stop_on_bugreport));\n        stopOnReport.setChecked(mPrefs.getBoolean(stopOnReport.getKey(), false));\n\n        // Update category list to match the categories available on the system.\n        Set<Entry<String, String>> availableTags = TraceUtils.listCategories().entrySet();\n        ArrayList<String> entries = new ArrayList<String>(availableTags.size());\n        ArrayList<String> values = new ArrayList<String>(availableTags.size());", "        for (Entry<String, String> entry : availableTags) {\n            entries.add(entry.getKey() + \": \" + entry.getValue());\n            values.add(entry.getKey());\n        }\n\n        mRefreshing = true;\n        try {\n            mTags.setEntries(entries.toArray(new String[0]));\n            mTags.setEntryValues(values.toArray(new String[0]));\n            if (restoreDefaultTags || !mPrefs.contains(context.getString(R.string.pref_key_tags))) {\n                mTags.setValues(Receiver.getDefaultTagList());\n            }\n        } finally {\n            mRefreshing = false;\n        }\n\n        // Update subtitles on this screen.\n        Set<String> categories = mTags.getValues();\n        MessageFormat msgFormat = new MessageFormat(\n                getResources().getString(R.string.num_categories_selected),\n                Locale.getDefault());\n        Map<String, Object> arguments = new HashMap<>();\n        arguments.put(\"count\", categories.size());\n        mTags.setSummary(Receiver.getDefaultTagList().equals(categories)\n                         ? context.getString(R.string.default_categories)\n                         : msgFormat.format(arguments));\n\n        ListPreference bufferSize = (ListPreference)findPreference(\n                context.getString(R.string.pref_key_buffer_size));\n        bufferSize.setSummary(bufferSize.getEntry());\n\n        // If we are not using the Perfetto trace backend,\n        // hide the unsupported preferences.", "            if (restoreDefaultTags || !mPrefs.contains(context.getString(R.string.pref_key_tags))) {\n                mTags.setValues(Receiver.getDefaultTagList());\n            }\n        } finally {\n            mRefreshing = false;\n        }\n\n        // Update subtitles on this screen.\n        Set<String> categories = mTags.getValues();\n        MessageFormat msgFormat = new MessageFormat(\n                getResources().getString(R.string.num_categories_selected),\n                Locale.getDefault());\n        Map<String, Object> arguments = new HashMap<>();\n        arguments.put(\"count\", categories.size());\n        mTags.setSummary(Receiver.getDefaultTagList().equals(categories)\n                         ? context.getString(R.string.default_categories)\n                         : msgFormat.format(arguments));\n\n        ListPreference bufferSize = (ListPreference)findPreference(\n                context.getString(R.string.pref_key_buffer_size));\n        bufferSize.setSummary(bufferSize.getEntry());\n\n        // If we are not using the Perfetto trace backend,\n        // hide the unsupported preferences.", "        if (TraceUtils.currentTraceEngine().equals(PerfettoUtils.NAME)) {\n            ListPreference maxLongTraceSize = (ListPreference)findPreference(\n                    context.getString(R.string.pref_key_max_long_trace_size));\n            maxLongTraceSize.setSummary(maxLongTraceSize.getEntry());\n\n            ListPreference maxLongTraceDuration = (ListPreference)findPreference(\n                    context.getString(R.string.pref_key_max_long_trace_duration));\n            maxLongTraceDuration.setSummary(maxLongTraceDuration.getEntry());\n        } else {\n            Preference longTraceCategory = findPreference(\"long_trace_category\");\n            if (longTraceCategory != null) {\n                getPreferenceScreen().removePreference(longTraceCategory);\n            }\n        }\n\n        // Check if BetterBug is installed to see if Traceur should display either the toggle for\n        // 'attach_to_bugreport' or 'stop_on_bugreport'.", "            if (longTraceCategory != null) {\n                getPreferenceScreen().removePreference(longTraceCategory);\n            }\n        }\n\n        // Check if BetterBug is installed to see if Traceur should display either the toggle for\n        // 'attach_to_bugreport' or 'stop_on_bugreport'.\n        try {\n            context.getPackageManager().getPackageInfo(BETTERBUG_PACKAGE_NAME,\n                    PackageManager.MATCH_SYSTEM_ONLY);\n            findPreference(getString(R.string.pref_key_attach_to_bugreport)).setVisible(true);\n            findPreference(getString(R.string.pref_key_stop_on_bugreport)).setVisible(false);\n            // Changes the long traces summary to add that they cannot be attached to bugreports.\n            findPreference(getString(R.string.pref_key_long_traces))\n                    .setSummary(getString(R.string.long_traces_summary_betterbug));\n        } catch (PackageManager.NameNotFoundException e) {\n            // attach_to_bugreport must be disabled here because it's true by default.\n            mPrefs.edit().putBoolean(\n                    getString(R.string.pref_key_attach_to_bugreport), false).commit();\n            findPreference(getString(R.string.pref_key_attach_to_bugreport)).setVisible(false);\n            findPreference(getString(R.string.pref_key_stop_on_bugreport)).setVisible(true);\n            // Sets long traces summary to the default in case Betterbug was removed.\n            findPreference(getString(R.string.pref_key_long_traces))\n                    .setSummary(getString(R.string.long_traces_summary));\n        }\n\n        // Check if an activity exists to handle the trace_link_button intent. If not, hide the UI\n        // element\n        PackageManager packageManager = context.getPackageManager();\n        Intent intent = buildTraceFileViewIntent();", "        if (intent.resolveActivity(packageManager) == null) {\n            findPreference(\"trace_link_button\").setVisible(false);\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/FileSender.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ClipData;\nimport android.content.Context;\nimport androidx.core.content.FileProvider;", "import android.content.Context;\nimport androidx.core.content.FileProvider;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.SystemProperties;\nimport android.util.Patterns;\n\nimport java.io.File;", "\nimport java.io.File;\n\n/**\n * Sends bugreport-y files, adapted from fw/base/packages/Shell's BugreportReceiver.\n */\npublic class FileSender {\n\n    private static final String AUTHORITY = \"com.android.traceur.files\";\n    private static final String MIME_TYPE = \"application/vnd.android.systrace\";\n", "    public static void postNotification(Context context, File file) {\n        // Files are kept on private storage, so turn into Uris that we can\n        // grant temporary permissions for.\n        final Uri traceUri = getUriForFile(context, file);\n\n        // Intent to send the file\n        Intent sendIntent = buildSendIntent(context, traceUri);\n        sendIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        // This dialog will show to warn the user about sharing traces, then will execute\n        // the above file-sharing intent.\n        final Intent intent = new Intent(context, UserConsentActivityDialog.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_RECEIVER_FOREGROUND);\n        intent.putExtra(Intent.EXTRA_INTENT, sendIntent);\n\n        final Notification.Builder builder =\n            new Notification.Builder(context, Receiver.NOTIFICATION_CHANNEL_OTHER)\n                .setSmallIcon(R.drawable.bugfood_icon)\n                .setContentTitle(context.getString(R.string.trace_saved))\n                .setTicker(context.getString(R.string.trace_saved))\n                .setContentText(context.getString(R.string.tap_to_share))\n                .setContentIntent(PendingIntent.getActivity(\n                        context, traceUri.hashCode(), intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT\n                                | PendingIntent.FLAG_IMMUTABLE))\n                .setAutoCancel(true)\n                .setLocalOnly(true)\n                .setColor(context.getColor(\n                        com.android.internal.R.color.system_notification_accent_color));\n", "        if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {\n            builder.extend(new Notification.TvExtender());\n        }\n\n        NotificationManager.from(context).notify(file.getName(), 0, builder.build());\n    }\n\n    public static void send(Context context, File file) {\n        // Files are kept on private storage, so turn into Uris that we can\n        // grant temporary permissions for.\n        final Uri traceUri = getUriForFile(context, file);\n\n        Intent sendIntent = buildSendIntent(context, traceUri);\n        sendIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        context.startActivity(sendIntent);\n    }\n\n    private static Uri getUriForFile(Context context, File file) {\n        return FileProvider.getUriForFile(context, AUTHORITY, file);\n    }\n\n    /**\n     * Build {@link Intent} that can be used to share the given bugreport.\n     */\n    private static Intent buildSendIntent(Context context, Uri traceUri) {\n        final CharSequence description = Build.FINGERPRINT;\n\n        final Intent intent = new Intent(Intent.ACTION_SEND);\n        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.setType(MIME_TYPE);\n\n        intent.putExtra(Intent.EXTRA_SUBJECT, traceUri.getLastPathSegment());\n        intent.putExtra(Intent.EXTRA_TEXT, description);\n        intent.putExtra(Intent.EXTRA_STREAM, traceUri);\n\n        // Explicitly set the clip data; see b/119399115\n        intent.setClipData(new ClipData(null, new String[] { MIME_TYPE },\n            new ClipData.Item(description, null, traceUri)));\n\n        final Account sendToAccount = findSendToAccount(context);", "        if (sendToAccount != null) {\n            intent.putExtra(Intent.EXTRA_EMAIL, new String[] { sendToAccount.name });\n        }\n\n        return intent;\n    }\n\n    /**\n     * Find the best matching {@link Account} based on build properties.\n     */\n    private static Account findSendToAccount(Context context) {\n        final AccountManager am = (AccountManager) context.getSystemService(\n                Context.ACCOUNT_SERVICE);\n\n        String preferredDomain = SystemProperties.get(\"sendbug.preferred.domain\");", "        if (!preferredDomain.startsWith(\"@\")) {\n            preferredDomain = \"@\" + preferredDomain;\n        }\n\n        final Account[] accounts = am.getAccounts();\n        Account foundAccount = null;\n        for (Account account : accounts) {\n            if (Patterns.EMAIL_ADDRESS.matcher(account.name).matches()) {\n                if (!preferredDomain.isEmpty()) {\n                    // if we have a preferred domain and it matches, return; otherwise keep\n                    // looking", "                if (!preferredDomain.isEmpty()) {\n                    // if we have a preferred domain and it matches, return; otherwise keep\n                    // looking\n                    if (account.name.endsWith(preferredDomain)) {\n                        return account;\n                    } else {\n                        foundAccount = account;\n                    }\n                    // if we don't have a preferred domain, just return since it looks like\n                    // an email address\n                } else {\n                    return account;\n                }\n            }\n        }\n        return foundAccount;\n    }\n}\n"]}
{"filename": "src/com/android/traceur/MainTvActivity.java", "chunked_list": ["package com.android.traceur;\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *", " *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport android.app.Activity;", "\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.os.UserManager;\nimport android.provider.Settings;\n\npublic class MainTvActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        boolean developerOptionsIsEnabled =\n            Settings.Global.getInt(getApplicationContext().getContentResolver(),\n                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n\n        UserManager userManager = getApplicationContext()\n                .getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);\n", "        if (!developerOptionsIsEnabled || !isAdminUser || debuggingDisallowed) {\n            finish();\n        }\n    }\n}\n"]}
{"filename": "src/com/android/traceur/TraceService.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\n\nimport android.app.IntentService;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;", "import android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.UserManager;\nimport android.preference.PreferenceManager;\nimport android.provider.Settings;\nimport android.text.format.DateUtils;\nimport android.util.EventLog;\nimport android.util.Log;", "import android.util.EventLog;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class TraceService extends IntentService {\n    /* Indicates Perfetto has stopped tracing due to either the supplied long trace limitations\n     * or limited storage capacity. */\n    static String INTENT_ACTION_NOTIFY_SESSION_STOPPED =\n            \"com.android.traceur.NOTIFY_SESSION_STOPPED\";\n    /* Indicates a Traceur-associated tracing session has been attached to a bug report */\n    static String INTENT_ACTION_NOTIFY_SESSION_STOLEN =\n            \"com.android.traceur.NOTIFY_SESSION_STOLEN\";\n    private static String INTENT_ACTION_STOP_TRACING = \"com.android.traceur.STOP_TRACING\";\n    private static String INTENT_ACTION_START_TRACING = \"com.android.traceur.START_TRACING\";\n\n    private static String INTENT_EXTRA_TAGS= \"tags\";\n    private static String INTENT_EXTRA_BUFFER = \"buffer\";\n    private static String INTENT_EXTRA_APPS = \"apps\";\n    private static String INTENT_EXTRA_LONG_TRACE = \"long_trace\";\n    private static String INTENT_EXTRA_LONG_TRACE_SIZE = \"long_trace_size\";\n    private static String INTENT_EXTRA_LONG_TRACE_DURATION = \"long_trace_duration\";\n\n    private static String BETTERBUG_PACKAGE_NAME = \"com.google.android.apps.internal.betterbug\";\n\n    private static int TRACE_NOTIFICATION = 1;\n    private static int SAVING_TRACE_NOTIFICATION = 2;\n\n    private static final int MIN_KEEP_COUNT = 3;\n    private static final long MIN_KEEP_AGE = 4 * DateUtils.WEEK_IN_MILLIS;\n", "    public static void startTracing(final Context context,\n            Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean longTrace, int maxLongTraceSizeMb, int maxLongTraceDurationMinutes) {\n        Intent intent = new Intent(context, TraceService.class);\n        intent.setAction(INTENT_ACTION_START_TRACING);\n        intent.putExtra(INTENT_EXTRA_TAGS, new ArrayList(tags));\n        intent.putExtra(INTENT_EXTRA_BUFFER, bufferSizeKb);\n        intent.putExtra(INTENT_EXTRA_APPS, apps);\n        intent.putExtra(INTENT_EXTRA_LONG_TRACE, longTrace);\n        intent.putExtra(INTENT_EXTRA_LONG_TRACE_SIZE, maxLongTraceSizeMb);\n        intent.putExtra(INTENT_EXTRA_LONG_TRACE_DURATION, maxLongTraceDurationMinutes);\n        context.startForegroundService(intent);\n    }\n", "    public static void stopTracing(final Context context) {\n        Intent intent = new Intent(context, TraceService.class);\n        intent.setAction(INTENT_ACTION_STOP_TRACING);\n        context.startForegroundService(intent);\n    }\n\n    // Silently stops a trace without saving it. This is intended to be called when tracing is no\n    // longer allowed, i.e. if developer options are turned off while tracing. The usual method of\n    // stopping a trace via intent, stopTracing(), will not work because intents cannot be received\n    // when developer options are disabled.\n    static void stopTracingWithoutSaving(final Context context) {\n        NotificationManager notificationManager =\n            context.getSystemService(NotificationManager.class);\n        notificationManager.cancel(TRACE_NOTIFICATION);\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        prefs.edit().putBoolean(context.getString(\n            R.string.pref_key_tracing_on), false).commit();\n        TraceUtils.traceStop();\n    }\n\n    public TraceService() {\n        this(\"TraceService\");\n    }\n\n    protected TraceService(String name) {\n        super(name);\n        setIntentRedelivery(true);\n    }\n\n    @Override", "    public void onHandleIntent(Intent intent) {\n        Context context = getApplicationContext();\n        // Checks that developer options are enabled and the user is an admin before continuing.\n        boolean developerOptionsEnabled =\n                Settings.Global.getInt(context.getContentResolver(),\n                        Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) != 0;\n        if (!developerOptionsEnabled) {\n            // Refer to b/204992293.\n            EventLog.writeEvent(0x534e4554, \"204992293\", -1, \"\");\n            return;\n        }\n        UserManager userManager = context.getSystemService(UserManager.class);\n        boolean isAdminUser = userManager.isAdminUser();\n        boolean debuggingDisallowed = userManager.hasUserRestriction(\n                UserManager.DISALLOW_DEBUGGING_FEATURES);", "        if (!isAdminUser || debuggingDisallowed) {\n            return;\n        }\n\n        if (intent.getAction().equals(INTENT_ACTION_START_TRACING)) {\n            startTracingInternal(intent.getStringArrayListExtra(INTENT_EXTRA_TAGS),\n                intent.getIntExtra(INTENT_EXTRA_BUFFER,\n                    Integer.parseInt(context.getString(R.string.default_buffer_size))),\n                intent.getBooleanExtra(INTENT_EXTRA_APPS, false),\n                intent.getBooleanExtra(INTENT_EXTRA_LONG_TRACE, false),\n                intent.getIntExtra(INTENT_EXTRA_LONG_TRACE_SIZE,\n                    Integer.parseInt(context.getString(R.string.default_long_trace_size))),\n                intent.getIntExtra(INTENT_EXTRA_LONG_TRACE_DURATION,\n                    Integer.parseInt(context.getString(R.string.default_long_trace_duration))));", "        } else if (intent.getAction().equals(INTENT_ACTION_STOP_TRACING)) {\n            stopTracingInternal(TraceUtils.getOutputFilename(), false, false);\n        } else if (intent.getAction().equals(INTENT_ACTION_NOTIFY_SESSION_STOPPED)) {\n            stopTracingInternal(TraceUtils.getOutputFilename(), true, false);\n        } else if (intent.getAction().equals(INTENT_ACTION_NOTIFY_SESSION_STOLEN)) {\n            stopTracingInternal(\"\", false, true);\n        }\n    }\n\n    private void startTracingInternal(Collection<String> tags, int bufferSizeKb, boolean appTracing,\n            boolean longTrace, int maxLongTraceSizeMb, int maxLongTraceDurationMinutes) {\n        Context context = getApplicationContext();\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        Intent stopIntent = new Intent(Receiver.STOP_ACTION,\n            null, context, Receiver.class);\n        stopIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n\n        String title = context.getString(R.string.trace_is_being_recorded);\n        String msg = context.getString(R.string.tap_to_stop_tracing);\n\n        boolean attachToBugreport =\n                prefs.getBoolean(context.getString(R.string.pref_key_attach_to_bugreport), true);\n\n        Notification.Builder notification =\n            new Notification.Builder(context, Receiver.NOTIFICATION_CHANNEL_TRACING)\n                .setSmallIcon(R.drawable.bugfood_icon)\n                .setContentTitle(title)\n                .setTicker(title)\n                .setContentText(msg)\n                .setContentIntent(\n                    PendingIntent.getBroadcast(context, 0, stopIntent, PendingIntent.FLAG_IMMUTABLE))\n                .setOngoing(true)\n                .setLocalOnly(true)\n                .setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)\n                .setColor(getColor(\n                    com.android.internal.R.color.system_notification_accent_color));\n", "        if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {\n            notification.extend(new Notification.TvExtender());\n        }\n\n        startForeground(TRACE_NOTIFICATION, notification.build());\n\n        if (TraceUtils.traceStart(tags, bufferSizeKb, appTracing,\n                longTrace, attachToBugreport, maxLongTraceSizeMb, maxLongTraceDurationMinutes)) {\n            stopForeground(Service.STOP_FOREGROUND_DETACH);\n        } else {\n            // Starting the trace was unsuccessful, so ensure that tracing\n            // is stopped and the preference is reset.\n            TraceUtils.traceStop();\n            prefs.edit().putBoolean(context.getString(R.string.pref_key_tracing_on),\n                        false).commit();\n            QsService.updateTile();\n            stopForeground(Service.STOP_FOREGROUND_REMOVE);\n        }\n    }\n\n    private void stopTracingInternal(String outputFilename, boolean forceStop,\n            boolean sessionStolen) {\n        Context context = getApplicationContext();\n        NotificationManager notificationManager =\n            getSystemService(NotificationManager.class);\n\n        Notification.Builder notification;", "        if (sessionStolen) {\n            notification = getBaseTraceurNotification()\n                .setContentTitle(getString(R.string.attaching_to_report))\n                .setTicker(getString(R.string.attaching_to_report))\n                .setProgress(1, 0, true);\n        } else {\n            notification = getBaseTraceurNotification()\n                .setContentTitle(getString(R.string.saving_trace))\n                .setTicker(getString(R.string.saving_trace))\n                .setProgress(1, 0, true);\n        }\n\n        startForeground(SAVING_TRACE_NOTIFICATION, notification.build());\n\n        notificationManager.cancel(TRACE_NOTIFICATION);\n", "        if (sessionStolen) {\n            Notification.Builder notificationAttached = getBaseTraceurNotification()\n                .setContentTitle(getString(R.string.attached_to_report))\n                .setTicker(getString(R.string.attached_to_report))\n                .setAutoCancel(true);\n\n            Intent openIntent =\n                    getPackageManager().getLaunchIntentForPackage(BETTERBUG_PACKAGE_NAME);\n            if (openIntent != null) {\n                // Add \"Tap to open BetterBug\" to notification only if intent is non-null.\n                notificationAttached.setContentText(getString(\n                        R.string.attached_to_report_summary));\n                notificationAttached.setContentIntent(PendingIntent.getActivity(\n                        context, 0, openIntent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT\n                                | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            // Adds an action button to the notification for starting a new trace.\n            Intent restartIntent = new Intent(context, InternalReceiver.class);\n            restartIntent.setAction(InternalReceiver.START_ACTION);\n            PendingIntent restartPendingIntent = PendingIntent.getBroadcast(context, 0,\n                    restartIntent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            Notification.Action action = new Notification.Action.Builder(\n                    R.drawable.bugfood_icon, context.getString(R.string.start_new_trace),\n                    restartPendingIntent).build();\n            notificationAttached.addAction(action);\n\n            NotificationManager.from(context).notify(0, notificationAttached.build());\n        } else {\n            File file = TraceUtils.getOutputFile(outputFilename);\n", "            if (openIntent != null) {\n                // Add \"Tap to open BetterBug\" to notification only if intent is non-null.\n                notificationAttached.setContentText(getString(\n                        R.string.attached_to_report_summary));\n                notificationAttached.setContentIntent(PendingIntent.getActivity(\n                        context, 0, openIntent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT\n                                | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            // Adds an action button to the notification for starting a new trace.\n            Intent restartIntent = new Intent(context, InternalReceiver.class);\n            restartIntent.setAction(InternalReceiver.START_ACTION);\n            PendingIntent restartPendingIntent = PendingIntent.getBroadcast(context, 0,\n                    restartIntent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            Notification.Action action = new Notification.Action.Builder(\n                    R.drawable.bugfood_icon, context.getString(R.string.start_new_trace),\n                    restartPendingIntent).build();\n            notificationAttached.addAction(action);\n\n            NotificationManager.from(context).notify(0, notificationAttached.build());\n        } else {\n            File file = TraceUtils.getOutputFile(outputFilename);\n", "            if (TraceUtils.traceDump(file)) {\n                FileSender.postNotification(getApplicationContext(), file);\n            }\n        }\n\n        stopForeground(Service.STOP_FOREGROUND_REMOVE);\n\n        TraceUtils.cleanupOlderFiles(MIN_KEEP_COUNT, MIN_KEEP_AGE);\n    }\n\n    private Notification.Builder getBaseTraceurNotification() {\n        Context context = getApplicationContext();\n        Notification.Builder notification =\n                new Notification.Builder(this, Receiver.NOTIFICATION_CHANNEL_OTHER)\n                    .setSmallIcon(R.drawable.bugfood_icon)\n                    .setLocalOnly(true)\n                    .setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)\n                    .setColor(context.getColor(\n                            com.android.internal.R.color.system_notification_accent_color));\n", "        if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {\n            notification.extend(new Notification.TvExtender());\n        }\n\n        return notification;\n    }\n}\n"]}
{"filename": "src/com/android/traceur/TraceUtils.java", "chunked_list": ["/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.traceur;\n", "package com.android.traceur;\n\nimport android.os.Build;\nimport android.os.AsyncTask;\nimport android.os.FileUtils;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;", "import java.io.File;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Collection;", "import java.util.Locale;\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\nimport java.util.TreeMap;\n\n/**\n * Utility functions for tracing.\n * Will call atrace or perfetto depending on the setting.\n */\npublic class TraceUtils {\n\n    static final String TAG = \"Traceur\";\n", " */\npublic class TraceUtils {\n\n    static final String TAG = \"Traceur\";\n\n    public static final String TRACE_DIRECTORY = \"/data/local/traces/\";\n\n    // To change Traceur to use atrace to collect traces,\n    // change mTraceEngine to point to AtraceUtils().\n    private static TraceEngine mTraceEngine = new PerfettoUtils();\n\n    private static final Runtime RUNTIME = Runtime.getRuntime();\n    private static final int PROCESS_TIMEOUT_MS = 30000; // 30 seconds\n", "    public interface TraceEngine {\n        public String getName();\n        public String getOutputExtension();\n        public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean attachToBugreport, boolean longTrace, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes);\n        public void traceStop();\n        public boolean traceDump(File outFile);\n        public boolean isTracingOn();\n    }\n", "        public boolean isTracingOn();\n    }\n\n    public static String currentTraceEngine() {\n        return mTraceEngine.getName();\n    }\n\n    public static boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps,\n            boolean longTrace, boolean attachToBugreport, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes) {\n        return mTraceEngine.traceStart(tags, bufferSizeKb, apps,\n            attachToBugreport, longTrace, maxLongTraceSizeMb, maxLongTraceDurationMinutes);\n    }\n", "    public static void traceStop() {\n        mTraceEngine.traceStop();\n    }\n\n    public static boolean traceDump(File outFile) {\n        return mTraceEngine.traceDump(outFile);\n    }\n\n    public static boolean isTracingOn() {\n        return mTraceEngine.isTracingOn();\n    }\n", "    public static boolean isTracingOn() {\n        return mTraceEngine.isTracingOn();\n    }\n\n    public static TreeMap<String, String> listCategories() {\n        return PerfettoUtils.perfettoListCategories();\n    }\n\n    public static void clearSavedTraces() {\n        String cmd = \"rm -f \" + TRACE_DIRECTORY + \"trace-*.*trace\";\n\n        Log.v(TAG, \"Clearing trace directory: \" + cmd);", "    public static void clearSavedTraces() {\n        String cmd = \"rm -f \" + TRACE_DIRECTORY + \"trace-*.*trace\";\n\n        Log.v(TAG, \"Clearing trace directory: \" + cmd);\n        try {\n            Process rm = exec(cmd);\n\n            if (rm.waitFor() != 0) {\n                Log.e(TAG, \"clearSavedTraces failed with: \" + rm.exitValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "    public static Process exec(String cmd) throws IOException {\n        return exec(cmd, null);\n    }\n\n    public static Process exec(String cmd, String tmpdir) throws IOException {\n        return exec(cmd, tmpdir, true);\n    }\n\n    public static Process exec(String cmd, String tmpdir, boolean logOutput) throws IOException {\n        String[] cmdarray = {\"sh\", \"-c\", cmd};\n        String[] envp = {\"TMPDIR=\" + tmpdir};\n        envp = tmpdir == null ? null : envp;\n\n        Log.v(TAG, \"exec: \" + Arrays.toString(envp) + \" \" + Arrays.toString(cmdarray));\n\n        Process process = RUNTIME.exec(cmdarray, envp);\n        new Logger(\"traceService:stderr\", process.getErrorStream());", "    public static Process exec(String cmd, String tmpdir, boolean logOutput) throws IOException {\n        String[] cmdarray = {\"sh\", \"-c\", cmd};\n        String[] envp = {\"TMPDIR=\" + tmpdir};\n        envp = tmpdir == null ? null : envp;\n\n        Log.v(TAG, \"exec: \" + Arrays.toString(envp) + \" \" + Arrays.toString(cmdarray));\n\n        Process process = RUNTIME.exec(cmdarray, envp);\n        new Logger(\"traceService:stderr\", process.getErrorStream());\n        if (logOutput) {\n            new Logger(\"traceService:stdout\", process.getInputStream());\n        }\n\n        return process;\n    }\n\n    // Returns the Process if the command terminated on time and null if not.", "        if (logOutput) {\n            new Logger(\"traceService:stdout\", process.getInputStream());\n        }\n\n        return process;\n    }\n\n    // Returns the Process if the command terminated on time and null if not.\n    public static Process execWithTimeout(String cmd, String tmpdir, long timeout)\n            throws IOException {\n        Process process = exec(cmd, tmpdir, true);", "    public static Process execWithTimeout(String cmd, String tmpdir, long timeout)\n            throws IOException {\n        Process process = exec(cmd, tmpdir, true);\n        try {\n            if (!process.waitFor(timeout, TimeUnit.MILLISECONDS)) {\n                Log.e(TAG, \"Command '\" + cmd + \"' has timed out after \" + timeout + \" ms.\");\n                process.destroyForcibly();\n                // Return null to signal a timeout and that the Process was destroyed.\n                return null;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return process;\n    }\n", "    public static String getOutputFilename() {\n        String format = \"yyyy-MM-dd-HH-mm-ss\";\n        String now = new SimpleDateFormat(format, Locale.US).format(new Date());\n        return String.format(\"trace-%s-%s-%s.%s\", Build.BOARD, Build.ID, now,\n            mTraceEngine.getOutputExtension());\n    }\n\n    public static File getOutputFile(String filename) {\n        return new File(TraceUtils.TRACE_DIRECTORY, filename);\n    }\n\n    protected static void cleanupOlderFiles(final int minCount, final long minAge) {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {", "                try {\n                    FileUtils.deleteOlderFiles(new File(TRACE_DIRECTORY), minCount, minAge);\n                } catch (RuntimeException e) {\n                    Log.e(TAG, \"Failed to delete older traces\", e);\n                }\n                return null;\n            }\n        }.execute();\n    }\n\n    /**\n     * Streams data from an InputStream to an OutputStream\n     */\n    static class Streamer {\n        private boolean mDone;\n\n        Streamer(final String tag, final InputStream in, final OutputStream out) {\n            new Thread(tag) {\n                @Override", "                public void run() {\n                    int read;\n                    byte[] buf = new byte[2 << 10];\n                    try {\n                        while ((read = in.read(buf)) != -1) {\n                            out.write(buf, 0, read);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"Error while streaming \" + tag);\n                    } finally {\n                        try {\n                            out.close();\n                        } catch (IOException e) {\n                            // Welp.\n                        }\n                        synchronized (Streamer.this) {\n                            mDone = true;\n                            Streamer.this.notify();\n                        }\n                    }\n                }\n            }.start();\n        }\n\n        synchronized boolean isDone() {\n            return mDone;\n        }\n\n        synchronized void waitForDone() {", "                        try {\n                            out.close();\n                        } catch (IOException e) {\n                            // Welp.\n                        }\n                        synchronized (Streamer.this) {\n                            mDone = true;\n                            Streamer.this.notify();\n                        }\n                    }\n                }\n            }.start();\n        }\n\n        synchronized boolean isDone() {\n            return mDone;\n        }\n\n        synchronized void waitForDone() {", "            while (!isDone()) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n\n    /**\n     * Redirects an InputStream to logcat.\n     */\n    private static class Logger {\n\n        Logger(final String tag, final InputStream in) {\n            new Thread(tag) {\n                @Override", "                public void run() {\n                    String line;\n                    BufferedReader r = new BufferedReader(new InputStreamReader(in));\n                    try {\n                        while ((line = r.readLine()) != null) {\n                            Log.e(TAG, tag + \": \" + line);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"Error while streaming \" + tag);\n                    } finally {\n                        try {\n                            r.close();\n                        } catch (IOException e) {\n                            // Welp.\n                        }\n                    }\n                }\n            }.start();\n        }\n    }\n}\n", "                        try {\n                            r.close();\n                        } catch (IOException e) {\n                            // Welp.\n                        }\n                    }\n                }\n            }.start();\n        }\n    }\n}\n"]}
