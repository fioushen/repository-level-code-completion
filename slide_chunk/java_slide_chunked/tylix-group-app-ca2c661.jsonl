{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/Request.java", "chunked_list": ["package com.maximilianwiegmann.backend;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n", "import java.util.Map;\n\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.Builder.Default;\n\n@Builder\n@Getter\npublic class Request {\n    private String url;\n    private String body;\n    private Map<String, String> headers;\n\n    @Default\n    private RequestMethod method = RequestMethod.POST;\n\n    @Default\n    private String contentType = \"application/json\";\n\n    @Default\n    private String accept = \"application/json\";\n\n", "@Builder\n@Getter\npublic class Request {\n    private String url;\n    private String body;\n    private Map<String, String> headers;\n\n    @Default\n    private RequestMethod method = RequestMethod.POST;\n\n    @Default\n    private String contentType = \"application/json\";\n\n    @Default\n    private String accept = \"application/json\";\n\n", "    public String sendRequest() throws IOException {\n        URL url = new URL(this.url);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(this.method.name());\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", this.contentType);\n        connection.setRequestProperty(\"Accept\", this.accept);\n\n        if (headers != null)\n            headers.forEach(connection::setRequestProperty);\n", "        if (headers != null)\n            headers.forEach(connection::setRequestProperty);\n\n        if (body != null)\n            try (OutputStream outputStream = connection.getOutputStream()) {\n                byte[] input = this.body.getBytes(\"utf-8\");\n                outputStream.write(input, 0, input.length);\n            }\n\n        StringBuilder response = new StringBuilder();\n\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String responseLine = null;", "            while ((responseLine = reader.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n        }\n\n        connection.disconnect();\n        return response.toString();\n    }\n\n    public enum RequestType {\n        POST,\n        GET,\n        PUT,\n        DELETE\n    }\n}\n", "    public enum RequestType {\n        POST,\n        GET,\n        PUT,\n        DELETE\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/BackendApplication.java", "chunked_list": ["package com.maximilianwiegmann.backend;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class BackendApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(BackendApplication.class, args);\n    }\n", "    public static void main(String[] args) {\n        SpringApplication.run(BackendApplication.class, args);\n    }\n\n    public static String generateString(int length) {\n        String chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            builder.append(chars.charAt((int) (Math.random() * chars.length())));\n        }\n        return builder.toString();\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/chat/ChatController.java", "chunked_list": ["package com.maximilianwiegmann.backend.chat;\n\nimport com.maximilianwiegmann.backend.group.GroupRepository;\nimport com.maximilianwiegmann.backend.group.data.GroupData;\nimport org.bson.json.JsonObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.messaging.handler.annotation.DestinationVariable;\nimport org.springframework.messaging.handler.annotation.MessageMapping;", "import org.springframework.messaging.handler.annotation.DestinationVariable;\nimport org.springframework.messaging.handler.annotation.MessageMapping;\nimport org.springframework.messaging.handler.annotation.Payload;\nimport org.springframework.messaging.handler.annotation.SendTo;\nimport org.springframework.messaging.simp.SimpMessageHeaderAccessor;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.messaging.simp.SimpMessagingTemplate;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.CrossOrigin;\n", "import org.springframework.web.bind.annotation.CrossOrigin;\n\nimport java.util.HashMap;\nimport java.util.Objects;\nimport java.util.UUID;\n\nimport static java.lang.String.format;\n\n@Controller\n@CrossOrigin(origins = \"*\", maxAge = 3600)\npublic class ChatController {\n\n    private static final Logger logger = LoggerFactory.getLogger(WebSocketEventListener.class);\n\n    @Autowired\n    private SimpMessageSendingOperations messagingTemplate;\n\n    @Autowired\n    private GroupRepository groupRepository;\n\n    @MessageMapping(\"/chat/{roomId}/sendMessage\")", "@Controller\n@CrossOrigin(origins = \"*\", maxAge = 3600)\npublic class ChatController {\n\n    private static final Logger logger = LoggerFactory.getLogger(WebSocketEventListener.class);\n\n    @Autowired\n    private SimpMessageSendingOperations messagingTemplate;\n\n    @Autowired\n    private GroupRepository groupRepository;\n\n    @MessageMapping(\"/chat/{roomId}/sendMessage\")", "    public void sendMessage(@DestinationVariable String roomId, @Payload ChatMessage chatMessage) {\n        messagingTemplate.convertAndSend(format(\"/channel/%s\", roomId), chatMessage);\n\n        chatMessage.setId(UUID.randomUUID().toString());\n        GroupData groupData = groupRepository.findById(roomId).orElse(null);\n        if (groupData == null) return;\n        groupData.getMessages().add(chatMessage);\n        groupRepository.save(groupData);\n    }\n\n    @MessageMapping(\"/chat/{roomId}/addUser\")", "    public void addUser(@DestinationVariable String roomId, @Payload ChatMessage chatMessage,\n                        SimpMessageHeaderAccessor headerAccessor) {\n        String currentRoomId = (String) headerAccessor.getSessionAttributes().put(\"room_id\", roomId);\n        GroupData groupData = groupRepository.findById(roomId).orElse(null);\n        if (groupData == null) return;\n        \n        if (currentRoomId != null) {\n            ChatMessage leaveMessage = new ChatMessage();\n            leaveMessage.setType(ChatMessage.MessageType.LEAVE);\n            leaveMessage.setUserId(chatMessage.getUserId());\n            messagingTemplate.convertAndSend(format(\"/channel/%s\", currentRoomId), leaveMessage);\n        }\n        headerAccessor.getSessionAttributes().put(\"uId\", chatMessage.getUserId());\n        messagingTemplate.convertAndSend(format(\"/channel/%s\", roomId), chatMessage);\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/chat/WebSocketEventListener.java", "chunked_list": ["package com.maximilianwiegmann.backend.chat;\n\nimport lombok.RequiredArgsConstructor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties.User;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.data.mongodb.core.aggregation.BooleanOperators.Not;\nimport org.springframework.messaging.simp.SimpMessageHeaderAccessor;", "import org.springframework.data.mongodb.core.aggregation.BooleanOperators.Not;\nimport org.springframework.messaging.simp.SimpMessageHeaderAccessor;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor;\nimport org.springframework.messaging.simp.user.SimpUser;\nimport org.springframework.messaging.simp.user.SimpUserRegistry;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.socket.messaging.SessionConnectedEvent;\nimport org.springframework.web.socket.messaging.SessionDisconnectEvent;\n", "import org.springframework.web.socket.messaging.SessionDisconnectEvent;\n\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.notifications.Notification;\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\n\nimport java.util.Iterator;\nimport java.util.Objects;\n\nimport static java.lang.String.format;", "\nimport static java.lang.String.format;\n\n@Component\npublic class WebSocketEventListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(WebSocketEventListener.class);\n\n    @Autowired\n    private SimpMessageSendingOperations messagingTemplate;\n\n    @Autowired\n    private NotificationHandler notificationHandler;\n\n    @EventListener", "    public void handleWebSocketConnectListener(SessionConnectedEvent event) {\n        logger.info(\"Received a new web socket connection.\");\n    }\n\n    @EventListener\n    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {\n        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());\n\n        String uId = (String) headerAccessor.getSessionAttributes().get(\"uId\");\n        String roomId = (String) headerAccessor.getSessionAttributes().get(\"room_id\");\n        if (uId != null) {\n            ChatMessage chatMessage = new ChatMessage();\n            chatMessage.setType(ChatMessage.MessageType.LEAVE);\n            chatMessage.setUserId(uId);\n\n            messagingTemplate.convertAndSend(format(\"/channel/%s\", roomId), chatMessage);\n        }\n    }\n\n}\n", "        if (uId != null) {\n            ChatMessage chatMessage = new ChatMessage();\n            chatMessage.setType(ChatMessage.MessageType.LEAVE);\n            chatMessage.setUserId(uId);\n\n            messagingTemplate.convertAndSend(format(\"/channel/%s\", roomId), chatMessage);\n        }\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/chat/ChatMessage.java", "chunked_list": ["package com.maximilianwiegmann.backend.chat;\n\nimport lombok.*;\n\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\n@Getter\npublic class ChatMessage {\n\n    private MessageType type;\n    private String content;\n    private String userId;\n    private long timestamp;\n    private String id;\n", "@Getter\npublic class ChatMessage {\n\n    private MessageType type;\n    private String content;\n    private String userId;\n    private long timestamp;\n    private String id;\n\n    public enum MessageType {\n        CHAT,\n        JOIN,\n        LEAVE\n    }\n}\n", "    public enum MessageType {\n        CHAT,\n        JOIN,\n        LEAVE\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/authentication/AuthenticationController.java", "chunked_list": ["package com.maximilianwiegmann.backend.authentication;\n\nimport com.maximilianwiegmann.backend.payload.request.AuthenticationRequest;\nimport com.maximilianwiegmann.backend.payload.request.RegisterRequest;\nimport com.maximilianwiegmann.backend.payload.request.TwoFARequest;\nimport com.maximilianwiegmann.backend.payload.response.AuthenticationResponse;\nimport jakarta.servlet.http.HttpServletRequest;\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n", "import lombok.val;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.json.JSONObject;\nimport org.springframework.http.HttpRequest;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.HttpStatusCode;\nimport org.springframework.http.ResponseEntity;", "import org.springframework.http.HttpStatusCode;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/auth\")\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequiredArgsConstructor\npublic class AuthenticationController {\n\n    private final AuthenticationService service;\n\n    @PostMapping(\"/register\")\n    public ResponseEntity<?> register(@RequestBody RegisterRequest request) {", "public class AuthenticationController {\n\n    private final AuthenticationService service;\n\n    @PostMapping(\"/register\")\n    public ResponseEntity<?> register(@RequestBody RegisterRequest request) {\n        if (!checkPasswordStrength(request.getPassword()))\n            return ResponseEntity.status(406).build();\n        if (!validateEmail(request.getEmail()))\n            return ResponseEntity.status(407).build();\n        AuthenticationResponse response = service.register(request);", "        if (!validateEmail(request.getEmail()))\n            return ResponseEntity.status(407).build();\n        AuthenticationResponse response = service.register(request);\n        if (response == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(response);\n    }\n\n    @PostMapping(\"/authenticate\")\n    public ResponseEntity<AuthenticationResponse> authenticate(@RequestBody AuthenticationRequest request) {\n        return ResponseEntity.ok(service.authenticate(request));\n    }\n\n    @PostMapping(\"/otp\")\n    public ResponseEntity<?> otp(@RequestBody TwoFARequest request) {\n        return service.otp(request);\n    }\n\n    @PostMapping(\"/status\")\n    public ResponseEntity<?> status(@RequestBody String bodyString) {\n        JSONObject body = new JSONObject(bodyString);\n        return service.status(body.getString(\"token\"));\n    }\n\n    @PostMapping(\"/logout\")\n    public ResponseEntity<Void> logout(HttpServletRequest request) {\n        service.logout(request);\n        return ResponseEntity.ok().build();\n    }\n\n    @PostMapping(\"/signinwith\")\n    public ResponseEntity<?> signInWith(@RequestParam String provider, @RequestParam String code) {\n        return service.signInWith(provider, code);\n    }\n\n    private boolean checkPasswordStrength(String password) {\n        String regex = \"^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(password);\n\n        return matcher.matches();\n    }\n\n    private boolean validateEmail(String email) {\n        String regex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(email);\n\n        return matcher.matches();\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/authentication/AuthStatus.java", "chunked_list": ["package com.maximilianwiegmann.backend.authentication;\n\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Data\n@Builder\n@Getter", "@Builder\n@Getter\n@Setter\npublic class AuthStatus {\n\n    private String token;\n    private Status status;\n    private String uId;\n    private long deviceId;\n    private int mobileConfirm;\n    private int fakeOne;\n    private int fakeTwo;\n    private boolean rememberMe;\n    private boolean mobile;\n    private boolean otp;\n", "    public enum Status {\n        OK,\n        WAIT,\n        ERROR\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/authentication/AuthenticationService.java", "chunked_list": ["package com.maximilianwiegmann.backend.authentication;\n\nimport com.maximilianwiegmann.backend.Request;\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.authentication.twofactor.TwoFactorService;\nimport com.maximilianwiegmann.backend.payload.request.AuthenticationRequest;\nimport com.maximilianwiegmann.backend.payload.request.RegisterRequest;\nimport com.maximilianwiegmann.backend.payload.request.TwoFARequest;\nimport com.maximilianwiegmann.backend.payload.response.AuthenticationResponse;\nimport com.maximilianwiegmann.backend.account.AccountRepository;", "import com.maximilianwiegmann.backend.payload.response.AuthenticationResponse;\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.account.signinwith.SigninWith;\nimport com.maximilianwiegmann.backend.account.signinwith.SigninWithRepository;\nimport com.maximilianwiegmann.backend.security.config.JwtService;\nimport com.maximilianwiegmann.backend.security.token.Token;\nimport com.maximilianwiegmann.backend.security.token.TokenRepository;\nimport jakarta.servlet.http.HttpServletRequest;\nimport lombok.RequiredArgsConstructor;\n", "import lombok.RequiredArgsConstructor;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.crypto.password.PasswordEncoder;", "import org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;", "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n@Service\n@RequiredArgsConstructor\npublic class AuthenticationService {\n    private final AuthenticationManager authenticationManager;\n\n    private final AccountRepository repository;\n    private final TokenRepository tokenRepository;\n    private final SigninWithRepository signinWithRepository;\n\n    private final PasswordEncoder passwordEncoder;\n    private final JwtService jwtService;\n    private final TwoFactorService twoFactorService;\n\n    private final Map<String, AuthenticationRequest> authenticationRequests = new HashMap<>();\n    private final Map<String, AuthStatus> permitted = new HashMap<>();\n\n    @Value(\"${github.secret}\")\n    private String gitHubSecret;\n\n    @Value(\"${github.clientId}\")\n    private String gitHubClientId;\n\n    @Value(\"${discord.clientId}\")\n    private String discordClientId;\n\n    @Value(\"${discord.secret}\")\n    private String discordSecret;\n", "    public AuthenticationResponse register(RegisterRequest request) {\n        if (repository.findByUsername(request.getUsername()).isPresent()\n                || repository.findByEmail(request.getEmail()).isPresent())\n            return null;\n\n        var account = AccountData.builder()\n                .firstName(request.getFirstName())\n                .lastName(request.getLastName())\n                .username(request.getUsername())\n                .password(passwordEncoder.encode(request.getPassword()))\n                .email(request.getEmail())\n                .contacts(new ArrayList<>())\n                .contactRequests(new ArrayList<>())\n                .build();\n        var savedUser = repository.save(account);\n        var jwtToken = jwtService.generateRegisterToken(account);\n        saveUserToken(savedUser, jwtToken);\n        return AuthenticationResponse.builder()\n                .token(jwtToken)\n                .build();\n    }\n", "    public AuthenticationResponse authenticate(AuthenticationRequest request) {\n        authenticationManager.authenticate(\n                new UsernamePasswordAuthenticationToken(\n                        request.getUsername(),\n                        request.getPassword()));\n        var account = repository.findByUsername(request.getUsername())\n                .orElseThrow();\n\n        AuthStatus authStatus = AuthStatus.builder().build();\n\n        authenticationRequests.put(account.getId(), request);\n\n        String token;", "        if (account.getTfaSecret() != null) {\n            token = jwtService.generateTfaToken(account);\n\n            authStatus.setOtp(true);\n            authStatus.setStatus(AuthStatus.Status.WAIT);\n            authStatus.setToken(token);\n            authStatus.setUId(account.getId());\n            permitted.put(token, authStatus);\n            return AuthenticationResponse.builder()\n                    .token(token)\n                    .build();\n        }\n        token = jwtService.generateToken(account);\n        revokeAllUserTokens(account);\n        saveUserToken(account, token);\n        return AuthenticationResponse.builder()\n                .token(token)\n                .build();\n    }\n\n    public ResponseEntity<?> otp(TwoFARequest request) {\n        String token = request.getToken();", "        if (token == null)\n            return ResponseEntity.badRequest().build();\n\n        var authStatus = permitted.get(token);\n        if (authStatus == null)\n            return ResponseEntity.badRequest().build();\n\n        if (!authStatus.isOtp())\n            return ResponseEntity.badRequest().build();\n        if (!authStatus.getStatus().equals(AuthStatus.Status.WAIT))\n            return ResponseEntity.badRequest().build();\n", "        if (!authStatus.getStatus().equals(AuthStatus.Status.WAIT))\n            return ResponseEntity.badRequest().build();\n\n        if (jwtService.isTokenExpired(token))\n            return ResponseEntity.badRequest().build();\n        if (!jwtService.isTfaToken(token))\n            return ResponseEntity.badRequest().build();\n\n        var account = repository.findById(authStatus.getUId())\n                .orElseThrow();\n\n        String otpSecret = account.getTfaSecret();", "        if (otpSecret == null)\n            return ResponseEntity.badRequest().build();\n        if (request.getCode().equals(twoFactorService.getTOTPCode(otpSecret))) {\n            if (!authenticationRequests.containsKey(authStatus.getUId()))\n                return ResponseEntity.badRequest().build();\n            permitted.get(request.getToken()).setStatus(AuthStatus.Status.OK);\n            return ResponseEntity.ok(\"{\\\"status\\\": \\\"OK\\\"}\");\n        }\n        return ResponseEntity.badRequest().build();\n    }\n\n    public ResponseEntity<?> status(String token) {\n        var authStatus = permitted.get(token);\n        switch (authStatus.getStatus()) {\n            case OK -> {\n                AuthenticationRequest request = authenticationRequests.get(authStatus.getUId());\n                authenticationRequests.remove(authStatus.getUId());\n                permitted.remove(token);\n\n                var account = repository.findByUsername(request.getUsername())\n                        .orElseThrow();\n                var jwtToken = jwtService.generateToken(account);\n                revokeAllUserTokens(account);\n                saveUserToken(account, jwtToken);\n                return ResponseEntity.ok(AuthenticationResponse.builder()\n                        .token(jwtToken)\n                        .build());\n            }\n            case WAIT -> {\n                return ResponseEntity.ok(\"{\\\"status\\\": \\\"WAIT\\\"}\");\n            }\n            default -> {\n                return ResponseEntity.badRequest().build();\n            }\n        }\n    }\n\n    public ResponseEntity<?> signInWith(String provider, String code) {\n        switch (provider) {\n            case \"github\" -> {\n                JSONObject body = new JSONObject();\n                body.put(\"client_id\", this.gitHubClientId);\n                body.put(\"client_secret\", this.gitHubSecret);\n                body.put(\"code\", code);\n", "                try {\n                    JSONObject response = new JSONObject(\n                            Request.builder().url(\"https://github.com/login/oauth/access_token\").body(body.toString())\n                                    .build().sendRequest());\n\n                    if (response.has(\"error\"))\n                        return ResponseEntity.badRequest().build();\n\n                    String accessToken = response.getString(\"access_token\");\n                    JSONObject user = new JSONObject(Request.builder()\n                            .url(\"https://api.github.com/user\").headers(Map.of(\"Authorization\", \"token \" + accessToken))\n                            .method(RequestMethod.GET)\n                            .build().sendRequest());\n\n                    String email = user.has(\"email\") && user.get(\"email\") != null && user.get(\"email\") instanceof String\n                            ? user.getString(\"email\")\n                            : user.getString(\"node_id\");\n                    String username = user.getString(\"login\");\n                    int id = user.getInt(\"id\");\n                    String avatarUrl = user.getString(\"avatar_url\");\n\n                    String[] nameSplit = user.has(\"name\") && user.get(\"name\") != null\n                            && user.get(\"name\") instanceof String\n                                    ? user.getString(\"name\").split(\" \")\n                                    : new String[0];\n                    String lastName = nameSplit.length > 0 ? nameSplit[nameSplit.length - 1] : \"\";\n                    String firstName = user.has(\"name\") && user.get(\"name\") != null\n                            && user.get(\"name\") instanceof String\n                                    ? user.getString(\"name\").replace(lastName, \"\")\n                                    : \"\";\n\n                    var signinWith = signinWithRepository.findByProviderAndProviderId(provider, String.valueOf(id));\n                    AccountData account = null;", "                    if (signinWith.isPresent()) {\n                        account = repository.findById(signinWith.get().getUId()).orElseThrow();\n                    } else {\n                        var newAccount = AccountData.builder()\n                                .username(username)\n                                .email(email)\n                                .password(passwordEncoder.encode(UUID.randomUUID().toString()))\n                                .firstName(firstName)\n                                .lastName(lastName)\n                                .contacts(new ArrayList<>())\n                                .contactRequests(new ArrayList<>())\n                                .build();\n\n                        account = repository.save(newAccount);\n\n                        SigninWith signInWith = SigninWith.builder().provider(provider)\n                                .providerId(String.valueOf(id)).uId(account.getId())\n                                .build();\n\n                        signinWithRepository.save(signInWith);\n                    }\n", "                    if (account == null)\n                        return ResponseEntity.badRequest().build();\n\n                    var jwtToken = jwtService.generateToken(account);\n                    revokeAllUserTokens(account);\n                    saveUserToken(account, jwtToken);\n                    return ResponseEntity.ok(AuthenticationResponse.builder()\n                            .token(jwtToken)\n                            .build());\n                } catch (IOException e) {\n                    return ResponseEntity.badRequest().build();\n                }\n            }\n            case \"discord\" -> {\n                JSONObject body = new JSONObject();\n                body.put(\"client_id\", this.discordClientId);\n                body.put(\"client_secret\", this.discordSecret);\n                body.put(\"grant_type\", \"authorization_code\");\n                body.put(\"code\", code);\n                body.put(\"redirect_uri\", \"https://maximilianwiegmann.com/login?siw=discord\");\n", "                try {\n\n                    StringBuilder formattedBody = new StringBuilder();\n                    int i = 0;\n                    for (String key : body.keySet()) {\n                        formattedBody.append(key).append(\"=\")\n                                .append(URLEncoder.encode(String.valueOf(body.get(key)), \"UTF-8\"));\n                        if (i != body.keySet().size() - 1)\n                            formattedBody.append(\"&\");\n                        i++;\n                    }\n\n                    JSONObject response = new JSONObject(\n                            Request.builder().url(\"https://discord.com/api/v10/oauth2/token\")\n                                    .contentType(\"application/x-www-form-urlencoded\").body(formattedBody.toString())\n                                    .build().sendRequest());\n", "                    if (response.has(\"error\"))\n                        return ResponseEntity.badRequest().build();\n\n                    String accessToken = response.getString(\"access_token\");\n                    JSONObject user = new JSONObject(Request.builder()\n                            .url(\"https://discord.com/api/users/@me\")\n                            .headers(Map.of(\"Authorization\", \"Bearer \" + accessToken))\n                            .method(RequestMethod.GET)\n                            .build().sendRequest());\n\n                    String email = user.getString(\"email\");\n                    String username = user.getString(\"username\");\n                    String id = user.getString(\"id\");\n                    String avatarUrl = user.getString(\"avatar\");\n\n                    var signinWith = signinWithRepository.findByProviderAndProviderId(provider, id);\n                    AccountData account = null;", "                    if (signinWith.isPresent()) {\n                        account = repository.findById(signinWith.get().getUId()).orElseThrow();\n                    } else {\n                        var newAccount = AccountData.builder()\n                                .username(username)\n                                .email(email)\n                                .password(passwordEncoder.encode(UUID.randomUUID().toString()))\n                                .contacts(new ArrayList<>())\n                                .contactRequests(new ArrayList<>())\n                                .build();\n\n                        account = repository.save(newAccount);\n\n                        SigninWith signInWith = SigninWith.builder().provider(provider)\n                                .providerId(id).uId(account.getId())\n                                .build();\n\n                        signinWithRepository.save(signInWith);\n                    }\n", "                    if (account == null)\n                        return ResponseEntity.badRequest().build();\n\n                    var jwtToken = jwtService.generateToken(account);\n                    revokeAllUserTokens(account);\n                    saveUserToken(account, jwtToken);\n                    return ResponseEntity.ok(AuthenticationResponse.builder()\n                            .token(jwtToken)\n                            .build());\n\n                    /*\n                     * JSONArray connections = new JSONArray(Request.builder()\n                     * .url(\"https://discord.com/api/users/@me/connections\")\n                     * .headers(Map.of(\"Authorization\", \"Bearer \" + accessToken))\n                     * .method(RequestMethod.GET)\n                     * .build().sendRequest());\n                     * \n                     * System.out.println(connections.get(0).toString());\n                     */\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return ResponseEntity.badRequest().build();\n                }\n            }\n        }\n        return ResponseEntity.badRequest().build();\n    }\n\n    private void saveUserToken(AccountData account, String jwtToken) {\n        var token = Token.builder()\n                .userId(account.getId())\n                .token(jwtToken)\n                .expired(false)\n                .revoked(false)\n                .build();\n        tokenRepository.save(token);\n    }\n", "    public void logout(HttpServletRequest request) {\n        String authHeader = request.getHeader(\"Authorization\");\n        String jwt;\n        if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            return;\n        }\n        jwt = authHeader.substring(7);\n        var storedToken = tokenRepository.findByToken(jwt)\n                .orElse(null);\n        if (storedToken != null) {\n            storedToken.setExpired(true);\n            storedToken.setRevoked(true);\n            tokenRepository.save(storedToken);\n            SecurityContextHolder.clearContext();\n        }\n    }\n", "        if (storedToken != null) {\n            storedToken.setExpired(true);\n            storedToken.setRevoked(true);\n            tokenRepository.save(storedToken);\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    public void revokeAllUserTokens(AccountData account) {\n        var validUserToken = tokenRepository.findAllValidTokensByUserId(account.getId());\n        if (validUserToken.isEmpty())\n            return;\n        validUserToken.forEach(token -> {\n            token.setExpired(true);\n            token.setRevoked(true);\n        });\n        tokenRepository.saveAll(validUserToken);\n    }\n}\n", "    public void revokeAllUserTokens(AccountData account) {\n        var validUserToken = tokenRepository.findAllValidTokensByUserId(account.getId());\n        if (validUserToken.isEmpty())\n            return;\n        validUserToken.forEach(token -> {\n            token.setExpired(true);\n            token.setRevoked(true);\n        });\n        tokenRepository.saveAll(validUserToken);\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/authentication/twofactor/TwoFactorController.java", "chunked_list": ["package com.maximilianwiegmann.backend.authentication.twofactor;\n\nimport com.google.zxing.WriterException;\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountService;\nimport com.maximilianwiegmann.backend.authentication.AuthenticationService;\nimport com.maximilianwiegmann.backend.security.config.JwtService;\nimport lombok.RequiredArgsConstructor;\nimport org.json.JSONObject;\nimport org.springframework.http.ResponseEntity;", "import org.json.JSONObject;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n", "import java.util.List;\n\n@RestController\n@RequestMapping(value = \"/twofactor\", produces = \"application/json\")\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequiredArgsConstructor\npublic class TwoFactorController {\n\n    private final TwoFactorService twoFactorService;\n    private final AuthenticationService authenticationService;\n    private final AccountService accountService;\n\n    private final List<JSONObject> generateRequests = new ArrayList<>();\n\n    @PostMapping(\"/generate\")\n    public ResponseEntity<?> generate() throws IOException, WriterException {\n        // TODO: Check for team to create qr code!\n\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null) return ResponseEntity.status(403).build();\n        if (accountData.getTfaSecret() != null) return ResponseEntity.status(403).build();\n\n        String username = accountData.getUsername();\n        String secret = twoFactorService.generateSecretKey();\n        String company = \"MORPHEUS\";\n\n        String barCode = twoFactorService.getGoogleAuthenticatorBarCode(secret, username, company);\n        String qr = twoFactorService.createQRCode(barCode, 400, 400);\n\n        JSONObject object = new JSONObject().put(\"secret\", secret).put(\"qr\", qr);\n        object.put(\"username\", username);\n        generateRequests.removeIf(o -> o.has(\"username\") && o.getString(\"username\").equals(username));\n        generateRequests.add(object);\n        return ResponseEntity.ok(object.toString());\n    }\n\n    @PostMapping(\"/verify\")\n    public ResponseEntity<?> verify(@RequestBody String json) {\n        JSONObject body = new JSONObject(json);\n        String code = body.getString(\"code\");\n\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null) return ResponseEntity.status(403).build();\n        if (accountData.getTfaSecret() != null) return ResponseEntity.status(403).build();\n        JSONObject object = generateRequests.stream().filter(o -> o.has(\"username\") && o.getString(\"username\").equals(accountData.getUsername())).findFirst().orElse(null);\n        if (object == null) return ResponseEntity.status(403).build();\n\n        String secret = object.getString(\"secret\");\n\n        if (!code.equals(twoFactorService.getTOTPCode(secret)))\n            return ResponseEntity.status(403).build();\n\n        accountService.setTfaSecret(accountData, secret);\n        authenticationService.revokeAllUserTokens(accountData);\n\n        return ResponseEntity.ok().build();\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/authentication/twofactor/TwoFactorService.java", "chunked_list": ["package com.maximilianwiegmann.backend.authentication.twofactor;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.MultiFormatWriter;\nimport com.google.zxing.WriterException;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport de.taimos.totp.TOTP;\nimport lombok.RequiredArgsConstructor;\nimport org.apache.commons.codec.binary.Base32;", "import lombok.RequiredArgsConstructor;\nimport org.apache.commons.codec.binary.Base32;\nimport org.apache.commons.codec.binary.Hex;\nimport org.springframework.stereotype.Service;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;", "import java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\n@Service\n@RequiredArgsConstructor\npublic class TwoFactorService {\n\n    public String generateSecretKey() {\n        SecureRandom random = new SecureRandom();\n        byte[] bytes = new byte[20];\n        random.nextBytes(bytes);\n        Base32 base32 = new Base32();\n        return base32.encodeToString(bytes);\n    }\n", "    public String generateSecretKey() {\n        SecureRandom random = new SecureRandom();\n        byte[] bytes = new byte[20];\n        random.nextBytes(bytes);\n        Base32 base32 = new Base32();\n        return base32.encodeToString(bytes);\n    }\n\n    public String getTOTPCode(String secretKey) {\n        Base32 base32 = new Base32();\n        byte[] bytes = base32.decode(secretKey);\n        String hexKey = Hex.encodeHexString(bytes);\n        return TOTP.getOTP(hexKey);\n    }\n", "    public String getTOTPCode(String secretKey) {\n        Base32 base32 = new Base32();\n        byte[] bytes = base32.decode(secretKey);\n        String hexKey = Hex.encodeHexString(bytes);\n        return TOTP.getOTP(hexKey);\n    }\n\n    public String getGoogleAuthenticatorBarCode(String secretKey, String account, String issuer) {\n        return \"otpauth://totp/\"\n                + URLEncoder.encode(issuer + \":\" + account, StandardCharsets.UTF_8).replace(\"+\", \"%20\")\n                + \"?secret=\" + URLEncoder.encode(secretKey, StandardCharsets.UTF_8).replace(\"+\", \"%20\")\n                + \"&issuer=\" + URLEncoder.encode(issuer, StandardCharsets.UTF_8).replace(\"+\", \"%20\");\n    }\n", "    public String createQRCode(String barCodeData, int height, int width) throws WriterException, IOException {\n        BitMatrix matrix = new MultiFormatWriter().encode(barCodeData, BarcodeFormat.QR_CODE,\n                width, height);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MatrixToImageWriter.writeToStream(matrix, \"png\", bos);\n        return Base64.getEncoder().encodeToString(bos.toByteArray());\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/statistics/StatisticHandler.java", "chunked_list": ["package com.maximilianwiegmann.backend.statistics;\n\nimport java.lang.reflect.Array;\nimport java.sql.Date;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n", "import java.util.Map;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.springframework.stereotype.Controller;\n\nimport com.maximilianwiegmann.backend.account.AccountService;\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport com.maximilianwiegmann.backend.group.GroupService;\nimport com.maximilianwiegmann.backend.group.data.GroupData;", "import com.maximilianwiegmann.backend.group.GroupService;\nimport com.maximilianwiegmann.backend.group.data.GroupData;\nimport com.maximilianwiegmann.backend.group.data.GroupMember;\nimport com.maximilianwiegmann.backend.notifications.Notification;\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;", "import lombok.Data;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@Controller\n@RequiredArgsConstructor\npublic class StatisticHandler {\n\n    private final GroupService groupService;\n    private final AccountService accountService;\n    private final NotificationHandler notificationHandler;\n", "    public JSONObject get(long from, long to) {\n        JSONObject json = new JSONObject();\n\n        for (StatsType value : StatsType.values()) {\n            json.put(value.name(), new JSONArray(getStatsObject(value, from, to)));\n        }\n\n        return json;\n    }\n\n    private List<StatsObject> getStatsObject(StatsType type, long from, long to) {\n        List<TrendItem> trends = new ArrayList<>();\n        switch (type) {\n            case GROUPS -> {\n                List<GroupData> groups = groupService.getGroups(from, to);\n                List<StatsItem> groupStats = groups.stream()\n                        .map(group -> new StatsItem(group.getCreated())).toList();\n\n                List<StatsItem> groupMemberStats = new ArrayList<>();\n\n                int groupAmount = groups.size();\n                int groupMember = 0;", "                for (GroupData group : groups) {\n                    groupMember += group.getMember().size();\n\n                    for (GroupMember member : group.getMember()) {\n                        groupMemberStats.add(new StatsItem(member.getTimestamp()));\n                    }\n                }\n                double average = groupAmount == 0 ? 0 : groupMember / groupAmount;\n\n                List<GroupData> previousGroups = groupService.getGroups(from - (to - from), from);\n\n                int previousGroupAmount = previousGroups.size();\n                int previousGroupMember = 0;", "                for (GroupData group : previousGroups) {\n                    previousGroupMember += group.getMember().size();\n                }\n                double previousAverage = previousGroupAmount == 0 ? previousGroupAmount\n                        : previousGroupMember / previousGroupAmount;\n\n                TrendItem averageMember = new TrendItem(calculatePercentageChange(previousAverage, average), average,\n                        previousAverage, TrendType.AVERAGE_GROUP_MEMBER);\n                trends.add(averageMember);\n\n                return Arrays.asList(new StatsObject(groupAmount, groupStats, new ArrayList<>()),\n                        new StatsObject(groupMember, groupMemberStats, trends));\n            }\n            case ACCOUNTS -> {\n                List<StatsItem> accounts = accountService.getAccounts(from, to).stream()\n                        .map(account -> new StatsItem(account.getTimestamp())).toList();\n\n                return Arrays.asList(new StatsObject(accounts.size(), accounts, trends));\n            }\n            case MESSAGES -> {\n                List<ChatMessage> messages = groupService.getMessages(from, to);\n                List<ChatMessage> previousMessages = groupService.getMessages(from - (to - from), from);\n\n                List<StatsItem> messageStats = messages.stream()\n                        .map(message -> new StatsItem(message.getTimestamp())).toList();\n\n                List<StatsItem> previousMessageStats = previousMessages.stream()\n                        .map(message -> new StatsItem(message.getTimestamp())).toList();\n\n                TrendItem totalMessages = new TrendItem(\n                        calculatePercentageChange(previousMessageStats.size(), messageStats.size()),\n                        messageStats.size(), previousMessageStats.size(), TrendType.TOTAL_MESSAGES);\n                trends.add(totalMessages);\n\n                double averageMessageCount = this.getMessageProUserAverage(messages);\n                double previousAMC = this.getMessageProUserAverage(previousMessages);\n\n                TrendItem messageProUser = new TrendItem(calculatePercentageChange(previousAMC, averageMessageCount),\n                        averageMessageCount, previousAMC, TrendType.MESSAGE_PRO_USER);\n                trends.add(messageProUser);\n\n                return Arrays.asList(new StatsObject(messageStats.size(), messageStats, trends));\n            }\n            case NOTIFICATIONS -> {\n                List<Notification> notifications = notificationHandler.getNotifications(from, to);\n                List<StatsItem> notificationStats = notifications.stream()\n                        .map(notification -> new StatsItem(notification.getTimestamp())).toList();\n\n                int notificationThisPeriod = notifications.size();\n\n                List<Notification> previousNotifications = notificationHandler.getNotifications(from - (to - from), from);\n                int previousNotification = previousNotifications.size();\n\n                double percentage = calculatePercentageChange(previousNotification, notificationThisPeriod);\n\n                TrendItem notificationTrend = new TrendItem(percentage, notificationThisPeriod, previousNotification, TrendType.TOTAL_NOTIFICATIONS);\n                trends.add(notificationTrend);\n\n                return Arrays.asList(new StatsObject(notificationStats.size(), notificationStats, trends));\n            }\n            case ACTIVITY -> {\n\n                return new ArrayList<>();\n            }\n            default -> {\n                return null;\n            }\n        }\n    }\n\n    private double getMessageProUserAverage(List<ChatMessage> messages) {", "        if (messages.size() == 0)\n            return 0;\n        Map<String, Integer> userMessages = new HashMap<>();\n        for (ChatMessage message : messages) {\n            userMessages.putIfAbsent(message.getUserId(), 0);\n            int currentCount = userMessages.get(message.getUserId());\n            userMessages.put(message.getUserId(), currentCount + 1);\n        }\n        int totalUsers = userMessages.size();\n        int totalMessages = 0;\n", "        for (int count : userMessages.values()) {\n            totalMessages += count;\n        }\n\n        return (double) totalMessages / totalUsers;\n    }\n\n    private double calculatePercentageChange(double initialValue, double finalValue) {\n        if (initialValue == 0)\n            return 0;\n        return ((finalValue - initialValue) / initialValue) * 100;\n    }\n\n    @RequiredArgsConstructor\n    @Getter", "        if (initialValue == 0)\n            return 0;\n        return ((finalValue - initialValue) / initialValue) * 100;\n    }\n\n    @RequiredArgsConstructor\n    @Getter\n    public class StatsObject {\n        private final int count;\n        private final List<StatsItem> data;\n        private final List<TrendItem> trends;\n    }\n\n    @RequiredArgsConstructor\n    @AllArgsConstructor\n    @Getter", "    public class StatsItem {\n        private final long timestamp;\n        private int amount;\n    }\n\n    @RequiredArgsConstructor\n    @Getter\n    public class TrendItem {\n        private final double percentagePeriod;\n        private final double amountPeriod;\n        private final double amountLastPeriod;\n        private final TrendType trendType;\n    }\n\n    @RequiredArgsConstructor\n    @Getter", "    public enum TrendType {\n        NEW_USERS(StatsType.ACCOUNTS),\n        AVERAGE_GROUP_MEMBER(StatsType.GROUPS),\n        MESSAGE_PRO_USER(StatsType.MESSAGES),\n        TOTAL_MESSAGES(StatsType.MESSAGES),\n        TOTAL_NOTIFICATIONS(StatsType.NOTIFICATIONS);\n\n        private final StatsType statsType;\n    }\n\n    public enum StatsType {\n        GROUPS, ACCOUNTS, MESSAGES, FILES, EVENTS, NOTIFICATIONS, ACTIVITY\n    }\n\n}\n", "    public enum StatsType {\n        GROUPS, ACCOUNTS, MESSAGES, FILES, EVENTS, NOTIFICATIONS, ACTIVITY\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/statistics/StatisticController.java", "chunked_list": ["package com.maximilianwiegmann.backend.statistics;\n\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport lombok.RequiredArgsConstructor;", "\nimport lombok.RequiredArgsConstructor;\n\n@RestController\n@RequestMapping(\"/statistics\")\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequiredArgsConstructor\npublic class StatisticController {\n    \n    private final StatisticHandler statisticHandler;\n\n    @GetMapping\n    public ResponseEntity<?> getStatistics(@RequestParam long from, @RequestParam long to) {\n        return ResponseEntity.ok(statisticHandler.get(from, to).toString());\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/statistics/StatisticRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.statistics;\n\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.Query;\n\npublic interface StatisticRepository<T> {\n    \n    @Query(\" {'?2' : { $gte: ?0, $lte: ?1 } }\")\n    List<T> findByFromTo(long from, long to, String timeName);\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/JwtService.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport io.jsonwebtoken.*;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\nimport io.jsonwebtoken.security.SignatureException;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Service;", "import org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Service;\n\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\n@Service\npublic class JwtService {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n", "\n@Service\npublic class JwtService {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n", "    public String extractUId(String token) {\n        return extractClaim(token, claims -> claims.get(\"uId\", String.class));\n    }\n\n    public <T> T extractClaim(String token, Function<Claims, T> claimResolver) {\n        Claims claims = extractAllClaims(token);\n        return claimResolver.apply(claims);\n    }\n\n    public String generateToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>(), userDetails, 1000 * 60 * 60 * 3);\n    }\n", "    public String generateToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>(), userDetails, 1000 * 60 * 60 * 3);\n    }\n\n    public String generateRegisterToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>() {\n            {\n                put(\"signup\", true);\n            }\n        }, userDetails, 1000 * 60 * 60 * 3);\n    }\n", "    public String generateTfaToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>() {\n            {\n                put(\"tfa\", true);\n            }\n        }, userDetails, 1000 * 60 * 5);\n    }\n\n    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails, long expiration) {\n        if (((AccountData) userDetails).getTfaSecret() != null)\n            extraClaims.put(\"otp\", true);\n        String uId = ((AccountData) userDetails).getId();\n        extraClaims.put(\"uId\", uId);\n        return Jwts.builder()\n                .setClaims(extraClaims)\n                .setSubject(userDetails.getUsername())\n                .setIssuedAt(new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() + expiration))\n                .signWith(getSignInKey(), SignatureAlgorithm.HS256)\n                .compact();\n    }\n", "    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails, long expiration) {\n        if (((AccountData) userDetails).getTfaSecret() != null)\n            extraClaims.put(\"otp\", true);\n        String uId = ((AccountData) userDetails).getId();\n        extraClaims.put(\"uId\", uId);\n        return Jwts.builder()\n                .setClaims(extraClaims)\n                .setSubject(userDetails.getUsername())\n                .setIssuedAt(new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() + expiration))\n                .signWith(getSignInKey(), SignatureAlgorithm.HS256)\n                .compact();\n    }\n", "    public boolean isTokenValid(String token, UserDetails userDetails) {\n        String username = extractUsername(token);\n        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);\n    }\n\n    public boolean isTfaToken(String token) {\n        Claims claims = extractAllClaims(token);\n        return claims != null && claims.containsKey(\"tfa\");\n    }\n\n    public boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n", "    public boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n\n    public Date extractExpiration(String token) {\n        return extractClaim(token, Claims::getExpiration);\n    }\n\n    private Claims extractAllClaims(String token) {\n        try {\n            return Jwts.parserBuilder()\n                    .setSigningKey(getSignInKey())\n                    .build()\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | SignatureException\n                | IllegalArgumentException e) {\n            return null;\n        }\n    }\n\n    private Key getSignInKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(secret);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n", "        try {\n            return Jwts.parserBuilder()\n                    .setSigningKey(getSignInKey())\n                    .build()\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | SignatureException\n                | IllegalArgumentException e) {\n            return null;\n        }\n    }\n\n    private Key getSignInKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(secret);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/LogoutService.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport com.maximilianwiegmann.backend.security.token.TokenRepository;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.logout.LogoutHandler;\nimport org.springframework.stereotype.Service;", "import org.springframework.security.web.authentication.logout.LogoutHandler;\nimport org.springframework.stereotype.Service;\n\n@Service\n@RequiredArgsConstructor\npublic class LogoutService implements LogoutHandler {\n\n    private final TokenRepository tokenRepository;\n\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        String authHeader = request.getHeader(\"Authorization\");\n        String jwt;", "    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        String authHeader = request.getHeader(\"Authorization\");\n        String jwt;\n        if(authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            return;\n        }\n        jwt = authHeader.substring(7);\n        var storedToken = tokenRepository.findByToken(jwt)\n                .orElse(null);\n        if(storedToken != null) {\n            storedToken.setExpired(true);\n            storedToken.setRevoked(true);\n            tokenRepository.save(storedToken);\n            SecurityContextHolder.clearContext();\n        }\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n}\n", "        if(storedToken != null) {\n            storedToken.setExpired(true);\n            storedToken.setRevoked(true);\n            tokenRepository.save(storedToken);\n            SecurityContextHolder.clearContext();\n        }\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/WebSocketConfig.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.simp.config.ChannelRegistration;\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry;\nimport org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.config.annotation.EnableWebSocket;", "import org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.config.annotation.EnableWebSocket;\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry;\nimport org.springframework.web.socket.config.annotation.WebSocketConfigurer;\nimport org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;\nimport org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;\nimport org.springframework.web.socket.config.annotation.WebSocketTransportRegistration;\nimport org.springframework.web.socket.server.HandshakeInterceptor;\n", "import org.springframework.web.socket.server.HandshakeInterceptor;\n\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\n\nimport lombok.RequiredArgsConstructor;\n\n@Configuration\n@EnableWebSocketMessageBroker\n@RequiredArgsConstructor\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    private final WebSocketAuthInterceptor authInterceptor;\n\n    @Override", "@RequiredArgsConstructor\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    private final WebSocketAuthInterceptor authInterceptor;\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\").setAllowedOriginPatterns(\"*\").withSockJS();\n    }\n\n    @Override", "    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.setApplicationDestinationPrefixes(\"/app\");\n        registry.enableSimpleBroker(\"/channel\", \"/notifications\");\n    }\n\n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(authInterceptor);\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/ApplicationConfig.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;", "import org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\n@RequiredArgsConstructor\npublic class ApplicationConfig {\n\n    private final AccountRepository accountRepository;\n\n    @Bean", "@RequiredArgsConstructor\npublic class ApplicationConfig {\n\n    private final AccountRepository accountRepository;\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        return username -> accountRepository.findByUsername(username).orElseThrow(() -> new UsernameNotFoundException(\"User not found\"));\n    }\n\n    @Bean", "    public AuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\n        authProvider.setUserDetailsService(userDetailsService());\n        authProvider.setPasswordEncoder(passwordEncoder());\n        return authProvider;\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n\n    @Bean", "    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/SecurityConfiguration.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authorization.AuthorizationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;", "import org.springframework.security.authorization.AuthorizationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.socket.EnableWebSocketSecurity;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.authentication.logout.HttpStatusReturningLogoutSuccessHandler;\nimport org.springframework.security.web.authentication.logout.LogoutHandler;", "import org.springframework.security.web.authentication.logout.HttpStatusReturningLogoutSuccessHandler;\nimport org.springframework.security.web.authentication.logout.LogoutHandler;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\n@Configuration\n@EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfiguration {\n\n    private final JwtAuthenticationFilter jwtAuthFilter;\n    private final AuthenticationProvider authenticationProvider;\n    private final LogoutHandler logoutHandler;\n\n    @Bean", "@RequiredArgsConstructor\npublic class SecurityConfiguration {\n\n    private final JwtAuthenticationFilter jwtAuthFilter;\n    private final AuthenticationProvider authenticationProvider;\n    private final LogoutHandler logoutHandler;\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.cors().and()\n                .csrf()\n                .disable()\n                .authorizeHttpRequests()\n                .requestMatchers(\"/auth/**\", \"/ws/**\")\n                .permitAll()\n                .anyRequest()\n                .authenticated()\n                .and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authenticationProvider(authenticationProvider).\n                addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n}\n", "    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.cors().and()\n                .csrf()\n                .disable()\n                .authorizeHttpRequests()\n                .requestMatchers(\"/auth/**\", \"/ws/**\")\n                .permitAll()\n                .anyRequest()\n                .authenticated()\n                .and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authenticationProvider(authenticationProvider).\n                addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/WebSocketAuthInterceptor.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport java.nio.file.AccessDeniedException;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.simp.stomp.StompCommand;\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor;", "import org.springframework.messaging.simp.stomp.StompCommand;\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor;\nimport org.springframework.messaging.support.ChannelInterceptor;\nimport org.springframework.messaging.support.MessageHeaderAccessor;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.Assert;", "import org.springframework.stereotype.Component;\nimport org.springframework.util.Assert;\n\nimport com.maximilianwiegmann.backend.security.token.TokenRepository;\n\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport lombok.RequiredArgsConstructor;\n\n@Component", "\n@Component\n@RequiredArgsConstructor\npublic class WebSocketAuthInterceptor implements ChannelInterceptor {\n\n    private final JwtService jwtService;\n    private final UserDetailsService userDetailsService;\n    private final TokenRepository tokenRepository;\n\n    @Override\n    public Message<?> preSend(Message<?> message, MessageChannel channel) {\n        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);", "        if (accessor == null) {\n            return null;\n        }\n        if (StompCommand.CONNECT.equals(accessor.getCommand())) {\n            List<String> authorizationHeaders = accessor.getNativeHeader(\"Authorization\");\n\n            if (authorizationHeaders != null && !authorizationHeaders.isEmpty()) {\n                String jwt = authorizationHeaders.get(0).replace(\"Bearer \", \"\");\n\n                String username = jwtService.extractUsername(jwt);\n                if (username != null && accessor.getUser() == null) {\n                    UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                    boolean isTokenValid = tokenRepository.findByToken(jwt)\n                            .map(token -> !token.isExpired() && !token.isRevoked())\n                            .orElse(false);", "                if (username != null && accessor.getUser() == null) {\n                    UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                    boolean isTokenValid = tokenRepository.findByToken(jwt)\n                            .map(token -> !token.isExpired() && !token.isRevoked())\n                            .orElse(false);\n                    if (jwtService.isTokenValid(jwt, userDetails) && isTokenValid && !jwtService.isTfaToken(jwt)) {\n                        accessor.setUser(new UsernamePasswordAuthenticationToken(jwt, null));\n                        return message;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        return message;\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/config/JwtAuthenticationFilter.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.config;\n\nimport com.maximilianwiegmann.backend.security.token.TokenRepository;\nimport io.jsonwebtoken.ExpiredJwtException;\nimport io.jsonwebtoken.MalformedJwtException;\nimport jakarta.servlet.FilterChain;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport lombok.NonNull;", "import jakarta.servlet.http.HttpServletResponse;\nimport lombok.NonNull;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;", "import org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport java.io.IOException;\n\n@Component\n@RequiredArgsConstructor\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    private final JwtService jwtService;\n    private final UserDetailsService userDetailsService;\n    private final TokenRepository tokenRepository;\n\n    @Override\n    protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain) throws ServletException, IOException {\n        String authHeader = request.getHeader(\"Authorization\");\n        String jwt;\n        String username;", "        if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        jwt = authHeader.substring(7);\n        try {\n            username = jwtService.extractUsername(jwt);\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                boolean isTokenValid = tokenRepository.findByToken(jwt)\n                        .map(token -> !token.isExpired() && !token.isRevoked())\n                        .orElse(false);", "                if (jwtService.isTokenValid(jwt, userDetails) && isTokenValid && !jwtService.isTfaToken(jwt)) {\n                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(\n                            userDetails,\n                            null,\n                            userDetails.getAuthorities()\n                    );\n                    authToken.setDetails(\n                            new WebAuthenticationDetailsSource().buildDetails(request)\n                    );\n                    SecurityContextHolder.getContext().setAuthentication(authToken);\n                }\n            }\n        } catch (ExpiredJwtException | NullPointerException e) {\n            filterChain.doFilter(request, response);\n            System.out.println(\"expired\");\n            return;\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/token/Token.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.token;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Data", "\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\n@Document(collection = \"tokens\")\npublic class Token {\n\n    @Id\n    private String id;\n\n    private String token;\n\n    private boolean revoked;\n\n    private boolean expired;\n\n    private String userId;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/security/token/TokenRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.security.token;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.mongodb.repository.Query;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface TokenRepository extends MongoRepository<Token, String> {\n\n    @Query(\"{ 'userId' : ?0, 'revoked' : false, 'expired' : false }\")\n    List<Token> findAllValidTokensByUserId(String userId);\n\n    Optional<Token> findByToken(String token);\n}\n", "public interface TokenRepository extends MongoRepository<Token, String> {\n\n    @Query(\"{ 'userId' : ?0, 'revoked' : false, 'expired' : false }\")\n    List<Token> findAllValidTokensByUserId(String userId);\n\n    Optional<Token> findByToken(String token);\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/GroupController.java", "chunked_list": ["package com.maximilianwiegmann.backend.group;\n\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport com.maximilianwiegmann.backend.group.data.GroupData;\nimport com.maximilianwiegmann.backend.group.data.GroupInvite;\nimport com.maximilianwiegmann.backend.group.data.GroupMember;\nimport com.maximilianwiegmann.backend.payload.response.GroupResponse;\nimport lombok.RequiredArgsConstructor;", "import com.maximilianwiegmann.backend.payload.response.GroupResponse;\nimport lombok.RequiredArgsConstructor;\nimport org.bson.Document;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;", "\nimport java.util.List;\n\n@RestController\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequestMapping(\"/groups\")\n@RequiredArgsConstructor\npublic class GroupController {\n\n    private final GroupService groupService;\n\n    @PostMapping\n    public ResponseEntity<GroupResponse> createGroup(@RequestBody GroupData groupData) {\n        return ResponseEntity.ok(groupService.createGroup(groupData));\n    }\n\n    @GetMapping\n    public ResponseEntity<List<GroupResponse>> getGroups() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        return ResponseEntity.ok(groupService.getGroupsByUser(accountData.getId()));\n    }\n\n    @DeleteMapping(\"/{gId}\")\n    public ResponseEntity<Boolean> deleteGroup(@PathVariable String gId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (groupService.getGroupsByUser(accountData.getId()).stream().noneMatch(groupResponse -> groupResponse.getId().equals(gId)))\n            return ResponseEntity.status(403).build();\n\n        GroupMember groupMember = groupService.getGroupById(gId).getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        assert groupMember != null;\n        if (groupMember.getRole() != GroupMember.ROLE_OWNER) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.deleteGroup(gId));\n    }\n\n    @GetMapping(\"/gid/{gId}\")\n    public ResponseEntity<GroupResponse> getGroupById(@PathVariable String gId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (groupService.getGroupsByUser(accountData.getId()).stream().noneMatch(groupResponse -> groupResponse.getId().equals(gId)))\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.getGroupById(gId));\n    }\n\n    @PostMapping(\"/update\")\n    public ResponseEntity<GroupResponse> updateGroup(@RequestBody GroupData groupData) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (groupService.getGroupsByUser(accountData.getId()).stream().noneMatch(groupResponse -> groupResponse.getId().equals(groupData.getId())))\n            return ResponseEntity.status(403).build();\n\n        GroupMember groupMember = groupService.getGroupById(groupData.getId()).getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        assert groupMember != null;", "        if (groupService.getGroupsByUser(accountData.getId()).stream().noneMatch(groupResponse -> groupResponse.getId().equals(groupData.getId())))\n            return ResponseEntity.status(403).build();\n\n        GroupMember groupMember = groupService.getGroupById(groupData.getId()).getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        assert groupMember != null;\n        if (groupMember.getRole() != GroupMember.ROLE_OWNER) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.updateGroup(groupData));\n    }\n\n    @GetMapping(\"/requests/{uId}\")\n    public ResponseEntity<List<Document>> getGroupRequests(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null || !accountData.getId().equals(uId)) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.getGroupRequests(uId));\n    }\n\n    @PostMapping(\"/join/{gId}\")\n    public ResponseEntity<GroupResponse> joinGroup(@PathVariable String gId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.joinGroup(gId, accountData.getId()));\n    }\n\n    @PostMapping(\"/join_link/{token}\")\n    public ResponseEntity<GroupResponse> joinGroupByLink(@PathVariable String token) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.joinByLink(token, accountData));\n    }\n\n    @PostMapping(\"/leave/{gId}\")\n    public ResponseEntity<?> leaveGroup(@PathVariable String gId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(groupService.leaveGroup(gId, accountData.getId()));\n    }\n\n    @PostMapping(\"/chat/delete/{gId}\")\n    public ResponseEntity<?> deleteChat(@PathVariable String gId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null) return ResponseEntity.status(403).build();\n\n        GroupData groupData = groupService.getGroup(gId);\n        if (groupData == null) return ResponseEntity.status(404).build();\n\n        GroupMember groupMember = groupData.getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        if (groupMember == null) return ResponseEntity.status(403).build();\n        if (groupMember.getRole() != GroupMember.ROLE_OWNER) return ResponseEntity.status(403).build();\n\n        return ResponseEntity.ok(groupService.deleteChat(gId));\n    }\n\n    @PostMapping(\"/invite/{gId}\")\n    public ResponseEntity<?> createInvite(@PathVariable String gId, @RequestBody GroupInvite invite) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null) return ResponseEntity.status(403).build();\n\n        GroupData groupData = groupService.getGroup(gId);\n        if (groupData == null) return ResponseEntity.status(404).build();\n\n        GroupMember groupMember = groupData.getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        if (groupMember == null) return ResponseEntity.status(403).build();\n\n        if (groupMember.getRole() != GroupMember.ROLE_OWNER && groupMember.getRole() != GroupMember.ROLE_ADMIN) return ResponseEntity.status(403).build();\n\n        return groupService.createInviteLink(gId, invite.getExpire(), invite.getReceiver(), invite.getMaxUses(), accountData.getId());\n    }\n\n    @GetMapping(\"/invite/{iId}\")\n    public ResponseEntity<?> getGroupByInviteLink(@PathVariable String iId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (groupMember.getRole() != GroupMember.ROLE_OWNER && groupMember.getRole() != GroupMember.ROLE_ADMIN) return ResponseEntity.status(403).build();\n\n        return groupService.createInviteLink(gId, invite.getExpire(), invite.getReceiver(), invite.getMaxUses(), accountData.getId());\n    }\n\n    @GetMapping(\"/invite/{iId}\")\n    public ResponseEntity<?> getGroupByInviteLink(@PathVariable String iId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.status(403).build();\n\n        GroupData groupData = groupService.getGroupByInviteToken(iId);", "        if (accountData == null) return ResponseEntity.status(403).build();\n\n        GroupData groupData = groupService.getGroupByInviteToken(iId);\n        if (groupData == null) return ResponseEntity.status(404).build();\n\n        GroupMember groupMember = groupData.getMember().stream().filter(member -> member.getId().equals(accountData.getId())).findFirst().orElse(null);\n        if (groupMember != null) return ResponseEntity.status(409).build();\n\n        return ResponseEntity.ok(groupData.toResponse().toPublicResponse());\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/GroupRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.group;\n\nimport com.maximilianwiegmann.backend.group.data.GroupData;\nimport com.maximilianwiegmann.backend.group.data.GroupMember;\nimport com.maximilianwiegmann.backend.statistics.StatisticRepository;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.mongodb.repository.Query;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface GroupRepository extends MongoRepository<GroupData, String>, StatisticRepository<GroupData> {\n\n    List<GroupData> findAllByMemberId(String uid);\n\n    @Query(\"{ 'invited' : { $elemMatch: { 'reciever' : ?0 } } }\")\n    List<GroupData> findAllByInvitedContains(String uid);\n\n    @Query(\"{ 'invited' : { $elemMatch: { 'token' : ?0 } } }\")\n    Optional<GroupData> findByInviteToken(String token);\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/GroupService.java", "chunked_list": ["package com.maximilianwiegmann.backend.group;\n\nimport com.maximilianwiegmann.backend.BackendApplication;\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport com.maximilianwiegmann.backend.group.data.GroupData;\nimport com.maximilianwiegmann.backend.group.data.GroupInvite;\nimport com.maximilianwiegmann.backend.group.data.GroupMember;\nimport com.maximilianwiegmann.backend.notifications.Notification;", "import com.maximilianwiegmann.backend.group.data.GroupMember;\nimport com.maximilianwiegmann.backend.notifications.Notification;\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\nimport com.maximilianwiegmann.backend.payload.response.GroupResponse;\nimport com.mongodb.lang.Nullable;\n\nimport lombok.RequiredArgsConstructor;\nimport org.bson.Document;\nimport org.json.JSONObject;\nimport org.springframework.http.ResponseEntity;", "import org.json.JSONObject;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n", "import java.util.Map;\n\n@Service\n@RequiredArgsConstructor\npublic class GroupService {\n\n    private final GroupRepository groupRepository;\n    private final SimpMessageSendingOperations messagingTemplate;\n    private final NotificationHandler notificationHandler;\n\n    public GroupData getGroup(String id) {\n        return groupRepository.findById(id).orElse(null);\n    }\n\n    public List<GroupData> getGroups(long from, long to) {\n        return groupRepository.findByFromTo(from, to, \"created\");\n    }\n\n    public List<ChatMessage> getMessages(long from, long to) {\n        List<GroupData> groups = groupRepository.findByFromTo(from, to, \"created\");\n        return groups.stream().map(GroupData::getMessages).flatMap(List::stream).toList();\n    }\n", "    public GroupData getGroup(String id) {\n        return groupRepository.findById(id).orElse(null);\n    }\n\n    public List<GroupData> getGroups(long from, long to) {\n        return groupRepository.findByFromTo(from, to, \"created\");\n    }\n\n    public List<ChatMessage> getMessages(long from, long to) {\n        List<GroupData> groups = groupRepository.findByFromTo(from, to, \"created\");\n        return groups.stream().map(GroupData::getMessages).flatMap(List::stream).toList();\n    }\n", "    public GroupResponse createGroup(GroupData groupData) {\n        Map<String, Object> defaultMap = new HashMap<>();\n        defaultMap.put(\"requireTfa\", false);\n        groupData.setSettingMap(defaultMap);\n        return groupRepository.save(groupData).toResponse();\n    }\n\n    public List<GroupResponse> getGroupsByUser(String uid) {\n        return groupRepository.findAllByMemberId(uid).stream().map(GroupData::toResponse).toList();\n    }\n\n    public List<GroupData> getGroupsDataByUser(String uid) {\n        return groupRepository.findAllByMemberId(uid);\n    }\n", "    public GroupResponse getGroupById(String gid) {\n        GroupData group = groupRepository.findById(gid).orElse(null);\n        if (group == null)\n            return null;\n        return group.toResponse();\n    }\n\n    public GroupResponse updateGroup(GroupData groupData) {\n        GroupData group = groupRepository.findById(groupData.getId()).orElse(null);\n        if (group == null)\n            return null;", "        if (group == null)\n            return null;\n        if (groupData.getName() != null)\n            group.setName(groupData.getName());\n        if (groupData.getDescription() != null)\n            group.setDescription(groupData.getDescription());\n        if (groupData.getIcon() != null)\n            group.setIcon(groupData.getIcon());\n        if (groupData.getMember() != null)\n            group.setInvited(groupData.getInvited());\n        if (groupData.getRequests() != null)\n            group.setRequests(groupData.getRequests());", "        if (groupData.getMember() != null)\n            group.setInvited(groupData.getInvited());\n        if (groupData.getRequests() != null)\n            group.setRequests(groupData.getRequests());\n        if (groupData.getSettingMap() != null)\n            group.setSettingMap(groupData.getSettingMap());\n        return groupRepository.save(group).toResponse();\n    }\n\n    public List<Document> getGroupRequests(String uid) {\n        return groupRepository.findAllByInvitedContains(uid).stream().map(data -> new Document()\n                .append(\"gId\", data.getId())\n                .append(\"name\", data.getName())\n                .append(\"description\", data.getDescription())\n                .append(\"icon\", data.getIcon())\n                .append(\"member\", data.getMember().size())).toList();\n    }\n", "    public GroupResponse joinGroup(String gid, String uid) {\n        GroupData group = groupRepository.findById(gid).orElse(null);\n        if (group == null)\n            return null;\n        if (group.getInvited().stream()\n                .noneMatch(invited -> invited.getReceiver() != null && invited.getReceiver().equals(uid))\n                || group.getMember().stream().anyMatch(member -> member.getId().equals(uid)))\n            return null;\n        group.getMember().add(new GroupMember(uid, System.currentTimeMillis(), GroupMember.ROLE_MEMBER));\n        group.getInvited().removeIf(invited -> invited.getReceiver() != null && invited.getReceiver().equals(uid));\n        group.getRequests().removeIf(request -> request.getId().equals(uid));\n        return groupRepository.save(group).toResponse();\n    }\n", "    public GroupResponse joinByLink(String token, AccountData account) {\n        GroupData group = groupRepository.findByInviteToken(token).stream().findFirst().orElse(null);\n        if (group == null)\n            return null;\n        if (group.getMember().stream().anyMatch(member -> member.getId().equals(account.getId())))\n            return null;\n        GroupInvite invite = group.getInvited().stream().filter(invited -> invited.getToken().equals(token)).findFirst()\n                .orElse(null);\n        if (invite == null)\n            return null;\n        if (invite.isExpired())\n            return null;", "        if (invite == null)\n            return null;\n        if (invite.isExpired())\n            return null;\n        if ((Boolean) group.getSettingMap().get(\"requireTfa\") && account.getTfaSecret() == null)\n            return null;\n        group.getMember().add(new GroupMember(account.getId(), System.currentTimeMillis(), GroupMember.ROLE_MEMBER));\n        invite.use();\n        group.updateInvite(invite);\n\n        if (invite.getIssuer() != null)\n            notificationHandler.notifyUser(invite.getIssuer(),\n                    Notification.builder()\n                            .title(\"Invite code has been used\")\n                            .body(account.getUsername() + \" has used your invite link.\")\n                            .build());\n        return groupRepository.save(group).toResponse();\n    }\n", "        if (invite.getIssuer() != null)\n            notificationHandler.notifyUser(invite.getIssuer(),\n                    Notification.builder()\n                            .title(\"Invite code has been used\")\n                            .body(account.getUsername() + \" has used your invite link.\")\n                            .build());\n        return groupRepository.save(group).toResponse();\n    }\n\n    public GroupResponse leaveGroup(String gid, String uid) {\n        GroupData group = groupRepository.findById(gid).orElse(null);", "    public GroupResponse leaveGroup(String gid, String uid) {\n        GroupData group = groupRepository.findById(gid).orElse(null);\n        if (group == null)\n            return null;\n        if (group.getMember().stream().noneMatch(member -> member.getId().equals(uid)))\n            return null;\n        group.getMember().removeIf(member -> member.getId().equals(uid));\n        if (group.getMember().isEmpty()) {\n            deleteGroup(group.getId());\n            return null;\n        }\n        group = groupRepository.save(group);\n        return group.toResponse();\n    }\n\n    public ResponseEntity<?> createInviteLink(String gId, long expire, @Nullable String reciever, int maxUses,\n            String issuer) {\n        GroupData groupData = getGroup(gId);", "        if (groupData == null)\n            return ResponseEntity.badRequest().build();\n        if (groupData.getInvited().stream()\n                .anyMatch(invite -> invite.getReceiver() != null && invite.getReceiver().equals(reciever)\n                        && !invite.isExpired()))\n            return ResponseEntity.badRequest().build();\n\n        String token = BackendApplication.generateString(20);\n\n        GroupInvite invite = GroupInvite.builder().token(token).expire(expire == 0 ? -1 : expire).maxUses(maxUses)\n                .receiver(reciever).issuer(issuer)\n                .build();\n        groupData.getInvited().add(invite);\n        groupRepository.save(groupData);\n", "        if (reciever != null) {\n            notificationHandler.notifyUser(reciever,\n                    Notification.builder()\n                            .title(\"Group Invite\")\n                            .body(\"You have been invited to \" + groupData.getName())\n                            .link(\"https://maximilianwiegmann.com/groups?invlink=\" + token)\n                            .build());\n        }\n\n        return ResponseEntity.ok(invite);\n    }\n", "    public GroupData getGroupByInviteToken(String token) {\n        GroupData group = groupRepository.findByInviteToken(token).stream().findFirst().orElse(null);\n        if (group == null)\n            return null;\n        GroupInvite invite = group.getInvited().stream().filter(invited -> invited.getToken().equals(token)).findFirst()\n                .orElse(null);\n        if (invite == null)\n            return null;\n        if (invite.isExpired())\n            return null;\n        AccountData account = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (invite.isExpired())\n            return null;\n        AccountData account = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (invite.getReceiver() != null && !invite.getReceiver().equals(account.getId()))\n            return null;\n        return group;\n        // return groupRepository.findAll().stream().filter(groupData ->\n        // groupData.getInvited().stream() .anyMatch(invite -> invite.getToken() != null\n        // && invite.getToken().equals(token) &&\n        // !invite.isExpired())).findFirst().orElse(null);\n    }\n", "    public boolean deleteChat(String gId) {\n        return false;\n    }\n\n    public boolean deleteChatFromUser(String gId, String uId) {\n        return false;\n    }\n\n    public boolean deleteChatById(String gId, String mId) {\n        return false;\n    }\n", "    public boolean deleteChatById(String gId, String mId) {\n        return false;\n    }\n\n    public boolean deleteGroup(String gid) {\n        if (!groupRepository.existsById(gid))\n            return false;\n        ChatMessage chatMessage = new ChatMessage();\n        chatMessage.setType(ChatMessage.MessageType.DELETE);\n\n        messagingTemplate.convertAndSend(String.format(\"/channel/%s\", gid), chatMessage);\n        groupRepository.deleteById(gid);\n        return true;\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/data/GroupInvite.java", "chunked_list": ["package com.maximilianwiegmann.backend.group.data;\n\nimport com.mongodb.lang.Nullable;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;", "import lombok.RequiredArgsConstructor;\nimport lombok.Setter;\nimport lombok.Builder.Default;\n\n@Data\n@Builder\n@AllArgsConstructor\n@RequiredArgsConstructor\n@Getter\n@Setter\npublic class GroupInvite {\n    private String token;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n    private long expire;\n    @Nullable\n    private String receiver;\n    private String issuer;\n\n    private int used;\n    private int maxUses;\n", "@Getter\n@Setter\npublic class GroupInvite {\n    private String token;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n    private long expire;\n    @Nullable\n    private String receiver;\n    private String issuer;\n\n    private int used;\n    private int maxUses;\n", "    public boolean isExpired() {\n        return (expire != -1 && timestamp + expire < System.currentTimeMillis()) || (maxUses != 0 && used >= maxUses);\n    }\n\n    public void use() {\n        used++;\n        if (receiver != null)\n            expire = 1;\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/data/GroupData.java", "chunked_list": ["package com.maximilianwiegmann.backend.group.data;\n\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport com.maximilianwiegmann.backend.payload.response.GroupResponse;\nimport lombok.*;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\n\n@Data\n@Builder\n@Document(collection = \"groups\")\n@AllArgsConstructor\n@NoArgsConstructor\n@Getter\npublic class GroupData {\n\n    @Id\n    private String id;\n\n    private String name;\n    private String description;\n    private long created;\n    private String icon;\n    private Map<String, Object> settingMap;\n    private List<GroupMember> member;\n    private List<GroupInvite> invited;\n    private List<GroupMember> requests;\n    private List<ChatMessage> messages;\n", "@Getter\npublic class GroupData {\n\n    @Id\n    private String id;\n\n    private String name;\n    private String description;\n    private long created;\n    private String icon;\n    private Map<String, Object> settingMap;\n    private List<GroupMember> member;\n    private List<GroupInvite> invited;\n    private List<GroupMember> requests;\n    private List<ChatMessage> messages;\n", "    public GroupResponse toResponse() {\n        return GroupResponse.builder()\n                .id(id)\n                .name(name)\n                .description(description)\n                .icon(icon)\n                .created(created)\n                .member(member)\n                .invited(invited)\n                .requests(requests)\n                .messages(messages)\n                .settingMap(settingMap)\n                .build();\n    }\n", "    public void updateInvite(GroupInvite invite) {\n        invited.removeIf(current -> current.getToken().equals(invite.getToken()));\n        invited.add(invite);\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/group/data/GroupMember.java", "chunked_list": ["package com.maximilianwiegmann.backend.group.data;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\n\n@AllArgsConstructor\n@Getter\n@Data", "@Getter\n@Data\n@Builder\npublic class GroupMember {\n    private String id;\n    private long timestamp;\n    private int role;\n\n    public static int ROLE_ADMIN = -1;\n    public static int ROLE_OWNER = 0;\n    public static int ROLE_MEMBER = 1;\n}\n", "    public static int ROLE_ADMIN = -1;\n    public static int ROLE_OWNER = 0;\n    public static int ROLE_MEMBER = 1;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/response/PublicAccountResponse.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.response;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Builder\n@Data\n@AllArgsConstructor", "@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class PublicAccountResponse {\n    private String uId;\n    private String username;\n    private String firstName;\n    private String lastName;\n    private String email;\n    private String avatar;\n    private int status;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/response/AuthenticationResponse.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.response;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@Builder\n@AllArgsConstructor", "@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class AuthenticationResponse {\n\n    private String token;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/response/GroupResponse.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.response;\n\nimport com.maximilianwiegmann.backend.chat.ChatMessage;\nimport com.maximilianwiegmann.backend.group.data.GroupInvite;\nimport com.maximilianwiegmann.backend.group.data.GroupMember;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n", "import lombok.NoArgsConstructor;\n\nimport java.util.List;\nimport java.util.Map;\n\n@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class GroupResponse {\n    private String name;\n    private String id;\n    private String description;\n    private String icon;\n    private long created;\n    private List<GroupMember> member;\n    private List<GroupInvite> invited;\n    private List<GroupMember> requests;\n    private List<ChatMessage> messages;\n    private Map<String, Object> settingMap;\n", "@NoArgsConstructor\npublic class GroupResponse {\n    private String name;\n    private String id;\n    private String description;\n    private String icon;\n    private long created;\n    private List<GroupMember> member;\n    private List<GroupInvite> invited;\n    private List<GroupMember> requests;\n    private List<ChatMessage> messages;\n    private Map<String, Object> settingMap;\n", "    public GroupResponse toPublicResponse() {\n        GroupResponse response = this;\n        response.setMessages(null);\n        response.setRequests(null);\n        response.setInvited(null);\n        return response;\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/request/TwoFARequest.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.request;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@AllArgsConstructor\n@Getter\npublic class TwoFARequest {\n    private final String token, code;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/request/AuthenticationRequest.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.request;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@Builder\n@AllArgsConstructor", "@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class AuthenticationRequest {\n\n    private String username, password;\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/payload/request/RegisterRequest.java", "chunked_list": ["package com.maximilianwiegmann.backend.payload.request;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@Builder\n@AllArgsConstructor", "@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class RegisterRequest {\n\n    private String username;\n    private String password;\n    private String firstName;\n    private String lastName;\n    private String email;\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/notifications/Notification.java", "chunked_list": ["package com.maximilianwiegmann.backend.notifications;\n\nimport org.json.JSONObject;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.DBRef;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\nimport com.fasterxml.jackson.annotation.JsonBackReference;\nimport com.maximilianwiegmann.backend.account.AccountData;\n", "import com.maximilianwiegmann.backend.account.AccountData;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\nimport lombok.Builder.Default;\n", "import lombok.Builder.Default;\n\n@Data\n@Builder\n@AllArgsConstructor\n@RequiredArgsConstructor\n@Getter\n@Setter\n@Document(collection = \"notifications\")\npublic class Notification {\n\n    @Id\n    private String id;\n\n    private String title;\n    private String body;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n    private String link;\n    @Default\n    private boolean read = false;\n\n    private String uId;\n", "@Document(collection = \"notifications\")\npublic class Notification {\n\n    @Id\n    private String id;\n\n    private String title;\n    private String body;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n    private String link;\n    @Default\n    private boolean read = false;\n\n    private String uId;\n", "    public String toJson() {\n        return new JSONObject().put(\"id\", id).put(\"title\", title).put(\"body\", body).put(\"timestamp\", timestamp)\n                .put(\"link\", link).put(\"read\", read).toString();\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/notifications/NotificationRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.notifications;\n\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.mongodb.repository.Query;\n\nimport com.maximilianwiegmann.backend.statistics.StatisticRepository;\n\npublic interface NotificationRepository extends MongoRepository<Notification, String>, StatisticRepository<Notification> {\n\n    @Query(\"{ 'uId' : ?0 }\")\n    List<Notification> findByUserId(String uId);\n\n    @Query(\"{ 'uId' : ?0, 'read' : false }\")\n    List<Notification> findByUserIdAndNotRead(String uId);\n\n}\n", "\npublic interface NotificationRepository extends MongoRepository<Notification, String>, StatisticRepository<Notification> {\n\n    @Query(\"{ 'uId' : ?0 }\")\n    List<Notification> findByUserId(String uId);\n\n    @Query(\"{ 'uId' : ?0, 'read' : false }\")\n    List<Notification> findByUserIdAndNotRead(String uId);\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/notifications/NotificationController.java", "chunked_list": ["package com.maximilianwiegmann.backend.notifications;\n\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.messaging.handler.annotation.MessageMapping;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;", "import org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.maximilianwiegmann.backend.account.AccountData;\n", "import com.maximilianwiegmann.backend.account.AccountData;\n\nimport lombok.RequiredArgsConstructor;\n\n@RestController\n@RequestMapping(\"/notifications\")\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequiredArgsConstructor\n@Controller\npublic class NotificationController {\n\n    private final NotificationHandler notificationHandler;\n\n    @GetMapping\n    public ResponseEntity<?> getNotifications() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "@Controller\npublic class NotificationController {\n\n    private final NotificationHandler notificationHandler;\n\n    @GetMapping\n    public ResponseEntity<?> getNotifications() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.getNotifications(accountData));\n    }\n\n    @PostMapping(\"/read/{id}\")\n    public ResponseEntity<?> readNotification(@PathVariable String id) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.getNotifications(accountData));\n    }\n\n    @PostMapping(\"/read/{id}\")\n    public ResponseEntity<?> readNotification(@PathVariable String id) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.readNotification(accountData, id));\n    }\n\n    @PostMapping(\"/readAll\")\n    public ResponseEntity<?> readAllNotifications() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.readNotification(accountData, id));\n    }\n\n    @PostMapping(\"/readAll\")\n    public ResponseEntity<?> readAllNotifications() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.readAllNotifications(accountData));\n    }\n\n    @PostMapping(\"/notifyAll\")\n    public ResponseEntity<?> notifyAll(@RequestBody Notification notification) {\n        notificationHandler.notifyAll(notification);\n        return ResponseEntity.ok().build();\n    }\n\n}\n", "        if (accountData == null)\n            return ResponseEntity.badRequest().build();\n        return ResponseEntity.ok(notificationHandler.readAllNotifications(accountData));\n    }\n\n    @PostMapping(\"/notifyAll\")\n    public ResponseEntity<?> notifyAll(@RequestBody Notification notification) {\n        notificationHandler.notifyAll(notification);\n        return ResponseEntity.ok().build();\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/notifications/NotificationHandler.java", "chunked_list": ["package com.maximilianwiegmann.backend.notifications;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n", "import java.util.Set;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.xml.PluggableSchemaResolver;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor;\nimport org.springframework.messaging.simp.user.SimpUser;\nimport org.springframework.messaging.simp.user.SimpUserRegistry;\nimport org.springframework.stereotype.Component;", "import org.springframework.messaging.simp.user.SimpUserRegistry;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.socket.CloseStatus;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketSession;\nimport org.springframework.web.socket.handler.TextWebSocketHandler;\n\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.security.config.JwtService;", "import com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.security.config.JwtService;\nimport com.maximilianwiegmann.backend.security.token.TokenRepository;\n\nimport ch.qos.logback.core.subst.Token;\nimport lombok.RequiredArgsConstructor;\n\n@Component\n@RequiredArgsConstructor\npublic class NotificationHandler extends TextWebSocketHandler {\n\n    private final AccountRepository accountRepository;\n    private final NotificationRepository notificationRepository;\n    private final SimpMessageSendingOperations messagingTemplate;\n    private final SimpUserRegistry userRegistry;\n    private final JwtService jwtService;\n", "@RequiredArgsConstructor\npublic class NotificationHandler extends TextWebSocketHandler {\n\n    private final AccountRepository accountRepository;\n    private final NotificationRepository notificationRepository;\n    private final SimpMessageSendingOperations messagingTemplate;\n    private final SimpUserRegistry userRegistry;\n    private final JwtService jwtService;\n\n    public int getStatus(String uId) {\n        SimpUser user = findByUId(uId);\n        return user == null ? 0 : 1;\n    }\n\n    public List<Notification> getNotifications(long from, long to) {\n        return notificationRepository.findByFromTo(from, to, \"timestamp\");\n    }\n", "    public int getStatus(String uId) {\n        SimpUser user = findByUId(uId);\n        return user == null ? 0 : 1;\n    }\n\n    public List<Notification> getNotifications(long from, long to) {\n        return notificationRepository.findByFromTo(from, to, \"timestamp\");\n    }\n\n    public void notifyUser(String uid, Notification notification) {\n        AccountData accountData = accountRepository.findById(uid).orElse(null);", "    public void notifyUser(String uid, Notification notification) {\n        AccountData accountData = accountRepository.findById(uid).orElse(null);\n        if (accountData == null)\n            return;\n        notification.setUId(uid);\n        notificationRepository.save(notification);\n        \n        SimpUser user = findByUId(uid);\n        if (user == null)\n            return;\n\n        messagingTemplate.convertAndSend(\"/notifications/\" + user.getName(), notification.toJson());\n    }\n\n    private SimpUser findByUId(String uId) {\n        return userRegistry.getUsers().stream().filter(entry -> {\n            String id = jwtService.extractUId(entry.getName());\n            return id != null && id.equals(uId);\n        }).findFirst().orElse(null);\n    }\n    ", "        if (user == null)\n            return;\n\n        messagingTemplate.convertAndSend(\"/notifications/\" + user.getName(), notification.toJson());\n    }\n\n    private SimpUser findByUId(String uId) {\n        return userRegistry.getUsers().stream().filter(entry -> {\n            String id = jwtService.extractUId(entry.getName());\n            return id != null && id.equals(uId);\n        }).findFirst().orElse(null);\n    }\n    ", "    public void notifyAll(Notification notification) {\n        userRegistry.getUsers().forEach(user -> {\n            messagingTemplate.convertAndSend(\"/notifications/\" + user.getName(), notification.toJson());\n        });\n    }\n\n    public ResponseEntity<List<Notification>> readAllNotifications(AccountData accountData) {\n        List<Notification> notifications = notificationRepository.findByUserIdAndNotRead(accountData.getId());\n        notifications.forEach(notification -> notification.setRead(true));\n        notificationRepository.saveAll(notifications);\n        return ResponseEntity.ok(getNotifications(accountData));\n    }\n\n    public ResponseEntity<List<Notification>> readNotification(AccountData accountData, String id) {\n        List<Notification> notifications = notificationRepository.findByUserId(accountData.getId());\n        notifications.stream().filter(notification -> notification.getId().equals(id)).findFirst().ifPresent(notification -> {\n            notification.setRead(true);\n            notificationRepository.save(notification);\n        });\n        return ResponseEntity.ok(notifications);\n    }\n\n    public List<Notification> getNotifications(AccountData accountData) {\n        return notificationRepository.findByUserId(accountData.getId());\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/AccountService.java", "chunked_list": ["package com.maximilianwiegmann.backend.account;\n\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\nimport com.maximilianwiegmann.backend.payload.response.PublicAccountResponse;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service", "\n@Service\n@RequiredArgsConstructor\npublic class AccountService {\n    private final AccountRepository repository;\n    private final NotificationHandler notificationHandler;\n\n    public int getStatus(String uId) {\n        return notificationHandler.getStatus(uId);\n    }\n\n    public List<AccountData> getAccounts(long from, long to) {\n        return repository.findByFromTo(from, to, \"timestamp\");\n    }\n\n    public List<PublicAccountResponse> findAll() {\n        return repository.findAllBy().map(account -> PublicAccountResponse.builder()\n                .uId(account.getId())\n                .username(account.getUsername())\n                .firstName(account.getFirstName())\n                .lastName(account.getLastName())\n                .email(account.getEmail())\n                .status(notificationHandler.getStatus(account.getId()))\n                .avatar(account.getAvatar())\n                .build()).toList();\n    }\n\n    public List<PublicAccountResponse> searchByUsername(String username) {\n        return repository.findAllByUsernameContains(username).map(account -> PublicAccountResponse.builder()\n                .uId(account.getId())\n                .username(account.getUsername())\n                .firstName(account.getFirstName())\n                .lastName(account.getLastName())\n                .email(account.getEmail())\n                .avatar(account.getAvatar())\n                .status(notificationHandler.getStatus(account.getId()))\n                .build()).toList();\n    }\n", "    public PublicAccountResponse findByUid(String uId) {\n        return repository.findById(uId).map(account -> PublicAccountResponse.builder()\n                .uId(account.getId())\n                .username(account.getUsername())\n                .firstName(account.getFirstName())\n                .lastName(account.getLastName())\n                .email(account.getEmail())\n                .avatar(account.getAvatar())\n                .status(notificationHandler.getStatus(account.getId()))\n                .build()).orElse(null);\n    }\n", "    public AccountData findByUsername(String username) {\n        return repository.findByUsername(username).orElse(null);\n    }\n\n    public void setTfaSecret(AccountData account, String tfaSecret) {\n        account.setTfaSecret(tfaSecret);\n        repository.save(account);\n    }\n\n    public PublicAccountResponse getUserByUsername(String username) {\n        return repository.findByUsername(username).map(account -> PublicAccountResponse.builder()\n                .uId(account.getId())\n                .username(account.getUsername())\n                .firstName(account.getFirstName())\n                .lastName(account.getLastName())\n                .email(account.getEmail())\n                .avatar(account.getAvatar())\n                .status(notificationHandler.getStatus(account.getId()))\n                .build()).orElse(null);\n    }\n}\n", "    public PublicAccountResponse getUserByUsername(String username) {\n        return repository.findByUsername(username).map(account -> PublicAccountResponse.builder()\n                .uId(account.getId())\n                .username(account.getUsername())\n                .firstName(account.getFirstName())\n                .lastName(account.getLastName())\n                .email(account.getEmail())\n                .avatar(account.getAvatar())\n                .status(notificationHandler.getStatus(account.getId()))\n                .build()).orElse(null);\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/AccountRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.account;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.mongodb.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.retry.stats.StatisticsRepository;\n\nimport com.maximilianwiegmann.backend.statistics.StatisticRepository;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n\npublic interface AccountRepository extends MongoRepository<AccountData, String>, StatisticRepository<AccountData> {\n\n    Stream<AccountData> findAllBy();\n\n    Optional<AccountData> findByUsername(String username);\n\n    Optional<AccountData> findByEmail(String email);\n\n    @Query(\"{ $or: [ { 'username': { $regex: '?0', $options: 'i' } }, { 'firstName': { $regex: '?0', $options: 'i' } } ] }\")\n    Stream<AccountData> findAllByUsernameContains(String username);\n\n    @Query(\"{ 'contactRequests' : { $elemMatch: { 'targetUId' : ?0 } } }\")\n    List<AccountData> findByContactRequest(String uId);\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/AccountController.java", "chunked_list": ["package com.maximilianwiegmann.backend.account;\n\nimport com.maximilianwiegmann.backend.account.contacts.ContactData;\nimport com.maximilianwiegmann.backend.account.contacts.ContactService;\nimport com.maximilianwiegmann.backend.payload.response.PublicAccountResponse;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.*;\n", "import org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/accounts\")\n@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RequiredArgsConstructor\npublic class AccountController {\n\n    private final AccountService service;\n    private final ContactService contactService;\n\n    @GetMapping\n    public ResponseEntity<PublicAccountResponse> getAccountData() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "public class AccountController {\n\n    private final AccountService service;\n    private final ContactService contactService;\n\n    @GetMapping\n    public ResponseEntity<PublicAccountResponse> getAccountData() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(service.findByUid(accountData.getId()));\n    }\n\n    @GetMapping(\"/{uId}\")\n    public ResponseEntity<PublicAccountResponse> getAccountData(@PathVariable String uId) {\n        return ResponseEntity.ok(service.findByUid(uId));\n    }\n\n    @GetMapping(\"/username/{username}\")\n    public ResponseEntity<PublicAccountResponse> getAccountDataByUsername(@PathVariable String username) {\n        return ResponseEntity.ok(service.getUserByUsername(username));\n    }\n\n    @GetMapping(\"/search/{username}\")\n    public ResponseEntity<List<PublicAccountResponse>> searchAccountDataByUsername(@PathVariable String username) {\n        return ResponseEntity.ok(service.searchByUsername(username));\n    }\n\n    @GetMapping(\"/all\")\n    public ResponseEntity<List<PublicAccountResponse>> getAllAccountData() {\n        return ResponseEntity.ok(service.findAll());\n    }\n\n    @GetMapping(\"/status/{id}\")\n    public ResponseEntity<Integer> getStatus(@PathVariable String id) {\n        return ResponseEntity.ok(service.getStatus(id));\n    }\n\n    @GetMapping(\"/contacts\")\n    public ResponseEntity<?> getContacts() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(service.findByUid(accountData.getId()));\n    }\n\n    @GetMapping(\"/{uId}\")\n    public ResponseEntity<PublicAccountResponse> getAccountData(@PathVariable String uId) {\n        return ResponseEntity.ok(service.findByUid(uId));\n    }\n\n    @GetMapping(\"/username/{username}\")\n    public ResponseEntity<PublicAccountResponse> getAccountDataByUsername(@PathVariable String username) {\n        return ResponseEntity.ok(service.getUserByUsername(username));\n    }\n\n    @GetMapping(\"/search/{username}\")\n    public ResponseEntity<List<PublicAccountResponse>> searchAccountDataByUsername(@PathVariable String username) {\n        return ResponseEntity.ok(service.searchByUsername(username));\n    }\n\n    @GetMapping(\"/all\")\n    public ResponseEntity<List<PublicAccountResponse>> getAllAccountData() {\n        return ResponseEntity.ok(service.findAll());\n    }\n\n    @GetMapping(\"/status/{id}\")\n    public ResponseEntity<Integer> getStatus(@PathVariable String id) {\n        return ResponseEntity.ok(service.getStatus(id));\n    }\n\n    @GetMapping(\"/contacts\")\n    public ResponseEntity<?> getContacts() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.getContacts(accountData));\n    }\n\n    @PostMapping(\"/contacts/request/{uId}\")\n    public ResponseEntity<?> sendRequest(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.sendRequest(accountData, uId));\n    }\n\n    @PostMapping(\"/contacts/accept/{uId}\")\n    public ResponseEntity<?> acceptRequest(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.sendRequest(accountData, uId));\n    }\n\n    @PostMapping(\"/contacts/accept/{uId}\")\n    public ResponseEntity<?> acceptRequest(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.acceptRequest(accountData, uId));\n    }\n\n    @GetMapping(\"/contacts/request/{rId}\")\n    public ResponseEntity<?> getRequest(@PathVariable String rId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.acceptRequest(accountData, uId));\n    }\n\n    @GetMapping(\"/contacts/request/{rId}\")\n    public ResponseEntity<?> getRequest(@PathVariable String rId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.status(403).build();\n\n        ContactData request = accountData.getContactRequests().stream().filter(req -> req.getId().equals(rId))\n                .findFirst().orElse(null);", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n\n        ContactData request = accountData.getContactRequests().stream().filter(req -> req.getId().equals(rId))\n                .findFirst().orElse(null);\n        if (request == null)\n            return ResponseEntity.status(403).build();\n\n        return ResponseEntity.ok(request);\n    }\n\n    @GetMapping(\"/contacts/requests\")\n    public ResponseEntity<?> getRequests() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.getRequests(accountData));\n    }\n\n    @PostMapping(\"/contacts/remove/{uId}\")\n    public ResponseEntity<?> removeContact(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        boolean remove = contactService.removeContact(accountData, uId);", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        boolean remove = contactService.removeContact(accountData, uId);\n        if (!remove)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(remove);\n    }\n\n    @PostMapping(\"/contacts/deny/{uId}\")\n    public ResponseEntity<?> denyRequest(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        boolean remove = contactService.denyRequest(accountData, uId);\n        if (!remove)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(remove);\n    }\n\n    @GetMapping(\"/contacts/requested\")\n    public ResponseEntity<?> getRequested() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();", "        if (accountData == null)\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.getRequested(accountData));\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/AccountData.java", "chunked_list": ["package com.maximilianwiegmann.backend.account;\n\nimport com.fasterxml.jackson.annotation.JsonBackReference;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonManagedReference;\nimport com.maximilianwiegmann.backend.account.contacts.ContactData;\nimport com.maximilianwiegmann.backend.account.signinwith.SigninWith;\nimport com.maximilianwiegmann.backend.notifications.Notification;\nimport com.maximilianwiegmann.backend.security.token.Token;\nimport lombok.*;", "import com.maximilianwiegmann.backend.security.token.Token;\nimport lombok.*;\nimport lombok.Builder.Default;\n\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.DBRef;\nimport org.springframework.data.mongodb.core.mapping.Document;\nimport org.springframework.security.access.method.P;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;", "import org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\n\n@Builder\n@Data\n@Getter\n@NoArgsConstructor", "@Getter\n@NoArgsConstructor\n@AllArgsConstructor\n@Document(collection = \"accounts\")\npublic class AccountData implements UserDetails {\n\n    @Id\n    private String id;\n\n    private String username;\n    private String firstName;\n    private String lastName;\n\n    private String password;\n    private String email;\n    private String avatar;\n\n    private String tfaSecret;\n\n    private List<ContactData> contacts;\n    private List<ContactData> contactRequests;\n\n    @Default\n    private long timestamp = System.currentTimeMillis();\n\n    @Default\n    private boolean enabled = true;\n\n    @DBRef(db = \"tokens\")\n    private List<Token> tokens;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override", "    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override", "    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return this.enabled;\n    }\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/contacts/ContactService.java", "chunked_list": ["package com.maximilianwiegmann.backend.account.contacts;\n\nimport java.util.List;\nimport java.util.UUID;\n\nimport org.springframework.stereotype.Service;\n\nimport com.maximilianwiegmann.backend.BackendApplication;\nimport com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountRepository;", "import com.maximilianwiegmann.backend.account.AccountData;\nimport com.maximilianwiegmann.backend.account.AccountRepository;\nimport com.maximilianwiegmann.backend.account.AccountService;\nimport com.maximilianwiegmann.backend.notifications.Notification;\nimport com.maximilianwiegmann.backend.notifications.NotificationHandler;\nimport com.maximilianwiegmann.backend.payload.response.PublicAccountResponse;\n\nimport lombok.RequiredArgsConstructor;\n\n@Service", "\n@Service\n@RequiredArgsConstructor\npublic class ContactService {\n\n    private final AccountRepository accountRepository;\n    private final NotificationHandler notificationHandler;\n\n    public List<ContactData> getContacts(AccountData account) {\n        return account.getContacts();\n    }\n\n    public List<ContactData> getRequests(AccountData account) {\n        return account.getContactRequests();\n    }\n\n    public List<PublicAccountResponse> getRequested(AccountData account) {\n        return accountRepository.findByContactRequest(account.getId()).stream()\n                .map(data -> PublicAccountResponse.builder()\n                        .username(data.getUsername()).firstName(data.getFirstName()).lastName(data.getLastName())\n                        .avatar(data.getAvatar()).status(notificationHandler.getStatus(data.getId())).build())\n                .toList();\n    }\n", "    public ContactData sendRequest(AccountData account, String targetUId) {\n        AccountData targetAccount = accountRepository.findById(targetUId).orElse(null);\n        if (targetAccount == null)\n            return null;\n        if (account.getContacts().stream().anyMatch(contact -> contact.getTargetUId().equals(targetUId)))\n            return null;\n\n        if (targetAccount.getContactRequests().stream()\n                .anyMatch(request -> request.getTargetUId().equals(account.getId())))\n            return null;\n        if (account.getContactRequests().stream().anyMatch(request -> request.getTargetUId().equals(targetUId)))\n            return acceptRequest(account, targetUId);\n\n        ContactData request = ContactData.builder().id(BackendApplication.generateString(20)).targetUId(account.getId())\n                .build();\n        targetAccount.getContactRequests().add(request);\n        accountRepository.save(targetAccount);\n\n        notificationHandler.notifyUser(targetUId, Notification.builder()\n                .title(\"You received a friend request\")\n                .body(account.getUsername() + \" want's to be your friend.\")\n                .link(\"https://maximilianwiegmann.com/contacts?request=\" + request.getId()).build());\n        return request;\n    }\n", "        if (account.getContactRequests().stream().anyMatch(request -> request.getTargetUId().equals(targetUId)))\n            return acceptRequest(account, targetUId);\n\n        ContactData request = ContactData.builder().id(BackendApplication.generateString(20)).targetUId(account.getId())\n                .build();\n        targetAccount.getContactRequests().add(request);\n        accountRepository.save(targetAccount);\n\n        notificationHandler.notifyUser(targetUId, Notification.builder()\n                .title(\"You received a friend request\")\n                .body(account.getUsername() + \" want's to be your friend.\")\n                .link(\"https://maximilianwiegmann.com/contacts?request=\" + request.getId()).build());\n        return request;\n    }\n", "    public ContactData acceptRequest(AccountData account, String targetUId) {\n        AccountData targetAccount = accountRepository.findById(targetUId).orElse(null);\n        if (targetAccount == null)\n            return null;\n        account.getContactRequests().removeIf(request -> request.getTargetUId().equals(targetUId));\n\n        ContactData newContact = ContactData.builder().targetUId(targetUId).build();\n        account.getContacts().add(newContact);\n        targetAccount.getContacts().add(ContactData.builder().targetUId(account.getId()).build());\n\n        accountRepository.save(account);\n        accountRepository.save(targetAccount);\n\n        notificationHandler.notifyUser(targetUId, Notification.builder()\n                .title(\"Friend request accepted\")\n                .body(account.getUsername() + \" has accepted your request.\").build());\n\n        return newContact;\n    }\n", "    public boolean denyRequest(AccountData account, String targetUId) {\n        AccountData targetAccount = accountRepository.findById(targetUId).orElse(null);\n        if (targetAccount == null)\n            return false;\n\n        if (account.getContactRequests().stream().noneMatch(contact -> contact.getTargetUId().equals(targetUId)))\n            return false;\n\n        account.getContactRequests().removeIf(contact -> contact.getTargetUId().equals(targetUId));\n        accountRepository.save(account);\n        return true;\n    }\n", "    public boolean removeContact(AccountData account, String targetUId) {\n        AccountData targetAccount = accountRepository.findById(targetUId).orElse(null);\n        if (targetAccount == null)\n            return false;\n\n        if (account.getContacts().stream().noneMatch(contact -> contact.getTargetUId().equals(targetUId)))\n            return false;\n\n        account.getContacts().removeIf(contact -> contact.getTargetUId().equals(targetUId));\n        targetAccount.getContacts().removeIf(contact -> contact.getTargetUId().equals(account.getId()));\n        accountRepository.save(account);\n        accountRepository.save(targetAccount);\n        return true;\n    }\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/contacts/ContactData.java", "chunked_list": ["package com.maximilianwiegmann.backend.account.contacts;\n\nimport org.springframework.data.mongodb.core.mapping.Document;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Builder.Default;", "import lombok.NoArgsConstructor;\nimport lombok.Builder.Default;\n\n@Data\n@Builder\n@Getter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ContactData {\n    \n    private String id;\n    private String targetUId;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n\n}\n", "public class ContactData {\n    \n    private String id;\n    private String targetUId;\n    @Default\n    private long timestamp = System.currentTimeMillis();\n\n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/signinwith/SigninWith.java", "chunked_list": ["package com.maximilianwiegmann.backend.account.signinwith;\n\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.DBRef;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\nimport com.fasterxml.jackson.annotation.JsonBackReference;\nimport com.maximilianwiegmann.backend.account.AccountData;\n\nimport lombok.AllArgsConstructor;", "\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Data\n@Builder", "@Data\n@Builder\n@NoArgsConstructor\n@Getter\n@Setter\n@AllArgsConstructor\n@Document(collection = \"signinwith\")\npublic class SigninWith {\n\n    @Id\n    private String id;\n\n    private String provider;\n    private String providerId;\n\n    private String uId;\n    \n}\n"]}
{"filename": "backend/src/main/java/com/maximilianwiegmann/backend/account/signinwith/SigninWithRepository.java", "chunked_list": ["package com.maximilianwiegmann.backend.account.signinwith;\n\nimport java.util.Optional;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\npublic interface SigninWithRepository extends MongoRepository<SigninWith, String> {\n\n    Optional<SigninWith> findByProviderAndProviderId(String provider, String providerId);\n\n}\n\n"]}
