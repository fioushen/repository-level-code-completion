{"filename": "src/main/java/committee/nova/flotage/FlotageClient.java", "chunked_list": ["package committee.nova.flotage;\n\nimport committee.nova.flotage.client.RackRenderer;\nimport committee.nova.flotage.init.TileRegistry;\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.fabricmc.fabric.api.client.rendering.v1.BlockEntityRendererRegistry;\n\n@Environment(EnvType.CLIENT)\npublic class FlotageClient implements ClientModInitializer {\n\n    @Override", "\n@Environment(EnvType.CLIENT)\npublic class FlotageClient implements ClientModInitializer {\n\n    @Override\n    public void onInitializeClient() {\n        BlockEntityRendererRegistry.register(TileRegistry.RACK_BLOCK_ENTITY, RackRenderer::new);\n\n        Flotage. LOGGER.info(\"Flotage Client setup done!\");\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/FlotageDataGen.java", "chunked_list": ["package committee.nova.flotage;\n\nimport committee.nova.flotage.datagen.*;\nimport net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;\n\npublic class FlotageDataGen implements DataGeneratorEntrypoint {\n    @Override\n    public void onInitializeDataGenerator(FabricDataGenerator generator) {\n        generator.createPack().addProvider(FloModelProvider::new);\n        generator.createPack().addProvider(FloBlockLootProvider::new);\n        generator.createPack().addProvider(FloLangProvider.English::new);\n        generator.createPack().addProvider(FloLangProvider.Chinese::new);\n        generator.createPack().addProvider(FloBlockTagProvider::new);\n\n        Flotage.LOGGER.info(\"Flotage dataGen done!\");\n    }\n}\n", "    public void onInitializeDataGenerator(FabricDataGenerator generator) {\n        generator.createPack().addProvider(FloModelProvider::new);\n        generator.createPack().addProvider(FloBlockLootProvider::new);\n        generator.createPack().addProvider(FloLangProvider.English::new);\n        generator.createPack().addProvider(FloLangProvider.Chinese::new);\n        generator.createPack().addProvider(FloBlockTagProvider::new);\n\n        Flotage.LOGGER.info(\"Flotage dataGen done!\");\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/Flotage.java", "chunked_list": ["package committee.nova.flotage;\n\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport committee.nova.flotage.init.*;\nimport net.fabricmc.api.ModInitializer;\nimport net.fabricmc.fabric.api.transfer.v1.item.ItemStorage;\nimport net.minecraft.util.Identifier;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Flotage implements ModInitializer {", "import org.slf4j.LoggerFactory;\n\npublic class Flotage implements ModInitializer {\n    public static final String MOD_NAME = \"Flotage\";\n    public static final String MOD_ID = \"flotage\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_NAME);\n\n    @Override\n    public void onInitialize() {\n\n        TabRegistry.register();\n        RecipeRegistry.register();\n        BlockRegistry.register();\n        TileRegistry.register();\n        ItemRegistry.register();\n\n        ItemStorage.SIDED.registerForBlockEntity(RackBlockEntity::getExposedStorage, TileRegistry.RACK_BLOCK_ENTITY);\n\n        LOGGER.info(\"Flotage setup done!\");\n    }\n", "    public void onInitialize() {\n\n        TabRegistry.register();\n        RecipeRegistry.register();\n        BlockRegistry.register();\n        TileRegistry.register();\n        ItemRegistry.register();\n\n        ItemStorage.SIDED.registerForBlockEntity(RackBlockEntity::getExposedStorage, TileRegistry.RACK_BLOCK_ENTITY);\n\n        LOGGER.info(\"Flotage setup done!\");\n    }\n", "    public static Identifier id(String path) {\n        return new Identifier(MOD_ID, path);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/init/RecipeRegistry.java", "chunked_list": ["package committee.nova.flotage.init;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.impl.recipe.RackRecipeSerializer;\nimport committee.nova.flotage.impl.recipe.RackRecipeType;\nimport net.minecraft.recipe.RecipeSerializer;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;\n", "import net.minecraft.registry.Registry;\n\n\npublic class RecipeRegistry {\n    public static void register() {\n        recipe(RackRecipeSerializer.INSTANCE, RackRecipeType.INSTANCE, \"rack\");\n    }\n\n    private static void recipe(RecipeSerializer<?> serializer, RecipeType<?> type, String id) {\n        Registry.register(Registries.RECIPE_TYPE, Flotage.id(id), type);\n        Registry.register(Registries.RECIPE_SERIALIZER, Flotage.id(id), serializer);\n    }\n", "    public static RecipeType<?> getType(String id) {\n        return Registries.RECIPE_TYPE.get(Flotage.id(id));\n    }\n\n    public static RecipeSerializer<?> getSerializer(String id) {\n        return Registries.RECIPE_SERIALIZER.get(Flotage.id(id));\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/init/BlockRegistry.java", "chunked_list": ["package committee.nova.flotage.init;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.impl.block.*;\nimport committee.nova.flotage.util.BlockMember;\nimport net.minecraft.block.AbstractBlock;\nimport net.minecraft.block.Block;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;\n", "import net.minecraft.registry.Registry;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class BlockRegistry {\n    public static void register() {\n        for (BlockMember member : BlockMember.values()) {\n            woodenRaft(member);\n            brokenRaft(member);\n            fence(member);\n            crossedFence(member);\n            rack(member);\n        }\n    }\n\n    private static void woodenRaft(BlockMember member) {\n        block(member.raft(), new WoodenRaftBlock(member));\n    }\n\n    private static void brokenRaft(BlockMember member) {\n        block(member.brokenRaft(), new BrokenRaftBlock(member));\n    }\n\n    private static void fence(BlockMember member) {\n        block(member.fence(), new SimpleFenceBlock(member));\n    }\n\n    private static void crossedFence(BlockMember member) {\n        block(member.crossedFence(), new CrossedFenceBlock(member));\n    }\n\n    private static void rack(BlockMember member) {\n        block(member.rack(), new RackBlock(member));\n    }\n\n    private static void block(String id, Block block) {\n        Registry.register(Registries.BLOCK, Flotage.id(id), block);\n    }\n\n    private static void block(String id, AbstractBlock.Settings settings) {\n        block(id, new Block(settings));\n    }\n", "    public static Block get(String id) {\n        return Registries.BLOCK.get(Flotage.id(id));\n    }\n\n    public static Block[] getRacks() {\n        ArrayList<Block> list = new ArrayList<>();\n        Arrays.stream(BlockMember.values()).forEach(member -> list.add(get(member.rack())));\n        return list.toArray(new Block[0]);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/init/TileRegistry.java", "chunked_list": ["package committee.nova.flotage.init;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;\nimport net.minecraft.block.entity.BlockEntityType;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;\n\npublic class TileRegistry {\n    public static final BlockEntityType<RackBlockEntity> RACK_BLOCK_ENTITY =\n            FabricBlockEntityTypeBuilder.create(RackBlockEntity::new, BlockRegistry.getRacks()).build();\n", "\npublic class TileRegistry {\n    public static final BlockEntityType<RackBlockEntity> RACK_BLOCK_ENTITY =\n            FabricBlockEntityTypeBuilder.create(RackBlockEntity::new, BlockRegistry.getRacks()).build();\n\n    public static void register() {\n        tile(RACK_BLOCK_ENTITY, \"rack\");\n    }\n\n    private static void tile(BlockEntityType<?> tile, String id) {\n        Registry.register(Registries.BLOCK_ENTITY_TYPE, Flotage.id(id), tile);\n    }\n", "    public static BlockEntityType<?> get(String id) {\n        return Registries.BLOCK_ENTITY_TYPE.get(Flotage.id(id));\n    }\n\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/init/ItemRegistry.java", "chunked_list": ["package committee.nova.flotage.init;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.impl.item.RaftItem;\nimport committee.nova.flotage.util.BlockMember;\nimport net.fabricmc.fabric.api.item.v1.FabricItemSettings;\nimport net.minecraft.item.BlockItem;\nimport net.minecraft.item.Item;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;", "import net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;\n\n\npublic class ItemRegistry {\n    public static void register() {\n        for (BlockMember member : BlockMember.values()) {\n            raftItem(member.raft(), settings());\n            raftItem(member.brokenRaft(), settings());\n            blockItem(member.fence(), settings());\n            blockItem(member.crossedFence(), settings());\n            blockItem(member.rack(), settings());\n        }\n    }\n\n    private static void blockItem(String id, Item.Settings settings) {\n        item(id, new BlockItem(Registries.BLOCK.get(Flotage.id(id)), settings));\n    }\n\n    private static void raftItem(String id, Item.Settings settings) {\n        item(id, new RaftItem(Registries.BLOCK.get(Flotage.id(id)), settings));\n    }\n\n    private static void item(String id, Item item) {\n        Registry.register(Registries.ITEM, Flotage.id(id), item);\n    }\n", "    public static Item.Settings settings() {\n        return new FabricItemSettings();\n    }\n\n    public static Item get(String id) {\n        return Registries.ITEM.get(Flotage.id(id));\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/init/TabRegistry.java", "chunked_list": ["package committee.nova.flotage.init;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.util.BlockMember;\nimport net.fabricmc.fabric.api.itemgroup.v1.FabricItemGroup;\nimport net.minecraft.item.ItemGroup;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.Registry;\nimport net.minecraft.text.Text;", "import net.minecraft.registry.Registry;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Identifier;\n\npublic class TabRegistry {\n    public static final Identifier TEXTURE = new Identifier(\"textures/gui/container/creative_inventory/flotage.png\");\n    public static ItemGroup TAB;\n\n    public static void register() {\n        TAB = Registry.register(Registries.ITEM_GROUP, Flotage.id(\"tab\"),\n                FabricItemGroup.builder()\n                        .displayName(Text.translatable(\"itemGroup.flotage.tab\"))\n                        .entries(((displayContext, entries) -> {", "    public static void register() {\n        TAB = Registry.register(Registries.ITEM_GROUP, Flotage.id(\"tab\"),\n                FabricItemGroup.builder()\n                        .displayName(Text.translatable(\"itemGroup.flotage.tab\"))\n                        .entries(((displayContext, entries) -> {\n                            for (BlockMember member : BlockMember.values()) {\n                                entries.add(new ItemStack(ItemRegistry.get(member.raft())));\n                                entries.add(new ItemStack(ItemRegistry.get(member.brokenRaft())));\n                                entries.add(new ItemStack(ItemRegistry.get(member.fence())));\n                                entries.add(new ItemStack(ItemRegistry.get(member.crossedFence())));\n                                entries.add(new ItemStack(ItemRegistry.get(member.rack())));\n                            }\n                        }))\n                        .icon(() -> new ItemStack(ItemRegistry.get(BlockMember.OAK.rack())))\n                        .texture(\"flotage.png\")\n                        .noRenderedName()\n                        .noScrollbar()\n                        .build());\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/rei/FlotageREIPlugin.java", "chunked_list": ["package committee.nova.flotage.compat.rei;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.compat.rei.category.RackREICategory;\nimport committee.nova.flotage.compat.rei.display.RackREIDisplay;\nimport committee.nova.flotage.impl.recipe.RackRecipe;\nimport committee.nova.flotage.impl.recipe.RackRecipeType;\nimport committee.nova.flotage.init.BlockRegistry;\nimport me.shedaniel.rei.api.client.plugins.REIClientPlugin;\nimport me.shedaniel.rei.api.client.registry.category.CategoryRegistry;", "import me.shedaniel.rei.api.client.plugins.REIClientPlugin;\nimport me.shedaniel.rei.api.client.registry.category.CategoryRegistry;\nimport me.shedaniel.rei.api.client.registry.display.DisplayRegistry;\nimport me.shedaniel.rei.api.common.category.CategoryIdentifier;\nimport me.shedaniel.rei.api.common.entry.EntryStack;\nimport me.shedaniel.rei.api.common.util.EntryStacks;\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n@Environment(EnvType.CLIENT)\npublic class FlotageREIPlugin implements REIClientPlugin {\n    public static final CategoryIdentifier<RackREIDisplay> RACK_DISPLAY_CATEGORY = CategoryIdentifier.of(Flotage.MOD_ID, \"plugins/rack\");\n\n    @Override\n    public void registerCategories(CategoryRegistry registry) {\n        registry.add(new RackREICategory());\n        List<EntryStack<?>> list = new ArrayList<>();\n        Arrays.stream(BlockRegistry.getRacks()).toList().forEach((block -> list.add(EntryStacks.of(block))));\n        registry.addWorkstations(RACK_DISPLAY_CATEGORY, list.toArray(new EntryStack<?>[0]));\n    }\n\n    @Override", "    public void registerCategories(CategoryRegistry registry) {\n        registry.add(new RackREICategory());\n        List<EntryStack<?>> list = new ArrayList<>();\n        Arrays.stream(BlockRegistry.getRacks()).toList().forEach((block -> list.add(EntryStacks.of(block))));\n        registry.addWorkstations(RACK_DISPLAY_CATEGORY, list.toArray(new EntryStack<?>[0]));\n    }\n\n    @Override\n    public void registerDisplays(DisplayRegistry registry) {\n        registry.registerRecipeFiller(RackRecipe.class, RackRecipeType.INSTANCE, RackREIDisplay::new);\n    }\n}\n", "    public void registerDisplays(DisplayRegistry registry) {\n        registry.registerRecipeFiller(RackRecipe.class, RackRecipeType.INSTANCE, RackREIDisplay::new);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/rei/display/RackREIDisplay.java", "chunked_list": ["package committee.nova.flotage.compat.rei.display;\n\nimport committee.nova.flotage.compat.rei.FlotageREIPlugin;\nimport committee.nova.flotage.impl.recipe.RackRecipe;\nimport committee.nova.flotage.util.WorkingMode;\nimport me.shedaniel.rei.api.common.category.CategoryIdentifier;\nimport me.shedaniel.rei.api.common.display.basic.BasicDisplay;\nimport me.shedaniel.rei.api.common.util.EntryIngredients;\n\nimport java.util.Collections;", "\nimport java.util.Collections;\n\npublic class RackREIDisplay extends BasicDisplay {\n    private final int processtime;\n    private final WorkingMode mode;\n\n    public RackREIDisplay(RackRecipe recipe) {\n        super(EntryIngredients.ofIngredients(recipe.getIngredients()), Collections.singletonList(EntryIngredients.of(recipe.getResult())));\n        this.processtime = recipe.getProcesstime();\n        this.mode = recipe.getMode();\n    }\n\n    @Override\n    public CategoryIdentifier<?> getCategoryIdentifier() {\n        return FlotageREIPlugin.RACK_DISPLAY_CATEGORY;\n    }\n\n", "    public int getProcesstime() {\n        return processtime;\n    }\n\n    public WorkingMode getMode() {\n        return mode;\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/rei/category/RackREICategory.java", "chunked_list": ["package committee.nova.flotage.compat.rei.category;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.compat.rei.FlotageREIPlugin;\nimport committee.nova.flotage.compat.rei.display.RackREIDisplay;\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.BlockRegistry;\nimport me.shedaniel.math.Point;\nimport me.shedaniel.math.Rectangle;\nimport me.shedaniel.rei.api.client.gui.Renderer;", "import me.shedaniel.math.Rectangle;\nimport me.shedaniel.rei.api.client.gui.Renderer;\nimport me.shedaniel.rei.api.client.gui.widgets.Arrow;\nimport me.shedaniel.rei.api.client.gui.widgets.Widget;\nimport me.shedaniel.rei.api.client.gui.widgets.Widgets;\nimport me.shedaniel.rei.api.client.registry.display.DisplayCategory;\nimport me.shedaniel.rei.api.common.category.CategoryIdentifier;\nimport me.shedaniel.rei.api.common.util.EntryStacks;\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;", "import net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Identifier;\nimport org.jetbrains.annotations.ApiStatus;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Environment(EnvType.CLIENT)", "\n@Environment(EnvType.CLIENT)\n@ApiStatus.Internal\npublic class RackREICategory implements DisplayCategory<RackREIDisplay> {\n    private static final Identifier GUI_TEXTURE = Flotage.id(\"textures/gui/rack_rei.png\");\n\n    @Override\n    public CategoryIdentifier<? extends RackREIDisplay> getCategoryIdentifier() {\n        return FlotageREIPlugin.RACK_DISPLAY_CATEGORY;\n    }\n\n    @Override", "    public Text getTitle() {\n        return Text.translatable(\"block.flotage.rack\");\n    }\n\n    @Override\n    public Renderer getIcon() {\n        return EntryStacks.of(BlockRegistry.get(BlockMember.OAK.rack()));\n    }\n\n    @Override\n    public List<Widget> setupDisplay(RackREIDisplay display, Rectangle bounds) {\n        Point origin = bounds.getLocation();\n        final List<Widget> widgets = new ArrayList<>();\n\n        widgets.add(Widgets.createRecipeBase(bounds));\n\n        Rectangle bgBounds = centeredIntoRecipeBase(new Point(origin.x, origin.y), 91, 54);\n        widgets.add(Widgets.createTexturedWidget(GUI_TEXTURE, new Rectangle(bgBounds.x, bgBounds.y, 91, 54), 10, 9));\n\n        widgets.add(Widgets.createSlot(new Point(bgBounds.x + 7, bgBounds.y + 1))\n                .entries(display.getInputEntries().get(0)).markInput().disableBackground());\n\n        Arrow arrow = Widgets.createArrow(new Point(bgBounds.x + 39, bgBounds.y + 18)).animationDurationTicks(20);\n        widgets.add(arrow);\n\n        Text text = Text.translatable(\"tip.flotage.rack.mode\").append(Text.translatable(\"tip.flotage.rack.mode.\" + display.getMode().toString()));\n        widgets.add(Widgets.withTooltip(arrow, Text.translatable(\"tip.flotage.rack.processtime\", display.getProcesstime() / 20), text));\n\n        widgets.add(Widgets.createSlot(new Point(bgBounds.x + 74, bgBounds.y + 18))\n                .entries(display.getOutputEntries().get(0)).markOutput().disableBackground());\n\n        return widgets;\n    }\n", "    public static Rectangle centeredIntoRecipeBase(Point origin, int width, int height) {\n        return centeredInto(new Rectangle(origin.x, origin.y, 150, 74), width, height);\n    }\n\n    public static Rectangle centeredInto(Rectangle origin, int width, int height) {\n        return new Rectangle(origin.x + (origin.width - width) / 2, origin.y + (origin.height - height) / 2, width, height);\n    }\n\n    @Override\n    public int getDisplayHeight() {\n        return 73;\n    }\n}\n", "    public int getDisplayHeight() {\n        return 73;\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/emi/FlotageEMIPlugin.java", "chunked_list": ["package committee.nova.flotage.compat.emi;\n\nimport committee.nova.flotage.compat.emi.recipe.RackEMIRecipe;\nimport committee.nova.flotage.impl.recipe.RackRecipe;\nimport committee.nova.flotage.impl.recipe.RackRecipeType;\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.BlockRegistry;\nimport dev.emi.emi.api.EmiPlugin;\nimport dev.emi.emi.api.EmiRegistry;\nimport dev.emi.emi.api.recipe.EmiRecipeCategory;", "import dev.emi.emi.api.EmiRegistry;\nimport dev.emi.emi.api.recipe.EmiRecipeCategory;\nimport dev.emi.emi.api.render.EmiTexture;\nimport dev.emi.emi.api.stack.EmiIngredient;\nimport dev.emi.emi.api.stack.EmiStack;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.util.Identifier;\n\nimport static committee.nova.flotage.Flotage.id;", "\nimport static committee.nova.flotage.Flotage.id;\n\npublic class FlotageEMIPlugin implements EmiPlugin {\n    public static final Identifier RACK_TEXTURE = id(\"textures/gui/emi_widgets.png\");\n    public static final EmiStack RACK_WORKSTATION = EmiStack.of(BlockRegistry.get(BlockMember.OAK.rack()));\n    public static final EmiRecipeCategory RACK_CATEGORY\n            = new EmiRecipeCategory(id(\"rack\"), RACK_WORKSTATION, new EmiTexture(RACK_TEXTURE, 0, 0, 16, 16));\n\n    @Override\n    public void register(EmiRegistry registry) {\n        registry.addCategory(RACK_CATEGORY);\n\n        registry.addWorkstation(RACK_CATEGORY, EmiIngredient.of(Ingredient.ofItems(BlockRegistry.getRacks())));\n\n        RecipeManager manager = registry.getRecipeManager();\n", "    public void register(EmiRegistry registry) {\n        registry.addCategory(RACK_CATEGORY);\n\n        registry.addWorkstation(RACK_CATEGORY, EmiIngredient.of(Ingredient.ofItems(BlockRegistry.getRacks())));\n\n        RecipeManager manager = registry.getRecipeManager();\n\n        for (RackRecipe recipe : manager.listAllOfType(RackRecipeType.INSTANCE)) {\n            registry.addRecipe(new RackEMIRecipe(recipe));\n        }\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/emi/recipe/RackEMIRecipe.java", "chunked_list": ["package committee.nova.flotage.compat.emi.recipe;\n\nimport committee.nova.flotage.compat.emi.FlotageEMIPlugin;\nimport committee.nova.flotage.impl.recipe.RackRecipe;\nimport dev.emi.emi.api.recipe.EmiRecipe;\nimport dev.emi.emi.api.recipe.EmiRecipeCategory;\nimport dev.emi.emi.api.stack.EmiIngredient;\nimport dev.emi.emi.api.stack.EmiStack;\nimport dev.emi.emi.api.widget.WidgetHolder;\nimport net.minecraft.util.Identifier;", "import dev.emi.emi.api.widget.WidgetHolder;\nimport net.minecraft.util.Identifier;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.List;\n\npublic class RackEMIRecipe implements EmiRecipe {\n\n    private final Identifier id;\n    private final List<EmiIngredient> input;\n    private final List<EmiStack> output;\n\n    public RackEMIRecipe(RackRecipe recipe) {\n        this.id = recipe.getId();\n        this.input = List.of(EmiIngredient.of(recipe.getIngredients().get(0)));\n        this.output = List.of(EmiStack.of(recipe.getResult()));\n    }\n\n    @Override", "    public EmiRecipeCategory getCategory() {\n        return FlotageEMIPlugin.RACK_CATEGORY;\n    }\n\n    @Override\n    public @Nullable Identifier getId() {\n        return id;\n    }\n\n    @Override\n    public List<EmiIngredient> getInputs() {\n        return input;\n    }\n\n    @Override\n    public List<EmiStack> getOutputs() {\n        return output;\n    }\n\n    @Override", "    public int getDisplayWidth() {\n        return 110;\n    }\n\n    @Override\n    public int getDisplayHeight() {\n        return 40;\n    }\n\n    @Override\n    public void addWidgets(WidgetHolder widgets) {\n        widgets.addSlot(input.get(0), 15, 10);\n        widgets.addSlot(output.get(0), 79, 10).recipeContext(this);\n\n        widgets.addFillingArrow(46, 10, 20 * 20);\n    }\n}\n", "    public void addWidgets(WidgetHolder widgets) {\n        widgets.addSlot(input.get(0), 15, 10);\n        widgets.addSlot(output.get(0), 79, 10).recipeContext(this);\n\n        widgets.addFillingArrow(46, 10, 20 * 20);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/jade/FlotageJadePlugin.java", "chunked_list": ["package committee.nova.flotage.compat.jade;\n\nimport committee.nova.flotage.compat.jade.provider.RackBlockTipProvider;\nimport committee.nova.flotage.impl.block.RackBlock;\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport snownee.jade.api.IWailaClientRegistration;\nimport snownee.jade.api.IWailaCommonRegistration;\nimport snownee.jade.api.IWailaPlugin;\nimport snownee.jade.api.WailaPlugin;\n", "import snownee.jade.api.WailaPlugin;\n\n@WailaPlugin\npublic class FlotageJadePlugin implements IWailaPlugin {\n\n    @Override\n    public void registerClient(IWailaClientRegistration registration) {\n        registration.registerBlockComponent(RackBlockTipProvider.INSTANCE, RackBlock.class);\n    }\n\n    @Override", "    public void register(IWailaCommonRegistration registration) {\n        registration.registerBlockDataProvider(RackBlockTipProvider.INSTANCE, RackBlockEntity.class);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/compat/jade/provider/RackBlockTipProvider.java", "chunked_list": ["package committee.nova.flotage.compat.jade.provider;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.util.WorkingMode;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.text.MutableText;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Identifier;\nimport snownee.jade.api.BlockAccessor;\nimport snownee.jade.api.IBlockComponentProvider;", "import snownee.jade.api.BlockAccessor;\nimport snownee.jade.api.IBlockComponentProvider;\nimport snownee.jade.api.IServerDataProvider;\nimport snownee.jade.api.ITooltip;\nimport snownee.jade.api.config.IPluginConfig;\n\npublic class RackBlockTipProvider implements IBlockComponentProvider, IServerDataProvider<BlockAccessor> {\n    public static final RackBlockTipProvider INSTANCE = new RackBlockTipProvider();\n\n    private RackBlockTipProvider() {}\n\n    @Override", "    public void appendTooltip(ITooltip tooltip, BlockAccessor accessor, IPluginConfig iPluginConfig) {\n        if (accessor.getServerData().contains(\"WorkingMode\")) {\n            WorkingMode mode = WorkingMode.match(accessor.getServerData().getString(\"WorkingMode\"));\n            MutableText text = Text.translatable(\"tip.flotage.rack.mode\").append(Text.translatable(\"tip.flotage.rack.mode.\" + mode.toString()));\n            tooltip.add(text);\n        }\n    }\n\n    @Override\n    public Identifier getUid() {\n        return Flotage.id(\"rack_blockentity\");\n    }\n\n    @Override", "    public Identifier getUid() {\n        return Flotage.id(\"rack_blockentity\");\n    }\n\n    @Override\n    public void appendServerData(NbtCompound nbt, BlockAccessor blockAccessor) {\n        nbt.putString(\"WorkingMode\", WorkingMode.judge(blockAccessor.getLevel(), blockAccessor.getPosition()).toString());\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/util/WorkingMode.java", "chunked_list": ["package committee.nova.flotage.util;\n\nimport net.minecraft.block.Blocks;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.Heightmap;\nimport net.minecraft.world.World;\nimport net.minecraft.world.biome.Biome;\n\npublic enum WorkingMode {\n    UNCONDITIONAL(\"unconditional\"),\n    SUN(\"sun\"),\n    NIGHT(\"night\"),\n    RAIN(\"rain\"),\n    SNOW(\"snow\"),\n    RAIN_AT(\"rain_at\"),\n    SNOW_AT(\"snow_at\"),\n    SMOKE(\"smoke\");\n    private final String type;\n    WorkingMode(String type) {\n        this.type = type;\n    }\n", "public enum WorkingMode {\n    UNCONDITIONAL(\"unconditional\"),\n    SUN(\"sun\"),\n    NIGHT(\"night\"),\n    RAIN(\"rain\"),\n    SNOW(\"snow\"),\n    RAIN_AT(\"rain_at\"),\n    SNOW_AT(\"snow_at\"),\n    SMOKE(\"smoke\");\n    private final String type;\n    WorkingMode(String type) {\n        this.type = type;\n    }\n", "    public static WorkingMode judge(World world, BlockPos pos) {\n        Biome biome = world.getBiome(pos).value();\n        if (hasSnow(world, pos)) {\n            return SNOW_AT;\n        } else if (world.hasRain(pos.up())) {\n            return RAIN_AT;\n        } else if (world.getBlockState(pos.down()).isOf(Blocks.CAMPFIRE)) {\n            return SMOKE;\n        } else if (world.isRaining()) {\n            if (biome.getPrecipitation(pos) == Biome.Precipitation.SNOW && !biome.doesNotSnow(pos))\n                return SNOW;\n            else\n                return RAIN;\n        }", "        } else if (world.isRaining()) {\n            if (biome.getPrecipitation(pos) == Biome.Precipitation.SNOW && !biome.doesNotSnow(pos))\n                return SNOW;\n            else\n                return RAIN;\n        }\n        if (world.isDay()) {\n            return SUN;\n        }else if (world.isNight()) {\n            return NIGHT;\n        }\n        return UNCONDITIONAL;\n    }\n", "        }else if (world.isNight()) {\n            return NIGHT;\n        }\n        return UNCONDITIONAL;\n    }\n\n    public static boolean hasSnow(World world, BlockPos pos) {\n        if (!world.isRaining()) {\n            return false;\n        }\n        if (!world.isSkyVisible(pos)) {\n            return false;\n        }", "        if (!world.isSkyVisible(pos)) {\n            return false;\n        }\n        if (world.getTopPosition(Heightmap.Type.MOTION_BLOCKING, pos).getY() > pos.getY()) {\n            return false;\n        }\n        Biome biome = world.getBiome(pos).value();\n        return biome.getPrecipitation(pos) == Biome.Precipitation.SNOW && !biome.doesNotSnow(pos);\n    }\n\n    @Override", "    public String toString() {\n        return type;\n    }\n\n    public static WorkingMode match(String s) {\n        for (WorkingMode mode : values()) {\n            if (mode.toString().equals(s))\n                return mode;\n        }\n        return WorkingMode.UNCONDITIONAL;\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/util/BlockMember.java", "chunked_list": ["package committee.nova.flotage.util;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.block.Blocks;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.util.Identifier;\n\npublic enum BlockMember {\n    OAK(Blocks.OAK_LOG, \"\u6a61\u6728\"),\n    SPRUCE(Blocks.SPRUCE_LOG, \"\u4e91\u6749\u6728\"),\n    BIRCH(Blocks.BIRCH_LOG, \"\u767d\u6866\u6728\"),\n    JUNGLE(Blocks.JUNGLE_LOG, \"\u4e1b\u6797\u6728\"),\n    ACACIA(Blocks.ACACIA_LOG, \"\u91d1\u5408\u6b22\u6728\"),\n    DARK_OAK(Blocks.DARK_OAK_LOG, \"\u6df1\u8272\u6a61\u6728\"),\n    CRIMSON(Blocks.CRIMSON_STEM, \"\u7eef\u7ea2\u6728\"),\n    WARPED(Blocks.WARPED_STEM, \"\u8be1\u5f02\u6728\");\n", "    public final Block repairBlock;\n    public final String chinese;\n    BlockMember(Block repairBlock, String chinese) {\n        this.repairBlock = repairBlock;\n        this.chinese = chinese;\n    }\n\n    public String rack() {\n        return name().toLowerCase() + \"_rack\";\n    }\n", "    public String fence() {\n        return name().toLowerCase() + \"_fence\";\n    }\n\n    public String crossedFence() {\n        return name().toLowerCase() + \"_crossed_fence\";\n    }\n\n    public Identifier log() {\n        return Registries.BLOCK.getId(repairBlock);\n    }\n", "    public Identifier log() {\n        return Registries.BLOCK.getId(repairBlock);\n    }\n\n    public String raft() {\n        return name().toLowerCase() + \"_raft\";\n    }\n\n    public String brokenRaft() {\n        return \"broken_\" + name().toLowerCase() + \"_raft\";\n    }\n}\n", "    public String brokenRaft() {\n        return \"broken_\" + name().toLowerCase() + \"_raft\";\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/client/RackRenderer.java", "chunked_list": ["package committee.nova.flotage.client;\n\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.render.VertexConsumerProvider;\nimport net.minecraft.client.render.block.entity.BlockEntityRenderer;\nimport net.minecraft.client.render.block.entity.BlockEntityRendererFactory;\nimport net.minecraft.client.render.item.ItemRenderer;\nimport net.minecraft.client.render.model.json.ModelTransformationMode;\nimport net.minecraft.client.util.math.MatrixStack;", "import net.minecraft.client.render.model.json.ModelTransformationMode;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.math.Direction;\nimport org.joml.Quaternionf;\n\npublic class RackRenderer implements BlockEntityRenderer<RackBlockEntity> {\n\n    public RackRenderer(BlockEntityRendererFactory.Context ctx) {}\n\n    @Override", "    public void render(RackBlockEntity tile, float tickDelta, MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light, int overlay) {\n        ItemStack stack = tile.getStack(0);\n        Direction direction = tile.getItemDirection();\n        int iPos = (int) tile.getPos().asLong();\n\n        if (!stack.isEmpty()) {\n            matrices.push();\n\n            ItemRenderer itemRenderer = MinecraftClient.getInstance().getItemRenderer();\n            boolean blockItem = itemRenderer.getModel(stack, tile.getWorld(), null, iPos).hasDepth();\n", "            if (blockItem) {\n                renderBlock(matrices, direction);\n            } else {\n                renderItemLayingDown(matrices, direction);\n            }\n\n            MinecraftClient.getInstance().getItemRenderer().renderItem(stack, ModelTransformationMode.FIXED, light, overlay, matrices, vertexConsumers, tile.getWorld(), iPos);\n            matrices.pop();\n        }\n    }\n\n    private void renderItemLayingDown(MatrixStack matrixStackIn, Direction direction) {\n        matrixStackIn.translate(0.5d, 1d, 0.5d);\n\n        matrixStackIn.multiply(direction.getRotationQuaternion());\n\n\n        matrixStackIn.scale(0.6f, 0.6f, 0.6f);\n    }\n\n    private void renderBlock(MatrixStack matrixStackIn, Direction direction) {\n        matrixStackIn.translate(0.5d, 1.15d, .5d);\n\n        matrixStackIn.multiply(direction.getRotationQuaternion());\n        matrixStackIn.multiply(new Quaternionf().rotationX((float) -(Math.PI * 0.5f)));\n\n        matrixStackIn.scale(0.8f, 0.8f, 0.8f);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/datagen/FloBlockTagProvider.java", "chunked_list": ["package committee.nova.flotage.datagen;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;\nimport net.fabricmc.fabric.api.datagen.v1.provider.FabricTagProvider;\nimport net.minecraft.block.Block;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.registry.RegistryWrapper;", "import net.minecraft.registry.Registries;\nimport net.minecraft.registry.RegistryWrapper;\nimport net.minecraft.registry.tag.TagKey;\nimport net.minecraft.util.Identifier;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class FloBlockTagProvider extends FabricTagProvider.BlockTagProvider {\n    public FloBlockTagProvider(FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) {\n        super(output, registriesFuture);\n    }\n\n    @Override\n    protected void configure(RegistryWrapper.WrapperLookup arg) {\n        FabricTagProvider<Block>.FabricTagBuilder pickaxe = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), new Identifier(\"mineable/pickaxe\")));\n        FabricTagProvider<Block>.FabricTagBuilder axe = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), new Identifier(\"mineable/axe\")));\n        FabricTagProvider<Block>.FabricTagBuilder rack = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), Flotage.id(\"rack\")));\n        FabricTagProvider<Block>.FabricTagBuilder fence = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), Flotage.id(\"fence\")));\n        FabricTagProvider<Block>.FabricTagBuilder crossedFence = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), Flotage.id(\"crossed_fence\")));\n        FabricTagProvider<Block>.FabricTagBuilder raft = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), Flotage.id(\"raft\")));\n        FabricTagProvider<Block>.FabricTagBuilder brokenRaft = this.getOrCreateTagBuilder(TagKey.of(Registries.BLOCK.getKey(), Flotage.id(\"broken_raft\")));\n", "        for (BlockMember member : BlockMember.values()){\n            rack.add(BlockRegistry.get(member.rack()));\n            fence.add(BlockRegistry.get(member.fence()));\n            crossedFence.add(BlockRegistry.get(member.crossedFence()));\n            raft.add(BlockRegistry.get(member.raft()));\n            brokenRaft.add(BlockRegistry.get(member.brokenRaft()));\n        }\n\n        for (BlockMember member : BlockMember.values()) {\n            axe.add(BlockRegistry.get(member.crossedFence()));\n            axe.add(BlockRegistry.get(member.fence()));\n            axe.add(BlockRegistry.get(member.raft()));\n            axe.add(BlockRegistry.get(member.brokenRaft()));\n            axe.add(BlockRegistry.get(member.rack()));\n        }\n    }\n}\n", "        for (BlockMember member : BlockMember.values()) {\n            axe.add(BlockRegistry.get(member.crossedFence()));\n            axe.add(BlockRegistry.get(member.fence()));\n            axe.add(BlockRegistry.get(member.raft()));\n            axe.add(BlockRegistry.get(member.brokenRaft()));\n            axe.add(BlockRegistry.get(member.rack()));\n        }\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/datagen/FloModelProvider.java", "chunked_list": ["package committee.nova.flotage.datagen;\n\nimport committee.nova.flotage.Flotage;\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;\nimport net.fabricmc.fabric.api.datagen.v1.provider.FabricModelProvider;\nimport net.minecraft.block.Block;\nimport net.minecraft.data.client.*;\nimport net.minecraft.registry.Registries;", "import net.minecraft.data.client.*;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.util.Identifier;\n\nimport java.util.Optional;\n\n\npublic class FloModelProvider extends FabricModelProvider {\n    protected static BlockStateModelGenerator blockGenerator;\n    protected static ItemModelGenerator itemGenerator;\n    public FloModelProvider(FabricDataOutput dataGenerator) {\n        super(dataGenerator);\n    }\n\n    private static void itemMember(BlockMember member) {\n        Block raft = BlockRegistry.get(member.raft());\n        Block brokenRaft = BlockRegistry.get(member.brokenRaft());\n        Block rack = BlockRegistry.get(member.rack());\n\n        itemGenerator.register(raft.asItem(), itemModel(raft));\n        itemGenerator.register(brokenRaft.asItem(), itemModel(brokenRaft));\n        itemGenerator.register(rack.asItem(), itemModel(rack));\n    }\n\n    private static void member(BlockMember member) {\n        Block raft = BlockRegistry.get(member.raft());\n        Block brokenRaft = BlockRegistry.get(member.brokenRaft());\n        Block rack = BlockRegistry.get(member.rack());\n\n        blockGenerator.registerSingleton(raft, memberTexture(member), model(\"raft\"));\n        blockGenerator.registerSingleton(brokenRaft, memberTexture(member), model(\"broken_raft\"));\n        blockGenerator.registerSingleton(rack, memberTexture(member), model(\"rack\"));\n    }\n\n    @Override", "    public void generateBlockStateModels(BlockStateModelGenerator generator) {\n        blockGenerator = generator;\n        for (BlockMember member : BlockMember.values()) {\n            member(member);\n        }\n    }\n\n    private static Model model(String path) {\n        return new Model(Optional.of(Flotage.id(\"base/\" + path)), Optional.empty(), TextureKey.TOP, TextureKey.SIDE, TextureKey.PARTICLE);\n    }\n\n    private static TextureMap memberTexture(BlockMember member) {\n        Identifier id = new Identifier(member.log().getNamespace(), \"block/\" + member.log().getPath());\n        return new TextureMap()\n                .put(TextureKey.TOP, new Identifier(member.log().getNamespace(), \"block/\" + member.log().getPath() + \"_top\"))\n                .put(TextureKey.SIDE, id)\n                .put(TextureKey.PARTICLE, id);\n    }\n\n    @Override", "    public void generateItemModels(ItemModelGenerator generator) {\n        itemGenerator = generator;\n        for (BlockMember member : BlockMember.values()) {\n            itemMember(member);\n        }\n    }\n\n    private static Model itemModel(Block block) {\n        return new Model(Optional.of(Flotage.id(\"block/\" + Registries.BLOCK.getId(block).getPath())), Optional.empty());\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/datagen/FloLangProvider.java", "chunked_list": ["package committee.nova.flotage.datagen;\n\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.util.WorkingMode;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;\nimport net.fabricmc.fabric.api.datagen.v1.provider.FabricLanguageProvider;\n\npublic class FloLangProvider {\n\n    public static class English extends FabricLanguageProvider {\n        public English(FabricDataOutput dataOutput) {\n            super(dataOutput);\n        }\n\n        @Override", "public class FloLangProvider {\n\n    public static class English extends FabricLanguageProvider {\n        public English(FabricDataOutput dataOutput) {\n            super(dataOutput);\n        }\n\n        @Override\n        public void generateTranslations(TranslationBuilder builder) {\n            builder.add(\"itemGroup.flotage.tab\", \"Flotage\");\n            builder.add(\"modmenu.descriptionTranslation.flotage\", \"Survive on the sea!\");\n            builder.add(\"tip.flotage.rack.processtime\", \"%s second(s) processing\");\n            builder.add(\"tip.flotage.rack.mode\", \"Current Condition: \");\n            builder.add(\"block.flotage.rack\", \"Rack Processing\");\n            builder.add(\"config.jade.plugin_flotage.rack_blockentity\", \"Rack Working Mode\");\n            builder.add(\"emi.category.flotage.rack\", \"Rack Processing\");\n", "        public void generateTranslations(TranslationBuilder builder) {\n            builder.add(\"itemGroup.flotage.tab\", \"Flotage\");\n            builder.add(\"modmenu.descriptionTranslation.flotage\", \"Survive on the sea!\");\n            builder.add(\"tip.flotage.rack.processtime\", \"%s second(s) processing\");\n            builder.add(\"tip.flotage.rack.mode\", \"Current Condition: \");\n            builder.add(\"block.flotage.rack\", \"Rack Processing\");\n            builder.add(\"config.jade.plugin_flotage.rack_blockentity\", \"Rack Working Mode\");\n            builder.add(\"emi.category.flotage.rack\", \"Rack Processing\");\n\n            for (WorkingMode mode : WorkingMode.values()) {\n                builder.add(\"tip.flotage.rack.mode.\" + mode.toString(), beautifyName(mode.toString()));\n            }\n", "            for (WorkingMode mode : WorkingMode.values()) {\n                builder.add(\"tip.flotage.rack.mode.\" + mode.toString(), beautifyName(mode.toString()));\n            }\n\n            for (BlockMember member : BlockMember.values()) {\n                builder.add(BlockRegistry.get(member.raft()), beautifyName(member.raft()));\n                builder.add(BlockRegistry.get(member.brokenRaft()), beautifyName(member.brokenRaft()));\n                builder.add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n    }\n", "    public static class Chinese extends FabricLanguageProvider {\n        public Chinese(FabricDataOutput dataOutput) {\n            super(dataOutput, \"zh_cn\");\n        }\n\n        @Override\n        public void generateTranslations(TranslationBuilder builder) {\n            builder.add(\"itemGroup.flotage.tab\", \"\u6f02\u6d6e\u7269\");\n            builder.add(\"modmenu.descriptionTranslation.flotage\", \"\u751f\u5b58\u4e8e\u5927\u6d77\u4e4b\u4e0a\uff01\");\n            builder.add(\"tip.flotage.rack.processtime\", \"\u9700\u8981\u5904\u7406 %s \u79d2\u3002\");\n            builder.add(\"tip.flotage.rack.mode\", \"\u5f53\u524d\u5904\u7406\u6761\u4ef6\uff1a\");\n            builder.add(\"block.flotage.rack\", \"\u7f6e\u7269\u67b6\");\n            builder.add(\"config.jade.plugin_flotage.rack_blockentity\", \"\u7f6e\u7269\u67b6\u6a21\u5f0f\");\n            builder.add(\"emi.category.flotage.rack\", \"\u7f6e\u7269\u67b6\");\n\n            builder.add(\"tip.flotage.rack.mode.unconditional\", \"\u65e0\u6761\u4ef6\");\n            builder.add(\"tip.flotage.rack.mode.sun\", \"\u767d\u5929\");\n            builder.add(\"tip.flotage.rack.mode.night\", \"\u591c\u665a\");\n            builder.add(\"tip.flotage.rack.mode.rain\", \"\u96e8\u5929\");\n            builder.add(\"tip.flotage.rack.mode.snow\", \"\u96ea\u5929\");\n            builder.add(\"tip.flotage.rack.mode.rain_at\", \"\u6dcb\u96e8\");\n            builder.add(\"tip.flotage.rack.mode.snow_at\", \"\u6dcb\u96ea\");\n            builder.add(\"tip.flotage.rack.mode.smoke\", \"\u70df\u718f\");\n", "            for (BlockMember member : BlockMember.values()) {\n                builder.add(BlockRegistry.get(member.raft()), member.chinese + \"\u7b4f\");\n                builder.add(BlockRegistry.get(member.brokenRaft()), \"\u635f\u574f\u7684\" + member.chinese + \"\u7b4f\");\n                builder.add(BlockRegistry.get(member.fence()), \"\u7b80\u6613\" + member.chinese + \"\u6805\u680f\");\n                builder.add(BlockRegistry.get(member.crossedFence()), member.chinese + \"\u5341\u5b57\u6805\u680f\");\n                builder.add(BlockRegistry.get(member.rack()), member.chinese + \"\u7f6e\u7269\u67b6\");\n            }\n        }\n    }\n\n    public static String beautifyName(String name) {\n        String[] str1 = name.split(\"_\");\n        StringBuilder str2 = new StringBuilder();", "    public static String beautifyName(String name) {\n        String[] str1 = name.split(\"_\");\n        StringBuilder str2 = new StringBuilder();\n        for(int i = 0 ; i < str1.length; i++) {\n            str1[i] = str1[i].substring(0,1).toUpperCase() + str1[i].substring(1);\n            if(i == str1.length-1)\n                str2.append(str1[i]);\n            else\n                str2.append(str1[i]).append(\" \");\n        }\n        return str2.toString();\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/datagen/FloBlockLootProvider.java", "chunked_list": ["package committee.nova.flotage.datagen;\n\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.init.ItemRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;\nimport net.fabricmc.fabric.api.datagen.v1.provider.FabricBlockLootTableProvider;\nimport net.minecraft.loot.provider.number.ConstantLootNumberProvider;\n\npublic class FloBlockLootProvider extends FabricBlockLootTableProvider {\n\n    public FloBlockLootProvider(FabricDataOutput dataOutput) {\n        super(dataOutput);\n    }\n\n    @Override", "\npublic class FloBlockLootProvider extends FabricBlockLootTableProvider {\n\n    public FloBlockLootProvider(FabricDataOutput dataOutput) {\n        super(dataOutput);\n    }\n\n    @Override\n    public void generate() {\n        for (BlockMember member : BlockMember.values()) {\n            addDrop(BlockRegistry.get(member.raft()));\n            addDrop(BlockRegistry.get(member.brokenRaft()), member.repairBlock.asItem());\n            addDrop(BlockRegistry.get(member.fence()));\n            addDrop(BlockRegistry.get(member.crossedFence()), drops(ItemRegistry.get(member.fence()), ConstantLootNumberProvider.create(2f)));\n            addDrop(BlockRegistry.get(member.rack()));\n        }\n    }\n}\n", "    public void generate() {\n        for (BlockMember member : BlockMember.values()) {\n            addDrop(BlockRegistry.get(member.raft()));\n            addDrop(BlockRegistry.get(member.brokenRaft()), member.repairBlock.asItem());\n            addDrop(BlockRegistry.get(member.fence()));\n            addDrop(BlockRegistry.get(member.crossedFence()), drops(ItemRegistry.get(member.fence()), ConstantLootNumberProvider.create(2f)));\n            addDrop(BlockRegistry.get(member.rack()));\n        }\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/mixin/FlotageTabRenderMixin.java", "chunked_list": ["package committee.nova.flotage.mixin;\n\n\nimport committee.nova.flotage.init.TabRegistry;\nimport net.minecraft.client.gui.DrawContext;\nimport net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;\nimport net.minecraft.item.ItemGroup;\nimport net.minecraft.item.ItemStack;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;", "import org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(CreativeInventoryScreen.class)\npublic abstract class FlotageTabRenderMixin {\n\n    @Inject(method = \"renderTabIcon\", at = @At(\"HEAD\"), cancellable = true)\n    private void renderTabIcon(DrawContext context, ItemGroup group, CallbackInfo info) {\n        if (group.equals(TabRegistry.TAB) && group == TabRegistry.TAB) {\n            boolean bl = group == CreativeInventoryScreen.selectedTab;\n            boolean bl2 = group.getRow() == ItemGroup.Row.TOP;\n            int i = group.getColumn();\n            int j = i * 26;\n            int k = 0;\n            int l = ((CreativeInventoryScreen)(Object)this).x + ((CreativeInventoryScreen)(Object)this).getTabX(group);\n            int m = ((CreativeInventoryScreen)(Object)this).y;\n            int n = 32;", "        if (group.equals(TabRegistry.TAB) && group == TabRegistry.TAB) {\n            boolean bl = group == CreativeInventoryScreen.selectedTab;\n            boolean bl2 = group.getRow() == ItemGroup.Row.TOP;\n            int i = group.getColumn();\n            int j = i * 26;\n            int k = 0;\n            int l = ((CreativeInventoryScreen)(Object)this).x + ((CreativeInventoryScreen)(Object)this).getTabX(group);\n            int m = ((CreativeInventoryScreen)(Object)this).y;\n            int n = 32;\n            if (bl) {\n                k += 32;\n            }", "            if (bl) {\n                k += 32;\n            }\n            if (bl2) {\n                m -= 29;\n            } else {\n                k += 64;\n                m += ((CreativeInventoryScreen)(Object)this).backgroundHeight - 3;\n            }\n            context.drawTexture(TabRegistry.TEXTURE, l, m, j, k, 26, 32);\n            context.getMatrices().push();\n            context.getMatrices().translate(0.0f, 0.0f, 100.0f);\n            int n2 = bl2 ? 1 : -1;\n            ItemStack itemStack = group.getIcon();", "            if (bl) {\n                m -= bl2 ? 3 : -3;\n            }\n            context.drawItem(itemStack, l += 5, m += 8 + n2);\n            context.drawItemInSlot(((CreativeInventoryScreen)(Object)this).textRenderer, itemStack, l, m);\n            context.getMatrices().pop();\n\n            info.cancel();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/item/RaftItem.java", "chunked_list": ["package committee.nova.flotage.impl.item;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.fluid.Fluids;\nimport net.minecraft.item.*;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.TypedActionResult;\nimport net.minecraft.util.hit.BlockHitResult;", "import net.minecraft.util.TypedActionResult;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.util.hit.HitResult;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.RaycastContext;\nimport net.minecraft.world.World;\n\npublic class RaftItem extends BlockItem {\n\n    public RaftItem(Block block, Settings settings) {\n        super(block, settings);\n    }\n\n    @Override", "    public ActionResult useOnBlock(ItemUsageContext context) {\n        return ActionResult.PASS;\n    }\n\n    @Override\n    public TypedActionResult<ItemStack> use(World world, PlayerEntity user, Hand hand) {\n        ItemStack itemStack = user.getStackInHand(hand);\n        BlockHitResult blockHitResult = BucketItem.raycast(world, user, RaycastContext.FluidHandling.SOURCE_ONLY);\n        if (blockHitResult.getType() == HitResult.Type.MISS) {\n            return TypedActionResult.pass(itemStack);\n        }", "        if (blockHitResult.getType() == HitResult.Type.MISS) {\n            return TypedActionResult.pass(itemStack);\n        }\n        if (blockHitResult.getType() == HitResult.Type.BLOCK) {\n            BlockPos blockPos = blockHitResult.getBlockPos();\n            if (world.getFluidState(blockPos).isOf(Fluids.WATER)) {\n                ActionResult actionResult = this.place(new ItemPlacementContext(user, hand, itemStack, blockHitResult));\n                switch (actionResult) {\n                    case SUCCESS -> {\n                        return TypedActionResult.success(itemStack);\n                    }\n                    case CONSUME -> {\n                        return TypedActionResult.consume(itemStack);\n                    }\n                    case FAIL -> {\n                        return TypedActionResult.fail(itemStack);\n                    }\n                    case PASS ->  {\n                        return TypedActionResult.pass(itemStack);\n                    }\n                }\n            }\n        }\n        return super.use(world, user, hand);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/recipe/RackRecipeSerializer.java", "chunked_list": ["package committee.nova.flotage.impl.recipe;\n\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonSyntaxException;\nimport committee.nova.flotage.util.WorkingMode;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.network.PacketByteBuf;\nimport net.minecraft.recipe.Ingredient;", "import net.minecraft.network.PacketByteBuf;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.RecipeSerializer;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.JsonHelper;\n\nimport static net.minecraft.recipe.ShapedRecipe.outputFromJson;\n\npublic class RackRecipeSerializer implements RecipeSerializer<RackRecipe> {\n    private RackRecipeSerializer() {\n    }\n", "\npublic class RackRecipeSerializer implements RecipeSerializer<RackRecipe> {\n    private RackRecipeSerializer() {\n    }\n\n    public static final RackRecipeSerializer INSTANCE = new RackRecipeSerializer();\n\n    @Override\n    public RackRecipe read(Identifier id, JsonObject json) {\n        Ingredient ingredient = Ingredient.fromJson(JsonHelper.getObject(json, \"ingredient\"));\n        ItemStack result;\n        JsonElement element = json.get(\"result\");", "    public RackRecipe read(Identifier id, JsonObject json) {\n        Ingredient ingredient = Ingredient.fromJson(JsonHelper.getObject(json, \"ingredient\"));\n        ItemStack result;\n        JsonElement element = json.get(\"result\");\n        if (element.isJsonObject())\n            result = outputFromJson((JsonObject) element);\n        else {\n            String string = element.getAsString();\n            Item item = Registries.ITEM.getOrEmpty(new Identifier(string)).orElseThrow(() -> new JsonSyntaxException(\"Unknown item '\" + string + \"'\"));\n            result = new ItemStack(item);\n        }\n        int processtime = json.get(\"processtime\").getAsInt();\n        WorkingMode mode = WorkingMode.match(json.get(\"mode\").getAsString());\n\n        return new RackRecipe(id, ingredient, result, processtime, mode);\n    }\n\n    @Override", "    public RackRecipe read(Identifier id, PacketByteBuf buf) {\n        Ingredient ingredient = Ingredient.fromPacket(buf);\n        ItemStack result = buf.readItemStack();\n        int processtime = buf.readInt();\n        WorkingMode mode = WorkingMode.match(buf.readString());\n        return new RackRecipe(id, ingredient, result, processtime, mode);\n    }\n\n    @Override\n    public void write(PacketByteBuf buf, RackRecipe recipe) {\n        recipe.ingredient.write(buf);\n        buf.writeItemStack(recipe.result);\n        buf.writeInt(recipe.getProcesstime());\n        buf.writeString(recipe.getMode().toString());\n    }\n}\n", "    public void write(PacketByteBuf buf, RackRecipe recipe) {\n        recipe.ingredient.write(buf);\n        buf.writeItemStack(recipe.result);\n        buf.writeInt(recipe.getProcesstime());\n        buf.writeString(recipe.getMode().toString());\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/recipe/RackRecipeType.java", "chunked_list": ["package committee.nova.flotage.impl.recipe;\n\nimport net.minecraft.recipe.RecipeType;\n\npublic class RackRecipeType implements RecipeType<RackRecipe> {\n    private RackRecipeType() {}\n\n    public static final RackRecipeType INSTANCE = new RackRecipeType();\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/recipe/RackRecipe.java", "chunked_list": ["package committee.nova.flotage.impl.recipe;\n\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.WorkingMode;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.Recipe;", "import net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeSerializer;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.registry.DynamicRegistryManager;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.world.World;\n\npublic class RackRecipe implements Recipe<RackBlockEntity> {\n    protected final Ingredient ingredient;\n    protected final ItemStack result;\n    private final int processtime;\n    private final WorkingMode mode;\n    private final Identifier id;\n\n    public RackRecipe(Identifier id, Ingredient ingredient, ItemStack result, int processtime, WorkingMode mode) {\n        this.id = id;\n        this.ingredient = ingredient;\n        this.result = result;\n        this.processtime = processtime;\n        this.mode = mode;\n    }\n\n    @Override", "\npublic class RackRecipe implements Recipe<RackBlockEntity> {\n    protected final Ingredient ingredient;\n    protected final ItemStack result;\n    private final int processtime;\n    private final WorkingMode mode;\n    private final Identifier id;\n\n    public RackRecipe(Identifier id, Ingredient ingredient, ItemStack result, int processtime, WorkingMode mode) {\n        this.id = id;\n        this.ingredient = ingredient;\n        this.result = result;\n        this.processtime = processtime;\n        this.mode = mode;\n    }\n\n    @Override", "    public boolean matches(RackBlockEntity inventory, World world) {\n        return this.ingredient.test(inventory.getStack(0));\n    }\n\n    @Override\n    public ItemStack craft(RackBlockEntity inventory, DynamicRegistryManager registryManager) {\n        ItemStack itemStack = this.result.copy();\n        NbtCompound nbtCompound = inventory.getStack(0).getNbt();\n        if (nbtCompound != null) {\n            itemStack.setNbt(nbtCompound.copy());\n        }\n        return itemStack;\n    }\n\n    @Override", "        if (nbtCompound != null) {\n            itemStack.setNbt(nbtCompound.copy());\n        }\n        return itemStack;\n    }\n\n    @Override\n    public boolean fits(int width, int height) {\n        return true;\n    }\n\n    @Override", "    public ItemStack getOutput(DynamicRegistryManager registryManager) {\n        return this.result;\n    }\n\n    public ItemStack getResult() {\n        return result;\n    }\n\n    @Override\n    public ItemStack createIcon() {\n        return new ItemStack(BlockRegistry.get(BlockMember.OAK.rack()));\n    }\n\n    @Override", "    public ItemStack createIcon() {\n        return new ItemStack(BlockRegistry.get(BlockMember.OAK.rack()));\n    }\n\n    @Override\n    public Identifier getId() {\n        return this.id;\n    }\n\n    @Override\n    public RecipeSerializer<?> getSerializer() {\n        return RackRecipeSerializer.INSTANCE;\n    }\n\n    @Override\n    public RecipeType<?> getType() {\n        return RackRecipeType.INSTANCE;\n    }\n", "    public int getProcesstime() {\n        return processtime;\n    }\n\n    @Override\n    public boolean isIgnoredInRecipeBook() {\n        return true;\n    }\n\n    public WorkingMode getMode() {\n        return mode;\n    }\n\n    @Override\n    public DefaultedList<Ingredient> getIngredients() {\n        DefaultedList<Ingredient> list = DefaultedList.of();\n        list.add(this.ingredient);\n        return list;\n    }\n}\n", "    public WorkingMode getMode() {\n        return mode;\n    }\n\n    @Override\n    public DefaultedList<Ingredient> getIngredients() {\n        DefaultedList<Ingredient> list = DefaultedList.of();\n        list.add(this.ingredient);\n        return list;\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/tile/RackBlockEntity.java", "chunked_list": ["package committee.nova.flotage.impl.tile;\n\nimport committee.nova.flotage.impl.recipe.RackRecipe;\nimport committee.nova.flotage.impl.recipe.RackRecipeType;\nimport committee.nova.flotage.init.TileRegistry;\nimport committee.nova.flotage.util.WorkingMode;\nimport it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\nimport net.fabricmc.fabric.api.transfer.v1.item.InventoryStorage;\nimport net.fabricmc.fabric.api.transfer.v1.item.ItemVariant;\nimport net.fabricmc.fabric.api.transfer.v1.item.base.SingleStackStorage;", "import net.fabricmc.fabric.api.transfer.v1.item.ItemVariant;\nimport net.fabricmc.fabric.api.transfer.v1.item.base.SingleStackStorage;\nimport net.fabricmc.fabric.api.transfer.v1.storage.Storage;\nimport net.fabricmc.fabric.api.transfer.v1.storage.base.CombinedStorage;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.entity.BlockEntity;\nimport net.minecraft.inventory.Inventories;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;", "import net.minecraft.nbt.NbtCompound;\nimport net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;\nimport net.minecraft.recipe.*;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.world.World;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic class RackBlockEntity extends BlockEntity implements BlockEntityInv, RecipeUnlocker, RecipeInputProvider {\n    public final RecipeType<RackRecipe> recipeType = RackRecipeType.INSTANCE;\n\n    private final DefaultedList<ItemStack> items = DefaultedList.ofSize(1, ItemStack.EMPTY);\n    private int processTimeTotal;\n    private int processTime;\n    private Direction itemDirection = Direction.NORTH;\n    private final Object2IntOpenHashMap<Identifier> recipesUsed = new Object2IntOpenHashMap<>();\n\n    @SuppressWarnings(\"UnstableApiUsage\")\n    private final SingleStackStorage[] internalStoreStorage = new SingleStackStorage[0];\n\n    public RackBlockEntity(BlockPos pos, BlockState state) {\n        super(TileRegistry.get(\"rack\"), pos, state);\n    }\n\n    @Override", "    public BlockEntityUpdateS2CPacket toUpdatePacket() {\n        return BlockEntityUpdateS2CPacket.create(this);\n    }\n\n    @Override\n    public NbtCompound toInitialChunkDataNbt() {\n        return createNbt();\n    }\n\n    @Override\n    public void readNbt(NbtCompound nbt) {\n        super.readNbt(nbt);\n        Inventories.readNbt(nbt, items);\n        this.processTimeTotal = nbt.getShort(\"ProcessTimeTotal\");\n        this.processTime = nbt.getShort(\"ProcessTime\");\n        this.itemDirection = Direction.valueOf(nbt.getString(\"ItemDirection\"));\n     \n        NbtCompound nbtCompound = nbt.getCompound(\"RecipesUsed\");", "    public void readNbt(NbtCompound nbt) {\n        super.readNbt(nbt);\n        Inventories.readNbt(nbt, items);\n        this.processTimeTotal = nbt.getShort(\"ProcessTimeTotal\");\n        this.processTime = nbt.getShort(\"ProcessTime\");\n        this.itemDirection = Direction.valueOf(nbt.getString(\"ItemDirection\"));\n     \n        NbtCompound nbtCompound = nbt.getCompound(\"RecipesUsed\");\n        for (String string : nbtCompound.getKeys()) {\n            this.recipesUsed.put(new Identifier(string), nbtCompound.getInt(string));\n        }\n    }\n\n    @Override\n    protected void writeNbt(NbtCompound nbt) {\n        super.writeNbt(nbt);\n        Inventories.writeNbt(nbt, items);\n        nbt.putShort(\"ProcessTimeTotal\", (short)this.processTimeTotal);\n        nbt.putShort(\"ProcessTime\", (short)this.processTime);\n        nbt.putString(\"ItemDirection\", this.itemDirection.name());\n\n        NbtCompound nbtCompound = new NbtCompound();\n        this.recipesUsed.forEach((identifier, count) -> nbtCompound.putInt(identifier.toString(), count));\n        nbt.put(\"RecipesUsed\", nbtCompound);\n    }\n", "        for (String string : nbtCompound.getKeys()) {\n            this.recipesUsed.put(new Identifier(string), nbtCompound.getInt(string));\n        }\n    }\n\n    @Override\n    protected void writeNbt(NbtCompound nbt) {\n        super.writeNbt(nbt);\n        Inventories.writeNbt(nbt, items);\n        nbt.putShort(\"ProcessTimeTotal\", (short)this.processTimeTotal);\n        nbt.putShort(\"ProcessTime\", (short)this.processTime);\n        nbt.putString(\"ItemDirection\", this.itemDirection.name());\n\n        NbtCompound nbtCompound = new NbtCompound();\n        this.recipesUsed.forEach((identifier, count) -> nbtCompound.putInt(identifier.toString(), count));\n        nbt.put(\"RecipesUsed\", nbtCompound);\n    }\n", "    public void setItem(ItemStack itemStack) {\n        if (isEmpty() && !itemStack.isEmpty()) {\n            items.set(0, itemStack);\n        }\n    }\n\n    public void clean() {\n        items.set(0, ItemStack.EMPTY);\n    }\n\n    public ItemStack getItem() {\n        return items.get(0);\n    }\n\n    @Override\n    public DefaultedList<ItemStack> getItems() {\n        return items;\n    }\n", "    public ItemStack getItem() {\n        return items.get(0);\n    }\n\n    @Override\n    public DefaultedList<ItemStack> getItems() {\n        return items;\n    }\n\n    public void inventoryChanged() {\n        this.markDirty();", "    public void inventoryChanged() {\n        this.markDirty();\n        if (world != null) {\n            world.updateListeners(getPos(), getCachedState(), getCachedState(), (1) | (1 << 1));\n        }\n    }\n\n    public static void tick(World world, BlockPos pos, BlockState state, RackBlockEntity tile) {\n        ItemStack itemStack = tile.getItem();\n        boolean flag = false;\n        if (!itemStack.isEmpty()) {\n            Optional<RackRecipe> optional = world.getRecipeManager().getFirstMatch(tile.recipeType, tile, world);\n", "        if (!itemStack.isEmpty()) {\n            Optional<RackRecipe> optional = world.getRecipeManager().getFirstMatch(tile.recipeType, tile, world);\n\n            if (optional.isPresent()) {\n                RackRecipe recipe = optional.get();\n                tile.processTimeTotal = recipe.getProcesstime();\n\n                if (WorkingMode.judge(world, pos) == recipe.getMode()) {\n                    tile.processTime++;\n                    if (tile.processTime == tile.processTimeTotal) {\n                        tile.processTime = 0;\n                        tile.setStack(0, recipe.getOutput(world.getRegistryManager()));\n                        tile.setLastRecipe(recipe);\n                        flag = true;\n                    }\n                }\n            }\n        }", "                    if (tile.processTime == tile.processTimeTotal) {\n                        tile.processTime = 0;\n                        tile.setStack(0, recipe.getOutput(world.getRegistryManager()));\n                        tile.setLastRecipe(recipe);\n                        flag = true;\n                    }\n                }\n            }\n        }\n        if (flag) {\n            tile.inventoryChanged();\n        }\n    }\n\n    @Override", "        if (flag) {\n            tile.inventoryChanged();\n        }\n    }\n\n    @Override\n    public void provideRecipeInputs(RecipeMatcher finder) {\n        for (ItemStack itemStack : this.items) {\n            finder.addInput(itemStack);\n        }\n    }\n\n    @Override", "    public void setLastRecipe(@Nullable Recipe<?> recipe) {\n        if (recipe != null) {\n            Identifier identifier = recipe.getId();\n            this.recipesUsed.addTo(identifier, 1);\n        }\n    }\n\n    @Nullable\n    @Override\n    public Recipe<?> getLastRecipe() {\n        return null;\n    }\n", "    public Direction getItemDirection() {\n        return itemDirection;\n    }\n\n    public void setItemDirection(Direction itemDirection) {\n        this.itemDirection = itemDirection;\n    }\n\n    @Override\n    public boolean canExtract(int slot, ItemStack stack, Direction dir) {\n        return processTime == 0;\n    }\n\n    @Override", "    public boolean canExtract(int slot, ItemStack stack, Direction dir) {\n        return processTime == 0;\n    }\n\n    @Override\n    public int getMaxCountPerStack() {\n        return 1;\n    }\n\n    public Storage<ItemVariant> getExposedStorage(Direction side) {\n        return new CombinedStorage<>(List.of(\n                getInternalStoreStorage(side),\n                InventoryStorage.of(this, side)\n        ));\n    }\n\n    private Storage<ItemVariant> getInternalStoreStorage(Direction side) {\n        Objects.requireNonNull(side);", "        if (internalStoreStorage[0] == null) {\n            internalStoreStorage[0] = new SingleStackStorage() {\n                @Override\n                protected ItemStack getStack() {\n                    return getItem();\n                }\n\n                @Override\n                protected void setStack(ItemStack stack) {\n                    if (stack.isEmpty()) {\n                        clean();\n                    } else {\n                        setItem(stack);\n                    }\n                }\n\n                @Override\n                protected int getCapacity(ItemVariant itemVariant) {\n                    return 1 - super.getCapacity(itemVariant);\n                }\n\n                @Override\n                protected boolean canInsert(ItemVariant itemVariant) {\n                    return RackBlockEntity.this.canInsert(0, itemVariant.toStack(), side);\n                }\n\n                @Override\n                protected boolean canExtract(ItemVariant itemVariant) {\n                    return RackBlockEntity.this.canExtract(0, itemVariant.toStack(), side);\n                }\n\n                @Override\n                protected void onFinalCommit() {\n                    inventoryChanged();\n                }\n            };\n        }\n        return internalStoreStorage[0];\n    }\n}\n", "                    if (stack.isEmpty()) {\n                        clean();\n                    } else {\n                        setItem(stack);\n                    }\n                }\n\n                @Override\n                protected int getCapacity(ItemVariant itemVariant) {\n                    return 1 - super.getCapacity(itemVariant);\n                }\n\n                @Override\n                protected boolean canInsert(ItemVariant itemVariant) {\n                    return RackBlockEntity.this.canInsert(0, itemVariant.toStack(), side);\n                }\n\n                @Override\n                protected boolean canExtract(ItemVariant itemVariant) {\n                    return RackBlockEntity.this.canExtract(0, itemVariant.toStack(), side);\n                }\n\n                @Override\n                protected void onFinalCommit() {\n                    inventoryChanged();\n                }\n            };\n        }\n        return internalStoreStorage[0];\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/tile/BlockEntityInv.java", "chunked_list": ["package committee.nova.flotage.impl.tile;\n\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.inventory.Inventories;\nimport net.minecraft.inventory.SidedInventory;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.util.math.Direction;\nimport org.jetbrains.annotations.Nullable;\n\npublic interface BlockEntityInv extends SidedInventory {\n    DefaultedList<ItemStack> getItems();\n\n    @Override\n    default int size() {\n        return getItems().size();\n    }\n\n    @Override\n    default boolean isEmpty() {", "import org.jetbrains.annotations.Nullable;\n\npublic interface BlockEntityInv extends SidedInventory {\n    DefaultedList<ItemStack> getItems();\n\n    @Override\n    default int size() {\n        return getItems().size();\n    }\n\n    @Override\n    default boolean isEmpty() {", "        for (int i = 0; i < size(); i++) {\n            ItemStack stack = getStack(i);\n            if (!stack.isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    default ItemStack getStack(int slot) {\n        return getItems().get(slot);\n    }\n\n    @Override\n    default ItemStack removeStack(int slot, int count) {\n        ItemStack result = Inventories.splitStack(getItems(), slot, count);", "        if (!result.isEmpty()) {\n            markDirty();\n        }\n        return result;\n    }\n\n    @Override\n    default void setStack(int slot, ItemStack stack) {\n        ItemStack itemStack = stack.copy();\n        stack.setCount(1);\n        getItems().set(slot, itemStack);\n        markDirty();\n    }\n\n    @Override\n    default ItemStack removeStack(int slot) {\n        return Inventories.removeStack(getItems(), slot);\n    }\n\n    @Override\n    default void clear() {", "        for (int i = 0; i < size(); i++) {\n            removeStack(i);\n        }\n    }\n\n    @Override\n    default boolean canPlayerUse(PlayerEntity player) {\n        return true;\n    }\n\n    @Override\n    default int[] getAvailableSlots(Direction side) {\n        return new int[0];\n    }\n\n    @Override\n    default boolean canExtract(int slot, ItemStack stack, Direction dir) {\n        return true;\n    }\n\n    @Override\n    default boolean canInsert(int slot, ItemStack stack, @Nullable Direction dir) {\n        return true;\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/SimpleFenceBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.BlockRegistry;\nimport net.minecraft.block.*;\nimport net.minecraft.block.enums.Instrument;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.fluid.FluidState;\nimport net.minecraft.fluid.Fluids;\nimport net.minecraft.item.BlockItem;", "import net.minecraft.fluid.Fluids;\nimport net.minecraft.item.BlockItem;\nimport net.minecraft.item.ItemPlacementContext;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.state.StateManager;\nimport net.minecraft.state.property.BooleanProperty;\nimport net.minecraft.state.property.DirectionProperty;\nimport net.minecraft.state.property.Properties;\nimport net.minecraft.util.ActionResult;", "import net.minecraft.state.property.Properties;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.BlockMirror;\nimport net.minecraft.util.BlockRotation;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.util.shape.VoxelShapes;", "import net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.util.shape.VoxelShapes;\nimport net.minecraft.world.BlockView;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldAccess;\nimport org.jetbrains.annotations.Nullable;\n\npublic class SimpleFenceBlock extends Block implements Waterloggable {\n    public static final BooleanProperty WATERLOGGED = Properties.WATERLOGGED;\n    public static final DirectionProperty FACING = Properties.HORIZONTAL_FACING;\n    public final BlockMember member;\n\n    public SimpleFenceBlock(BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().strength(1.5F,1F));", "    public static final BooleanProperty WATERLOGGED = Properties.WATERLOGGED;\n    public static final DirectionProperty FACING = Properties.HORIZONTAL_FACING;\n    public final BlockMember member;\n\n    public SimpleFenceBlock(BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().strength(1.5F,1F));\n        this.setDefaultState(this.getDefaultState().with(WATERLOGGED, false).with(FACING, Direction.NORTH));\n        this.member = member;\n    }\n\n    @Override", "    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {\n        ItemStack handStack = player.getStackInHand(hand);\n        if (handStack.getItem() instanceof BlockItem blockItem) {\n            if (blockItem.getBlock() instanceof SimpleFenceBlock fence) {\n                if (fence == this) {\n                    world.setBlockState(pos, BlockRegistry.get(member.crossedFence()).getDefaultState(), Block.NOTIFY_ALL);\n                    if (!player.isCreative()) {\n                        handStack.decrement(1);\n                    }\n                    return ActionResult.success(world.isClient);\n                }\n            }\n        }\n        return super.onUse(state, world, pos, player, hand, hit);\n    }\n\n    @Override\n    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {\n        builder.add(WATERLOGGED, FACING);\n    }\n\n    @Override", "    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return createShape(state.get(FACING) == Direction.WEST || state.get(FACING) == Direction.EAST);\n    }\n\n    protected static VoxelShape createShape(boolean rotated) {\n        VoxelShape shape1;\n        VoxelShape shape2;\n        VoxelShape shape3;\n        VoxelShape shape4;\n        if (rotated) {\n            shape1 = Block.createCuboidShape(6.75, 0, 3, 9.25, 16, 5.5);\n            shape2 = Block.createCuboidShape(6.75, 0, 10.5, 9.25, 16, 13);\n            shape3 = Block.createCuboidShape(7,5.5,0,9, 7.5, 16);\n            shape4 = Block.createCuboidShape(7,11,0,9, 13, 16);\n        }else {\n            shape1 = Block.createCuboidShape(3, 0, 6.75, 5.5, 16, 9.25);\n            shape2 = Block.createCuboidShape(10.5, 0, 6.75, 13, 16, 9.25);\n            shape3 = Block.createCuboidShape(0,5.5,7,16, 7.5, 9);\n            shape4 = Block.createCuboidShape(0,11,7,16, 13, 9);\n        }\n        return VoxelShapes.union(shape1, shape2, shape3, shape4);\n    }\n\n    @Override", "        if (rotated) {\n            shape1 = Block.createCuboidShape(6.75, 0, 3, 9.25, 16, 5.5);\n            shape2 = Block.createCuboidShape(6.75, 0, 10.5, 9.25, 16, 13);\n            shape3 = Block.createCuboidShape(7,5.5,0,9, 7.5, 16);\n            shape4 = Block.createCuboidShape(7,11,0,9, 13, 16);\n        }else {\n            shape1 = Block.createCuboidShape(3, 0, 6.75, 5.5, 16, 9.25);\n            shape2 = Block.createCuboidShape(10.5, 0, 6.75, 13, 16, 9.25);\n            shape3 = Block.createCuboidShape(0,5.5,7,16, 7.5, 9);\n            shape4 = Block.createCuboidShape(0,11,7,16, 13, 9);\n        }\n        return VoxelShapes.union(shape1, shape2, shape3, shape4);\n    }\n\n    @Override", "    public BlockState getPlacementState(ItemPlacementContext ctx) {\n        World worldAccess = ctx.getWorld();\n        boolean bl = worldAccess.getFluidState(ctx.getBlockPos()).getFluid() == Fluids.WATER;\n        return this.getDefaultState().with(WATERLOGGED, bl).with(FACING, ctx.getPlayerLookDirection().getOpposite());\n    }\n\n    @Nullable\n    @Override\n    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override", "    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override\n    public FluidState getFluidState(BlockState state) {\n        return state.get(WATERLOGGED) ? Fluids.WATER.getStill(false) : super.getFluidState(state);\n    }\n\n    @Override", "    public FluidState getFluidState(BlockState state) {\n        return state.get(WATERLOGGED) ? Fluids.WATER.getStill(false) : super.getFluidState(state);\n    }\n\n    @Override\n    public BlockState rotate(BlockState state, BlockRotation rotation) {\n        return state.with(FACING, rotation.rotate(state.get(FACING)));\n    }\n\n    @Override\n    public BlockState mirror(BlockState state, BlockMirror mirror) {\n        return state.rotate(mirror.getRotation(state.get(FACING)));\n    }\n}\n", "    public BlockState mirror(BlockState state, BlockMirror mirror) {\n        return state.rotate(mirror.getRotation(state.get(FACING)));\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/RaftBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.util.BlockMember;\nimport net.minecraft.block.*;\nimport net.minecraft.entity.ai.pathing.NavigationType;\nimport net.minecraft.fluid.FluidState;\nimport net.minecraft.fluid.Fluids;\nimport net.minecraft.item.ItemPlacementContext;\nimport net.minecraft.state.StateManager;\nimport net.minecraft.state.property.BooleanProperty;", "import net.minecraft.state.StateManager;\nimport net.minecraft.state.property.BooleanProperty;\nimport net.minecraft.state.property.Properties;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.world.BlockView;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldAccess;\nimport net.minecraft.world.WorldView;", "import net.minecraft.world.WorldAccess;\nimport net.minecraft.world.WorldView;\nimport org.jetbrains.annotations.Nullable;\n\npublic class RaftBlock extends Block implements Waterloggable {\n    public static final BooleanProperty WATERLOGGED = Properties.WATERLOGGED;\n    public final BlockMember member;\n\n    public RaftBlock(Settings settings, BlockMember member) {\n        super(settings);\n        this.setDefaultState(this.getDefaultState().with(WATERLOGGED, true));\n        this.member = member;\n    }\n\n    @Override\n    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {\n        builder.add(WATERLOGGED);\n    }\n\n    @Override", "        this.setDefaultState(this.getDefaultState().with(WATERLOGGED, true));\n        this.member = member;\n    }\n\n    @Override\n    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {\n        builder.add(WATERLOGGED);\n    }\n\n    @Override\n    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return Block.createCuboidShape(0, 13.25, 0, 16, 15.25, 16);\n    }\n\n    @Override", "    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return Block.createCuboidShape(0, 13.25, 0, 16, 15.25, 16);\n    }\n\n    @Override\n    public VoxelShape getCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return Block.createCuboidShape(0, 13.25, 0, 16, 16, 16);\n    }\n\n    @Override\n    public BlockState getPlacementState(ItemPlacementContext ctx) {\n        World worldAccess = ctx.getWorld();\n        boolean bl = worldAccess.getFluidState(ctx.getBlockPos()).getFluid() == Fluids.WATER;", "    public BlockState getPlacementState(ItemPlacementContext ctx) {\n        World worldAccess = ctx.getWorld();\n        boolean bl = worldAccess.getFluidState(ctx.getBlockPos()).getFluid() == Fluids.WATER;\n        return this.getDefaultState().with(WATERLOGGED, bl);\n    }\n\n    @Nullable\n    @Override\n    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override", "    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override\n    public FluidState getFluidState(BlockState state) {\n        return state.get(WATERLOGGED) ? Fluids.WATER.getStill(false) : super.getFluidState(state);\n    }\n\n    @Override", "    public FluidState getFluidState(BlockState state) {\n        return state.get(WATERLOGGED) ? Fluids.WATER.getStill(false) : super.getFluidState(state);\n    }\n\n    @Override\n    public boolean isTransparent(BlockState state, BlockView world, BlockPos pos) {\n        return true;\n    }\n\n    @Override\n    public boolean canPlaceAt(BlockState state, WorldView world, BlockPos pos) {\n        BlockState state2 = world.getBlockState(pos.up());\n        return (!state2.contains(WATERLOGGED) || !state2.get(WATERLOGGED)) && state.getFluidState().isOf(Fluids.WATER);\n    }\n\n    @Override", "    public boolean canPlaceAt(BlockState state, WorldView world, BlockPos pos) {\n        BlockState state2 = world.getBlockState(pos.up());\n        return (!state2.contains(WATERLOGGED) || !state2.get(WATERLOGGED)) && state.getFluidState().isOf(Fluids.WATER);\n    }\n\n    @Override\n    public boolean canPathfindThrough(BlockState state, BlockView world, BlockPos pos, NavigationType type) {\n        return false;\n    }\n\n    @Override", "    public BlockRenderType getRenderType(BlockState state) {\n        return BlockRenderType.MODEL;\n    }\n\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/CrossedFenceBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.BlockRegistry;\nimport net.minecraft.block.*;\nimport net.minecraft.block.enums.Instrument;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.fluid.FluidState;\nimport net.minecraft.fluid.Fluids;\nimport net.minecraft.item.ItemPlacementContext;", "import net.minecraft.fluid.Fluids;\nimport net.minecraft.item.ItemPlacementContext;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.state.StateManager;\nimport net.minecraft.state.property.BooleanProperty;\nimport net.minecraft.state.property.Properties;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.ItemScatterer;", "import net.minecraft.util.Hand;\nimport net.minecraft.util.ItemScatterer;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.util.shape.VoxelShapes;\nimport net.minecraft.world.BlockView;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldAccess;", "import net.minecraft.world.World;\nimport net.minecraft.world.WorldAccess;\nimport org.jetbrains.annotations.Nullable;\n\npublic class CrossedFenceBlock extends Block implements Waterloggable {\n    public static final BooleanProperty WATERLOGGED = Properties.WATERLOGGED;\n    public final BlockMember member;\n\n    public CrossedFenceBlock(BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().strength(1.5F,1F));\n        this.setDefaultState(this.getDefaultState().with(WATERLOGGED, false));\n        this.member = member;\n    }\n\n    @Override", "        this.setDefaultState(this.getDefaultState().with(WATERLOGGED, false));\n        this.member = member;\n    }\n\n    @Override\n    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {\n        ItemStack stack = player.getStackInHand(hand);\n        Block fenceBlock = BlockRegistry.get(member.fence());\n        ItemStack fenceStack = new ItemStack(fenceBlock, 1);\n        if (stack.isEmpty()) {\n            if (!player.isCreative()) {", "        if (stack.isEmpty()) {\n            if (!player.isCreative()) {\n                if (!player.getInventory().insertStack(fenceStack)) {\n                    ItemScatterer.spawn(world, pos.getX(), pos.getY(), pos.getZ(), fenceStack);\n                }\n            }\n            world.setBlockState(pos, BlockRegistry.get(member.fence()).getDefaultState().with(SimpleFenceBlock.FACING, player.getHorizontalFacing()), Block.NOTIFY_ALL);\n            return ActionResult.SUCCESS;\n        }\n        return super.onUse(state, world, pos, player, hand, hit);\n    }\n\n    @Override\n    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {\n        builder.add(WATERLOGGED);\n    }\n\n    @Override", "    public BlockState getPlacementState(ItemPlacementContext ctx) {\n        World worldAccess = ctx.getWorld();\n        boolean bl = worldAccess.getFluidState(ctx.getBlockPos()).getFluid() == Fluids.WATER;\n        return this.getDefaultState().with(WATERLOGGED, bl);\n    }\n\n    @Nullable\n    @Override\n    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override", "    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {\n        if (state.get(WATERLOGGED)) {\n            world.scheduleFluidTick(pos, Fluids.WATER, Fluids.WATER.getTickRate(world));\n        }\n        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);\n    }\n\n    @Override\n    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return VoxelShapes.union(SimpleFenceBlock.createShape(true), SimpleFenceBlock.createShape(false));\n    }\n\n    @Override", "    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return VoxelShapes.union(SimpleFenceBlock.createShape(true), SimpleFenceBlock.createShape(false));\n    }\n\n    @Override\n    public FluidState getFluidState(BlockState state) {\n        return state.get(WATERLOGGED) ? Fluids.WATER.getStill(false) : super.getFluidState(state);\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/WoodenRaftBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.enums.Instrument;\nimport net.minecraft.server.world.ServerWorld;\nimport net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.util.math.BlockPos;", "import net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.util.math.BlockPos;\n\npublic class WoodenRaftBlock extends RaftBlock {\n\n    public WoodenRaftBlock(BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().strength(1.5F,1F), member);\n    }\n\n    @Override\n    public boolean hasRandomTicks(BlockState state) {\n        return state.get(WATERLOGGED);\n    }\n\n    @Override", "    public boolean hasRandomTicks(BlockState state) {\n        return state.get(WATERLOGGED);\n    }\n\n    @Override\n    public void randomTick(BlockState state, ServerWorld world, BlockPos pos, net.minecraft.util.math.random.Random random) {\n        if (world.hasRain(pos.up()) && world.random.nextBoolean()) {\n            world.setBlockState(pos, BlockRegistry.get(member.brokenRaft()).getDefaultState(), Block.NOTIFY_ALL);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/BrokenRaftBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.init.BlockRegistry;\nimport committee.nova.flotage.util.BlockMember;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.ShapeContext;\nimport net.minecraft.block.enums.Instrument;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.item.ItemStack;", "import net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.util.shape.VoxelShapes;\nimport net.minecraft.world.BlockView;", "import net.minecraft.util.shape.VoxelShapes;\nimport net.minecraft.world.BlockView;\nimport net.minecraft.world.World;\n\npublic class BrokenRaftBlock extends RaftBlock {\n    public BrokenRaftBlock( BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().noCollision().strength(1.5F,1F), member);\n    }\n\n    @Override\n    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {\n        ItemStack stack = player.getStackInHand(hand);", "    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {\n        ItemStack stack = player.getStackInHand(hand);\n        if (stack.getItem() == member.repairBlock.asItem()) {\n            Boolean property = world.getBlockState(hit.getBlockPos()).get(WATERLOGGED);\n            world.setBlockState(pos, BlockRegistry.get(member.raft()).getDefaultState().with(WATERLOGGED, property), Block.NOTIFY_ALL);\n            if (!player.isCreative() && world.random.nextFloat() < 0.3f)\n                stack.decrement(1);\n            return ActionResult.success(world.isClient);\n        }\n        return super.onUse(state, world, pos, player, hand, hit);\n    }\n\n    @Override", "    public VoxelShape getCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return VoxelShapes.empty();\n    }\n}\n"]}
{"filename": "src/main/java/committee/nova/flotage/impl/block/RackBlock.java", "chunked_list": ["package committee.nova.flotage.impl.block;\n\nimport committee.nova.flotage.impl.tile.RackBlockEntity;\nimport committee.nova.flotage.util.BlockMember;\nimport committee.nova.flotage.init.TileRegistry;\nimport net.minecraft.block.*;\nimport net.minecraft.block.entity.BlockEntity;\nimport net.minecraft.block.entity.BlockEntityTicker;\nimport net.minecraft.block.entity.BlockEntityType;\nimport net.minecraft.block.enums.Instrument;", "import net.minecraft.block.entity.BlockEntityType;\nimport net.minecraft.block.enums.Instrument;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.inventory.Inventory;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.server.world.ServerWorld;\nimport net.minecraft.sound.BlockSoundGroup;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.ItemScatterer;", "import net.minecraft.util.Hand;\nimport net.minecraft.util.ItemScatterer;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.shape.VoxelShape;\nimport net.minecraft.util.shape.VoxelShapes;\nimport net.minecraft.world.BlockView;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldView;\nimport org.jetbrains.annotations.Nullable;", "import net.minecraft.world.WorldView;\nimport org.jetbrains.annotations.Nullable;\n\npublic class RackBlock extends BlockWithEntity implements BlockEntityProvider {\n    public final BlockMember member;\n\n    public RackBlock(BlockMember member) {\n        super(Settings.create().instrument(Instrument.BASS).sounds(BlockSoundGroup.WOOD).burnable().strength(1.5F,1F));\n        this.member = member;\n    }\n\n    @Override", "    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult result) {\n        if (!(world.getBlockEntity(pos) instanceof RackBlockEntity tile))\n            return ActionResult.PASS;\n\n        ItemStack handStack = player.getStackInHand(hand);\n        ItemStack storedStack = tile.getItem();\n        tile.setItemDirection(player.getHorizontalFacing());\n        if (handStack.isEmpty() && storedStack.isEmpty()) {\n            return ActionResult.PASS;\n        } else if (handStack.isEmpty()) {\n            if (!player.getInventory().insertStack(tile.getItem())) {\n                tile.inventoryChanged();\n                ItemScatterer.spawn(world, pos.getX(), pos.getY(), pos.getZ(), tile.getItem());\n            }\n            return ActionResult.success(world.isClient());", "        } else if (handStack.isEmpty()) {\n            if (!player.getInventory().insertStack(tile.getItem())) {\n                tile.inventoryChanged();\n                ItemScatterer.spawn(world, pos.getX(), pos.getY(), pos.getZ(), tile.getItem());\n            }\n            return ActionResult.success(world.isClient());\n        }else if (storedStack.isEmpty()) {\n            tile.setStack(0, handStack.split(1));\n            tile.inventoryChanged();\n            return ActionResult.success(world.isClient());\n        }else {", "            if (storedStack.getItem() != handStack.getItem()) {\n                if (!player.getInventory().insertStack(tile.getItem())) {\n                    tile.inventoryChanged();\n                    ItemScatterer.spawn(world, pos.getX(), pos.getY(), pos.getZ(), tile.getItem());\n                }\n                tile.setStack(0, handStack.split(1));\n                tile.inventoryChanged();\n                return ActionResult.success(world.isClient());\n            }\n        }\n        return ActionResult.PASS;\n    }\n\n    @Override", "    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        VoxelShape shape1 = Block.createCuboidShape(0,0,0,1,16,1);\n        VoxelShape shape2 = Block.createCuboidShape(15,0,0,16,16,1);\n        VoxelShape shape3 = Block.createCuboidShape(0,0,15,1,16,16);\n        VoxelShape shape4 = Block.createCuboidShape(15,0,15,16,16,16);\n        VoxelShape shape5 = Block.createCuboidShape(0,14.05,0,16,15.5,16);\n        return VoxelShapes.union(shape1, shape2, shape3, shape4, shape5);\n    }\n\n    @Override\n    public boolean isTransparent(BlockState state, BlockView world, BlockPos pos) {\n        return true;\n    }\n\n    @Nullable\n    @Override", "    public boolean isTransparent(BlockState state, BlockView world, BlockPos pos) {\n        return true;\n    }\n\n    @Nullable\n    @Override\n    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {\n        return new RackBlockEntity(pos, state);\n    }\n\n    @Override", "    public boolean canPlaceAt(BlockState state, WorldView world, BlockPos pos) {\n        return !world.getBlockState(pos.down()).isOf(this);\n    }\n\n    @Override\n    public BlockRenderType getRenderType(BlockState state) {\n        return BlockRenderType.MODEL;\n    }\n\n    @Override\n    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {", "    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {\n        if (state.isOf(newState.getBlock())) {\n            return;\n        }\n        BlockEntity blockEntity = world.getBlockEntity(pos);\n        if (blockEntity instanceof RackBlockEntity) {\n            if (world instanceof ServerWorld) {\n                ItemScatterer.spawn(world, pos, (Inventory) blockEntity);\n            }\n            world.updateComparators(pos, this);\n        }\n        super.onStateReplaced(state, world, pos, newState, moved);\n    }\n\n    @Override", "    public boolean hasComparatorOutput(BlockState state) {\n        return true;\n    }\n\n    @Override\n    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {\n        if (world.getBlockEntity(pos) instanceof RackBlockEntity tile) {\n            return  !tile.getItem().isEmpty() ? 10 : 0;\n        }\n        return super.getComparatorOutput(state, world, pos);\n    }\n\n    @Nullable\n    @Override\n    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(World world, BlockState state, BlockEntityType<T> type) {\n        return RackBlock.checkType(world, type, TileRegistry.RACK_BLOCK_ENTITY);\n    }\n\n    @Nullable\n    protected static <T extends BlockEntity> BlockEntityTicker<T> checkType(World world, BlockEntityType<T> givenType, BlockEntityType<? extends RackBlockEntity> expectedType) {\n        return world.isClient ? null : RackBlock.checkType(givenType, expectedType, RackBlockEntity::tick);\n    }\n}\n"]}
