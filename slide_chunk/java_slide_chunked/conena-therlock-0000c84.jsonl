{"filename": "therlock/src/main/java/com/conena/therlock/ThreadAccessor.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Used to allow the {@link BlockedThreadDetector} to post a {@link Runnable} on the monitored thread.\n * In fact, you can also use it to monitor things other than a thread. For example, a thread group.\n */\n@FunctionalInterface\npublic interface ThreadAccessor {\n\n    /**\n     * Post the provided {@link Runnable} on the monitored thread.\n     *\n     * @param runnable The runnable with the code that the BlockedThreadDetector\n     *                 uses to determine if the thread is blocked.\n     */\n    void post(@NotNull Runnable runnable);\n\n}", " */\n@FunctionalInterface\npublic interface ThreadAccessor {\n\n    /**\n     * Post the provided {@link Runnable} on the monitored thread.\n     *\n     * @param runnable The runnable with the code that the BlockedThreadDetector\n     *                 uses to determine if the thread is blocked.\n     */\n    void post(@NotNull Runnable runnable);\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/LibraryThreadFactory.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.concurrent.ThreadFactory;\n\n/**\n * Internal class which is used to create the threads used by this library.\n * In practice, each instance is only used to create a single thread.", " * Internal class which is used to create the threads used by this library.\n * In practice, each instance is only used to create a single thread.\n */\nfinal class LibraryThreadFactory implements ThreadFactory {\n\n    /**\n     * The {@link ThreadGroup} for all threads of this library.\n     */\n    @NotNull\n    static final ThreadGroup libraryGroup = new ThreadGroup(\"therlock\");", "    @NotNull\n    static final ThreadGroup libraryGroup = new ThreadGroup(\"therlock\");\n\n    /**\n     * The name of the threads provided by {@link ThreadFactory#newThread(Runnable)}.\n     */\n    @NotNull\n    private final String name;\n\n    /**", "\n    /**\n     * @param threadName The name of the threads provided by {@link ThreadFactory#newThread(Runnable)}.\n     */\n    LibraryThreadFactory(@NotNull String threadName) {\n        super();\n        this.name = threadName;\n    }\n\n    /**", "\n    /**\n     * @return A {@link ThreadFactory} to create the thread used by the {@link BlockedThreadDetector}\n     * to monitor the selected thread.\n     */\n    @NotNull\n    static ThreadFactory createInspectorFactory() {\n        return new LibraryThreadFactory(\"inspector-thread\");\n    }\n", "    }\n\n    /**\n     * @return A {@link ThreadFactory} to create the thread used by the {@link BlockedThreadDetector}\n     * to to report when the monitored thread is blocked.\n     */\n    @NotNull\n    static ThreadFactory createReporterFactory() {\n        return new LibraryThreadFactory(\"reporter-thread\");\n    }", "        return new LibraryThreadFactory(\"reporter-thread\");\n    }\n\n    @Override\n    public Thread newThread(@NotNull Runnable r) {\n        Thread thread = new Thread(libraryGroup, r, name);\n        thread.setDaemon(true);\n        return thread;\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/DaemonThreadFilter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Implementation of {@link ThreadFilter} which filters out daemon threads.\n * It is not necessary to combine this filter with the {@link LibraryThreadFilter},\n * because all library threads are daemon threads.\n */\npublic final class DaemonThreadFilter implements ThreadFilter {\n\n    @Override", " * because all library threads are daemon threads.\n */\npublic final class DaemonThreadFilter implements ThreadFilter {\n\n    @Override\n    public boolean isAllowed(@NotNull Thread thread) {\n        return !thread.isDaemon();\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/ThreadInfo.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n\n/**\n * Provides information about a thread for which a report was requested.\n */\npublic class ThreadInfo extends Throwable {\n\n    /**\n     * The name of the {@link Thread}.\n     *\n     * @see Thread#getName()\n     */\n    @NotNull", " */\npublic class ThreadInfo extends Throwable {\n\n    /**\n     * The name of the {@link Thread}.\n     *\n     * @see Thread#getName()\n     */\n    @NotNull\n    public final String name;\n\n    /**\n     * The name of the {@link ThreadGroup} the thread belongs to.\n     *\n     * @see Thread#getThreadGroup()\n     */\n    @NotNull", "    public final String name;\n\n    /**\n     * The name of the {@link ThreadGroup} the thread belongs to.\n     *\n     * @see Thread#getThreadGroup()\n     */\n    @NotNull\n    public final String groupName;\n\n    /**\n     * The id of the {@link Thread}.\n     *\n     * @see Thread#getId()\n     */", "    public final String groupName;\n\n    /**\n     * The id of the {@link Thread}.\n     *\n     * @see Thread#getId()\n     */\n    public final long id;\n\n    /**\n     * The priority of the {@link Thread}.\n     *\n     * @see Thread#getPriority()\n     */", "    public final int priority;\n\n    /**\n     * The stack trace of the {@link Thread}.\n     *\n     * @see Thread#getStackTrace()\n     */\n    @NotNull\n    public final StackTraceElement @NotNull [] stackTrace;\n\n    /**\n     * @param name       The name of the {@link Thread}.\n     * @param groupName  The name of the {@link ThreadGroup} the thread belongs to.\n     * @param id         The id of the {@link Thread}.\n     * @param priority   The priority of the {@link Thread}.\n     * @param stackTrace The stack trace of the {@link Thread}.\n     */\n    ThreadInfo(\n            @NotNull String name,\n            @NotNull String groupName,\n            long id,\n            int priority,\n            @NotNull StackTraceElement @NotNull [] stackTrace\n    ) {\n        super(String.format(\"Stacktrace of the thread '%s' (id: %d, group: '%s').\", name, id, groupName));\n        setStackTrace(stackTrace);\n        this.name = name;\n        this.groupName = groupName;\n        this.id = id;\n        this.priority = priority;\n        this.stackTrace = stackTrace;\n    }\n\n    /**\n     * Create a {@link ThreadInfo} instance from a {@link Thread}.\n     *\n     * @param thread The thread for which the {@link ThreadInfo} should be created.\n     * @return The created {@link ThreadInfo} instance provides information about the provided thread.\n     */\n    @NotNull\n    static ThreadInfo fromThread(@NotNull Thread thread) {\n        return new ThreadInfo(\n                thread.getName(),\n                thread.getThreadGroup().getName(),\n                thread.getId(),\n                thread.getPriority(),\n                thread.getStackTrace()\n        );\n    }\n\n}", "    public final StackTraceElement @NotNull [] stackTrace;\n\n    /**\n     * @param name       The name of the {@link Thread}.\n     * @param groupName  The name of the {@link ThreadGroup} the thread belongs to.\n     * @param id         The id of the {@link Thread}.\n     * @param priority   The priority of the {@link Thread}.\n     * @param stackTrace The stack trace of the {@link Thread}.\n     */\n    ThreadInfo(\n            @NotNull String name,\n            @NotNull String groupName,\n            long id,\n            int priority,\n            @NotNull StackTraceElement @NotNull [] stackTrace\n    ) {\n        super(String.format(\"Stacktrace of the thread '%s' (id: %d, group: '%s').\", name, id, groupName));\n        setStackTrace(stackTrace);\n        this.name = name;\n        this.groupName = groupName;\n        this.id = id;\n        this.priority = priority;\n        this.stackTrace = stackTrace;\n    }\n\n    /**\n     * Create a {@link ThreadInfo} instance from a {@link Thread}.\n     *\n     * @param thread The thread for which the {@link ThreadInfo} should be created.\n     * @return The created {@link ThreadInfo} instance provides information about the provided thread.\n     */\n    @NotNull\n    static ThreadInfo fromThread(@NotNull Thread thread) {\n        return new ThreadInfo(\n                thread.getName(),\n                thread.getThreadGroup().getName(),\n                thread.getId(),\n                thread.getPriority(),\n                thread.getStackTrace()\n        );\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/BlockedThreadLogWriter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Implementation of {@link BlockedThreadListener} that just prints the\n * {@link BlockedThreadEvent} to the standard error stream.\n */\npublic final class BlockedThreadLogWriter implements BlockedThreadListener {\n\n    @Override", " */\npublic final class BlockedThreadLogWriter implements BlockedThreadListener {\n\n    @Override\n    public void onBlockedThreadDetected(\n            @NotNull BlockedThreadDetector detector,\n            @NotNull BlockedThreadEvent event\n    ) {\n        event.printStackTrace();\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/LibraryThreadFilter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Implementation of {@link ThreadFilter} which filters out the threads created by this library.\n */\npublic final class LibraryThreadFilter implements ThreadFilter {\n\n    @Override", "public final class LibraryThreadFilter implements ThreadFilter {\n\n    @Override\n    public boolean isAllowed(@NotNull Thread thread) {\n        return thread.getThreadGroup() != LibraryThreadFactory.libraryGroup;\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/ThreadFilter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Used for {@link FilteredThreadProvider}.\n */\n@FunctionalInterface\npublic interface ThreadFilter {\n\n    /**\n     * @param thread The thread to check.\n     * @return True if the {@link ThreadFilter} allows the thread. False otherwise.\n     */\n    boolean isAllowed(@NotNull Thread thread);\n\n}", "@FunctionalInterface\npublic interface ThreadFilter {\n\n    /**\n     * @param thread The thread to check.\n     * @return True if the {@link ThreadFilter} allows the thread. False otherwise.\n     */\n    boolean isAllowed(@NotNull Thread thread);\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/ThreadProvider.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Provides the threads for which the {@link BlockedThreadDetector} collects the stack traces\n * once it is detected that the monitored thread is blocked.\n */\n@FunctionalInterface\npublic interface ThreadProvider {\n\n    /**\n     * @return The threads for which the {@link BlockedThreadDetector} collects the stack traces\n     * once it is detected that the monitored thread is blocked.\n     * The order of the threads in the array determines the subsequent order of the\n     * {@link ThreadInfo} objects in {@link BlockedThreadEvent}.\n     */\n    @NotNull\n    Thread @NotNull [] provideThreads();\n\n}", " */\n@FunctionalInterface\npublic interface ThreadProvider {\n\n    /**\n     * @return The threads for which the {@link BlockedThreadDetector} collects the stack traces\n     * once it is detected that the monitored thread is blocked.\n     * The order of the threads in the array determines the subsequent order of the\n     * {@link ThreadInfo} objects in {@link BlockedThreadEvent}.\n     */\n    @NotNull\n    Thread @NotNull [] provideThreads();\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/CombinedDetectionExemption.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * An implementation of {@link DetectionExemption} that accepts multiple DetectionExemptions\n * and affirms an exemption as soon as one of the defined exemptions applies.\n */\npublic class CombinedDetectionExemption implements DetectionExemption {\n\n    /**\n     * The applied {@link DetectionExemption} instances.\n     */\n    @NotNull\n    private final DetectionExemption @NotNull [] exemptions;\n\n    /**\n     * @param exemptions The exemptions that are checked one after the other.\n     */\n    public CombinedDetectionExemption(@NotNull DetectionExemption @NotNull ... exemptions) {\n        this.exemptions = exemptions;\n    }\n\n    @Override", " */\npublic class CombinedDetectionExemption implements DetectionExemption {\n\n    /**\n     * The applied {@link DetectionExemption} instances.\n     */\n    @NotNull\n    private final DetectionExemption @NotNull [] exemptions;\n\n    /**\n     * @param exemptions The exemptions that are checked one after the other.\n     */\n    public CombinedDetectionExemption(@NotNull DetectionExemption @NotNull ... exemptions) {\n        this.exemptions = exemptions;\n    }\n\n    @Override", "    public final boolean isExemptionActive() {\n        for (DetectionExemption exemption : exemptions) {\n            if (exemption.isExemptionActive()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/CombinedThreadFilter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * An implementation of {@link ThreadFilter} that accepts multiple ThreadFilters\n * and allows a thread only if all accepted ThreadFilters allow the thread.\n */\npublic class CombinedThreadFilter implements ThreadFilter {\n\n    /**\n     * The applied {@link ThreadFilter} instances.\n     */\n    @NotNull\n    private final ThreadFilter @NotNull [] filters;\n\n    /**\n     * @param threadFilter The filters that are applied one after the other.\n     */\n    public CombinedThreadFilter(@NotNull ThreadFilter @NotNull ... threadFilter) {\n        this.filters = threadFilter;\n    }\n\n    @Override", " */\npublic class CombinedThreadFilter implements ThreadFilter {\n\n    /**\n     * The applied {@link ThreadFilter} instances.\n     */\n    @NotNull\n    private final ThreadFilter @NotNull [] filters;\n\n    /**\n     * @param threadFilter The filters that are applied one after the other.\n     */\n    public CombinedThreadFilter(@NotNull ThreadFilter @NotNull ... threadFilter) {\n        this.filters = threadFilter;\n    }\n\n    @Override", "    public final boolean isAllowed(@NotNull Thread thread) {\n        for (ThreadFilter filter : filters) {\n            if (!filter.isAllowed(thread)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n"]}
{"filename": "therlock/src/main/java/com/conena/therlock/FilteredThreadProvider.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Arrays;\n\n/**\n * Implementation of {@link ThreadProvider} that provides all active threads sorted by their id", "/**\n * Implementation of {@link ThreadProvider} that provides all active threads sorted by their id\n * which match an optional {@link ThreadFilter}.\n */\npublic final class FilteredThreadProvider extends ActiveThreadProvider {\n\n    /**\n     * The {@link ThreadFilter} to use.\n     */\n    @NotNull\n    private final ThreadFilter threadFilter;\n\n    /**\n     * @param filter The {@link ThreadFilter} to use. You can use {@link CombinedThreadFilter}\n     *               to combine multiple filter.\n     * @see CombinedThreadFilter\n     * @see DaemonThreadFilter\n     * @see LibraryThreadFilter\n     * @see PriorityThreadFilter\n     */\n    public FilteredThreadProvider(@NotNull ThreadFilter filter) {\n        threadFilter = filter;\n    }\n\n    /**\n     * @return All active threads that match the applied {@link ThreadFilter} sorted by id.\n     */\n    @NotNull\n    @Override\n    public Thread @NotNull [] provideThreads() {\n        Thread[] activeThreads = super.provideThreads();\n        Thread[] filteredThreads = new Thread[activeThreads.length];\n        int threadCount = 0;", "        for (Thread thread : activeThreads) {\n            if (threadFilter.isAllowed(thread)) {\n                filteredThreads[threadCount++] = thread;\n            }\n        }\n        return Arrays.copyOf(filteredThreads, threadCount);\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/BlockedThreadDetectorBuilder.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * Build a {@link BlockedThreadDetector} instance.\n */\npublic class BlockedThreadDetectorBuilder {\n\n    /**\n     * Used to post {@link Runnable} instances on the monitored thread.\n     */\n    @NotNull\n    private final ThreadAccessor threadAccessor;\n\n    /**\n     * Provides the threads that are included in the {@link BlockedThreadEvent},\n     * with the current stack trace, in the order provided by the {@link ThreadProvider}, in the detection case.\n     */\n    @Nullable\n    private ThreadProvider threadProvider;\n\n    /**\n     * To receive {@link BlockedThreadEvent} instances.\n     * The listener is called on a separate background thread.\n     */\n    @Nullable\n    private BlockedThreadListener listener;\n\n    /**\n     * Defines an exemption when a thread should not be considered as blocked.\n     * Can be used e.g. to create an exemption for debuggers.\n     * This does not stop monitoring, it only suppresses reporting.\n     */\n    @Nullable\n    private DetectionExemption exemption;\n\n    /**\n     * The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent} to be triggered.\n     */\n    @Nullable\n    private Long threshold;\n\n    /**\n     * The interval in milliseconds in which it is checked whether a thread is blocked.\n     */\n    @Nullable\n    private Long inspectionInterval;\n\n    /**\n     * @param threadAccessor Used to post {@link Runnable} instances on the monitored thread.\n     */\n    public BlockedThreadDetectorBuilder(@NotNull ThreadAccessor threadAccessor) {\n        this.threadAccessor = threadAccessor;\n    }\n\n    /**\n     * @param threadProvider If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve\n     *                       the threads for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     *                       The sort order of the returned threads will also be the order of the corresponding\n     *                       stack traces in the {@link BlockedThreadEvent}.\n     * @return A reference to this instance.\n     * @see ActiveThreadProvider\n     * @see FilteredThreadProvider\n     * @see PredefinedThreadProvider\n     */\n    @NotNull", " */\npublic class BlockedThreadDetectorBuilder {\n\n    /**\n     * Used to post {@link Runnable} instances on the monitored thread.\n     */\n    @NotNull\n    private final ThreadAccessor threadAccessor;\n\n    /**\n     * Provides the threads that are included in the {@link BlockedThreadEvent},\n     * with the current stack trace, in the order provided by the {@link ThreadProvider}, in the detection case.\n     */\n    @Nullable\n    private ThreadProvider threadProvider;\n\n    /**\n     * To receive {@link BlockedThreadEvent} instances.\n     * The listener is called on a separate background thread.\n     */\n    @Nullable\n    private BlockedThreadListener listener;\n\n    /**\n     * Defines an exemption when a thread should not be considered as blocked.\n     * Can be used e.g. to create an exemption for debuggers.\n     * This does not stop monitoring, it only suppresses reporting.\n     */\n    @Nullable\n    private DetectionExemption exemption;\n\n    /**\n     * The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent} to be triggered.\n     */\n    @Nullable\n    private Long threshold;\n\n    /**\n     * The interval in milliseconds in which it is checked whether a thread is blocked.\n     */\n    @Nullable\n    private Long inspectionInterval;\n\n    /**\n     * @param threadAccessor Used to post {@link Runnable} instances on the monitored thread.\n     */\n    public BlockedThreadDetectorBuilder(@NotNull ThreadAccessor threadAccessor) {\n        this.threadAccessor = threadAccessor;\n    }\n\n    /**\n     * @param threadProvider If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve\n     *                       the threads for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     *                       The sort order of the returned threads will also be the order of the corresponding\n     *                       stack traces in the {@link BlockedThreadEvent}.\n     * @return A reference to this instance.\n     * @see ActiveThreadProvider\n     * @see FilteredThreadProvider\n     * @see PredefinedThreadProvider\n     */\n    @NotNull", "    public BlockedThreadDetectorBuilder setThreadProvider(@NotNull ThreadProvider threadProvider) {\n        this.threadProvider = threadProvider;\n        return this;\n    }\n\n    /**\n     * @param listener To receive {@link BlockedThreadEvent} instances.\n     *                 The listener is called on a separate background thread.\n     * @return A reference to this instance.\n     */\n    @NotNull", "    public BlockedThreadDetectorBuilder setListener(@NotNull BlockedThreadListener listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    /**\n     * @param exemption Defines an exemption when a thread should not be considered as blocked.\n     *                  Can be used e.g. to create an exemption for debuggers.\n     *                  This does not stop monitoring, it only suppresses reporting.\n     * @return A reference to this instance.\n     */\n    @NotNull", "    public BlockedThreadDetectorBuilder setExemption(@NotNull DetectionExemption exemption) {\n        this.exemption = exemption;\n        return this;\n    }\n\n    /**\n     * @param threshold The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent} to be triggered.\n     * @return A reference to this instance.\n     */\n    @NotNull\n    public BlockedThreadDetectorBuilder setThreshold(long threshold) {\n        this.threshold = threshold;\n        return this;\n    }\n\n    /**\n     * @param interval The interval in milliseconds in which it is checked whether a thread is blocked.\n     * @return A reference to this instance.\n     */\n    @NotNull", "    public BlockedThreadDetectorBuilder setThreshold(long threshold) {\n        this.threshold = threshold;\n        return this;\n    }\n\n    /**\n     * @param interval The interval in milliseconds in which it is checked whether a thread is blocked.\n     * @return A reference to this instance.\n     */\n    @NotNull\n    public BlockedThreadDetectorBuilder setInspectionInterval(long interval) {\n        this.inspectionInterval = interval;\n        return this;\n    }\n\n    /**\n     * Build a {@link BlockedThreadDetector} with the parameters supplied to the builder methods.\n     * If {@link #setThreadProvider(ThreadProvider)} was not called, a {@link FilteredThreadProvider}\n     * with a {@link DaemonThreadFilter} will be used.\n     * If {@link #setListener(BlockedThreadListener)} was not called a {@link BlockedThreadLogWriter} will be used.\n     * If {@link #setThreshold(long)} was not called 1000 milliseconds will be used.\n     * If {@link #setInspectionInterval(long)} was not called, one fifth of the threshold value, but at least 100 ms and at most 500ms, is used.\n     *\n     * @return The created {@link BlockedThreadDetector}.\n     */\n    @NotNull", "    public BlockedThreadDetectorBuilder setInspectionInterval(long interval) {\n        this.inspectionInterval = interval;\n        return this;\n    }\n\n    /**\n     * Build a {@link BlockedThreadDetector} with the parameters supplied to the builder methods.\n     * If {@link #setThreadProvider(ThreadProvider)} was not called, a {@link FilteredThreadProvider}\n     * with a {@link DaemonThreadFilter} will be used.\n     * If {@link #setListener(BlockedThreadListener)} was not called a {@link BlockedThreadLogWriter} will be used.\n     * If {@link #setThreshold(long)} was not called 1000 milliseconds will be used.\n     * If {@link #setInspectionInterval(long)} was not called, one fifth of the threshold value, but at least 100 ms and at most 500ms, is used.\n     *\n     * @return The created {@link BlockedThreadDetector}.\n     */\n    @NotNull", "    public BlockedThreadDetector build() {\n        long threshold = this.threshold == null ? 1_000L : this.threshold;\n        return new BlockedThreadDetector(\n                threadAccessor,\n                threadProvider == null ? new FilteredThreadProvider(new DaemonThreadFilter()) : threadProvider,\n                listener == null ? new BlockedThreadLogWriter() : listener,\n                exemption,\n                threshold,\n                inspectionInterval == null ? Math.min(500L, Math.max(100L, threshold / 5L)) : inspectionInterval\n        );\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/PriorityThreadFilter.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Implementation of {@link ThreadFilter} which filters out threads by priority.\n */\npublic final class PriorityThreadFilter implements ThreadFilter {\n\n    /**\n     * The minimum priority for threads that this filter accepts.\n     */\n    private final int minPriority;\n\n    /**\n     * The maximum priority for threads that this filter accepts.\n     */\n    private final int maxPriority;\n\n    /**\n     * @param minPriority The minimum priority for threads that this filter accepts.\n     * @see Thread#MIN_PRIORITY\n     */\n    public PriorityThreadFilter(int minPriority) {\n        this(minPriority, Thread.MAX_PRIORITY);\n    }\n\n    /**\n     * @param minPriority The minimum priority for threads that this filter accepts.\n     * @param maxPriority The maximum priority for threads that this filter accepts.\n     * @see Thread#MIN_PRIORITY\n     * @see Thread#MAX_PRIORITY\n     */\n    public PriorityThreadFilter(int minPriority, int maxPriority) {\n        this.minPriority = minPriority;\n        this.maxPriority = maxPriority;\n    }\n\n    @Override", "public final class PriorityThreadFilter implements ThreadFilter {\n\n    /**\n     * The minimum priority for threads that this filter accepts.\n     */\n    private final int minPriority;\n\n    /**\n     * The maximum priority for threads that this filter accepts.\n     */\n    private final int maxPriority;\n\n    /**\n     * @param minPriority The minimum priority for threads that this filter accepts.\n     * @see Thread#MIN_PRIORITY\n     */\n    public PriorityThreadFilter(int minPriority) {\n        this(minPriority, Thread.MAX_PRIORITY);\n    }\n\n    /**\n     * @param minPriority The minimum priority for threads that this filter accepts.\n     * @param maxPriority The maximum priority for threads that this filter accepts.\n     * @see Thread#MIN_PRIORITY\n     * @see Thread#MAX_PRIORITY\n     */\n    public PriorityThreadFilter(int minPriority, int maxPriority) {\n        this.minPriority = minPriority;\n        this.maxPriority = maxPriority;\n    }\n\n    @Override", "    public boolean isAllowed(@NotNull Thread thread) {\n        return thread.getPriority() >= minPriority && thread.getPriority() <= maxPriority;\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/DetectionExemption.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\n/**\n * Defines an exemption when a thread should not be considered as blocked.\n * Can be used e.g. to create an exemption for debuggers.\n * This does not stop monitoring, it only suppresses reporting.\n */\n@FunctionalInterface\npublic interface DetectionExemption {\n\n    /**\n     * @return True if the exception rule is active and a blocked thread should not currently be reported.\n     */\n    boolean isExemptionActive();\n\n}", "@FunctionalInterface\npublic interface DetectionExemption {\n\n    /**\n     * @return True if the exception rule is active and a blocked thread should not currently be reported.\n     */\n    boolean isExemptionActive();\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/PredefinedThreadProvider.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * {@link ThreadProvider} implementation that provides a predefined array of threads.\n */\npublic class PredefinedThreadProvider implements ThreadProvider {\n\n    /**\n     * The threads to provide.\n     */\n    @NotNull\n    private final Thread @NotNull [] threads;\n\n    /**\n     * @param threads The threads to provide.\n     */\n    public PredefinedThreadProvider(@NotNull Thread @NotNull ... threads) {\n        this.threads = threads;\n    }\n\n    @Override\n    public final @NotNull Thread @NotNull [] provideThreads() {\n        return threads.clone();\n    }\n\n}", "public class PredefinedThreadProvider implements ThreadProvider {\n\n    /**\n     * The threads to provide.\n     */\n    @NotNull\n    private final Thread @NotNull [] threads;\n\n    /**\n     * @param threads The threads to provide.\n     */\n    public PredefinedThreadProvider(@NotNull Thread @NotNull ... threads) {\n        this.threads = threads;\n    }\n\n    @Override\n    public final @NotNull Thread @NotNull [] provideThreads() {\n        return threads.clone();\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/BlockedThreadEvent.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Provides information about an event where the monitored thread was blocked.\n * This class inherits from Throwable for the sole purpose of making it compatible\n * with various bug reporting tools as well as making the event easy to display in the log.", " * This class inherits from Throwable for the sole purpose of making it compatible\n * with various bug reporting tools as well as making the event easy to display in the log.\n * {@link #getStackTrace()} shows all threads returned by the {@link ThreadProvider} for which a stack trace is available.\n * The order corresponds to the order in which {@link ThreadProvider#provideThreads()} has returned the threads.\n * Depending on the configuration of the {@link ThreadProvider},\n * it is therefore possible that the stack trace has nothing at all to do with the blocked thread.\n * Avoiding this is the responsibility of the implementer.\n * Also, don't get confused by the \"Caused by\" in the stack trace.\n * The order of the causes is given by the {@link ThreadProvider}, the caused by has no meaning and can be ignored.\n */\npublic final class BlockedThreadEvent extends Throwable {\n\n    /**\n     * The duration in milliseconds for which the monitored thread was blocked.\n     */", " * The order of the causes is given by the {@link ThreadProvider}, the caused by has no meaning and can be ignored.\n */\npublic final class BlockedThreadEvent extends Throwable {\n\n    /**\n     * The duration in milliseconds for which the monitored thread was blocked.\n     */\n    public final long blockedDuration;\n\n    /**\n     * Information about the threads that should be reported at the moment when the monitored thread was blocked.\n     */\n    @NotNull", "    public final ThreadInfo @NotNull [] threadInfos;\n\n    /**\n     * @param blockedDuration The duration in milliseconds for which the monitored thread was blocked.\n     * @param threadInfos     Information about the threads that should be reported at the moment when the monitored thread was blocked.\n     */\n    BlockedThreadEvent(long blockedDuration, @NotNull ThreadInfo @NotNull [] threadInfos) {\n        super(\"The monitored thread was blocked for at least \" + blockedDuration + \" milliseconds. The stack trace contains the stack traces of all threads selected for reporting. Please refer to the documentation when interpreting the stack traces.\");\n        setStackTrace(new StackTraceElement[0]);\n        Throwable lastProcessed = this;\n        for (ThreadInfo threadInfo : threadInfos) {\n            lastProcessed.initCause(threadInfo);\n            lastProcessed = threadInfo;\n        }\n        this.blockedDuration = blockedDuration;\n        this.threadInfos = threadInfos;\n    }\n\n}", "        for (ThreadInfo threadInfo : threadInfos) {\n            lastProcessed.initCause(threadInfo);\n            lastProcessed = threadInfo;\n        }\n        this.blockedDuration = blockedDuration;\n        this.threadInfos = threadInfos;\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/BlockedThreadListener.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Listener that is notified when a blocked thread was detected.\n */\n@FunctionalInterface\npublic interface BlockedThreadListener {\n\n    /**\n     * Called when a blocked thread was detected.\n     *\n     * @param event Information about the event.\n     */\n    void onBlockedThreadDetected(\n            @NotNull BlockedThreadDetector detector,\n            @NotNull BlockedThreadEvent event\n    );\n\n}", "@FunctionalInterface\npublic interface BlockedThreadListener {\n\n    /**\n     * Called when a blocked thread was detected.\n     *\n     * @param event Information about the event.\n     */\n    void onBlockedThreadDetected(\n            @NotNull BlockedThreadDetector detector,\n            @NotNull BlockedThreadEvent event\n    );\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/ActiveThreadProvider.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\n/**", "\n/**\n * Implementation of {@link ThreadProvider} that provides all active threads sorted by their id.\n */\npublic class ActiveThreadProvider implements ThreadProvider {\n\n    /**\n     * Compare {@link Thread} instances by their id.\n     */\n    // Comparator.comparingLong would break compatibility with older android versions.\n    // https://developer.android.com/reference/java/util/Comparator#comparingLong(java.util.function.ToLongFunction%3C?%20super%20T%3E)\n    @SuppressWarnings(\"ComparatorCombinators\")\n    @NotNull\n    private final static Comparator<Thread> threadIdComparator = (Thread t1, Thread t2) ->\n            Long.compare(t1.getId(), t2.getId());\n\n    /**\n     * @return All active threads sorted by id.\n     */\n    @NotNull\n    @Override\n    public Thread @NotNull [] provideThreads() {\n        ThreadGroup root = getRootThreadGroup();\n        Thread[] threadHolder = new Thread[root.activeCount() * 2];\n        Thread[] threadArray = Arrays.copyOf(threadHolder, root.enumerate(threadHolder));\n        Arrays.sort(threadArray, threadIdComparator);\n        return threadArray;\n    }\n\n    /**\n     * @return The root {@link ThreadGroup} that all other groups belong to.\n     */\n    @NotNull\n    private ThreadGroup getRootThreadGroup() {\n        ThreadGroup group = getCurrentThreadGroup();\n        ThreadGroup parent = group.getParent();", "        while (parent != null) {\n            group = parent;\n            parent = group.getParent();\n        }\n        return group;\n    }\n\n    /**\n     * @return The {@link ThreadGroup} the current thread belongs to.\n     */\n    @NotNull\n    private ThreadGroup getCurrentThreadGroup() {\n        return Thread.currentThread().getThreadGroup();\n    }\n\n}"]}
{"filename": "therlock/src/main/java/com/conena/therlock/BlockedThreadDetector.java", "chunked_list": ["/*\n * Copyright (C) 2023 Fabian Andera\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage com.conena.therlock;", "\npackage com.conena.therlock;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Arrays;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;", "import java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\n/**\n * Used to detect blocked threads.\n * This does not necessarily mean threads in the {@link Thread.State#BLOCKED} state,\n * but that a thread that is intended to constantly accept tasks is no longer\n * capable of executing new tasks for a specified period of time.\n */\npublic class BlockedThreadDetector {\n\n    /**\n     * Used to post {@link Runnable} instances on the monitored thread.\n     */\n    @NotNull\n    private final ThreadAccessor threadAccessor;\n\n    /**\n     * If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve the threads\n     * for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     * The sort order of the returned threads will also be the order of the corresponding\n     * stack traces in the {@link BlockedThreadEvent}.\n     */\n    @NotNull\n    private final ThreadProvider threadProvider;\n\n    /**\n     * To receive {@link BlockedThreadEvent} instances.\n     * The listener is called on a separate background thread.\n     */\n    @NotNull\n    private final BlockedThreadListener listener;\n\n    /**\n     * Defines an exemption when a thread should not be considered as blocked.\n     * Can be used e.g. to create an exemption for debuggers.\n     * This does not stop monitoring, it only suppresses reporting.\n     */\n    @Nullable\n    private final DetectionExemption exemption;\n\n    /**\n     * The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent} to be triggered.\n     */\n    private final long threshold;\n\n    /**\n     * The interval in milliseconds in which it is checked whether a thread is blocked.\n     */\n    private final long inspectionInterval;\n\n    /**\n     * Used to ping the monitored thread on a regular basis.\n     */\n    @NotNull\n    private final ScheduledExecutorService inspectionService = Executors.newSingleThreadScheduledExecutor(\n            LibraryThreadFactory.createInspectorFactory()\n    );\n\n    /**\n     * Used to report {@link BlockedThreadEvent}s to the listener.\n     */\n    @NotNull\n    private final ExecutorService reportService = Executors.newSingleThreadExecutor(\n            LibraryThreadFactory.createReporterFactory()\n    );\n\n    /**\n     * The time in milliseconds how long the monitored thread has been blocked.\n     */\n    private final AtomicLong blockingTime = new AtomicLong();\n\n    /**\n     * If the current {@link BlockedThreadEvent} has already been reported to the listener.\n     */\n    private final AtomicBoolean reported = new AtomicBoolean();\n\n    /**\n     * A Future that represents the Inspection Task.\n     */\n    @Nullable\n    private ScheduledFuture<?> inspectionTask = null;\n\n    /**\n     * @param threadAccessor     Used to post {@link Runnable} instances on the monitored thread.\n     * @param threadProvider     If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve\n     *                           the threads for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     *                           The sort order of the returned threads will also be the order of the corresponding\n     *                           stack traces in the {@link BlockedThreadEvent}.\n     * @param listener           To receive {@link BlockedThreadEvent} instances.\n     *                           The listener is called on a separate background thread.\n     * @param exemption          Defines an exemption when a thread should not be considered as blocked.\n     *                           Can be used e.g. to create an exemption for debuggers.\n     *                           This does not stop monitoring, it only suppresses reporting.\n     * @param threshold          The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent}\n     *                           to be triggered.\n     * @param inspectionInterval The interval in milliseconds in which it is checked whether\n     *                           a thread is blocked. Together with the threshold this value decides if and how soon\n     *                           blocked threads are detected.\n     */\n    public BlockedThreadDetector(\n            @NotNull ThreadAccessor threadAccessor,\n            @NotNull ThreadProvider threadProvider,\n            @NotNull BlockedThreadListener listener,\n            @Nullable DetectionExemption exemption,\n            long threshold,\n            long inspectionInterval\n    ) {\n        this.threadAccessor = threadAccessor;\n        this.threadProvider = threadProvider;\n        this.listener = listener;\n        this.exemption = exemption;\n        this.threshold = threshold;\n        this.inspectionInterval = inspectionInterval;\n    }\n\n    /**\n     * Start the detector. If it is already running, the method just returns.\n     *\n     * @return The current instance to chain multiple calls.\n     */", " */\npublic class BlockedThreadDetector {\n\n    /**\n     * Used to post {@link Runnable} instances on the monitored thread.\n     */\n    @NotNull\n    private final ThreadAccessor threadAccessor;\n\n    /**\n     * If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve the threads\n     * for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     * The sort order of the returned threads will also be the order of the corresponding\n     * stack traces in the {@link BlockedThreadEvent}.\n     */\n    @NotNull\n    private final ThreadProvider threadProvider;\n\n    /**\n     * To receive {@link BlockedThreadEvent} instances.\n     * The listener is called on a separate background thread.\n     */\n    @NotNull\n    private final BlockedThreadListener listener;\n\n    /**\n     * Defines an exemption when a thread should not be considered as blocked.\n     * Can be used e.g. to create an exemption for debuggers.\n     * This does not stop monitoring, it only suppresses reporting.\n     */\n    @Nullable\n    private final DetectionExemption exemption;\n\n    /**\n     * The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent} to be triggered.\n     */\n    private final long threshold;\n\n    /**\n     * The interval in milliseconds in which it is checked whether a thread is blocked.\n     */\n    private final long inspectionInterval;\n\n    /**\n     * Used to ping the monitored thread on a regular basis.\n     */\n    @NotNull\n    private final ScheduledExecutorService inspectionService = Executors.newSingleThreadScheduledExecutor(\n            LibraryThreadFactory.createInspectorFactory()\n    );\n\n    /**\n     * Used to report {@link BlockedThreadEvent}s to the listener.\n     */\n    @NotNull\n    private final ExecutorService reportService = Executors.newSingleThreadExecutor(\n            LibraryThreadFactory.createReporterFactory()\n    );\n\n    /**\n     * The time in milliseconds how long the monitored thread has been blocked.\n     */\n    private final AtomicLong blockingTime = new AtomicLong();\n\n    /**\n     * If the current {@link BlockedThreadEvent} has already been reported to the listener.\n     */\n    private final AtomicBoolean reported = new AtomicBoolean();\n\n    /**\n     * A Future that represents the Inspection Task.\n     */\n    @Nullable\n    private ScheduledFuture<?> inspectionTask = null;\n\n    /**\n     * @param threadAccessor     Used to post {@link Runnable} instances on the monitored thread.\n     * @param threadProvider     If a blocked thread is detected, the {@link ThreadProvider} is used to retrieve\n     *                           the threads for which a stack trace should be saved in the {@link BlockedThreadEvent}.\n     *                           The sort order of the returned threads will also be the order of the corresponding\n     *                           stack traces in the {@link BlockedThreadEvent}.\n     * @param listener           To receive {@link BlockedThreadEvent} instances.\n     *                           The listener is called on a separate background thread.\n     * @param exemption          Defines an exemption when a thread should not be considered as blocked.\n     *                           Can be used e.g. to create an exemption for debuggers.\n     *                           This does not stop monitoring, it only suppresses reporting.\n     * @param threshold          The minimum time in milliseconds a thread must be blocked for a {@link BlockedThreadEvent}\n     *                           to be triggered.\n     * @param inspectionInterval The interval in milliseconds in which it is checked whether\n     *                           a thread is blocked. Together with the threshold this value decides if and how soon\n     *                           blocked threads are detected.\n     */\n    public BlockedThreadDetector(\n            @NotNull ThreadAccessor threadAccessor,\n            @NotNull ThreadProvider threadProvider,\n            @NotNull BlockedThreadListener listener,\n            @Nullable DetectionExemption exemption,\n            long threshold,\n            long inspectionInterval\n    ) {\n        this.threadAccessor = threadAccessor;\n        this.threadProvider = threadProvider;\n        this.listener = listener;\n        this.exemption = exemption;\n        this.threshold = threshold;\n        this.inspectionInterval = inspectionInterval;\n    }\n\n    /**\n     * Start the detector. If it is already running, the method just returns.\n     *\n     * @return The current instance to chain multiple calls.\n     */", "    public synchronized BlockedThreadDetector startDetection() {\n        return startDetection(0L);\n    }\n\n    /**\n     * Start the detector. If it is already running, the method just returns.\n     *\n     * @param delay An initial delay in milliseconds from when the detection starts.\n     *              Note that {@link #isRunning()} returns true as soon as this method returns,\n     *              regardless of whether the detection is delayed or not.\n     * @return The current instance to chain multiple calls.\n     */", "    public synchronized BlockedThreadDetector startDetection(long delay) {\n        if (isRunning()) {\n            return this;\n        }\n        resetAsync();\n        inspectionTask = inspectionService.scheduleWithFixedDelay(\n                this::checkIfThreadIsBlocked,\n                delay,\n                inspectionInterval,\n                TimeUnit.MILLISECONDS\n        );\n        return this;\n    }\n\n    /**\n     * Stop the detector. If the detector is not running, nothing happens.\n     */", "    public synchronized void stopDetection() {\n        if (inspectionTask != null) {\n            inspectionTask.cancel(false);\n            inspectionTask = null;\n        }\n    }\n\n    /**\n     * @return True if the detector is running.\n     * This is the case as soon as startDetection was called but stopDetection was not yet called.\n     */", "    public synchronized boolean isRunning() {\n        return inspectionTask != null;\n    }\n\n    /**\n     * Recurring task that checks whether the observed thread is blocked and\n     * reports this as soon as the blocking time exceeds the {@link #threshold}.\n     * This method must only be executed in the {@link #inspectionService}.\n     */\n    private void checkIfThreadIsBlocked() {\n        if (exemption != null && exemption.isExemptionActive()) {\n            reset();\n            return;\n        }\n        long blockedSince = blockingTime.getAndAdd(inspectionInterval);", "        if (exemption != null && exemption.isExemptionActive()) {\n            reset();\n            return;\n        }\n        long blockedSince = blockingTime.getAndAdd(inspectionInterval);\n        if (blockedSince == 0L) {\n            threadAccessor.post(this::resetAsync);\n        } else if (blockedSince >= threshold && !reported.getAndSet(true)) {\n            reportBlockedThread(blockedSince);\n        }\n    }\n\n    /**\n     * Reset the {@link #blockingTime} and the {@link #reported} state.\n     * This method must only be executed in the {@link #inspectionService}.\n     */\n    private void reset() {\n        blockingTime.set(0L);\n        reported.set(false);\n    }\n\n    /**\n     * Submits a {@link #reset()} in the {@link #inspectionService}.\n     */\n    private void resetAsync() {\n        inspectionService.submit(this::reset);\n    }\n\n    /**\n     * Reports a {@link BlockedThreadEvent} asynchronously.\n     *\n     * @param blockedFor The time in milliseconds how long the thread is blocked.\n     */\n    private void reportBlockedThread(final long blockedFor) {\n        reportService.submit(() -> {\n            final Thread[] threadsToReport = threadProvider.provideThreads();\n            final ThreadInfo[] threadInfos = new ThreadInfo[threadsToReport.length];\n            int reported = 0;", "            for (Thread thread : threadsToReport) {\n                final ThreadInfo threadInfo = ThreadInfo.fromThread(thread);\n                if (threadInfo.stackTrace.length > 0) {\n                    threadInfos[reported++] = threadInfo;\n                }\n            }\n            listener.onBlockedThreadDetected(\n                    this,\n                    new BlockedThreadEvent(blockedFor, Arrays.copyOf(threadInfos, reported))\n            );\n        });\n    }\n\n}"]}
