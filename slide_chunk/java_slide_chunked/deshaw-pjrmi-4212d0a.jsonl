{"filename": "java/src/test/java/com/deshaw/pjrmi/SourceInjectorTest.java", "chunked_list": ["/*\n * Copyright 2020 D.E. Shaw & Co.  All rights reserved.\n *\n * This software is the confidential and proprietary information\n * of D.E. Shaw & Co. (\"Confidential Information\").  You\n * shall not disclose such Confidential Information and shall use\n * it only in accordance with the terms of the license agreement\n * you entered into with D.E. Shaw & Co.\n */\n", " */\n\npackage com.deshaw.pjrmi;\n\nimport com.deshaw.pjrmi.SourceInjector;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * A unit test suite for the SourceInjector class.\n */\npublic class SourceInjectorTest\n{\n    /**\n     * Our source injector.\n     */\n    private final SourceInjector mySourceInjector = new SourceInjector();\n\n    /**\n     * The interface we'll use for testing.\n     */", "public class SourceInjectorTest\n{\n    /**\n     * Our source injector.\n     */\n    private final SourceInjector mySourceInjector = new SourceInjector();\n\n    /**\n     * The interface we'll use for testing.\n     */\n    public interface SourceInjectorTestHelper\n    {\n        /**\n         * Do something which returns a string!\n         */", "    public interface SourceInjectorTestHelper\n    {\n        /**\n         * Do something which returns a string!\n         */\n        public String doSomething();\n    }\n\n    /**\n     * Test that we can override the interface with dynamically-compiled code.\n     */\n    @Test", "    public void testSourceInjector()\n        throws Throwable\n    {\n        final String className = \"SourceInjectorTest\";\n\n        // Source code to compile\n        final String source =\n            \"public class \" + className + \" \"                                +\n            \"implements \"                                                    +\n            \"com.deshaw.pjrmi.SourceInjectorTest.SourceInjectorTestHelper {\" +\n            \"    public String doSomething() {\"                              +\n            \"        return \\\"Expected output\\\";\"                            +\n            \"    }\"                                                          +\n            \"}\";\n\n        // Compile the class and create an instance\n        @SuppressWarnings(\"unchecked\")\n        final Class<SourceInjectorTestHelper> klass =\n            (Class<SourceInjectorTestHelper>)mySourceInjector.inject(className, source);\n        final SourceInjectorTestHelper testInstance =\n            klass.getDeclaredConstructor().newInstance();\n\n        // Ensure that we have injected the source code successfully\n        assertEquals(testInstance.doSomething(), \"Expected output\");\n\n        // Test that an invalid className is correctly handled", "            \"    public String doSomething() {\"                              +\n            \"        return \\\"Expected output\\\";\"                            +\n            \"    }\"                                                          +\n            \"}\";\n\n        // Compile the class and create an instance\n        @SuppressWarnings(\"unchecked\")\n        final Class<SourceInjectorTestHelper> klass =\n            (Class<SourceInjectorTestHelper>)mySourceInjector.inject(className, source);\n        final SourceInjectorTestHelper testInstance =\n            klass.getDeclaredConstructor().newInstance();\n\n        // Ensure that we have injected the source code successfully\n        assertEquals(testInstance.doSomething(), \"Expected output\");\n\n        // Test that an invalid className is correctly handled", "        try {\n            mySourceInjector.inject(\"invalid \", source);\n\n            fail(\"Invalid class name\");\n        }\n        catch (ClassNotFoundException e) {\n            // This is expected\n        }\n\n        // Test that a mismatch in the given className and class name in the\n        // source code is correctly handled.", "        try {\n            mySourceInjector.inject(\"badClassName\", source);\n\n            fail(\"className and class name in source mismatch\");\n        }\n        catch (ClassNotFoundException e) {\n            // This is expected\n        }\n\n        // Test that invalid source code is correctly handled\n        final String badSource =", "            \"public class SourceInjectorTest \"                               +\n            \"implements \"                                                    +\n            \"com.deshaw.pjrmi.SourceInjectorTest.SourceInjectorTestHelper {\" +\n            \"    public String doSomething() {\"                              +\n            \"        return \\\"I am invalid code\\\";\"                          +\n            \"    }}}\"                                                        +\n            \"}\";\n        try {\n            mySourceInjector.inject(className, badSource);\n\n            fail(\"Invalid source code\");\n        }\n        catch (ClassNotFoundException e) {\n            // This is expected\n        }\n\n        // Test that invalid source code, delimited by the `\\n` character, is\n        // correctly parsed and the problematic line is displayed.\n        final String badSourceWithNewlines =", "            \"public class SourceInjectorTest\\n\"                                +\n            \"implements\\n\"                                                     +\n            \"com.deshaw.pjrmi.SourceInjectorTest.SourceInjectorTestHelper {\\n\" +\n            \"    public String doSomething() {\\n\"                              +\n            \"        return \\\"I am invalid code\\\"\\n;\"                          +\n            \"    }}}\\n\"                                                        +\n            \"}\";\n        try {\n            mySourceInjector.inject(className, badSourceWithNewlines);\n\n            fail(\"Invalid source code, with new lines\");\n        }\n        catch (ClassNotFoundException e) {\n            assertTrue( e.getMessage().contains(\"}}}\"),    e.toString());\n            assertFalse(e.getMessage().contains(\"public\"), e.toString());\n        }\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/pjrmi/MethodUtilTest.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.pjrmi.MethodUtil;\n\nimport java.lang.reflect.Method;\n\nimport org.junit.jupiter.api.Test;\n\nimport static com.deshaw.pjrmi.MethodUtil.compareBySpecificity;\n", "import static com.deshaw.pjrmi.MethodUtil.compareBySpecificity;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n/**\n * Unit tests for the {@link MethodUtil} class.\n */\npublic class MethodUtilTest\n{\n    // Helper classes\n\n    /**\n     * Root interface.\n     */", "public class MethodUtilTest\n{\n    // Helper classes\n\n    /**\n     * Root interface.\n     */\n    public static interface A\n    {\n        // Nothing\n    }\n\n    /**\n     * Sub-interface of {@link A}.\n     */", "    public static interface B\n        extends A\n    {\n        // Nothing\n    }\n\n    /**\n     * Sub-interface of {@link B}.\n     */\n    public static interface C\n        extends B\n    {\n        // Nothing\n    }\n\n    /**\n     * A class with Methods.\n     */", "    public static interface C\n        extends B\n    {\n        // Nothing\n    }\n\n    /**\n     * A class with Methods.\n     */\n    public static class Methods\n    {", "    public static class Methods\n    {\n        public static final Method[] METHODS = Methods.class.getMethods();\n\n        public static final Method o_f_aa;\n        public static final Method o_f_ba;\n        public static final Method o_f_ab;\n\n        public static final Method o_f_ion;\n        public static final Method o_f_nio;\n        public static final Method o_f_oni;\n", "        public static final Method o_f_ion;\n        public static final Method o_f_nio;\n        public static final Method o_f_oni;\n\n        public static final Method o_f_isn;\n        public static final Method o_f_nis;\n        public static final Method o_f_sni;\n\n        public static final Method v_g_n;\n        public static final Method v_g_b;\n        public static final Method v_g_s;", "        public static final Method v_g_n;\n        public static final Method v_g_b;\n        public static final Method v_g_s;\n        public static final Method v_g_i;\n        public static final Method v_g_l;\n        public static final Method v_g_f;\n        public static final Method v_g_d;\n\n        public static final Method v_h_i;\n        public static final Method v_h_I;\n\n        static {", "        public static final Method v_h_i;\n        public static final Method v_h_I;\n\n        static {\n            try {\n                o_f_aa = Methods.class.getMethod(\"f\", A.class, A.class);\n                o_f_ba = Methods.class.getMethod(\"f\", B.class, A.class);\n                o_f_ab = Methods.class.getMethod(\"f\", A.class, B.class);\n\n                o_f_ion = Methods.class.getMethod(\"f\",\n                                                  Integer.class,\n                                                  Object .class,\n                                                  Number .class);\n                o_f_nio = Methods.class.getMethod(\"f\",\n                                                  Number .class,\n                                                  Integer.class,\n                                                  Object .class);\n                o_f_oni = Methods.class.getMethod(\"f\",\n                                                  Object .class,\n                                                  Number .class,\n                                                  Integer.class);\n\n                o_f_isn = Methods.class.getMethod(\"f\",\n                                                  Integer.class,\n                                                  String .class,\n                                                  Number .class);\n                o_f_nis = Methods.class.getMethod(\"f\",\n                                                  Number .class,\n                                                  Integer.class,\n                                                  String .class);\n                o_f_sni = Methods.class.getMethod(\"f\",\n                                                  String .class,\n                                                  Number .class,\n                                                  Integer.class);\n\n                v_g_n = Methods.class.getMethod(\"g\", Number.class);\n                v_g_b = Methods.class.getMethod(\"g\", byte  .class);\n                v_g_s = Methods.class.getMethod(\"g\", Short .class);\n                v_g_i = Methods.class.getMethod(\"g\", int   .class);\n                v_g_l = Methods.class.getMethod(\"g\", Long  .class);\n                v_g_f = Methods.class.getMethod(\"g\", float .class);\n                v_g_d = Methods.class.getMethod(\"g\", Double.class);\n\n                v_h_i = Methods.class.getMethod(\"h\", int    .class);\n                v_h_I = Methods.class.getMethod(\"h\", Integer.class);\n            }\n            catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n            assertNotNull(o_f_aa);\n            assertNotNull(o_f_ab);\n            assertNotNull(o_f_ba);\n\n            assertNotNull(o_f_ion);\n            assertNotNull(o_f_nio);\n            assertNotNull(o_f_oni);\n\n            assertNotNull(o_f_isn);\n            assertNotNull(o_f_nis);\n            assertNotNull(o_f_sni);\n\n            assertNotNull(v_g_n);\n            assertNotNull(v_g_b);\n            assertNotNull(v_g_s);\n            assertNotNull(v_g_i);\n            assertNotNull(v_g_l);\n            assertNotNull(v_g_f);\n            assertNotNull(v_g_d);\n\n            assertNotNull(v_h_i);\n            assertNotNull(v_h_I);\n        }\n\n        // Least to most specific", "        public Object f(A x, A y) { return \"o_f_aa\"; }\n        public Object f(B x, A y) { return \"o_f_ba\"; }\n        public Object f(A x, B y) { return \"o_f_ab\"; }\n\n\n        // Methods with what looks like a circular hierachy, but are actually\n        // all incomparable\n        public Object f(Integer x, String  y, Number  z) { return \"o_f_isn\"; }\n        public Object f(Number  x, Integer y, String  z) { return \"o_f_nis\"; }\n        public Object f(String  x, Number  y, Integer z) { return \"o_f_sni\"; }\n\n        // Ditto, but with inheritance between all the arguments", "        public Object f(Number  x, Integer y, String  z) { return \"o_f_nis\"; }\n        public Object f(String  x, Number  y, Integer z) { return \"o_f_sni\"; }\n\n        // Ditto, but with inheritance between all the arguments\n        public Object f(Integer x, Object  y, Number  z) { return \"o_f_ion\"; }\n        public Object f(Number  x, Integer y, Object  z) { return \"o_f_nio\"; }\n        public Object f(Object  x, Number  y, Integer z) { return \"o_f_oni\"; }\n\n        // Mixing primitives and non-primitives\n        public void g(Number  x) { }\n        public void g(byte    x) { }", "        public void g(Number  x) { }\n        public void g(byte    x) { }\n        public void g(Short   x) { }\n        public void g(int     x) { }\n        public void g(Long    x) { }\n        public void g(float   x) { }\n        public void g(Double  x) { }\n\n        // These are effectively equal for the purposes of specificity\n        public void h(int     x) { }\n        public void h(Integer x) { }\n    }\n\n    /**\n     * A class with more methods, some which which override those in the parent\n     * class.\n     */", "        public void h(int     x) { }\n        public void h(Integer x) { }\n    }\n\n    /**\n     * A class with more methods, some which which override those in the parent\n     * class.\n     */\n    public static class MoreMethods\n        extends Methods\n    {", "    public static class MoreMethods\n        extends Methods\n    {\n        public final Method[] METHODS = MoreMethods.class.getMethods();\n\n        public static final Method s_f_aa;\n        static {\n            try {\n                s_f_aa = MoreMethods.class.getMethod(\"f\", A.class, A.class);\n            }\n            catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n            assertNotNull(s_f_aa);\n        }\n\n        /** Overloaded return type */", "        public String f(A x, A y) { return \"s_f_aa\"; }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Ensure that {@link MethodUtil#compareBySpecificity(Method,Method)} works.\n     */\n    @Test\n    public void testCompare()\n        throws Exception\n    {\n        // Comparing with self\n        assertTrue(compareBySpecificity(Methods    .o_f_aa,     Methods.o_f_aa) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab,     Methods.o_f_ab) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ba,     Methods.o_f_ba) == 0);\n        assertTrue(compareBySpecificity(MoreMethods.s_f_aa, MoreMethods.s_f_aa) == 0);\n\n        // Comparing with others\n        assertTrue(compareBySpecificity(Methods    .o_f_aa, Methods    .o_f_ab)  > 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab, Methods    .o_f_aa)  < 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ba, Methods    .o_f_ab) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab, Methods    .o_f_ba) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_aa, MoreMethods.s_f_aa)  > 0);\n        assertTrue(compareBySpecificity(MoreMethods.s_f_aa, Methods    .o_f_aa)  < 0);\n\n        // Comparing circular-or-not. None of these should be considered\n        // comparable with one another.\n        assertTrue(compareBySpecificity(Methods.o_f_ion, Methods.o_f_nio) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_nio, Methods.o_f_oni) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_oni, Methods.o_f_ion) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_isn, Methods.o_f_nis) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_nis, Methods.o_f_sni) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_sni, Methods.o_f_isn) == 0);\n\n        // Compare primitives and Object types. Remember that we have more\n        // restrictive semantics when it comes to boxed types.\n        //\n        // First, see how everything compares against g(int), in both\n        // directions.\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_n) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_b)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_s) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_l) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_f)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_d) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_b, Methods.v_g_i)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_s, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_l, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_f, Methods.v_g_i)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_d, Methods.v_g_i) == 0);\n        // Now some other things, not covered by the above, which we expect to\n        // be true.\n        assertTrue(compareBySpecificity(Methods.v_g_s, Methods.v_g_n)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_s)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_d, Methods.v_g_n)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_d)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_h_I, Methods.v_h_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_h_i, Methods.v_h_I) == 0);\n    }\n}\n", "    public void testCompare()\n        throws Exception\n    {\n        // Comparing with self\n        assertTrue(compareBySpecificity(Methods    .o_f_aa,     Methods.o_f_aa) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab,     Methods.o_f_ab) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ba,     Methods.o_f_ba) == 0);\n        assertTrue(compareBySpecificity(MoreMethods.s_f_aa, MoreMethods.s_f_aa) == 0);\n\n        // Comparing with others\n        assertTrue(compareBySpecificity(Methods    .o_f_aa, Methods    .o_f_ab)  > 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab, Methods    .o_f_aa)  < 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ba, Methods    .o_f_ab) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_ab, Methods    .o_f_ba) == 0);\n        assertTrue(compareBySpecificity(Methods    .o_f_aa, MoreMethods.s_f_aa)  > 0);\n        assertTrue(compareBySpecificity(MoreMethods.s_f_aa, Methods    .o_f_aa)  < 0);\n\n        // Comparing circular-or-not. None of these should be considered\n        // comparable with one another.\n        assertTrue(compareBySpecificity(Methods.o_f_ion, Methods.o_f_nio) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_nio, Methods.o_f_oni) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_oni, Methods.o_f_ion) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_isn, Methods.o_f_nis) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_nis, Methods.o_f_sni) == 0);\n        assertTrue(compareBySpecificity(Methods.o_f_sni, Methods.o_f_isn) == 0);\n\n        // Compare primitives and Object types. Remember that we have more\n        // restrictive semantics when it comes to boxed types.\n        //\n        // First, see how everything compares against g(int), in both\n        // directions.\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_n) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_b)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_s) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_l) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_f)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_d) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_b, Methods.v_g_i)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_s, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_i, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_l, Methods.v_g_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_g_f, Methods.v_g_i)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_d, Methods.v_g_i) == 0);\n        // Now some other things, not covered by the above, which we expect to\n        // be true.\n        assertTrue(compareBySpecificity(Methods.v_g_s, Methods.v_g_n)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_s)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_g_d, Methods.v_g_n)  < 0);\n        assertTrue(compareBySpecificity(Methods.v_g_n, Methods.v_g_d)  > 0);\n        assertTrue(compareBySpecificity(Methods.v_h_I, Methods.v_h_i) == 0);\n        assertTrue(compareBySpecificity(Methods.v_h_i, Methods.v_h_I) == 0);\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/pjrmi/PJRmiTest.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.pjrmi.PythonFunction;\nimport com.deshaw.pjrmi.PythonMinion;\nimport com.deshaw.pjrmi.PythonMinionProvider;\nimport com.deshaw.pjrmi.PythonObject;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;", "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Unit tests for PJRmi.\n */\npublic class PJRmiTest\n{\n    private static final PythonMinion PYTHON;\n    static {", "        try {\n            PYTHON = PythonMinionProvider.spawn(true);\n            PYTHON.exec(\"import pjrmi\");\n            PYTHON.exec(\"from numpy import int8\");\n        }\n        catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n    }\n\n    /**\n     * Test eval()\n     */\n    @Test", "    public void testPythonEval()\n        throws Throwable\n    {\n        assertEquals(Byte.valueOf((byte)2), PYTHON.eval(\"1 + 1\"));\n        assertEquals(Byte.valueOf((byte)5), PYTHON.eval(\"len('hello')\"));\n    }\n\n    /**\n     * Test invoke().\n     */\n    @Test", "    public void testPythonInvoke()\n        throws Throwable\n    {\n        assertEquals(Byte.valueOf((byte)5), PYTHON.invoke(\"len\", \"hello\"));\n    }\n\n    /**\n     * Test setGlobalVariable().\n     */\n    @Test\n    public void testSetGlobal()\n        throws Throwable\n    {\n        // Put our thread object into Python as a global and attempt to call a\n        // method on it to test that it's there okay\n        final Thread thread = Thread.currentThread();\n        PYTHON.setGlobalVariable(\"global_variable\", thread);\n        assertEquals(thread.getName(), PYTHON.eval(\"global_variable.getName()\"));\n    }\n\n    /**\n     * Test PythonObject.\n     */\n    @Test", "    public void testSetGlobal()\n        throws Throwable\n    {\n        // Put our thread object into Python as a global and attempt to call a\n        // method on it to test that it's there okay\n        final Thread thread = Thread.currentThread();\n        PYTHON.setGlobalVariable(\"global_variable\", thread);\n        assertEquals(thread.getName(), PYTHON.eval(\"global_variable.getName()\"));\n    }\n\n    /**\n     * Test PythonObject.\n     */\n    @Test", "    public void testPythonObject()\n        throws Throwable\n    {\n        // Create a Python class \"C\"\n        final String klass = (\"class C(object):\\n\" +\n                              \"    def __init__(self, i):\\n\" +\n                              \"        self.i = i\\n\" +\n                              \"    def f(self):\\n\" +\n                              \"        return 'FOO'\\n\" +\n                              \"    def g(self):\\n\" +\n                              \"        raise ValueError('BAR')\\n\" +\n                              \"    def h(self, lst):\\n\" +\n                              \"        lst.get(0)\\n\" +\n                              \"    def c(self, i):\\n\" +\n                              \"        return C(self.i + i)\");\n        PYTHON.exec(klass);\n\n        // Get an instance of the class \"C\"\n        final PythonObject c = PYTHON.getObject(\"C(int8(1))\");\n\n        // Try explicit and implicit marshalling with getattr\n        assertEquals(Boolean.TRUE,               c.getattr(Boolean.class, \"i\"));\n        assertEquals(Byte   .valueOf((byte)  1), c.getattr(Byte   .class, \"i\"));\n        assertEquals(Short  .valueOf((short) 1), c.getattr(Short  .class, \"i\"));\n        assertEquals(Integer.valueOf((int)   1), c.getattr(Integer.class, \"i\"));\n        assertEquals(Long   .valueOf((long)  1), c.getattr(Long   .class, \"i\"));\n        assertEquals(Float  .valueOf((float) 1), c.getattr(Float  .class, \"i\"));\n        assertEquals(Double .valueOf((double)1), c.getattr(Double .class, \"i\"));\n        assertEquals(\"1\",                        c.getattr(Object .class, \"i\").toString());\n\n        // Invoke a method to get back another instance of C, and test similarly\n        PythonObject cc = c.invoke(PythonObject.class, \"c\", 1);\n        assertEquals(Integer.valueOf(2), cc.getattr(Integer.class, \"i\"));\n\n        // Look for a missing field", "        try {\n            c.getattr(Integer.class, \"j\");\n            fail();\n        }\n        catch (NoSuchFieldException e) {\n            // pass\n        }\n\n        // Get a method handle and invoke it to get back a value\n        @SuppressWarnings(\"unchecked\")\n        final PythonFunction<String> f1 = c.getattr(PythonFunction.class, \"f\");\n        assertEquals(\"FOO\", f1.invoke());\n\n        // And again, in a different way\n        final PythonFunction<String> f2 = c.getMethod(String.class, \"f\");\n        assertEquals(\"FOO\", f2.invoke());\n\n        // Get a method handle and invoke it to raise an exception\n        @SuppressWarnings(\"unchecked\")\n        final PythonFunction<String> g = c.getattr(PythonFunction.class, \"g\");", "        try {\n            g.invoke();\n            fail();\n        }\n        catch (Exception e) {\n            // pass\n        }\n\n        // Get another method handle and invoke it to raise a Java exception\n        @SuppressWarnings(\"unchecked\")\n        final PythonFunction<String> h = c.getattr(PythonFunction.class, \"h\");", "        try {\n            h.invoke(Collections.emptyList());\n            fail();\n        }\n        catch (Exception e) {\n            // pass\n        }\n\n        // Test that we can construct an object by passing Java args.\n        PythonObject c2 = PYTHON.invokeAndGetObject(\"C\", 3);\n        assertEquals(Integer.valueOf(3), c2.getattr(Integer.class, \"i\"));\n    }\n\n    /**\n     * Test PythonObject.\n     */\n    @Test", "    public void testPythonMethods()\n        throws Throwable\n    {\n        // Get the object wrapper\n        final PythonObject dict = PYTHON.getObject(\"dict()\", \"MyDictionary\");\n\n        // Get some functional aliases; same method but different ways of\n        // invoking it\n        final BiConsumer<String,String> setitemBC = dict.getBiConsumer(\"__setitem__\");\n        final PythonFunction<Object>    setitemM  = dict.getMethod(Object.class,\n                                                                   \"__setitem__\");\n\n        // Insert values using the methods\n        setitemBC.accept(\"hello\", \"world\");\n        setitemM .invoke(\"dict\",  dict);\n\n        // Get the stringified version of the dict; the entry ordering here is\n        // abritrary so we test both\n        final String str = dict.invoke(String.class, \"__str__\");\n        assertTrue(\"{u'dict': {...}, u'hello': u'world'}\".equals(str)\n                || \"{u'hello': u'world', u'dict': {...}}\".equals(str)\n                || \"{'dict': {...}, 'hello': 'world'}\".equals(str)\n                || \"{'hello': 'world', 'dict': {...}}\".equals(str),\n                              \"Unexpected output: \\\"\" + str + \"\\\"\");\n    }\n\n    /**\n     * Test PythonObject as a Proxy. Tests calling methods which given back\n     * values.\n     */\n    @Test", "    public void testPythonProxy1()\n        throws Throwable\n    {\n        // Create a Python class \"CharSequence\"\n        final String klass = (\"class CharSequence(pjrmi.JavaProxyBase):\\n\" +\n                              \"    def __init__(self, s):\\n\" +\n                              \"        self.s = s\\n\" +\n                              \"    def charAt(self, i):\\n\" +\n                              \"        return self.s[i]\\n\" +\n                              \"    def length(self):\\n\" +\n                              \"        return len(self.s)\\n\" +\n                              \"    def subSequence(self, s, e):\\n\" +\n                              \"        return self.s[s:e]\\n\" +\n                              \"    def toString(self):\\n\" +\n                              \"        return self.s\");\n        PYTHON.exec(klass);\n\n        // And get an instance of it, masqueraiding as a Java CharSequence\n        final CharSequence s1 = \"0123456789\";\n        final CharSequence s2 = PYTHON.getObject(\"CharSequence('\" + s1 + \"')\")\n                                      .asProxy(CharSequence.class);\n        assertEquals(s1.length(), s2.length());\n        assertEquals(s1.toString(), s2.toString());", "        for (int i=0; i < s1.length(); i++) {\n            assertEquals(s1.charAt(i), s2.charAt(i));\n        }\n        assertEquals(s1.subSequence(3, 6), s2.subSequence(3, 6));\n    }\n\n    /**\n     * Test PythonObject as a Proxy. Makes sure that calling methods which\n     * \"return\" void works as well as the \"native\" toString() method.\n     */\n    @Test", "    public void testPythonProxy2()\n        throws Throwable\n    {\n        // Create a Python class \"Runnable\"\n        final String klass = (\"class Runnable(pjrmi.JavaProxyBase):\\n\" +\n                              \"    def __init__(self):\\n\" +\n                              \"        pass\\n\" +\n                              \"    def run(self):\\n\" +\n                              \"        pass\\n\");\n        PYTHON.exec(klass);\n\n        // Just make sure we can call it\n        final Runnable r = PYTHON.getObject(\"Runnable()\")\n                                 .asProxy(Runnable.class);\n        r.run();\n\n        // And ensure that the native toString() method doesn't explode\n        r.toString();\n    }\n\n    /**\n     * Tests array method return types from Python back to Java.\n     */\n    @Test", "    public void testArrayMethodReturnTypes()\n        throws Throwable\n    {\n        // Create some methods which return back various different types of\n        // array data.\n        final String methodDefs = (\n            \"import numpy\\n\" +\n            \"def getByteArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='int8')\\n\" +\n            \"def getShortArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='int16')\\n\" +\n            \"def getIntArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='int32')\\n\" +\n            \"def getLongArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='int64')\\n\" +\n            \"def getFloatArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='float32')\\n\" +\n            \"def getDoubleArray():\\n\" +\n            \"    return numpy.array([1,2,3], dtype='float64')\\n\" +\n            \"def getBooleanArray():\\n\" +\n            \"    return numpy.array([False,True], dtype='bool')\\n\" +\n            \"def getStringArray():\\n\" +\n            \"    return numpy.array(['abc', 'def'])\\n\" +\n            \"def getMixedMap():\\n\" +\n            \"    return {\\n\" +\n            \"        'bytes'  : getByteArray  (),\\n\" +\n            \"        'ints'   : getIntArray   (),\\n\" +\n            \"        'strings': getStringArray(),\\n\" +\n            \"    }\\n\"\n        );\n\n        PYTHON.exec(methodDefs);\n\n        // Test casting of the return type.\n        assertTrue(Arrays.equals(new    byte[] { 1, 2, 3      }, (byte   []) PYTHON.invoke(\"getByteArray\"   )));\n        assertTrue(Arrays.equals(new   short[] { 1, 2, 3      }, (short  []) PYTHON.invoke(\"getShortArray\"  )));\n        assertTrue(Arrays.equals(new     int[] { 1, 2, 3      }, (int    []) PYTHON.invoke(\"getIntArray\"    )));\n        assertTrue(Arrays.equals(new    long[] { 1, 2, 3      }, (long   []) PYTHON.invoke(\"getLongArray\"   )));\n        assertTrue(Arrays.equals(new   float[] { 1, 2, 3      }, (float  []) PYTHON.invoke(\"getFloatArray\"  )));\n        assertTrue(Arrays.equals(new  double[] { 1, 2, 3      }, (double []) PYTHON.invoke(\"getDoubleArray\" )));\n        assertTrue(Arrays.equals(new boolean[] { false, true  }, (boolean[]) PYTHON.invoke(\"getBooleanArray\")));\n        assertTrue(Arrays.equals(new  String[] { \"abc\", \"def\" }, (String []) PYTHON.invoke(\"getStringArray\" )));\n\n        // Test explicitly providing the return type to Python.\n        assertTrue(Arrays.equals(new    byte[] { 1, 2, 3      }, PYTHON.invoke(\"getByteArray\"   , byte   [].class)));\n        assertTrue(Arrays.equals(new   short[] { 1, 2, 3      }, PYTHON.invoke(\"getShortArray\"  , short  [].class)));\n        assertTrue(Arrays.equals(new     int[] { 1, 2, 3      }, PYTHON.invoke(\"getIntArray\"    , int    [].class)));\n        assertTrue(Arrays.equals(new    long[] { 1, 2, 3      }, PYTHON.invoke(\"getLongArray\"   , long   [].class)));\n        assertTrue(Arrays.equals(new   float[] { 1, 2, 3      }, PYTHON.invoke(\"getFloatArray\"  , float  [].class)));\n        assertTrue(Arrays.equals(new  double[] { 1, 2, 3      }, PYTHON.invoke(\"getDoubleArray\" , double [].class)));\n        assertTrue(Arrays.equals(new boolean[] { false, true  }, PYTHON.invoke(\"getBooleanArray\", boolean[].class)));\n        assertTrue(Arrays.equals(new  String[] { \"abc\", \"def\" }, PYTHON.invoke(\"getStringArray\" , String [].class)));\n\n        // Test some cases which would fail.\n        assertFalse(Arrays.equals(new    byte[] { 3, 2, 1      }, PYTHON.invoke(\"getByteArray\"   , byte   [].class)));\n        assertFalse(Arrays.equals(new boolean[] { true, false  }, PYTHON.invoke(\"getBooleanArray\", boolean[].class)));\n        assertFalse(Arrays.equals(new  String[] { null, \"def\"  }, PYTHON.invoke(\"getStringArray\" , String [].class)));", "        try {\n            short[] result = (short[]) PYTHON.invoke(\"getByteArray\");\n\n            // We should never get here.\n            fail(\"byte[] cast to short[]\");\n        }\n        catch (ClassCastException e) {\n            // This is expected.\n        }\n\n        // Test that arrays in a more complex type like a map are returned with\n        // the correct type.\n        Map<?,?> result = PYTHON.invoke(\"getMixedMap\", Map.class);\n        assertTrue(Arrays.equals(new   byte[] { 1, 2, 3      }, (byte  []) result.get(\"bytes\"  )));\n        assertTrue(Arrays.equals(new   int [] { 1, 2, 3      }, (int   []) result.get(\"ints\"   )));\n        assertTrue(Arrays.equals(new String[] { \"abc\", \"def\" }, (String[]) result.get(\"strings\")));\n    }\n\n    /**\n     * Tests native array handling from Java to Python and vice versa.\n     */\n    @Test", "    public void testNativeArray()\n        throws Throwable\n    {\n        // Create some methods which take various different types of array data.\n        final String methodDefs = (\n            \"import numpy\\n\" +\n            \"def getArrayLength(array):\\n\" +\n            \"    return(len(array))\\n\" +\n            \"def getNumpyBooleanEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='bool')\\n\" +\n            \"def getNumpyByteEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='int8')\\n\" +\n            \"def getNumpyShortEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='int16')\\n\" +\n            \"def getNumpyIntEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='int32')\\n\" +\n            \"def getNumpyLongEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='int64')\\n\" +\n            \"def getNumpyFloatEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='float32')\\n\" +\n            \"def getNumpyDoubleEquivalent(array):\\n\" +\n            \"    return numpy.asarray(array, dtype='float64')\\n\" +\n            \"def populateMap(java_map):\\n\" +\n            \"    # To match the Java arrays in the later code\\n\" +\n            \"    for dtype in ('int8', 'int16', 'int32', 'int64',\\n\" +\n            \"                  'float32', 'float64'):\\n\" +\n            \"        java_map.put(dtype, numpy.arange(1, 4, dtype=dtype))\\n\"\n        );\n\n        PYTHON.exec(methodDefs);\n\n        // Some primitive Java arrays we'll use for the tests\n        boolean[] java_empty_array   = new boolean[] {};\n        boolean[] java_boolean_array = new boolean[] {true, false};\n        byte   [] java_byte_array    = new byte   [] {1, 2, 3};\n        short  [] java_short_array   = new short  [] {1, 2, 3};\n        int    [] java_int_array     = new int    [] {1, 2, 3};\n        long   [] java_long_array    = new long   [] {1, 2, 3};\n        float  [] java_float_array   = new float  [] {1, 2, 3};\n        double [] java_double_array  = new double [] {1, 2, 3};\n\n        // Test that input type of primitive Java array are cast\n        // appropriately in Python.\n        assertEquals(Integer.valueOf(0),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_empty_array));\n        assertEquals(Integer.valueOf(2),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_boolean_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_byte_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_short_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_int_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_long_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_float_array));\n        assertEquals(Integer.valueOf(3),\n                     PYTHON.invoke(\"getArrayLength\", int.class, java_double_array));\n\n        // Test that input type of primitive Java array are cast and used\n        // appropriately in Python. We cast the returned value to check\n        // for equality.\n        assertTrue(Arrays.equals(         java_empty_array,   (boolean[]) PYTHON.invoke\n            (\"getNumpyBooleanEquivalent\", java_empty_array)));\n        assertTrue(Arrays.equals(         java_boolean_array, (boolean[]) PYTHON.invoke\n            (\"getNumpyBooleanEquivalent\", java_boolean_array)));\n        assertTrue(Arrays.equals(         java_byte_array,    (byte   []) PYTHON.invoke\n            (\"getNumpyByteEquivalent\",    java_byte_array)));\n        assertTrue(Arrays.equals(         java_short_array,   (short  []) PYTHON.invoke\n            (\"getNumpyShortEquivalent\",   java_byte_array)));\n        assertTrue(Arrays.equals(         java_int_array,     (int    []) PYTHON.invoke\n            (\"getNumpyIntEquivalent\",     java_byte_array)));\n        assertTrue(Arrays.equals(         java_long_array,    (long   []) PYTHON.invoke\n            (\"getNumpyLongEquivalent\",    java_byte_array)));\n        assertTrue(Arrays.equals(         java_float_array,   (float  []) PYTHON.invoke\n            (\"getNumpyFloatEquivalent\",   java_byte_array)));\n        assertTrue(Arrays.equals(         java_double_array,  (double []) PYTHON.invoke\n            (\"getNumpyDoubleEquivalent\",  java_double_array)));\n\n        // Now test stuffing values into a Map\n        final Map<String,Object> map = new HashMap<>();\n        PYTHON.invoke(\"populateMap\", map);\n        assertTrue(Arrays.equals(java_byte_array,   (byte   [])map.get(\"int8\"   )));\n        assertTrue(Arrays.equals(java_short_array,  (short  [])map.get(\"int16\"  )));\n        assertTrue(Arrays.equals(java_int_array,    (int    [])map.get(\"int32\"  )));\n        assertTrue(Arrays.equals(java_long_array,   (long   [])map.get(\"int64\"  )));\n        assertTrue(Arrays.equals(java_float_array,  (float  [])map.get(\"float32\")));\n        assertTrue(Arrays.equals(java_double_array, (double [])map.get(\"float64\")));\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/python/PickleTest.java", "chunked_list": ["package com.deshaw.python;\n\nimport com.deshaw.python.DType;\nimport com.deshaw.python.NumpyArray;\nimport com.deshaw.python.PythonPickle;\nimport com.deshaw.python.PythonUnpickle;\n\nimport java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;", "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Verify the operation of the Python picking code.\n */\npublic class PickleTest\n{\n    /*\n     * Empty arrays\n     */\n    private static final int[]    EMPTY_INT    = new int   [0];\n    private static final long[]   EMPTY_LONG   = new long  [0];\n    private static final double[] EMPTY_DOUBLE = new double[0];\n\n\n    /**\n     * Objects of various primitive types.\n     */\n    private static final Object[] OBJECTS = {\n        null,\n        true, false,\n        -100.0f, 0.0f, 100.0f\n        -1000.0, 0.0, 1000.0,\n        -10000000, 10000000,\n        -10000000000L, 10000000000L,\n        \"hello\", \"world\", \"\"\n    };\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Test pickling and unpickling of primitives.\n     */\n    @Test", " * Verify the operation of the Python picking code.\n */\npublic class PickleTest\n{\n    /*\n     * Empty arrays\n     */\n    private static final int[]    EMPTY_INT    = new int   [0];\n    private static final long[]   EMPTY_LONG   = new long  [0];\n    private static final double[] EMPTY_DOUBLE = new double[0];\n\n\n    /**\n     * Objects of various primitive types.\n     */\n    private static final Object[] OBJECTS = {\n        null,\n        true, false,\n        -100.0f, 0.0f, 100.0f\n        -1000.0, 0.0, 1000.0,\n        -10000000, 10000000,\n        -10000000000L, 10000000000L,\n        \"hello\", \"world\", \"\"\n    };\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Test pickling and unpickling of primitives.\n     */\n    @Test", "    public void testPrimitives()\n        throws Exception\n    {\n        for (Object object : OBJECTS) {\n            doInOut(object);\n        }\n    }\n\n    /**\n     * Test arrays.\n     */\n    @Test", "    public void testArrays()\n        throws Exception\n    {\n        doInOut(new int[]    {     -10000000,     10000000 });\n        doInOut(new long[]   { -10000000000L, 10000000000L });\n        doInOut(new double[] {       -1000.0,       1000.0 });\n    }\n\n    /**\n     * Test a map.\n     */\n    @Test", "    public void testMap()\n        throws Exception\n    {\n        final Map<Object,Object> map = new HashMap<>();\n        for (Object object : OBJECTS) {\n            if (object != null) {\n                map.put(object, object);\n            }\n        }\n        doInOut(map);\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Actually test some pickling.\n     */\n    private void doInOut(Object in)\n        throws Exception\n    {\n        final PythonPickle pickle = new PythonPickle();\n        final Object out = PythonUnpickle.loadPickle(pickle.toByteArray(in));\n        Assertions.assertTrue(equals(in, out),\n                              \"IN[\" + describe(in) + \"] != OUT[\" + describe(out) + \"]\");\n    }\n\n    /**\n     * Whether two things are equal.\n     */\n    private boolean equals(final Object in, final Object out)\n    {\n        // Null check", "        if (in == null && out == null) {\n            return true;\n        }\n        if (in == null && out != null ||\n            in != null && out == null)\n        {\n            return false;\n        }\n\n        // Unwrap arrays\n        final boolean isArray = in.getClass().isArray();", "        if (isArray) {\n            // Should be a numpy array\n            if (!(out instanceof NumpyArray)) {\n                return false;\n            }\n            final NumpyArray array = (NumpyArray)out;\n\n            // Check size\n            final int length = array.size();\n            if (length != Array.getLength(in)) {\n                return false;\n            }\n", "            if (length != Array.getLength(in)) {\n                return false;\n            }\n\n            if (in.getClass().equals(EMPTY_INT.getClass())) {\n                if (DType.Type.INT32 != array.dtype().type()) {\n                    return false;\n                }\n                for (int i=0; i < length; i++) {\n                    if (array.getInt(i) != Array.getInt(in, i)) {\n                        return false;\n                    }\n                }\n                return true;\n            }", "                for (int i=0; i < length; i++) {\n                    if (array.getInt(i) != Array.getInt(in, i)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else if (in.getClass().equals(EMPTY_LONG.getClass())) {\n                if (DType.Type.INT64 != array.dtype().type()) {\n                    return false;\n                }", "                if (DType.Type.INT64 != array.dtype().type()) {\n                    return false;\n                }\n                for (int i=0; i < length; i++) {\n                    if (array.getLong(i) != Array.getLong(in, i)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else if (in.getClass().equals(EMPTY_DOUBLE.getClass())) {", "            else if (in.getClass().equals(EMPTY_DOUBLE.getClass())) {\n                if (DType.Type.FLOAT64 != array.dtype().type()) {\n                    return false;\n                }\n                for (int i=0; i < length; i++) {\n                    if (array.getDouble(i) != Array.getDouble(in, i)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else {\n                // Unhandled\n                return false;\n            }\n        }\n\n        // Compare\n        return Objects.equals(in, out);\n    }\n\n    /**\n     * Describe an object.\n     */\n    private String describe(final Object object)\n    {\n        final StringBuilder sb = new StringBuilder();", "        if (object == null) {\n            sb.append(\"null\");\n        }\n        else if (object.getClass().isArray()) {\n            final int length = Array.getLength(object);\n            sb.append('[');\n            for (int i=0; i < length; i++) {\n                if (i > 0) sb.append(\", \");\n                sb.append(Array.get(object, i));\n            }\n            sb.append(']');\n        }", "        else if (object instanceof CharSequence) {\n            sb.append('\"').append(object).append('\"');\n        }\n        else {\n            sb.append(String.valueOf(object));\n        }\n        if (object != null) {\n            sb.append(\" <\");\n            sb.append(object.getClass());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/util/StringUtilTest.java", "chunked_list": ["package com.deshaw.util;\n\nimport com.deshaw.util.StringUtil;\nimport com.deshaw.util.StringUtil.HashableSubSequence;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;", "import java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\nimport java.nio.ByteBuffer;\n\nimport java.text.ParseException;\n", "import java.text.ParseException;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.junit.jupiter.api.Test;", "\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n", "import static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * A unit test suite for testing {@link com.deshaw.util.StringUtil} class.\n */\npublic class StringUtilTest\n{\n    /**\n     * Test hashing of a wrapped subsequence.\n     */\n    @Test", "    public void testHashableSubSequence()\n    {\n        final StringUtil.HashableSubSequence wrapper =\n            new StringUtil.HashableSubSequence();\n\n        // Compare how wrapper works against a native string\n        final String string = \"Hello World\";\n        final StringBuilder buf = new StringBuilder();\n        buf.append(string);\n\n        // All these should match", "        for (int start = 0; start < string.length(); start++) {\n            for (int end = start; end < string.length(); end++) {\n                wrapper.wrap(buf, start, end-start);\n                final String substring = string.substring(start, end);\n\n                assertEquals(wrapper.length(),   substring.length());\n                assertEquals(wrapper.hashCode(), substring.hashCode());\n                assertTrue  (wrapper.equals(substring));\n\n                for (int i=0; i < wrapper.length(); i++) {\n                    assertEquals(wrapper.charAt(i), substring.charAt(i));\n                }\n            }\n        }\n    }\n\n    /**\n     * Test {@link StringUtil#equalsIgnoreCase(CharSequence, CharSequence)}.\n     */\n    @Test", "                for (int i=0; i < wrapper.length(); i++) {\n                    assertEquals(wrapper.charAt(i), substring.charAt(i));\n                }\n            }\n        }\n    }\n\n    /**\n     * Test {@link StringUtil#equalsIgnoreCase(CharSequence, CharSequence)}.\n     */\n    @Test", "    public void testEqualsIgnoreCase()\n    {\n        assertTrue(StringUtil.equalsIgnoreCase(null, null));\n        assertTrue(StringUtil.equalsIgnoreCase(\"\", new HashableSubSequence(\"\")));\n        assertTrue(StringUtil.equalsIgnoreCase(\"abc\", new HashableSubSequence(\"abc\")));\n        assertTrue(StringUtil.equalsIgnoreCase(\"aBc\", new HashableSubSequence(\"AbC\")));\n        assertTrue(StringUtil.equalsIgnoreCase(\"abcdefghijklmnopqrstuvwxyz\",\n                                               new HashableSubSequence(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")));\n\n        assertFalse(StringUtil.equalsIgnoreCase(null, new HashableSubSequence(\"\")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"\", null));\n        assertFalse(StringUtil.equalsIgnoreCase(null, new HashableSubSequence(\"a\")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"a\", null));\n        assertFalse(StringUtil.equalsIgnoreCase(\"\", new HashableSubSequence(\" \")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"a \", new HashableSubSequence(\" a\")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"ab\", new HashableSubSequence(\"ba\")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"a a\", new HashableSubSequence(\"aa\")));\n        assertFalse(StringUtil.equalsIgnoreCase(\"a\", new HashableSubSequence(\"aa\")));\n    }\n\n    /**\n     * Tests {@link StringUtil#equals(CharSequence, CharSequence)}.\n     */\n    @Test", "    public void testEquals()\n    {\n        assertTrue(StringUtil.equals(null, null));\n        assertTrue(StringUtil.equals(\"\", new HashableSubSequence(\"\")));\n        assertTrue(StringUtil.equals(\"abcdefghijklmnopqrstuvwxyz\",\n                                     new HashableSubSequence(\"abcdefghijklmnopqrstuvwxyz\")));\n        assertTrue(StringUtil.equals(\"1234567890\", new HashableSubSequence(\"1234567890\")));\n\n        assertFalse(StringUtil.equals(null, new HashableSubSequence(\"\")));\n        assertFalse(StringUtil.equals(\"\", null));\n        assertFalse(StringUtil.equals(null, new HashableSubSequence(\"a\")));\n        assertFalse(StringUtil.equals(\"a\", null));\n        assertFalse(StringUtil.equals(\"\", new HashableSubSequence(\" \")));\n        assertFalse(StringUtil.equals(\"a \", new HashableSubSequence(\" a\")));\n        assertFalse(StringUtil.equals(\"ab\", new HashableSubSequence(\"ba\")));\n        assertFalse(StringUtil.equals(\"a a\", new HashableSubSequence(\"aa\")));\n        assertFalse(StringUtil.equals(\"a\", new HashableSubSequence(\"aa\")));\n        assertFalse(StringUtil.equals(\"aBc\", new HashableSubSequence(\"AbC\")));\n    }\n\n    /**\n     * Returns true if {@link StringUtil#parseBoolean(CharSequence)} fails to\n     * parse the given string as a boolean value (by throwing a ParseException)\n     * or false if parsing completed successfully without throwing a\n     * ParseException.\n     */\n    private boolean failParseBoolean(CharSequence s) {", "        try {\n            StringUtil.parseBoolean(s);\n\n            // If we get here, then no exception was thrown, which was not\n            // expected.\n            return false;\n        }\n        catch (ParseException e) {\n            // We expected to receive a ParseException here.\n            return true;\n        }\n        catch (Exception e) {\n            // Any other exception signals an unexpected error.\n            return false;\n        }\n    }\n\n    /**\n     * Tests {@link StringUtil#parseBoolean(CharSequence)}.\n     */\n    @Test", "    public void testParseBoolean()\n    {\n        try {\n            assertTrue(StringUtil.parseBoolean(\"true\"));\n            assertTrue(StringUtil.parseBoolean(\"TRUE\"));\n            assertTrue(StringUtil.parseBoolean(\"tRuE\"));\n            assertFalse(StringUtil.parseBoolean(\"false\"));\n            assertFalse(StringUtil.parseBoolean(\"FALSE\"));\n            assertFalse(StringUtil.parseBoolean(\"FaLsE\"));\n        }\n        catch (ParseException e) {\n            // We don't expect to receive ParseException's in any of the cases\n            // above.\n            fail(\"Unexpected ParseException caught\");\n        }\n\n        assertTrue(failParseBoolean(null));\n        assertTrue(failParseBoolean(\"\"));\n        assertTrue(failParseBoolean(\"foobar\"));\n        assertTrue(failParseBoolean(\" false\"));\n        assertTrue(failParseBoolean(\"false \"));\n        assertTrue(failParseBoolean(\" true\"));\n        assertTrue(failParseBoolean(\"true \"));\n        assertFalse(failParseBoolean(\"true\"));\n        assertFalse(failParseBoolean(\"false\"));\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/util/concurrent/LockManagerTest.java", "chunked_list": ["package com.deshaw.util.concurrent;\n\nimport com.deshaw.util.concurrent.LockManager;\nimport com.deshaw.util.concurrent.LockManager.SafeLock;\nimport com.deshaw.util.concurrent.LockManager.SafeLock.AcquireFailedException;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.Test;", "\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Test LockManager for correctness.\n */\npublic class LockManagerTest\n{\n    /**\n     * A thread which watches a queue and tries to lock the Strings it finds\n     * there.\n     */\n    private static class Locker\n        extends Thread\n    {\n        private final ArrayBlockingQueue<String> myNames = new ArrayBlockingQueue<>(100);\n        private final AtomicBoolean              myDone  = new AtomicBoolean(false);\n        private final LockManager                myMgr;\n        private final boolean                    myExclusive;\n\n        public Locker(String name, LockManager mgr, boolean exclusive)\n        {\n            super(name);\n            setDaemon(true);\n            myMgr = mgr;\n            myExclusive = exclusive;\n        }\n\n        /**\n         * Terminate this thread after a given time; this is to try to prevent\n         * the thing hanging forever in some weird case.\n         */", " * Test LockManager for correctness.\n */\npublic class LockManagerTest\n{\n    /**\n     * A thread which watches a queue and tries to lock the Strings it finds\n     * there.\n     */\n    private static class Locker\n        extends Thread\n    {\n        private final ArrayBlockingQueue<String> myNames = new ArrayBlockingQueue<>(100);\n        private final AtomicBoolean              myDone  = new AtomicBoolean(false);\n        private final LockManager                myMgr;\n        private final boolean                    myExclusive;\n\n        public Locker(String name, LockManager mgr, boolean exclusive)\n        {\n            super(name);\n            setDaemon(true);\n            myMgr = mgr;\n            myExclusive = exclusive;\n        }\n\n        /**\n         * Terminate this thread after a given time; this is to try to prevent\n         * the thing hanging forever in some weird case.\n         */", "        public void doneAfter(final long millis)\n        {\n            new Thread() {\n                public void run() {\n                    sleepMs(millis);\n                    myDone.set(true);\n                }\n            }.start();\n        }\n\n        /**\n         * Add a named lock to the queue for acquisition.\n         */", "        public void lock(String name)\n        {\n            myNames.add(name);\n        }\n\n        /**\n         * See if all the named locks have been pulled from the queue for\n         * acquisition.\n         */\n        public boolean allLocksPolled()\n        {\n            return myNames.isEmpty();\n        }\n\n        /**\n         * Look to acquire the next lock in the queue, if any. We call this\n         * recursively.\n         */\n        @Override", "        public boolean allLocksPolled()\n        {\n            return myNames.isEmpty();\n        }\n\n        /**\n         * Look to acquire the next lock in the queue, if any. We call this\n         * recursively.\n         */\n        @Override\n        public void run()\n        {\n            String name = null;", "        public void run()\n        {\n            String name = null;\n            while (!myDone.get() && (name = myNames.poll()) == null) {\n                sleepMs(1);\n            }\n\n            if (name != null) {\n                try (SafeLock l =\n                         (myExclusive\n                             ? myMgr.getExclusiveLockFor(name)\n                             : myMgr.getSharedLockFor   (name)).acquire())\n                {\n                    run(); // recurse\n                }\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * We should get a deadlock in this case since we acquire the two locks in a\n     * bad order.\n     */\n    @Test", "    public void testDeadlockTwoLocks()\n    {\n        final LockManager mgr = new LockManager();\n        final SafeLock  exclA = mgr.getExclusiveLockFor(\"A\");\n        final SafeLock  exclB = mgr.getExclusiveLockFor(\"B\");\n\n        Locker locker = new Locker(\"testDeadlockTwoLocks\", mgr, true);\n        locker.start();\n        locker.doneAfter(2000);\n\n        exclA.lock();\n        locker.lock(\"B\");\n        locker.lock(\"A\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(100);\n\n        try {\n            exclB.lock();\n            exclB.unlock();\n            fail(\"Expected DeadlockException was not thrown\");\n        }\n        catch (LockManager.DeadlockException e) {\n            // Good, we expect to get the exception\n        }\n        exclA.unlock();\n    }\n\n    /**\n     * We should get a deadlock in this case since we acquire three locks in a\n     * bad order.\n     */\n    @Test", "    public void testDeadlockThreeLocks()\n    {\n        final LockManager mgr = new LockManager();\n        final SafeLock  exclA = mgr.getExclusiveLockFor(\"A\");\n        final SafeLock  exclB = mgr.getExclusiveLockFor(\"B\");\n\n        Locker locker = new Locker(\"testDeadlockThreeLocks\", mgr, true);\n        locker.start();\n        locker.doneAfter(2000);\n\n        exclA.lock();\n        locker.lock(\"C\");\n        locker.lock(\"B\");\n        locker.lock(\"A\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(100);\n\n        try {\n            exclB.lock();\n            exclB.unlock();\n            fail(\"Expected DeadlockException was not thrown\");\n        }\n        catch (LockManager.DeadlockException e) {\n            // Good\n        }\n        exclA.unlock();\n    }\n\n    /**\n     * We should not get a deadlock in this case since we acquire the locks in\n     * the same order.\n     */\n    @Test", "    public void testNoDeadlockTwoThreads()\n    {\n        final LockManager mgr = new LockManager();\n        final SafeLock  exclA = mgr.getExclusiveLockFor(\"A\");\n        final SafeLock  exclB = mgr.getExclusiveLockFor(\"B\");\n\n        Locker locker = new Locker(\"testNoDeadlockTwoThreads\", mgr, true);\n        locker.start();\n        locker.doneAfter(1000);\n\n        locker.lock(\"A\");\n        locker.lock(\"B\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(100);\n\n        exclA.lock(); // this will block until locker exits\n        exclB.lock();\n        exclB.unlock();\n        exclA.unlock();\n    }\n\n    /**\n     * We should not get a deadlock in this case since we're using a single\n     * thread, even though we acquire locks in a \"bad\" order.\n     */\n    @Test", "    public void testNoDeadlockOneThread()\n    {\n        final LockManager mgr = new LockManager();\n        final SafeLock  exclA = mgr.getExclusiveLockFor(\"A\");\n        final SafeLock  exclB = mgr.getExclusiveLockFor(\"B\");\n\n        exclA.lock();\n        exclB.lock();\n        exclA.lock();\n        exclA.unlock();\n        exclB.unlock();\n        exclA.unlock();\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * We should not get a deadlock in this case since we're using a single\n     * thread; also since these are shared locks.\n     */\n    @Test", "    public void testNoDeadlockSharedOneThread()\n    {\n        final LockManager  mgr = new LockManager();\n        final SafeLock sharedA = mgr.getSharedLockFor(\"A\");\n        final SafeLock sharedB = mgr.getSharedLockFor(\"B\");\n\n        sharedA.lock();\n        sharedB.lock();\n        sharedA.lock();\n        sharedA.unlock();\n        sharedB.unlock();\n        sharedA.unlock();\n    }\n\n    /**\n     * We should not get a deadlock in this case since we acquire the locks in\n     * the same order.\n     */\n    @Test", "    public void testNoDeadlockSharedTwoThreads()\n    {\n        final LockManager  mgr = new LockManager();\n        final SafeLock sharedA = mgr.getSharedLockFor(\"A\");\n        final SafeLock sharedB = mgr.getSharedLockFor(\"B\");\n\n        // This is the case where we don't expect deadlock anyhow\n        Locker locker = new Locker(\"testNoDeadlockTwoThreads\", mgr, false);\n        locker.start();\n        locker.doneAfter(1000);\n\n        locker.lock(\"A\");\n        locker.lock(\"B\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(10);\n\n        sharedA.lock();\n        sharedB.lock();\n        sharedB.unlock();\n        sharedA.unlock();\n\n        while (true) {\n            try {\n                locker.join();\n                break;\n            }\n            catch (InterruptedException e) {\n                // Nothing\n            }\n        }\n\n        // This is the case where we would expect deadlock in an exclusive\n        // situation, but not for shared locks\n        locker = new Locker(\"testDeadlockTwoLocks\", mgr, false);\n        locker.start();\n        locker.doneAfter(2000);\n\n        sharedA.lock();\n        locker.lock(\"B\");\n        locker.lock(\"A\");", "        while (true) {\n            try {\n                locker.join();\n                break;\n            }\n            catch (InterruptedException e) {\n                // Nothing\n            }\n        }\n\n        // This is the case where we would expect deadlock in an exclusive\n        // situation, but not for shared locks\n        locker = new Locker(\"testDeadlockTwoLocks\", mgr, false);\n        locker.start();\n        locker.doneAfter(2000);\n\n        sharedA.lock();\n        locker.lock(\"B\");\n        locker.lock(\"A\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(10);\n\n        // This should be fine\n        try {\n            sharedB.lock();\n            sharedB.unlock();\n        }\n        catch (LockManager.DeadlockException e) {\n            throw new RuntimeException(\n                \"unexpected DeadlockException was thrown\", e\n            );\n        }\n        sharedA.unlock();\n    }\n\n    /**\n     * We should not see a deadlock if we are just waiting to acquire an\n     * exclusive lock and others hold shared ones.\n     */\n    @Test", "    public void testNoDeadlockSharedExclusiveTwoThreads()\n    {\n        final LockManager  mgr = new LockManager();\n        final SafeLock sharedA = mgr.getSharedLockFor   (\"A\");\n        final SafeLock   exclB = mgr.getExclusiveLockFor(\"B\");\n\n        Locker locker = new Locker(\"testNoDeadlockTwoThreads\", mgr, false);\n        locker.start();\n        locker.doneAfter(1000);\n\n        locker.lock(\"A\");\n        locker.lock(\"B\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(10);\n\n        sharedA.lock();\n\n        exclB.lock(); // this will block until locker exits\n        exclB.unlock();\n    }\n\n    /**\n     * We should see a deadlock if we try a exclusive locks over the top of\n     * shared ones, just like regular ones.\n     */\n    @Test", "    public void testDeadlockSharedExclusiveTwoThreads()\n    {\n        final LockManager  mgr = new LockManager();\n        final SafeLock   exclA = mgr.getExclusiveLockFor(\"A\");\n        final SafeLock sharedB = mgr.getSharedLockFor   (\"B\");\n\n        Locker locker = new Locker(\"testNoDeadlockTwoThreads\", mgr, true);\n        locker.start();\n        locker.doneAfter(1000);\n\n        sharedB.lock();\n\n        locker.lock(\"A\");\n        locker.lock(\"B\"); // This will block", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(10);\n\n        try {\n            exclA.lock(); // This should raise a deadlock exception\n            exclA.unlock();\n            fail(\"Expected DeadlockException was not thrown\");\n        }\n        catch (LockManager.DeadlockException e) {\n            // Good\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Make sure that try-with-resources works.\n     */\n    @Test", "    public void testTryWithResources()\n    {\n        final LockManager mgr       = new LockManager();\n        final SafeLock    lockExcl = mgr.getExclusiveLockFor(\"LOCK\");\n        final SafeLock    lockShrd = mgr.getSharedLockFor   (\"LOCK\");\n\n        // Acquire the lock in the try clause\n        try (LockManager.SafeLock l = lockExcl.acquire()) {\n            // We should have it here\n            assertTrue(lockExcl.isHeldByCurrentThread(), \"Lock should be held\");\n        }\n        // It should have been dropped by here\n        assertFalse(lockExcl.isHeldByCurrentThread(), \"Lock should not be held\");\n\n        // Acquire the lock in the try clause\n        try (LockManager.SafeLock l = lockShrd.acquire()) {\n            // We should have it here\n            assertTrue(lockShrd.isHeldByCurrentThread(), \"Lock should be held\");\n        }\n        // It should have been dropped by here\n        assertFalse(lockShrd.isHeldByCurrentThread(), \"Lock should not be held\");\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Make sure that try-with-resources works for the tryAcquire() case.\n     */\n    @Test", "    public void testAcquireWithResources()\n    {\n        final LockManager mgr  = new LockManager();\n        final SafeLock    lock = mgr.getExclusiveLockFor(\"LOCK\");\n\n        // Acquire the lock in the try clause\n        try (LockManager.SafeLock l = lock.tryAcquire()) {\n            // We should have it here\n            assertTrue(lock.isHeldByCurrentThread(), \"Lock should be held\");\n        }\n        catch (AcquireFailedException e) {\n            fail(\"Unexpected AcquireFailedException thrown: \" + e);\n        }\n        // It should have been dropped by here\n        assertFalse(lock.isHeldByCurrentThread(), \"Lock should not be held\");\n\n        // Now get a locker to lock it so that tryAcquire() will fail\n        final Locker locker = new Locker(\"testAcquireWithResources\", mgr, true);\n        locker.start();\n        locker.doneAfter(1000);\n        locker.lock(\"LOCK\");", "        while (!locker.allLocksPolled()) sleepMs(1);\n        sleepMs(100);\n\n        // Acquire the lock in the try clause\n        try (LockManager.SafeLock l = lock.tryAcquire()) {\n            fail(\"Expected AcquireFailedException not thrown\");\n        }\n        catch (AcquireFailedException e) {\n            // Good\n        }\n        // Check that the lock isn't mysteriously held\n        assertFalse(lock.isHeldByCurrentThread(), \"Lock should not be held\");\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Make sure that state restoral works.\n     */\n    @Test", "    public void testStateRestoral()\n    {\n        // The lock manager and the locks\n        final LockManager mgr   = new LockManager();\n        final SafeLock    lock1 = mgr.getExclusiveLockFor(\"LOCK1\");\n        final SafeLock    lock2 = mgr.getExclusiveLockFor(\"LOCK2\");\n        final SafeLock    lock3 = mgr.getExclusiveLockFor(\"LOCK3\");\n\n        // Acquire Lock1 and Lock2\n        lock1.lock();\n        lock2.lock();\n        assertTrue (lock1.isHeldByCurrentThread(), \"LOCK1 should be held\"    );\n        assertTrue (lock2.isHeldByCurrentThread(), \"LOCK2 should be held\"    );\n        assertFalse(lock3.isHeldByCurrentThread(), \"LOCK3 should not be held\");\n\n        // At this point we have 1 lock on each of Lock1 and Lock2\n        try (LockManager.ThreadLockState state = mgr.saveLockState()) {\n            // Get more locks\n            lock2.lock();\n            lock3.lock();\n\n            // We now have 1 lock on Lock1 and Lock3 and 2 locks on Lock2\n            assertTrue(lock1.isHeldByCurrentThread(), \"LOCK1 should be held\");\n            assertTrue(lock2.isHeldByCurrentThread(), \"LOCK2 should be held\");\n            assertTrue(lock3.isHeldByCurrentThread(), \"LOCK3 should be held\");\n        }\n\n        // Upon exiting the try block we now are back to 1 lock on Lock1 and Lock2\n        assertTrue (lock1.isHeldByCurrentThread(), \"LOCK1 should be held\"    );\n        assertTrue (lock2.isHeldByCurrentThread(), \"LOCK2 should be held\"    );\n        assertFalse(lock3.isHeldByCurrentThread(), \"LOCK3 should not be held\");\n\n        // Check that we have the right amount of locking here\n        final SafeLock[] locks = {lock1, lock2};", "        for (SafeLock lock : locks) {\n            assertTrue (lock.isHeldByCurrentThread(), lock + \" should be held\"    );\n            lock.unlock();\n            assertFalse(lock.isHeldByCurrentThread(), lock + \" should not be held\");\n        }\n    }\n\n    /**\n     * Make sure that dropping all locks works\n     */\n    @Test", "    public void testDropAllThreadLocks()\n    {\n        // The lock manager and the locks\n        final LockManager mgr   = new LockManager();\n        final SafeLock    lock1 = mgr.getExclusiveLockFor(\"LOCK1\");\n        final SafeLock    lock2 = mgr.getExclusiveLockFor(\"LOCK2\");\n        final SafeLock    lock3 = mgr.getExclusiveLockFor(\"LOCK3\");\n\n        // Nothing yet\n        assertFalse(lock1.isHeldByCurrentThread(), \"LOCK1 should not be held\");\n        assertFalse(lock2.isHeldByCurrentThread(), \"LOCK2 should not be held\");\n        assertFalse(lock3.isHeldByCurrentThread(), \"LOCK3 should not be held\");\n\n        // Acquire lockN N times\n        lock1.lock();\n        lock2.lock(); lock2.lock();\n        lock3.lock(); lock3.lock(); lock3.lock();\n\n        // We now have 1 lock on Lock1 and Lock3 and 2 locks on Lock2\n        assertTrue(lock1.isHeldByCurrentThread(), \"LOCK1 should be held\");\n        assertTrue(lock2.isHeldByCurrentThread(), \"LOCK2 should be held\");\n        assertTrue(lock3.isHeldByCurrentThread(), \"LOCK3 should be held\");\n\n        // Drop everything\n        mgr.dropAllThreadLocks();\n\n        // Nothing now\n        assertFalse(lock1.isHeldByCurrentThread(), \"LOCK1 should be released\");\n        assertFalse(lock2.isHeldByCurrentThread(), \"LOCK2 should be released\");\n        assertFalse(lock3.isHeldByCurrentThread(), \"LOCK3 should be released\");\n    }\n\n    // ----------------------------------------------------------------------\n\n     /**\n     * Wait for at least a set period of time.\n     */\n    private static void sleepMs(long millis)\n    {\n        final long until = System.currentTimeMillis() + millis;", "        while (System.currentTimeMillis() < until) {\n            try {\n                // Wait for one ms and then see if we've waited long enough\n                Thread.sleep(1);\n            }\n            catch (InterruptedException e) {\n                // Don't care, loop around and continue to wait\n            }\n        }\n    }\n}\n"]}
{"filename": "java/src/test/java/com/deshaw/util/concurrent/VirtualThreadLockTest.java", "chunked_list": ["package com.deshaw.util.concurrent;\n\nimport com.deshaw.util.concurrent.VirtualThreadLock;\nimport com.deshaw.util.concurrent.VirtualThreadLock.VirtualThread;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n", "import java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Test the VirtualThreadLock class for correctness.", "/**\n * Test the VirtualThreadLock class for correctness.\n */\npublic class VirtualThreadLockTest\n{\n    // What we'll use in the tests\n    private static final VirtualThread THREAD1 = new VirtualThread(\"Thread1\");\n    private static final VirtualThread THREAD2 = new VirtualThread(\"Thread2\");\n\n    /**\n     * Ensure that get and set works as expected.\n     */\n    @Test", "    public void testGetSet()\n    {\n        // Ensure it's clear; should not throw\n        VirtualThreadLock.setThread(null);\n\n        // This should throw\n        try {\n            VirtualThreadLock.getThread();\n            fail(\"getThread() should have thrown\");\n        }\n        catch (IllegalArgumentException e) { /* Nothing */ }\n\n        // Associate, should not throw\n        VirtualThreadLock.setThread(THREAD1);\n\n        // This shoudl now not throw\n        VirtualThreadLock.getThread();\n\n        // This should now throw", "        try {\n            VirtualThreadLock.setThread(THREAD2);\n            fail(\"setThread() should have thrown\");\n        }\n        catch (IllegalArgumentException e) { /* Nothing */ }\n\n        // Tidy up; should not throw\n        VirtualThreadLock.setThread(null);\n    }\n\n    /**\n     * Ensure that acquiring works as expected for the same VirtualThread.\n     */\n    @Test", "    public void testMultipleSameLockers()\n    {\n        final VirtualThreadLock lock = new VirtualThreadLock(\"SameLock\");\n\n        List<String> exceptions = Collections.synchronizedList(new ArrayList<>());\n\n        final AtomicBoolean result1 = new AtomicBoolean();\n        final AtomicBoolean result2 = new AtomicBoolean();\n        final Thread locker1 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD1);\n                        final boolean locked = lock.tryLock();\n                        sleep(200);\n                        if (locked) {\n                            assertTrue(lock.isHeldByCurrentThread());\n                            lock.unlock();\n                        }\n                        result1.set(locked);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n        final Thread locker2 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD1);\n                        sleep(100);\n                        final boolean locked = lock.tryLock();\n                        sleep(100);\n                        if (locked) {\n                            assertTrue(lock.isHeldByCurrentThread());\n                            lock.unlock();\n                        }\n                        result2.set(locked);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n\n        // Daemonise, we don't want to hang on exit\n        locker1.setDaemon(true);\n        locker2.setDaemon(true);\n\n        // Start them\n        final long start = System.nanoTime();\n        locker1.start();\n        locker2.start();\n\n        // Wait for them to finish, or timeout", "        while ((locker1.isAlive() || locker2.isAlive()) &&\n               (System.nanoTime() - start < 10_000_000_000L))\n        {\n            sleep(1);\n        }\n\n        assertTrue(exceptions.isEmpty(),\n                   \"Problems in spawned thread: \" + exceptions);\n\n        // Threads should have exited\n        assertFalse(locker1.isAlive(), \"Locker1 didn't exit\"   );\n        assertFalse(locker2.isAlive(), \"Locker2 didn't exit\"   );\n        assertTrue (result1.get(),     \"Locker1 failed to lock\");\n        assertTrue (result2.get(),     \"Locker2 failed to lock\");\n    }\n\n    /**\n     * Ensure that acquiring works as expected for different VirtualThreads.\n     */\n    @Test", "    public void testMultipleDifferentTryLockers()\n    {\n        final VirtualThreadLock lock = new VirtualThreadLock(\"DifferentLock\");\n\n        List<String> exceptions = Collections.synchronizedList(new ArrayList<>());\n\n        final AtomicBoolean result1 = new AtomicBoolean();\n        final AtomicBoolean result2 = new AtomicBoolean();\n        final Thread locker1 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD1);\n                        final boolean locked = lock.tryLock();\n                        sleep(200);\n                        if (locked) {\n                            assertTrue(lock.isHeldByCurrentThread());\n                            lock.unlock();\n                        }\n                        result1.set(locked);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n        final Thread locker2 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD2);\n                        sleep(100);\n                        assertTrue(lock.isLocked(), \"Lock is not locked\");\n                        final boolean locked = lock.tryLock();\n                        sleep(100);\n                        if (locked) {\n                            assertTrue(lock.isHeldByCurrentThread());\n                            lock.unlock();\n                        }\n                        result2.set(locked);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n\n        // Daemonise, we don't want to hang on exit\n        locker1.setDaemon(true);\n        locker2.setDaemon(true);\n\n        // Start them\n        final long start = System.nanoTime();\n        locker1.start();\n        locker2.start();\n\n        // Wait for them to finish, or timeout", "                        if (locked) {\n                            assertTrue(lock.isHeldByCurrentThread());\n                            lock.unlock();\n                        }\n                        result2.set(locked);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n\n        // Daemonise, we don't want to hang on exit\n        locker1.setDaemon(true);\n        locker2.setDaemon(true);\n\n        // Start them\n        final long start = System.nanoTime();\n        locker1.start();\n        locker2.start();\n\n        // Wait for them to finish, or timeout", "        while ((locker1.isAlive() || locker2.isAlive()) &&\n               (System.nanoTime() - start < 10_000_000_000L))\n        {\n            sleep(1);\n        }\n\n        assertTrue(exceptions.isEmpty(),\n                   \"Problems in spawned thread: \" + exceptions);\n\n        // Threads should have exited\n        assertFalse(locker1.isAlive(),\"Locker1 didn't exit\"          );\n        assertFalse(locker2.isAlive(),\"Locker2 didn't exit\"          );\n        assertTrue (result1.get(),    \"Locker1 failed to lock\"       );\n        assertFalse(result2.get(),    \"Locker2 shouldn't have locked\");\n    }\n\n    /**\n     * Ensure that acquiring works as expected for different VirtualThreads.\n     */\n    @Test", "    public void testMultipleDifferentBlockingLockers()\n    {\n        final VirtualThreadLock lock = new VirtualThreadLock(\"DifferentLock\");\n\n        List<String> exceptions = Collections.synchronizedList(new ArrayList<>());\n\n        final AtomicBoolean result1 = new AtomicBoolean();\n        final AtomicBoolean result2 = new AtomicBoolean();\n        final Thread locker1 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD1);\n                        lock.lock();\n                        sleep(200);\n                        assertTrue(lock.isHeldByCurrentThread());\n                        lock.unlock();\n                        result1.set(true);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n        final Thread locker2 =\n            new Thread()\n            {", "                @Override public void run()\n                {\n                    try {\n                        VirtualThreadLock.setThread(THREAD2);\n                        sleep(100);\n                        assertTrue(lock.isLocked(), \"Lock is not locked\");\n                        lock.lock();\n                        sleep(100);\n                        assertTrue(lock.isHeldByCurrentThread());\n                        lock.unlock();\n                        result2.set(true);\n                    }\n                    catch (Throwable t) {\n                        exceptions.add(this + \": \" + t);\n                    }\n                }\n            };\n\n        // Daemonise, we don't want to hang on exit\n        locker1.setDaemon(true);\n        locker2.setDaemon(true);\n\n        // Start them\n        final long start = System.nanoTime();\n        locker1.start();\n        locker2.start();\n\n        // Wait for them to finish, or timeout", "        while ((locker1.isAlive() || locker2.isAlive()) &&\n               (System.nanoTime() - start < 10_000_000_000L))\n        {\n            sleep(1);\n        }\n\n        assertTrue(exceptions.isEmpty(),\n                   \"Problems in spawned thread: \" + exceptions);\n\n        // Threads should have exited\n        assertFalse(locker1.isAlive(), \"Locker1 didn't exit\"   );\n        assertFalse(locker2.isAlive(), \"Locker2 didn't exit\"   );\n        assertTrue (result1.get(),     \"Locker1 failed to lock\");\n        assertTrue (result2.get(),     \"Locker2 failed to lock\");\n    }\n\n    /**\n     * Sleep without worrying about interruptions.\n     */\n    private static void sleep(long millis)\n    {", "        try {\n            Thread.sleep(millis);\n        }\n        catch (InterruptedException e) {\n            // Nothing\n        }\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonMinion.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.python.PythonPickle;\n\nimport java.io.IOException;\n\n/**\n * How one may call into Python.\n */\npublic interface PythonMinion\n{\n    /**\n     * A special \"annotation\" class which allows users to specify that\n     * arguments should be passed by value instead of by reference.\n     *\n     * <p>In order to send values by value they must be supported by the\n     * {@link PythonPickle} class.\n     */", " */\npublic interface PythonMinion\n{\n    /**\n     * A special \"annotation\" class which allows users to specify that\n     * arguments should be passed by value instead of by reference.\n     *\n     * <p>In order to send values by value they must be supported by the\n     * {@link PythonPickle} class.\n     */\n    public static final class ByValue\n    {\n        /**\n         * What we're going to take the value of.\n         */\n        private final Object myReference;\n\n        /**\n         * Constructor.\n         *\n         * @param reference the reference to use.\n         */\n        protected ByValue(final Object reference)\n        {\n            myReference = reference;\n        }\n\n        /**\n         * Get the wrapped object.\n         *\n         * @return the wrappe object.\n         */\n        protected Object get()\n        {\n            return myReference;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "    public static final class ByValue\n    {\n        /**\n         * What we're going to take the value of.\n         */\n        private final Object myReference;\n\n        /**\n         * Constructor.\n         *\n         * @param reference the reference to use.\n         */\n        protected ByValue(final Object reference)\n        {\n            myReference = reference;\n        }\n\n        /**\n         * Get the wrapped object.\n         *\n         * @return the wrappe object.\n         */\n        protected Object get()\n        {\n            return myReference;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"ByValue{\" + myReference + \"}\";\n        }\n    }\n\n    /**\n     * Method to \"annotate\" a reference and denote that it should be sent by\n     * value in invoke() calls.\n     *\n     * <p>In order to send values by reference they must be supported by the\n     * {@link PythonPickle} class.\n     *\n     * @param reference  The reference to use.\n     *\n     * @return the value.\n     */", "    public static ByValue byValue(final Object reference)\n    {\n        return new ByValue(reference);\n    }\n\n    /**\n     * Perform a Python exec() call in the global context.\n     *\n     * <p>The Python exec call performs dynamic execution of Python code in the\n     * global context. This is what you want to use should you desire to do\n     * things like {@code from foo.bar import baz}.\n     *\n     * @param string  The code to exec.\n     *\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */", "    public void exec(final String string)\n        throws IOException,\n               PythonCallbackException;\n\n    /**\n     * Perform a python eval() call on an expression.\n     *\n     * @param string  The code to eval.\n     *\n     * @return the result of the eval.\n     *\n     * @throws ClassCastException      if there was a problem returning the result.\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */", "    public default Object eval(final String string)\n        throws ClassCastException,\n               IOException,\n               PythonCallbackException\n    {\n        return eval(string, Object.class);\n    }\n\n    /**\n     * Perform a python eval() call on an expression. The returnType tells\n     * Python what we expect to get back.\n     *\n     * @param <T>         The type of the return value.\n     * @param string      The code to eval.\n     * @param returnType  The type to return the value as.\n     *\n     * @return the result of the eval.\n     *\n     * @throws ClassCastException      if there was a problem returning the result.\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */\n    public <T> T eval(final String string, final Class<T> returnType)\n        throws ClassCastException,\n               IOException,\n               PythonCallbackException;\n\n    /**\n     * Set a variable to point to a Java value in the Python globals.\n     *\n     * @param name   The name of the value to set.\n     * @param value  The value to set with.\n     *\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */", "    public void setGlobalVariable(final String name, final Object value)\n        throws IOException,\n               PythonCallbackException;\n\n    /**\n     * Call a python function call with the given args.\n     *\n     * <p>If an argument is wrapped by {@code byValue()} then the\n     * {@link PythonPickle} class will be used to send it over the wire,\n     * otherwise arguments are passed by reference.\n     *\n     * @param functionName  The name of the function to invoke.\n     * @param args          The function arguments.\n     *\n     * @return the result.\n     *\n     * @throws ClassCastException      if there was a problem returning the result.\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */", "    public default Object invoke(final String functionName,\n                                 final Object... args)\n        throws ClassCastException,\n               IOException,\n               PythonCallbackException\n    {\n        return invoke(functionName, Object.class, args);\n    }\n\n    /**\n     * Call a python function call with the given args. The returnType tells\n     * Python what we expect to get back.\n     * <p>\n     * If an argument is wrapped by {@code byValue()} then the {@link\n     * PythonPickle} class will be used to send it over the wire, otherwise\n     * arguments are passed by reference.\n     *\n     * @param <T>           The type of the return value.\n     * @param functionName  The name of the function to invoke.\n     * @param returnType    The type to return the value as.\n     * @param args          The function arguments.\n     *\n     * @return the result.\n     *\n     * @throws ClassCastException      if there was a problem returning the result.\n     * @throws IOException             if there was a problem.\n     * @throws PythonCallbackException if calling Python resulted in an exception.\n     */\n    public <T> T invoke(final String    functionName,\n                        final Class<T>  returnType,\n                        final Object... args)\n        throws ClassCastException,\n               IOException,\n               PythonCallbackException;\n\n    /**\n     * Get a wrapper around a Python object.\n     *\n     * @param string the object to get.\n     *\n     * @return the wrapper.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public default PythonObject getObject(final String string)\n        throws Throwable\n    {\n        return getObject(string, null);\n    }\n\n    /**\n     * Get a wrapper around a Python object.\n     *\n     * @param string The string to representing the object.\n     * @param name   What to name the local instance, if anything.\n     *\n     * @return the result of the lookup, if any.\n     *\n     * @throws Throwable if there was a problem\n     */", "    public PythonObject getObject(final String string,\n                                  final String name)\n        throws Throwable;\n\n    /**\n     * Invokes the given function name with the provided arguments and\n     * returns a wrapper around the resulting Python object.\n     *\n     * @param functionName The function to invoke.\n     * @param args         The arguments to provide to the function.\n     *\n     * @return the result of the call, if any.\n     *\n     * @throws Throwable if there was a problem\n     */", "    public PythonObject invokeAndGetObject(final String functionName,\n                                           final Object... args)\n        throws Throwable;\n\n    /**\n     * Close the connection.\n     */\n    public void close();\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/SocketTransport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\nimport java.net.Socket;\n\n/**", "\n/**\n * A raw socket transport.\n */\n/*package*/ class SocketTransport\n    implements Transport\n{\n    /**\n     * Our socket.\n     */", "     * Our socket.\n     */\n    private final Socket mySocket;\n\n    /**\n     * Our description.\n     */\n    private final String myString;\n\n    /**", "\n    /**\n     * CTOR.\n     */\n    public SocketTransport(final Socket socket)\n    {\n        mySocket = socket;\n        myString = String.valueOf(socket.getRemoteSocketAddress());\n    }\n", "    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getRemoteAddress()\n    {\n        return mySocket.getInetAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String getUserName()\n    {\n        // There's no way to know..!\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getInputStream()\n        throws IOException\n    {\n        return mySocket.getInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public InputStream getInputStream()\n        throws IOException\n    {\n        return mySocket.getInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return mySocket.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return mySocket.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {", "    public void close()\n    {\n        try {\n            mySocket.close();\n        }\n        catch (Throwable t) {\n            // Nothing\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return mySocket.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return myString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isLocalhost()\n    {\n        // Socket transport could happen on the same host, but we'll assume it\n        // doesn't for now. We'll look into determining this at a later date.\n        return false;\n    }\n}\n", "    public boolean isLocalhost()\n    {\n        // Socket transport could happen on the same host, but we'll assume it\n        // doesn't for now. We'll look into determining this at a later date.\n        return false;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/SocketProvider.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.IOException;\n\nimport java.net.ServerSocket;\n\n/**\n * A transport provider for a raw socket connection.\n *\n * <p>This is probably the most basic use-case for RMI, but it provides", " *\n * <p>This is probably the most basic use-case for RMI, but it provides\n * <b>absolutely no</b> user authentication. (And, as such, there is nothing to\n * stop anyone from connecting to your PJRmi instance and running arbitrary code\n * and/or commands from it.) Given this you should probably not really be using\n * it for anything other than testing etc.\n */\npublic class SocketProvider\n    implements Transport.Provider\n{\n    /**\n     * The server socket which we use.\n     */\n    private final ServerSocket myServerSocket;\n\n    /**\n     * Our string representation.\n     */\n    private final String myString;\n\n    /**\n     * CTOR.\n     *\n     * @param port  The port to listen on.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public SocketProvider(int port)\n        throws IOException\n    {\n        myServerSocket = new ServerSocket(port);\n        myString       = \"Socket[\" + port + \"]\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public Transport accept()\n        throws IOException\n    {\n        return new SocketTransport(myServerSocket.accept());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return myString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        myServerSocket.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void close()\n        throws IOException\n    {\n        myServerSocket.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return myServerSocket.isClosed();\n    }\n}\n", "    public boolean isClosed()\n    {\n        return myServerSocket.isClosed();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonMinionTransport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.BufferedReader;\nimport java.io.EOFException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;", "\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A transport which spawns a Python child and sets it up as a minion", "/**\n * A transport which spawns a Python child and sets it up as a minion\n * process.\n */\n/*package*/ class PythonMinionTransport\n    implements Transport\n{\n    /**\n     * How we uniquely identify threads.\n     */", "     * How we uniquely identify threads.\n     */\n    private static final AtomicInteger ourThreadId = new AtomicInteger(0);\n\n    /**\n     * The process we spawn.\n     */\n    private final Process myPythonMinion;\n\n    /**", "\n    /**\n     * CTOR.\n     */\n    public PythonMinionTransport(final String  stdinFilename,\n                                 final String  stdoutFilename,\n                                 final String  stderrFilename,\n                                 final boolean useShmArgPassing)\n    {\n        // The command which we run inside the python process to turn it", "    {\n        // The command which we run inside the python process to turn it\n        // into a minion instance for us\n        String comma = \"\";\n        final StringBuilder command = new StringBuilder();\n        command.append(\"from pjrmi import become_pjrmi_minion; \");\n        command.append(\"become_pjrmi_minion(\");\n        if (stdinFilename != null) {\n            command.append(comma) // <-- A NOP but future-proofing via symmetry\n                   .append(\"stdin='\").append(stdinFilename).append(\"'\");\n            comma = \", \";\n        }", "        if (stdoutFilename != null) {\n            command.append(comma)\n                   .append(\"stdout='\").append(stdoutFilename).append(\"'\");\n            comma = \", \";\n        }\n        if (stderrFilename != null) {\n            command.append(comma)\n                   .append(\"stderr='\").append(stderrFilename).append(\"'\");\n            comma = \", \";\n        }\n        if (useShmArgPassing) {\n            command.append(comma)\n                   .append(\"use_shm_arg_passing=True\");\n            comma = \", \"; // <-- Ditto future-proofing via symmetry\n        }\n        command.append(\");\");\n\n        // How we spawn the child\n        final ProcessBuilder pb =\n            new ProcessBuilder(\"python3\", \"-c\", command.toString());", "        if (useShmArgPassing) {\n            command.append(comma)\n                   .append(\"use_shm_arg_passing=True\");\n            comma = \", \"; // <-- Ditto future-proofing via symmetry\n        }\n        command.append(\");\");\n\n        // How we spawn the child\n        final ProcessBuilder pb =\n            new ProcessBuilder(\"python3\", \"-c\", command.toString());\n        try {\n            // Spawn the child\n            myPythonMinion = pb.start();\n\n            // Spawn a thread to dump out any remaining output from the\n            // child. If stdout and stderr have been defined above this\n            // won't be a lot.\n            final Thread stderr = new Thread(\n                () -> {\n                    final BufferedReader err =\n                        new BufferedReader(\n                            new InputStreamReader(\n                                myPythonMinion.getErrorStream()\n                            )\n                        );", "        try {\n            // Spawn the child\n            myPythonMinion = pb.start();\n\n            // Spawn a thread to dump out any remaining output from the\n            // child. If stdout and stderr have been defined above this\n            // won't be a lot.\n            final Thread stderr = new Thread(\n                () -> {\n                    final BufferedReader err =\n                        new BufferedReader(\n                            new InputStreamReader(\n                                myPythonMinion.getErrorStream()\n                            )\n                        );", "                    try {\n                        while (true) {\n                            final String line = err.readLine();\n                            if (line == null) {\n                                // EOF encountered\n                                PJRmi.LOG.info(\"[Python child] <EOF>\");\n                                return;\n                            }\n                            PJRmi.LOG.info(\"[Python child] \" + line);\n                        }\n                    }\n                    catch (IOException e) {\n                        // Done, one way or another\n                    }\n                },\n                \"PythonMinionStderr-\" + ourThreadId.incrementAndGet()\n            );\n            stderr.setDaemon(true);\n            stderr.start();\n\n            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n            // Spool forward to the transport's hello string; this tells us\n            // that it's ready for work and ensures that we don't accidently\n            // try to interpret random foo, appearing on stdout during\n            // python's start-up, as something for us. We embed some magic\n            // hex values (0xFeedBeef) to try to ensure that we don't\n            // accidently clash with another hello string.\n            final String hello =\n                String.format(\"PYTHON IS READY: %c%c%c%c\",\n                              (char)0xfe, (char)0xed, (char)0xbe, (char)0xef);\n            final InputStream in = myPythonMinion.getInputStream();\n            int index = 0;", "            while (index < hello.length()) {\n                final int read = in.read();\n                if (read == -1) {\n                    // EOF'd on us?\n                    throw new EOFException(\n                        \"Child stream closed before hello string could be read\"\n                    );\n                }\n\n                // Accept the next matching char; if it doesn't match\n                // then we reset back to the start of the string.", "                if (read != (int)hello.charAt(index++)) {\n                    index = 0;\n                }\n            }\n        }\n        catch (Throwable e) {\n            throw new RuntimeException(\"Failed to spawn Python child\", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String getUserName()\n    {\n        // Must be this\n        return System.getProperty(\"user.name\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getRemoteAddress()\n    {", "    public InetAddress getRemoteAddress()\n    {\n        try {\n            return InetAddress.getLocalHost();\n        }\n        catch (UnknownHostException e) {\n            return InetAddress.getLoopbackAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public InputStream getInputStream()\n        throws IOException\n    {\n        return myPythonMinion.getInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myPythonMinion.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myPythonMinion.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {", "    public void close()\n    {\n        try {\n            myPythonMinion.destroy();\n        }\n        catch (Throwable t) {\n            // Nothing\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return !myPythonMinion.isAlive();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return myPythonMinion.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myPythonMinion.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n", "    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/SourceInjector.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\nimport java.util.Arrays;", "\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.tools.Diagnostic;\nimport javax.tools.DiagnosticCollector;\nimport javax.tools.FileObject;\nimport javax.tools.ForwardingJavaFileManager;\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileManager;", "import javax.tools.JavaCompiler;\nimport javax.tools.JavaFileManager;\nimport javax.tools.JavaFileObject;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.StandardJavaFileManager;\nimport javax.tools.ToolProvider;\n\n/**\n * How we dynamically compile and inject compiled classes from a string.\n */\npublic class SourceInjector\n{\n    /**\n     * A {@code SimpleJavaFileObject} represented as a {@code String}.\n     */\n    private static class JavaStringObject\n        extends SimpleJavaFileObject\n    {\n        /**\n         * The source code in the file object.\n         */\n        private final String mySource;\n\n        /**\n         * CTOR.\n         */\n        protected JavaStringObject(final String name, final String source)\n        {\n            // Convert the name to a valid URI\n            super(URI.create(\"string:///\"                +\n                             name.replaceAll(\"\\\\.\", \"/\") +\n                             Kind.SOURCE.extension),\n                  Kind.SOURCE);\n\n            mySource = source;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", " * How we dynamically compile and inject compiled classes from a string.\n */\npublic class SourceInjector\n{\n    /**\n     * A {@code SimpleJavaFileObject} represented as a {@code String}.\n     */\n    private static class JavaStringObject\n        extends SimpleJavaFileObject\n    {\n        /**\n         * The source code in the file object.\n         */\n        private final String mySource;\n\n        /**\n         * CTOR.\n         */\n        protected JavaStringObject(final String name, final String source)\n        {\n            // Convert the name to a valid URI\n            super(URI.create(\"string:///\"                +\n                             name.replaceAll(\"\\\\.\", \"/\") +\n                             Kind.SOURCE.extension),\n                  Kind.SOURCE);\n\n            mySource = source;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public CharSequence getCharContent(final boolean ignoreEncodingErrors)\n        {\n            // No need to read any files; we already have the source code\n            return mySource;\n        }\n    }\n\n    /**\n     * A {@link SimpleJavaFileObject} represented as a {@link ByteArrayOutputStream}.\n     */\n    private static class JavaByteObject\n        extends SimpleJavaFileObject\n    {\n        /**\n         * The byte stream.\n         */\n        private ByteArrayOutputStream myOutputStream;\n\n        /**\n         * CTOR.\n         */\n        protected JavaByteObject(final String name)\n            throws URISyntaxException\n        {\n            // Convert the name to a valid URI\n            super(URI.create(\"bytes:///\" + name.replaceAll(\"\\\\.\", \"/\")),\n                  Kind.CLASS);\n\n            myOutputStream = new ByteArrayOutputStream();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public OutputStream openOutputStream()\n        {\n            return myOutputStream;\n        }\n\n        /**\n         * Get a copy of the {@code byte[]} from the underlying stream.\n         */\n        public byte[] getBytes()\n        {\n            return myOutputStream.toByteArray();\n        }\n    }\n\n    /**\n     * Create a custom {@link ForwardingJavaFileManager} so that it\n     * recognizes the given {@code byteObject} as a file.\n     */\n    private static JavaFileManager\n        createFileManager(final StandardJavaFileManager fileManager,\n                          final JavaByteObject          byteObject)\n    {\n        return new ForwardingJavaFileManager<StandardJavaFileManager>(fileManager)\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public JavaFileObject\n                getJavaFileForOutput(final Location            location,\n                                     final String              className,\n                                     final JavaFileObject.Kind kind,\n                                     final FileObject          sibling)\n            {\n                return byteObject;\n            }\n        };\n    }\n\n    /**\n     * Create a custom ClassLoader so that it can find the {@code byteObject}\n     * as the definition for a class.\n     */\n    private static ClassLoader createClassLoader(final JavaByteObject byteObject)\n    {\n        return new ClassLoader()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public Class<?> findClass(final String className)\n            {\n                // This replaces the need to search for the class\n                final byte[] bytes = byteObject.getBytes();\n\n                return defineClass(className, bytes, 0, bytes.length);\n            }\n        };\n    }\n\n    /**\n     * Compiles and injects a new class definition from the {@code source}.\n     *\n     * @throws ClassNotFoundException If some error happened which prevented\n     *                                class instantiation.\n     */", "    public static Class<?> inject(final String className, final String source)\n        throws ClassNotFoundException\n    {\n        // Sanity\n        if (className == null) {\n            throw new ClassNotFoundException(\"Given a null class name\");\n        }\n        if (source == null || source.isEmpty()) {\n            throw new ClassNotFoundException(\"Source was null or missing\");\n        }\n\n        // Instantiate the compiler with a diagnostic collector, which\n        // stores any diagnostics (e.g. error messages) from compilation.\n        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        final DiagnosticCollector<JavaFileObject> diagnostics =\n            new DiagnosticCollector<>();\n\n        // This will hold the compiled code\n        final JavaByteObject byteObject;", "        try {\n            byteObject = new JavaByteObject(className);\n        }\n        catch (Exception e) {\n            throw new ClassNotFoundException(\n                \"Could not create the raw source data for \" + className,\n                e\n            );\n        }\n\n        // Instantiate the custom file manager, which recognizes the\n        // compiled code stored in the  byteObject as a file.\n        final StandardJavaFileManager standardFileManager =\n            compiler.getStandardFileManager(diagnostics, null, null);\n        final JavaFileManager fileManager =\n            createFileManager(standardFileManager, byteObject);\n\n        // Format the source code for compilation\n        final JavaStringObject stringObject =\n            new JavaStringObject(className, source);\n\n        // Set up the compilation task. We will use -parameters option to store\n        // formal parameter names of constructors and methods in the compiled\n        // class.\n        final JavaCompiler.CompilationTask task =\n            compiler.getTask(null,                           // Writer\n                             fileManager,\n                             diagnostics,\n                             Arrays.asList(\"-parameters\"),   // Options\n                             null,                           // Classes\n                             Arrays.asList(stringObject));\n\n        // Compile the class, throwing an exception if there are any errors", "        if (!task.call()) {\n            // Format the error message\n            StringBuilder errorMsg = new StringBuilder();\n            for (Diagnostic d : diagnostics.getDiagnostics()) {\n                final int lineNumber = (int)d.getLineNumber();\n                errorMsg.append(\"Compilation error: line \")\n                        .append(lineNumber)\n                        .append(' ')\n                        .append(d.getMessage(null));\n\n                // Print the erroneous line (lineNumber is 1-indexed)\n                boolean found = false;\n                final StringBuilder sb = new StringBuilder();", "                for (int i = 0, line = 1;\n                     i < source.length() && line <= lineNumber;\n                     i++)\n                {\n                    final char c = source.charAt(i);\n                    if (c == '\\n') {\n                        line++;\n                    }\n                    else if (line == lineNumber) {\n                        if (!found) {\n                            found = true;\n                            errorMsg.append(\" in: \");\n                        }\n                        errorMsg.append(c);\n                    }\n                }\n            }\n            throw new ClassNotFoundException(\n                errorMsg + \" \" +\n                \"(Are the className variable, \\\"\" + className + \"\\\", \" +\n                \"and the class name in the source code the same?)\"\n            );\n        }\n\n        // Clean up", "                    else if (line == lineNumber) {\n                        if (!found) {\n                            found = true;\n                            errorMsg.append(\" in: \");\n                        }\n                        errorMsg.append(c);\n                    }\n                }\n            }\n            throw new ClassNotFoundException(\n                errorMsg + \" \" +\n                \"(Are the className variable, \\\"\" + className + \"\\\", \" +\n                \"and the class name in the source code the same?)\"\n            );\n        }\n\n        // Clean up", "        try {\n            fileManager.close();\n        }\n        catch (IOException e) {\n            // This should not happen since we don't do any IO\n            throw new ClassNotFoundException(\n                \"Unexpected IOException when tidying up\",\n                e\n            );\n        }\n\n        // Load the class from the byte object that holds the compiled code\n        final ClassLoader inMemoryClassLoader = createClassLoader(byteObject);\n\n        // And give it back\n        return inMemoryClassLoader.loadClass(className);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PipedTransport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**", "\n/**\n * An inter-thread piped transport.\n */\n/*package*/ class PipedTransport\n    implements Transport\n{\n    /**\n     * Our pipe.\n     */", "     * Our pipe.\n     */\n    private final PipedProvider.BidirectionalPipe myPipe;\n\n    /**\n     * CTOR.\n     */\n    public PipedTransport(final PipedProvider.BidirectionalPipe pipe)\n    {\n        myPipe = pipe;", "    {\n        myPipe = pipe;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getUserName()\n    {\n        // Must be this\n        return System.getProperty(\"user.name\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String getUserName()\n    {\n        // Must be this\n        return System.getProperty(\"user.name\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getRemoteAddress()\n    {", "    public InetAddress getRemoteAddress()\n    {\n        try {\n            return InetAddress.getLocalHost();\n        }\n        catch (UnknownHostException e) {\n            return InetAddress.getLoopbackAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public InputStream getInputStream()\n        throws IOException\n    {\n        return myPipe.getJavaInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myPipe.getJavaOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myPipe.getJavaOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {", "    public void close()\n    {\n        try {\n            myPipe.close();\n        }\n        catch (Throwable t) {\n            // Nothing\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return myPipe.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return myPipe.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myPipe.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n", "    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/Transport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\n\nimport java.util.Arrays;\nimport java.util.HashSet;", "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * An abstraction of the data transport which is used to allow the Python\n * instance to talk to us.\n *\n * <p>This mainly provides an {@link InputStream} and {@link OutputStream} once\n * a client has connected to us.", " * <p>This mainly provides an {@link InputStream} and {@link OutputStream} once\n * a client has connected to us.\n */\npublic interface Transport\n{\n    /**\n     * What provides us with a transport. This mainly sits there, waiting for a\n     * client to connect.\n     */\n    public static interface Provider\n    {\n        /**\n         * The arguments to the provider.\n         */", "    public static interface Provider\n    {\n        /**\n         * The arguments to the provider.\n         */\n        public static class Arguments\n        {\n            /**\n             * The set of classes to allow, if blocking is enabled.\n             */\n            public Set<Object> additionalAllowlistedClasses;\n\n            /**\n             * Whether to allow class injection.\n             */", "            public Boolean allowClassInjection;\n\n            /**\n             * Whether to block access to non-allowlisted classes.\n             */\n            public Boolean blockNonAllowlistedClasses;\n\n            /**\n             * The number of workers to use.\n             */\n            public int numWorkers;\n\n            /**\n             * Whether to use locking.\n             */", "            public int numWorkers;\n\n            /**\n             * Whether to use locking.\n             */\n            public boolean useLocking;\n\n            /**\n             * Constructor, which will parse the given arguments.\n             *\n             * @throws IllegalArgumentException if a bad argument was supplied.\n             */\n            public Arguments(final String... args)\n            {\n                // Defaults\n                additionalAllowlistedClasses = new HashSet<>();\n                allowClassInjection          = null;\n                blockNonAllowlistedClasses   = null;\n                numWorkers                   = 0;\n                useLocking                   = false;\n\n                // And parse", "                if (args != null && args.length > 0) {\n                    for (String arg : args) {\n                        if (arg.startsWith(\"additional_allowlisted_classes=\")) {\n                            additionalAllowlistedClasses.addAll(\n                                Arrays.asList(arg.substring(31).split(\",\"))\n                            );\n                        }\n                        else if (arg.startsWith(\"allow_class_injection=\")) {\n                            allowClassInjection =\n                                Boolean.valueOf(arg.substring(22));\n                        }", "                        else if (arg.startsWith(\"block_non_allowlisted_classes=\")) {\n                            blockNonAllowlistedClasses =\n                                Boolean.valueOf(arg.substring(30));\n                        }\n                        else if (arg.startsWith(\"num_workers=\")) {\n                            numWorkers =\n                                Integer.valueOf(arg.substring(12));\n                        }\n                        else if (arg.startsWith(\"use_locking=\")) {\n                            useLocking =\n                                Boolean.valueOf(arg.substring(12));\n                        }\n                        else {\n                            throw new IllegalArgumentException(\n                                \"Unhandled argument: \" + arg\n                            );\n                        }\n                    }\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "                        else if (arg.startsWith(\"use_locking=\")) {\n                            useLocking =\n                                Boolean.valueOf(arg.substring(12));\n                        }\n                        else {\n                            throw new IllegalArgumentException(\n                                \"Unhandled argument: \" + arg\n                            );\n                        }\n                    }\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public String toString()\n            {\n                return\n                    \"additional_allowlisted_classes=\" +\n                        additionalAllowlistedClasses + \" \" +\n                    \"allow_class_injection=\" +\n                        allowClassInjection + \" \" +\n                    \"block_non_allowlisted_classes=\" +\n                        blockNonAllowlistedClasses + \" \" +\n                    \"num_workers=\" +\n                        numWorkers + \" \" +\n                    \"use_locking=\" +\n                        useLocking;\n            }\n        }\n\n        /**\n         * Accept a connection from a client.\n         *\n         * @return The resultant transport instance.\n         *\n         * @throws IOException if there was a problem.\n         */", "        public Transport accept()\n            throws IOException;\n\n        /**\n         * A brief description of this Provider.\n         *\n         * @return The description.\n         */\n        @Override\n        public String toString();\n\n        /**\n         * Releases the resources related to this provider.\n         *\n         * @throws IOException raises this exception if the provider is\n         *                     unable to release the resources.\n         */", "        public String toString();\n\n        /**\n         * Releases the resources related to this provider.\n         *\n         * @throws IOException raises this exception if the provider is\n         *                     unable to release the resources.\n         */\n        public void close()\n            throws IOException;\n\n        /**\n         * Whether the provider has been {@code close()}'d.\n         *\n         * @return whether the provider is closed.\n         */", "        public void close()\n            throws IOException;\n\n        /**\n         * Whether the provider has been {@code close()}'d.\n         *\n         * @return whether the provider is closed.\n         */\n        public boolean isClosed();\n    }\n\n    /**\n     * Get the <i>authenticated</i> username of the client at the end of the\n     * transport, or null if this does not exist.\n     *\n     * @return the username.\n     */", "        public boolean isClosed();\n    }\n\n    /**\n     * Get the <i>authenticated</i> username of the client at the end of the\n     * transport, or null if this does not exist.\n     *\n     * @return the username.\n     */\n    public String getUserName();\n\n    /**\n     * Get the {@link InetAddress} of the remote client, if any.\n     *\n     * @return The {@link InetAddress} from which the client connection is\n     *         being made, or {@code null} if it could not be determined.\n     */", "    public String getUserName();\n\n    /**\n     * Get the {@link InetAddress} of the remote client, if any.\n     *\n     * @return The {@link InetAddress} from which the client connection is\n     *         being made, or {@code null} if it could not be determined.\n     */\n    public InetAddress getRemoteAddress();\n\n    /**\n     * Get a handle on the InputStream.\n     *\n     * @throws IOException if there was a problem.\n     */", "    public InetAddress getRemoteAddress();\n\n    /**\n     * Get a handle on the InputStream.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public InputStream getInputStream()\n        throws IOException;\n\n    /**\n     * Get a handle on the OutputStream.\n     *\n     * @throws IOException if there was a problem.\n     */", "    public OutputStream getOutputStream()\n        throws IOException;\n\n    /**\n     * Close the transport; this renders it unusable.\n     */\n    public void close();\n\n    /**\n     * Whether the connection has been {@code close()}'d.\n     *\n     * @return whether the transport is closed.\n     */", "    public boolean isClosed();\n\n    /**\n     * A brief description of this Transport.\n     *\n     * @return the description.\n     */\n    @Override\n    public String toString();\n\n    /**\n     * Returns whether we are guaranteed to be on the same host. Might\n     * return {@code false} even if we are but never {@code true} if we are\n     * not.\n     *\n     * @return {@code true} if on localhost.\n     */", "    public String toString();\n\n    /**\n     * Returns whether we are guaranteed to be on the same host. Might\n     * return {@code false} even if we are but never {@code true} if we are\n     * not.\n     *\n     * @return {@code true} if on localhost.\n     */\n    public boolean isLocalhost();\n}\n", "    public boolean isLocalhost();\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonObject.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.IOException;\n\nimport java.lang.reflect.UndeclaredThrowableException;\n\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.BiPredicate;", "import java.util.function.BiFunction;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\n\n/**\n * A wrapper around an object sitting in the Python interpreter.", "/**\n * A wrapper around an object sitting in the Python interpreter.\n *\n * <p>A word about runtime errors. Since The Python objects may be mutated in\n * the background after a PythonObject wrapper is instantiated all errors are\n * thrown when you attempt interact with the object. That is to say, you won't\n * see a NoSuchMethodException until you attempt to call {@code invoke()}.\n */\npublic abstract class PythonObject\n{\n    /**\n     * Constructor, forces local implementation since we only really want\n     * this to be implemented by PythonObjectImpl.\n     */\n    protected PythonObject()\n    {\n        // Nothing\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param methodName  The name of the method to invoke.\n     * @param args        The method's arguments, if any (may be null).\n     *\n     * @return the resultant object.\n     *\n     * @throws Throwable if there was a problem.\n     */", "public abstract class PythonObject\n{\n    /**\n     * Constructor, forces local implementation since we only really want\n     * this to be implemented by PythonObjectImpl.\n     */\n    protected PythonObject()\n    {\n        // Nothing\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param methodName  The name of the method to invoke.\n     * @param args        The method's arguments, if any (may be null).\n     *\n     * @return the resultant object.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public PythonObject invoke(final String    methodName,\n                               final Object... args)\n        throws Throwable\n    {\n        return invoke(PythonObject.class, methodName, null, args);\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param methodName  The name of the method to invoke.\n     * @param kwargs      The method's keyword arguments, if any (may be null).\n     * @param args        The method's arguments, if any (may be null).\n     *\n     * @return the resultant object.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public PythonObject invoke(final String             methodName,\n                               final Map<String,Object> kwargs,\n                               final Object...          args)\n        throws Throwable\n    {\n        return invoke(PythonObject.class, methodName, kwargs, args);\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param <T>         The type of the result.\n     * @param returnType  The return type expected of the method (may be null).\n     * @param methodName  The name of the method to invoke.\n     * @param args        The method's arguments, if any (may be null).\n     *\n     * @return the resultant object.\n     *\n     * @throws Throwable if there was a problem.\n     */\n    public <T> T invoke(final Class<T>  returnType,\n                        final String    methodName,\n                        final Object... args)\n        throws Throwable\n    {\n        return invoke(returnType, methodName, null, args);\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param <T>         The type of the result.\n     * @param returnType  The return type expected of the method (may be null).\n     * @param methodName  The name of the method to invoke.\n     * @param kwargs      The method's keyword arguments, if any (may be null).\n     * @param args        The method's arguments, if any (may be null).\n     *\n     * @return the resultant object.\n     *\n     * @throws Throwable if there was a problem.\n     */\n    public abstract <T> T invoke(final Class<T>           returnType,\n                                 final String             methodName,\n                                 final Map<String,Object> kwargs,\n                                 final Object...          args)\n        throws Throwable;\n\n    /**\n     * Get a field from the object.\n     *\n     * @param fieldName  The name of the field in the object.\n     *\n     * @return the field.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public PythonObject getattr(final String fieldName)\n        throws Throwable\n    {\n        return getattr(PythonObject.class, fieldName);\n    }\n\n    /**\n     * Get a field from the object.\n     *\n     * @param <T>        The type of the field.\n     * @param fieldType  The field's type.\n     * @param fieldName  The name of the field in the object.\n     *\n     * @return the field.\n     *\n     * @throws Throwable if there was a problem.\n     */\n    public abstract <T> T getattr(final Class<T> fieldType,\n                                  final String   fieldName)\n        throws Throwable;\n\n    /**\n     * Get a wrapper for this object which attempts to treat it as the given\n     * Java interface.\n     *\n     * @param <T>    The new type.\n     * @param klass  The new type.\n     *\n     * @return the field.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public abstract <T> T asProxy(final Class<T> klass)\n        throws IOException;\n\n    // -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -\n\n    // Functionals sugar\n\n    /**\n     * Get a function by name bound to this instance as a PythonFunction. If\n     * the function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The function return type.\n     * @param returnType  The type to cast the result to.\n     * @param methodName  The name of the method.\n     *\n     * @return the function.\n     */\n    public <T> PythonFunction<T> getMethod(final Class<T> returnType,\n                                           final String   methodName)\n    {\n        return\n            new PythonFunction<T>()\n            {\n                @Override", "                public T invoke(final Object... args)\n                    throws Throwable\n                {\n                    return PythonObject.this.invoke(returnType,\n                                                    methodName,\n                                                    args);\n                }\n\n                @Override\n                public String toString()\n                {\n                    return returnType.getSimpleName() + \" \" +\n                           methodName + \"(*args)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a PythonKwargsFunction.\n     * If the function does not exist then you will get an exception when\n     * you attempt to invoke it.\n     *\n     * @param <T>         The function return type.\n     * @param returnType  The type to cast the result to.\n     * @param methodName  The name of the method.\n     *\n     * @return the function.\n     */\n    public <T> PythonKwargsFunction<T> getKwargsMethod(final Class<T> returnType,\n                                                       final String   methodName)\n    {\n        return\n            new PythonKwargsFunction<T>()\n            {\n                @Override", "                public String toString()\n                {\n                    return returnType.getSimpleName() + \" \" +\n                           methodName + \"(*args)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a PythonKwargsFunction.\n     * If the function does not exist then you will get an exception when\n     * you attempt to invoke it.\n     *\n     * @param <T>         The function return type.\n     * @param returnType  The type to cast the result to.\n     * @param methodName  The name of the method.\n     *\n     * @return the function.\n     */\n    public <T> PythonKwargsFunction<T> getKwargsMethod(final Class<T> returnType,\n                                                       final String   methodName)\n    {\n        return\n            new PythonKwargsFunction<T>()\n            {\n                @Override", "                public T invoke(final Map<String,Object> kwargs,\n                                final Object...          args)\n                    throws Throwable\n                {\n                    return PythonObject.this.invoke(returnType,\n                                                    methodName,\n                                                    kwargs,\n                                                    args);\n                }\n\n                @Override", "                public String toString()\n                {\n                    return returnType.getSimpleName() + \" \" +\n                           methodName + \"(*args, **kwargs)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a Function. If the\n     * function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The function argument type.\n     * @param <R>         The function return type.\n     * @param returnType  The type to cast the result to.\n     * @param methodName  The name of the method.\n     *\n     * @return the function.\n     */\n    public <T,R> Function<T,R> getFunction(final Class<R> returnType,\n                                           final String   methodName)\n    {\n        return\n            new Function<T,R>()\n            {\n                @Override", "                public R apply(final T arg)\n                {\n                    try {\n                        return PythonObject.this.invoke(returnType,\n                                                        methodName,\n                                                        null,\n                                                        arg);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return returnType.getSimpleName() + \" \" + methodName + \"(?)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a BiFunction. If the\n     * function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The function's first argument type.\n     * @param <U>         The function's second argument type.\n     * @param <R>         The function return type.\n     * @param returnType  The type to cast the result to.\n     * @param methodName  The name of the method.\n     *\n     * @return the function.\n     */\n    public <T,U,R> BiFunction<T,U,R> getBiFunction(final Class<R> returnType,\n                                                   final String   methodName)\n    {\n        return\n            new BiFunction<T,U,R>()\n            {\n                @Override", "                public R apply(final T arg1, final U arg2)\n                {\n                    try {\n                        return PythonObject.this.invoke(returnType,\n                                                        methodName,\n                                                        null,\n                                                        arg1, arg2);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return returnType.getSimpleName() + \" \" +\n                           methodName + \"(?, ?)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a Consumer. If the\n     * function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The consumer's argument type.\n     * @param methodName  The name of the method.\n     *\n     * @return the consumer.\n     */\n    public <T> Consumer<T> getConsumer(final String methodName)\n    {\n        return\n            new Consumer<T>()\n            {\n                @Override", "                public void accept(final T arg)\n                {\n                    try {\n                        PythonObject.this.invoke(PythonObject.class,\n                                                 methodName,\n                                                 null,\n                                                 arg);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return \"void \" + methodName + \"(?)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a BiConsumer. If the\n     * function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The consumer's first argument type.\n     * @param <U>         The consumer's second argument type.\n     * @param methodName  The name of the method.\n     *\n     * @return the consumer.\n     */\n    public <T,U> BiConsumer<T,U> getBiConsumer(final String methodName)\n    {\n        return\n            new BiConsumer<T,U>()\n            {\n                @Override", "                public void accept(final T arg1, final U arg2)\n                {\n                    try {\n                        PythonObject.this.invoke(PythonObject.class,\n                                                 methodName,\n                                                 null,\n                                                 arg1, arg2);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return \"void \" + methodName + \"(?, ?)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a Predicate. If the\n     * function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The predicate's argument type.\n     * @param methodName  The name of the method.\n     *\n     * @return the predicate.\n     */\n    public <T> Predicate<T> getPredicate(final String methodName)\n    {\n        return\n            new Predicate<T>()\n            {\n                @Override", "                public boolean test (final T arg)\n                {\n                    try {\n                        return PythonObject.this.invoke(Boolean.class,\n                                                        methodName,\n                                                        null,\n                                                        arg);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return \"boolean \" + methodName + \"(?)\";\n                }\n            };\n    }\n\n    /**\n     * Get a function by name bound to this instance as a BiPredicate. If\n     * the function does not exist then you will get an exception when you\n     * attempt to invoke it.\n     *\n     * @param <T>         The predicate's first argument type.\n     * @param <U>         The predicate's second argument type.\n     * @param methodName  The name of the method.\n     *\n     * @return the predicate.\n     */\n    public <T,U> BiPredicate<T,U> getBiPredicate(final String methodName)\n    {\n        return\n            new BiPredicate<T,U>()\n            {\n                @Override", "                public boolean test(final T arg1, final U arg2)\n                {\n                    try {\n                        return PythonObject.this.invoke(Boolean.class,\n                                                        methodName,\n                                                        null,\n                                                        arg1, arg2);\n                    }\n                    catch (Throwable t) {\n                        throw new UndeclaredThrowableException(t);\n                    }\n                }\n\n                @Override", "                public String toString()\n                {\n                    return \"boolean \" + methodName + \"(?, ?)\";\n                }\n            };\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/UnixFifoTransport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**", "\n/**\n * An inter-process unix FIFO transport.\n */\n/*package*/ class UnixFifoTransport\n    implements Transport\n{\n    /**\n     * Our fifo.\n     */", "     * Our fifo.\n     */\n    private final UnixFifoProvider.Fifo myFifo;\n\n    /**\n     * CTOR.\n     */\n    public UnixFifoTransport(final UnixFifoProvider.Fifo fifo)\n    {\n        myFifo = fifo;", "    {\n        myFifo = fifo;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getUserName()\n    {\n        // Must be this\n        return System.getProperty(\"user.name\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String getUserName()\n    {\n        // Must be this\n        return System.getProperty(\"user.name\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getRemoteAddress()\n    {", "    public InetAddress getRemoteAddress()\n    {\n        try {\n            return InetAddress.getLocalHost();\n        }\n        catch (UnknownHostException e) {\n            return InetAddress.getLoopbackAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public InputStream getInputStream()\n        throws IOException\n    {\n        return myFifo.getInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myFifo.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public OutputStream getOutputStream()\n        throws IOException\n    {\n        return myFifo.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {", "    public void close()\n    {\n        try {\n            myFifo.close();\n        }\n        catch (Throwable t) {\n            // Nothing\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return myFifo.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return myFifo.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myFifo.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n", "    public boolean isLocalhost()\n    {\n        return true;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PipedProvider.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.io.BlockingPipe;\nimport com.deshaw.util.StringUtil;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;", "\nimport java.net.InetAddress;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * A transport provider which uses PipedStreams to allow users to\n * communicate with another thread inside the process.\n */\npublic class PipedProvider\n    implements Transport.Provider\n{\n    /**\n     * A simple PJRmi instance to use with this.\n     */", " * communicate with another thread inside the process.\n */\npublic class PipedProvider\n    implements Transport.Provider\n{\n    /**\n     * A simple PJRmi instance to use with this.\n     */\n    public static class PipedPJRmi\n        extends PJRmi\n    {\n        /**\n         * The arguments supplied to the instance.\n         */\n        private final Arguments myArguments;\n\n        /**\n         * Constructor.\n         *\n         * @param provider  The provider to use.\n         *\n         * @throws IOException              if there was a problem.\n         * @throws IllegalArgumentException if there was a problem.\n         */\n        public PipedPJRmi(PipedProvider provider)\n            throws IOException,\n                   IllegalArgumentException\n        {\n            this(provider, null);\n        }\n\n        /**\n         * Constructor.\n         *\n         * @param provider  The provider to use.\n         * @param args      The PJRmi arguments.\n         *\n         * @throws IOException              if there was a problem.\n         * @throws IllegalArgumentException if there was a problem.\n         */\n        public PipedPJRmi(PipedProvider provider, String[] args)\n            throws IOException,\n                   IllegalArgumentException\n        {\n            super(provider.toString(),\n                  provider,\n                  new Arguments(args).useLocking);\n            myArguments = new Arguments(args);\n\n            // Multi-threading doesn't yet work in the in-process world as it\n            // causes segfaults because there's no threading protection", "    public static class PipedPJRmi\n        extends PJRmi\n    {\n        /**\n         * The arguments supplied to the instance.\n         */\n        private final Arguments myArguments;\n\n        /**\n         * Constructor.\n         *\n         * @param provider  The provider to use.\n         *\n         * @throws IOException              if there was a problem.\n         * @throws IllegalArgumentException if there was a problem.\n         */\n        public PipedPJRmi(PipedProvider provider)\n            throws IOException,\n                   IllegalArgumentException\n        {\n            this(provider, null);\n        }\n\n        /**\n         * Constructor.\n         *\n         * @param provider  The provider to use.\n         * @param args      The PJRmi arguments.\n         *\n         * @throws IOException              if there was a problem.\n         * @throws IllegalArgumentException if there was a problem.\n         */\n        public PipedPJRmi(PipedProvider provider, String[] args)\n            throws IOException,\n                   IllegalArgumentException\n        {\n            super(provider.toString(),\n                  provider,\n                  new Arguments(args).useLocking);\n            myArguments = new Arguments(args);\n\n            // Multi-threading doesn't yet work in the in-process world as it\n            // causes segfaults because there's no threading protection", "            if (myArguments.numWorkers != 0) {\n                throw new IllegalArgumentException(\n                    \"Multi-threading not supporting for in-process instances\"\n                );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected Object getObjectInstance(CharSequence name)\n        {", "            if (StringUtil.equals(name, \"LockManager\")) {\n                return getLockManager();\n            }\n            else {\n                return null;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean isClassBlockingOn()\n        {\n            return (myArguments.blockNonAllowlistedClasses != null)\n                   ? myArguments.blockNonAllowlistedClasses\n                   : super.isClassBlockingOn();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean isClassPermitted(CharSequence className)\n        {\n            return\n                super.isClassPermitted(className) || (\n                    className != null &&\n                    myArguments.additionalAllowlistedClasses.contains(\n                        className.toString()\n                    )\n                );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean isClassInjectionPermitted()\n        {\n            return (myArguments.allowClassInjection != null)\n                   ? myArguments.allowClassInjection\n                   : super.isClassInjectionPermitted();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean isUserPermitted(CharSequence username)\n        {\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean isHostPermitted(InetAddress address)\n        {\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected int numWorkers()\n        {\n            // We don't support multiple workers and multi-threading in the\n            // in-process instance. Note that this method can be called in the\n            // super CTOR if use-locking is enabled; this means that we have a\n            // bootstrapping problem which needs to be fixed if we need to\n            // reference myArguments here.\n            return 0;\n        }\n    }\n\n    /**\n     * The pipe.\n     */", "    public static class BidirectionalPipe\n    {\n        /**\n         * Set to true when closed.\n         */\n        private volatile boolean myIsClosed;\n\n        /**\n         * The input pipe going from outside into us.\n         */\n        private final InputStream myJavaInputStream;\n\n        /**\n         * The output pipe going from us to the outside.\n         */\n        private final OutputStream myJavaOutputStream;\n\n        /**\n         * The input pipe going us to the outside.\n         */\n        private final InputStream myPythonInputStream;\n\n        /**\n         * The output pipe going from the outside to us.\n         */\n        private final OutputStream myPythonOutputStream;\n\n        /**\n         * Constructor.\n         */\n        private BidirectionalPipe()\n        {\n            // We are open, or will be when we are out of the CTOR anyhow\n            myIsClosed = false;\n\n            // Create and hook up the different ends\n            final BlockingPipe in  = new BlockingPipe(64 * 1024);\n            final BlockingPipe out = new BlockingPipe(64 * 1024);\n            myJavaInputStream    = in.getInputStream();\n            myJavaOutputStream   = out.getOutputStream();\n            myPythonInputStream  = out.getInputStream();\n            myPythonOutputStream = in.getOutputStream();\n        }\n\n        /**\n         * Close the pipe.\n         */", "        public void close()\n        {\n            // Close all the pipes\n            try { myJavaInputStream   .close(); } catch (IOException e) { }\n            try { myJavaOutputStream  .close(); } catch (IOException e) { }\n            try { myPythonInputStream .close(); } catch (IOException e) { }\n            try { myPythonOutputStream.close(); } catch (IOException e) { }\n            myIsClosed = true;\n        }\n\n        /**\n         * Whether the pipe has been {@code close()}'d.\n         *\n         * @return whether the pipe is closed.\n         */", "        public boolean isClosed()\n        {\n            return myIsClosed;\n        }\n\n        /**\n         * Read a byte from the pipe (from the outside world).\n         *\n         * @return the byte, or -1 if EOF\n         *\n         * @throws IOException if there was a problem.\n         */", "        public synchronized int read()\n            throws IOException\n        {\n            return myPythonInputStream.read();\n        }\n\n        /**\n         * Write a byte into pipe (from the outside world).\n         *\n         * @param b  The byte to write.\n         *\n         * @throws IOException if there was a problem.\n         */", "        public synchronized void write(int b)\n            throws IOException\n        {\n            myPythonOutputStream.write(b);\n        }\n\n        /**\n         * Get the Java input stream.\n         *\n         * @return the input stream.\n         */\n        protected InputStream getJavaInputStream()\n        {\n            return myJavaInputStream;\n        }\n\n        /**\n         * Get the Java output stream.\n         *\n         * @return the output stream.\n         */\n        protected OutputStream getJavaOutputStream()\n        {\n            return myJavaOutputStream;\n        }\n    }\n\n    /**\n     * The pipes waiting to connect.\n     */\n    private volatile BlockingQueue<BidirectionalPipe> myPendingPipes;\n\n    /**\n     * CTOR.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public PipedProvider()\n        throws IOException\n    {\n        myPendingPipes = new ArrayBlockingQueue<>(8);\n    }\n\n    /**\n     * Allow the outside world to get a Pipe instance to talk down. Blocks\n     * until the other side is close to being ready to service it.\n     *\n     * @return the new connection.\n     *\n     * @throws IOException if there was a problem.\n     */", "    public BidirectionalPipe newConnection()\n        throws IOException\n    {\n        final BidirectionalPipe pipe = new BidirectionalPipe();\n        for (BlockingQueue<BidirectionalPipe> pipes = myPendingPipes;\n             pipes != null;\n             pipes = myPendingPipes)\n        {\n            try {\n                pipes.put(pipe);\n                return pipe;\n            }\n            catch (InterruptedException e) {\n                // Just try again\n            }\n        }\n\n        // If we got here then we have been closed\n        throw new IOException(\"Provider is closed\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "            try {\n                pipes.put(pipe);\n                return pipe;\n            }\n            catch (InterruptedException e) {\n                // Just try again\n            }\n        }\n\n        // If we got here then we have been closed\n        throw new IOException(\"Provider is closed\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public Transport accept()\n        throws IOException\n    {\n        for (BlockingQueue<BidirectionalPipe> pipes = myPendingPipes;\n             pipes != null;\n             pipes = myPendingPipes)\n        {\n            try {\n                return new PipedTransport(pipes.take());\n            }\n            catch (InterruptedException e) {\n                // Just try again\n            }\n        }\n\n        // If we got here then we have been closed\n        throw new IOException(\"Provider is closed\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void close()\n    {\n        // Null the queue out so that new connections can't be made\n        final BlockingQueue<BidirectionalPipe> pipes = myPendingPipes;\n        myPendingPipes = null;\n\n        // Now clear the queue\n        for (BidirectionalPipe pipe : pipes) {\n            pipe.close();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return (myPendingPipes == null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return \"BidirectionalPipe\";\n    }\n}\n", "    public String toString()\n    {\n        return \"BidirectionalPipe\";\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/UnixFifoProvider.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.util.StringUtil;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.IOException;", "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;", "import java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * A transport provider which uses a Unix FIFO to allow users to communicate\n * with another process.", " * A transport provider which uses a Unix FIFO to allow users to communicate\n * with another process.\n */\npublic class UnixFifoProvider\n    implements Transport.Provider\n{\n    /**\n     * The FIFO.\n     */\n    public static class Fifo\n    {\n        /**\n         * Set to true when closed.\n         */\n        private volatile boolean myIsClosed;\n\n        /**\n         * The input fifo going from outside into us.\n         */\n        private final InputStream myInputStream;\n\n        /**\n         * The output fifo going from us to the outside.\n         */\n        private final OutputStream myOutputStream;\n\n        /**\n         * Constructor.\n         */\n        private Fifo(final String fromFifoname, final String toFifoname)\n            throws FileNotFoundException\n        {\n            final File toFile   = new File(toFifoname);\n            final File fromFile = new File(fromFifoname);\n\n            // Create the streams\n            myIsClosed     = false;\n            myOutputStream = new FileOutputStream(toFile, true);\n            myInputStream  = new FileInputStream (fromFile);\n\n            // We make this private communication", "    public static class Fifo\n    {\n        /**\n         * Set to true when closed.\n         */\n        private volatile boolean myIsClosed;\n\n        /**\n         * The input fifo going from outside into us.\n         */\n        private final InputStream myInputStream;\n\n        /**\n         * The output fifo going from us to the outside.\n         */\n        private final OutputStream myOutputStream;\n\n        /**\n         * Constructor.\n         */\n        private Fifo(final String fromFifoname, final String toFifoname)\n            throws FileNotFoundException\n        {\n            final File toFile   = new File(toFifoname);\n            final File fromFile = new File(fromFifoname);\n\n            // Create the streams\n            myIsClosed     = false;\n            myOutputStream = new FileOutputStream(toFile, true);\n            myInputStream  = new FileInputStream (fromFile);\n\n            // We make this private communication", "            try {\n                toFile  .setReadable(true, true);\n                toFile  .setWritable(true, true);\n                fromFile.setReadable(true, true);\n                fromFile.setWritable(true, true);\n            }\n            catch (SecurityException e) {\n                // Nothing, best effort\n            }\n        }\n\n        /**\n         * Close the fifo.\n         */", "        public void close()\n        {\n            // Close all the fifos\n            try { myInputStream .close(); } catch (IOException e) { }\n            try { myOutputStream.close(); } catch (IOException e) { }\n            myIsClosed = true;\n        }\n\n        /**\n         * Whether the fifo has been {@code close()}'d.\n         */", "        public boolean isClosed()\n        {\n            return myIsClosed;\n        }\n\n        /**\n         * Get the Java input stream.\n         */\n        protected InputStream getInputStream()\n        {\n            return myInputStream;\n        }\n\n        /**\n         * Get the Java output stream.\n         */\n        protected OutputStream getOutputStream()\n        {\n            return myOutputStream;\n        }\n    }\n\n    /**\n     * The input FIFO.\n     */\n    private final String myFromFifoname;\n\n    /**\n     * The output FIFO.\n     */\n    private final String myToFifoname;\n\n    /**\n     * The input FIFO File.\n     */\n    private final File myFromFifo;\n\n    /**\n     * The output FIFO File.\n     */\n    private final File myToFifo;\n\n    /**\n     * Our parent's PID.\n     */\n    private final long myParentPid;\n\n    /**\n     * Whether we have accepted a connection; we only ever want to do this\n     * once.\n     */\n    private boolean myAccepted;\n\n    /**\n     * Get the PID of our parent.\n     */\n    private static long getParentPid()\n    {\n        final Optional<ProcessHandle> parent =\n            ProcessHandle.current().parent();", "        try {\n            return parent.orElseThrow().pid();\n        }\n        catch (NoSuchElementException e) {\n            // This should only get thrown for a zombie process for Unix.\n            // Since we're still executing we can't be a zombie so this\n            // should never happen.\n            return -1;\n        }\n    }\n\n    /**\n     * CTOR.\n     */\n    public UnixFifoProvider(final String fromFifoname,\n                            final String toFifoname)\n    {\n        myFromFifoname = fromFifoname;\n        myToFifoname   = toFifoname;\n        myFromFifo     = new File(myFromFifoname);\n        myToFifo       = new File(myFromFifoname);\n        myParentPid    = getParentPid();\n        myAccepted     = false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public Transport accept()\n        throws IOException\n    {\n        // We only accept once since the pipes are one-use only\n        if (myAccepted) {\n            // Spin while isClosed() is false and otherwise exit since, when\n            // that returns true, it will be a signal that the Python\n            // process has gone away.\n            while (!isClosed()) {\n                try {\n                    Thread.sleep(1000);\n                }\n                catch (InterruptedException e) {\n                    // Nothing\n                }\n            }\n            System.exit(0);\n            return null; // for the compiler\n        }\n        else {\n            // Accepting for the first and only time\n            myAccepted = true;\n            return new UnixFifoTransport(\n                new Fifo(myFromFifoname, myToFifoname)\n            );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "            while (!isClosed()) {\n                try {\n                    Thread.sleep(1000);\n                }\n                catch (InterruptedException e) {\n                    // Nothing\n                }\n            }\n            System.exit(0);\n            return null; // for the compiler\n        }\n        else {\n            // Accepting for the first and only time\n            myAccepted = true;\n            return new UnixFifoTransport(\n                new Fifo(myFromFifoname, myToFifoname)\n            );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void close()\n    {\n        try { myFromFifo.delete(); } catch (SecurityException e) { }\n        try { myToFifo  .delete(); } catch (SecurityException e) { }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed()\n    {\n        // See if our FIFOs are gone", "    public boolean isClosed()\n    {\n        // See if our FIFOs are gone\n        if (!myFromFifo.exists() || !myToFifo.exists()) {\n            // One or both of our FIFOs are gone, this means that we are no\n            // longer talking to our parent. Theoretically because the\n            // parent removed them, with its atexit hook, and then went\n            // away.\n            return true;\n        }\n\n        // See if our parent has gone and we got inherited by init (or a\n        // \"child sub-reaper\") as a consequence. If the parent is SIGTERM'd\n        // or SIGKILL'd then they won't have been able to remove the FIFOs.", "        if (getParentPid() != myParentPid) {\n            return true;\n        }\n\n        // If we got here then we're not closed\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return \"UnixFifo@\" + myParentPid + \":\" +\n               myFromFifoname + \":\" + myToFifoname;\n    }\n\n    /**\n     * The method used to launch this externally.\n     */\n    public static void main(String[] args)\n        throws IOException\n    {\n        // Usage?", "    public static void main(String[] args)\n        throws IOException\n    {\n        // Usage?\n        if (args.length < 2) {\n            System.err.println(\"UnixFifoProvider in_fifo out_fifo [args]\");\n            System.exit(1);\n        }\n\n        // Handle optional args\n        final Arguments arguments =\n            new Arguments(Arrays.copyOfRange(args, 2, args.length));\n\n        // Create the PJRmi instance now, along with the transport we'll\n        // need for it\n        final UnixFifoProvider provider = new UnixFifoProvider(args[0], args[1]);\n        final PJRmi pjrmi =\n            new PJRmi(\"PJRmi\", provider, arguments.useLocking)\n            {\n                @Override\n                protected Object getObjectInstance(CharSequence name)\n                {", "                    if (StringUtil.equals(name, \"LockManager\")) {\n                        return getLockManager();\n                    }\n                    else {\n                        return null;\n                    }\n                }\n\n                @Override\n                protected boolean isClassBlockingOn()\n                {\n                    return (arguments.blockNonAllowlistedClasses != null)\n                           ? arguments.blockNonAllowlistedClasses\n                           : super.isClassBlockingOn();\n                }\n\n                @Override\n                protected boolean isClassPermitted(CharSequence className)\n                {\n                    return\n                        super.isClassPermitted(className) || (\n                            className != null &&\n                            arguments.additionalAllowlistedClasses.contains(\n                                className.toString()\n                            )\n                        );\n                }\n\n                @Override\n                protected boolean isClassInjectionPermitted()\n                {\n                    return (arguments.allowClassInjection != null)\n                           ? arguments.allowClassInjection\n                           : super.isClassInjectionPermitted();\n                }\n\n                @Override\n                protected boolean isUserPermitted(CharSequence username)\n                {\n                    return true;\n                }\n\n                @Override\n                protected boolean isHostPermitted(InetAddress address)\n                {\n                    return true;\n                }\n\n                @Override\n                protected int numWorkers()\n                {\n                    return arguments.numWorkers;\n                }\n            };\n\n        // Set it rolling\n        pjrmi.run();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonSlice.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n/**\n * A class which represents a Python {@code slice}.\n *\n * <p>The Java version has the same immutability semantics as its Python\n * counterpart.\n */\npublic class PythonSlice\n{\n    /**\n     * The slice start. This may be {@code null} if the start is unbounded.\n     */", "public class PythonSlice\n{\n    /**\n     * The slice start. This may be {@code null} if the start is unbounded.\n     */\n    public final Long start;\n\n    /**\n     * The slice stop. This may be {@code null} if the stop is unbounded.\n     */\n    public final Long stop;\n\n    /**\n     * The slice step. This may be {@code null} if the step is the default\n     * {@code 1} value.\n     */", "    public final Long stop;\n\n    /**\n     * The slice step. This may be {@code null} if the step is the default\n     * {@code 1} value.\n     */\n    public final Long step;\n\n    /**\n     * Constructor with start and stop values.\n     *\n     * @param start  The start value.\n     * @param stop   The stop value.\n     */\n    public PythonSlice(final Long start,\n                       final Long stop)\n    {\n        this(start, stop, null);\n    }\n\n    /**\n     * Constructor with start, stop and step values.\n     *\n     * @param start  The start value.\n     * @param stop   The stop value.\n     * @param step   The step value.\n     */\n    public PythonSlice(final Long start,\n                       final Long stop,\n                       final Long step)\n    {\n        this.start = start;\n        this.stop  = stop;\n        this.step  = step;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        // Use Python null/None semantics for this\n        return \"slice(\" +\n            ((start == null) ? \"None\" : start.toString()) + \", \" +\n            ((stop  == null) ? \"None\" : stop .toString()) + \", \" +\n            ((step  == null) ? \"None\" : step .toString()) +\n        \")\";\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/SSLSocketTransport.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\n\nimport java.util.List;\n\nimport javax.naming.InvalidNameException;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;", "import javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\n\nimport javax.net.ssl.SSLPeerUnverifiedException;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocket;\n\nimport static com.deshaw.pjrmi.PJRmi.LOG;\n\n/**", "\n/**\n * An SSL socket transport.\n */\n/*package*/ class SSLSocketTransport\n    extends SocketTransport\n{\n    /**\n     * The LDAP entry key for the \"common name\".\n     */", "     * The LDAP entry key for the \"common name\".\n     */\n    private static final String COMMON_NAME = \"CN\";\n\n    /**\n     * Our socket.\n     */\n    private final SSLSocket mySocket;\n\n    /**", "\n    /**\n     * CTOR.\n     */\n    public SSLSocketTransport(final SSLSocket socket)\n    {\n        super(socket);\n        mySocket = socket;\n    }\n", "    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getUserName()\n    {\n        // Look through all the certificates for the one with the common name in\n        // it, which we interpret as the username\n        try {", "        try {\n            for (Certificate cert : mySocket.getSession().getPeerCertificates()) {\n                // This has to be an x509 certificate for us to process it. If\n                // it's not then there's not a lot that we can do.\n                final X509Certificate x509 = (X509Certificate)cert;\n\n                // We want the \"common name\" out of it. This can be obtained by\n                // parsing the principal name as an LDAP name. Avoid overhead\n                // from implicit iterators when we loop over the its components.\n                final LdapName ldapName =\n                    new LdapName(x509.getSubjectX500Principal().getName());\n                final List<Rdn> rdns = ldapName.getRdns();", "                for (int i=0; i < rdns.size(); i++) {\n                    // Look for the \"common name\" entry and, if we find a valid\n                    // one, return its associated value\n                    final Rdn rdn = rdns.get(i);\n                    if (COMMON_NAME.equals(rdn.getType()) &&\n                        rdn.getValue() != null)\n                    {\n                        return rdn.getValue().toString();\n                    }\n                }\n            }\n        }\n        catch (ClassCastException   |\n               InvalidNameException |\n               SSLPeerUnverifiedException e)\n        {\n            // Nothing that we can do except to just fall out of to the end and\n            // return null\n            LOG.severe(\"Failed to extract username from connection: \" + e);\n        }\n\n        // If we got here then we could not find it\n        LOG.warning(\n            \"Failed to find the username from the connection \" + mySocket\n        );\n        return null;\n    }\n\n    /**\n     * Get the certificates associated with this connection.\n     *\n     * @throws SSLPeerUnverifiedException if the peer's credentials have not\n     *                                    been authoritatively checked.\n     */\n    public Certificate[] getPeerCertificates()\n        throws SSLPeerUnverifiedException\n    {\n        return mySocket.getSession().getPeerCertificates();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PJRmi.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.io.BlockingPipe;\nimport com.deshaw.python.Operations;\nimport com.deshaw.python.PythonPickle;\nimport com.deshaw.util.ByteList;\nimport com.deshaw.util.Instrumentor;\nimport com.deshaw.util.StringUtil;\nimport com.deshaw.util.StringUtil.HashableSubSequence;\nimport com.deshaw.util.ThreadLocalStringBuilder;", "import com.deshaw.util.StringUtil.HashableSubSequence;\nimport com.deshaw.util.ThreadLocalStringBuilder;\nimport com.deshaw.util.concurrent.LockManager;\nimport com.deshaw.util.concurrent.VirtualThreadLock;\nimport com.deshaw.util.concurrent.VirtualThreadLock.VirtualThread;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;", "import java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;", "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;", "import java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodHandles.Lookup;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;", "import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketException;", "import java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;", "import java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;", "import java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;", "import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.LockSupport;", "import java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.LockSupport;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;", "import java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\nimport org.xerial.snappy.Snappy;\n\nimport static com.deshaw.pjrmi.MethodUtil.compareBySpecificity;\nimport static com.deshaw.util.StringUtil.appendHexByte;", "import static com.deshaw.pjrmi.MethodUtil.compareBySpecificity;\nimport static com.deshaw.util.StringUtil.appendHexByte;\nimport static com.deshaw.util.StringUtil.stackTraceToString;\n\n/**\n * Python-to-Java RMI.\n *\n * <p>This code uses Java reflection to allow users in an external Python\n * process to call methods on and get values from object instances.\n *", " * process to call methods on and get values from object instances.\n *\n * <p>If you want thread safety here you have two options:\n * <ul>\n *   <li>Firstly you can program this into the Java code which you're attaching\n *       to at the deepest level. I.e. you just treat the PJRmi thread as\n *       another thread in the code and make your code threadsafe\n *       accordingly.</li>\n *   <li>Secondly, the PJRmi instance has a {@link PJRmiLockManager} that uses a\n *       global lock.  This manager will automatically synchronize incoming", " *   <li>Secondly, the PJRmi instance has a {@link PJRmiLockManager} that uses a\n *       global lock.  This manager will automatically synchronize incoming\n *       calls from clients if instructed to do so.  It is also available\n *       to the clients for additional manual synchronization amongst\n *       themselves.  If you want to share locking between multiple PJRmi\n *       instances, a constructor is provided that accepts an existing\n *       {@link PJRmiLockManager}.</li>\n * </ul>\n *\n * <p>The binary protocol employed is described in the comments of the inner", " *\n * <p>The binary protocol employed is described in the comments of the inner\n * Connection class.\n */\npublic abstract class PJRmi\n    extends Thread\n{\n    /**\n     * How the PJRmi class manages locks. This is here so that external Python\n     * processes can get their hands on various locks and coordinate with\n     * one-another. This also manages locking of any global lock.\n     *\n     * <p>This class manages deadlock detection since it's possible for external\n     * threads to acquire locks in ways which would cause them to hang forever.\n     * As such it is important that <i>all</i> locking is done via this class's\n     * methods.\n     */", "    public class PJRmiLockManager\n        extends LockManager\n    {\n        /**\n         * Our virtual thread lock.\n         */\n        private class PJRmiVirtualThreadLock\n            extends VirtualThreadLock\n            implements LockManagerLock\n        {\n            /**\n             * Our list of threads which hold us, or are trying to acquire us.\n             */\n            private final ColouredList<Locker> myLockers;\n\n            /**\n             * The log level of this lock.\n             */\n            private volatile Level myLogLevel;\n\n            /**\n             * CTOR\n             */\n            public PJRmiVirtualThreadLock(CharSequence name)\n            {\n                super(name.toString()); // will throw if name is null\n                myLockers = new ColouredList<>(4);\n                myLogLevel = Level.FINEST;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public ColouredList<Locker> getLockers()\n            {\n                return myLockers;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public void lock(final boolean isExclusive)\n            {\n                if (isExclusive) {\n                    super.lock();\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Shared locks not supported\"\n                    );\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public boolean tryLock(final boolean isExclusive)\n            {\n                if (isExclusive) {\n                    return super.tryLock();\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Shared locks not supported\"\n                    );\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public boolean tryLock(final boolean isExclusive,\n                                   final long time,\n                                   final TimeUnit unit)\n                throws InterruptedException\n            {\n                if (isExclusive) {\n                    return super.tryLock(time, unit);\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Shared locks not supported\"\n                    );\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public void unlock(final boolean isExclusive)\n            {\n                if (isExclusive) {\n                    super.unlock();\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Shared locks not supported\"\n                    );\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public Condition newCondition(final boolean isExclusive)\n            {\n                if (isExclusive) {\n                    return super.newCondition();\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Shared locks not supported\"\n                    );\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public boolean isHeldByCurrentThread(final boolean isExclusive)\n            {\n                // We only support exclusive locks and so a shared lock can\n                // never be held. We don't throw here since the parent\n                // LockManager class calls this method as part of its checks.\n                return isExclusive ? super.isHeldByCurrentThread() : false;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public int getHoldCountForCurrentThread(final boolean isExclusive)\n            {\n                // We only support exclusive locks and so a shared lock can\n                // never be held.\n                return isExclusive ? super.getHoldCount() : 0;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public Level getLogLevel()\n            {\n                return myLogLevel;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void setLogLevel(final Level level)\n            {", "            public void setLogLevel(final Level level)\n            {\n                if (level == null) {\n                    throw new NullPointerException(\"Given a null level\");\n                }\n                myLogLevel = level;\n            }\n        }\n\n        // --------------------------------------------------------------------\n\n        /**\n         * The prefix of the global lock. We append a {@code \\0} to the end of\n         * it so that it hides the postfix when printing but still contains it.\n         */\n        private static final String GLOBAL_LOCK_PREFIX =\n            \"__PJRMI_GLOBAL_LOCK_-_DO_NOT_USE__\\0\";\n\n        /**\n         * Our global lock instance, if any.\n         */\n        private final LockManager.SafeLock myGlobalLock;\n\n        /**\n         * CTOR.\n         */\n        private PJRmiLockManager(final boolean useGlobalLock)\n        {", "            if (useGlobalLock) {\n                myGlobalLock =\n                    getExclusiveLockFor(\n                        GLOBAL_LOCK_PREFIX + ourGlobalLockCount.getAndIncrement()\n                    );\n            }\n            else {\n                myGlobalLock = null;\n            }\n        }\n\n        /**\n         * Whether this class contains a global lock instance. There may be no\n         * global lock if the PJRmi instance was specified not to create one.\n         *\n         * @return  whether the class contains a lock instance.\n         */", "        public boolean hasGlobalLock()\n        {\n            return myGlobalLock != null;\n        }\n\n        /**\n         * Get the the global lock, if any.\n         *\n         * @return  the lock.\n         */\n        public LockManager.SafeLock getGlobalLock()\n        {\n            return myGlobalLock;\n        }\n\n        /**\n         * Lock the global lock, if it exists.\n         *\n         * @return  the acquired lock.\n         *\n         * @throws DeadlockException if acquiring the lock would result in\n         *         deadlock.\n         */", "        public SafeLock lockGlobal()\n            throws DeadlockException\n        {\n            if (myGlobalLock != null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.log(Level.FINEST,\n                            currentThread() + \" acquiring global lock\",\n                            new Throwable());\n                }\n                else if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(currentThread() + \" acquiring global lock\");\n                }\n                myGlobalLock.lock();\n            }\n            return myGlobalLock;\n        }\n\n        /**\n         * Unlock the global lock, if it exists.\n         */", "                else if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(currentThread() + \" acquiring global lock\");\n                }\n                myGlobalLock.lock();\n            }\n            return myGlobalLock;\n        }\n\n        /**\n         * Unlock the global lock, if it exists.\n         */", "        public void unlockGlobal()\n        {\n            if (myGlobalLock != null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.log(Level.FINEST,\n                            currentThread() + \" dropping global lock\",\n                            new Throwable());\n                }\n                else if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(currentThread() + \" dropping global lock\");\n                }\n                myGlobalLock.unlock();\n            }\n        }\n\n        /**\n         * Whether the global lock, if any, is held by the current thread.\n         *\n         * @return whether the lock is held.\n         */", "                else if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(currentThread() + \" dropping global lock\");\n                }\n                myGlobalLock.unlock();\n            }\n        }\n\n        /**\n         * Whether the global lock, if any, is held by the current thread.\n         *\n         * @return whether the lock is held.\n         */", "        public boolean isGlobalHeldByCurrentThread()\n        {\n            if (myGlobalLock != null) {\n                return myGlobalLock.isHeldByCurrentThread();\n            }\n            else {\n                return false;\n            }\n        }\n\n        /**\n         * Invoke a runnable (or a function without arguments which returns\n         * nothing) without holding the global lock.\n         *\n         * @param  runnable  The runnable to invoke.\n         *\n         * @throws DeadlockException            if there was a deadlock when\n         *                                      reacquiring the lock.\n         * @throws UndeclaredThrowableException if the given function threw an\n         *                                      exception.\n         */", "        public void invokeWithoutGlobalLock(final Runnable runnable)\n            throws DeadlockException,\n                   UndeclaredThrowableException\n        {\n            invokeWithoutGlobalLock(\n                new Function<Object,Object>() {\n                    @Override public Object apply(Object notused) {\n                        runnable.run();\n                        return null;\n                    }\n                },\n                null\n            );\n        }\n\n        /**\n         * Invoke an argumentless function without holding the global lock, and\n         * return its result.\n         *\n         * @param  <T>       The type of the result.\n         * @param  function  The function to invoke.\n         *\n         * @return the function's result.\n         *\n         * @throws DeadlockException            if there was a deadlock when\n         *                                      reacquiring the lock.\n         * @throws UndeclaredThrowableException if the given function threw an\n         *                                      exception.\n         */\n        public <T> T invokeWithoutGlobalLock(final Supplier<T> function)\n            throws DeadlockException,\n                   UndeclaredThrowableException\n        {\n            return invokeWithoutGlobalLock(\n                new Function<Object,T>() {", "                    @Override public T apply(Object notused) {\n                        return function.get();\n                    }\n                },\n                null\n            );\n        }\n\n        /**\n         * Invoke a function with the given argument and return its result, all\n         * without holding the global lock.\n         *\n         * @param  <T>       The type of the argument.\n         * @param  <R>       The type of the result.\n         * @param  function  The function to invoke.\n         * @param  argument  The function's argument.\n         *\n         * @return the function's result.\n         *\n         * @throws DeadlockException            if there was a deadlock when\n         *                                      reacquiring the lock.\n         * @throws UndeclaredThrowableException if the given function threw an\n         *                                      exception.\n         */\n        public <T,R> R invokeWithoutGlobalLock(final Function<T,R> function,\n                                               final T             argument)\n            throws DeadlockException,\n                   UndeclaredThrowableException\n        {\n            // How many times this thread held the lock (it's reentrant). We\n            // remember this so that we ensure that, when we exit this method, the\n            // lock is held the same number of times as it was when we entered it.\n            int lockCount = 0;\n", "            try {\n                // Unwind the lock, remembering how many times we had it held\n                while (isGlobalHeldByCurrentThread()) {\n                    unlockGlobal();\n                    lockCount++;\n                }\n\n                // Now we can call the function\n                return function.apply(argument);\n            }\n            catch (Throwable t) {\n                throw new UndeclaredThrowableException(t);\n            }\n            finally {\n                // Reacquire the lock again", "                while (lockCount > 0) {\n                    lockGlobal();\n                    lockCount--;\n                }\n            }\n        }\n\n        /**\n         * Sleep for a period of time, without holding the global lock.\n         *\n         * @param millis  How long to sleep for.\n         *\n         * @throws DeadlockException if there was a deadlock when reacquiring\n         *                           the lock.\n         */", "        public void sleepWithoutGlobalLock(final long millis)\n            throws DeadlockException\n        {\n            try {\n                invokeWithoutGlobalLock(\n                    () -> {\n                        try {\n                            Thread.sleep(millis);\n                        }\n                        catch (InterruptedException e) {\n                            // Nothing\n                        }\n                    }\n                );\n            }\n            catch (UndeclaredThrowableException e) {\n                // This should never happen\n                throw new RuntimeException(e);\n            }\n        }\n\n        /**\n         * Waits on the given monitor to be either interrupted or notified,\n         * without holding the global lock.\n         *\n         * @param monitor The object to use for synchronizing the wait.\n         *\n         * @throws DeadlockException If there was a deadlock amongst locks\n         *                           managed by LockManagers when re-acquiring\n         *                           the lock.\n         */", "        public void waitWithoutGlobalLock(Object monitor)\n            throws DeadlockException\n        {\n            try {\n                invokeWithoutGlobalLock(() -> {\n                    try {\n                        monitor.wait();\n                    }\n                    catch (InterruptedException e) {\n                        // Do nothing since we are done waiting at this point\n                    }\n                });\n            }\n            catch (UndeclaredThrowableException e) {\n                // This should probably never happen\n                throw (new RuntimeException(e));\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public SafeLock getSharedLockFor(final CharSequence lockName)\n        {\n            // We only support exclusive locks right now\n            throw new UnsupportedOperationException(\n                \"Shared locks not supported\"\n            );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected LockManagerLock newNamedLock(final CharSequence name)\n        {\n            return useWorkers() ? new PJRmiVirtualThreadLock(name) :\n                                  super.newNamedLock(name);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected Thread currentThread()\n        {\n            return useWorkers() ? VirtualThreadLock.getThread() :\n                                  super.currentThread();\n        }\n    }\n    private static final AtomicLong ourGlobalLockCount = new AtomicLong();\n    // Used to distinguish global locks between instances. PJRmiLockManager only.\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * An annotation used to denote that a method returning an {@link Object}\n     * should downcast that value to its actual type when being sent to the\n     * Python side. This allows methods to mimic the return type semantics used\n     * by generic classes.\n     *\n     * <p>PJRmi understands to do such downcasting for methods in generic\n     * classes (e.g. {@code V Map<K,V>::get(K key)}) but there are non-generic\n     * classes which might want to have similar semantics. Adding this\n     * annotation allows the user to tell the Java side where this should\n     * happen. E.g:\n     <pre>\n          // A class which contains various things\n          class OpaqueBagOfStuff {\n              // Get the first item to hand from the bag\n              &#64;GenericReturnType", "              public Object remove() {\n                ...\n              }\n\n              // Put something into the bag\n              public void add(Object something) {\n                ...\n              }\n         }\n      </pre>\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(value={ElementType.METHOD})\n    public @interface GenericReturnType\n    {\n        // Nothing else.\n    }\n\n    /**\n     * Flags which describe the system.\n     */\n    private enum Flags\n    {\n        USE_WORKERS((byte)(1 << 0));\n", "        public final byte value;\n\n        private Flags(final byte value)\n        {\n            this.value = value;\n        }\n    }\n\n    /**\n     * Our message types.\n     */\n    private enum MessageType\n    {\n        NONE                 ((byte) '\\0',false), // Effectively \"null\"\n        INSTANCE_REQUEST     ((byte) 'A', false), // Client to server\n        ADD_REFERENCE        ((byte) 'B', false), // Client to server & Server to client\n        DROP_REFERENCES      ((byte) 'C', false), // Client to server & Server to client\n        TYPE_REQUEST         ((byte) 'D', false), // Client to server\n        METHOD_CALL          ((byte) 'E', true ), // Client to server\n        TO_STRING            ((byte) 'F', true ), // Client to server\n        GET_FIELD            ((byte) 'G', true ), // Client to server\n        SET_FIELD            ((byte) 'H', true ), // Client to server\n        GET_ARRAY_LENGTH     ((byte) 'I', false), // Client to server\n        NEW_ARRAY_INSTANCE   ((byte) 'J', false), // Client to server\n        OBJECT_CAST          ((byte) 'K', false), // Client to server\n        LOCK                 ((byte) 'L', false), // Client to server\n        UNLOCK               ((byte) 'M', false), // Client to server\n        INJECT_CLASS         ((byte) 'N', false), // Client to server\n        GET_VALUE_OF         ((byte) 'O', true ), // Client to server\n        GET_CALLBACK_HANDLE  ((byte) 'P', false), // Client to server\n        CALLBACK_RESPONSE    ((byte) 'Q', false), // Client to server\n        GET_PROXY            ((byte) 'R', false), // Client to server\n        INVOKE_AND_GET_OBJECT((byte) 'S', false), // Client to server\n        INJECT_SOURCE        ((byte) 'T', false), // Client to server\n        OBJECT_REFERENCE     ((byte) 'a', false), // Server to client\n        TYPE_DESCRIPTION     ((byte) 'b', false), // Server to client\n        ARBITRARY_ITEM       ((byte) 'c', false), // Server to client\n        EXCEPTION            ((byte) 'd', false), // Server to client\n        ASCII_VALUE          ((byte) 'e', false), // Server to client\n        EMPTY_ACK            ((byte) 'f', false), // Server to client\n        ARRAY_LENGTH         ((byte) 'g', false), // Server to client\n        UTF16_VALUE          ((byte) 'h', false), // Server to client\n        PICKLE_BYTES         ((byte) 'i', false), // Server to client\n        CALLBACK             ((byte) 'j', false), // Server to client\n        PYTHON_EVAL_OR_EXEC  ((byte) 'k', false), // Server to client\n        PYTHON_INVOKE        ((byte) 'l', false), // Server to client\n        OBJECT_CALLBACK      ((byte) 'm', false), // Server to client\n        GET_OBJECT           ((byte) 'n', false), // Server to client\n        PYTHON_REFERENCE     ((byte) 'o', false), // Server to client\n        GETATTR              ((byte) 'p', false), // Server to client\n        SET_GLOBAL_VARIABLE  ((byte) 'q', false), // Server to client\n        SHMDATA_BYTES        ((byte) 'r', false), // Server to client\n        ;\n\n        /**\n         * All the possible types, keyed by ID.\n         */\n        private static final MessageType[] VALUES = new MessageType[0xff];\n        static {", "            for (MessageType mt : MessageType.values()) {\n                VALUES[Byte.toUnsignedInt(mt.id)] = mt;\n            }\n        }\n\n        /**\n         * The unique identifier of this message type.\n         */\n        public final byte id;\n\n        /**\n         * Whether the global lock should be held when receiving with these\n         * messages.\n         *\n         * <p>It is  important that  we get  this right  since holding  the lock\n         * might result  in deadlock (for LOCK  and UNLOCK) and not  holding the\n         * lock for operations which read or write from the non-PJRmi Java state\n         * might   result  un   undefined/unexpected   client  behaviour   (e.g.\n         * METHOD_CALL, GET_FIELD, SET_FIELD, etc.).\n         */", "        public final byte id;\n\n        /**\n         * Whether the global lock should be held when receiving with these\n         * messages.\n         *\n         * <p>It is  important that  we get  this right  since holding  the lock\n         * might result  in deadlock (for LOCK  and UNLOCK) and not  holding the\n         * lock for operations which read or write from the non-PJRmi Java state\n         * might   result  un   undefined/unexpected   client  behaviour   (e.g.\n         * METHOD_CALL, GET_FIELD, SET_FIELD, etc.).\n         */", "        public final boolean shouldLockFor;\n\n        /**\n         * Get the MessageType instance for a given ID.\n         */\n        public static MessageType byId(final byte id)\n        {\n            MessageType result = VALUES[Byte.toUnsignedInt(id)];\n            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad MessageType value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private MessageType(byte id, final boolean shouldLockFor)\n        {\n            this.id            = id;\n            this.shouldLockFor = shouldLockFor;\n        }\n    }\n\n    /**\n     * The wire format to use when sending objects to python.\n     */\n    private enum PythonValueFormat\n    {\n        REFERENCE               ((byte) 'A'),\n        RAW_PICKLE              ((byte) 'B'),\n        SNAPPY_PICKLE           ((byte) 'C'),\n        PYTHON_REFERENCE        ((byte) 'D'),\n        SHMDATA                 ((byte) 'E'),\n        BESTEFFORT_PICKLE       ((byte) 'F'),\n        BESTEFFORT_SNAPPY_PICKLE((byte) 'G'),\n        ;\n\n        /**\n         * All the possible types, keyed by ID.\n         */\n        private static final PythonValueFormat[] VALUES =\n            new PythonValueFormat[0xff];\n        static {", "            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad MessageType value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private MessageType(byte id, final boolean shouldLockFor)\n        {\n            this.id            = id;\n            this.shouldLockFor = shouldLockFor;\n        }\n    }\n\n    /**\n     * The wire format to use when sending objects to python.\n     */\n    private enum PythonValueFormat\n    {\n        REFERENCE               ((byte) 'A'),\n        RAW_PICKLE              ((byte) 'B'),\n        SNAPPY_PICKLE           ((byte) 'C'),\n        PYTHON_REFERENCE        ((byte) 'D'),\n        SHMDATA                 ((byte) 'E'),\n        BESTEFFORT_PICKLE       ((byte) 'F'),\n        BESTEFFORT_SNAPPY_PICKLE((byte) 'G'),\n        ;\n\n        /**\n         * All the possible types, keyed by ID.\n         */\n        private static final PythonValueFormat[] VALUES =\n            new PythonValueFormat[0xff];\n        static {", "            for (PythonValueFormat rf : PythonValueFormat.values()) {\n                VALUES[Byte.toUnsignedInt(rf.id)] = rf;\n            }\n        }\n\n        /**\n         * The unique identifier of this return format.\n         */\n        public final byte id;\n\n        /**\n         * Get the PythonValueFormat instance for a given ID.\n         */", "        public final byte id;\n\n        /**\n         * Get the PythonValueFormat instance for a given ID.\n         */\n        public static PythonValueFormat byId(final byte id)\n        {\n            PythonValueFormat result = VALUES[Byte.toUnsignedInt(id)];\n            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad PythonValueFormat value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private PythonValueFormat(byte id)\n        {\n            this.id = id;\n        }\n    }\n\n    /**\n     * Flags associated with a type description.\n     */\n    private static enum TypeFlags\n    {\n        IS_PRIMITIVE           (1 <<  0),\n        IS_THROWABLE           (1 <<  1),\n        IS_INTERFACE           (1 <<  2),\n        IS_ENUM                (1 <<  3),\n        IS_ARRAY               (1 <<  4),\n        IS_FUNCTIONAL_INTERFACE(1 <<  5);\n", "            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad PythonValueFormat value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private PythonValueFormat(byte id)\n        {\n            this.id = id;\n        }\n    }\n\n    /**\n     * Flags associated with a type description.\n     */\n    private static enum TypeFlags\n    {\n        IS_PRIMITIVE           (1 <<  0),\n        IS_THROWABLE           (1 <<  1),\n        IS_INTERFACE           (1 <<  2),\n        IS_ENUM                (1 <<  3),\n        IS_ARRAY               (1 <<  4),\n        IS_FUNCTIONAL_INTERFACE(1 <<  5);\n", "        public final int value;\n\n        private TypeFlags(final int value)\n        {\n            this.value = value;\n        }\n    }\n\n    /**\n     * What a type looks like.\n     */\n    private class TypeDescription\n    {\n        /**\n         * The actual class we're representing.\n         */\n        private final Class<?> myClass;\n\n        /**\n         * The name of the type a returned by Class.getName().\n         */\n        private final String myName;\n\n        /**\n         * The flags associated with this type.\n         */\n        private final Set<TypeFlags> myFlags = EnumSet.noneOf(TypeFlags.class);\n\n        /**\n         * The ID of this type as defined by TypeMapping. The 'void' type is\n         * always zero (but we can't have a static member for that inside a\n         * non-static class; sigh).\n         */\n        private final int myTypeId;\n\n        /**\n         * The IDs of this types which the class the of this type represents.\n         */\n        private final int[] mySupertypeIds;\n\n        /**\n         * The array of publically accessible fields.\n         */\n        private final Field[] myFields;\n\n        /**\n         * The fields this type has.\n         */\n        private final FieldDescription[] myFieldDescriptions;\n\n        /**", "         * The array of public constructors which this type has.\n         */\n        private final Constructor<?>[] myConstructors;\n\n        /**\n         * The relative binding specificity of the constructors with one-\n         * another as determined by {@link compareBySpecificity(Constructor,Constructor)}.\n         * It's keyed as one constructor index vs the other (matching\n         * myConstructors).\n         */\n        private final byte[][] myConstructorSpecificities;\n\n        /**", "         * The descriptions of the public constructors which this type has.\n         * These are modeled as methods which return a class instance as the\n         * result.\n         */\n        private final MethodDescription[] myConstructorDescriptions;\n\n        /**\n         * The array of public methods which this type has (including methods\n         * inherited from superclasses).\n         */\n        private final Method[] myMethods;\n\n        /**\n         * The relative binding specificity of the methods with one-another as\n         * determined by {@link compareBySpecificity(Method, Method)}. It's\n         * keyed as one method index vs the other (matching myMethods).\n         */\n        private final byte[][] myMethodSpecificities;\n\n        /**", "         * The descriptions of the public methods which this type has (including\n         * methods inherited from superclasses).\n         */\n        private final MethodDescription[] myMethodDescriptions;\n\n        /**\n         * Optional samplers for instrumenting method calls.\n         */\n        private final Instrumentor[] myMethodInstrumentors;\n\n        /**\n         * CTOR.\n         */\n        public TypeDescription(final Class<?> klass, final int id)\n        {", "            if (klass == null) {\n                throw new NullPointerException(\n                    \"Attempt to create TypeDescription for null\"\n                );\n            }\n\n            myClass = klass;\n\n            myName = klass.getName();\n\n            myTypeId = id;\n\n            Class<?>   superClass = klass.getSuperclass();\n            Class<?>[] interfaces = klass.getInterfaces();\n            mySupertypeIds = new int[interfaces.length +\n                                     ((superClass == null) ? 0 : 1)];\n            /*scope*/ {\n                int index = 0;", "                if (superClass != null) {\n                    mySupertypeIds[index++] =\n                        myTypeMapping.getDescription(superClass).getTypeId();\n                }\n                for (Class<?> i : interfaces) {\n                    mySupertypeIds[index++] =\n                        myTypeMapping.getDescription(i).getTypeId();\n                }\n            }\n\n            switch (myName) {\n            case \"void\":\n            case \"boolean\":\n            case \"byte\":\n            case \"char\":\n            case \"double\":\n            case \"float\":\n            case \"int\":\n            case \"long\":\n            case \"short\":\n                myFlags.add(TypeFlags.IS_PRIMITIVE);\n                break;\n\n            default:\n                // Not a known primitive\n                break;\n            }\n\n            // Other flags", "            if (Throwable.class.isAssignableFrom(klass)) {\n                myFlags.add(TypeFlags.IS_THROWABLE);\n            }\n            if (klass.isArray()) {\n                myFlags.add(TypeFlags.IS_ARRAY);\n            }\n            if (isFunctionalInterface(klass)) {\n                myFlags.add(TypeFlags.IS_FUNCTIONAL_INTERFACE);\n            }\n            if (klass.isEnum()) {\n                myFlags.add(TypeFlags.IS_ENUM);\n            }", "            if (klass.isEnum()) {\n                myFlags.add(TypeFlags.IS_ENUM);\n            }\n            if (klass.isInterface()) {\n                myFlags.add(TypeFlags.IS_INTERFACE);\n            }\n\n            // Put all the fields, constructors and methods into arrays, we'll\n            // look at them later. We don't attempt to create the Description\n            // instances right away since they might involve this type which\n            // will cause us to recurse infinitely.\n\n            // Walk all the fields. We ensure that shadowing variables correctly\n            // override one-another.\n            final Map<String,Field> fields = new HashMap<>();", "            for (Field field : klass.getFields()) {\n                final String   name      = field.getName();\n                final Class<?> container = field.getDeclaringClass();\n                final Field    current   = fields.get(name);\n\n                // If we've not seen this field before, or if we have and the\n                // previous one is in a class which is further up the\n                // inheritance tree from this one, then we should save it in the\n                // mapping.\n                if (current == null ||\n                    current.getDeclaringClass().isAssignableFrom(container))\n                {\n                    fields.put(name, field);\n                }\n            }\n\n            myFields            = fields.values().toArray(new Field[fields.size()]);\n            myFieldDescriptions = new FieldDescription[myFields.length];\n\n            myConstructors = klass.getConstructors();\n            myConstructorSpecificities = new byte[myConstructors.length][];", "                if (current == null ||\n                    current.getDeclaringClass().isAssignableFrom(container))\n                {\n                    fields.put(name, field);\n                }\n            }\n\n            myFields            = fields.values().toArray(new Field[fields.size()]);\n            myFieldDescriptions = new FieldDescription[myFields.length];\n\n            myConstructors = klass.getConstructors();\n            myConstructorSpecificities = new byte[myConstructors.length][];", "            for (int i=0; i < myConstructors.length; i++) {\n                myConstructorSpecificities[i] = new byte[myConstructors.length];\n            }\n            myConstructorDescriptions  =\n                new MethodDescription[myConstructors.length];\n\n            // Determine the relative binding specificities. The i==j diagonal\n            // will be left as zero, which is correct (a constructor is\n            // incomparible with itself).\n            for (int i=0; i < myConstructors.length; i++) {\n                for (int j=0; j < i; j++) {\n                    final int cmp = compareBySpecificity(myConstructors[i],\n                                                         myConstructors[j]);\n                    myConstructorSpecificities[i][j] = (byte)Math.signum( cmp);\n                    myConstructorSpecificities[j][i] = (byte)Math.signum(-cmp);\n                }\n            }\n\n            // The way we get methods differs depending on whether klass is a\n            // class or an interface\n            myMethods = klass.isInterface() ? findInterfaceMethods(klass)\n                                            : findClassMethods    (klass);\n\n            myMethodSpecificities = new byte[myMethods.length][];", "            for (int i=0; i < myConstructors.length; i++) {\n                for (int j=0; j < i; j++) {\n                    final int cmp = compareBySpecificity(myConstructors[i],\n                                                         myConstructors[j]);\n                    myConstructorSpecificities[i][j] = (byte)Math.signum( cmp);\n                    myConstructorSpecificities[j][i] = (byte)Math.signum(-cmp);\n                }\n            }\n\n            // The way we get methods differs depending on whether klass is a\n            // class or an interface\n            myMethods = klass.isInterface() ? findInterfaceMethods(klass)\n                                            : findClassMethods    (klass);\n\n            myMethodSpecificities = new byte[myMethods.length][];", "            for (int i=0; i < myMethods.length; i++) {\n                myMethodSpecificities[i] = new byte[myMethods.length];\n            }\n            myMethodDescriptions = new MethodDescription[myMethods.length];\n            myMethodInstrumentors =\n                instrumentMethodCalls() ? new Instrumentor[myMethods.length]\n                                        : null;\n\n            // Determine the relative binding specificities. The i==j diagonal\n            // will be left as zero, which is correct (a method is incomparible\n            // with itself).", "            for (int i=0; i < myMethods.length; i++) {\n                for (int j=0; j < i; j++) {\n                    final int cmp = compareBySpecificity(myMethods[i],\n                                                         myMethods[j]);\n                    myMethodSpecificities[i][j] = (byte)Math.signum( cmp);\n                    myMethodSpecificities[j][i] = (byte)Math.signum(-cmp);\n                }\n            }\n\n            // Talk to the animals\n            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Created \" + this);\n            }\n        }\n\n        /**\n         * Get the ID of this type.\n         */", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Created \" + this);\n            }\n        }\n\n        /**\n         * Get the ID of this type.\n         */\n        public int getTypeId()\n        {\n            return myTypeId;\n        }\n\n        /**\n         * Get the Class represented by this TypeDescription.\n         */\n        public Class<?> getRepresentedClass()\n        {\n            return myClass;\n        }\n\n        /**\n         * Get the name of this type, as returned by Class.getName();\n         */", "        public int getTypeId()\n        {\n            return myTypeId;\n        }\n\n        /**\n         * Get the Class represented by this TypeDescription.\n         */\n        public Class<?> getRepresentedClass()\n        {\n            return myClass;\n        }\n\n        /**\n         * Get the name of this type, as returned by Class.getName();\n         */", "        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * Whether this type is 'void'.\n         */\n        public boolean isVoid()\n        {\n            return myTypeId == 0;\n        }\n\n        /**\n         * Whether this type is a primitive one or not.\n         */", "        public boolean isVoid()\n        {\n            return myTypeId == 0;\n        }\n\n        /**\n         * Whether this type is a primitive one or not.\n         */\n        public boolean isPrimitive()\n        {\n            return myFlags.contains(TypeFlags.IS_PRIMITIVE);\n        }\n\n        /**\n         * Whether this type is an array.\n         */", "        public boolean isPrimitive()\n        {\n            return myFlags.contains(TypeFlags.IS_PRIMITIVE);\n        }\n\n        /**\n         * Whether this type is an array.\n         */\n        public boolean isArray()\n        {\n            return myFlags.contains(TypeFlags.IS_ARRAY);\n        }\n\n        /**\n         * Get the flags associated with this type, as an int.\n         */", "        public boolean isArray()\n        {\n            return myFlags.contains(TypeFlags.IS_ARRAY);\n        }\n\n        /**\n         * Get the flags associated with this type, as an int.\n         */\n        public int getFlagsValue()\n        {\n            int result = 0;", "        public int getFlagsValue()\n        {\n            int result = 0;\n            for (TypeFlags flag : myFlags) {\n                result |= flag.value;\n            }\n            return result;\n        }\n\n        /**\n         * If this is an array, get the class of the component type.\n         */\n        public Class<?> getArrayComponentType()\n        {\n            return myClass.getComponentType();\n        }\n\n        /**\n         * Get the number types which this type inherits from (might be\n         * interfaces or classes).\n         */", "        public int getNumSupertypes()\n        {\n            return mySupertypeIds.length;\n        }\n\n        /**\n         * Get the method for the given index.\n         */\n        public int getSupertypeId(int index)\n        {\n            return mySupertypeIds[index];\n        }\n\n        /**", "        public int getSupertypeId(int index)\n        {\n            return mySupertypeIds[index];\n        }\n\n        /**\n         * Get the number of public constructors this type has. This will always\n         * be zero for primitive types and arrays.\n         */\n        public int getNumConstructors()\n        {\n            return (isPrimitive() || isArray()) ? 0 : myConstructors.length;\n        }\n\n        /**\n         * Get the method for the given index.\n         */", "        public int getNumConstructors()\n        {\n            return (isPrimitive() || isArray()) ? 0 : myConstructors.length;\n        }\n\n        /**\n         * Get the method for the given index.\n         */\n        public MethodDescription getConstructor(int index)\n        {\n            MethodDescription desc = myConstructorDescriptions[index];", "        public MethodDescription getConstructor(int index)\n        {\n            MethodDescription desc = myConstructorDescriptions[index];\n            if (desc == null) {\n                // Need to create it, grab the corresponding Java method\n                final Constructor<?> ctor = myConstructors[index];\n\n                // The method arguments\n                final Class<?>[]        args           = ctor.getParameterTypes();\n                final Parameter[]       params         = ctor.getParameters();\n                final TypeDescription[] argTypes       = new TypeDescription[args.length];\n                final String[]          parameterNames = new String[args.length];", "                for (int i=0; i < args.length; i++) {\n                    final Class<?> arg = args[i];\n                    argTypes[i]        = myTypeMapping.getDescription(arg);\n                    parameterNames[i]  = params[i].getName();\n                }\n                final boolean isDeprecated =\n                    (ctor.getAnnotation(Deprecated.class) != null);\n\n                // Now we can create it\n                desc =\n                    new MethodDescription(\n                        index,\n                        ctor.toString(),\n                        false, // static\n                        isDeprecated,\n                        false, // default\n                        this,  // return type\n                        false, // generic\n                        argTypes,\n                        parameterNames\n                    );\n\n                // And remember it\n                myConstructorDescriptions[index] = desc;\n            }\n            return desc;\n        }\n\n        /**\n         * Get the relative specificity of one constructor vs another.\n         */", "        public byte getRelativeConstructorSpecificity(final int idx1,\n                                                      final int idx2)\n        {\n            return myConstructorSpecificities[idx1][idx2];\n        }\n\n        /**\n         * Call a constructor with the given args.\n         */\n        public Object callConstructor(int index, Object[] arguments)\n            throws Throwable\n        {", "        public Object callConstructor(int index, Object[] arguments)\n            throws Throwable\n        {\n            try {\n                return myConstructors[index].newInstance(arguments);\n            }\n            catch (InvocationTargetException e) {\n                // Throw the exception which came out of the call\n                throw e.getTargetException();\n            }\n        }\n\n        /**", "         * Get the number of public methods this type has. This will always be\n         * zero for primitive types.\n         */\n        public int getNumMethods()\n        {\n            return isPrimitive() ? 0 : myMethods.length;\n        }\n\n        /**\n         * Get the method for the given index.\n         */", "        public MethodDescription getMethod(int index)\n        {\n            MethodDescription desc = myMethodDescriptions[index];\n            if (desc == null) {\n                // Need to construct it, grab the corresponding Java method\n                final Method method = myMethods[index];\n\n                // The method arguments\n                final Class<?>[]        args           = method.getParameterTypes();\n                final Parameter[]       params         = method.getParameters();\n                final TypeDescription[] argumentTypes  = new TypeDescription[args.length];\n                final String[]          parameterNames = new String[args.length];", "                for (int i=0; i < args.length; i++) {\n                    final Class<?> arg = args[i];\n                    argumentTypes[i]   = myTypeMapping.getDescription(arg);\n                    parameterNames[i]  = params[i].getName();\n                }\n\n                // Special hack for getClass(). Since we don't have Foo.class on\n                // the Python side we allow ourselves to call getClass() in a\n                // static context.\n                final boolean isStatic =\n                    (method.getName().equals(\"getClass\") && args.length == 0) ||\n                    ((method.getModifiers() & Modifier.STATIC) != 0);\n\n                // Determine if the return type is a generic; this is a little\n                // tricky since it requires heuristics and they might get\n                // fooled. If the type is not a generic in some way then\n                // toString() will return the same for both, otherwise we get\n                // things like \"E\" or \"java.util.Set<E>\" back. This code may\n                // give false positives or false negatives if the heuristics are\n                // broken.\n                final String rt  = method.getReturnType()       .toString();\n                final String grt = method.getGenericReturnType().toString();\n                boolean isGenericReturnType =\n                    (method.getAnnotation(GenericReturnType.class) != null);", "                if (!rt.equals(grt)) {\n                    // Okay, the names differ. We now have to determine whether\n                    // the grt is a type param (e.g. \"E\") or a parameterised\n                    // type (e.g. \"java.util.Set<E>\").\n                    if (grt.indexOf('<') < 0 && grt.indexOf('>') < 0) {\n                        isGenericReturnType = true;\n                    }\n                }\n                final boolean isDeprecated =\n                    (method.getAnnotation(Deprecated.class) != null);\n\n                // Now we can create it\n                desc =\n                    new MethodDescription(\n                        index,\n                        method.getName(),\n                        isStatic,\n                        isDeprecated,\n                        method.isDefault(),\n                        myTypeMapping.getDescription(method.getReturnType()),\n                        isGenericReturnType,\n                        argumentTypes,\n                        parameterNames\n                    );\n\n                // And remember it\n                myMethodDescriptions[index] = desc;\n            }\n            return desc;\n        }\n\n        /**\n         * Get the relative specificity of one method vs another.\n         */", "        public byte getRelativeMethodSpecificity(final int idx1,\n                                                 final int idx2)\n        {\n            return myMethodSpecificities[idx1][idx2];\n        }\n\n        /**\n         * Call a given method on a object instance with the given args.\n         */\n        public Object callMethod(int index, Object instance, Object[] arguments)\n            throws Throwable\n        {\n            final MethodDescription desc = myMethodDescriptions[index];\n\n            // See if we are instrumenting our method calls, if we are then the\n            // myMethodInstrumentors array will be non-null;\n            final Instrumentor instr;\n            final long start;", "        public Object callMethod(int index, Object instance, Object[] arguments)\n            throws Throwable\n        {\n            final MethodDescription desc = myMethodDescriptions[index];\n\n            // See if we are instrumenting our method calls, if we are then the\n            // myMethodInstrumentors array will be non-null;\n            final Instrumentor instr;\n            final long start;\n            if (myMethodInstrumentors == null) {\n                instr = null;\n                start = -1;\n            }\n            else {\n                // Grab the instr, lazily creating it if needbe", "            if (myMethodInstrumentors == null) {\n                instr = null;\n                start = -1;\n            }\n            else {\n                // Grab the instr, lazily creating it if needbe\n                if (myMethodInstrumentors[index] == null) {\n                    instr = getInstrumentor(PJRmi.this.myName + ':' +\n                                            myName + '#' + desc.getName() + \"()\");\n                    instr.setIntervalMod(1);\n                    myMethodInstrumentors[index] = instr;\n                }\n                else {\n                    instr = myMethodInstrumentors[index];\n                }\n\n                // And actually do any instrumenting\n                start = instr.start();\n            }\n", "            try {\n                // Handle our special getClass() hack\n                if (instance == null &&\n                    desc.getName().equals(\"getClass\") &&\n                    desc.getNumArguments() == 0)\n                {\n                    return getRepresentedClass();\n                }\n                else {\n                    return myMethods[index].invoke(instance, arguments);\n                }\n            }\n            catch (InvocationTargetException e) {\n                // Throw the exception which came out of the call\n                throw e.getTargetException();\n            }\n            catch (Throwable t) {\n                // Augment and rethrow\n                throw new IllegalArgumentException(\n                    \"Failed to call method \\\"\" + myMethods[index] + \"\\\", \" +\n                    \"with arguments \" + Arrays.toString(arguments),\n                    t\n                );\n            }\n            finally {\n                // And accumulate any instrumentation time", "                if (instr != null) {\n                    instr.end(start);\n                }\n            }\n        }\n\n        /**\n         * The number of public fields this type has. For primitive types this\n         * will always be zero. For arrays this will also be zero, we model\n         * 'fields' in them as their contents.\n         */", "        public int getNumFields()\n        {\n            return (isPrimitive() || isArray()) ? 0 : myFields.length;\n        }\n\n        /**\n         * Get the member type description for the given index.\n         */\n        public FieldDescription getField(int index)\n        {\n            FieldDescription desc = myFieldDescriptions[index];", "        public FieldDescription getField(int index)\n        {\n            FieldDescription desc = myFieldDescriptions[index];\n            if (desc == null) {\n                // Need to construct it, grab the corresponding Java method\n                final Field field = myFields[index];\n                desc =\n                    new FieldDescription(\n                        field.getName(),\n                        myTypeMapping.getDescription(field.getType()),\n                        (field.getModifiers() & Modifier.STATIC) != 0\n                    );\n\n                // And remember it\n                myFieldDescriptions[index] = desc;\n            }\n            return desc;\n        }\n\n        /**\n         * Get the value associated with a given field index from an instance.\n         */", "        public Object getField(int index, Object instance)\n            throws IllegalArgumentException,\n                   IllegalAccessException\n        {\n            return myFields[index].get(instance);\n        }\n\n        /**\n         * Set the value associated with a given field index from an instance.\n         */\n        public void setField(int index, Object instance, Object value)\n            throws IllegalArgumentException,\n                   IllegalAccessException\n        {\n            myFields[index].set(instance, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void setField(int index, Object instance, Object value)\n            throws IllegalArgumentException,\n                   IllegalAccessException\n        {\n            myFields[index].set(instance, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return myName + \"<\" + myTypeId + \">\";\n        }\n\n        /**\n         * Look for methods in a class which are publicly accessible.\n         *\n         * <p>We might need to do this if, for example, the class we have is not\n         * itself declared \"public\". If we don't do this then calling a\n         * non-accessible method will result in an {@link IllegalAccessException}\n         * being thrown. This is more involved than what we do for interfaces.\n         * See the {@code findInterfaceMethods()} sister method.\n         */\n        private Method[] findClassMethods(final Class<?> klass)\n        {\n            // This not be called for interfaces", "            if (klass.isInterface()) {\n                throw new IllegalArgumentException(\n                    \"Called for an interface: \" + klass\n                );\n            }\n\n            // Simple case if public\n            if ((klass.getModifiers() & Modifier.PUBLIC) != 0) {\n                return klass.getMethods();\n            }\n\n            // Otherwise we need to go off and hunt for them. We only save each\n            // method with a given signature once so that we don't get clashes.\n            final Map<MethodSignature,Method> methods = new HashMap<>();\n\n            // Handle all the interfaces", "            for (Class<?> iface : klass.getInterfaces()) {\n                for (Method method : iface.getMethods()) {\n                    final MethodSignature key =\n                        new MethodSignature(\n                            method.getName(),\n                            Arrays.asList(method.getParameterTypes())\n                        );\n                    if (!methods.containsKey(key)) {\n                        methods.put(key, method);\n                    }\n                }\n            }\n\n            // And the superclass", "            if (klass.getSuperclass() != null) {\n                // Recurse here, applying the same logic to the superclass\n                for (Method method : findClassMethods(klass.getSuperclass())) {\n                    final MethodSignature key =\n                        new MethodSignature(\n                            method.getName(),\n                            Arrays.asList(method.getParameterTypes())\n                        );\n                    if (!methods.containsKey(key)) {\n                        methods.put(key, method);\n                    }\n                }\n            }\n\n            // Given them back as an array\n            return methods.values().toArray(new Method[methods.size()]);\n        }\n\n        /**\n         * Get the accessible methods for a given interface.\n         *\n         * <p>Since these are in an interface we can do it in one fell swoop.\n         * This is a lot simpler than what we have to do for concrete classes.\n         * See the {@code findClassMethods()} sister method.\n         */\n        private Method[] findInterfaceMethods(final Class<?> klass)\n        {\n            // This method is only for interfaces", "                    if (!methods.containsKey(key)) {\n                        methods.put(key, method);\n                    }\n                }\n            }\n\n            // Given them back as an array\n            return methods.values().toArray(new Method[methods.size()]);\n        }\n\n        /**\n         * Get the accessible methods for a given interface.\n         *\n         * <p>Since these are in an interface we can do it in one fell swoop.\n         * This is a lot simpler than what we have to do for concrete classes.\n         * See the {@code findClassMethods()} sister method.\n         */\n        private Method[] findInterfaceMethods(final Class<?> klass)\n        {\n            // This method is only for interfaces", "            if (!klass.isInterface()) {\n                throw new IllegalArgumentException(\n                    \"Called for a non-interface: \" + klass\n                );\n            }\n\n            // We need to manually add in the Object methods to interfaces since\n            // they won't appear in the result of getMethods(), even though they\n            // are there for any object instance. This is needed for things like\n            // toString() and hashCode() to work as expected, when you are given\n            // back an interface instance from a method.\n            //\n            // We have to be slightly careful here to avoid adding methods from\n            // Object which have been specified in the interface though (people\n            // do this). We use the interface's method in preference to Object's\n            // one since the interface method's return type might have been\n            // overloaded to be more specific.\n            final Method[] klassMethods = klass.getMethods();\n            final Set<String> klassMethodNames =\n                Arrays.stream(klassMethods)\n                      .map(Method::getName)\n                      .collect(Collectors.toSet());\n\n            // Start with all of klass's methods\n            final List<Method> methods =\n                new ArrayList<>(Arrays.asList(klassMethods));\n\n            // And add in Object's ones, ensuring that the method doesn't appear\n            // in klass's methods. This is potentially O(n^2) but there are only\n            // 9 methods in Object so it's not awful, especially since we do the\n            // name-check first.", "            for (Method objectMethod : OBJECT_METHODS) {\n                final String objectMethodName = objectMethod.getName();\n                boolean contains = false;\n                if (klassMethodNames.contains(objectMethodName)) {\n                    for (Method klassMethod : klassMethods) {\n                        // We can't do a straight equals() here since the\n                        // methods are associated with different declaring\n                        // classes.\n                        if (objectMethodName.equals(klassMethod.getName()) &&\n                            Arrays.equals(objectMethod.getParameterTypes(),\n                                          klassMethod .getParameterTypes()))\n                        {\n                            // We matched on the name and params, that is\n                            // enough. The return type doesn't when it comes to\n                            // binding of overloaded methods.\n                            contains = true;\n                            break;\n                        }\n                    }\n                }\n\n                // It's not in the interface's methods so it's safe to add", "                        if (objectMethodName.equals(klassMethod.getName()) &&\n                            Arrays.equals(objectMethod.getParameterTypes(),\n                                          klassMethod .getParameterTypes()))\n                        {\n                            // We matched on the name and params, that is\n                            // enough. The return type doesn't when it comes to\n                            // binding of overloaded methods.\n                            contains = true;\n                            break;\n                        }\n                    }\n                }\n\n                // It's not in the interface's methods so it's safe to add", "                if (!contains) {\n                    methods.add(objectMethod);\n                }\n            }\n\n            // And convert the list an array to return it\n            return methods.toArray(new Method[methods.size()]);\n        }\n\n        /**\n         * See if this class is a functional interface.\n         */\n        private boolean isFunctionalInterface(final Class<?> klass)\n        {\n            // Any class?", "            if (klass == null) {\n                return false;\n            }\n\n            // First look at the annotations of this class\n            for (Annotation annotation : klass.getAnnotations()) {\n                if (annotation instanceof FunctionalInterface) {\n                    return true;\n                }\n            }\n\n            // Else, recurse on the interfaces", "            for (Class<?> iface : klass.getInterfaces()) {\n                if (isFunctionalInterface(iface)) {\n                    return true;\n                }\n            }\n\n            // And the superclass\n            return isFunctionalInterface(klass.getSuperclass());\n        }\n    }\n\n    // Classes for handling Python's subscriptable, item assignment and related\n    // functionality.\n\n    /**\n     * A class which represents a Python subscriptable container object which can\n     * have items associated with specific keys. This is anything which\n     * supports the {@code __getitem__()} operation as far as Python is\n     * concerned.\n     */", "    public static interface PythonSubscriptable\n    {\n        /**\n         * The Python {@code __getitem__()} method, which takes a multi-\n         * dimensional key.\n         *\n         * <p>E.g. {@code foo = bar[0,1,3]} on the Python side.\n         *\n         * <p>Implemenations of this method should include the\n         * {@link GenericReturnType} annotation in their signature so that the\n         * Python side sees the right type, and not just {@link Object}.\n         *\n         * @param key  The Python-style lookup key.\n         *\n         * @return  The value which was found, if any.\n         */\n        @GenericReturnType", "        public Object __getitem__(final Object[] key);\n    }\n\n    /**\n     * A class which represents a Python key-based container object which can\n     * have items associated with specific keys. This is anything which supports\n     * the {@code __setitem__()} operation as far as Python is concerned.\n     */\n    public static interface PythonItemAssignable\n    {\n        /**\n         * The Python {@code __setitem__()} method, which takes a multi-\n         * dimensional key and its associated value.\n         *\n         * <p>E.g. {@code foo [0,1,2] = 3} on the Python side.\n         *\n         * @param key    The Python-style lookup key.\n         * @param value  The value to set with.\n         */", "    public static interface PythonItemAssignable\n    {\n        /**\n         * The Python {@code __setitem__()} method, which takes a multi-\n         * dimensional key and its associated value.\n         *\n         * <p>E.g. {@code foo [0,1,2] = 3} on the Python side.\n         *\n         * @param key    The Python-style lookup key.\n         * @param value  The value to set with.\n         */", "        public void __setitem__(final Object[] key, final Object value);\n    }\n\n    /**\n     * What an array looks like in Java, as far as Python is concerned.\n     */\n    public interface ArrayLike\n        extends Iterable,\n                PythonSubscriptable,\n                PythonItemAssignable\n    {\n        /**\n         * Python length operator.\n         *\n         * @return the size of the (first dimension of the) array.\n         */", "        public int __len__();\n    }\n\n    /**\n     * A class which wraps a Java array and presents it as a Python array-like.\n     * This will eventually handle more complex array operations.\n     *\n     * <p>This class is a work-in-progress and more about fleshing out the\n     * semantics of using ArrayLikes and slice operations right now. It might\n     * even go away altogether...\n     */", "    public static class WrappedArrayLike\n        implements ArrayLike\n    {\n        /**\n         * The iterator for this array-like\n         */\n        private class ArrayIterator\n            implements Iterator<Object>\n        {\n            /**\n             * Current index.\n             */\n            private int myIndex = 0;\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public boolean hasNext()\n            {\n                return myIndex < __len__();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public Object next()\n                throws NoSuchElementException\n            {", "            public Object next()\n                throws NoSuchElementException\n            {\n                if (myIndex < __len__()) {\n                    final Object value = Array.get(myArray, myIndex++);\n                    return (value != null && value.getClass().isArray())\n                        ? new WrappedArrayLike(value)\n                        : value;\n                }\n                else {\n                    throw new NoSuchElementException();\n                }\n            }\n        }\n\n        /**\n         * The array which we wrap and will attempt to access in an array-like\n         * manner.\n         */\n        private final Object myArray;\n\n        /**\n         * The number of dimension of the wrapped array.\n         */\n        private final int myNumDims;\n\n        /**\n         * The element's class.\n         */\n        private final Class<?> myElementType;\n\n        /**\n         * Constructor.\n         *\n         * @param array  The array to wrap.\n         */\n        public WrappedArrayLike(final Object array)\n            throws IllegalArgumentException\n        {\n            // Check before we do anything", "            if (array == null) {\n                throw new NullPointerException(\"Given array was null\");\n            }\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException(\n                    \"Given value was a \" +\n                    array.getClass().getSimpleName() + \", not an array\"\n                );\n            }\n\n            // Safe to assign\n            myArray = array;\n\n            // Now determine other meta-data\n            Class<?> klass = array.getClass();\n            int ndim = 0;", "            while (true) {\n                // We have a new dimension\n                ndim++;\n                klass = klass.getComponentType();\n\n                // If we have gotten to the last array of a multidimensional one\n                // then we have elements in it\n                if (!klass.isArray()) {\n                    myElementType = klass;\n                    break;\n                }\n                // Otherwise we go around again...\n            }\n            assert(myElementType != null);\n            myNumDims = ndim;\n        }\n\n        /**\n         * Get the array which we are wrapping.\n         *\n         * @return the wrapped array.\n         */\n        @GenericReturnType", "        public Object getWrappedArray()\n        {\n            return myArray;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int __len__()\n        {\n            return Array.getLength(myArray);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        @GenericReturnType", "        public int __len__()\n        {\n            return Array.getLength(myArray);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        @GenericReturnType\n        public Object __getitem__(final Object[] key)\n            throws ArrayIndexOutOfBoundsException,\n                   IllegalArgumentException,\n                   NullPointerException\n        {\n            // Validate the key before we use it\n            assertKeyCorrectness(key);\n\n            // Keep walking down and attempt to give back whatever we find for\n            // the key\n            Object value = myArray;", "        public Object __getitem__(final Object[] key)\n            throws ArrayIndexOutOfBoundsException,\n                   IllegalArgumentException,\n                   NullPointerException\n        {\n            // Validate the key before we use it\n            assertKeyCorrectness(key);\n\n            // Keep walking down and attempt to give back whatever we find for\n            // the key\n            Object value = myArray;", "            for (Object k : key) {\n                if (k instanceof Number) {\n                    final int index = ((Number)k).intValue();\n                    try {\n                        value = Array.get(value, index);\n                    }\n                    catch (ArrayIndexOutOfBoundsException e) {\n                        throw new ArrayIndexOutOfBoundsException(\n                            index + \" was not in the range [0..\" +\n                            Array.getLength(value) + \")\"\n                        );\n                    }\n                }\n                // TODO handle PythonSlice in here too\n                else {\n                    throw new IllegalArgumentException(\n                        \"Don't know how to index with \" + k + \" in key \" +\n                        Arrays.toString(key)\n                    );\n                }\n            }\n\n            // If we have an array then we wrap that, else we just return what\n            // we got\n            return (value != null && value.getClass().isArray())\n                ? new WrappedArrayLike(value)\n                : value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void __setitem__(final Object[] key, final Object value)\n            throws ArrayIndexOutOfBoundsException,\n                   IllegalArgumentException\n        {\n            // Validate the key before we use it\n            assertKeyCorrectness(key);\n\n            // Keep walking down until we get to the penultimate array\n            Object array = myArray;\n            for (int i=0; i < key.length-1; i++) {\n                final Object k = key[i];", "            for (int i=0; i < key.length-1; i++) {\n                final Object k = key[i];\n                if (k instanceof Number) {\n                    final int index = ((Number)k).intValue();\n                    try {\n                        array = Array.get(value, ((Number)k).intValue());\n                    }\n                    catch (ArrayIndexOutOfBoundsException e) {\n                        throw new ArrayIndexOutOfBoundsException(\n                            index + \" was not in the range [0..\" +\n                            Array.getLength(value) + \")\"\n                        );\n                    }\n                }\n                // TODO handle PythonSlice in here too\n                else {\n                    throw new IllegalArgumentException(\n                        \"Don't know how to index with \" + k + \" in key \" +\n                        Arrays.toString(key)\n                    );\n                }\n            }\n\n            // Now attempt to use the last key to set the value", "            try {\n                final Object k = key[key.length-1];\n                if (k instanceof Number) {\n                    final int index = ((Number)k).intValue();\n                    try {\n                        Array.set(array, ((Number)k).intValue(), value);\n                    }\n                    catch (ArrayIndexOutOfBoundsException e) {\n                        throw new ArrayIndexOutOfBoundsException(\n                            index + \" was not in the range [0..\" +\n                            Array.getLength(array) + \")\"\n                        );\n                    }\n                }\n                else {\n                    throw new IllegalArgumentException(\n                        \"Don't know how to index with \" + k + \" in key \" +\n                        Arrays.toString(key)\n                    );\n                }\n            }\n            catch (ClassCastException e) {\n                throw new IllegalArgumentException(\n                    \"Failed to set in array of \" + array.getClass() + \" \" +\n                    \"with value of type \" +\n                    (value == null ? \"null\" : value.getClass().getSimpleName()),\n                    e\n                );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Object> iterator()\n        {\n            return new ArrayIterator();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            final StringBuilder sb = new StringBuilder();\n            toStringBuilder(sb, myArray);\n            return sb.toString();\n        }\n\n        /**\n         * Recurse down into an array and keep printing its contents.\n         */\n        private void toStringBuilder(final StringBuilder sb, final Object array)\n        {\n            sb.append('[');", "            if (array != null) {\n                final boolean isArray =\n                    array.getClass().getComponentType().isArray();\n                for (int i = 0, len = Array.getLength(array); i < len; i++) {\n                    final Object element = Array.get(array, i);\n                    if (element.getClass().isArray()) {\n                        toStringBuilder(sb, element);\n                    }\n                    else {\n                        sb.append(element);\n                    }", "                    if (i < len-1) {\n                        sb.append(\", \");\n                    }\n                }\n            }\n            sb.append(']');\n        }\n\n        /**\n         * Check that a key is correct.\n         */\n        private void assertKeyCorrectness(final Object[] key)\n        {\n            // Check key correctness", "            if (key == null) {\n                throw new NullPointerException(\"Given a null key\");\n            }\n            if (key.length > myNumDims) {\n                throw new ArrayIndexOutOfBoundsException(\n                    \"Too many indices for array; \" +\n                    \"array is \" + myNumDims + \"-dimensional, \" +\n                    \"but \" + key.length + \" were indexed\"\n                );\n            }\n        }\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * How we order methods. We put them in order of:\n     *  1. Name\n     *  2. Number of arguments\n     *  3. Most specific\n     * The final point (3) is the important one here since the Python code will\n     * bind to the first match it finds. As such you want it to bind to, say,\n     * {@code void Foo(String)} before it binds to {@code void Foo(Object)}\n     * and {@code String Foo()} before {@code Object Foo()}.\n     *\n     * <p>Note that this somewhat breaks the Comparable contract since methods\n     * may not have a canonical partial ordering. This is because we rely on\n     * method arguments, and return types, to order the methods. Since there is\n     * no \"true\" ordering of the classes within an inheritance tree, there can\n     * be no \"true\" ordering of things based on this. Alternatively, one can say\n     * that the ordering is not transitive; you potentially have a form of\n     * \"paper, scissors, stone\" ordering in some cases. This can break things\n     * like TimSort (used by Arrays.sort()) which rely on a true partial\n     * ordering.\n     */\n    private static final class MethodComparator\n        implements Comparator<Method>\n    {\n        /**\n         * Our singleton instance.\n         */", "        public static final MethodComparator INSTANCE = new MethodComparator();\n\n        /**\n         * How we ensure that longs, ints, etc. are orders with the largest one\n         * first. This is needed since we might be inferring the type on the\n         * Python side and we want to avoid throwing a ImpreciseRepresentationError\n         * in the wrong place.\n         */\n        private static final List<Class<?>> PRIMITIVE_PRIORITIES;\n        static {\n            PRIMITIVE_PRIORITIES = new ArrayList<>();\n            PRIMITIVE_PRIORITIES.add(Double .TYPE);\n            PRIMITIVE_PRIORITIES.add(Float  .TYPE);\n            PRIMITIVE_PRIORITIES.add(Long   .TYPE);\n            PRIMITIVE_PRIORITIES.add(Integer.TYPE);\n            PRIMITIVE_PRIORITIES.add(Short  .TYPE);\n            PRIMITIVE_PRIORITIES.add(Byte   .TYPE);\n        }\n\n        /**\n         * Singleton CTOR.\n         */\n        private MethodComparator()\n        {\n            // Nothing\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int compare(Method m1, Method m2)\n        {\n            // First by name\n            int c = m1.getName().compareTo(m2.getName());\n            if (c != 0) {\n                return c;\n            }\n\n            // Next by number of arguments\n            Class<?>[] p1 = m1.getParameterTypes();\n            Class<?>[] p2 = m2.getParameterTypes();\n            c = p1.length - p2.length;", "            if (c != 0) {\n                return c;\n            }\n\n            // Next, by specificity\n            for (int i=0; i < p1.length; i++) {\n                // We need to ensure that longs come before ints come before\n                // shorts etc. We need this since long and int are both\n                // assignable from one-another(!).\n                final int i1 = PRIMITIVE_PRIORITIES.indexOf(p1[i]);\n                final int i2 = PRIMITIVE_PRIORITIES.indexOf(p2[i]);", "                if (i1 >= 0 && i2 >= 0 && i1 != i2) {\n                    return i1 - i2;\n                }\n\n                // Now fall back assignment comparison\n                if ( p2[i].isAssignableFrom(p1[i]) &&\n                    !p1[i].isAssignableFrom(p2[i]))\n                {\n                    return -1;\n                }\n                if ( p1[i].isAssignableFrom(p2[i]) &&\n                    !p2[i].isAssignableFrom(p1[i]))\n                {\n                    return 1;\n                }\n            }\n\n            // Now by return type. Sort methods so that the ones which have\n            // subclasses as their return type come first. This ensures that\n            // the the \"most\" overridden method is called and the caller gets\n            // an object with the appropriate return type.\n            final Class<?> r1 = m1.getReturnType();\n            final Class<?> r2 = m2.getReturnType();", "                if ( p1[i].isAssignableFrom(p2[i]) &&\n                    !p2[i].isAssignableFrom(p1[i]))\n                {\n                    return 1;\n                }\n            }\n\n            // Now by return type. Sort methods so that the ones which have\n            // subclasses as their return type come first. This ensures that\n            // the the \"most\" overridden method is called and the caller gets\n            // an object with the appropriate return type.\n            final Class<?> r1 = m1.getReturnType();\n            final Class<?> r2 = m2.getReturnType();", "            if ( r2.isAssignableFrom(r1) &&\n                !r1.isAssignableFrom(r2))\n            {\n                return -1;\n            }\n            if ( r1.isAssignableFrom(r2) &&\n                !r2.isAssignableFrom(r1))\n            {\n                return 1;\n            }\n\n            // Finally, as a tie-break, we sort by class name so as to ensure\n            // that we have a total ordering (required for TimSort to work)", "            for (int i=0; i < p1.length; i++) {\n                final int cmp = p1[i].getName().compareTo(p2[i].getName());\n                if (cmp != 0) {\n                    return cmp;\n                }\n            }\n\n            // Must be the same\n            return 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean equals(Object that)\n        {\n            return (this == that);\n        }\n    }\n\n    /**\n     * A name and list of classes which uniquely define a method signature.\n     */\n    private static class MethodSignature\n    {\n        /**\n         * The name of the method.\n         */\n        private final String myName;\n\n        /**\n         * The classes of each of its parameters.\n         */\n        private final List<Class<?>> myParamTypes;\n\n        /**\n         * CTOR.\n         */\n        public MethodSignature(String name, List<Class<?>> paramTypes)\n        {\n            myName       = name;\n            myParamTypes = paramTypes;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int hashCode()\n        {\n            return myName      .hashCode() ^\n                   myParamTypes.hashCode();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean equals(Object obj)\n        {", "        public boolean equals(Object obj)\n        {\n            if (obj instanceof MethodSignature) {\n                final MethodSignature that = (MethodSignature)obj;\n                return this.myName      .equals(that.myName      ) &&\n                       this.myParamTypes.equals(that.myParamTypes);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * The result of {@code readObject()}.\n     */\n    private static class ReadObjectResult\n    {\n        // The result is an offset and the object read", "        public final int    offset;\n        public final Object object;\n\n        /**\n         * CTOR.\n         */\n        public ReadObjectResult(final int offset, final Object object)\n        {\n            this.offset = offset;\n            this.object = object;\n        }\n    }\n\n    /**\n     * What a field looks like.\n     */\n    private static class FieldDescription\n    {\n        /**\n         * The method name.\n         */\n        private final String myName;\n\n        /**\n         * The field type.\n         */\n        private final TypeDescription myType;\n\n        /**\n         * Whether this is a static field.\n         */\n        private final boolean myIsStatic;\n\n        /**\n         * CTOR.\n         */\n        public FieldDescription(final String          name,\n                                final TypeDescription type,\n                                final boolean         isStatic)\n        {\n            myName     = name;\n            myType     = type;\n            myIsStatic = isStatic;\n\n            // Talk to the animals", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Created \" + this);\n            }\n        }\n\n        /**\n         * Get the method name.\n         */\n        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * Get the type.\n         */", "        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * Get the type.\n         */\n        public TypeDescription getType()\n        {\n            return myType;\n        }\n\n        /**\n         * Whether this is a static method.\n         */", "        public TypeDescription getType()\n        {\n            return myType;\n        }\n\n        /**\n         * Whether this is a static method.\n         */\n        public boolean isStatic()\n        {\n            return myIsStatic;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean isStatic()\n        {\n            return myIsStatic;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return myName;\n        }\n    }\n\n    /**\n     * Flags associated with a method description.\n     */\n    private static enum MethodFlags\n    {\n        IS_STATIC    ((short)(1 << 0)),\n        IS_DEPRECATED((short)(1 << 1)),\n        UNUSED_02    ((short)(1 << 2)),\n        UNUSED_03    ((short)(1 << 3)),\n        UNUSED_04    ((short)(1 << 4)),\n        UNUSED_05    ((short)(1 << 5)),\n        UNUSED_06    ((short)(1 << 6)),\n        UNUSED_07    ((short)(1 << 7)),\n        IS_DEFAULT   ((short)(1 << 8));\n", "        public String toString()\n        {\n            return myName;\n        }\n    }\n\n    /**\n     * Flags associated with a method description.\n     */\n    private static enum MethodFlags\n    {\n        IS_STATIC    ((short)(1 << 0)),\n        IS_DEPRECATED((short)(1 << 1)),\n        UNUSED_02    ((short)(1 << 2)),\n        UNUSED_03    ((short)(1 << 3)),\n        UNUSED_04    ((short)(1 << 4)),\n        UNUSED_05    ((short)(1 << 5)),\n        UNUSED_06    ((short)(1 << 6)),\n        UNUSED_07    ((short)(1 << 7)),\n        IS_DEFAULT   ((short)(1 << 8));\n", "        public final short value;\n\n        private MethodFlags(final short value)\n        {\n            this.value = value;\n        }\n    }\n\n    /**\n     * How a method is being called.\n     */\n    private static enum SyncMode\n    {\n        SYNCHRONOUS((byte) 'S'),\n        JAVA_THREAD((byte) 'J');\n\n        /**\n         * All the possible modes, keyed by ID.\n         */\n        private static final SyncMode[] VALUES = new SyncMode[0xff];\n        static {", "            for (SyncMode sm : SyncMode.values()) {\n                VALUES[Byte.toUnsignedInt(sm.id)] = sm;\n            }\n        }\n\n        /**\n         * The unique identifier of this mode.\n         */\n        public final byte id;\n\n        /**\n         * Get the SyncMode instance for a given ID.\n         */", "        public final byte id;\n\n        /**\n         * Get the SyncMode instance for a given ID.\n         */\n        public static SyncMode byId(final byte id)\n        {\n            SyncMode result = VALUES[Byte.toUnsignedInt(id)];\n            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad SyncMode value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private SyncMode(byte id)\n        {\n            this.id = id;\n        }\n    }\n\n    /**\n     * What we get back when we call a method asynchronously.\n     */\n    private static class MethodCallFuture\n        implements Future<Object>\n    {\n        /**\n         * Our description.\n         */\n        private String myDescription;\n\n        /**\n         * Our result.\n         */\n        private volatile Object myResult;\n\n        /**\n         * Whether the call is done.\n         */\n        private volatile boolean myIsDone;\n\n        /**\n         * Whether the call resulted in an exception, which should be thrown.\n         */\n        private volatile boolean myIsException;\n\n        /**\n         * CTOR.\n         */\n        public MethodCallFuture(final String desc)\n        {\n            myDescription = desc;\n            myResult      = null;\n            myIsDone      = false;\n            myIsException = false;\n        }\n\n        /**\n         * Called when done.\n         */", "            if (result == null) {\n                throw new IllegalArgumentException(\n                    \"Bad SyncMode value: '\" + (char)id + \"' \" + (int)id\n                );\n            }\n            return result;\n        }\n\n        /**\n         * CTOR.\n         */\n        private SyncMode(byte id)\n        {\n            this.id = id;\n        }\n    }\n\n    /**\n     * What we get back when we call a method asynchronously.\n     */\n    private static class MethodCallFuture\n        implements Future<Object>\n    {\n        /**\n         * Our description.\n         */\n        private String myDescription;\n\n        /**\n         * Our result.\n         */\n        private volatile Object myResult;\n\n        /**\n         * Whether the call is done.\n         */\n        private volatile boolean myIsDone;\n\n        /**\n         * Whether the call resulted in an exception, which should be thrown.\n         */\n        private volatile boolean myIsException;\n\n        /**\n         * CTOR.\n         */\n        public MethodCallFuture(final String desc)\n        {\n            myDescription = desc;\n            myResult      = null;\n            myIsDone      = false;\n            myIsException = false;\n        }\n\n        /**\n         * Called when done.\n         */", "        public void done(final Object  result,\n                         final boolean isException)\n        {\n            myResult      = result;\n            myIsException = isException;\n            myIsDone      = true; // <-- Must be last\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean cancel(boolean mayInterruptIfRunning)\n        {\n            // Can't be cancelled\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isCancelled()\n        {\n            // Can't be cancelled\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean isCancelled()\n        {\n            // Can't be cancelled\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isDone()\n        {\n            return myIsDone;\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * <p>Calling this more than once will result in an exception being\n         * thrown since the result is released once collected.\n         */\n        @Override", "        public boolean isDone()\n        {\n            return myIsDone;\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * <p>Calling this more than once will result in an exception being\n         * thrown since the result is released once collected.\n         */\n        @Override", "        public Object get()\n            throws ExecutionException,\n                   InterruptedException\n        {\n            try {\n                return get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n            }\n            catch (TimeoutException e) {\n                throw new ExecutionException(\n                    \"Timed out but should not have\",\n                    e\n                );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * <p>Calling this more than once will result in an exception being\n         * thrown since the result is released once collected.\n         */\n        @Override", "        public Object get(long timeout, TimeUnit unit)\n            throws ExecutionException,\n                   InterruptedException,\n                   TimeoutException\n        {\n            // See how long to wait until\n            final long untilMs;\n            if (timeout < 0) {\n                untilMs = System.currentTimeMillis();\n            }\n            else {\n                // Need to handle overflow here\n                final long end =\n                    System.currentTimeMillis() + unit.toMillis(timeout);\n                untilMs = (end < 0) ? Long.MAX_VALUE : end;\n            }\n\n            // Now do the get", "            while (true) {\n                // See if we got a result\n                if (myIsDone) {\n                    // Give back whatever it was\n                    if (myIsException) {\n                        if (myResult != null) {\n                            throw new ExecutionException((Throwable)myResult);\n                        }\n                        else {\n                            throw new ExecutionException(\n                                \"An unknown error occurred\",\n                                new Throwable()\n                            );\n                        }\n                    }\n                    else {\n                        // Get the result and give it back. This may only be\n                        // called once since we release the handle on the result\n                        // so that it may be GC'd.\n                        final Object result = myResult;\n                        myResult =\n                            new IllegalStateException(\"Result already collected\");\n                        myIsException = true;\n                        myDescription += \" [COLLECTED]\";\n                        return result;\n                    }\n                }", "                else if (System.currentTimeMillis() >= untilMs) {\n                    throw new TimeoutException();\n                }\n                else {\n                    // Wait a microsecond\n                    Thread.sleep(0, 1000);\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return myDescription;\n        }\n    }\n\n    /**\n     * What a method looks like.\n     */\n    private static class MethodDescription\n    {\n        /**\n         * Method argument types as they come over the wire.\n         */\n        private static enum ArgumentType\n        {\n            REFERENCE ((byte) 'R'), // Value is a handle\n            VALUE     ((byte) 'V'), // Value is raw bits\n            SHMDATA   ((byte) 'S'), // Value is written in a shared file\n            METHOD    ((byte) 'M'), // Value is a method handle\n            LAMBDA    ((byte) 'L'), // Value is supplied by invoking a lambda\n            ;\n\n            /**\n             * All the possible types, keyed by ID.\n             */\n            private static final ArgumentType[] VALUES = new ArgumentType[0xff];\n            static {", "                for (ArgumentType mt : ArgumentType.values()) {\n                    VALUES[Byte.toUnsignedInt(mt.id)] = mt;\n                }\n            }\n\n            /**\n             * The unique identifier of this message type.\n             */\n            public final byte id;\n\n            /**\n             * Get the ArgumentType instance for a given ID.\n             */", "            public final byte id;\n\n            /**\n             * Get the ArgumentType instance for a given ID.\n             */\n            public static ArgumentType byId(final byte id)\n            {\n                ArgumentType result = VALUES[Byte.toUnsignedInt(id)];\n                if (result == null) {\n                    throw new IllegalArgumentException(\n                        \"Bad ArgumentType value: '\" + (char)id + \"' \" + (int)id\n                    );\n                }\n                return result;\n            }\n\n            /**\n             * CTOR.\n             */\n            private ArgumentType(byte id)\n            {\n                this.id = id;\n            }\n        }\n\n        /**\n         * The method's index; this will be unique in each category of \"methods\"\n         * and \"constructors\".\n         */\n        private final int myIndex;\n\n        /**\n         * The method name.\n         */\n        private final String myName;\n\n        /**\n         * The {@link MethodFlags} associated with this method.\n         */\n        private final short myFlags;\n\n        /**\n         * The return type, may be VOID.\n         */\n        private final TypeDescription myReturnType;\n\n        /**\n         * Whether the return type is a type as specified as a parameter to a\n         * generic declaration.\n         */\n        private final boolean myIsGenericReturnType;\n\n        /**\n         * The arguments, if any.\n         */\n        private final TypeDescription[] myArguments;\n\n        /**\n         * The parameter names, if any.\n         */\n        private final String[] myParameterNames;\n\n        /**\n         * The toString() representation.\n         */\n        private final String myString;\n\n        /**\n         * CTOR.\n         */\n        public MethodDescription(final int               index,\n                                 final String            name,\n                                 final boolean           isStatic,\n                                 final boolean           isDeprecated,\n                                 final boolean           isDefault,\n                                 final TypeDescription   returnType,\n                                 final boolean           isGenericReturnType,\n                                 final TypeDescription[] arguments,\n                                 final String[]          parameterNames)\n        {\n            myIndex               = index;\n            myName                = name;\n            myReturnType          = returnType;\n            myIsGenericReturnType = isGenericReturnType;\n            myArguments           = arguments;\n            myParameterNames      = parameterNames;\n\n            myFlags = (short)((isStatic     ? MethodFlags.IS_STATIC    .value : 0) |\n                              (isDeprecated ? MethodFlags.IS_DEPRECATED.value : 0) |\n                              (isDefault    ? MethodFlags.IS_DEFAULT   .value : 0));\n\n            // Create the string representation to save work later\n            StringBuilder sb = new StringBuilder();\n            sb.append(returnType.toString()).append(' ')\n              .append(name).append('(');\n            String comma = \"\";", "                if (result == null) {\n                    throw new IllegalArgumentException(\n                        \"Bad ArgumentType value: '\" + (char)id + \"' \" + (int)id\n                    );\n                }\n                return result;\n            }\n\n            /**\n             * CTOR.\n             */\n            private ArgumentType(byte id)\n            {\n                this.id = id;\n            }\n        }\n\n        /**\n         * The method's index; this will be unique in each category of \"methods\"\n         * and \"constructors\".\n         */\n        private final int myIndex;\n\n        /**\n         * The method name.\n         */\n        private final String myName;\n\n        /**\n         * The {@link MethodFlags} associated with this method.\n         */\n        private final short myFlags;\n\n        /**\n         * The return type, may be VOID.\n         */\n        private final TypeDescription myReturnType;\n\n        /**\n         * Whether the return type is a type as specified as a parameter to a\n         * generic declaration.\n         */\n        private final boolean myIsGenericReturnType;\n\n        /**\n         * The arguments, if any.\n         */\n        private final TypeDescription[] myArguments;\n\n        /**\n         * The parameter names, if any.\n         */\n        private final String[] myParameterNames;\n\n        /**\n         * The toString() representation.\n         */\n        private final String myString;\n\n        /**\n         * CTOR.\n         */\n        public MethodDescription(final int               index,\n                                 final String            name,\n                                 final boolean           isStatic,\n                                 final boolean           isDeprecated,\n                                 final boolean           isDefault,\n                                 final TypeDescription   returnType,\n                                 final boolean           isGenericReturnType,\n                                 final TypeDescription[] arguments,\n                                 final String[]          parameterNames)\n        {\n            myIndex               = index;\n            myName                = name;\n            myReturnType          = returnType;\n            myIsGenericReturnType = isGenericReturnType;\n            myArguments           = arguments;\n            myParameterNames      = parameterNames;\n\n            myFlags = (short)((isStatic     ? MethodFlags.IS_STATIC    .value : 0) |\n                              (isDeprecated ? MethodFlags.IS_DEPRECATED.value : 0) |\n                              (isDefault    ? MethodFlags.IS_DEFAULT   .value : 0));\n\n            // Create the string representation to save work later\n            StringBuilder sb = new StringBuilder();\n            sb.append(returnType.toString()).append(' ')\n              .append(name).append('(');\n            String comma = \"\";", "            for (TypeDescription td : arguments) {\n                sb.append(comma).append(td.toString());\n                comma = \", \";\n            }\n            sb.append(')');\n\n            myString = sb.toString();\n\n            // Talk to the animals\n            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Created \" + this);\n            }\n        }\n\n        /**\n         * Get the method index.\n         */", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Created \" + this);\n            }\n        }\n\n        /**\n         * Get the method index.\n         */\n        public int getIndex()\n        {\n            return myIndex;\n        }\n\n        /**\n         * Get the method name.\n         */", "        public int getIndex()\n        {\n            return myIndex;\n        }\n\n        /**\n         * Get the method name.\n         */\n        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * Get the {@link MethodFlags} mask for this method.\n         */", "        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * Get the {@link MethodFlags} mask for this method.\n         */\n        public short getFlags()\n        {\n            return myFlags;\n        }\n\n        /**\n         * Whether this is a static method.\n         */", "        public short getFlags()\n        {\n            return myFlags;\n        }\n\n        /**\n         * Whether this is a static method.\n         */\n        public boolean isStatic()\n        {\n            return (MethodFlags.IS_STATIC.value & myFlags) != 0;\n        }\n\n        /**\n         * Whether this is a deprecated method.\n         */", "        public boolean isStatic()\n        {\n            return (MethodFlags.IS_STATIC.value & myFlags) != 0;\n        }\n\n        /**\n         * Whether this is a deprecated method.\n         */\n        public boolean isDeprecated()\n        {\n            return (MethodFlags.IS_DEPRECATED.value & myFlags) != 0;\n        }\n\n        /**\n         * Whether this is a default method.\n         */", "        public boolean isDeprecated()\n        {\n            return (MethodFlags.IS_DEPRECATED.value & myFlags) != 0;\n        }\n\n        /**\n         * Whether this is a default method.\n         */\n        public boolean isDefault()\n        {\n            return (MethodFlags.IS_DEFAULT.value & myFlags) != 0;\n        }\n\n        /**\n         * Get the return type.\n         */", "        public boolean isDefault()\n        {\n            return (MethodFlags.IS_DEFAULT.value & myFlags) != 0;\n        }\n\n        /**\n         * Get the return type.\n         */\n        public TypeDescription getReturnType()\n        {\n            return myReturnType;\n        }\n\n        /**\n         * Whether the return type is a type specified as a generic parameter\n         * (e.g. the E in List&lt;E&gt;).\n         */", "        public TypeDescription getReturnType()\n        {\n            return myReturnType;\n        }\n\n        /**\n         * Whether the return type is a type specified as a generic parameter\n         * (e.g. the E in List&lt;E&gt;).\n         */\n        public boolean isGenericReturnType()\n        {\n            return myIsGenericReturnType;\n        }\n\n        /**\n         * Get the number of arguments.\n         */", "        public boolean isGenericReturnType()\n        {\n            return myIsGenericReturnType;\n        }\n\n        /**\n         * Get the number of arguments.\n         */\n        public short getNumArguments()\n        {\n            return (short)myArguments.length;\n        }\n\n        /**\n         * Get the nth argument.\n         */", "        public short getNumArguments()\n        {\n            return (short)myArguments.length;\n        }\n\n        /**\n         * Get the nth argument.\n         */\n        public TypeDescription getArgument(short index)\n        {\n            return myArguments[index];\n        }\n\n        /**\n         * Get the nth parameter name.\n         */", "        public TypeDescription getArgument(short index)\n        {\n            return myArguments[index];\n        }\n\n        /**\n         * Get the nth parameter name.\n         */\n        public String getParameterName(short index)\n        {\n            return myParameterNames[index];\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String getParameterName(short index)\n        {\n            return myParameterNames[index];\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return myString;\n        }\n    }\n\n    /**\n     * The type to ID mapping.\n     */\n    private class TypeMapping\n    {\n        /**\n         * The mappings.\n         */\n        private TypeDescription[] myIdToDescription = new TypeDescription[1024];\n        private final Map<Class<?>,TypeDescription> myClassToDescription =\n            new HashMap<>();\n\n        /**\n         * The next ID to use.\n         */\n        private int myNextId = 0;\n\n        /**\n         * CTOR.\n         */\n        public TypeMapping()\n        {\n            // Ensure void is ID zero; not actually required but make debugging\n            // easier etc. when you have things like NULL and Void be zero\n            final TypeDescription voidType = getDescription(Void.TYPE);\n            assert(voidType.getTypeId() == 0);\n        }\n\n        /**\n         * Get the ID for a given object's class, creating it if need be.\n         */", "        public String toString()\n        {\n            return myString;\n        }\n    }\n\n    /**\n     * The type to ID mapping.\n     */\n    private class TypeMapping\n    {\n        /**\n         * The mappings.\n         */\n        private TypeDescription[] myIdToDescription = new TypeDescription[1024];\n        private final Map<Class<?>,TypeDescription> myClassToDescription =\n            new HashMap<>();\n\n        /**\n         * The next ID to use.\n         */\n        private int myNextId = 0;\n\n        /**\n         * CTOR.\n         */\n        public TypeMapping()\n        {\n            // Ensure void is ID zero; not actually required but make debugging\n            // easier etc. when you have things like NULL and Void be zero\n            final TypeDescription voidType = getDescription(Void.TYPE);\n            assert(voidType.getTypeId() == 0);\n        }\n\n        /**\n         * Get the ID for a given object's class, creating it if need be.\n         */", "        public synchronized int getId(final Object object)\n        {\n            if (object == null) {\n                throw new NullPointerException(\n                    \"Asked for the type ID of a null object\"\n                );\n            }\n            return getId(object.getClass());\n        }\n\n        /**\n         * Get the TypeDescription for a given class, creating it if need be.\n         */", "        public synchronized TypeDescription getDescription(final Class<?> klass)\n        {\n            if (klass == null) {\n                throw new NullPointerException(\n                    \"Asked for the type ID of a null class\"\n                );\n            }\n            TypeDescription desc = myClassToDescription.get(klass);\n            if (desc == null) {\n                final int id = myNextId++;\n                if (id >= myIdToDescription.length) {\n                    // This will fail if we manage to get more than 2^31 types\n                    // active at any one time. I hope that this is unlikely.\n                    myIdToDescription =\n                        Arrays.copyOf(myIdToDescription,\n                                      myIdToDescription.length << 1);\n                }\n\n                desc = new TypeDescription(klass, id);\n                myClassToDescription.put(klass, desc);\n                myIdToDescription[id] = desc;\n", "            if (desc == null) {\n                final int id = myNextId++;\n                if (id >= myIdToDescription.length) {\n                    // This will fail if we manage to get more than 2^31 types\n                    // active at any one time. I hope that this is unlikely.\n                    myIdToDescription =\n                        Arrays.copyOf(myIdToDescription,\n                                      myIdToDescription.length << 1);\n                }\n\n                desc = new TypeDescription(klass, id);\n                myClassToDescription.put(klass, desc);\n                myIdToDescription[id] = desc;\n", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Created type mapping \" +\n                               \"from \" + klass + \" to \" + desc);\n                }\n            }\n            return desc;\n        }\n\n        /**\n         * Get the TypeDescription for a given ID, if any.\n         */", "        public synchronized TypeDescription getDescription(final int id)\n        {\n            return (0 <= id && id < myIdToDescription.length)\n                   ? myIdToDescription[id]\n                   : null;\n        }\n\n        /**\n         * Get the ID for a given class, creating it if needbe.\n         */\n        public synchronized int getId(final Class<?> klass)\n        {\n            return getDescription(klass).getTypeId();\n        }\n\n        /**\n         * Get a copy of the set of mapped classes.\n         */", "        public synchronized int getId(final Class<?> klass)\n        {\n            return getDescription(klass).getTypeId();\n        }\n\n        /**\n         * Get a copy of the set of mapped classes.\n         */\n        public synchronized Set<Class<?>> getClasses()\n        {\n            return new HashSet<>(myClassToDescription.keySet());\n        }\n    }\n\n    /**\n     * The handle to object mapping.\n     */\n    private static class HandleMapping\n    {\n        /**\n         * A reference to an object, with a count.\n         */\n        private static class Reference\n        {", "        public synchronized Set<Class<?>> getClasses()\n        {\n            return new HashSet<>(myClassToDescription.keySet());\n        }\n    }\n\n    /**\n     * The handle to object mapping.\n     */\n    private static class HandleMapping\n    {\n        /**\n         * A reference to an object, with a count.\n         */\n        private static class Reference\n        {", "            public final Object object;\n            public final long   handle;\n            public       int    count;\n\n            public Reference(Object object, long handle)\n            {\n                this.object = object;\n                this.handle = handle;\n                this.count  = 0;\n            }\n        }\n\n        /**\n         * The handle value for \"null\".\n         */", "        public static final long NULL_HANDLE = 0;\n\n        /*\n         * The mappings.\n         */\n        private final Map<Long,Reference> myHandleToReference =\n            new HashMap<>();\n        private final Map<Object,Reference> myObjectToReference =\n            new IdentityHashMap<>();\n\n        /**\n         * The next handle to use.\n         */\n        private long myNextHandle;\n\n        /**\n         * CTOR.\n         */\n        public HandleMapping(int salt)\n        {\n            // Start from an arbitrary value; never zero since we use that for\n            // NULL_HANDLE\n            myNextHandle = Math.abs((long)salt << 32) + 1;\n        }\n\n        /**\n         * Add a reference for a given object, returning the handle.\n         */", "        public synchronized long addReference(final Object object)\n        {\n            if (object == null) {\n                throw new NullPointerException(\n                    \"Attempt to add a reference to a null object\"\n                );\n            }\n\n            // Get the reference, lazily creating\n            Reference ref = myObjectToReference.get(object);\n            if (ref == null) {\n                ref = new Reference(object, myNextHandle++);\n                myObjectToReference.put(ref.object, ref);\n                myHandleToReference.put(ref.handle, ref);\n", "            if (ref == null) {\n                ref = new Reference(object, myNextHandle++);\n                myObjectToReference.put(ref.object, ref);\n                myHandleToReference.put(ref.handle, ref);\n\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Created object handle \" +\n                        \"from \" + ref.handle + \" \" +\n                        \"to object of class \" + object.getClass()\n                    );\n                }\n            }\n\n            // Actually add the reference\n            ref.count++;", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Reference count now \" + ref.count + \" for \" + ref.handle\n                );\n            }\n\n            // And ensure the user knows the handle\n            return ref.handle;\n        }\n\n        /**\n         * Add a reference for a given handle.\n         */", "        public synchronized void addReference(final long handle)\n        {\n            Reference ref = myHandleToReference.get(handle);\n            if (ref != null) {\n                ref.count++;\n\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Reference count now \" + ref.count + \" for \" + handle\n                    );\n                }\n            }\n        }\n\n        /**\n         * Drop the reference for a given handle.\n         */", "        public synchronized void dropReference(final long handle)\n        {\n            final Reference ref = myHandleToReference.get(handle);\n            if (ref == null) {\n                // Warn?\n                return;\n            }\n\n            // Decrement the reference counter\n            ref.count--;\n            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Reference count now \" + ref.count + \" for \" + ref.handle\n                );\n            }\n\n            // Anything left?", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Reference count now \" + ref.count + \" for \" + ref.handle\n                );\n            }\n\n            // Anything left?\n            if (ref.count <= 0) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Dropping reference to \" + ref.handle);\n                }\n                myHandleToReference.remove(ref.handle);\n                myObjectToReference.remove(ref.object);\n            }\n        }\n\n        /**\n         * Get the object for a given handle.\n         */", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Dropping reference to \" + ref.handle);\n                }\n                myHandleToReference.remove(ref.handle);\n                myObjectToReference.remove(ref.object);\n            }\n        }\n\n        /**\n         * Get the object for a given handle.\n         */", "        public synchronized Object getObject(final long handle)\n        {\n            final Reference ref = myHandleToReference.get(handle);\n            return (ref == null) ? null : ref.object;\n        }\n\n        /**\n         * Drop all handles.\n         */\n        public synchronized void clear()\n        {\n            myHandleToReference.clear();\n            myObjectToReference.clear();\n        }\n    }\n\n    /**\n     * How we inject classes into a running instance from the outside world.\n     */\n    private static class ClassInjector\n        extends ClassLoader\n    {\n        /**\n         * Inject a new class definition.\n         */\n        public Class<?> inject(final byte[] buffer, final int len)\n            throws ClassFormatError,\n                   IndexOutOfBoundsException,\n                   SecurityException\n        {\n            Class<?> result = defineClass(null, buffer, 0, len);\n            resolveClass(result);\n            return result;\n        }\n    }\n\n    /**\n     * A ByteArrayOutputStream wrapped in a DataOutputStream.\n     */\n    private static class ByteArrayDataOutputStream\n    {\n        /* The ByteArrayOutputStream which is fed by the DataOutputStream. */", "        public synchronized void clear()\n        {\n            myHandleToReference.clear();\n            myObjectToReference.clear();\n        }\n    }\n\n    /**\n     * How we inject classes into a running instance from the outside world.\n     */\n    private static class ClassInjector\n        extends ClassLoader\n    {\n        /**\n         * Inject a new class definition.\n         */\n        public Class<?> inject(final byte[] buffer, final int len)\n            throws ClassFormatError,\n                   IndexOutOfBoundsException,\n                   SecurityException\n        {\n            Class<?> result = defineClass(null, buffer, 0, len);\n            resolveClass(result);\n            return result;\n        }\n    }\n\n    /**\n     * A ByteArrayOutputStream wrapped in a DataOutputStream.\n     */\n    private static class ByteArrayDataOutputStream\n    {\n        /* The ByteArrayOutputStream which is fed by the DataOutputStream. */", "        public final ByteArrayOutputStream bytes   = new ByteArrayOutputStream(1024);\n        public final DataOutputStream      dataOut = new DataOutputStream(bytes);\n\n        /** Sugar method to reset the {@link ByteArrayOutputStream}. */\n        public void reset() { bytes.reset(); }\n    }\n\n    /**\n     * A thread-local instance of the ByteArrayDataOutputStream.\n     */\n    private static class ThreadLocalByteArrayDataOutputStream\n        extends ThreadLocal<ByteArrayDataOutputStream>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public ByteArrayDataOutputStream get()\n        {\n            final  ByteArrayDataOutputStream buffer = super.get();\n            buffer.reset();\n            return buffer;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected ByteArrayDataOutputStream initialValue()\n        {\n            return new ByteArrayDataOutputStream();\n        }\n    }\n\n    /**\n     * A thread with a numeric ID, like what Python doth use.\n     */\n    private interface ThreadId\n    {\n        /**\n         * Get the thread ID associated with this caller.\n         */", "        public long getThreadId();\n    }\n\n    /**\n     * An active connection. This is where most of the logic lives.\n     */\n    private class Connection\n        extends    Thread\n        implements PythonMinion\n    {\n        /**\n         * A worker thread for this connection. Each incoming request gets\n         * handled by a worker so that we never block, even if someone is in the\n         * middle of a call.\n         */\n        private class Worker\n            extends    Thread\n            implements ThreadId\n        {\n            /*\n             * The parameters of what we're working on.\n             */\n            private volatile MessageType      myMessageType = MessageType.NONE;\n            private volatile long             myThreadId    = -1L;\n            private volatile VirtualThread    myThread      = null;\n            private volatile int              myRequestId   = -1;\n            private final    ByteList         myPayload     = new ByteList(1024 * 1024);\n            private volatile DataOutputStream myOut         = null;\n\n            /**\n             * This gets set to false if we are ever done. It is IMPORTANT that\n             * it is never set to false when this thread is in the worker queue,\n             * otherwise you will lose messages.\n             */\n            private volatile boolean myActive = true;\n\n            /**\n             * The sending buffer instance used by this worker thread. This is\n             * used to build up the message which this worker creates via the\n             * receive() calls.\n             */\n            private final ByteArrayDataOutputStream mySendBuf =\n                new ByteArrayDataOutputStream();\n\n            /**\n             * Constructor.\n             */\n            public Worker(String name)\n            {\n                super(name);\n                setDaemon(true);\n            }\n\n            /**\n             * Tell this worker to work.\n             */", "            public void handle(final MessageType      type,\n                               final long             threadId,\n                               final VirtualThread    thread,\n                               final int              reqId,\n                               final ByteList         payload,\n                               final DataOutputStream out)\n            {\n                // Set the params\n                myMessageType = type;\n                myThreadId    = threadId;\n                myThread      = thread;\n                myRequestId   = reqId;\n                myPayload.addAll(payload);\n                myOut         = out;\n\n                // And wake up the thread\n                LockSupport.unpark(this);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public void run()\n            {\n                LOG.fine(\"Worker thread starts\");\n\n                while (myActive) {\n                    // Anything to do?\n                    if (myOut != null) {\n                        work();\n                    }\n                    else {\n                        // Wait for a bit, we might be woken sooner. It seems\n                        // that, in order to be decently responsive, the sleep\n                        // time needs to be small here. (It seems unpark() can\n                        // be slow.)\n                        LockSupport.parkNanos(1000);\n                    }\n                }\n\n                LOG.fine(\"Worker thread stops\");\n            }\n\n            /**\n             * Called when it's time for the thread to die.\n             *\n             * <p>This should <b>NEVER</b> be called if the thread is in the\n             * worker pool. If that happens then you may lose messages.\n             */", "            public void terminate()\n            {\n                myActive = false;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public long getThreadId()\n            {\n                return myThreadId;\n            }\n\n            /**\n             * We've received something to do, so do it;\n             */\n            private void work()\n            {\n                // What we are about to do", "            public long getThreadId()\n            {\n                return myThreadId;\n            }\n\n            /**\n             * We've received something to do, so do it;\n             */\n            private void work()\n            {\n                // What we are about to do", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"ThreadId \" + myThreadId + \":\" + myThread + \" \" +\n                               \"handling \" + myMessageType + \", \" +\n                               \"request ID \" + myRequestId + \": \" +\n                               PJRmi.toString(myPayload));\n                }\n\n                // Time this operation\n                final Instrumentor instr = myInstrumentors[myMessageType.ordinal()];\n                final long start = instr.start();\n\n                // Whether we locked the global lock\n                boolean lockedGlobal = false;\n\n                // Get the sending buffer ready for use\n                mySendBuf.reset();\n\n                // Any exception which we catch below\n                Throwable caught = null;\n\n                // Do all this inside a try-catch since we don't want any form\n                // of failure to take down the thread", "                try {\n                    // First thing to do is to set our virtual thread. (This is\n                    // needed by the LockManager to determine \"who\" is doing the\n                    // locking.)\n                    VirtualThreadLock.setThread(myThread);\n\n                    // Attempt to lock and then handle what we're handling\n                    if (myMessageType.shouldLockFor) {\n                        myLockManager.lockGlobal();\n                        lockedGlobal = true;\n                    }\n\n                    // And actually handle the request\n                    receive(myMessageType,\n                            myThreadId,\n                            myThread,\n                            myRequestId,\n                            myPayload,\n                            mySendBuf,\n                            myOut);\n                }\n                catch (Throwable e) {\n                    // We caught something\n                    caught = e;\n\n                    // Attempt to return everything back to the caller.\n                    // This might be a problem with the connection\n                    // itself, in which case we'll simply bail out at\n                    // the end anyhow (when we try to send the\n                    // exception).", "                    if (LOG.isLoggable(Level.FINE)) {\n                        LOG.fine(\"Encountered exception \" +\n                                 \"when handling \" + myMessageType + \" \" +\n                                 PJRmi.toString(myPayload) + \":\\n\" +\n                                 stackTraceToString(e));\n                    }\n\n                    // What we'll be sending back\n                    final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n\n                    // We'll treat this like a normal object\n                    final TypeDescription exDesc =\n                        myTypeMapping.getDescription(e.getClass());\n                    final long exHandle = myHandleMapping.addReference(e);\n\n                    // Populate with the exception information", "                    try {\n                        bados.dataOut.writeInt (exDesc.getTypeId());\n                        bados.dataOut.writeLong(exHandle);\n                        bados.dataOut.writeInt (-1);\n\n                        // And create it. We will need to reset the send buffer\n                        // here since it might have been partially written to\n                        mySendBuf.reset();\n                        buildMessage(mySendBuf.dataOut,\n                                     MessageType.EXCEPTION,\n                                     myThreadId,\n                                     myRequestId,\n                                     bados.bytes);\n                    }\n                    catch (IOException ioe) {\n                        // This should never happen when writing to a byte\n                        // stream\n                        throw new RuntimeException(\"Should not happen\", ioe);\n                    }\n                }\n                finally {\n                    // Done with the global lock", "                    if (lockedGlobal) {\n                        myLockManager.unlockGlobal();\n                    }\n                    instr.end(start);\n\n                    // Now that we have dropped the lock it's safe to send the\n                    // reply. This is the last thing we need to do as part of\n                    // our work for the client.\n                    try {\n                        send(mySendBuf, myOut);\n                    }\n                    catch (Throwable e) {\n                        // This is probably fine if the other side closed the\n                        // connection. If that happened we'll see an\n                        // EOFException.", "                    try {\n                        send(mySendBuf, myOut);\n                    }\n                    catch (Throwable e) {\n                        // This is probably fine if the other side closed the\n                        // connection. If that happened we'll see an\n                        // EOFException.\n                        if (caught instanceof EOFException) {\n                            LOG.info(\"Looks like the client disconnected: \" + e);\n                        }\n                        else if (caught == null) {\n                            LOG.warning(\"Error when sending: \" + e);\n                        }\n                        else {\n                            LOG.warning(\"Error when sending back \" + caught + \": \" + e);\n                        }\n                    }\n\n                    // Zero out our params\n                    myMessageType = MessageType.NONE;\n                    myRequestId   = -1;\n                    myThreadId    = -1;\n                    myThread      = null;\n                    myPayload.clear();\n                    myOut         = null;\n\n                    // Disassociate\n                    VirtualThreadLock.setThread(null);\n\n                    // If our connection is closed then we should mark ourselves\n                    // as inactive. This is important since the Connection\n                    // thread will drain the myWorker queue to terminate the\n                    // workers and we don't want to add ourselves after that has\n                    // happened (else we will never die).", "                        else if (caught == null) {\n                            LOG.warning(\"Error when sending: \" + e);\n                        }\n                        else {\n                            LOG.warning(\"Error when sending back \" + caught + \": \" + e);\n                        }\n                    }\n\n                    // Zero out our params\n                    myMessageType = MessageType.NONE;\n                    myRequestId   = -1;\n                    myThreadId    = -1;\n                    myThread      = null;\n                    myPayload.clear();\n                    myOut         = null;\n\n                    // Disassociate\n                    VirtualThreadLock.setThread(null);\n\n                    // If our connection is closed then we should mark ourselves\n                    // as inactive. This is important since the Connection\n                    // thread will drain the myWorker queue to terminate the\n                    // workers and we don't want to add ourselves after that has\n                    // happened (else we will never die).", "                    if (Connection.this.isClosed()) {\n                        myActive = false;\n                    }\n\n                    // If we are active then return ourselves to the queue. This\n                    // is a best effort operation.\n                    if (myActive && !myWorkers.offer(this)) {\n                        // We failed to offer ourselves to the queue. This means\n                        // that are done and should pass into that gentle night.\n                        myActive = false;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Thread to handle asynchronous method calls. We have specialised\n         * threads for this since they need to have unique VirtualThread IDs, in\n         * order to respect the locking semantics.\n         */\n        private class MethodCaller\n            extends    Thread\n            implements ThreadId\n        {\n            /**\n             * The (hopefully) globally unique ID of this thread. This should\n             * not clash with that of the Python threads.\n             */\n            private final long myThreadId;\n\n            /**\n             * The VirtualThread, unique to this thread.\n             */\n            private final VirtualThread myThread;\n\n            /**\n             * The {@link Runnable} which we are working for.\n             */\n            private volatile Runnable myRunnable;\n\n            /**\n             * This gets set to false if we are ever done.\n             */\n            private volatile boolean myActive;\n\n            /**\n             * The last time we were invoked, as per {@code System.nanoTime()}.\n             */\n            private long myLastCallNs;\n\n            /**\n             * Constructor.\n             */\n            public MethodCaller()\n            {\n                // Mimic Python for this, kinda. We parse the ID back out of the\n                // thread name so that we are sure to match. We want the thread\n                // IDs to be unique so we use nanotime which, until computers\n                // get _really_ fast, should be different each time it's called.\n                super(\n                    \"MethodCaller:\" +\n                    ((System.nanoTime() ^ THREAD_ID_XOR) & 0x7fffffffffffffffL)\n                );\n                myThreadId   = Long.parseLong(getName().substring(13)); // Erk!\n                myThread     = new VirtualThread(getName());\n                myRunnable   = null;\n                myActive     = true;\n                myLastCallNs = System.nanoTime(); // Kinda...\n                setDaemon(true);\n            }\n\n            /**\n             * Tell this caller to call, using the given runnable. It is\n             * <b>IMPORTANT</b> that the given runnable does not throw an\n             * exception.\n             */", "            public void handle(final Runnable runnable)\n                throws IllegalStateException\n            {\n                // We should not be in the queue if we're working already\n                if (myRunnable != null) {\n                    throw new IllegalStateException(\n                        \"Already working on \" + myRunnable\n                    );\n                }\n\n                // Set the runnable and wake up the thread\n                myRunnable = runnable;\n                LockSupport.unpark(this);\n            }\n\n            /**\n             * Called when it's time for the thread to die.\n             */", "            public void terminate()\n            {\n                myActive = false;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public long getThreadId()\n            {\n                return myThreadId;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public long getThreadId()\n            {\n                return myThreadId;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void run()\n            {\n                LOG.fine(\"MethodCaller thread starts\");\n\n                // We're running, so we associate this thread with the virtual\n                // one. This must be called from within the thread.\n                VirtualThreadLock.setThread(myThread);\n\n                // Now enter the worker loop, working until we're told to stop", "            public void run()\n            {\n                LOG.fine(\"MethodCaller thread starts\");\n\n                // We're running, so we associate this thread with the virtual\n                // one. This must be called from within the thread.\n                VirtualThreadLock.setThread(myThread);\n\n                // Now enter the worker loop, working until we're told to stop\n                while (myActive) {\n                    // Anything to do?", "                while (myActive) {\n                    // Anything to do?\n                    if (myRunnable != null) {\n                        try {\n                            // Invoke the run and note when we did it\n                            myLastCallNs = System.nanoTime();\n                            myRunnable.run();\n                        }\n                        catch (Throwable t) {\n                            // We can't do a lot about this. It's up to the\n                            // caller to construct a runnable which won't throw.\n                            LOG.log(Level.SEVERE,\n                                    \"Runnable threw an exception; \" +\n                                    \"that should ideally never happen\",\n                                    t);\n                        }\n                        finally {\n                            // We're done. Clear out the runnable and return\n                            // ourselves to the queue.\n                            myRunnable = null;\n                            myMethodCallers.offer(this);\n                        }\n                    }\n                    else {\n                        // Wait for at least 1us, and at most 1s, here since\n                        // these threads are long-lived and we don't care _too_\n                        // much about being reactive for asynchronous method\n                        // calls. As time goes on we back off on the wake-up\n                        // period so as not to drain CPU resources. Hopefully\n                        // unpark() will wake us up in _reasonable_ time anyhow.\n                        LockSupport.parkNanos(\n                            Math.min(1_000_000_000L,\n                                     Math.max(1_000L,\n                                              System.nanoTime() - myLastCallNs))\n                        );\n                    }\n                }\n\n                LOG.fine(\"MethodCaller thread stops\");\n            }\n        }\n\n        /**\n         * Our extended version of the {@link PythonPickle} class, which can be\n         * used to instantiate Java objects on the other side.\n         */\n        private class BestEffortPythonPickle\n            extends PythonPickle\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected void saveObject(final Object obj)\n                throws UnsupportedOperationException\n            {\n                // We'll need to know the type and the handle\n                final TypeDescription type =\n                    myTypeMapping.getDescription(\n                        (obj == null) ? Object.class : obj.getClass()\n                    );\n                final long handle = (obj == null)\n                    ? HandleMapping.NULL_HANDLE\n                    : myHandleMapping.addReference(obj);\n\n                // We'll call this method to unmarshall it on the other side\n                // with 3 arguments which are turned into a tuple3 before being\n                // passed to the pjrmi module's function call.\n                saveGlobal (\"pjrmi\", \"_handle_pickle_bytes_create_object\");\n                saveInteger(myPythonId);        // PJRmi instance ID\n                saveInteger(type.getTypeId());  // Type ID\n                saveInteger(handle);            // Object handle\n                write      (Operations.TUPLE3); // Turn those into args\n                write      (Operations.REDUCE); // Call the function\n            }\n        }\n\n        // -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -\n\n        // Python callback support\n\n        /**\n         * How a PythonCallback receives its result.\n         */\n        private class PythonCallbackResult\n        {\n            /**\n             * The thread which is receiving the callback.\n             */\n            private final Thread myReceiver;\n\n            /**\n             * What is received.\n             */\n            private volatile Object myResult;\n\n            /**\n             * Whether myResult is an exception to be thrown.\n             */\n            private volatile boolean myIsException;\n\n            /**\n             * Whether myResult is ready for reading.\n             */\n            private volatile boolean myReady;\n\n            /**\n             * Constructor.\n             */\n            public PythonCallbackResult(final Thread receiver)\n            {\n                myReceiver = receiver;\n                myResult   = null;\n                myReady    = false;\n            }\n\n            /**\n             * Set the result.\n             */", "            public void setResult(final boolean isException, final Object result)\n            {\n                myResult      = result;\n                myIsException = isException;\n                myReady       = true;\n                LockSupport.unpark(myReceiver);\n            }\n\n            /**\n             * Whether the result is ready.\n             */", "            public boolean isReady()\n            {\n                return myReady;\n            }\n\n            /**\n             * Whether the result is an exception to be thrown\n             */\n            public boolean isException()\n            {\n                return myIsException;\n            }\n\n            /**\n             * Get the result\n             */", "            public boolean isException()\n            {\n                return myIsException;\n            }\n\n            /**\n             * Get the result\n             */\n            public Object getResult()\n            {\n                return myResult;\n            }\n        }\n\n        /**\n         * A callback into Python from Java.\n         */\n        private abstract class PythonCallback<T>\n            implements PythonKwargsFunction<T>\n        {\n            /**\n             * The Python ID of the function.\n             */\n            private final int myFunctionId;\n\n            /**\n             * How we send the message to Python.\n             */\n            private final DataOutputStream myOut;\n\n            /**\n             * Constructor.\n             */\n            public PythonCallback(final int functionId,\n                                  final DataOutputStream out)\n            {\n                myFunctionId = functionId;\n                myOut = out;\n            }\n\n            /**\n             * The type description of this function. This should be the public\n             * interface, not the implementation.\n             */", "            public Object getResult()\n            {\n                return myResult;\n            }\n        }\n\n        /**\n         * A callback into Python from Java.\n         */\n        private abstract class PythonCallback<T>\n            implements PythonKwargsFunction<T>\n        {\n            /**\n             * The Python ID of the function.\n             */\n            private final int myFunctionId;\n\n            /**\n             * How we send the message to Python.\n             */\n            private final DataOutputStream myOut;\n\n            /**\n             * Constructor.\n             */\n            public PythonCallback(final int functionId,\n                                  final DataOutputStream out)\n            {\n                myFunctionId = functionId;\n                myOut = out;\n            }\n\n            /**\n             * The type description of this function. This should be the public\n             * interface, not the implementation.\n             */", "            public abstract TypeDescription getType();\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public T invoke(final Map<String,Object> kwargs,\n                            final Object...          args)\n                throws Throwable\n            {\n                return doInvoke(kwargs, args);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public String toString()\n            {\n                return getClass().getSimpleName() + \"#\" + myFunctionId;\n            }\n\n            /**\n             * How we make the call. This sends a message over to the Python\n             * side which should hopefully be picked up.\n             */\n            protected T doInvoke(final Map<String,Object> kwargs,\n                                 final Object...          args)\n                throws IOException,\n                       PythonCallbackException\n            {\n                // Say we're doing it", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Invoking \" + this + \" \" +\n                               \"with args \" + Arrays.toString(args));\n                }\n\n                // Figure out our thread ID\n                final Thread thread = Thread.currentThread();\n                final long threadId = (thread instanceof ThreadId)\n                    ? ((ThreadId)thread).getThreadId()\n                    : -1;\n\n                // The python callback request ID\n                final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                // Build the data to make the call\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeInt(requestId);\n                bados.dataOut.writeInt(myFunctionId);", "                if (args == null) {\n                    bados.dataOut.writeInt(0);\n                }\n                else {\n                    bados.dataOut.writeInt(args.length);\n                    for (Object arg : args) {\n                        writeArgument(bados.dataOut, arg);\n                    }\n                }\n\n                // The number of keyword arguments", "                if (kwargs == null) {\n                    bados.dataOut.writeInt(0);\n                }\n                else {\n                    bados.dataOut.writeInt(kwargs.size());\n                    for (Map.Entry<String,Object> entry : kwargs.entrySet()) {\n                        // Write name and argument\n                        writeUTF16   (bados.dataOut, entry.getKey());\n                        writeArgument(bados.dataOut, entry.getValue());\n                    }\n                }\n\n                // Register ourselves for the callback\n                final PythonCallbackResult result = new PythonCallbackResult(thread);\n                myPythonCallbackResults.put(requestId, result);\n\n                // Send the request over", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Calling back to Python with thread ID \" + threadId + \" \" +\n                        \"and Java request ID \" + requestId\n                    );\n                }\n                sendMessage(myOut,\n                            MessageType.CALLBACK,\n                            threadId,\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n\n                // Now wait for the result\n                return awaitCallbackReponse(result);\n            }\n        }\n\n        /**\n         * A Runnable implemented using a PythonCallback.\n         */\n        private class PythonCallbackRunnable\n            extends PythonCallback<Object>\n            implements Runnable\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackRunnable(final int functionId,\n                                          final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(Runnable.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void run()\n            {", "            public void run()\n            {\n                try {\n                    invoke();\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A UnaryOperator implemented using a PythonCallback.\n         */\n        private class PythonCallbackUnaryOperator<T>\n            extends PythonCallback<T>\n            implements UnaryOperator<T>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackUnaryOperator(final int functionId,\n                                               final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(UnaryOperator.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public T apply(T arg)\n            {", "            public T apply(T arg)\n            {\n                try {\n                    return invoke(arg);\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A Function implemented using a PythonCallback.\n         */\n        private class PythonCallbackFunction<T,R>\n            extends PythonCallback<R>\n            implements Function<T,R>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackFunction(final int functionId,\n                                          final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(Function.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public R apply(T arg)\n            {", "            public R apply(T arg)\n            {\n                try {\n                    return invoke(arg);\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A BiFunction implemented using a PythonCallback.\n         */\n        private class PythonCallbackBiFunction<T,R,U>\n            extends PythonCallback<R>\n            implements BiFunction<T,U,R>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackBiFunction(final int functionId,\n                                            final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(BiFunction.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public R apply(T arg1, U arg2)\n            {", "            public R apply(T arg1, U arg2)\n            {\n                try {\n                    return invoke(arg1, arg2);\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A Consumer implemented using a PythonCallback.\n         */\n        private class PythonCallbackConsumer<T>\n            extends PythonCallback<Object>\n            implements Consumer<T>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackConsumer(final int functionId,\n                                          final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(Consumer.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void accept(T arg)\n            {", "            public void accept(T arg)\n            {\n                try {\n                    invoke(arg);\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A BiConsumer implemented using a PythonCallback.\n         */\n        private class PythonCallbackBiConsumer<T,U>\n            extends PythonCallback<Object>\n            implements BiConsumer<T,U>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackBiConsumer(final int functionId,\n                                            final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(BiConsumer.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void accept(T arg1, U arg2)\n            {", "            public void accept(T arg1, U arg2)\n            {\n                try {\n                    invoke(arg1, arg2);\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * A Predicate implemented using a PythonCallback.\n         */\n        private class PythonCallbackPredicate<T>\n            extends PythonCallback<Object>\n            implements Predicate<T>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackPredicate(final int functionId,\n                                           final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(Predicate.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public boolean test(T arg)\n            {", "            public boolean test(T arg)\n            {\n                try {\n                    // We'll try to keep the same semantics that we expect in\n                    // Python given various types\n                    final Object result = invoke(arg);\n                    if (result instanceof Boolean) {\n                        return ((Boolean)result).booleanValue();\n                    }\n                    else if (result instanceof String) {\n                        return !((String)result).isEmpty();\n                    }", "                    else if (result instanceof String) {\n                        return !((String)result).isEmpty();\n                    }\n                    else if (result instanceof Number) {\n                        return ((Number)result).doubleValue() != 0.0;\n                    }\n                    else {\n                        return (result != null);\n                    }\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n\n        /**\n         * A BiPredicate implemented using a PythonCallback.\n         */\n        private class PythonCallbackBiPredicate<T,U>\n            extends PythonCallback<Object>\n            implements BiPredicate<T,U>\n        {\n            /**\n             * Constructor.\n             */\n            public PythonCallbackBiPredicate(final int functionId,\n                                             final DataOutputStream out)\n            {\n                super(functionId, out);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public TypeDescription getType()\n            {\n                return myTypeMapping.getDescription(BiPredicate.class);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public boolean test(T arg1, U arg2)\n            {", "            public boolean test(T arg1, U arg2)\n            {\n                try {\n                    // We'll try to keep the same semantics that we expect in\n                    // Python given various types\n                    final Object result = invoke(arg1, arg2);\n                    if (result instanceof Boolean) {\n                        return ((Boolean)result).booleanValue();\n                    }\n                    else if (result instanceof String) {\n                        return !((String)result).isEmpty();\n                    }", "                    else if (result instanceof String) {\n                        return !((String)result).isEmpty();\n                    }\n                    else if (result instanceof Number) {\n                        return ((Number)result).doubleValue() != 0.0;\n                    }\n                    else {\n                        return (result != null);\n                    }\n                }\n                catch (PythonCallbackException e) {\n                    throw new RuntimeException(\"Failed to invoke callback\",\n                                               e.getCause());\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\"Failed to invoke callback\", t);\n                }\n            }\n        }\n\n        /**\n         * The invocation handler for calling a single Python function as a Java\n         * lambda.\n         */\n        private class PythonLambdaHandler\n            implements InvocationHandler\n        {\n            /**\n             * The name of the method which is being handled.\n             */\n            private final String myMethodName;\n\n            /**\n             * The Python ID of the function.\n             */\n            private final int myFunctionId;\n\n            /**\n             * How we send the message to Python.\n             */\n            private final DataOutputStream myOut;\n\n            /**\n             * Constructor.\n             */\n            public PythonLambdaHandler(final String methodName,\n                                       final int functionId,\n                                       final DataOutputStream out)\n            {\n                myMethodName = methodName;\n                myFunctionId = functionId;\n                myOut = out;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public Object invoke(final Object proxy,\n                                 final Method method,\n                                 final Object[] args)\n                throws Throwable\n            {\n                // Say we're doing it\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Invoking lambda method \" + method + \" \" +\n                               \"with args \" + Arrays.toString(args));\n                }\n\n                // Handle Object methods specially\n                switch (method.getName()) {\n                case \"equals\": {\n                    final Object that = (args.length == 2) ? args[1] : null;", "                    if (that instanceof PythonLambdaHandler) {\n                        final PythonLambdaHandler plh = (PythonLambdaHandler)that;\n                        return (plh.myMethodName.equals(myMethodName) &&\n                                plh.myFunctionId == myFunctionId);\n                    }\n                    else {\n                        return false;\n                    }\n                }\n\n                case \"getClass\":\n                    return super.getClass();\n\n                case \"hashCode\":\n                    return (myFunctionId ^ myMethodName.hashCode());\n\n                case \"notify\":\n                    super.notify();\n                    return null;\n\n                case \"notifyAll\":\n                    super.notifyAll();\n                    return null;\n\n                case \"toString\":\n                    return \"PythonLambda<\" + myMethodName + \"()>\";\n\n                case \"wait\":\n                    super.wait();\n                    return null;\n                }\n\n                // Is this a default method? If so then fall back to the\n                // interface implementation", "                if (method.isDefault()) {\n                    // Need to jump through some ugly hoops to allow\n                    // \"private\" access to the method here\n                    final Class<?> klass = method.getDeclaringClass();\n                    final Lookup lookup = MethodHandles.lookup().in(klass);\n                    final Field allowedModes =\n                        Lookup.class.getDeclaredField(\"allowedModes\");\n                    allowedModes.setAccessible(true);\n                    allowedModes.set(lookup, Modifier.PRIVATE);\n                    return lookup.unreflectSpecial(method, klass)\n                                 .bindTo(proxy)\n                                 .invokeWithArguments(args);\n                }", "                else if (myMethodName.equals(method.getName())) {\n                    // Figure out our thread ID\n                    final Thread thread = Thread.currentThread();\n                    final long threadId = (thread instanceof ThreadId)\n                        ? ((ThreadId)thread).getThreadId()\n                        : -1;\n\n                    // The python callback request ID\n                    final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                    // Build the data to make the call\n                    final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                    bados.dataOut.writeInt(requestId);\n                    bados.dataOut.writeInt(myFunctionId);", "                    if (args == null) {\n                        bados.dataOut.writeInt(0);\n                    }\n                    else {\n                        bados.dataOut.writeInt(args.length);\n                        for (Object arg : args) {\n                            writeArgument(bados.dataOut, arg);\n                        }\n                    }\n\n                    // No kwargs\n                    bados.dataOut.writeInt(0);\n\n                    // Register ourselves for the callback\n                    final PythonCallbackResult result = new PythonCallbackResult(thread);\n                    myPythonCallbackResults.put(requestId, result);\n\n                    // Send the request over", "                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\n                            \"Calling back to Python with thread ID \" + threadId + \" \" +\n                            \"and Java request ID \" + requestId\n                        );\n                    }\n                    sendMessage(myOut,\n                                MessageType.CALLBACK,\n                                threadId,\n                                CALLBACK_REQUEST_ID,\n                                bados.bytes);\n\n                    // Now wait for the result\n                    return awaitCallbackReponse(result);\n                }\n                else {\n                    // We don't know how to handle this. This isn't really\n                    // expected given that we should be constructed in such a\n                    // fashion as to only be working for one, non-default,\n                    // method so we'll just throw here.\n                    throw new IllegalArgumentException(\n                        \"Don't know how to handle call to \" + method\n                    );\n                }\n            }\n        }\n\n        /**\n         * The invocation handler for calling methods on a Python object being\n         * proxied by a Java one. This allows for duck-typing of Java\n         * interfaces.\n         */\n        private class PythonProxyHandler\n            implements InvocationHandler\n        {\n            /**\n             * The Python ID of the object.\n             */\n            private final int myObjectId;\n\n            /**\n             * How we send the message to Python.\n             */\n            private final DataOutputStream myOut;\n\n            /**\n             * Constructor.\n             */\n            public PythonProxyHandler(final int objectId,\n                                      final DataOutputStream out)\n                throws IOException\n            {\n                // Init members\n                myObjectId = objectId;\n                myOut = out;\n\n                // Tell Python that we are adding a reference\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeLong(myObjectId);\n                sendMessage(myOut,\n                            MessageType.ADD_REFERENCE,\n                            -1, // Thread ID\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public Object invoke(final Object proxy,\n                                 final Method method,\n                                 final Object[] args)\n                throws Throwable\n            {\n                // Say we're doing it\n                if (LOG.isLoggable(Level.FINEST)) {\n                    final String argString;\n                    if (args == null) {\n                        argString = \"<null>\";\n                    }\n                    else {\n                        // Turn the array of arguments into a string of\n                        // <type:value> pairs\n                        StringBuilder sb = new StringBuilder(\"[\");", "                    if (args == null) {\n                        argString = \"<null>\";\n                    }\n                    else {\n                        // Turn the array of arguments into a string of\n                        // <type:value> pairs\n                        StringBuilder sb = new StringBuilder(\"[\");\n                        for (int i=0; i < args.length; i++) {\n                            if (i > 0) {\n                                sb.append(\", \");\n                            }\n                            final Object arg = args[i];", "                            if (i > 0) {\n                                sb.append(\", \");\n                            }\n                            final Object arg = args[i];\n                            if (arg == null) {\n                                sb.append(\"<null>\");\n                            }\n                            else {\n                                sb.append(arg.getClass())\n                                  .append(':')\n                                  .append(arg);\n                            }\n                        }\n                        sb.append(']');\n                        argString = sb.toString();\n                    }\n                    LOG.finest(\"Invoking proxy \" + method + \" \" +\n                               \"on \" + toLocalString() + \" \" +\n                               \"with args \" + argString);\n                }\n\n                // Special case: If this is an equals method with one argument\n                // which is another proxy then we need to see if it's being\n                // called with this proxy as the argument.", "                if (\"equals\".equals(method.getName()) &&\n                    args        != null               &&\n                    args.length == 1                  &&\n                    args[0] instanceof Proxy)\n                {\n                    final InvocationHandler handler = Proxy.getInvocationHandler(args[0]);\n                    if (handler instanceof PythonProxyHandler) {\n                        final PythonProxyHandler that = (PythonProxyHandler)handler;\n                        if (LOG.isLoggable(Level.FINEST)) {\n                            LOG.finest(\n                                \"Handling call of equals(\" + that.toLocalString() + \")\"\n                            );\n                        }\n                        return this.myObjectId == that.myObjectId;\n                    }\n                }\n\n                // Figure out our thread ID\n                final Thread thread = Thread.currentThread();\n                final long threadId = (thread instanceof ThreadId)\n                    ? ((ThreadId)thread).getThreadId()\n                    : -1;\n\n                // The python callback request ID\n                final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                // Build the data to make the call\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeInt(requestId);\n                bados.dataOut.writeInt(myObjectId);\n                bados.dataOut.writeInt(myTypeMapping.getId(method.getReturnType()));\n                writeUTF16            (bados.dataOut, method.getName());\n\n                // Handle any arguments", "                        if (LOG.isLoggable(Level.FINEST)) {\n                            LOG.finest(\n                                \"Handling call of equals(\" + that.toLocalString() + \")\"\n                            );\n                        }\n                        return this.myObjectId == that.myObjectId;\n                    }\n                }\n\n                // Figure out our thread ID\n                final Thread thread = Thread.currentThread();\n                final long threadId = (thread instanceof ThreadId)\n                    ? ((ThreadId)thread).getThreadId()\n                    : -1;\n\n                // The python callback request ID\n                final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                // Build the data to make the call\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeInt(requestId);\n                bados.dataOut.writeInt(myObjectId);\n                bados.dataOut.writeInt(myTypeMapping.getId(method.getReturnType()));\n                writeUTF16            (bados.dataOut, method.getName());\n\n                // Handle any arguments", "                if (args == null) {\n                    bados.dataOut.writeInt(0);\n                }\n                else {\n                    bados.dataOut.writeInt(args.length);\n                    for (Object arg : args) {\n                        writeArgument(bados.dataOut, arg);\n                    }\n                }\n\n                // No kwargs\n                bados.dataOut.writeInt(0);\n\n                // Register ourselves for the callback\n                final PythonCallbackResult result = new PythonCallbackResult(thread);\n                myPythonCallbackResults.put(requestId, result);\n\n                // Send the request over", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Calling back to Python with thread ID \" + threadId + \" \" +\n                        \"and Java request ID \" + requestId\n                    );\n                }\n                sendMessage(myOut,\n                            MessageType.OBJECT_CALLBACK,\n                            threadId,\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n", "                try {\n                    // Now wait for the result\n                    return awaitCallbackReponse(result);\n                }\n                catch (PythonCallbackException e) {\n                    // Fall back to any default implementation if we failed to\n                    // find the method\n                    if (e.getCause() instanceof NoSuchMethodException &&\n                        method.isDefault())\n                    {\n                        // Need to jump through some ugly hoops to allow\n                        // \"private\" access to the method here\n                        final Class<?> klass = method.getDeclaringClass();\n                        final Lookup lookup = MethodHandles.lookup().in(klass);\n                        final Field allowedModes =\n                            Lookup.class.getDeclaredField(\"allowedModes\");\n                        allowedModes.setAccessible(true);\n                        allowedModes.set(lookup, Modifier.PRIVATE);\n                        return lookup.unreflectSpecial(method, klass)\n                                     .bindTo(proxy)\n                                     .invokeWithArguments(args);\n                    }\n\n                    // Rethrow if we got here\n                    throw e;\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            @SuppressWarnings(\"deprecation\")\n            protected void finalize()\n                throws Throwable\n            {", "                try {\n                    // Tell Python that it can forget about this object now\n                    final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                    bados.dataOut.writeInt(1);\n                    bados.dataOut.writeLong(myObjectId);\n                    sendMessage(myOut,\n                                MessageType.DROP_REFERENCES,\n                                -1, // Thread ID\n                                CALLBACK_REQUEST_ID,\n                                bados.bytes);\n                }\n                finally {\n                    super.finalize();\n                }\n            }\n\n            /**\n             * The Object ID.\n             */\n            private int getId()\n            {\n                return myObjectId;\n            }\n\n            /**\n             * Get our local toString() representation.\n             */\n            private String toLocalString()\n            {\n                return getClass().getSimpleName() + \"[\" + getId() + \"]\";\n            }\n        }\n\n        /**\n         * A wrapper around an object sitting in the Python interpreter. This\n         * should be the only implementation of PythonObject.\n         */\n        private class PythonObjectImpl\n            extends PythonObject\n        {\n            /**\n             * The name of the object.\n             */\n            private final String myName;\n\n            /**\n             * The ID of the object we represent.\n             */\n            private final int myObjectId;\n\n            /**\n             * How we send the message to Python.\n             */\n            private final DataOutputStream myOut;\n\n            /**\n             * Constructor.\n             */\n            private PythonObjectImpl(final String           name,\n                                     final int              objectId,\n                                     final DataOutputStream out)\n                throws IOException\n            {\n                // Init members\n                myName     = name;\n                myObjectId = objectId;\n                myOut      = out;\n\n                // Tell Python that we are adding a reference\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeLong(myObjectId);\n                sendMessage(myOut,\n                            MessageType.ADD_REFERENCE,\n                            -1, // Thread ID\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public <T> T invoke(final Class<T>           returnType,\n                                final String             methodName,\n                                final Map<String,Object> kwargs,\n                                final Object...          args)\n                throws Throwable\n            {\n                // Say we're doing it", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Invoking \" + returnType + \" \" + methodName + \"(\" +\n                            \"args=\"   + Arrays.toString(args) + \", \" +\n                            \"kawrgs=\" + kwargs +\n                        \")\"\n                    );\n                }\n\n                // Figure out our thread ID\n                final Thread thread = Thread.currentThread();\n                final long threadId = (thread instanceof ThreadId)\n                    ? ((ThreadId)thread).getThreadId()\n                    : -1;\n\n                // The python callback request ID\n                final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                // The ID of the return type. If it's null then just use\n                // PythonObject to give back another wrapper instance. Most\n                // likely it will just be thrown away anyhow. (Possibly we could\n                // use Void here so as to force nothing/null to be returned.)\n                final int returnTypeId =\n                    myTypeMapping.getId((returnType == null) ? PythonObject.class :\n                                                               returnType);\n\n                // Build the data to make the call\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeInt(requestId);\n                bados.dataOut.writeInt(myObjectId);\n                bados.dataOut.writeInt(returnTypeId);\n                writeUTF16            (bados.dataOut, methodName);\n\n                // Handle any arguments", "                if (args == null) {\n                    bados.dataOut.writeInt(0);\n                }\n                else {\n                    bados.dataOut.writeInt(args.length);\n                    for (Object arg : args) {\n                        writeArgument(bados.dataOut, arg);\n                    }\n                }\n\n                // The number of keyword arguments", "                if (kwargs == null) {\n                    bados.dataOut.writeInt(0);\n                }\n                else {\n                    bados.dataOut.writeInt(kwargs.size());\n                    for (Map.Entry<String,Object> entry : kwargs.entrySet()) {\n                        // Write name and argument\n                        writeUTF16   (bados.dataOut, entry.getKey());\n                        writeArgument(bados.dataOut, entry.getValue());\n                    }\n                }\n\n                // Register ourselves for the callback\n                final PythonCallbackResult result = new PythonCallbackResult(thread);\n                myPythonCallbackResults.put(requestId, result);\n\n                // Send the request over", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Calling back to Python with thread ID \" + threadId + \" \" +\n                        \"and Java request ID \" + requestId\n                    );\n                }\n                sendMessage(myOut,\n                            MessageType.OBJECT_CALLBACK,\n                            threadId,\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n\n                // Now wait for the result\n                return awaitCallbackReponse(result);\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public <T> T getattr(final Class<T> fieldType,\n                                 final String   fieldName)\n                throws Throwable\n            {\n                // Say we're doing it", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Getting field \" + fieldName + \" as a \" + fieldType);\n                }\n\n                // Figure out our thread ID\n                final Thread thread = Thread.currentThread();\n                final long threadId = (thread instanceof ThreadId)\n                    ? ((ThreadId)thread).getThreadId()\n                    : -1;\n\n                // The python callback request ID\n                final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n                // The ID of the field type. If it's null then just use\n                // PythonObject to give back another wrapper instance.\n                final int fieldTypeId =\n                    myTypeMapping.getId((fieldType == null) ? PythonObject.class :\n                                                              fieldType);\n\n                // Build the data to make the call\n                final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                bados.dataOut.writeInt(requestId);\n                bados.dataOut.writeInt(myObjectId);\n                bados.dataOut.writeInt(fieldTypeId);\n                writeUTF16            (bados.dataOut, fieldName);\n\n                // Register ourselves for the callback\n                final PythonCallbackResult result = new PythonCallbackResult(thread);\n                myPythonCallbackResults.put(requestId, result);\n\n                // Send the request over", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Calling back to Python with thread ID \" + threadId + \" \" +\n                        \"and Java request ID \" + requestId\n                    );\n                }\n                sendMessage(myOut,\n                            MessageType.GETATTR,\n                            threadId,\n                            CALLBACK_REQUEST_ID,\n                            bados.bytes);\n\n                // Now wait for the result", "                try {\n                    return awaitCallbackReponse(result);\n                }\n                catch (PythonCallbackException e) {\n                    throw e.getCause();\n                }\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <T> T asProxy(final Class<T> klass)\n                throws IOException\n            {\n                return (T) Proxy.newProxyInstance(\n                    klass.getClassLoader(),\n                    new Class<?>[] { klass },\n                    new PythonProxyHandler(myObjectId, myOut)\n                );\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public String toString()\n            {\n                try {\n                    // Attempt to get Python's str representation\n                    return invoke(String.class, \"__str__\");\n                }\n                catch (Throwable t) {\n                    // Fall back to the name\n                    return myName;\n                }\n            }\n\n            /**\n             * The Object ID.\n             */\n            protected int getId()\n            {\n                return myObjectId;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            @SuppressWarnings(\"deprecation\")\n            protected void finalize()\n                throws Throwable\n            {", "                try {\n                    // Tell Python that it can forget about this object now\n                    final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n                    bados.dataOut.writeInt(1);\n                    bados.dataOut.writeLong(myObjectId);\n                    sendMessage(myOut,\n                                MessageType.DROP_REFERENCES,\n                                -1, // Thread ID\n                                CALLBACK_REQUEST_ID,\n                                bados.bytes);\n                }\n                finally {\n                    super.finalize();\n                }\n            }\n        }\n\n        // --------------------------------------------------------------------\n\n        /**\n         * Set to false when we are terminating.\n         */\n        private volatile boolean myIsActive;\n\n        /**\n         * The transport.\n         */\n        private final Transport myTransport;\n\n        /**\n         * The Python instance's ID.\n         */\n        private final long myPythonId;\n\n        /**\n         * Where data comes in.\n         */\n        private final DataInputStream myIn;\n\n        /**\n         * Where data goes out.\n         */\n        private final DataOutputStream myOut;\n\n        /**\n         * Our per-thread PythonPicklers, for converting values to Python's\n         * pickle format in a best-effort fashion.\n         */\n        private final ThreadLocal<PythonPickle> myBestEffortPythonPickle;\n\n        /**\n         * Our object handle mappings.\n         */\n        private final HandleMapping myHandleMapping;\n\n        /**\n         * Our workers, if any. This will be null if useWorkers() is false.\n         */\n        private final BlockingQueue<Worker> myWorkers;\n\n        /**\n         * Our method callers.\n         */\n        private final BlockingQueue<MethodCaller> myMethodCallers;\n\n        /**\n         * The mapping from virtual thread ID to a virtual Java Thread. Only\n         * needed (non-null) if we have workers.\n         */\n        private Map<Long,VirtualThread> myVirtualThreads;\n\n        /**\n         * How many workers we have created; used for naming.\n         */\n        private int myNumWorkers;\n\n        /**\n         * The next request ID for making Python callbacks over this connection.\n         */\n        private final AtomicInteger myPythonCallbackRequestId = new AtomicInteger();\n\n        /**\n         * The map used to receive python callback results.\n         */\n        private final Map<Integer,PythonCallbackResult> myPythonCallbackResults =\n            new ConcurrentHashMap<>();\n\n        /**\n         * The \"depth\" into the call stack. This is to spot cases where we are\n         * calling from Java to Python to Java to Python ad infinitum.\n         */\n        private int myCallDepth;\n\n        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n        /**\n         * CTOR.\n         */\n        public Connection(final String name,\n                          final Transport transport,\n                          final long pythonId)\n            throws IOException\n        {\n            super(name);\n\n            myTransport = transport;\n            myPythonId = pythonId;\n\n            // We are active from the get-go\n            myIsActive = true;\n\n            // Set up the streams. It's important that we use a buffered output\n            // stream for myOut since this will send the responses as a single\n            // packet and this _greatly_ speeds up the way the clients work.\n            // The 64k value is the usual MTU and should be way bigger than\n            // anything we will end up sending.\n            final InputStream  inStream  = transport.getInputStream();\n            final OutputStream outStream = transport.getOutputStream();\n            myIn = (inStream instanceof DataInputStream) ?\n                (DataInputStream)inStream : new DataInputStream(inStream);\n            myOut =\n                new DataOutputStream(\n                    new BufferedOutputStream(outStream, 65536)\n                );\n\n            // How we render with pickle in a best-effort fashion\n            myBestEffortPythonPickle =\n                ThreadLocal.withInitial(BestEffortPythonPickle::new);\n\n            // Try to ensure that all the handles have a reasonably unique\n            // identifier\n            myHandleMapping =\n                new HandleMapping(hashCode() & (int)System.nanoTime());\n\n            // Where our workers, if any, live etc", "            if (useWorkers()) {\n                myWorkers        = new ArrayBlockingQueue<>(numWorkers());\n                myVirtualThreads = new HashMap<>();\n            }\n            else {\n                myWorkers        = null;\n                myVirtualThreads = null;\n            }\n            myNumWorkers = 0;\n\n            // Unbounded queue of these since we want them to be long-lived\n            myMethodCallers = new LinkedBlockingQueue<>();\n\n            // The depth of our stack\n            myCallDepth = 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void run()\n        {\n            LOG.info(\"Started handler thread: \" + this);\n\n            try {\n                // Listen until there is nothing else to hear\n                listen();\n            }\n            finally {\n                // Be nice to the GC\n                myHandleMapping.clear();\n\n                // Drop any locks, if we are holding them", "                try {\n                    myLockManager.dropAllThreadLocks();\n                }\n                catch (IllegalArgumentException e) {\n                    // This is fine but log when debugging\n                    LOG.fine(\"Problem dropping locks: \" + e);\n                }\n\n                // Ensure the underlying connection is closed so that the other\n                // side won't hang forever etc.\n                try {\n                    myTransport.close();\n                }\n                catch (Throwable t) {\n                    // Nothing\n                }\n            }\n\n            // Mark ourselves as inactive. We should do this before killing off\n            // the workers so that none of them attempt to insert themselves\n            // into the queue as we terminate them. See the Worker#work()\n            // method.\n            myIsActive = false;\n\n            // If we have worker threads then close them down", "                try {\n                    myTransport.close();\n                }\n                catch (Throwable t) {\n                    // Nothing\n                }\n            }\n\n            // Mark ourselves as inactive. We should do this before killing off\n            // the workers so that none of them attempt to insert themselves\n            // into the queue as we terminate them. See the Worker#work()\n            // method.\n            myIsActive = false;\n\n            // If we have worker threads then close them down", "            if (myWorkers != null) {\n                LOG.fine(\"Terminating workers\");\n                for (Worker worker = myWorkers.poll();\n                     worker != null;\n                     worker = myWorkers.poll())\n                {\n                    worker.terminate();\n                }\n            }\n            LOG.fine(\"Terminating method callers\");\n            for (MethodCaller caller = myMethodCallers.poll();\n                 caller != null;\n                 caller = myMethodCallers.poll())\n            {\n                caller.terminate();\n            }\n\n            LOG.info(\"Exiting handler thread: \" + this);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public <T> T eval(final String string, final Class<T> returnType)\n            throws ClassCastException,\n                   IOException,\n                   PythonCallbackException\n        {\n            return evalOrExec(true, string, returnType);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "            for (MethodCaller caller = myMethodCallers.poll();\n                 caller != null;\n                 caller = myMethodCallers.poll())\n            {\n                caller.terminate();\n            }\n\n            LOG.info(\"Exiting handler thread: \" + this);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public <T> T eval(final String string, final Class<T> returnType)\n            throws ClassCastException,\n                   IOException,\n                   PythonCallbackException\n        {\n            return evalOrExec(true, string, returnType);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void exec(final String string)\n            throws IOException,\n                   PythonCallbackException\n        {\n            try {\n                evalOrExec(false, string, Object.class);\n            }\n            catch (ClassCastException e) {\n                // Shouldn't happen\n                throw new AssertionError(\"Unexpected error\", e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void setGlobalVariable(final String name, final Object value)\n            throws IOException,\n                   PythonCallbackException\n        {\n            // We need a name\n            if (name == null || name.isEmpty()) {\n                throw new IllegalArgumentException(\"Empty name given\");\n            }\n\n            // The python callback request ID\n            final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n            // Build the data to make the call\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(requestId);\n\n            // What name for the variable\n            writeUTF16(bados.dataOut, name);\n\n            // Send the value we're setting by reference, as an \"argument\".\n            // (It's sort of an argument to the set function. Sort of...)\n            final TypeDescription type =\n                myTypeMapping.getDescription(\n                    (value == null) ? Object.class : value.getClass()\n                );\n            bados.dataOut.writeByte(PythonValueFormat.REFERENCE.id);\n            writeObject(bados.dataOut, value, type);\n\n            // Figure out our thread ID\n            final Thread thread = Thread.currentThread();\n            final long threadId = (thread instanceof ThreadId)\n                ? ((ThreadId)thread).getThreadId()\n                : -1;\n\n            // Register ourselves for the callback\n            final PythonCallbackResult result = new PythonCallbackResult(this);\n            myPythonCallbackResults.put(requestId, result);\n\n            // Send the request over", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Setting global variable \" + name + \" \" +\n                    \"to value \" + value + \" \" +\n                    \"with request ID \" + requestId + \" \" +\n                    \"from Java thread ID \" + threadId\n                );\n            }\n            sendMessage(myOut,\n                        MessageType.SET_GLOBAL_VARIABLE,\n                        threadId,\n                        CALLBACK_REQUEST_ID,\n                        bados.bytes);\n\n            // Now wait for the result, might be null or an exception\n            awaitCallbackReponse(result);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public <T> T invoke(final String    functionName,\n                            final Class<T>  returnType,\n                            final Object... args)\n            throws ClassCastException,\n                   IOException,\n                   PythonCallbackException\n        {\n            // The python callback request ID\n            final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n            // Get the thread ID\n            final long threadId = getThreadId();\n\n            // Build the data to make the call\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(requestId);\n            bados.dataOut.writeInt(myTypeMapping.getId(returnType));\n            writeUTF16(bados.dataOut, functionName);", "            if (args == null) {\n                bados.dataOut.writeInt(0);\n            }\n            else {\n                bados.dataOut.writeInt(args.length);\n                for (Object arg : args) {\n                    writeArgument(bados.dataOut, arg);\n                }\n            }\n\n            // Register ourselves for the callback\n            final PythonCallbackResult result = new PythonCallbackResult(this);\n            myPythonCallbackResults.put(requestId, result);\n\n            // Send the request over", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Sending invocation of \" + functionName + \" \" +\n                    \"to Python with thread ID \" + threadId + \" \" +\n                    \"and Java request ID \" + requestId\n                );\n            }\n            sendMessage(myOut,\n                        MessageType.PYTHON_INVOKE,\n                        threadId,\n                        CALLBACK_REQUEST_ID,\n                        bados.bytes);\n\n            // Now wait for the result\n            return awaitCallbackReponse(result);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public PythonObject getObject(final String string,\n                                      final String name)\n            throws Throwable\n        {\n            // The python callback request ID\n            final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n            // Get the thread ID\n            final long threadId = getThreadId();\n\n            // Build the data to make the call\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(requestId);\n            writeUTF16(bados.dataOut, string);\n\n            // Register ourselves for the callback\n            final PythonCallbackResult result = new PythonCallbackResult(this);\n            myPythonCallbackResults.put(requestId, result);\n\n            // Send the request over", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Sending object request to Python with thread ID \" +\n                    threadId + \" and Java request ID \" + requestId\n                );\n            }\n            sendMessage(myOut,\n                        MessageType.GET_OBJECT,\n                        threadId,\n                        CALLBACK_REQUEST_ID,\n                        bados.bytes);\n\n            // Get back the Python object ID and use it to construct the\n            // wrapper. A negative ID means null.\n            final Integer objectId = awaitCallbackReponse(result);\n            return (objectId < 0)\n                ? null\n                : new PythonObjectImpl(name == null ? string : name, objectId, myOut);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public PythonObject invokeAndGetObject(final String functionName,\n                                               final Object... args)\n            throws Throwable\n        {\n            // The python callback request ID\n            final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n            // Get the thread ID\n            final long threadId = getThreadId();\n\n            // Build the data to make the call\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(requestId);\n            writeUTF16(bados.dataOut, functionName);", "            if (args == null) {\n                bados.dataOut.writeInt(0);\n            }\n            else {\n                bados.dataOut.writeInt(args.length);\n                for (Object arg : args) {\n                    writeArgument(bados.dataOut, arg);\n                }\n            }\n\n            // Register ourselves for the callback\n            final PythonCallbackResult result = new PythonCallbackResult(this);\n            myPythonCallbackResults.put(requestId, result);\n\n            // Send the request over", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Sending object request to Python with thread ID \" +\n                    threadId + \" and Java request ID \" + requestId\n                );\n            }\n            sendMessage(myOut,\n                        MessageType.INVOKE_AND_GET_OBJECT,\n                        threadId,\n                        CALLBACK_REQUEST_ID,\n                        bados.bytes);\n\n            // Get back the Python object ID and use it to construct the\n            // wrapper. A negative ID means null.\n            final Integer objectId = awaitCallbackReponse(result);\n            return (objectId < 0)\n                ? null\n                : new PythonObjectImpl(functionName, objectId, myOut);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void close()\n        {\n            myTransport.close();\n        }\n\n        /**\n         * Whether this connection is closed or not.\n         */\n        public boolean isClosed()\n        {\n            return !myIsActive || myTransport.isClosed();\n        }\n\n        /**\n         * Returns the thread ID of the current thread, or if that is\n         * unavailable then a best-effort version.\n         */\n        private long getThreadId()\n        {\n            final long threadId = Thread.currentThread().getId();", "        public boolean isClosed()\n        {\n            return !myIsActive || myTransport.isClosed();\n        }\n\n        /**\n         * Returns the thread ID of the current thread, or if that is\n         * unavailable then a best-effort version.\n         */\n        private long getThreadId()\n        {\n            final long threadId = Thread.currentThread().getId();", "            if (threadId < 0) {\n                return ProcessHandle.current().pid();\n            }\n            else {\n                return threadId;\n            }\n        }\n\n        /**\n         * Do the Python eval or exec.\n         */\n        private <T> T evalOrExec(final boolean isEval,\n                                 final String string,\n                                 final Class<T> returnType)\n            throws ClassCastException,\n                   IOException,\n                   PythonCallbackException\n        {\n            // The python callback request ID\n            final int requestId = myPythonCallbackRequestId.getAndIncrement();\n\n            // Get the thread ID\n            final long threadId = getThreadId();\n\n            // Build the data to make the call\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(requestId);\n            bados.dataOut.writeBoolean(isEval);\n            bados.dataOut.writeInt(myTypeMapping.getId(returnType));\n            writeUTF16(bados.dataOut, string);\n\n            // Register ourselves for the callback\n            final PythonCallbackResult result = new PythonCallbackResult(this);\n            myPythonCallbackResults.put(requestId, result);\n\n            // Send the request over", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\n                    \"Sending eval to Python with thread ID \" + threadId + \" \" +\n                    \"and Java request ID \" + requestId\n                );\n            }\n            sendMessage(myOut,\n                        MessageType.PYTHON_EVAL_OR_EXEC,\n                        threadId,\n                        CALLBACK_REQUEST_ID,\n                        bados.bytes);\n\n            // Now wait for the result\n            return awaitCallbackReponse(result);\n        }\n\n        /**\n         * Write out a function argument. This might be by reference or by\n         * value.\n         */\n        private void writeArgument(final DataOutputStream out, final Object arg)\n            throws IOException\n        {", "            if (arg instanceof ByValue) {\n                // Sending by value\n                final Object reference = ((ByValue)arg).get();\n                if (reference == null) {\n                    // Can't send the value of NULL, fall back to a NULL reference\n                    out.writeByte(PythonValueFormat.REFERENCE.id);\n                    writeObject(out,\n                                null,\n                                myTypeMapping.getDescription(Object.class));\n                }\n                else {\n                    // We'd prefer to send it via SHMDATA methods, if we can:\n                    // Right now, this means we're using a transport where both\n                    // sides know they are on the same host and the feature is\n                    // enabled.\n\n                    // Here's where we can store the native array info\n                    // if needed. If the object is not one of primitive types,\n                    // it will be null.\n                    JniPJRmi.ArrayHandle arrayInfo = null;\n", "                    if (myUseShmdata && myTransport.isLocalhost()) {\n                        // Do this inside a try-catch since we don't want any\n                        // form of exception to take down the thread if we can\n                        // help it.\n                        try {\n                            // Determine the type of the array and write it\n                            // natively, after casting to the appropriate type.\n                            if (reference instanceof boolean[]) {\n                                arrayInfo = JniPJRmi.writeArray((boolean[])reference);\n                            }\n                            else if (reference instanceof byte[]) {\n                                arrayInfo = JniPJRmi.writeArray((byte   [])reference);\n                            }", "                            else if (reference instanceof byte[]) {\n                                arrayInfo = JniPJRmi.writeArray((byte   [])reference);\n                            }\n                            else if (reference instanceof short[]) {\n                                arrayInfo = JniPJRmi.writeArray((short  [])reference);\n                            }\n                            else if (reference instanceof int[]) {\n                                arrayInfo = JniPJRmi.writeArray((int    [])reference);\n                            }\n                            else if (reference instanceof long[]) {\n                                arrayInfo = JniPJRmi.writeArray((long   [])reference);\n                            }", "                            else if (reference instanceof long[]) {\n                                arrayInfo = JniPJRmi.writeArray((long   [])reference);\n                            }\n                            else if (reference instanceof float[]) {\n                                arrayInfo = JniPJRmi.writeArray((float  [])reference);\n                            }\n                            else if (reference instanceof double[]) {\n                                arrayInfo = JniPJRmi.writeArray((double [])reference);\n                            }\n                        }\n                        catch (Throwable e) {\n                            // Nothing, we'll proceed with the previous Pickle\n                            // format\n                            LOG.log(Level.FINE, \"writeArray() failed unexpectedly\", e);\n                        }\n                    }\n\n                    // Did we use the native method successfully? If so, we'll\n                    // send the info from that process.", "                    if (arrayInfo != null) {\n                        out.writeByte(PythonValueFormat.SHMDATA.id);\n                        writeUTF16   (out, arrayInfo.filename);\n                        out.writeInt (arrayInfo.numElems);\n                        out.writeChar(arrayInfo.type);\n                    }\n\n                    // Otherwise, proceed with normal pickle protocol\n                    else {\n                        // Convert it to a byte[] and compress\n                        final byte[] bytes =\n                            Snappy.compress(\n                                ourPythonPickle.get().toByteArray(reference)\n                            );\n\n                        // Marshall it\n                        out.writeByte(PythonValueFormat.SNAPPY_PICKLE.id);\n                        out.writeInt (bytes.length);\n                        out.write    (bytes, 0, bytes.length);\n                    }\n                }\n            }", "            else if (arg instanceof PythonObjectImpl) {\n                out.writeByte(PythonValueFormat.PYTHON_REFERENCE.id);\n                out.writeInt (((PythonObjectImpl)arg).getId());\n            }\n            else {\n                // Sending by reference\n                final TypeDescription argType =\n                    myTypeMapping.getDescription(\n                        (arg == null) ? Object.class : arg.getClass()\n                    );\n                out.writeByte(PythonValueFormat.REFERENCE.id);\n                writeObject(out, arg, argType);\n            }\n        }\n\n        /**\n         * Listen for incoming data. We do this while the connection is still\n         * good.\n         */\n        private void listen()\n        {\n            // Variables for stats gathering\n            final long startTimeMs = System.currentTimeMillis();\n            int        numRequests  = 0;\n\n            // How we pull in the data\n            final ByteList payload = new ByteList(1024 * 1024);\n            final byte[]   header  = new byte[17];\n            final byte[]   buffer  = new byte[64 * 1024];\n\n            // Keep reading the stream socket until it's done", "            while (true) {\n                // Set everything to empty to start with\n                payload.clear();\n                byte        typeId   = -1;\n                long        threadId = -1;\n                int         reqId    = -1;\n                MessageType type     = null;\n                try {\n                    // Read in the header; this should be a byte (type ID)\n                    // followed by an int (size). We try to read this in a\n                    // single go since reading a byte and then an int winds\n                    // making 5 calls to recvfrom(), as opposed to just 1!\n                    int headerRead = 0;", "                    while (headerRead < header.length) {\n                        final int read = myIn.read(header,\n                                                   headerRead,\n                                                   header.length - headerRead);\n                        if (read < 0) {\n                            break;\n                        }\n                        else {\n                            headerRead += read;\n                        }\n                    }", "                    if (headerRead < header.length) {\n                        throw new EOFException(\"EOF when reading PJRmi header\");\n                    }\n\n                    // Okay, unpack the header now\n                    typeId = header[0];\n                    threadId       = (((((long)header[ 1]) & 0xff) << 56) |\n                                      ((((long)header[ 2]) & 0xff) << 48) |\n                                      ((((long)header[ 3]) & 0xff) << 40) |\n                                      ((((long)header[ 4]) & 0xff) << 32) |\n                                      ((((long)header[ 5]) & 0xff) << 24) |\n                                      ((((long)header[ 6]) & 0xff) << 16) |\n                                      ((((long)header[ 7]) & 0xff) <<  8) |\n                                      ((((long)header[ 8]) & 0xff)      ));\n                    reqId          = (((( (int)header[ 9]) & 0xff) << 24) |\n                                      ((( (int)header[10]) & 0xff) << 16) |\n                                      ((( (int)header[11]) & 0xff) <<  8) |\n                                      ((( (int)header[12]) & 0xff)      ));\n                    final int size = (((( (int)header[13]) & 0xff) << 24) |\n                                      ((( (int)header[14]) & 0xff) << 16) |\n                                      ((( (int)header[15]) & 0xff) <<  8) |\n                                      ((( (int)header[16]) & 0xff)      ));\n", "                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\n                            \"Read \" +\n                            \"typeId = \"   + (int)typeId  + \" \" +\n                            \"('\"          + (char)typeId + \"'), \" +\n                            \"threadId = \" + threadId     + \" \" +\n                            \"reqId = \"    + reqId        + \" \" +\n                            \"size = \"     + size\n                        );\n                    }\n\n                    // Now read the payload. We keep reading until we believe\n                    // that we got everything we care about. The payload might\n                    // be split over several packets etc.\n                    int totalRead = 0;", "                    while (totalRead < size) {\n                        // Pull in all the data we can into the local buffer\n                        final int read =\n                            myIn.read(\n                                buffer,\n                                0,\n                                Math.min(buffer.length, size - totalRead)\n                            );\n\n                        // Check for EOF\n                        if (read < 0) {\n                            break;\n                        }\n                        else {\n                            payload.append(buffer, 0, read);\n                            totalRead += read;\n                        }\n                    }\n\n                    // Now figure out the incoming message type\n                    type = MessageType.byId(typeId);", "                        if (read < 0) {\n                            break;\n                        }\n                        else {\n                            payload.append(buffer, 0, read);\n                            totalRead += read;\n                        }\n                    }\n\n                    // Now figure out the incoming message type\n                    type = MessageType.byId(typeId);", "                    if (type == null) {\n                        throw new IllegalArgumentException(\n                            \"Unknown message type ID: \" + typeId\n                        );\n                    }\n\n                    // Good?\n                    if (totalRead == size) {\n                        // Now we have the payload we can log\n                        if (LOG.isLoggable(Level.FINER)) {\n                            LOG.finer(\n                                \"Received \" +\n                                \"typeId = \"    + (int)typeId  + \" \" +\n                                \"('\"           + (char)typeId + \"'), \" +\n                                PJRmi.toString(payload)\n                            );\n                        }\n                        numRequests++;\n\n                        // See if we have workers or not", "                        if (LOG.isLoggable(Level.FINER)) {\n                            LOG.finer(\n                                \"Received \" +\n                                \"typeId = \"    + (int)typeId  + \" \" +\n                                \"('\"           + (char)typeId + \"'), \" +\n                                PJRmi.toString(payload)\n                            );\n                        }\n                        numRequests++;\n\n                        // See if we have workers or not", "                        if (myWorkers == null) {\n                            // Nope, handle directly, and time it here\n                            final Instrumentor instr = myInstrumentors[type.ordinal()];\n                            final long start = instr.start();\n\n                            // Whether we acquired the global lock, or not\n                            boolean lockedGlobal = false;\n\n                            // The result goes in here. It's important that\n                            // no-one else uses this buffer for anything; we own\n                            // it here.\n                            final ByteArrayDataOutputStream sendBuf = mySendBufs.get();\n\n                            // Do all this inside a try-catch since we don't\n                            // want any form of exception to take down the\n                            // thread if we can help it", "                            try {\n                                if (type.shouldLockFor) {\n                                    myLockManager.lockGlobal();\n                                    lockedGlobal = true;\n                                }\n\n                                // Handle the incoming payload. We don't have a\n                                // VirtualThread in this case so we pass in null.\n                                receive(type,\n                                        threadId,\n                                        null,\n                                        reqId,\n                                        payload,\n                                        sendBuf,\n                                        myOut);\n                            }\n                            finally {", "                                if (lockedGlobal) {\n                                    // Release the global lock now. This should\n                                    // never fail in a perfect world but it's\n                                    // possible for users to do something bad to\n                                    // the lock. If that's the case then we\n                                    // simply drop the connection by exiting\n                                    // this method. The issue here is that\n                                    // receive() will have already sent a\n                                    // response and we don't want to send yet\n                                    // _another_ response (with this exception)\n                                    // since that will pollute the protocol\n                                    // stream.", "                                    try {\n                                        myLockManager.unlockGlobal();\n                                    }\n                                    catch (Throwable t) {\n                                        LOG.log(\n                                            Level.SEVERE,\n                                            \"Terminating listener on locking exception\",\n                                            t\n                                        );\n                                        return;\n                                    }\n                                }\n\n                                // Try to send the reply. This has to be done\n                                // after we've dropped the global lock since we\n                                // don't want the client thread initiating\n                                // another request (over a different connection\n                                // to us) and touching the lock. This is an\n                                // unlikely version of the same problem in the\n                                // worker pattern.\n                                send(sendBuf, myOut);\n\n                                // And we're finally done\n                                instr.end(start);\n                            }\n                        }\n                        else {\n                            // Hand off to a worker\n                            Worker worker = myWorkers.poll();", "                            if (worker == null) {\n                                // Need to create a new worker and set it running\n                                worker = new Worker(getName() + \"#Worker\" + ++myNumWorkers);\n                                worker.start();\n                            }\n\n                            // Find the virtual thread associated with the\n                            // threadId. The myVirtualThreads Map is only ever\n                            // touched in this thread.\n                            VirtualThread thread = myVirtualThreads.get(threadId);\n                            if (thread == null) {\n                                thread = new VirtualThread(getName() + \":\" + threadId);\n                                myVirtualThreads.put(threadId, thread);\n                            }\n                            worker.handle(type, threadId, thread, reqId, payload, myOut);\n                        }\n                    }\n                    else {\n                        // Junk this, we don't understand it\n                        throw new IllegalArgumentException(\n                            \"Received malformed request: \" +\n                            \"typeId = \"    + (int)typeId  + \" \" +\n                            \"('\"           + (char)typeId + \"'), \" +\n                            \"threadId = \"  + threadId     + \" \" +\n                            \"reqId = \"     + reqId        + \" \" +\n                            \"size = \"      + size         + \" \" +\n                            \"size-read = \" + totalRead    + \": \" +\n                            PJRmi.toString(payload)\n                        );\n                    }\n                }\n                catch (Throwable e) {\n                    // Attempt to return everything back to the caller. This\n                    // might be a problem with the connection itself, in which\n                    // case we'll simply bail out at the end anyhow (when we try\n                    // to send the exception).", "                            if (thread == null) {\n                                thread = new VirtualThread(getName() + \":\" + threadId);\n                                myVirtualThreads.put(threadId, thread);\n                            }\n                            worker.handle(type, threadId, thread, reqId, payload, myOut);\n                        }\n                    }\n                    else {\n                        // Junk this, we don't understand it\n                        throw new IllegalArgumentException(\n                            \"Received malformed request: \" +\n                            \"typeId = \"    + (int)typeId  + \" \" +\n                            \"('\"           + (char)typeId + \"'), \" +\n                            \"threadId = \"  + threadId     + \" \" +\n                            \"reqId = \"     + reqId        + \" \" +\n                            \"size = \"      + size         + \" \" +\n                            \"size-read = \" + totalRead    + \": \" +\n                            PJRmi.toString(payload)\n                        );\n                    }\n                }\n                catch (Throwable e) {\n                    // Attempt to return everything back to the caller. This\n                    // might be a problem with the connection itself, in which\n                    // case we'll simply bail out at the end anyhow (when we try\n                    // to send the exception).", "                    if (LOG.isLoggable(Level.FINE)) {\n                        LOG.fine(\n                            \"Encountered exception \" +\n                            \"when handling \" + type + \" \" + PJRmi.toString(payload) + \":\\n\" +\n                            stackTraceToString(e)\n                        );\n                    }\n\n                    // What we'll be sending back\n                    final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n\n                    // We'll treat this like a normal object\n                    final TypeDescription exDesc =\n                        myTypeMapping.getDescription(e.getClass());\n                    final long exHandle = myHandleMapping.addReference(e);\n", "                    try {\n                        // Populate with the exception information\n                        bados.dataOut.writeInt (exDesc.getTypeId());\n                        bados.dataOut.writeLong(exHandle);\n                        bados.dataOut.writeInt (-1);\n\n                        // And send\n                        sendMessage(myOut,\n                                    MessageType.EXCEPTION,\n                                    threadId,\n                                    reqId,\n                                    bados.bytes);\n                    }\n                    catch (SocketException ee) {\n                        // This is probably fine if the other side closed the\n                        // connection", "                        if (e instanceof EOFException) {\n                            LOG.info(\"Looks like the client disconnected: \" + ee);\n                        }\n                        else {\n                            LOG.warning(\"Error when sending back \" + e + \": \" + ee);\n                        }\n                        break;\n                    }\n                    catch (IOException ee) {\n                        // This is probably fine if the other side closed the\n                        // connection. We may get IOException on some transports\n                        // while trying to send the exception.", "                        if (e instanceof EOFException) {\n                            LOG.info(\"Looks like the client disconnected: \" + ee);\n                        }\n                        else {\n                            LOG.severe(\"IO error when sending \" + e + \": \" + ee);\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // Dump some auditing information\n            final long durationMs = System.currentTimeMillis() - startTimeMs;\n            final Collection<String> classes =\n                myTypeMapping.getClasses()\n                             .stream()\n                             .map(Class::getName)\n                             .collect(Collectors.toSet());\n            LOG.info(\"ConnectionStats:: \" +\n                     \"Name: \"               + myName            + \"; \" +\n                     \"Duration: \"           + durationMs + \"ms\" + \"; \" +\n                     \"NumRequests: \"        + numRequests       + \"; \" +\n                     \"NumAccessedClasses: \" + classes.size()    + \"; \" +\n                     \"AccessedClasses: \"    + classes);\n        }\n        /** For use in the listen() method only. */\n        private final ThreadLocalByteArrayDataOutputStream mySendBufs =\n            new ThreadLocalByteArrayDataOutputStream();\n\n        /**\n         * Handle a raw set of bytes making up a payload. This could throw\n         * pretty much any exception depending on what it does.\n         *\n         * <p>The clientReceiver stream should <i>not</i> be used for sending back\n         * messages directly from this method; they should be put into the\n         * result stream. This is to avoid race conditions in the worker code.\n         */\n        private void receive(final MessageType type,\n                             final long threadId,\n                             final VirtualThread thread,\n                             final int reqId,\n                             final ByteList payload,\n                             final ByteArrayDataOutputStream result,\n                             final DataOutputStream clientReceiver)\n            throws Throwable\n        {", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Handling \" + type + \": \" + PJRmi.toString(payload));\n            }\n\n            // This should always be empty when we get it\n            if (result.bytes.size() != 0) {\n                throw new IllegalStateException(\n                    \"Result buffer was non-empty: \" +\n                    PJRmi.toString(result.bytes.toByteArray())\n                );\n            }\n\n            // Handle whatever it ws\n            switch (type) {\n            case INSTANCE_REQUEST:\n                handleInstanceRequest(threadId, reqId, payload, result);\n                return;\n\n            case ADD_REFERENCE:\n                handleAddReference(threadId, reqId, payload, result);\n                return;\n\n            case DROP_REFERENCES:\n                handleDropReferences(threadId, reqId, payload, result);\n                return;\n\n            case TYPE_REQUEST:\n                handleTypeRequest(threadId, reqId, payload, result);\n                return;\n\n            case METHOD_CALL:\n                handleMethodCall(threadId, thread, reqId, payload, result);\n                return;\n\n            case TO_STRING:\n                handleToString(threadId, reqId, payload, result);\n                return;\n\n            case GET_FIELD:\n                handleGetField(threadId, reqId, payload, result);\n                return;\n\n            case SET_FIELD:\n                handleSetField(threadId, reqId, payload, result);\n                return;\n\n            case GET_ARRAY_LENGTH:\n                handleGetArrayLength(threadId, reqId, payload, result);\n                return;\n\n            case NEW_ARRAY_INSTANCE:\n                handleNewArrayInstance(threadId, reqId, payload, result);\n                return;\n\n            case OBJECT_CAST:\n                handleObjectCast(threadId, reqId, payload, result);\n                return;\n\n            case LOCK:\n                handleLock(threadId, reqId, payload, result);\n                return;\n\n            case UNLOCK:\n                handleUnlock(threadId, reqId, payload, result);\n                return;\n\n            case INJECT_CLASS:\n                handleInjectClass(threadId, reqId, payload, result);\n                return;\n\n            case INJECT_SOURCE:\n                handleInjectSource(threadId, reqId, payload, result);\n                return;\n\n            case GET_VALUE_OF:\n                handleGetValueOf(threadId, reqId, payload, result);\n                return;\n\n            case GET_CALLBACK_HANDLE:\n                handleGetCallbackHandle(threadId, reqId, payload, result,\n                                        clientReceiver);\n                return;\n\n            case CALLBACK_RESPONSE:\n                handleCallbackResponse(threadId, reqId, payload, result);\n                return;\n\n            case GET_PROXY:\n                handleGetProxy(threadId, reqId, payload, result,\n                               clientReceiver);\n                return;\n\n            default:\n                throw new IllegalArgumentException(\n                    \"Unhandled incoming message type: \" + type\n                );\n            }\n        }\n\n        /**\n         * Put a ByteArrayOutputStream as the payload into a buffer which we can\n         * later send over the wire.\n         *\n         * <p>The payload may be null if there is none. This can be true for\n         * simple ACK messages, for example.\n         */\n        private void buildMessage(final DataOutputStream      out,\n                                  final MessageType           type,\n                                  final long                  threadId,\n                                  final int                   reqId,\n                                  final ByteArrayOutputStream payload)\n            throws IOException\n        {\n            final long start = myInstrumentors[type.ordinal()].start();", "            try {\n                // The message type is always the first byte in the message\n                out.writeByte(type.id);\n\n                // And the thread ID and request number is the next 12 (8 and 4)\n                out.writeLong(threadId);\n                out.writeInt (reqId);\n\n                // Send any payload\n                if (payload != null && payload.size() > 0) {\n                    if (LOG.isLoggable(Level.FINER)) {\n                        LOG.finer(\n                            \"Creating \" + type + \" '\" + (char)type.id + \"' \" +\n                            \"for thread ID \" + threadId + \" \" +\n                            \"and request ID \" + reqId + \": \" +\n                            PJRmi.toString(payload.toByteArray())\n                        );\n                    }\n\n                    // Write out the payload size and whatever it is\n                    out.writeInt(payload.size());\n                    payload.writeTo(out);\n                }\n                else {", "                if (payload != null && payload.size() > 0) {\n                    if (LOG.isLoggable(Level.FINER)) {\n                        LOG.finer(\n                            \"Creating \" + type + \" '\" + (char)type.id + \"' \" +\n                            \"for thread ID \" + threadId + \" \" +\n                            \"and request ID \" + reqId + \": \" +\n                            PJRmi.toString(payload.toByteArray())\n                        );\n                    }\n\n                    // Write out the payload size and whatever it is\n                    out.writeInt(payload.size());\n                    payload.writeTo(out);\n                }\n                else {", "                    if (LOG.isLoggable(Level.FINER)) {\n                        LOG.finer(\"Building: \" + type + \" <>\");\n                    }\n\n                    // No payload so size is zero\n                    out.writeInt(0);\n                }\n\n                // Ensure everything is in there\n                out.flush();\n            }\n            finally {\n                myInstrumentors[type.ordinal()].end(start);\n            }\n        }\n\n        /**\n         * Send a ByteArrayDataOutputStream over the wire.\n         *\n         * <p>This could be called from multiple threads so it needs to be\n         * synchronized in order to prevent mangling the output stream.\n         */\n        private synchronized void send(final ByteArrayDataOutputStream msg,\n                                       final DataOutputStream          out)\n            throws IOException\n        {\n            // Push the bytes to the output stream and ensure that they are\n            // sent, using a flush()", "            if (msg.bytes.size() > 0) {\n                if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(\"Sending: \" + PJRmi.toString(msg.bytes.toByteArray()));\n                }\n                msg.bytes.writeTo(out);\n                out.flush();\n            }\n        }\n\n        /**\n         * Build a message and send it.\n         */\n        private void sendMessage(final DataOutputStream      out,\n                                 final MessageType           type,\n                                 final long                  threadId,\n                                 final int                   reqId,\n                                 final ByteArrayOutputStream payload)\n            throws IOException\n        {\n            final ByteArrayDataOutputStream sendBuf = mySendMessageBufs.get();\n            buildMessage(sendBuf.dataOut, type, threadId, reqId, payload);\n            send(sendBuf, out);\n        }\n        /** Only used by sendMessage(). */\n        private final ThreadLocalByteArrayDataOutputStream mySendMessageBufs =\n            new ThreadLocalByteArrayDataOutputStream();\n\n        /**\n         * Convert an object to a payload byte stream, following the given\n         * return format.\n         *\n         * @param objectType Type that the client should use when interpreting\n         *                   the object. May be {@code null} when\n         *                   {@code valueFormat} is not\n         *                   {@link PythonValueFormat#REFERENCE}\n         */\n        private void renderObject(final long                      threadId,\n                                  final int                       reqId,\n                                  final ByteArrayDataOutputStream buf,\n                                  final PythonValueFormat         valueFormat,\n                                  final Object                    object,\n                                  final TypeDescription           objectType)\n            throws Throwable\n        {\n            // What we'll be sending back\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n\n            switch (valueFormat) {\n            case REFERENCE:\n            case PYTHON_REFERENCE:\n                // What do we have to give back?", "                if (object instanceof PythonObjectImpl) {\n                    // A wrapped Python object\n                    bados.dataOut.writeInt(((PythonObjectImpl)object).getId());\n                    buildMessage(buf.dataOut,\n                                 MessageType.PYTHON_REFERENCE,\n                                 threadId,\n                                 reqId,\n                                 bados.bytes);\n                }\n                else if (object instanceof PythonProxyHandler) {\n                    // A Python object proxying for a Java one\n                    bados.dataOut.writeInt(((PythonProxyHandler)object).getId());\n                    buildMessage(buf.dataOut,\n                                 MessageType.PYTHON_REFERENCE,\n                                 threadId,\n                                 reqId,\n                                 bados.bytes);\n                }", "                else if (object instanceof PythonProxyHandler) {\n                    // A Python object proxying for a Java one\n                    bados.dataOut.writeInt(((PythonProxyHandler)object).getId());\n                    buildMessage(buf.dataOut,\n                                 MessageType.PYTHON_REFERENCE,\n                                 threadId,\n                                 reqId,\n                                 bados.bytes);\n                }\n                else if (valueFormat == PythonValueFormat.PYTHON_REFERENCE) {\n                    // We can't turn this into a Python object reference, sorry\n                    throw new IllegalArgumentException(\n                        \"Can't send a \" +\n                        (object == null ? \"null\" : object.getClass().toString()) + \" \" +\n                        \"as a Python reference\"\n                    );\n                }\n                else {\n                    // This this is just a Java object\n                    writeObject(bados.dataOut, object, objectType);\n                    buildMessage(buf.dataOut,\n                                 MessageType.ARBITRARY_ITEM,\n                                 threadId,\n                                 reqId,\n                                 bados.bytes);\n                }\n                return;\n\n            case RAW_PICKLE:\n            case SNAPPY_PICKLE:\n            case BESTEFFORT_PICKLE:\n            case BESTEFFORT_SNAPPY_PICKLE:\n                // Figure out which PythonPickle instance to use\n                final PythonPickle pickle;", "                else if (valueFormat == PythonValueFormat.PYTHON_REFERENCE) {\n                    // We can't turn this into a Python object reference, sorry\n                    throw new IllegalArgumentException(\n                        \"Can't send a \" +\n                        (object == null ? \"null\" : object.getClass().toString()) + \" \" +\n                        \"as a Python reference\"\n                    );\n                }\n                else {\n                    // This this is just a Java object\n                    writeObject(bados.dataOut, object, objectType);\n                    buildMessage(buf.dataOut,\n                                 MessageType.ARBITRARY_ITEM,\n                                 threadId,\n                                 reqId,\n                                 bados.bytes);\n                }\n                return;\n\n            case RAW_PICKLE:\n            case SNAPPY_PICKLE:\n            case BESTEFFORT_PICKLE:\n            case BESTEFFORT_SNAPPY_PICKLE:\n                // Figure out which PythonPickle instance to use\n                final PythonPickle pickle;", "                if (valueFormat == PythonValueFormat.RAW_PICKLE ||\n                    valueFormat == PythonValueFormat.SNAPPY_PICKLE)\n                {\n                    pickle = ourPythonPickle.get();\n                }\n                else {\n                    pickle = myBestEffortPythonPickle.get();\n                }\n\n                // Convert it to a byte[], and possibly compress it\n                byte[] bytes = pickle.toByteArray(object);", "                if (valueFormat == PythonValueFormat.SNAPPY_PICKLE ||\n                    valueFormat == PythonValueFormat.BESTEFFORT_SNAPPY_PICKLE)\n                {\n                    bytes = Snappy.compress(bytes);\n                }\n\n                // Stuff this into our buffer\n                // Number of bytes sent = data size + valueFormat byte\n                bados.dataOut.writeInt (bytes.length + 1);\n                bados.dataOut.writeByte(valueFormat.id);\n                bados.dataOut.write    (bytes, 0, bytes.length);\n\n                // And package it up\n                buildMessage(buf.dataOut,\n                             MessageType.PICKLE_BYTES,\n                             threadId,\n                             reqId,\n                             bados.bytes);\n                return;\n\n            default:\n                throw new IllegalArgumentException(\n                    \"Unhandled return format\" + valueFormat\n                );\n            }\n        }\n\n        /**\n         * Convert a deconstructed {@link JniPJRmi$ArrayHandle} object to a\n         * payload byte stream.\n         *\n         * @param threadId Logical thread ID.\n         * @param reqId    Request number.\n         * @param buf      The buffer which will eventually be sent.\n         * @param filename Name of the file to read from.\n         * @param numElems Number of elements we expect to read.\n         * @param type     Type of the array represented as a char, that\n         *                 {@link JniPJRmi} understands.\n         */\n        private void writeShmObject(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteArrayDataOutputStream buf,\n                                    final String                    filename,\n                                    final int                       numElems,\n                                    final char                      type)\n            throws Throwable\n        {\n            // What we'll be sending back\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n\n            // Let 'em know we're sending an ArrayHandle\n            bados.dataOut.writeByte(PythonValueFormat.SHMDATA.id);\n\n            // Write each input object to the output stream\n            writeUTF16(bados.dataOut, filename);\n            bados.dataOut.writeInt (numElems);\n            bados.dataOut.writeChar(type);\n\n            // And push it out over the wire\n            buildMessage(buf.dataOut,\n                         MessageType.SHMDATA_BYTES,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Write an Object to an output stream along with its type information,\n         * according to that given type information.\n         */\n        private void writeObject(final DataOutputStream dataOut,\n                                 final Object           object,\n                                 final TypeDescription  typeInfo)\n            throws IOException\n        {\n            final long start = myWriteObjectInstrumentor.start();\n\n            // Always write the type\n            dataOut.writeInt(typeInfo.getTypeId());\n\n            // Now handle the object itself", "            if (!typeInfo.isPrimitive()) {\n                // Get a handle on the object to give back. If it's null then we\n                // use the NULL handle.\n                if (object == null) {\n                    dataOut.writeLong(HandleMapping.NULL_HANDLE);\n                }\n                else {\n                    dataOut.writeLong(\n                        myHandleMapping.addReference(object)\n                    );\n                }\n\n                // Potentially write out the value as raw data too. This is pro-\n                // active support for the boxing on the Python side (so that it\n                // doesn't have to make another callback to determine the raw\n                // value of a boxed object). Note that not all primitive types\n                // are boxed on the Python side.", "                if (object instanceof java.lang.String) {\n                    // Don't send \"large\" strings automatically out over the\n                    // wire; wait for them to be requested.\n                    final String string = (String)object;\n                    if (string.length() < 32768) {\n                        writeUTF16(dataOut, string);\n                    }\n                    else {\n                        dataOut.writeInt(-1);\n                    }\n                }", "                else if (object instanceof java.lang.Boolean) {\n                    dataOut.writeInt(1);\n                    dataOut.writeBoolean((Boolean)object);\n                }\n                else if (object instanceof java.lang.Byte) {\n                    dataOut.writeInt(Byte.BYTES);\n                    dataOut.writeByte((Byte)object);\n                }\n                else if (object instanceof java.lang.Short) {\n                    dataOut.writeInt(Short.BYTES);\n                    dataOut.writeShort((Short)object);\n                }", "                else if (object instanceof java.lang.Short) {\n                    dataOut.writeInt(Short.BYTES);\n                    dataOut.writeShort((Short)object);\n                }\n                else if (object instanceof java.lang.Integer) {\n                    dataOut.writeInt(Integer.BYTES);\n                    dataOut.writeInt((Integer)object);\n                }\n                else if (object instanceof java.lang.Long) {\n                    dataOut.writeInt(Long.BYTES);\n                    dataOut.writeLong((Long)object);\n                }", "                else if (object instanceof java.lang.Long) {\n                    dataOut.writeInt(Long.BYTES);\n                    dataOut.writeLong((Long)object);\n                }\n                else if (object instanceof java.lang.Float) {\n                    dataOut.writeInt(Float.BYTES);\n                    dataOut.writeFloat((Float)object);\n                }\n                else if (object instanceof java.lang.Double) {\n                    dataOut.writeInt(Double.BYTES);\n                    dataOut.writeDouble((Double)object);\n                }\n                else {\n                    // No raw representation\n                    dataOut.writeInt(-1);\n                }\n            }", "                else if (object instanceof java.lang.Double) {\n                    dataOut.writeInt(Double.BYTES);\n                    dataOut.writeDouble((Double)object);\n                }\n                else {\n                    // No raw representation\n                    dataOut.writeInt(-1);\n                }\n            }\n            else if (typeInfo.isVoid()) {\n                // You can't have an object of type 'void' so grumble about this", "            else if (typeInfo.isVoid()) {\n                // You can't have an object of type 'void' so grumble about this\n                if (object != null) {\n                    throw new IllegalArgumentException(\n                        \"Attempt to write out a non-null as 'void': \" + object\n                    );\n                }\n\n                // Push out the NULL handle\n                dataOut.writeLong(HandleMapping.NULL_HANDLE);\n                dataOut.writeInt(-1);\n            }", "            else if (object == null) {\n                throw new NullPointerException(\n                    \"Attempt to write out null as a primitive\"\n                );\n            }\n            else {\n                // We need to marshal the object as a native value\n                switch (typeInfo.getName()) {\n                case \"boolean\":\n                    dataOut.writeBoolean((Boolean)object);\n                    break;\n\n                case \"byte\":\n                    dataOut.writeByte((Byte)object);\n                    break;\n\n                case \"char\":\n                    dataOut.writeChar((Character)object);\n                    break;\n\n                case \"double\":\n                    dataOut.writeDouble((Double)object);\n                    break;\n\n                case \"float\":\n                    dataOut.writeFloat((Float)object);\n                    break;\n\n                case \"int\":\n                    dataOut.writeInt((Integer)object);\n                    break;\n\n                case \"long\":\n                    dataOut.writeLong((Long)object);\n                    break;\n\n                case \"short\":\n                    dataOut.writeShort((Short)object);\n                    break;\n\n                case \"void\":\n                    // We write nothing out\n                    break;\n\n                default:\n                    throw new RuntimeException(\n                        \"Unhandled type when marshalling object: \" +\n                        typeInfo\n                    );\n                }\n            }\n            myWriteObjectInstrumentor.end(start);\n        }\n\n        /**\n         * Read an Object from an input stream along with its type information.\n         */\n        private ReadObjectResult readObject(final ByteList bytes, int offset)\n            throws IOException\n        {\n            final long start = myReadObjectInstrumentor.start();\n\n            // How it's being sent down the wire.\n            final MethodDescription.ArgumentType wireType =\n                MethodDescription.ArgumentType.byId(bytes.get(offset++));\n\n            // What we'll give back\n            Object result;\n\n            // See what we were given\n            switch (wireType) {\n            case VALUE: {\n                // First read the type information\n                final int typeId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n\n                final TypeDescription typeDesc = myTypeMapping.getDescription(typeId);", "                if (typeDesc == null) {\n                    throw new IllegalArgumentException(\"Unknown type ID: \" + typeId);\n                }\n\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\n                        \"Unmarshalling \" + typeId + \" \" +\n                        \"from raw bits at offset \" + offset\n                    );\n                }\n\n                // If it's sent natively down the wire then we convert from\n                // the raw bits", "                if (typeDesc.getName().equals(\"void\")) {\n                    // Like Method#invoke() we treat voids as nulls; there will\n                    // not be any associated data.\n                    result = null;\n                }\n                else if (typeDesc.getName().equals(\"boolean\") ||\n                         typeDesc.getName().equals(\"java.lang.Boolean\"))\n                {\n                    result = Boolean.valueOf(\n                        bytes.get(offset++) != 0\n                    );\n                }", "                else if (typeDesc.getName().equals(\"byte\") ||\n                         typeDesc.getName().equals(\"java.lang.Byte\"))\n                {\n                    result = Byte.valueOf(\n                        bytes.get(offset++)\n                    );\n                }\n                else if (typeDesc.getName().equals(\"double\") ||\n                         typeDesc.getName().equals(\"java.lang.Double\"))\n                {\n                    result = Double.valueOf(\n                        Double.longBitsToDouble(readLong(bytes, offset))\n                    );\n                    offset += Long.BYTES;\n                }", "                else if (typeDesc.getName().equals(\"float\") ||\n                         typeDesc.getName().equals(\"java.lang.Float\"))\n                {\n                    result = Float.valueOf(\n                        Float.intBitsToFloat(readInt(bytes, offset))\n                    );\n                    offset += Integer.BYTES;\n                }\n                else if (typeDesc.getName().equals(\"int\") ||\n                         typeDesc.getName().equals(\"java.lang.Integer\"))\n                {\n                    result = Integer.valueOf(readInt(bytes, offset));\n                    offset += Integer.BYTES;\n                }", "                else if (typeDesc.getName().equals(\"int\") ||\n                         typeDesc.getName().equals(\"java.lang.Integer\"))\n                {\n                    result = Integer.valueOf(readInt(bytes, offset));\n                    offset += Integer.BYTES;\n                }\n                else if (typeDesc.getName().equals(\"long\") ||\n                         typeDesc.getName().equals(\"java.lang.Long\"))\n                {\n                    result = Long.valueOf(readLong(bytes, offset));\n                    offset += Long.BYTES;\n                }", "                else if (typeDesc.getName().equals(\"short\") ||\n                         typeDesc.getName().equals(\"java.lang.Short\"))\n                {\n                    result = Short.valueOf(readShort(bytes, offset));\n                    offset += Short.BYTES;\n                }\n                else if (typeDesc.getName().equals(\"char\")                ||\n                         typeDesc.getName().equals(\"java.lang.Character\") ||\n                         typeDesc.getName().equals(\"[C\")                  ||\n                         typeDesc.getName().equals(\"java.lang.String\"))\n                {\n                    // Strings, char[]s, chars are sent over as UTF-16 strings\n                    // and handled appropriately\n                    final int count = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n                    final byte[] buffer = getByteArray(count);", "                    for (int i=0; i < count; i++) {\n                        buffer[i] = bytes.get(offset++);\n                    }\n                    final String string = new String(buffer, 0, count, \"UTF-16\");\n\n                    // Switch to the desired type\n                    if (typeDesc.getName().equals(\"char\") ||\n                        typeDesc.getName().equals(\"java.lang.Character\"))\n                    {\n                        if (string.length() != 1) {\n                            throw new IllegalArgumentException(\n                                \"Got a char in a String of length other than 1: \" +\n                                \"'\" + string + \"'\"\n                            );\n                        }\n                        result = Character.valueOf(string.charAt(0));\n                    }", "                        if (string.length() != 1) {\n                            throw new IllegalArgumentException(\n                                \"Got a char in a String of length other than 1: \" +\n                                \"'\" + string + \"'\"\n                            );\n                        }\n                        result = Character.valueOf(string.charAt(0));\n                    }\n                    else if (typeDesc.getName().equals(\"[C\")) {\n                        result = string.toCharArray();\n                    }", "                    else if (typeDesc.getName().equals(\"[C\")) {\n                        result = string.toCharArray();\n                    }\n                    else if (typeDesc.getName().equals(\"java.lang.String\")) {\n                        result = string;\n                    }\n                    else {\n                        // Ensure that the if statements all match up\n                        throw new AssertionError(\"Unexpected type: \" + typeDesc);\n                    }\n                }", "                else if (typeDesc.getName().equals(\"[Z\")) {\n                    final boolean[] array = new boolean[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = (\n                            bytes.get(offset++) != 0\n                        );\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[B\")) {\n                    final byte[] array = new byte[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[B\")) {\n                    final byte[] array = new byte[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = (\n                            bytes.get(offset++)\n                        );\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[D\")) {\n                    final double[] array = new double[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[D\")) {\n                    final double[] array = new double[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = Double.longBitsToDouble(readLong(bytes, offset));\n                        offset += Long.BYTES;\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[F\")) {\n                    final float[] array = new float[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[F\")) {\n                    final float[] array = new float[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = Float.intBitsToFloat(readInt(bytes, offset));\n                        offset += Integer.BYTES;\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[I\")) {\n                    final int[] array = new int[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[I\")) {\n                    final int[] array = new int[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = readInt(bytes, offset);\n                        offset += Integer.BYTES;\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[J\")) {\n                    final long[] array = new long[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[J\")) {\n                    final long[] array = new long[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = readLong(bytes, offset);\n                        offset += Long.BYTES;\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().equals(\"[S\")) {\n                    final short[] array = new short[readInt(bytes, offset)];\n                    offset += Integer.BYTES;", "                else if (typeDesc.getName().equals(\"[S\")) {\n                    final short[] array = new short[readInt(bytes, offset)];\n                    offset += Integer.BYTES;\n                    for (int i=0; i < array.length; i++) {\n                        array[i] = readShort(bytes, offset);\n                        offset += Short.BYTES;\n                    }\n                    result = array;\n                }\n                else if (typeDesc.getName().startsWith(\"[\")) {\n                    // An array of <something>s with a known length\n                    final int length = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n\n                    // Create an array of the right type by reflection, and\n                    // populate it\n                    result = Array.newInstance(typeDesc.getArrayComponentType(),\n                                               length);", "                else if (typeDesc.getName().startsWith(\"[\")) {\n                    // An array of <something>s with a known length\n                    final int length = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n\n                    // Create an array of the right type by reflection, and\n                    // populate it\n                    result = Array.newInstance(typeDesc.getArrayComponentType(),\n                                               length);\n                    for (int i=0; i < length; i++) {\n                        final ReadObjectResult ror = readObject(bytes, offset);\n                        offset = ror.offset;\n                        Array.set(result, i, ror.object);\n                    }\n                }", "                    for (int i=0; i < length; i++) {\n                        final ReadObjectResult ror = readObject(bytes, offset);\n                        offset = ror.offset;\n                        Array.set(result, i, ror.object);\n                    }\n                }\n                else if (typeDesc.getName().equals(\"java.util.Map\")) {\n                    // How many entries\n                    final int count = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n\n                    // Create and populate\n                    final Map<Object, Object> map = new HashMap<>();", "                    for (int i=0; i < count; i++) {\n                        // Pull out the key and value\n                        final ReadObjectResult keyRor   = readObject(bytes, offset);\n                        offset = keyRor.offset;\n                        final ReadObjectResult valueRor = readObject(bytes, offset);\n                        offset = valueRor.offset;\n\n                        // Stuff them into the map\n                        map.put(keyRor.object, valueRor.object);\n                    }\n\n                    result = map;\n                }", "                else if (typeDesc.getName().equals(\"java.util.Set\")) {\n                    final int count = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n\n                    final Set<Object> set = new HashSet<>();\n                    for (int i=0; i < count; i++) {\n                        final ReadObjectResult ror = readObject(bytes, offset);\n                        offset = ror.offset;\n                        set.add(ror.object);\n                    }\n                    result = set;\n                }", "                else if (typeDesc.getName().equals(\"java.util.Collection\") ||\n                         typeDesc.getName().equals(\"java.util.List\"))\n                {\n                    final int count = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n\n                    final List<Object> list = new ArrayList<>(count);\n                    for (int i=0; i < count; i++) {\n                        final ReadObjectResult ror = readObject(bytes, offset);\n                        offset = ror.offset;\n                        list.add(ror.object);\n                    }\n                    result = list;\n                }", "                else if (typeDesc.getName().equals(\"com.deshaw.pjrmi.PythonObject\")) {\n                    // A negative ID means null\n                    final int objectId = readInt(bytes, offset);\n                    offset += Integer.BYTES;\n                    result = (objectId < 0)\n                        ? null\n                        : new PythonObjectImpl(\"PythonObject#\" + objectId,\n                                               objectId,\n                                               myOut);\n                }\n                else if (typeDesc.getName().equals(\"com.deshaw.pjrmi.PythonSlice\")) {\n                    ReadObjectResult ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStart = ror.object;\n                    ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStop = ror.object;\n                    ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStep = ror.object;\n\n                    // Now build it. We might have been given any form of Number\n                    // but we convert them all to longs.\n                    result = new PythonSlice(\n                        (sliceStart != null) ? ((Number)sliceStart).longValue() : null,\n                        (sliceStop  != null) ? ((Number)sliceStop ).longValue() : null,\n                        (sliceStep  != null) ? ((Number)sliceStep ).longValue() : null\n                    );\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Don't know how to convert \" + typeDesc + \" \" +\n                        \"from raw bytes\"\n                    );\n                }\n            }   break;\n\n            case REFERENCE: {\n                // Simply grab the handle and add the associated object, it\n                // may be null which is okay\n                final long handle = readLong(bytes, offset);\n                offset += Long.BYTES;\n", "                else if (typeDesc.getName().equals(\"com.deshaw.pjrmi.PythonSlice\")) {\n                    ReadObjectResult ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStart = ror.object;\n                    ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStop = ror.object;\n                    ror = readObject(bytes, offset);\n                    offset = ror.offset;\n                    final Object sliceStep = ror.object;\n\n                    // Now build it. We might have been given any form of Number\n                    // but we convert them all to longs.\n                    result = new PythonSlice(\n                        (sliceStart != null) ? ((Number)sliceStart).longValue() : null,\n                        (sliceStop  != null) ? ((Number)sliceStop ).longValue() : null,\n                        (sliceStep  != null) ? ((Number)sliceStep ).longValue() : null\n                    );\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Don't know how to convert \" + typeDesc + \" \" +\n                        \"from raw bytes\"\n                    );\n                }\n            }   break;\n\n            case REFERENCE: {\n                // Simply grab the handle and add the associated object, it\n                // may be null which is okay\n                final long handle = readLong(bytes, offset);\n                offset += Long.BYTES;\n", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Grabbed handle \" + handle);\n                }\n                result = myHandleMapping.getObject(handle);\n            }   break;\n\n            case SHMDATA: {\n                // The object of interest was written natively, and we have to\n                // read it. We use the incoming object, which is a deconstructed\n                // {@link JniPJRmi$ArrayHandle}, to read it.\n\n                // First, we read the filename as a String\n                final int countString = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final byte[] bufferString = getByteArray(countString);", "                for (int i=0; i < countString; i++) {\n                    bufferString[i] = bytes.get(offset++);\n                }\n                final String filename = new String(bufferString, 0, countString, \"UTF-16\");\n\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"SHMDATA filename: \" + filename);\n                }\n\n                // Then we read the number of elements\n                final int numElems = Integer.valueOf(readInt(bytes, offset));\n                offset += Integer.BYTES;\n", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"SHMDATA numElems: \" + numElems);\n                }\n\n                // Read in the array type\n                final int countChar = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final byte[] bufferChar = getByteArray(countChar);\n                for (int i=0; i < countChar; i++) {\n                    bufferChar[i] = bytes.get(offset++);\n                }\n                final String stringType = new String(bufferChar, 0, countChar, \"UTF-16\");\n\n                // Let's make sure it was actually a char", "                for (int i=0; i < countChar; i++) {\n                    bufferChar[i] = bytes.get(offset++);\n                }\n                final String stringType = new String(bufferChar, 0, countChar, \"UTF-16\");\n\n                // Let's make sure it was actually a char\n                if (stringType.length() != 1) {\n                    throw new IllegalArgumentException(\n                        \"Got a char in a String of length other than 1: \" +\n                        \"'\" + stringType + \"'\"\n                    );\n                }\n                final char type = Character.valueOf(stringType.charAt(0));\n", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"SHMDATA type: \" + type);\n                }\n\n                // Now, we can read from the file\n                result = JniPJRmi.readArray(filename, numElems, type);\n            }   break;\n\n            case METHOD: {\n                // This is a method handle which we want to turn into a\n                // functional interface.\n                //\n                // Right now we expect to be given the exact method which is\n                // going to be used by the functional interface. However, that\n                // requires the user to determine this up front. While that's\n                // not particularly onerous, we might one day look to perform\n                // the method binding on this side, as an extended feature. We\n                // would probably do this by adding a flag to the request\n                // indicating as such, and just using the method ID to allow us\n                // to look up the name. Getting such method binding correct\n                // probably isn't hard, per se, but will require a lot of care;\n                // there are a number of gotchas in it. The method's relative\n                // specificities values might come into play if and when we\n                // choose to do it.\n                //\n                // The first value we read is a boolean represented by a byte.\n                // At some point we might want to turn this into an 8bit flags\n                // value (see above), but we can do that without changing the\n                // wire format.\n\n                final boolean isConstructor = (bytes.get(offset++) != 0);\n                final int ifaceId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final int klassId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final int methodId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final long handleId = readLong(bytes, offset);\n                offset += Long.BYTES;\n\n                // Now resolve what we can\n                final TypeDescription iface = myTypeMapping.getDescription(ifaceId);", "                if (iface == null) {\n                    throw new IllegalArgumentException(\n                        \"No known class type for interface ID \" + ifaceId\n                    );\n                }\n                final TypeDescription klass = myTypeMapping.getDescription(klassId);\n                if (klass == null) {\n                    throw new IllegalArgumentException(\n                        \"No known class type for method class ID \" + klassId\n                    );\n                }\n                final MethodDescription method = isConstructor\n                    ? klass.getConstructor(methodId)\n                    : klass.getMethod     (methodId);", "                if (method == null) {\n                    throw new IllegalArgumentException(\n                        (isConstructor ? \"Constructor\" : \"Method\") + \" \" +\n                        \"with ID \" + methodId + \" not found in \" + klass\n                    );\n                }\n\n                // It's okay for the instance to be null, depending on how we're\n                // binding etc.\n                final Object instance = myHandleMapping.getObject(handleId);\n\n                // And defer to the helper method to give back the object that\n                // we want", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Turning \" +\n                               (isConstructor ? \"constructor \" : \"method \") +\n                               method + \" into functional call for \" + iface);\n                }\n                result = getProxyForMethod(iface.getRepresentedClass(),\n                                           klass,\n                                           method,\n                                           isConstructor,\n                                           instance);\n            }   break;\n\n            case LAMBDA: {\n                // The argument is given by invoking a lambda. We should get\n                // method details (similar to the above) and then the arguments.\n                final boolean isConstructor = (bytes.get(offset++) != 0);\n                final int klassId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final int methodId = readInt(bytes, offset);\n                offset += Integer.BYTES;\n                final long handleId = readLong(bytes, offset);\n                offset += Long.BYTES;\n\n                // Now the arguments\n                final short numArgs = readShort(bytes, offset);\n                offset += Short.BYTES;\n                final Object args[] = new Object[numArgs];", "                for (int i=0; i < numArgs; i++) {\n                    final ReadObjectResult ror = readObject(bytes, offset);\n                    args[i] = ror.object;\n                    offset  = ror.offset;\n                }\n\n                // Now resolve what we got\n                final TypeDescription typeDesc =\n                    myTypeMapping.getDescription(klassId);\n                if (typeDesc == null) {\n                    throw new IllegalArgumentException(\n                        \"No known class type for method class ID \" + klassId\n                    );\n                }\n                final MethodDescription method =\n                    isConstructor ? typeDesc.getConstructor(methodId)\n                                  : typeDesc.getMethod     (methodId);", "                if (typeDesc == null) {\n                    throw new IllegalArgumentException(\n                        \"No known class type for method class ID \" + klassId\n                    );\n                }\n                final MethodDescription method =\n                    isConstructor ? typeDesc.getConstructor(methodId)\n                                  : typeDesc.getMethod     (methodId);\n                if (method == null) {\n                    throw new IllegalArgumentException(\n                        (isConstructor ? \"Constructor\" : \"Method\") + \" \" +\n                        \"with ID \" + methodId + \" not found in \" + typeDesc\n                    );\n                }\n                final Object instance = myHandleMapping.getObject(handleId);\n\n                // We invoke the method and give back its result", "                if (method == null) {\n                    throw new IllegalArgumentException(\n                        (isConstructor ? \"Constructor\" : \"Method\") + \" \" +\n                        \"with ID \" + methodId + \" not found in \" + typeDesc\n                    );\n                }\n                final Object instance = myHandleMapping.getObject(handleId);\n\n                // We invoke the method and give back its result\n                try {\n                    result =\n                        isConstructor ? typeDesc.callConstructor(method.getIndex(),\n                                                                 args)\n                                      : typeDesc.callMethod     (method.getIndex(),\n                                                                 instance,\n                                                                 args);\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\n                        \"Failed to invoke \" +\n                        (isConstructor ? \"constructor\" : \"method\") + \" \" +\n                        \"with ID \" + methodId + \" in \" + typeDesc +\n                        (instance == null ? \"\" : \" on object\"),\n                        t\n                    );\n                }\n            }   break;\n\n            default:\n                throw new RuntimeException(\n                    \"Unhandled argument type \" +\n                    \"received on the wire: \" + wireType\n                );\n            }\n\n            myReadObjectInstrumentor.end(start);\n            return new ReadObjectResult(offset, result);\n        }\n\n        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n        //                             HANDLERS                                  //\n\n        /**\n         * Handle an INSTANCE_REQUEST message.\n         *\n         * This is of the form:\n         *  int16   : String length\n         *  byte[]  : String bytes (string length in total)\n         *\n         * Gives back:\n         *  int32   : Type ID\n         *  int64   : Handle\n         *  int32   : -1 (no raw data)\n         * where Handle will be -ve if the result was null.\n         */\n        private void handleInstanceRequest(final long                      threadId,\n                                           final int                       reqId,\n                                           final ByteList                  payload,\n                                           final ByteArrayDataOutputStream buf)\n            throws IOException\n        {\n            // Need at least 4 bytes at the start of the message, for the string length", "                try {\n                    result =\n                        isConstructor ? typeDesc.callConstructor(method.getIndex(),\n                                                                 args)\n                                      : typeDesc.callMethod     (method.getIndex(),\n                                                                 instance,\n                                                                 args);\n                }\n                catch (Throwable t) {\n                    throw new RuntimeException(\n                        \"Failed to invoke \" +\n                        (isConstructor ? \"constructor\" : \"method\") + \" \" +\n                        \"with ID \" + methodId + \" in \" + typeDesc +\n                        (instance == null ? \"\" : \" on object\"),\n                        t\n                    );\n                }\n            }   break;\n\n            default:\n                throw new RuntimeException(\n                    \"Unhandled argument type \" +\n                    \"received on the wire: \" + wireType\n                );\n            }\n\n            myReadObjectInstrumentor.end(start);\n            return new ReadObjectResult(offset, result);\n        }\n\n        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n        //                             HANDLERS                                  //\n\n        /**\n         * Handle an INSTANCE_REQUEST message.\n         *\n         * This is of the form:\n         *  int16   : String length\n         *  byte[]  : String bytes (string length in total)\n         *\n         * Gives back:\n         *  int32   : Type ID\n         *  int64   : Handle\n         *  int32   : -1 (no raw data)\n         * where Handle will be -ve if the result was null.\n         */\n        private void handleInstanceRequest(final long                      threadId,\n                                           final int                       reqId,\n                                           final ByteList                  payload,\n                                           final ByteArrayDataOutputStream buf)\n            throws IOException\n        {\n            // Need at least 4 bytes at the start of the message, for the string length", "            if (payload.size() < 4) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // Grab the name of the object which we want\n            final int size = readInt(payload, 0);\n\n            // These are sent over as UTF-16\n            final byte[] buffer = getByteArray(size);", "            for (int i=0; i < size; i++) {\n                buffer[i] = payload.get(i + 4);\n            }\n            final String name = new String(buffer, 0, size, \"UTF-16\");\n\n            // Get the object\n            final Object instance = getObjectInstance(name);\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            if (instance == null) {\n                bados.dataOut.writeInt (myTypeMapping.getId(Object.class));\n                bados.dataOut.writeLong(HandleMapping.NULL_HANDLE);\n                bados.dataOut.writeInt (-1);\n            }\n            else {\n                bados.dataOut.writeInt (myTypeMapping  .getId       (instance));\n                bados.dataOut.writeLong(myHandleMapping.addReference(instance));\n                bados.dataOut.writeInt (-1);\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.OBJECT_REFERENCE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle an ADD_REFERENCE message.\n         *\n         * This is of the form:\n         *  int64   : Handle\n         *\n         * Gives back and empty ACK.\n         */\n        private void handleAddReference(final long                      threadId,\n                                        final int                       reqId,\n                                        final ByteList                  payload,\n                                        final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (instance == null) {\n                bados.dataOut.writeInt (myTypeMapping.getId(Object.class));\n                bados.dataOut.writeLong(HandleMapping.NULL_HANDLE);\n                bados.dataOut.writeInt (-1);\n            }\n            else {\n                bados.dataOut.writeInt (myTypeMapping  .getId       (instance));\n                bados.dataOut.writeLong(myHandleMapping.addReference(instance));\n                bados.dataOut.writeInt (-1);\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.OBJECT_REFERENCE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle an ADD_REFERENCE message.\n         *\n         * This is of the form:\n         *  int64   : Handle\n         *\n         * Gives back and empty ACK.\n         */\n        private void handleAddReference(final long                      threadId,\n                                        final int                       reqId,\n                                        final ByteList                  payload,\n                                        final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() != 8) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final long handle = readLong(payload, 0);\n            myHandleMapping.addReference(handle);\n\n            buildMessage(buf.dataOut, MessageType.EMPTY_ACK, threadId, reqId, null);\n        }\n\n        /**\n         * Handle a DROP_REFERENCES message.\n         *\n         * This is of the form:\n         *  int32     : Num handles\n         *  handles[] :\n         *    int64   : Handle\n         *\n         * Gives back an empty ACK.\n         */\n        private void handleDropReferences(final long                      threadId,\n                                          final int                       reqId,\n                                          final ByteList                  payload,\n                                          final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() < 4) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // Our position in the payload data\n            int offset = 0;\n\n            // How many to drop\n            final int count = readInt(payload, offset);\n            offset += Integer.BYTES;\n", "            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Dropping \" + count + \" references...\");\n            }\n\n            // Drop them\n            for (int i=0; i < count; i++) {\n                final long handle = readLong(payload, offset);\n                offset += Long.BYTES;\n\n                myHandleMapping.dropReference(handle);\n            }\n\n            // ACK back\n            buildMessage(buf.dataOut, MessageType.EMPTY_ACK, threadId, reqId, null);\n        }\n\n        /**\n         * Handle a TYPE_REQUEST message.\n         *\n         * This is of the form:\n         *  boolean : by-id or by-string flag\n         *  type:\n         *   int32   : Type ID\n         *  or\n         *   int32   : Name length\n         *   bytes[] : Name\n         *\n         * Gives back by deferring to writeTypeDesc().\n         */\n        private void handleTypeRequest(final long                      threadId,\n                                       final int                       reqId,\n                                       final ByteList                  payload,\n                                       final ByteArrayDataOutputStream buf)\n            throws ClassNotFoundException,\n                   IOException,\n                   SecurityException\n        {", "            if (payload.size() < 1) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // Our position in the payload data\n            int offset = 0;\n\n            // Start off by finding out what sort of call this is\n            final boolean isById = (payload.get(offset++) != 0);\n\n            // Get the type description\n            final TypeDescription desc;\n            final int int32 = readInt(payload, offset);\n            offset += Integer.BYTES;\n", "            if (isById) {\n                desc = myTypeMapping.getDescription(int32);\n            }\n            else {\n                final StringBuilder sb = new StringBuilder();\n                while (sb.length() < int32) {\n                    sb.append((char)payload.get(offset++));\n                }\n                final String className = sb.toString();\n\n                // See if we are allowed to give back this class", "                if (!isClassPermitted(className)) {\n                    final String msg = getClassNotPermittedMessage();\n                    throw new SecurityException(\n                        \"Access permission denied for class \\\"\" + className + \"\\\"\" +\n                        (msg == null ? \"\" : \": \" + msg)\n                    );\n                }\n\n                // Okay to give back, handle requests for primitives specially\n                final Class<?> klass;\n                switch (className) {\n                case \"void\":    klass = Void     .TYPE;           break;\n                case \"boolean\": klass = Boolean  .TYPE;           break;\n                case \"byte\":    klass = Byte     .TYPE;           break;\n                case \"short\":   klass = Short    .TYPE;           break;\n                case \"int\":     klass = Integer  .TYPE;           break;\n                case \"long\":    klass = Long     .TYPE;           break;\n                case \"float\":   klass = Float    .TYPE;           break;\n                case \"double\":  klass = Double   .TYPE;           break;\n                case \"char\":    klass = Character.TYPE;           break;\n                default:        klass = Class.forName(className); break;\n                }\n                desc = myTypeMapping.getDescription(klass);\n            }\n\n            // Send it back\n            writeTypeDesc(desc, threadId, reqId, buf);\n        }\n\n        /**\n         * Handle an METHOD_CALL message.\n         *\n         * This is of the form:\n         *  boolean : isConstructor flag\n         *  int32   : Type ID\n         *  byte    : PythonValueFormat\n         *  int64   : Object handle\n         *  int32   : Method/constructor index as defined by TypeDescription\n         *  bytes[] : Arguments (if any) as raw bytes\n         *\n         * Gives back:\n         *  int32    : Result type (possibly void)\n         *  bytes[]  : The result (if native), or its handle (if an Object),\n         *             or nothing (if void)\n         */\n        private void handleMethodCall(final long                      threadId,\n                                      final VirtualThread             virtualThread,\n                                      final int                       reqId,\n                                      final ByteList                  payload,\n                                      final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() < 18) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // Our position in the payload data\n            int offset = 0;\n\n            // Pull in the header information from the wire, everything up to\n            // the, optional, arguments\n            final boolean isConstructor = (payload.get(offset++) != 0);\n\n            final int typeId = readInt(payload, offset);\n            offset += Integer.BYTES;\n\n            final byte valueFormatId = payload.get(offset++);\n\n            final byte syncModeId = payload.get(offset++);\n\n            final long handle = readLong(payload, offset);\n            offset += Long.BYTES;\n\n            final int index = readInt(payload, offset);\n            offset += Integer.BYTES;\n\n            // Figure out what we need to know in order to invoke this method\n            final Object          object = myHandleMapping.getObject(handle);\n            final TypeDescription klass  = myTypeMapping.getDescription(typeId);\n\n            // Known type?", "            if (klass == null) {\n                throw new IllegalArgumentException(\"Unknown type \" + typeId);\n            }\n\n            // Get the return format\n            final PythonValueFormat valueFormat =\n                PythonValueFormat.byId(valueFormatId);\n\n            // Get the calling mode\n            final SyncMode syncMode = SyncMode.byId(syncModeId);\n\n            // Grab the method info, different depending on the type of call\n            final MethodDescription method;", "            if (isConstructor) {\n                if (index < 0 || index >= klass.getNumConstructors()) {\n                    throw new ArrayIndexOutOfBoundsException(\n                        \"Bad constructor index: \" + index\n                    );\n                }\n                else {\n                    method = klass.getConstructor(index);\n                }\n            }\n            else {", "                if (index < 0 || index >= klass.getNumMethods()) {\n                    throw new ArrayIndexOutOfBoundsException(\n                        \"Bad method index: \" + index\n                    );\n                }\n                else {\n                    method = klass.getMethod(index);\n                }\n            }\n\n            // What we now know", "            if (LOG.isLoggable(Level.FINEST)) {\n                // Don't call toString() on the object here since it might be a\n                // Python shim and we don't want to wind up either recursing\n                // indefinitely or similar if that call invokes Java methods or\n                // similar.\n                LOG.finest(\n                    \"Going to call \" + method + \" on \" +\n                    ((object == null) ? \"\" : \"an instance of \") +\n                    \"class \" + klass\n                );\n            }\n\n            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n            // Pull out all the arguments and turn them into Objects\n            final Object[] args = new Object[method.getNumArguments()];", "            for (short i=0; i < args.length; i++) {\n                // Pull it from the data\n                final ReadObjectResult read = readObject(payload, offset);\n                offset  = read.offset;\n                args[i] = read.object;\n\n                // What did we get?\n                if (LOG.isLoggable(Level.FINEST)) {\n                    try {\n                        LOG.finest(\"Argument \" + i + \" is: <\" + args[i] + \">\");\n                    }\n                    catch (Exception e) {\n                        // Proxy classes might balk here, for example\n                        LOG.finest(\"Error rendering argument \" + i + \": e\" + e);\n                    }\n                }\n            }\n\n            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n", "                    try {\n                        LOG.finest(\"Argument \" + i + \" is: <\" + args[i] + \">\");\n                    }\n                    catch (Exception e) {\n                        // Proxy classes might balk here, for example\n                        LOG.finest(\"Error rendering argument \" + i + \": e\" + e);\n                    }\n                }\n            }\n\n            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n", "            try {\n                // We're calling down a level in the \"stack\"\n                myCallDepth++;\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Call depth is now \" + myCallDepth);\n                }\n                if (myCallDepth >= MAX_CALL_DEPTH) {\n                    throw new StackOverflowError(\"Call depth became \" + myCallDepth);\n                }\n\n                // Say what we're about to do", "                if (LOG.isLoggable(Level.FINEST)) {\n                    final StringBuilder sb = new StringBuilder();\n                    for (Object arg : args) {\n                        if (sb.length() > 0) {\n                            sb.append(\", \");\n                        }\n                        try {\n                            sb.append(arg);\n                        }\n                        catch (Exception e) {\n                            sb.append(\"<???>\");\n                        }\n                        sb.append('<')\n                          .append((arg == null) ? \"NULL\" : arg.getClass())\n                          .append('>');\n                    }", "                    if (isConstructor) {\n                        LOG.finest(\"Calling constructor \" + index + \" for \" +\n                                   klass + \" with arguments [\" + sb + \"]\");\n                    }\n                    else {\n                        LOG.finest(\"Calling method \" + index + \" \"+\n                                   \"'\" + method + \"' \" +\n                                   \"with arguments [\" + sb + \"]\");\n                    }\n                }\n\n                // Now we can actually call the method\n                final Object result;", "                if (syncMode == SyncMode.SYNCHRONOUS) {\n                    // A straight call. Give back whatever we got.\n                    result = isConstructor\n                        ? klass.callConstructor(index,         args)\n                        : klass.callMethod     (index, object, args);\n                }\n                else if (syncMode == SyncMode.JAVA_THREAD) {\n                    // Create a Future instance to give back and spawn the\n                    // thread to set the result into that future. Try to give\n                    // the future a reasonable name so that the user knows what\n                    // it is. However we avoid expanding all the arguments for\n                    // the same of brevity.\n                    final MethodCallFuture future =\n                        new MethodCallFuture(\n                            \"Future for call to: \" +\n                            method.getReturnType      ()\n                                  .getRepresentedClass()\n                                  .getSimpleName      () + \" \" +\n                            klass .getRepresentedClass()\n                                  .getSimpleName      () + \".\" +\n                            (isConstructor ? \"<init>\"\n                                           : method.getName() + \"\") +\n                            (args.length > 0 ? \"(...)\" : \"()\")\n                        );\n\n                    // Get a caller, creating if needbe\n                    MethodCaller caller = myMethodCallers.poll();", "                    if (caller == null) {\n                        // Create and spawn the caller thread\n                        caller = new MethodCaller();\n                        caller.start();\n                    }\n\n                    // And actually tell it to do the work\n                    caller.handle(\n                        () -> {\n                            // Make the call, reaping any exceptions along the\n                            // way and also giving them back via the Future", "                            try {\n                                // This is a method call so we need to acquire\n                                // the global lock, if any, like any other\n                                // method call would.\n                                myLockManager.lockGlobal();\n                                future.done(\n                                    isConstructor\n                                        ? klass.callConstructor(index,         args)\n                                        : klass.callMethod     (index, object, args),\n                                    false\n                                );\n                            }\n                            catch (Throwable t) {\n                                future.done(t, true);\n                            }\n                            finally {\n                                myLockManager.unlockGlobal();\n                            }\n                        }\n                    );\n\n                    // And we'll be giving back the Future, rather than the\n                    // result, for this calling mode\n                    result = future;\n                }\n                else {\n                    throw new UnsupportedOperationException(\n                        \"Unhandle sync mode \" + syncMode\n                    );\n                }\n\n                // What did we get?", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Result was <\" + result + \">\");\n                }\n\n                // Figure out what type to associate with the result.\n                //\n                // What we are trying to deal with here is type erasure of the\n                // information associated with generics. For something like\n                // Set<Integer> the get() method will always return an Object\n                // since the runtime environment doesn't know the real type;\n                // that it becomes an Int happens because the compiler inserts a\n                // cast along the way. (This is why it's possible to put a\n                // Double into such a List if we cast away its type information.\n                // We'll only discover that when we pull the Double out as an\n                // Integer.)\n                //\n                // What this means for us is that such methods return fun values\n                // which have to be downcast into their \"real\" type on the\n                // Python side if we want to use them. In order to deal with\n                // this we give back the _actual_ type associated with the value\n                // which the method returns. This is slightly icky since it\n                // means that, say, get() on a List of CharSequences will\n                // actually return a String, or StringBuilder, or whatever the\n                // concrete implementation happens to be. Since we have _no_ way\n                // to knowing at runtime that the E in List<E> is a CharSequence\n                // we don't know to hand back a CharSequence. We argue that this\n                // is actually okay and vaguely Pythonic since Python employs\n                // duck-typing most of the time and what we hand back conforms\n                // better with this view of the world. However, it's open to\n                // abuse on the other side and we simply have to trust that the\n                // Python users won't to anything special with the concrete\n                // class; if they do then their code may fail if the class\n                // changes.\n                final TypeDescription returnType;", "                if (syncMode != SyncMode.SYNCHRONOUS) {\n                    assert(result instanceof Future);\n                    returnType = myTypeMapping.getDescription(Future.class);\n                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\"Return type is \" + returnType);\n                    }\n                }\n                else if (result != null && method.isGenericReturnType()) {\n                    returnType = myTypeMapping.getDescription(result.getClass());\n                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\"Return type is exposed as \" + returnType);\n                    }\n                }\n                else {\n                    returnType = method.getReturnType();", "                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\"Return type is exposed as \" + returnType);\n                    }\n                }\n                else {\n                    returnType = method.getReturnType();\n                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\n                            \"Return type matches method result \" + returnType\n                        );\n                    }\n                }\n\n                // Convert the result to a payload byte stream\n                renderObject(threadId, reqId, buf, valueFormat, result, returnType);\n            }\n            finally {\n                // We're coming back up here so reduce the depth\n                myCallDepth--;\n            }\n        }\n\n        /**\n         * Handle a TO_STRING message.\n         *\n         * This is of the form:\n         *  int64   : Handle\n         *\n         * Gives back the UTF16 string representation, or -1\n         */\n        private void handleToString(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteList                  payload,\n                                    final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() != 8) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final long handle = readLong(payload, 0);\n\n            final Object instance = myHandleMapping.getObject(handle);\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            if (instance == null) {\n                bados.dataOut.writeInt(-1);\n            }\n            else {\n                final String string = instance.toString();\n                writeUTF16(bados.dataOut, string);\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.UTF16_VALUE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle an GET_FIELD message.\n         *\n         * This is of the form:\n         *  int32   : Object type ID\n         *  int64   : Object handle\n         *  int32   : Field index as defined by TypeDescription\n         *\n         * Gives back:\n         *  int32    : Field type ID\n         *  bytes[]  : The field (if native), or its handle (if an Object)\n         */\n        private void handleGetField(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteList                  payload,\n                                    final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (instance == null) {\n                bados.dataOut.writeInt(-1);\n            }\n            else {\n                final String string = instance.toString();\n                writeUTF16(bados.dataOut, string);\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.UTF16_VALUE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle an GET_FIELD message.\n         *\n         * This is of the form:\n         *  int32   : Object type ID\n         *  int64   : Object handle\n         *  int32   : Field index as defined by TypeDescription\n         *\n         * Gives back:\n         *  int32    : Field type ID\n         *  bytes[]  : The field (if native), or its handle (if an Object)\n         */\n        private void handleGetField(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteList                  payload,\n                                    final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() != 16) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final int  typeId = readInt (payload,  0);\n            final long handle = readLong(payload,  4);\n            final int  index  = readInt (payload, 12);\n\n            final TypeDescription desc = myTypeMapping.getDescription(typeId);\n            final Object object = myHandleMapping.getObject(handle);\n\n            // Grab the field and its type\n            final Object          field;\n            final TypeDescription fieldType;", "            if (desc.isArray()) {\n                // For arrays, this is the array index\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Getting array index \" + index + \" from \" + handle);\n                }\n                field     = Array.get(object, index);\n                fieldType =\n                    myTypeMapping.getDescription(\n                        object.getClass().getComponentType()\n                    );\n            }\n            else {\n                // Else it's just an actual field, grab its value", "                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Getting field index \" + index + \" from \" + handle);\n                }\n                field = desc.getField(index, object);\n\n                // The type is the declared type, not the type of the object\n                // (which might be a subclass)\n                fieldType = desc.getField(index).getType();\n            }\n\n            // Simply marshal up the value which we got back\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            writeObject(bados.dataOut, field, fieldType);\n            buildMessage(buf.dataOut,\n                         MessageType.ARBITRARY_ITEM,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle an SET_FIELD message.\n         *\n         * This is of the form:\n         *  int64   : Object handle\n         *  int32   : Field index as defined by TypeDescription\n         *  int32   : Field type\n         *  bytes[] : The new value of the field (if native), or a handle\n         *\n         * Gives back empty ACK.\n         */\n        private void handleSetField(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteList                  payload,\n                                    final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() < 17) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final int objTypeId = readInt (payload,  0);\n            final long handle   = readLong(payload,  4);\n            final int index     = readInt (payload, 12);\n\n            final Object value = readObject(payload, 16).object;\n\n            // The object we're setting on, this may be null if we're setting a\n            // static field\n            final Object object = myHandleMapping.getObject(handle);\n\n            // The type information comes from the object itself\n            final TypeDescription desc = myTypeMapping.getDescription(objTypeId);\n\n            // Now just set it", "            if (desc.isArray()) {\n                // For arrays, this is the array index\n                Array.set(object, index, value);\n            }\n            else {\n                // Else it's just an actual field\n                desc.setField(index, object, value);\n            }\n\n            // ACK comes back\n            buildMessage(buf.dataOut, MessageType.EMPTY_ACK, threadId, reqId, null);\n        }\n\n        /**\n         * Handle a GET_ARRAY_LENGTH message.\n         *\n         * This is of the form:\n         *  int64   : Handle\n         *\n         * Gives back:\n         *  int32   : The length\n         */\n        private void handleGetArrayLength(final long                      threadId,\n                                          final int                       reqId,\n                                          final ByteList                  payload,\n                                          final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() != 8) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final long handle = readLong(payload, 0);\n\n            final Object object = myHandleMapping.getObject(handle);\n            if (object == null) {\n                throw new IllegalArgumentException(\n                    \"No object for handle \" + handle\n                );\n            }\n\n            // Simply marshal up the value which we got back. If the object is\n            // not an array then getLength() will throw an exception.\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(Array.getLength(object));\n            buildMessage(buf.dataOut,\n                         MessageType.ARRAY_LENGTH,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a NEW_ARRAY_INSTANCE message.\n         *\n         * This is of the form:\n         *  int32   : Type ID\n         *  int32   : Length\n         *\n         * Gives back:\n         *  int32   : Type ID\n         *  int64   : The array handle\n         *  int32   : -1 (no raw data)\n         */\n        private void handleNewArrayInstance(final long                      threadId,\n                                            final int                       reqId,\n                                            final ByteList                  payload,\n                                            final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (object == null) {\n                throw new IllegalArgumentException(\n                    \"No object for handle \" + handle\n                );\n            }\n\n            // Simply marshal up the value which we got back. If the object is\n            // not an array then getLength() will throw an exception.\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt(Array.getLength(object));\n            buildMessage(buf.dataOut,\n                         MessageType.ARRAY_LENGTH,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a NEW_ARRAY_INSTANCE message.\n         *\n         * This is of the form:\n         *  int32   : Type ID\n         *  int32   : Length\n         *\n         * Gives back:\n         *  int32   : Type ID\n         *  int64   : The array handle\n         *  int32   : -1 (no raw data)\n         */\n        private void handleNewArrayInstance(final long                      threadId,\n                                            final int                       reqId,\n                                            final ByteList                  payload,\n                                            final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() != 8) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final int typeId = readInt(payload, 0);\n            final int length = readInt(payload, 4);\n\n            // Known type?\n            final TypeDescription klass  = myTypeMapping.getDescription(typeId);", "            if (klass == null) {\n                throw new IllegalArgumentException(\"Unknown type \" + typeId);\n            }\n\n            // Create it\n            final Object array =\n                Array.newInstance(klass.getArrayComponentType(), length);\n\n            // Return the new instance along with its type information\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt (typeId);\n            bados.dataOut.writeLong(myHandleMapping.addReference(array));\n            bados.dataOut.writeInt (-1);\n            buildMessage(buf.dataOut,\n                         MessageType.OBJECT_REFERENCE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a OBJECT_CAST message.\n         *\n         * This is of the form:\n         *  int32   : Type ID\n         *  int64   : Handle\n         *\n         * Gives back:\n         *  int32   : Type ID\n         *  int64   : The cast'd instance's handle\n         *  int32   : -1 (no raw data)\n         */\n        private void handleObjectCast(final long                      threadId,\n                                      final int                       reqId,\n                                      final ByteList                  payload,\n                                      final ByteArrayDataOutputStream buf)\n            throws IOException\n        {", "            if (payload.size() != 12) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            final int typeId  = readInt (payload, 0);\n            final long handle = readLong(payload, 4);\n\n            // Known type?\n            final TypeDescription klass  = myTypeMapping.getDescription(typeId);", "            if (klass == null) {\n                throw new IllegalArgumentException(\"Unknown type \" + typeId);\n            }\n\n            // Get the object for this handle, allow it to be the null pointer\n            final Object object = myHandleMapping.getObject(handle);\n            if (object == null && handle != HandleMapping.NULL_HANDLE) {\n                throw new IllegalArgumentException(\n                    \"No object for handle \" + handle\n                );\n            }\n\n            // Do the cast, we simply try to do it here; it doesn't matter\n            // what we get back as we are only interested in if it throws an\n            // exception when we do so.\n            klass.getRepresentedClass().cast(object);\n\n            // That worked so add a new reference to this object since the other\n            // side will create a new object to track it\n            myHandleMapping.addReference(handle);\n\n            // Echo back the instance along with the type ID\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            bados.dataOut.writeInt (typeId);\n            bados.dataOut.writeLong(handle);\n            bados.dataOut.writeInt (-1);\n            buildMessage(buf.dataOut,\n                         MessageType.OBJECT_REFERENCE,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a LOCK message.\n         *\n         * This is of the form:\n         *  int32   : lock-name length\n         *  bytes   : lock-name as ASCII bytes\n         *\n         * Gives back empty ACK.\n         */\n        private void handleLock(final long                      threadId,\n                                final int                       reqId,\n                                final ByteList                  payload,\n                                final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() < 4) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n            else {\n                final int length = readInt(payload, 0);\n                final CharSequence name = new HashableSubSequence(payload, 4, length);\n                myLockManager.getExclusiveLockFor(name).lock();\n            }\n\n            // ACK comes back\n            buildMessage(buf.dataOut, MessageType.EMPTY_ACK, threadId, reqId, null);\n        }\n\n        /**\n         * Handle an UNLOCK message.\n         *\n         * This is of the form:\n         *  int32   : lock-name length\n         *  bytes   : lock-name as ASCII bytes\n         *\n         * Gives back empty ACK.\n         */\n        private void handleUnlock(final long                      threadId,\n                                  final int                       reqId,\n                                  final ByteList                  payload,\n                                  final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() < 4) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n            else {\n                final int length = readInt(payload, 0);\n                final CharSequence name = new HashableSubSequence(payload, 4, length);\n                myLockManager.getExclusiveLockFor(name).unlock();\n            }\n\n            // ACK comes back\n            buildMessage(buf.dataOut,\n                         MessageType.EMPTY_ACK,\n                         threadId,\n                         reqId,\n                         null);\n        }\n\n        /**\n         * Handle an INJECT_CLASS message.\n         *\n         * Gives back by deferring to writeTypeDesc().\n         */\n        private void handleInjectClass(final long                      threadId,\n                                       final int                       reqId,\n                                       final ByteList                  payload,\n                                       final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() == 0) {\n                throw new IllegalArgumentException(\"Got an empty payload\");\n            }\n\n            // Disallow class injection?\n            if (!isClassInjectionPermitted()) {\n                throw new SecurityException(\"Class injection not permitted\");\n            }\n\n            // Inject it\n            final Class<?> klass =\n                myClassInjector.inject(payload.toArray(), payload.size());\n\n            // And give it back\n            writeTypeDesc(myTypeMapping.getDescription(klass),\n                          threadId,\n                          reqId,\n                          buf);\n        }\n\n        /**\n         * Handle an INJECT_SOURCE message.\n         *\n         * This is of the form:\n         *  int32   : Class name length\n         *  bytes[] : Class name\n         *  int32   : Source code length\n         *  bytes[] : Source code\n         *\n         * Gives back by deferring to writeTypeDesc().\n         */\n        private void handleInjectSource(final long                      threadId,\n                                        final int                       reqId,\n                                        final ByteList                  payload,\n                                        final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() == 0) {\n                throw new IllegalArgumentException(\"Got an empty payload\");\n            }\n\n            // Disallow source injection? We don't allow this if we don't allow\n            // Java class injection; they are basically the same thing when it\n            // comes to security.\n            if (!isClassInjectionPermitted()) {\n                throw new SecurityException(\"Source injection not permitted\");\n            }\n\n            // Our position in the payload data\n            int offset = 0;\n\n            // Get the class name\n            final int lenClassName = readInt(payload, offset);\n            offset += Integer.BYTES;\n            final StringBuilder sbClassName = new StringBuilder();", "            while (sbClassName.length() < lenClassName) {\n                sbClassName.append((char)payload.get(offset++));\n            }\n            final String className = sbClassName.toString();\n\n            // Get the source code\n            final int lenSource = readInt(payload, offset);\n            offset += Integer.BYTES;\n            final StringBuilder sbSource = new StringBuilder();\n            while (sbSource.length() < lenSource) {\n                sbSource.append((char)payload.get(offset++));\n            }\n            final String source = sbSource.toString();\n\n            // Compile the class and make it available to the JVM\n            final Class<?> klass = mySourceInjector.inject(className, source);\n\n            // And send it back\n            writeTypeDesc(myTypeMapping.getDescription(klass),\n                          threadId,\n                          reqId,\n                          buf);\n        }\n\n        /**\n         * Handle a GET_VALUE_OF message.\n         *\n         * This is of the form:\n         *  int64   : Object handle\n         *  byte    : PythonValueFormat\n         *\n         * Gives back:\n         *  int32    : Number of bytes\n         *  bytes[]  : The pickled form of the object, or each component of a\n         *             {@link JniPJRmi$ArrayHandle}, depending on the specified\n         *             {@link PythonValueFormat}.\n         */\n        private void handleGetValueOf(final long                      threadId,\n                                      final int                       reqId,\n                                      final ByteList                  payload,\n                                      final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            while (sbSource.length() < lenSource) {\n                sbSource.append((char)payload.get(offset++));\n            }\n            final String source = sbSource.toString();\n\n            // Compile the class and make it available to the JVM\n            final Class<?> klass = mySourceInjector.inject(className, source);\n\n            // And send it back\n            writeTypeDesc(myTypeMapping.getDescription(klass),\n                          threadId,\n                          reqId,\n                          buf);\n        }\n\n        /**\n         * Handle a GET_VALUE_OF message.\n         *\n         * This is of the form:\n         *  int64   : Object handle\n         *  byte    : PythonValueFormat\n         *\n         * Gives back:\n         *  int32    : Number of bytes\n         *  bytes[]  : The pickled form of the object, or each component of a\n         *             {@link JniPJRmi$ArrayHandle}, depending on the specified\n         *             {@link PythonValueFormat}.\n         */\n        private void handleGetValueOf(final long                      threadId,\n                                      final int                       reqId,\n                                      final ByteList                  payload,\n                                      final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() != 9) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // The object handle\n            final long handle = readLong(payload, 0);\n\n            // The return format. Make sure it's kosher.\n            final PythonValueFormat valueFormat =\n                PythonValueFormat.byId(payload.get(8));", "            if (valueFormat == null) {\n                throw new IllegalArgumentException(\n                    \"Unknown return format #\" + payload.get(8)\n                );\n\n            }\n            switch (valueFormat) {\n            case RAW_PICKLE:\n            case SNAPPY_PICKLE:\n            case BESTEFFORT_PICKLE:\n            case BESTEFFORT_SNAPPY_PICKLE:\n            case SHMDATA:\n                // These are handled below\n                break;\n\n            default:\n                // Anything else isn't\n                throw new IllegalArgumentException(\n                  \"Unhandled return format `\" + valueFormat + \"`; \" +\n                  \"only Python pickle and SHM-data formats are supported.\"\n                );\n            }\n\n            // Get the object for this handle, allow it to be the null pointer\n            final Object object = myHandleMapping.getObject(handle);", "            if (object == null && handle != HandleMapping.NULL_HANDLE) {\n                throw new IllegalArgumentException(\n                    \"No object for handle \" + handle\n                );\n            }\n\n            // Send result based on return type\n            if (valueFormat == PythonValueFormat.RAW_PICKLE        ||\n                valueFormat == PythonValueFormat.SNAPPY_PICKLE     ||\n                valueFormat == PythonValueFormat.BESTEFFORT_PICKLE ||\n                valueFormat == PythonValueFormat.BESTEFFORT_SNAPPY_PICKLE)\n            {\n                // Convert the result to a payload byte stream\n                renderObject(threadId, reqId, buf, valueFormat, object, null);\n            }", "            else if (valueFormat == PythonValueFormat.SHMDATA) {\n                // Here's where we'll store the information from the write\n                final JniPJRmi.ArrayHandle arrayInfo;\n\n                // Determine the type of the array and write it natively\n                if (object instanceof boolean[]) {\n                    arrayInfo = JniPJRmi.writeArray((boolean[])object);\n                }\n                else if (object instanceof byte[]) {\n                    arrayInfo = JniPJRmi.writeArray((byte[])object);\n                }", "                else if (object instanceof byte[]) {\n                    arrayInfo = JniPJRmi.writeArray((byte[])object);\n                }\n                else if (object instanceof short[]) {\n                    arrayInfo = JniPJRmi.writeArray((short[])object);\n                }\n                else if (object instanceof int[]) {\n                    arrayInfo = JniPJRmi.writeArray((int[])object);\n                }\n                else if (object instanceof long[]) {\n                    arrayInfo = JniPJRmi.writeArray((long[])object);\n                }", "                else if (object instanceof long[]) {\n                    arrayInfo = JniPJRmi.writeArray((long[])object);\n                }\n                else if (object instanceof float[]) {\n                    arrayInfo = JniPJRmi.writeArray((float[])object);\n                }\n                else if (object instanceof double[]) {\n                    arrayInfo = JniPJRmi.writeArray((double[])object);\n                }\n                else {\n                    throw new IllegalArgumentException(\n                      \"Unhandled array type for object: \" +\n                      object.getClass() +\n                      \"`. Only primitive, non-char arrays are supported.\"\n                    );\n                }\n\n                // Write the resulting information\n                writeShmObject(threadId, reqId, buf, arrayInfo.filename,\n                                                     arrayInfo.numElems,\n                                                     arrayInfo.type);\n            }\n            else {\n                throw new IllegalStateException(\"Someone can't code\");\n            }\n        }\n\n        /**\n         * Handle a GET_CALLBACK_HANDLE message.\n         *\n         * This is of the form:\n         *  int32   : Python function ID\n         *  int32   : Java Type ID, or -1\n         *  byte    : Argument count\n         *\n         * Gives back:\n         *  int32    : Function type ID\n         *  bytes[]  : The function type\n         */\n        private void handleGetCallbackHandle(final long                      threadId,\n                                             final int                       reqId,\n                                             final ByteList                  payload,\n                                             final ByteArrayDataOutputStream buf,\n                                             final DataOutputStream          out)\n            throws Throwable\n        {", "            if (payload.size() != 9) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // The object handle\n            final int functionId = readInt(payload, 0);\n            final int typeId     = readInt(payload, 4);\n            final int numArgs    = payload.get(8) & 0xff; // '&' up-casts to int\n\n            // Create the appropriate function wrapper\n            final Object callback;\n            TypeDescription typeDesc = myTypeMapping.getDescription(typeId);", "            if (typeDesc == null) {\n                // Need to guess a function\n                switch (numArgs) {\n                case 1:\n                    final PythonCallbackFunction<?,?> f =\n                        new PythonCallbackFunction<>(functionId, out);\n                    callback = f;\n                    typeDesc = f.getType();\n                    break;\n\n                case 2:\n                    final PythonCallbackBiFunction<?,?,?> bf =\n                        new PythonCallbackBiFunction<>(functionId, out);\n                    callback = bf;\n                    typeDesc = bf.getType();\n                    break;\n\n                default:\n                    final PythonCallback<TypeDescription> c =\n                        new PythonCallback<TypeDescription>(functionId, out)\n                        {", "                            @Override public TypeDescription getType()\n                            {\n                                return myTypeMapping.getDescription(\n                                    PythonKwargsFunction.class\n                                );\n                            }\n                        };\n                    callback = c;\n                    typeDesc = c.getType();\n                    break;\n                }\n            }\n            else {\n                // We should be able to create it directly since we know the\n                // type of the class were are aiming to invoke for.\n                final Class<?> klass = typeDesc.getRepresentedClass();", "                if (Runnable.class.equals(klass)) {\n                    callback = new PythonCallbackRunnable(functionId, out);\n                }\n                else if (Function.class.equals(klass)) {\n                    callback = new PythonCallbackFunction<>(functionId, out);\n                }\n                else if (BiFunction.class.equals(klass)) {\n                    callback = new PythonCallbackBiFunction<>(functionId, out);\n                }\n                else if (Consumer.class.equals(klass)) {\n                    callback = new PythonCallbackConsumer<>(functionId, out);\n                }", "                else if (Consumer.class.equals(klass)) {\n                    callback = new PythonCallbackConsumer<>(functionId, out);\n                }\n                else if (BiConsumer.class.equals(klass)) {\n                    callback = new PythonCallbackBiConsumer<>(functionId, out);\n                }\n                else if (Predicate.class.equals(klass)) {\n                    callback = new PythonCallbackPredicate<>(functionId, out);\n                }\n                else if (BiPredicate.class.equals(klass)) {\n                    callback = new PythonCallbackBiPredicate<>(functionId, out);\n                }", "                else if (BiPredicate.class.equals(klass)) {\n                    callback = new PythonCallbackBiPredicate<>(functionId, out);\n                }\n                else if (UnaryOperator.class.equals(klass)) {\n                    callback = new PythonCallbackUnaryOperator<>(functionId, out);\n                }\n                else if (PythonFunction      .class.equals(klass) ||\n                         PythonKwargsFunction.class.equals(klass))\n                {\n                    callback =\n                        new PythonCallback<TypeDescription>(functionId, out)\n                        {", "                            @Override public TypeDescription getType()\n                            {\n                                return myTypeMapping.getDescription(klass);\n                            }\n                        };\n                }\n                else {\n                    // Okay, we are going to try to inspect the class to see if\n                    // it has a single non-default, non-static, method which\n                    // looks like it might match the one we have been given.\n                    // This is determined by looking at the number of args since\n                    // we can't use anything else (the arg types are unknown and\n                    // the name is irrelevant for lambdas). This is roughly\n                    // similar to what Java does with allowing users to supply\n                    // lambdas for factory classes etc.\n                    final List<MethodDescription> methods = new ArrayList<>();", "                    for (int i=0; i < typeDesc.getNumMethods(); i++) {\n                        // Determine if the method is magically handled by\n                        // PythonLambdaHandler or not. Ideally this would be a\n                        // static method of the class but it's not a static\n                        // class and the current Java version doesn't allow\n                        // static methods in instance classes so...\n                        final MethodDescription method = typeDesc.getMethod(i);\n                        switch (method.getName()) {\n                        case \"getClass\":\n                        case \"equals\":\n                        case \"hashCode\":\n                        case \"notify\":\n                        case \"notifyAll\":\n                        case \"toString\":\n                        case \"wait\":\n                            // Magically handled\n                            break;\n\n                        default:\n                            // Any non-default, non-static method is not handled", "                            if (!method.isDefault() && !method.isStatic()) {\n                                methods.add(method);\n                            }\n                        }\n                    }\n\n                    // Now, see if we got a single method with the right number\n                    // of arguments\n                    if (methods.size() == 1 &&\n                        methods.get(0).getNumArguments() == numArgs)\n                    {\n                        // Okay, we got a match, create a proxy which wraps just\n                        // that method alone\n                        callback =\n                            Proxy.newProxyInstance(\n                                klass.getClassLoader(),\n                                new Class<?>[] { klass },\n                                new PythonLambdaHandler(\n                                    methods.get(0).getName(),\n                                    functionId,\n                                    out\n                                )\n                            );\n                    }\n                    else {\n                        // Failed, say why\n                        throw new UnsupportedOperationException(\n                            \"Can't create a callback wrapper \" +\n                            \"for Python function with \" + numArgs + \" \" +\n                            \"argument\" + (numArgs == 1 ? \"\" : \"s\") + \" \" +\n                            \"for \" + klass + \" \" +\n                            \"with methods: \" + methods\n                        );\n                    }\n                }\n            }\n\n            // Convert the callback, whatever it was, to a payload byte stream\n            // and send it\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            writeObject(bados.dataOut, callback, typeDesc);\n            buildMessage(buf.dataOut,\n                         MessageType.ARBITRARY_ITEM,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a CALLBACK_RESPONSE message.\n         *\n         * This is of the form:\n         *  int32   : Java request ID\n         *  ...     : Arbitrary item\n         *\n         * Gives back:\n         *  Nothing(!)\n         */\n        private void handleCallbackResponse(final long                      threadId,\n                                            final int                       reqId,\n                                            final ByteList                  payload,\n                                            final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "                    if (methods.size() == 1 &&\n                        methods.get(0).getNumArguments() == numArgs)\n                    {\n                        // Okay, we got a match, create a proxy which wraps just\n                        // that method alone\n                        callback =\n                            Proxy.newProxyInstance(\n                                klass.getClassLoader(),\n                                new Class<?>[] { klass },\n                                new PythonLambdaHandler(\n                                    methods.get(0).getName(),\n                                    functionId,\n                                    out\n                                )\n                            );\n                    }\n                    else {\n                        // Failed, say why\n                        throw new UnsupportedOperationException(\n                            \"Can't create a callback wrapper \" +\n                            \"for Python function with \" + numArgs + \" \" +\n                            \"argument\" + (numArgs == 1 ? \"\" : \"s\") + \" \" +\n                            \"for \" + klass + \" \" +\n                            \"with methods: \" + methods\n                        );\n                    }\n                }\n            }\n\n            // Convert the callback, whatever it was, to a payload byte stream\n            // and send it\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            writeObject(bados.dataOut, callback, typeDesc);\n            buildMessage(buf.dataOut,\n                         MessageType.ARBITRARY_ITEM,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Handle a CALLBACK_RESPONSE message.\n         *\n         * This is of the form:\n         *  int32   : Java request ID\n         *  ...     : Arbitrary item\n         *\n         * Gives back:\n         *  Nothing(!)\n         */\n        private void handleCallbackResponse(final long                      threadId,\n                                            final int                       reqId,\n                                            final ByteList                  payload,\n                                            final ByteArrayDataOutputStream buf)\n            throws Throwable\n        {", "            if (payload.size() < 5) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // The Java request ID\n            final int     requestId   = readInt    (payload, 0);\n            final boolean isException = readBoolean(payload, 4);\n            final Object  result      = readObject (payload, 5).object;\n\n            // Give them to the appropriate callback listener, if we can find it\n            final PythonCallbackResult cbr =\n                myPythonCallbackResults.remove(requestId);", "            if (cbr != null) {\n                cbr.setResult(isException, result);\n            }\n            else {\n                LOG.warning(\n                    \"No callback response found for Java request ID \" + requestId\n                );\n            }\n        }\n\n        /**\n         * Handle a GET_PROXY message.\n         *\n         * This is of the form:\n         *  int32   : Python object ID\n         *  int32   : Java Type ID\n         *\n         * Gives back:\n         *  ...     : Arbitrary item (Proxy instance)\n         */\n        private void handleGetProxy(final long                      threadId,\n                                    final int                       reqId,\n                                    final ByteList                  payload,\n                                    final ByteArrayDataOutputStream buf,\n                                    final DataOutputStream          out)\n            throws Throwable\n        {", "            if (payload.size() != 8) {\n                throw new IllegalArgumentException(\n                    \"Got a malformed payload: \" + PJRmi.toString(payload)\n                );\n            }\n\n            // The object handle\n            final int objectId = readInt(payload, 0);\n            final int typeId   = readInt(payload, 4);\n\n            // Grab the type\n            final TypeDescription typeDesc = myTypeMapping.getDescription(typeId);", "            if (typeDesc == null) {\n                throw new IllegalArgumentException(\"Unknown type ID: \" + typeId);\n            }\n            final Class<?> klass = typeDesc.getRepresentedClass();\n\n            // We can create the proxy now\n            final Object proxy =\n                Proxy.newProxyInstance(\n                    klass.getClassLoader(),\n                    new Class<?>[] { klass },\n                    new PythonProxyHandler(objectId, out)\n                );\n\n            // And send it back\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();\n            writeObject(bados.dataOut, proxy, typeDesc);\n            buildMessage(buf.dataOut,\n                         MessageType.ARBITRARY_ITEM,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n        /**\n         * Write a type description message into the given buffer.\n         *\n         * Gives back:\n         *  int32    : Type ID, or -1 then nothing else if the type was not found\n         *  int32    : Name length\n         *  byte[]   : Name\n         *  int32    : TypeFlags as int\n         *  int32    : The type ID of the array element type, or -1 if not an array\n         *  int32    : Number of super-type IDs\n         *  types[]  :\n         *    int32    : Type ID\n         *  int32    : Number of fields\n         *  Field[]  :\n         *    int32    : Field name length\n         *    byte[]   : Field name\n         *    int32    : Type ID\n         *  int32    : Number of constructors\n         *  CTOR[]   :\n         *    int16    : Flags\n         *    int16    : Number of arguments\n         *    Param[]  :\n         *      int32    : Argument type ID\n         *      int32    : Parameter name length\n         *      byte[]   : Parameter name\n         *    byte[]   : Relative specificities\n         *  int32    : Number of methods\n         *  Method[] :\n         *    int32    : Method name length\n         *    byte[]   : Method name\n         *    int16    : Flags\n         *    int32    : Return type ID\n         *    int16    : Number of arguments\n         *    Param[]  :\n         *      int32    : Argument type ID\n         *      int32    : Parameter name length\n         *      byte[]   : Parameter name\n         *    byte[]   : Relative specificities\n         */\n        private void writeTypeDesc(final TypeDescription           desc,\n                                   final long                      threadId,\n                                   final int                       reqId,\n                                   final ByteArrayDataOutputStream buf)\n            throws IOException\n        {\n            // Look up the description\n            final ByteArrayDataOutputStream bados = ourByteOutBuffer.get();", "            if (desc == null) {\n                bados.dataOut.writeInt(-1);\n            }\n            else {\n                bados.dataOut.writeInt(desc.getTypeId());\n\n                final String typeName = desc.getName();\n                bados.dataOut.writeInt  (typeName.length());\n                bados.dataOut.writeBytes(typeName);\n                bados.dataOut.writeInt  (desc.getFlagsValue());\n\n                final Class<?> elementType = desc.getArrayComponentType();", "                if (elementType == null) {\n                    bados.dataOut.writeInt(-1);\n                }\n                else {\n                    bados.dataOut.writeInt(\n                        myTypeMapping.getDescription(elementType).getTypeId()\n                    );\n                }\n\n                bados.dataOut.writeInt(desc.getNumSupertypes());\n                for (int i=0; i < desc.getNumSupertypes(); i++) {\n                    bados.dataOut.writeInt(desc.getSupertypeId(i));\n                }\n\n                bados.dataOut.writeInt(desc.getNumFields());", "                for (int i=0; i < desc.getNumSupertypes(); i++) {\n                    bados.dataOut.writeInt(desc.getSupertypeId(i));\n                }\n\n                bados.dataOut.writeInt(desc.getNumFields());\n                for (int i=0; i < desc.getNumFields(); i++) {\n                    final FieldDescription field = desc.getField(i);\n                    final String fieldName = field.getName();\n                    bados.dataOut.writeInt    (fieldName.length());\n                    bados.dataOut.writeBytes  (fieldName);\n                    bados.dataOut.writeInt    (field.getType().getTypeId());\n                    bados.dataOut.writeBoolean(field.isStatic());\n                }\n\n                bados.dataOut.writeInt(desc.getNumConstructors());", "                for (int i=0; i < desc.getNumConstructors(); i++) {\n                    final MethodDescription ctor = desc.getConstructor(i);\n\n                    bados.dataOut.writeShort(ctor.getFlags());\n\n                    bados.dataOut.writeShort(ctor.getNumArguments());\n                    for (short j=0; j < ctor.getNumArguments(); j++) {\n                        final String parameterName = ctor.getParameterName(j);\n                        bados.dataOut.writeInt(ctor.getArgument(j).getTypeId());\n                        bados.dataOut.writeInt(parameterName.length());\n                        bados.dataOut.writeBytes(parameterName);\n                    }\n\n                    bados.dataOut.writeInt(desc.getNumConstructors());", "                    for (int j=0; j < desc.getNumConstructors(); j++) {\n                        bados.dataOut.write(\n                            desc.getRelativeConstructorSpecificity(i, j)\n                        );\n                    }\n                }\n\n                bados.dataOut.writeInt(desc.getNumMethods());\n                for (int i=0; i < desc.getNumMethods(); i++) {\n                    final MethodDescription method = desc.getMethod(i);\n\n                    final String methodName = method.getName();\n                    bados.dataOut.writeInt  (methodName.length());\n                    bados.dataOut.writeBytes(methodName);\n\n                    bados.dataOut.writeShort(method.getFlags());\n\n                    bados.dataOut.writeInt(method.getReturnType().getTypeId());\n\n                    bados.dataOut.writeShort(method.getNumArguments());", "                for (int i=0; i < desc.getNumMethods(); i++) {\n                    final MethodDescription method = desc.getMethod(i);\n\n                    final String methodName = method.getName();\n                    bados.dataOut.writeInt  (methodName.length());\n                    bados.dataOut.writeBytes(methodName);\n\n                    bados.dataOut.writeShort(method.getFlags());\n\n                    bados.dataOut.writeInt(method.getReturnType().getTypeId());\n\n                    bados.dataOut.writeShort(method.getNumArguments());", "                    for (short j=0; j < method.getNumArguments(); j++) {\n                        final String parameterName = method.getParameterName(j);\n                        bados.dataOut.writeInt(method.getArgument(j).getTypeId());\n                        bados.dataOut.writeInt(parameterName.length());\n                        bados.dataOut.writeBytes(parameterName);\n                    }\n\n                    bados.dataOut.writeInt(desc.getNumMethods());\n                    for (int j=0; j < desc.getNumMethods(); j++) {\n                        bados.dataOut.write(\n                            desc.getRelativeMethodSpecificity(i, j)\n                        );\n                    }\n                }\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.TYPE_DESCRIPTION,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Read a boolean from a ByteList.\n         */\n        private boolean readBoolean(ByteList bytes, int offset)\n        {\n            return (bytes.get(offset) != 0);\n        }\n\n        /**\n         * Read a short from a ByteList.\n         */\n        private short readShort(ByteList bytes, int offset)\n        {\n            return (short) ((Byte.toUnsignedInt(bytes.get(offset++)) << 8) |\n                            (Byte.toUnsignedInt(bytes.get(offset++))     ));\n        }\n\n        /**\n         * Read an integer from a ByteList.\n         */\n        private int readInt(ByteList bytes, int offset)\n        {\n            return (Byte.toUnsignedInt(bytes.get(offset++)) << 24) |\n                   (Byte.toUnsignedInt(bytes.get(offset++)) << 16) |\n                   (Byte.toUnsignedInt(bytes.get(offset++)) <<  8) |\n                   (Byte.toUnsignedInt(bytes.get(offset++))      );\n        }\n\n        /**\n         * Read a long from a ByteList.\n         */\n        private long readLong(ByteList bytes, int offset)\n        {\n            return (Byte.toUnsignedLong(bytes.get(offset++)) << 56) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 48) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 40) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 32) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 24) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 16) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) <<  8) |\n                   (Byte.toUnsignedLong(bytes.get(offset++))      );\n        }\n\n        /**\n         * Await the response from a Python callback.\n         */\n        private <T> T awaitCallbackReponse(final PythonCallbackResult result)\n            throws PythonCallbackException\n        {\n            // Loop until we get it back", "                    for (int j=0; j < desc.getNumMethods(); j++) {\n                        bados.dataOut.write(\n                            desc.getRelativeMethodSpecificity(i, j)\n                        );\n                    }\n                }\n            }\n            buildMessage(buf.dataOut,\n                         MessageType.TYPE_DESCRIPTION,\n                         threadId,\n                         reqId,\n                         bados.bytes);\n        }\n\n        /**\n         * Read a boolean from a ByteList.\n         */\n        private boolean readBoolean(ByteList bytes, int offset)\n        {\n            return (bytes.get(offset) != 0);\n        }\n\n        /**\n         * Read a short from a ByteList.\n         */\n        private short readShort(ByteList bytes, int offset)\n        {\n            return (short) ((Byte.toUnsignedInt(bytes.get(offset++)) << 8) |\n                            (Byte.toUnsignedInt(bytes.get(offset++))     ));\n        }\n\n        /**\n         * Read an integer from a ByteList.\n         */\n        private int readInt(ByteList bytes, int offset)\n        {\n            return (Byte.toUnsignedInt(bytes.get(offset++)) << 24) |\n                   (Byte.toUnsignedInt(bytes.get(offset++)) << 16) |\n                   (Byte.toUnsignedInt(bytes.get(offset++)) <<  8) |\n                   (Byte.toUnsignedInt(bytes.get(offset++))      );\n        }\n\n        /**\n         * Read a long from a ByteList.\n         */\n        private long readLong(ByteList bytes, int offset)\n        {\n            return (Byte.toUnsignedLong(bytes.get(offset++)) << 56) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 48) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 40) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 32) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 24) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) << 16) |\n                   (Byte.toUnsignedLong(bytes.get(offset++)) <<  8) |\n                   (Byte.toUnsignedLong(bytes.get(offset++))      );\n        }\n\n        /**\n         * Await the response from a Python callback.\n         */\n        private <T> T awaitCallbackReponse(final PythonCallbackResult result)\n            throws PythonCallbackException\n        {\n            // Loop until we get it back", "            while (true) {\n                if (result.isReady()) {\n                    final Object pythonResult = result.getResult();\n                    if (LOG.isLoggable(Level.FINEST)) {\n                        LOG.finest(\n                            \"Result was \" +\n                            pythonResult + \" \" +\n                            (pythonResult == null ? \"\" : pythonResult.getClass())\n                        );\n                    }\n\n                    // Either throw or return, depending", "                    if (result.isException()) {\n                        final Throwable t = (Throwable)pythonResult;\n                        throw new PythonCallbackException(t.getMessage(), t);\n                    }\n                    else {\n                        @SuppressWarnings(\"unchecked\")\n                        final T pr = (T)pythonResult;\n                        return pr;\n                    }\n                }\n                else {\n                    // Busy-ish wait\n                    LockSupport.parkNanos(1000);\n                }\n            }\n        }\n\n        /**\n         * Return a proxy interface, targeting the given interface class, by\n         * using the given method.\n         */", "        public Object getProxyForMethod(final Class<?> iface,\n                                        final TypeDescription typeDesc,\n                                        final MethodDescription methodDesc,\n                                        final boolean isConstructor,\n                                        final Object instance)\n        {\n            // Make sure everything is in order\n            Objects.requireNonNull(iface);\n            Objects.requireNonNull(typeDesc);\n            Objects.requireNonNull(methodDesc);\n\n            // We will build a proxy for the given interface class. For this we\n            // will need a handler.\n            final InvocationHandler handler =\n                new InvocationHandler() {", "                    public Object invoke(final Object proxy,\n                                         final Method method,\n                                         final Object[] args)\n                        throws Throwable\n                    {\n                        // Determine the arguments which we are passing along\n                        final Object   callInst;\n                        final Object[] callArgs;\n                        if (methodDesc.isStatic() || isConstructor) {\n                            // This is a static method. Hence we will always\n                            // pass in null as the first argument to its\n                            // invocation and the call args are just passed\n                            // through.\n                            callInst = null;\n                            callArgs = args;\n                        }", "                        if (methodDesc.isStatic() || isConstructor) {\n                            // This is a static method. Hence we will always\n                            // pass in null as the first argument to its\n                            // invocation and the call args are just passed\n                            // through.\n                            callInst = null;\n                            callArgs = args;\n                        }\n                        else if (instance == null) {\n                            // This is an instance method the method which we\n                            // have was not bound to any particular instance.\n                            // The first argument is thus the instance. E.g.\n                            // map(values, Integer::toString).", "                        else if (instance == null) {\n                            // This is an instance method the method which we\n                            // have was not bound to any particular instance.\n                            // The first argument is thus the instance. E.g.\n                            // map(values, Integer::toString).\n                            if (args == null || args.length == 0) {\n                                throw new IllegalArgumentException(\n                                    \"Given no arguments to instance method call \" +\n                                    method.getName() + \" but need an instance\"\n                                );\n                            }\n                            callInst = args[0];\n                            callArgs =\n                                (args.length == 1)\n                                ? EMPTY_OBJECTS // Avoid creating empty arrays\n                                : Arrays.copyOfRange(args, 1, args.length);\n                        }\n                        else {\n                            // We have an instance so use that, and just pass\n                            // through the arguments. We could roll this into\n                            // the first if block but (I assert without proof\n                            // that) it's clearer this way.\n                            callInst = instance;\n                            callArgs = args;\n                        }\n\n                        // Do a bit of brief checking to make sure that the\n                        // method being called looks vaguely compatible with the\n                        // one which we're about to invoke. We'll catch any true\n                        // problems when we actually come to invoke the method.\n                        //\n                        // First, check that we are not trying to get a value\n                        // out of a function which has a void return type.\n                        final Class<?> returnType =\n                            methodDesc.getReturnType().getRepresentedClass();", "                        if (!Void.TYPE.equals(method.getReturnType()) &&\n                            Void.TYPE.equals(returnType))\n\n                        {\n                            throw new InvocationTargetException(\n                                new IllegalArgumentException(\n                                    \"Functional method, \" + method + \", \" +\n                                    \"expects to return a \" +\n                                    method.getReturnType() + \" \" +\n                                    \"but target method, \" + methodDesc + \", \" +\n                                    \"is void\"\n                                )\n                            );\n                        }\n                        // Second, check that the number of arguments looks okay\n                        final int numCallArgs =\n                            (callArgs == null) ? 0 : callArgs.length;", "                        if (numCallArgs != methodDesc.getNumArguments()) {\n                            throw new InvocationTargetException(\n                                new IllegalArgumentException(\n                                    \"Functional method, \" + method + \", \" +\n                                    \"was given \" + numCallArgs + \" \" +\n                                    \"argument\" + (numCallArgs == 1 ? \" \" : \"s \") +\n                                    \"but target method, \" + methodDesc + \", \" +\n                                    \"takes \" + methodDesc.getNumArguments()\n                                )\n                            );\n                        }\n\n                        // Now attempt to invoke it", "                        try {\n                            return isConstructor\n                                ? typeDesc.callConstructor(methodDesc.getIndex(),\n                                                           callArgs)\n                                : typeDesc.callMethod     (methodDesc.getIndex(),\n                                                           callInst,\n                                                           callArgs);\n                        }\n                        catch (Throwable t) {\n                            // Give a decent message back\n                            final String inst;", "                            if (callInst == null) {\n                                inst = \"\";\n                            }\n                            else {\n                                inst = \"on \" + callInst + \" \" +\n                                       \"<\" + callInst.getClass() + \"> \";\n                            }\n\n                            // And throw\n                            throw new InvocationTargetException(\n                                t,\n                                \"Failed to call \" +\n                                (methodDesc.isStatic() ? \"static \" : \"\") +\n                                \"method \" +\n                                typeDesc.getName() + \"::\" +\n                                methodDesc.getName() + \" \" + inst +\n                                \"with arguments \" +\n                                Arrays.toString(callArgs) + \" \" +\n                                \"via \" +\n                                iface.getSimpleName() + \"::\" + method.getName()\n                            );\n                        }\n                    }\n                };\n\n            // Now it's easy to make the proxy class\n            return Proxy.newProxyInstance(iface.getClassLoader(),\n                                          new Class<?>[] { iface },\n                                          handler);\n        }\n    }\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Render a ByteList as a string, converting non-ASCII chars to sensible\n     * printed values.\n     */\n    private static String toString(final ByteList bytes)\n    {\n        StringBuilder sb = ourByteListStringBuilder.get();\n\n        sb.append('<');", "        for (int i=0; i < bytes.size(); i++) {\n            final byte b = bytes.getNoCheck(i);\n            if (b < (byte)' ' || b > (byte)'~') {\n                sb.append(\"\\\\x\");\n                appendHexByte(sb, b);\n            }\n            else if (b == '\\\\') {\n                // Since we use '\\' as an escape char we also need to escape it.\n                // That makes cutting and pasting strings into python easier.\n                sb.append(\"\\\\\\\\\");\n            }\n            else {\n                sb.append((char)b);\n            }\n        }\n        sb.append('>');\n\n        return sb.toString();\n    }\n    private static final ThreadLocalStringBuilder ourByteListStringBuilder =\n        new ThreadLocalStringBuilder(1024);\n\n    /**\n     * Render a byte[] as a string, converting non-ASCII chars to readable\n     * printed values.\n     */\n    private static String toString(final byte[] bytes)\n    {\n        StringBuilder sb = ourByteArrayStringBuilder.get();\n\n        sb.append('<');", "        for (byte b : bytes) {\n            if (b < (byte)' ' || b > (byte)'~') {\n                sb.append(\"\\\\x\");\n                appendHexByte(sb, b);\n            }\n            else {\n                sb.append((char)b);\n            }\n        }\n        sb.append('>');\n\n        return sb.toString();\n    }\n    private static final ThreadLocalStringBuilder ourByteArrayStringBuilder =\n        new ThreadLocalStringBuilder(1024);\n\n    /**\n     * Send a UTF16 string over the wire.\n     *\n     * <p>This method is needed because the DataOutputStream writeUTF() method\n     * doesn't handle Strings longer than 64k in size(!) and is also a tad\n     * inefficient and garbagy.\n     *\n     * <p>The format of data is an int32 denoting the length, followed by the\n     * UTF16 bytes representing the chars.\n     *\n     * <p>See http://www.ietf.org/rfc/rfc2781.txt for more information\n     */\n    private static void writeUTF16(DataOutputStream out, String string)\n        throws IOException\n    {\n        // We need to know the length of the string we are about to write out so\n        // as to make sure that our buffer will be big enough.\n        final int len = string.length();\n\n        // The buffer must be big enough for a pathological UTF string, with 4\n        // bytes at the front for the length\n        final byte[] buffer = getByteArray(len * 4 + 4);\n\n        // Pointer into the buffer for stuffing in the string's chars. This\n        // starts 4 bytes in so as to leave room for the size at the front.\n        int index = 4;\n\n        // First we insert the byte-order mark so that the other side knows how\n        // to decode the data. See section 3.2 of the RFC.\n        buffer[index++] = (byte)0xfe;\n        buffer[index++] = (byte)0xff;\n\n        // Copy the data into our buffer", "        for (int i=0; i < len; i++) {\n            // How we handle the various UTF16 encodings. See section 2.1 in RFC2781:\n            //   https://www.ietf.org/rfc/rfc2781.txt\n            final char u = string.charAt(i);\n            if (u < 0x10000) {\n                buffer[index++] = (byte)((u >> 8) & 0xff);\n                buffer[index++] = (byte)((u     ) & 0xff);\n            }\n            else {\n                final int uu = (int)u - 0x10000;\n                final int w1 = 0xd800 | ((uu >> 10) & 0x3ff);\n                final int w2 = 0xdc00 | ((uu      ) & 0x3ff);\n                buffer[index++] = (byte)((w1 >> 8) & 0xff);\n                buffer[index++] = (byte)((w1     ) & 0xff);\n                buffer[index++] = (byte)((w2 >> 8) & 0xff);\n                buffer[index++] = (byte)((w2     ) & 0xff);\n            }\n        }\n\n        // Now we know the number of bytes which make up the string\n        // representation. Write this into the start of the buffer (network\n        // byte-order).\n        final int sz = (index - 4);\n        buffer[0] = (byte)((sz >>> 24) & 0xff);\n        buffer[1] = (byte)((sz >>> 16) & 0xff);\n        buffer[2] = (byte)((sz >>>  8) & 0xff);\n        buffer[3] = (byte)((sz       ) & 0xff);\n\n        // And, finally, we can send it out over the wire\n        out.write(buffer, 0, index);\n    }\n\n    /**\n     * Get a thread-local byte[] of at least the given size.\n     */\n    private static byte[] getByteArray(final int size)\n    {\n        byte[] buffer = ourThreadLocalByteBuffer.get();", "        if (buffer.length < size) {\n            // Need a bigger buffer, with 10% overhead to prevent malloc\n            // thrashing over time\n            buffer = new byte[(int)(size * 1.1)];\n            ourThreadLocalByteBuffer.set(buffer);\n        }\n        return buffer;\n    }\n    private static final ThreadLocal<byte[]> ourThreadLocalByteBuffer =\n        new ThreadLocal<byte[]>()\n        {\n            @Override\n            protected byte[] initialValue()\n            {\n                // 640k^H^H^H^H1Mb should be enough for anyone\n                return new byte[1024 * 1024];\n            }\n        };\n\n    /**\n     * Sort the given Methods into a reasonable ordering. This is the\n     * entry-point to the actual methodSort().\n     *\n     * <p>See the JavaDoc of MethodComparator for caveats.\n     */\n    private static void methodSort(final Method[] methods)\n    {\n        // Duplicate the input and sort _that duplicate_ back into the original\n        // input. Hand off the recursive call directly.\n        final int length = methods.length;\n        methodSort(Arrays.copyOf(methods, length), methods, 0, length);\n    }\n\n    /**\n     * The recursive step of methodSort(), which is a form of merge-sort.\n     *\n     * <p>Do not call this directly.\n     */\n    private static void methodSort(final Method[] src,\n                                   final Method[] dst,\n                                   final int      low,\n                                   final int      high)\n    {\n        final int length = high - low;\n\n        // If we have fewer than two elements then we're trivially done", "        if (length < 2) {\n            return;\n        }\n\n        // The recursion step\n        final int mid = (low + high) >>> 1;\n        methodSort(dst, src, low, mid);\n        methodSort(dst, src, mid, high);\n\n        // And the merge step\n        for (int i = low, j = low, k = mid; i < high; i++) {", "        for (int i = low, j = low, k = mid; i < high; i++) {\n            if (k >= high ||\n                j < mid && MethodComparator.INSTANCE.compare(src[j], src[k]) <= 0)\n            {\n                dst[i] = src[j++];\n            }\n            else {\n                dst[i] = src[k++];\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * The default collection of classes required for the basic PJRmi code to\n     * function (i.e. this is what the Python code relies on). This can be used\n     * as a basis for users wanting to create their own allowlists.\n     *\n     * <p>The idea is that the allowlist should not have classes in it which\n     * would allow privilege escalation by a PJRmi client. (I.e. things which\n     * let them run binaries, access files, etc.)\n     *\n     * <p><b>THINK VERY CAREFULLY BEFORE ADDING ANY CLASSES TO THIS LIST!</b>\n     */\n    private static final Collection<String> DEFAULT_CLASS_NAME_ALLOWLIST =\n        Collections.unmodifiableList(\n            Arrays.asList(\n                // Primitive types\n                \"boolean\",\n                \"byte\",\n                \"char\",\n                \"double\",\n                \"float\",\n                \"int\",\n                \"long\",\n                \"short\",\n                \"void\",\n\n                // Arrays\n                \"[B\",\n                \"[C\",\n                \"[D\",\n                \"[F\",\n                \"[I\",\n                \"[J\",\n                \"[Ljava.lang.Object;\",\n                \"[Ljava.lang.String;\",\n                \"[S\",\n                \"[Z\",\n\n                // Classes\n                \"com.deshaw.pjrmi.JavaProxyBase\",\n                \"com.deshaw.pjrmi.PythonFunction\",\n                \"com.deshaw.pjrmi.PythonKwargsFunction\",\n                \"com.deshaw.pjrmi.PythonObject\",\n                \"com.deshaw.pjrmi.PythonSlice\",\n                \"com.deshaw.util.StringUtil\",\n\n                \"java.lang.AutoCloseable\",\n                \"java.lang.Boolean\",\n                \"java.lang.Byte\",\n                \"java.lang.Character\",\n                \"java.lang.ClassNotFoundException\",\n                \"java.lang.Comparable\",\n                \"java.lang.Double\",\n                \"java.lang.Exception\",\n                \"java.lang.Float\",\n                \"java.lang.Integer\",\n                \"java.lang.Iterable\",\n                \"java.lang.Long\",\n                \"java.lang.NoSuchFieldException\",\n                \"java.lang.NoSuchMethodException\",\n                \"java.lang.Number\",\n                \"java.lang.Object\",\n                \"java.lang.Short\",\n                \"java.lang.String\",\n\n                \"java.util.Collection\",\n                \"java.util.Iterator\",\n                \"java.util.List\",\n                \"java.util.Map\",\n                \"java.util.Map$Entry\",\n                \"java.util.NoSuchElementException\",\n                \"java.util.Set\",\n                \"java.util.concurrent.Future\",\n                \"java.util.function.BiFunction\",\n                \"java.util.function.Function\",\n                \"java.util.logging.Level\",\n                \"java.util.logging.LogManager\",\n\n                \"sun.misc.Signal\"\n            )\n        );\n\n    /**\n     * Our default logger.\n     */\n    /*package*/ static final Logger LOG = Logger.getLogger(\"com.deshaw.pjrmi.PJRmi\");\n\n    /**\n     * The handshake string, this should have the same value as the one in the\n     * Python code. The major and minor version numbers should match the\n     * {@code pjrmiVersion} values in {@code gradle.properties}. Typically the\n     * minor version number should change whenever the wire format changes.\n     */\n    private static final String HELLO = \"PJRMI_1.11\";\n\n    /**\n     * The request ID to use for callbacks (which are unsolicited from Python's\n     * point of view).\n     */\n    private static final int CALLBACK_REQUEST_ID = -1;\n\n    /**\n     * The methods in an Object.\n     */\n    private static final List<Method> OBJECT_METHODS =\n        Collections.unmodifiableList(\n            Arrays.asList(Object.class.getMethods())\n        );\n\n    /**\n     * How much we're allowed to recurse from Java to Python to Java before we\n     * decide it's too much. Note that each level of recursion is a new thread\n     * so we can't make this <i>too</i> big.\n     */\n    private static final int MAX_CALL_DEPTH = 128;\n\n    /**\n     * The global XOR value to use then creating thread IDs. This mimics the\n     * code on the Python side.\n     */\n    private final long THREAD_ID_XOR = new Random().nextLong() & 0x7fffffffffffffffL;\n\n    /**\n     * An empty {@code Object[]}, so we don't create pointless ones.\n     */\n    private static final Object[] EMPTY_OBJECTS = new Object[0];\n\n    /**\n     * The byte buffers used to build up the output messages. Always returned\n     * empty.\n     */\n    private static final ThreadLocal<ByteArrayDataOutputStream> ourByteOutBuffer =\n        new ThreadLocalByteArrayDataOutputStream();\n\n    /**\n     * Our per-thread PythonPicklers, for converting values to pickle format.\n     */\n    private static final ThreadLocal<PythonPickle> ourPythonPickle =\n        ThreadLocal.withInitial(PythonPickle::new);\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Where connections come in.\n     */\n    private final Transport.Provider myTransportProvider;\n\n    /**\n     * The name of this instance.\n     */\n    private final String myName;\n\n    /**\n     * How we index the connections.\n     */\n    private int myConnectionIndex;\n\n    /**\n     * A flag is used to notify the driver thread to stop its processing.\n     */\n    private final AtomicBoolean myIsClosed;\n\n    /**\n     * Our type mappings. These are shared by all connections.\n     */\n    private final TypeMapping myTypeMapping;\n\n    /**\n     * Our class injector.\n     */\n    private final ClassInjector myClassInjector;\n\n    /**\n     * Our source injector.\n     */\n    private final SourceInjector mySourceInjector;\n\n    /**\n     * Our lock manager instance.\n     */\n    private final PJRmiLockManager myLockManager;\n\n    /**\n     * The Instrumentors for this instance, keyed by MessageType ordinal.\n     */\n    private final Instrumentor[] myInstrumentors;\n\n    /**\n     * The instrumentor for the readObject() method.\n     */\n    private final Instrumentor myReadObjectInstrumentor;\n\n    /**\n     * The instrumentor for the writeObject() method.\n     */\n    private final Instrumentor myWriteObjectInstrumentor;\n\n    /**\n     * Whether to use SHM copying.\n     */\n    private final boolean myUseShmdata;\n\n    /**\n     * The collection of classes which the user is allowed to get using a\n     * TYPE_REQUEST. If this is null then all classes are permitted.\n     *\n     * <p>The idea is that the allowlist should not have classes in it which\n     * would allow privilege escalation by a PJRmi client. (I.e. things which\n     * let them run binaries, access files, etc.)\n     *\n     * <p>By default this collection is used by the {@link #isClassPermitted(CharSequence)}\n     * method in order to determine what's allowed. If that method is overridden\n     * then this collection's purpose may become moot.\n     *\n     * <p>Likewise, if {@link isClassBlockingOn} is {@code false}, this\n     * collection's purpose is moot.\n     */\n    private final Collection<String> myClassNameAllowlist;\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * CTOR.\n     *\n     * @param name     The name of this instance.\n     * @param provider How we get connections from the outside world.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public PJRmi(final String name, final Transport.Provider provider)\n        throws IOException\n    {\n        this(name, provider, false);\n    }\n\n    /**\n     * CTOR.\n     *\n     * @param name           The name of this instance.\n     * @param provider       How we get connections from the outside world.\n     * @param useGlobalLock  Whether to instantiate the global lock for all\n     *                       method calls from Python etc.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public PJRmi(final String             name,\n                 final Transport.Provider provider,\n                 final boolean            useGlobalLock)\n        throws IOException\n    {\n        this(name, provider, useGlobalLock, null);\n    }\n\n    /**\n     * CTOR.\n     *\n     * @param name           The name of this instance.\n     * @param provider       How we get connections from the outside world.\n     * @param useGlobalLock  Whether to instantiate the global lock for all\n     *                       method calls from Python etc.\n     * @param useShmdata     Whether to use SHM copying.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public PJRmi(final String             name,\n                 final Transport.Provider provider,\n                 final boolean            useGlobalLock,\n                 final boolean            useShmdata)\n        throws IOException\n    {\n        this(name, provider, useGlobalLock, useShmdata, null);\n    }\n\n    /**\n     * CTOR.\n     *\n     * @param name         The name of this instance.\n     * @param provider     How we get connections from the outside world.\n     * @param lockManager  The LockManager to be used for this PJRmi instance.\n     *\n     * @throws IOException if there was a problem.\n     */\n    public PJRmi(final String             name,\n                 final Transport.Provider provider,\n                 final PJRmiLockManager   lockManager)\n        throws IOException\n    {\n        // See private constructor for semantics when providing\n        // both a non-null lockManager and a value for useGlobalLock.\n        this(name, provider, false, Objects.requireNonNull(lockManager));\n    }\n\n    /**\n     * CTOR.\n     *\n     * SHM value passing disabled by default.\n     *\n     * @param name           The name of this instance.\n     * @param provider       How we get connections from the outside world.\n     * @param useGlobalLock  Whether to instantiate the global lock for all\n     *                       method calls from Python etc.  Ignored if\n     *                       lockManager is non-null (inherits the value\n     *                       from the provided lockManager).\n     * @param lockManager    The LockManager to use for this PJRmi instance\n     *                       (null if a new lockManager should be created).\n     *\n     * @throws IOException if there was a problem.\n     */\n    private PJRmi(final String             name,\n                  final Transport.Provider provider,\n                  final boolean            useGlobalLock,\n                  final PJRmiLockManager   lockManager)\n        throws IOException\n    {\n        this(name, provider, useGlobalLock, false, lockManager);\n    }\n\n    /**\n     * CTOR.\n     *\n     * Alternative PJRmi constructor to allow a lock manager\n     * to be passed in so that this PJRmi instance can share a lock\n     * with other instances.\n     *\n     * This constructor is private to hide a potentially confusing semantic\n     * from users, in the case that this constructor is invoked with a\n     * non-null lockManager with a value for useGlobalLock that is different\n     * from the value for useGlobalLock passed into this method.  The\n     * behavior would be undefined and hence is hidden so that these parameters\n     * will be consistent.\n     *\n     * @param name           The name of this instance.\n     * @param provider       How we get connections from the outside world.\n     * @param useGlobalLock  Whether to instantiate the global lock for all\n     *                       method calls from Python etc. Ignored if\n     *                       lockManager is non-{@code null} (inherits the value\n     *                       from the provided lockManager).\n     * @param lockManager    The LockManager to use for this PJRmi instance\n     *                       ({@code null} if a new lockManager should be\n     *                       created).\n     *\n     * @throws IOException if there was a problem.\n     */\n    private PJRmi(final String             name,\n                  final Transport.Provider provider,\n                  final boolean            useGlobalLock,\n                  final boolean            useShmdata,\n                  final PJRmiLockManager   lockManager)\n        throws IOException\n    {\n        // Set up our thread nicely\n        super(name);\n        setDaemon(true);\n\n        // Very simply, create the connection and set it running; we make it\n        // 'active' when start() is called.\n        myTransportProvider = provider;\n        myName = name + \":\" + provider;\n        myUseShmdata = useShmdata && JniPJRmi.isAvailable();\n        myConnectionIndex = 0;", "        if (lockManager == null) {\n            myLockManager = new PJRmiLockManager(useGlobalLock);\n        }\n        else {\n            myLockManager = lockManager;\n        }\n        myIsClosed = new AtomicBoolean(false);\n        myTypeMapping = new TypeMapping();\n        myClassInjector = new ClassInjector();\n        mySourceInjector = new SourceInjector();\n\n        // Keep track of how long things are taking etc.\n        myReadObjectInstrumentor  = getInstrumentor(myName + \":readObject()\");\n        myWriteObjectInstrumentor = getInstrumentor(myName + \":writeObject()\");\n        final MessageType[] types = MessageType.values();\n        myInstrumentors = new Instrumentor[types.length];", "        for (MessageType type : types) {\n            Instrumentor instr = getInstrumentor(myName + \":\" + type);\n            myInstrumentors[type.ordinal()] = instr;\n\n            // Set the interval mods to reflect how much we expect things to be\n            // called. For some things we expect a lot of calls, for some we\n            // expect very few.\n            switch (type) {\n            case INSTANCE_REQUEST:\n            case TYPE_REQUEST:\n            case GET_CALLBACK_HANDLE:\n                instr.setIntervalMod(1);\n                break;\n\n            case ARBITRARY_ITEM:\n            case METHOD_CALL:\n                instr.setIntervalMod(1000);\n                break;\n\n            default:\n                instr.setIntervalMod(10);\n                break;\n            }\n        }\n\n        // Figure out the class-name allowlist\n        Collection<String> allowlist = getClassNameAllowlist();", "        if (allowlist != null) {\n            allowlist = Collections.unmodifiableSet(new HashSet<>(allowlist));\n        }\n        myClassNameAllowlist = allowlist;\n    }\n\n    /**\n     * Get a handle on the lock manager.\n     *\n     * @return the lock manager.\n     */", "    public PJRmiLockManager getLockManager()\n    {\n        return myLockManager;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void run()\n    {\n        // Say we're up and running\n        LOG.info(myName + \" \" +\n                 \"Listening for connections with \" + myTransportProvider);\n\n        // Keep accepting connections as they arrive and spawn a new handler\n        // thread for each one", "    public void run()\n    {\n        // Say we're up and running\n        LOG.info(myName + \" \" +\n                 \"Listening for connections with \" + myTransportProvider);\n\n        // Keep accepting connections as they arrive and spawn a new handler\n        // thread for each one\n        while (!myIsClosed.get()) {\n            try {\n                awaitConnection();\n            }\n            catch (IOException|SecurityException e) {\n                LOG.log(Level.INFO, \"Failed to establish connection\", e);\n\n                // If the reason for the failure was that the provider has been\n                // closed then we should terminate at this point", "        while (!myIsClosed.get()) {\n            try {\n                awaitConnection();\n            }\n            catch (IOException|SecurityException e) {\n                LOG.log(Level.INFO, \"Failed to establish connection\", e);\n\n                // If the reason for the failure was that the provider has been\n                // closed then we should terminate at this point\n                if (myTransportProvider.isClosed()) {\n                    LOG.log(Level.INFO, \"Provider is closed so exiting\");\n                    return;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the instance by the given name.\n     *\n     * @param name  The name to look up for.\n     *\n     * @return the instance, if any.\n     */\n    protected abstract Object getObjectInstance(CharSequence name);\n\n    /**\n     * Whether the given <i>authenticated</i> username is permitted to access\n     * this instance. If the user cannot be securely identified then the caller\n     * should pass {@code null} to this method.\n     *\n     * @param username  The autheticated username, or {@code null} if it does\n     *                  not exist.\n     *\n     * @return whether the user is permitted.\n     */\n    protected boolean isUserPermitted(CharSequence username)\n    {\n        // By default we allow the user who is running the process to access it\n        return StringUtil.equals(System.getProperty(\"user.name\"), username);\n    }\n\n    /**\n     * Whether the host with the given internet address is permitted to access\n     * this instance.\n     *\n     * @param address The address of the remote client. This may be {@code null}.\n     *\n     * @return whether the host is permitted.\n     */\n    protected boolean isHostPermitted(InetAddress address)\n    {\n        // By default we let all remote hosts connect\n        return true;\n    }\n\n    /**\n     * Whether class blocking is on, i.e. whether only a specific set of\n     * classes is permitted or not. Subclasses can override this behavior.\n     *\n     * @return whether blocking is on.\n     */\n    protected boolean isClassBlockingOn()\n    {\n        // By default, class blocking is off and all classes are permitted.\n        return false;\n    }\n\n    /**\n     * Whether access to a class, given its canonical name, is permitted or not.\n     *\n     * <p>By default:<ul>\n     *  <li>If {@link #isClassBlockingOn()} returns {@code false} then this\n     *      method is effectively inactive and all classes are permitted.\n     *  <li>If {@code true}, the result of {@link #getClassNameAllowlist()}\n     *      will be used to decide whether a class is allowed or not, making\n     *      this method \"active\".\n     *  <li>Access to primitive types, and their arrays, is permitted.\n     *  <li>Arrays of objects are allowed if their element's class is allowed.\n     * </ul>\n     * This default behaviour may not apply should the method be overridden.\n     *\n     * <p><b>IMPORTANT:</b> In all circumstances, if this method is \"active\"\n     * then passing in {@code null} should return {@code false} and, if it is\n     * not \"active\" then doing so should return {@code true}. Other logic\n     * depends on these semantics.\n     *\n     * @param className  The name to check.\n     *\n     * @return Whether access to the class is allowed.\n     *\n     * @see getClassNameAllowlist\n     */\n    protected boolean isClassPermitted(final CharSequence className)\n    {\n        // By default, if class blocking is not on, then we allow everything", "                if (myTransportProvider.isClosed()) {\n                    LOG.log(Level.INFO, \"Provider is closed so exiting\");\n                    return;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the instance by the given name.\n     *\n     * @param name  The name to look up for.\n     *\n     * @return the instance, if any.\n     */\n    protected abstract Object getObjectInstance(CharSequence name);\n\n    /**\n     * Whether the given <i>authenticated</i> username is permitted to access\n     * this instance. If the user cannot be securely identified then the caller\n     * should pass {@code null} to this method.\n     *\n     * @param username  The autheticated username, or {@code null} if it does\n     *                  not exist.\n     *\n     * @return whether the user is permitted.\n     */\n    protected boolean isUserPermitted(CharSequence username)\n    {\n        // By default we allow the user who is running the process to access it\n        return StringUtil.equals(System.getProperty(\"user.name\"), username);\n    }\n\n    /**\n     * Whether the host with the given internet address is permitted to access\n     * this instance.\n     *\n     * @param address The address of the remote client. This may be {@code null}.\n     *\n     * @return whether the host is permitted.\n     */\n    protected boolean isHostPermitted(InetAddress address)\n    {\n        // By default we let all remote hosts connect\n        return true;\n    }\n\n    /**\n     * Whether class blocking is on, i.e. whether only a specific set of\n     * classes is permitted or not. Subclasses can override this behavior.\n     *\n     * @return whether blocking is on.\n     */\n    protected boolean isClassBlockingOn()\n    {\n        // By default, class blocking is off and all classes are permitted.\n        return false;\n    }\n\n    /**\n     * Whether access to a class, given its canonical name, is permitted or not.\n     *\n     * <p>By default:<ul>\n     *  <li>If {@link #isClassBlockingOn()} returns {@code false} then this\n     *      method is effectively inactive and all classes are permitted.\n     *  <li>If {@code true}, the result of {@link #getClassNameAllowlist()}\n     *      will be used to decide whether a class is allowed or not, making\n     *      this method \"active\".\n     *  <li>Access to primitive types, and their arrays, is permitted.\n     *  <li>Arrays of objects are allowed if their element's class is allowed.\n     * </ul>\n     * This default behaviour may not apply should the method be overridden.\n     *\n     * <p><b>IMPORTANT:</b> In all circumstances, if this method is \"active\"\n     * then passing in {@code null} should return {@code false} and, if it is\n     * not \"active\" then doing so should return {@code true}. Other logic\n     * depends on these semantics.\n     *\n     * @param className  The name to check.\n     *\n     * @return Whether access to the class is allowed.\n     *\n     * @see getClassNameAllowlist\n     */\n    protected boolean isClassPermitted(final CharSequence className)\n    {\n        // By default, if class blocking is not on, then we allow everything", "        if (!isClassBlockingOn()) {\n            return true;\n        }\n\n        // Classes with a null name are not allowed. Who knows what they are?!\n        if (className == null) {\n            return false;\n        }\n\n        // For shredding the name\n        final int len = className.length();\n\n        // We allow all 1D and 2D primitive arrays since they don't allow\n        // access to insecure methods", "        if ((len == 2 && className.charAt(0) == '[') ||\n            (len == 3 && className.charAt(0) == '[' &&\n                         className.charAt(1) == '['))\n        {\n            switch (className.charAt(len - 1)) {\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'F':\n            case 'I':\n            case 'J':\n            case 'S':\n            case 'Z':\n                return true;\n            }\n        }\n\n        //  Check the map for the actual class. We render to a String at this\n        //  point since that's what the map is keyed with. Chances are that we\n        //  are given a String anyhow so this will be a NOP.\n        //\n        // If the allow list is null, all classes are permitted.\n        final String classNameStr = className.toString();", "        if (myClassNameAllowlist == null ||\n            myClassNameAllowlist.contains(classNameStr))\n        {\n            return true;\n        }\n\n        // All primitive types are allowed, including 'void'\n        switch (classNameStr) {\n            case \"void\":\n            case \"boolean\":\n            case \"byte\":\n            case \"char\":\n            case \"double\":\n            case \"float\":\n            case \"int\":\n            case \"long\":\n            case \"short\":\n                return true;\n        }\n\n        // See if the className is an array. If it's an object array then we\n        // only allow it if the underlying class is also allowed. We could just\n        // allow arrays of anything, but subclasses can be more lax if they\n        // really want to.", "        if (len > 3 &&\n            className.charAt(0)     == '[' &&\n            className.charAt(1)     == 'L' &&\n            className.charAt(len-1) == ';' &&\n            isClassPermitted(className.subSequence(2, len-1)))\n        {\n            return true;\n        }\n\n        // Otherwise access to this class isn't allowed\n        return false;\n    }\n\n    /**\n     * Get the additional message to add to the {@code SecurityException} that\n     * is thrown when a not-permitted class, as determined by\n     * {@code isClassPermitted}, is accessed.\n     *\n     * @return the message.\n     */\n    protected String getClassNotPermittedMessage()\n    {\n        // No-op for the base class\n        return \"\";\n    }\n\n    /**\n     * Whether class injection is permitted in this instance.\n     *\n     * <p>By default this is not allowed if we have class permissioning enabled.\n     * Subclasses should be very careful about overriding this method to return\n     * {@code true} if this class's call returns {@code false}. (I.e. don't make\n     * it more permissive.)\n     *\n     * @return whether injection is permitted.\n     */\n    protected boolean isClassInjectionPermitted()\n    {\n        // We defer to the semantics of isClassPermitted() for this. If we give\n        // it null then it will return false if the function is active and true\n        // otherwise. We should not allow class injection if we have\n        // permissioning enabled since it could be used to subvert the security.\n        return isClassPermitted(null);\n    }\n\n    /**\n     * This method is called when a client connection is accepted. Subclasses\n     * may wish to override this in order to add extra logging etc. Some or all\n     * of the arguments to this function may be {@code null}.\n     *\n     * @param username       The username of the connection, if any.\n     * @param address        The address of the client, if any.\n     * @param transport      The transport used, if any.\n     * @param clientCommand  The name of tha client script, if any.\n     * @param pid            The PID of the client, if any.\n     * @param id             The unique ID of the client, if any.\n     */\n    protected void connectionAccepted(final String      username,\n                                      final InetAddress address,\n                                      final Transport   transport,\n                                      final String      clientCommand,\n                                      final Integer     pid,\n                                      final Long        id)\n    {\n        // Build the connection details\n        final StringBuilder sb = new StringBuilder();\n        sb.append(myName).append(' ').append(\"Allowed \");", "        if (username != null) {\n            sb.append(\"user \\\"\").append(username).append(\"\\\"\");\n        }\n        else {\n            sb.append(\"anonymous/unauthenicated user\");\n        }\n        if (address != null) {\n            sb.append(\" from \").append(address);\n        }\n        if (transport != null) {\n            sb.append(\" via \").append(transport);\n        }", "        if (transport != null) {\n            sb.append(\" via \").append(transport);\n        }\n        if (clientCommand != null) {\n            sb.append(\" using client command \")\n              .append(\"\\\"\").append(clientCommand).append(\"\\\"\");\n        }\n        if (pid != null) {\n            sb.append(\" with PID \").append(pid);\n        }\n        if (id != null) {\n            sb.append(\" with ID \").append(id);\n        }\n\n        // And log it all\n        LOG.info(sb.toString());\n    }\n\n    /**\n     * This method is called when a connection is refused for some reason.\n     * Subclasses may wish to override this in order to add extra logging etc.\n     * Some or all of the arguments to this function may be {@code null}.\n     *\n     * <p>Note that this method could be called repeatedly in quick succession\n     * for a variety of reasons. Subclasses should be aware of this when\n     * deciding how to alert.\n     *\n     * @param username   The username of the connection, if any.\n     * @param address    The address of the client, if any.\n     * @param transport  The transport used, if any.\n     * @param reason     The reason the connection was refused, if any.\n     */\n    protected void connectionRejected(final String      username,\n                                      final InetAddress address,\n                                      final Transport   transport,\n                                      final String      reason)\n    {\n        LOG.warning(\n            \"Rejected connection by user \" +\n            ((username  == null) ? \"<unknown>\" : username            ) + \" \" +\n            \"from host \" +\n            ((address   == null) ? \"<unknown>\" : address  .toString()) + \" \" +\n            \"via transport \" +\n            ((transport == null) ? \"<unknown>\" : transport.toString()) + \" \" +\n            ((reason    == null) ? \"\" : \": \" + reason)\n        );\n    }\n\n    /**\n     * Get the collection of classes which the user is allowed to get using a\n     * TYPE_REQUEST. This returns a safe but conservative collection of classes.\n     *\n     * <p>This method will be called once, in the constructor, and its result\n     * copied and saved.\n     *\n     * <p>If {@link isClassBlockingOn} is {@code false}, then the results of\n     * this call are effectively ignored.\n     *\n     * <p><i>Note:</i> If this method returns null, then all classes are\n     * permitted.\n     *\n     * @return the allow-list.\n     */\n    protected Collection<String> getClassNameAllowlist()\n    {\n        return DEFAULT_CLASS_NAME_ALLOWLIST;\n    }\n\n    /**\n     * How many worker threads this PJRmi instance should use to field incoming\n     * requests.\n     *\n     * <p>If this value is greater than zero then worker threads will be used;\n     * else all the calls will be handled in the receiver thread. using workers\n     * slower but allows for re-entrancy (i.e. Python calls Java calls Python\n     * calls Java). This value determines how many worker threads to actively\n     * maintain; it's possible that more threads than this will be created, if\n     * required, but they will be leaked.\n     *\n     * <p>By default this returns {@code 0}, implying single-threaded access.\n     *\n     * @return the number of workers.\n     */\n    protected int numWorkers()\n    {\n        return 0;\n    }\n\n    /**\n     * Whether we're using workers or not.\n     *\n     * @return whether to use workers.\n     */\n    protected final boolean useWorkers()\n    {\n        return (numWorkers() > 0);\n    }\n\n    /**\n     * Whether or not to instrument method calls using the instrumentation\n     * framework.\n     *\n     * @return whether to instrument calls.\n     */\n    protected boolean instrumentMethodCalls()\n    {\n        return false;\n    }\n\n    /**\n     * Await a connection on our transport and, when we get one, hand it back.\n     * The returned connection will be active and running.\n     *\n     * <p>In the event of a failure to correctly connect an error message will\n     * be sent back and the connection dropped.\n     *\n     * @return the new connection.\n     *\n     * @throws IOException       if there was a problem.\n     * @throws SecurityException if access was blocked by security mechanisms.\n     */\n    protected final Connection awaitConnection()\n        throws IOException,\n               SecurityException\n    {\n        final Transport transport = myTransportProvider.accept();\n        LOG.info(\n            myName + \" Got connection \" + transport\n        );\n\n        // Grab its streams\n        final InputStream  is = transport.getInputStream();\n        final OutputStream os = transport.getOutputStream();\n\n        // Do the handshake string exchange\n        final StringBuilder hello = new StringBuilder();", "        if (id != null) {\n            sb.append(\" with ID \").append(id);\n        }\n\n        // And log it all\n        LOG.info(sb.toString());\n    }\n\n    /**\n     * This method is called when a connection is refused for some reason.\n     * Subclasses may wish to override this in order to add extra logging etc.\n     * Some or all of the arguments to this function may be {@code null}.\n     *\n     * <p>Note that this method could be called repeatedly in quick succession\n     * for a variety of reasons. Subclasses should be aware of this when\n     * deciding how to alert.\n     *\n     * @param username   The username of the connection, if any.\n     * @param address    The address of the client, if any.\n     * @param transport  The transport used, if any.\n     * @param reason     The reason the connection was refused, if any.\n     */\n    protected void connectionRejected(final String      username,\n                                      final InetAddress address,\n                                      final Transport   transport,\n                                      final String      reason)\n    {\n        LOG.warning(\n            \"Rejected connection by user \" +\n            ((username  == null) ? \"<unknown>\" : username            ) + \" \" +\n            \"from host \" +\n            ((address   == null) ? \"<unknown>\" : address  .toString()) + \" \" +\n            \"via transport \" +\n            ((transport == null) ? \"<unknown>\" : transport.toString()) + \" \" +\n            ((reason    == null) ? \"\" : \": \" + reason)\n        );\n    }\n\n    /**\n     * Get the collection of classes which the user is allowed to get using a\n     * TYPE_REQUEST. This returns a safe but conservative collection of classes.\n     *\n     * <p>This method will be called once, in the constructor, and its result\n     * copied and saved.\n     *\n     * <p>If {@link isClassBlockingOn} is {@code false}, then the results of\n     * this call are effectively ignored.\n     *\n     * <p><i>Note:</i> If this method returns null, then all classes are\n     * permitted.\n     *\n     * @return the allow-list.\n     */\n    protected Collection<String> getClassNameAllowlist()\n    {\n        return DEFAULT_CLASS_NAME_ALLOWLIST;\n    }\n\n    /**\n     * How many worker threads this PJRmi instance should use to field incoming\n     * requests.\n     *\n     * <p>If this value is greater than zero then worker threads will be used;\n     * else all the calls will be handled in the receiver thread. using workers\n     * slower but allows for re-entrancy (i.e. Python calls Java calls Python\n     * calls Java). This value determines how many worker threads to actively\n     * maintain; it's possible that more threads than this will be created, if\n     * required, but they will be leaked.\n     *\n     * <p>By default this returns {@code 0}, implying single-threaded access.\n     *\n     * @return the number of workers.\n     */\n    protected int numWorkers()\n    {\n        return 0;\n    }\n\n    /**\n     * Whether we're using workers or not.\n     *\n     * @return whether to use workers.\n     */\n    protected final boolean useWorkers()\n    {\n        return (numWorkers() > 0);\n    }\n\n    /**\n     * Whether or not to instrument method calls using the instrumentation\n     * framework.\n     *\n     * @return whether to instrument calls.\n     */\n    protected boolean instrumentMethodCalls()\n    {\n        return false;\n    }\n\n    /**\n     * Await a connection on our transport and, when we get one, hand it back.\n     * The returned connection will be active and running.\n     *\n     * <p>In the event of a failure to correctly connect an error message will\n     * be sent back and the connection dropped.\n     *\n     * @return the new connection.\n     *\n     * @throws IOException       if there was a problem.\n     * @throws SecurityException if access was blocked by security mechanisms.\n     */\n    protected final Connection awaitConnection()\n        throws IOException,\n               SecurityException\n    {\n        final Transport transport = myTransportProvider.accept();\n        LOG.info(\n            myName + \" Got connection \" + transport\n        );\n\n        // Grab its streams\n        final InputStream  is = transport.getInputStream();\n        final OutputStream os = transport.getOutputStream();\n\n        // Do the handshake string exchange\n        final StringBuilder hello = new StringBuilder();", "        for (int i=0; i < HELLO.length(); i++) {\n            // Build up the hello string one char at a time, so that we don't\n            // block on a malformed one\n            final int c = is.read();\n            hello.append((char)c);\n            if (c != (int)HELLO.charAt(i)) {\n                break;\n            }\n        }\n        for (int i=0; i < HELLO.length(); i++) {\n            os.write((byte)HELLO.charAt(i));\n        }\n\n        // Check to see if the HELLO string was what we expected. If not we send\n        // back an error message and drop the connection.", "        for (int i=0; i < HELLO.length(); i++) {\n            os.write((byte)HELLO.charAt(i));\n        }\n\n        // Check to see if the HELLO string was what we expected. If not we send\n        // back an error message and drop the connection.\n        for (int i=0; i < HELLO.length(); i++) {\n            if (hello.charAt(i) != HELLO.charAt(i)) {\n                final String error =\n                    \"Malformed HELLO string; \" +\n                    \"had \\\"\"      + hello + \"\\\", \" +\n                    \"expected \\\"\" + HELLO + \"\\\"\";\n                final int len = Math.min(127, error.length());\n                os.write(-len);", "                for (int j=0; j < len; j++) {\n                    os.write((int)error.charAt(j));\n                }\n                transport.close();\n                throw new IOException(error + \"; dropping connection\");\n            }\n        }\n\n        // Read the client script name and PID\n        final int count = ((Byte.toUnsignedInt((byte)is.read()) << 24) |\n                           (Byte.toUnsignedInt((byte)is.read()) << 16) |\n                           (Byte.toUnsignedInt((byte)is.read()) <<  8) |\n                           (Byte.toUnsignedInt((byte)is.read())      ));\n        final byte[] buffer = new byte[count];", "        for (int i=0; i < count; i++) {\n            buffer[i] = (byte)is.read();\n        }\n        final String argv = new String(buffer, 0, count, \"UTF-16\");\n        final int pid   = ((      Byte.toUnsignedInt((byte)is.read()) << 24) |\n                           (      Byte.toUnsignedInt((byte)is.read()) << 16) |\n                           (      Byte.toUnsignedInt((byte)is.read()) <<  8) |\n                           (      Byte.toUnsignedInt((byte)is.read())      ));\n        final long id   = (((long)Byte.toUnsignedInt((byte)is.read()) << 56) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) << 48) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) << 40) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) << 32) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) << 24) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) << 16) |\n                           ((long)Byte.toUnsignedInt((byte)is.read()) <<  8) |\n                           ((long)Byte.toUnsignedInt((byte)is.read())      ));\n\n        // Grab the host address and authenticated username and see if they are\n        // allowed to connect. If not we send back an error message and drop the\n        // connection.\n        final String      username = transport.getUserName();\n        final InetAddress address  = transport.getRemoteAddress();", "        if (!isUserPermitted(username)) {\n            final String error = (username != null) ?\n                \"User not permissioned: \\\"\" + username + \"\\\"\" :\n                \"Unauthenticated users not permitted\";\n            final int len = Math.min(127, error.length());\n            os.write(-len);\n            for (int i=0; i < len; i++) {\n                os.write((int)error.charAt(i));\n            }\n\n            // Close, flag and bail\n            transport.close();\n            connectionRejected(username, address, transport, error);\n            throw new SecurityException(error);\n        }", "        else if (!isHostPermitted(address)) {\n            final String error = (address != null) ?\n                \"Host address not permissioned: \" + address :\n                \"Unknown remote host not permitted\";\n            final int len = Math.min(127, error.length());\n            os.write(-len);\n            for (int i=0; i < len; i++) {\n                os.write((int)error.charAt(i));\n            }\n\n            // Close, flag and bail\n            transport.close();\n            connectionRejected(username, address, transport, error);\n            throw new SecurityException(error);\n        }\n        else {\n            // Otherwise we echo back our name, this may not be longer than 127\n            // chars since we encode the length as a signed byte. This is done\n            // to simplify the client side's error handling. (This probably\n            // doesn't matter too much since it's not really used by the client\n            // right now. Though I think I'm going to regret saying this.)\n            final int len = Math.min(127, myName.length());\n            os.write(len);", "            for (int i=0; i < len; i++) {\n                os.write((int)myName.charAt(i));\n            }\n\n            // Now send along some flags telling the other side about\n            // us; just a byte for now\n            final byte flags =\n                (byte)((useWorkers() ? Flags.USE_WORKERS.value : 0));\n            os.write(flags);\n        }\n\n        // Flag a successful connection\n        connectionAccepted(username, address, transport, argv, pid, id);\n\n        // Create it the handler thread and set it rolling\n        final Connection c =\n            new Connection(\n                myName + \":\" + (myConnectionIndex++) + \":\" + username,\n                transport,\n                id\n            );\n        c.setDaemon(true);\n        c.start();\n\n        // Now give it back\n        return c;\n    }\n\n    /**\n     * Terminates the PJRmi service, rendering this instance unusable.\n     *\n     * @throws IOException if there was a problem.\n     */", "    public void close()\n        throws IOException\n    {\n        if (myIsClosed.compareAndSet(false, true)) {\n            if (myTransportProvider != null) {\n                myTransportProvider.close();\n            }\n\n            // Interrupt the PJRmi thread so that (hopefully) it wakes up from\n            // any blocked calls it's in and is able to terminate\n            this.interrupt();\n        }\n    }\n\n    /**\n     * How we might instrument.\n     *\n     * @param name  The name of the instrumentor to get.\n     *\n     * @return the instrumentor.\n     */\n    protected Instrumentor getInstrumentor(final String name)\n    {\n        return Instrumentor.NULL_INSTRUMENTOR;\n    }\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Simple testing method which exposes a socket.\n     * <pre>\n         java -Djava.library.path=`python -c 'import pjrmi; print(str(pjrmi.get_config()[\"libpath\"]))'` \\\n              -classpath `python -c 'import pjrmi; print(str(pjrmi.get_config()[\"classpath\"]))'`        \\\n                  com.deshaw.pjrmi.PJRmi\n     * </pre>\n     *\n     * The connect with: <pre>\n     *   import pjrmi\n     *   c = pjrmi.connect_to_socket('localhost', 65432)\n     *</pre>\n     *\n     * @param args  Ignored.\n     *\n     * @throws Exception if there was a problem.\n     */", "    public static void main(String[] args)\n        throws Exception\n    {\n        // Get our params from properties\n        final String prefix    = \"com.deshaw.pjrmi.PJRmi.\";\n        final String logLevel  = System.getProperty(prefix + \"logLevel\", \"INFO\");\n        final String port      = System.getProperty(prefix + \"port\", \"65432\");\n        final String storeName = System.getProperty(prefix + \"storeName\");\n        final String storePass = System.getProperty(prefix + \"storePassword\");\n\n        // Set up logging\n        LOG.setLevel(Level.parse(logLevel));\n\n        // Set up the transport\n        final int portNum = Integer.parseInt(port);\n        final Transport.Provider provider =\n            (storeName != null && storePass != null)\n                ? new SSLSocketProvider(portNum, storeName, storePass)\n                : new SocketProvider   (portNum);\n\n        // Create a simple instance which just echoes back the name it's given\n        LOG.info(\"Waiting for connections with \" + provider);\n        final PJRmi pjrmi =\n            new PJRmi(\"PJRmi\", provider, true) {\n                @Override\n                protected boolean isUserPermitted(CharSequence username)\n                {\n                    return true;\n                }\n\n                @Override\n                protected int numWorkers()\n                {\n                    return 2;\n                }\n\n                @Override\n                protected Object getObjectInstance(CharSequence name)\n                {\n                    return name.toString().intern();\n                }\n            };\n\n        // Set it rolling\n        pjrmi.run();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonMinionProvider.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport com.deshaw.util.StringUtil;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.net.InetAddress;\n", "import java.net.InetAddress;\n\n/**\n * A transport provider which spawns a child Python process to talk to.\n */\npublic class PythonMinionProvider\n    implements Transport.Provider\n{\n    /**\n     * Our stdin filename, if any.\n     */\n    private final String myStdinFilename;\n\n    /**\n     * Our stdout filename, if any.\n     */\n    private final String myStdoutFilename;\n\n    /**\n     * Our stderr filename, if any.\n     */\n    private final String myStderrFilename;\n\n    /**\n     * Whether to use SHM data passing.\n     */\n    private final boolean myUseShmdata;\n\n    /**\n     * The singleton child which we will spawn.\n     */\n    private volatile PythonMinionTransport myMinion;\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * Spawn a Python minion with SHM value passing disabled by default.\n     *\n     * @return the minion instance.\n     *\n     * @throws IOException If there was a problem spawning the child.\n     */", "    public static PythonMinion spawn()\n        throws IOException\n    {\n        try {\n            return spawn(null, null, null, false);\n        }\n        catch (IllegalArgumentException e) {\n            // Should never happen\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Spawn a Python minion, and a PJRmi connection to handle its callbacks.\n     * This allows users to specify if they want to use native array\n     * handling.\n     *\n     * @param useShmArgPassing Whether to use native array handling.\n     *\n     * @return the minion instance.\n     *\n     * @throws IOException If there was a problem spawning the child.\n     */", "    public static PythonMinion spawn(final boolean useShmArgPassing)\n        throws IOException\n    {\n        try {\n            return spawn(null, null, null, useShmArgPassing);\n        }\n        catch (IllegalArgumentException e) {\n            // Should never happen\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Spawn a Python minion with SHM value passing disabled by default.\n     *\n     * @param stdinFilename  The filename the child process should use for\n     *                       stdin, or {@code null} if none.\n     * @param stdoutFilename The filename the child process should use for\n     *                       stdout, or {@code null} if none.\n     * @param stderrFilename The filename the child process should use for\n     *                       stderr, or {@code null} if none.\n     *\n     * @return the minion instance.\n     *\n     * @throws IOException              If there was a problem spawning\n     *                                  the child.\n     * @throws IllegalArgumentException If any of the stio redirects were\n     *                                  disallowed.\n     */", "    public static PythonMinion spawn(final String stdinFilename,\n                                     final String stdoutFilename,\n                                     final String stderrFilename)\n        throws IOException,\n               IllegalArgumentException\n    {\n        return spawn(stdinFilename, stdoutFilename, stderrFilename, false);\n    }\n\n    /**\n     * Spawn a Python minion, and a PJRmi connection to handle its callbacks.\n     *\n     * <p>This method allows the caller to provide optional overrides for\n     * the child process's stdio. Since the child uses stdin and stdout to\n     * talk to the parent these must not be any of the \"/dev/std???\" files.\n     * This method also allows users to specify whether to enable passing\n     * of some values by SHM copying.\n     *\n     * @param stdinFilename    The filename the child process should use for\n     *                         stdin, or {@code null} if none.\n     * @param stdoutFilename   The filename the child process should use for\n     *                         stdout, or {@code null} if none.\n     * @param stderrFilename   The filename the child process should use for\n     *                         stderr, or {@code null} if none.\n     * @param useShmArgPassing Whether to use native array handling.\n     *\n     * @return the minion instance.\n     *\n     * @throws IOException              If there was a problem spawning\n     *                                  the child.\n     * @throws IllegalArgumentException If any of the stio redirects were\n     *                                  disallowed.\n     */", "    public static PythonMinion spawn(final String  stdinFilename,\n                                     final String  stdoutFilename,\n                                     final String  stderrFilename,\n                                     final boolean useShmArgPassing)\n        throws IOException,\n               IllegalArgumentException\n    {\n        // Make sure that people don't interfere with our comms channel\n        assertGoodForStdio(\"stdin\",  stdinFilename );\n        assertGoodForStdio(\"stdout\", stdoutFilename);\n        assertGoodForStdio(\"stderr\", stderrFilename);\n\n        // Create the PJRmi instance now, along with the transport we'll\n        // need for it\n        final PythonMinionProvider provider =\n            new PythonMinionProvider(stdinFilename,\n                                     stdoutFilename,\n                                     stderrFilename,\n                                     useShmArgPassing);\n        final PJRmi pjrmi =\n            new PJRmi(\"PythonMinion\", provider, false, useShmArgPassing)\n            {\n                @Override protected Object getObjectInstance(CharSequence name)\n                {\n                    return null;\n                }\n\n                @Override protected boolean isUserPermitted(CharSequence username)\n                {\n                    return true;\n                }\n\n                @Override\n                protected boolean isHostPermitted(InetAddress address)\n                {\n                    return true;\n                }\n\n                @Override protected int numWorkers()\n                {\n                    return 16;\n                }\n            };\n\n        // Give back the connection to handle evals\n        return pjrmi.awaitConnection();\n    }\n\n    /**\n     * Ensure that someone isn't trying to be clever with the output\n     * filenames, if any. This should prevent people accidently using our\n     * comms channel for their own purposes.\n     *\n     * @param what      The file description.\n     * @param filename  The file path.\n     */\n    private static void assertGoodForStdio(final String what,\n                                           final String filename)\n        throws IllegalArgumentException\n    {\n        // Early-out if there's no override", "        if (filename == null) {\n            return;\n        }\n\n        // Using /dev/null is fine\n        if (filename.equals(\"/dev/null\")) {\n            return;\n        }\n\n        // Disallow all files which look potentially dubious. We could try\n        // to walk the symlinks here but that seems like overkill", "        if (filename.startsWith(\"/dev/\") || filename.startsWith(\"/proc/\")) {\n            throw new IllegalArgumentException(\n                \"Given \" + what + \" file was of a disallowed type: \" +\n                filename\n            );\n        }\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * CTOR.\n     *\n     * @param stdinFilename     The stdin path.\n     * @param stdoutFilename    The stdout path.\n     * @param stderrFilename    The stderr path.\n     * @param useShmArgPassing  Whether to use shared-memory arg passing.\n     */\n    private PythonMinionProvider(final String  stdinFilename,\n                                 final String  stdoutFilename,\n                                 final String  stderrFilename,\n                                 final boolean useShmArgPassing)\n    {\n        myStdinFilename  = stdinFilename;\n        myStdoutFilename = stdoutFilename;\n        myStderrFilename = stderrFilename;\n        myUseShmdata     = useShmArgPassing;\n        myMinion         = null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public Transport accept()\n        throws IOException\n    {\n        if (myMinion == null) {\n            myMinion = new PythonMinionTransport(myStdinFilename,\n                                                 myStdoutFilename,\n                                                 myStderrFilename,\n                                                 myUseShmdata);\n            return myMinion;\n        }\n        else {", "            while (myMinion != null) {\n                try {\n                    Thread.sleep(1000);\n                }\n                catch (InterruptedException e) {\n                    // Nothing\n                }\n            }\n\n            // If we get here we have been closed so throw as such\n            throw new IOException(\"Instance is closed\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void close()\n    {\n        if (myMinion != null) {\n            myMinion.close();\n            myMinion = null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean isClosed()\n    {\n        return myMinion == null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return \"PythonMinion\";\n    }\n\n    /**\n     * Testing method.\n     *\n     * @param args  What to eval.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public String toString()\n    {\n        return \"PythonMinion\";\n    }\n\n    /**\n     * Testing method.\n     *\n     * @param args  What to eval.\n     *\n     * @throws Throwable if there was a problem.\n     */", "    public static void main(String[] args)\n        throws Throwable\n    {\n        final PythonMinion python = spawn();\n\n        System.out.println();\n        System.out.println(\"Calling eval and invoke...\");\n        Object result;\n        for (String arg : args) {\n            // Do the eval\n            try {\n                result = python.eval(arg);\n            }\n            catch (Throwable t) {\n                result = StringUtil.stackTraceToString(t);\n            }\n            System.out.println(\"  \\\"\" + arg + \"\\\" -> \" + result);\n\n            // Call a function on the argument", "        for (String arg : args) {\n            // Do the eval\n            try {\n                result = python.eval(arg);\n            }\n            catch (Throwable t) {\n                result = StringUtil.stackTraceToString(t);\n            }\n            System.out.println(\"  \\\"\" + arg + \"\\\" -> \" + result);\n\n            // Call a function on the argument", "            try {\n                result = python.invoke(\"len\", Integer.class, arg);\n            }\n            catch (Throwable t) {\n                result = StringUtil.stackTraceToString(t);\n            }\n            System.out.println(\"  len('\" + arg + \"') -> \" + result);\n        }\n\n        // Stress test\n        System.out.println();\n        System.out.println(\"Stress testing invoke()...\");", "        for (int round = 1; round <= 3; round++) {\n            Object foo = \"foo\";\n            final int count = 10000;\n            long start = System.nanoTime();\n            for (int i=0; i < count; i++) {\n                python.invoke(\"len\", Integer.class, foo);\n            }\n            long end = System.nanoTime();\n            System.out.println(\"  time(len('\" + foo + \"')) = \" +\n                               ((end - start) / count / 1000) + \"us\");\n\n            foo = PythonMinion.byValue(foo);\n            start = System.nanoTime();", "            for (int i=0; i < count; i++) {\n                python.invoke(\"len\", Integer.class, foo);\n            }\n            end = System.nanoTime();\n            System.out.println(\"  time(len('\" + foo + \"')) = \" +\n                               ((end - start) / count / 1000) + \"us\");\n        }\n\n        // Done\n        System.out.println();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonCallbackException.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n/**\n * An exception thrown by a Python callback.\n */\npublic class PythonCallbackException\n    extends Exception\n{\n    /**\n     * Constructor with a message and a cause.\n     *\n     * @param message  The exception message.\n     * @param cause    The reason.\n     */\n    public PythonCallbackException(final String message,\n                                   final Throwable cause)\n    {\n        super(message, cause);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonFunction.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n/**\n * A Python function which may be invoked with regular (non-kwarg) arguments\n * only.\n */\n@FunctionalInterface\npublic interface PythonFunction<T>\n{\n    /**\n     * Invoke a method on the object.\n     *\n     * @param args  The method's arguments, if any (may be null).\n     *\n     * @return the result of the call.\n     *\n     * @throws IllegalArgumentException if the arguments were incorrect.\n     * @throws NoSuchMethodException    if there was no such method in the\n     *                                  Python object.\n     */", "    public T invoke(final Object... args)\n        throws Throwable;\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/JniPJRmi.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.IOException;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Arrays;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**", "\n/**\n * C extensions for the {@link PJRmi} Java code.\n */\npublic class JniPJRmi\n{\n    /**\n     * Standard logger.\n     */\n    private static final Logger LOG = Logger.getLogger(\"com.deshaw.pjrmi.JniPJRmi\");\n\n    /**\n     * Whether we successfully loaded the native library.\n     */\n    private static final boolean ourLoadedLibrary;\n    static {\n        // Attempt to load in the JNI code\n        final String library = \"pjrmijni\";\n        boolean      loaded  = false;", "        try {\n            System.loadLibrary(library);\n            loaded = true;\n        }\n        catch (SecurityException | UnsatisfiedLinkError e) {\n            final String libraryPath =\n                ManagementFactory.getRuntimeMXBean().getLibraryPath();\n            LOG.warning(\"Unable to load library \" + library + \" \" +\n                        \"using library path \" + libraryPath + \": \" + e);\n        }\n\n        // And assign\n        ourLoadedLibrary = loaded;\n    }\n\n    /**\n     * Private constructor to prevent instantiation of a JniPJRmi\n     * object.\n     */\n    private JniPJRmi()\n    {\n    }\n\n    /**\n     * The handle for the input and output methods.\n     */", "    public static class ArrayHandle\n    {\n        /**\n         * Path to memory location containing the array.\n         */\n        public String filename;\n\n        /**\n         * Number of elements in the array.\n         * Initialized to an invalid value.\n         */", "        public int numElems = -1;\n\n        /**\n         * Type of array.\n         */\n        public char type;\n\n        /**\n         * Class constructor.\n         */\n        private ArrayHandle() {}\n\n        /**\n         * Class non-default constructor.\n         *\n         * @param  inFilename  The input filename.\n         * @param  inNumElems  The number of expected elements in the returned\n         *                     array.\n         * @param  inType      The expected type of the returned array.\n         */\n        private ArrayHandle(String inFilename, int inNumElems, char inType)\n        {\n            filename = inFilename;\n            numElems = inNumElems;\n            type = inType;\n        }\n    }\n\n    // -----------------------------------------------------------------------\n\n    /**\n     * Whether the library is available for use.\n     *\n     * @return yes or no.\n     */", "    public static boolean isAvailable()\n    {\n        return ourLoadedLibrary;\n    }\n\n    /**\n     * Writes the input array into a file and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final boolean[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutBooleanArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final byte[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutByteArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final short[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutShortArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final int[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutIntegerArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final long[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutLongArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final float[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutFloatArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Writes the input array into memory and returns an object containing the\n     * file information.\n     *\n     * @param  array  The primitive array we are writing into the file.\n     *\n     * @return        The file information.\n     *\n     * @throws  IllegalArgumentException  If there is an error in the creating\n     *                                    the filename.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     * @throws  OutOfMemoryError          If the file size is insufficient.\n     */", "    public static ArrayHandle writeArray(final double[] array)\n        throws IllegalArgumentException,\n               IOException,\n               OutOfMemoryError\n    {\n        if (ourLoadedLibrary) {\n            ArrayHandle result = new JniPJRmi.ArrayHandle();\n            nativePutDoubleArray(array, result);\n            return result;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Create an ArrayHandle and call readArray() on it.\n     * This is to keep users from interacting with the ArrayHandle class.\n     *\n     * @param  inFilename  The input filename.\n     * @param  inNumElems  The number of expected elements in the returned\n     *                     array.\n     * @param  inType      The expected type of the returned array.\n     *\n     * @return             The populated array Object, or NULL if an invalid\n     *                     case was given or an exception occurred.\n     *\n     * @throws  IllegalArgumentException  If the input is invalid.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     */", "    public static Object readArray(String inFilename,\n                                   int inNumElems,\n                                   char inType)\n        throws IllegalArgumentException,\n               IOException\n    {\n        if (LOG.isLoggable(Level.FINEST)) {\n            LOG.log(Level.FINEST, \"Input type to readArray() \" + inType);\n        }\n\n        // Create the object for communicating with the JNI.\n        ArrayHandle input = new ArrayHandle(inFilename,\n                                            inNumElems,\n                                            inType);\n\n        // Read from the corresponding file.\n        return readArray(input);\n    }\n\n    /**\n     * Given the location and size of a file, this function populates an array\n     * with the contents of the file. It performs sanity checks to ensure that\n     * the file contains an array of the appropriate type.\n     *\n     * @param  input  The information of the size, location, and type of file.\n     *\n     * @return        The populated array Object, or NULL if an invalid case\n     *                was given or an exception occurred.\n     *\n     * @throws  IllegalArgumentException  If the input is invalid.\n     * @throws  IOException               If there is an error in using the\n     *                                    file.\n     */", "    public static Object readArray(ArrayHandle input)\n        throws IllegalArgumentException,\n               IOException\n    {\n        if (ourLoadedLibrary) {\n            // Are our inputs valid?\n            if (input == null) {\n                return null;\n            }\n\n            final int numElems = input.numElems;\n            final String filename = input.filename;", "            if (numElems < 0 || filename == null) {\n                throw new IllegalArgumentException(\"Invalid input value\");\n            }\n\n            // JNI uses char identifiers for each type.\n            if (nativeIsBooleanArrayType(input.type)) {\n                boolean[] resultBoolean = new boolean[numElems];\n                nativeGetBooleanArray(filename, resultBoolean, numElems);\n                return resultBoolean;\n            }\n            else if (nativeIsByteArrayType(input.type)) {\n                byte[] resultByte = new byte[numElems];\n                nativeGetByteArray(filename, resultByte, numElems);\n                return resultByte;\n            }", "            else if (nativeIsByteArrayType(input.type)) {\n                byte[] resultByte = new byte[numElems];\n                nativeGetByteArray(filename, resultByte, numElems);\n                return resultByte;\n            }\n            else if (nativeIsShortArrayType(input.type)) {\n                short[] resultShort = new short[numElems];\n                nativeGetShortArray(filename, resultShort, numElems);\n                return resultShort;\n            }\n            else if (nativeIsIntegerArrayType(input.type)) {\n                int[] resultInt = new int[numElems];\n                nativeGetIntegerArray(filename, resultInt, numElems);\n                return resultInt;\n            }", "            else if (nativeIsIntegerArrayType(input.type)) {\n                int[] resultInt = new int[numElems];\n                nativeGetIntegerArray(filename, resultInt, numElems);\n                return resultInt;\n            }\n            else if (nativeIsLongArrayType(input.type)) {\n                long[] resultLong = new long[numElems];\n                nativeGetLongArray(filename, resultLong, numElems);\n                return resultLong;\n            }\n            else if (nativeIsFloatArrayType(input.type)) {\n                float[] resultFloat = new float[numElems];\n                nativeGetFloatArray(filename, resultFloat, numElems);\n                return resultFloat;\n            }", "            else if (nativeIsFloatArrayType(input.type)) {\n                float[] resultFloat = new float[numElems];\n                nativeGetFloatArray(filename, resultFloat, numElems);\n                return resultFloat;\n            }\n            else if (nativeIsDoubleArrayType(input.type)) {\n                double[] resultDouble = new double[numElems];\n                nativeGetDoubleArray(filename, resultDouble, numElems);\n                return resultDouble;\n            }\n            else {\n                throw new IllegalArgumentException(\"Invalid input type\");\n            }\n        }\n        return null;\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n\n    /*\n     * Given a character, returns whether it represents the PJRmi library\n     * enumerated type.\n     */\n    private native static boolean nativeIsBooleanArrayType (char type);\n    private native static boolean nativeIsByteArrayType    (char type);\n    private native static boolean nativeIsShortArrayType   (char type);\n    private native static boolean nativeIsIntegerArrayType (char type);\n    private native static boolean nativeIsLongArrayType    (char type);\n    private native static boolean nativeIsFloatArrayType   (char type);\n    private native static boolean nativeIsDoubleArrayType  (char type);\n\n    /*\n     * Writes the array into a /dev/shm file and returns the file information.\n     */\n    private native static void nativePutBooleanArray (boolean[] array, ArrayHandle result);\n    private native static void nativePutByteArray    (byte   [] array, ArrayHandle result);\n    private native static void nativePutShortArray   (short  [] array, ArrayHandle result);\n    private native static void nativePutIntegerArray (int    [] array, ArrayHandle result);\n    private native static void nativePutLongArray    (long   [] array, ArrayHandle result);\n    private native static void nativePutFloatArray   (float  [] array, ArrayHandle result);\n    private native static void nativePutDoubleArray  (double [] array, ArrayHandle result);\n\n    /*\n     * Given the file information, returns the contents of the file as an array.\n     */\n    private native static void nativeGetBooleanArray (String filename, boolean[] result, int numElems);\n    private native static void nativeGetByteArray    (String filename, byte   [] result, int numElems);\n    private native static void nativeGetShortArray   (String filename, short  [] result, int numElems);\n    private native static void nativeGetIntegerArray (String filename, int    [] result, int numElems);\n    private native static void nativeGetLongArray    (String filename, long   [] result, int numElems);\n    private native static void nativeGetFloatArray   (String filename, float  [] result, int numElems);\n    private native static void nativeGetDoubleArray  (String filename, double [] result, int numElems);\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Simple test method which prints out calls from this class.\n     *\n     * @param args  Ignored.\n     */", "    public static void main(String[] args)\n    {\n        // Have we loaded ourselves okay?\n        LOG.info(\"Loaded library successfully: \" + ourLoadedLibrary);\n\n        // For testing native function calls.\n        ArrayHandle result = new ArrayHandle();\n\n        // Sanity check tests: if we write into the file and then read out the\n        // results, do they match?\n        boolean[] testBoolean = new boolean[]{false, true, false};", "        try {\n            result = writeArray(testBoolean);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjBoolean = readArray(result.filename,\n                                                result.numElems,\n                                                result.type);\n            if (resultObjBoolean != null) {\n                boolean[] resultBoolean = (boolean[])resultObjBoolean;", "            if (resultObjBoolean != null) {\n                boolean[] resultBoolean = (boolean[])resultObjBoolean;\n                if (Arrays.equals(testBoolean, resultBoolean)) {\n                    LOG.info(\"main_boolean success\");\n                }\n                else {\n                    LOG.info(\"main_boolean incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_boolean returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        byte[] testByte = new byte[]{69, 121, 101, 45, 62, 118};", "        try {\n            result = writeArray(testByte);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjByte = readArray(result.filename,\n                                             result.numElems,\n                                             result.type);\n            if (resultObjByte != null) {\n                byte[] resultByte = (byte[])resultObjByte;", "            if (resultObjByte != null) {\n                byte[] resultByte = (byte[])resultObjByte;\n                if (Arrays.equals(testByte, resultByte)) {\n                    LOG.info(\"main_byte success\");\n                }\n                else {\n                    LOG.info(\"main_byte incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_byte returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        short[] testShort = new short[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};", "        try {\n            result = writeArray(testShort);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjShort = readArray(result.filename,\n                                              result.numElems,\n                                              result.type);\n            if (resultObjShort != null) {\n                short[] resultShort = (short[])resultObjShort;", "            if (resultObjShort != null) {\n                short[] resultShort = (short[])resultObjShort;\n                if (Arrays.equals(testShort, resultShort)) {\n                    LOG.info(\"main_short success\");\n                }\n                else {\n                    LOG.info(\"main_short incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_short returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        int[] testInt = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};", "        try {\n            result = writeArray(testInt);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjInt = readArray(result.filename,\n                                            result.numElems,\n                                            result.type);\n            if (resultObjInt != null) {\n                int[] resultInt = (int[])resultObjInt;", "            if (resultObjInt != null) {\n                int[] resultInt = (int[])resultObjInt;\n                if (Arrays.equals(testInt, resultInt)) {\n                    LOG.info(\"main_int success\");\n                }\n                else {\n                    LOG.info(\"main_int incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_int returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        long[] testLong = new long[]{1, 2, 3, 4, 5};", "        try {\n            result = writeArray(testLong);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjLong = readArray(result.filename,\n                                             result.numElems,\n                                             result.type);\n            if (resultObjLong != null) {\n                long[] resultLong = (long[])resultObjLong;", "            if (resultObjLong != null) {\n                long[] resultLong = (long[])resultObjLong;\n                if (Arrays.equals(testLong, resultLong)) {\n                    LOG.info(\"main_long success\");\n                }\n                else {\n                    LOG.info(\"main_long incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_long returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        float[] testFloat = new float[]{1, 2, 3, 4, 5, 6};", "        try {\n            result = writeArray(testFloat);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjFloat = readArray(result.filename,\n                                              result.numElems,\n                                              result.type);\n            if (resultObjFloat != null) {\n                float[] resultFloat = (float[])resultObjFloat;", "            if (resultObjFloat != null) {\n                float[] resultFloat = (float[])resultObjFloat;\n                if (Arrays.equals(testFloat, resultFloat)) {\n                    LOG.info(\"main_float success\");\n                }\n                else {\n                    LOG.info(\"main_float incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_float returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        double[] testDouble = new double[]{1, 2, 3, 4, 5};", "        try {\n            result = writeArray(testDouble);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n        try {\n            Object resultObjDouble = readArray(result.filename,\n                                               result.numElems,\n                                               result.type);\n            if (resultObjDouble != null) {\n                double[] resultDouble = (double[])resultObjDouble;", "            if (resultObjDouble != null) {\n                double[] resultDouble = (double[])resultObjDouble;\n                if (Arrays.equals(testDouble, resultDouble)) {\n                    LOG.info(\"main_double success\");\n                }\n                else {\n                    LOG.info(\"main_double incorrect array values\");\n                }\n            }\n            else {\n                LOG.info(\"main_double returned a null object.\");\n            }\n        }\n        catch (IOException e) {\n            LOG.info(\"readArray() failed with \" + e);\n        }\n\n        // Test whether overwriting a returned ArrayHandle produces graceful\n        // error messages. We don't want it to core dump.\n        byte[] testError = new byte[]{3, 1, 4, 15, 92};", "        try {\n            result = writeArray(testError);\n        }\n        catch (IOException e) {\n            LOG.info(\"writeArray() failed with \" + e);\n        }\n\n        // Set result to erroneous values.\n        // Preserving the original filename, set filename.\n        String originalFilename = result.filename;\n        result.filename = \"Bad filename\";\n", "        try {\n            readArray(result.filename, result.numElems, result.type);\n        }\n        catch (IOException e) {\n            LOG.info(\"bad_filename failed correctly with \" + e);\n        }\n        catch (Exception e) {\n            LOG.info(\"bad_filename unexpectedly threw \" + e);\n        }\n\n        // Revert original filename.\n        result.filename = originalFilename;\n\n        // Preserving the original numElems, set numElems.\n        int originalNumElems = result.numElems;\n        result.numElems = -1;\n", "        try {\n            readArray(result.filename, result.numElems, result.type);\n        }\n        catch (IllegalArgumentException e) {\n            LOG.info(\"bad_num_elems failed correctly with \" + e);\n        }\n        catch (Exception e) {\n            LOG.info(\"bad_num_elems unexpectedly threw \" + e);\n        }\n\n        // Revert original numElems.\n        result.numElems = originalNumElems;\n\n        // Preserving the original type, set type.\n        // 'h' is an invalid type as it does not represent a Java primitive.\n        int originalType = result.type;\n        result.type = 'h';\n", "        try {\n            readArray(result.filename, result.numElems, result.type);\n        }\n        catch (IllegalArgumentException e) {\n            LOG.info(\"bad_type failed correctly with \" + e);\n        }\n        catch (Exception e) {\n            LOG.info(\"bad_type unexpectedly threw \" + e);\n        }\n\n        // Revert original type.\n        result.numElems = originalType;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/AsType.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n// We use cog.py to provide the different versions of the various methods. In\n// order to update this file you need to do:\n//   cog.py -rc AsType.java\n//\n// See:  https://nedbatchelder.com/code/cog\n//       https://www.python.org/about/success/cog/\n\n/**", "\n/**\n * Some methods for type \"hinting\", to be used when going from the Python to the\n * Java side. This works by effectively telling the Python side what type we\n * want and letting it figure out how to convert what it has into that desired\n * type. This can be useful when heavily overloaded methods yield ambiguous or\n * undesired binding semantics.\n *\n * <p>E.g.<pre>\n *   AsType = class_for_name('com.deshaw.pjrmi.AsType')", " * <p>E.g.<pre>\n *   AsType = class_for_name('com.deshaw.pjrmi.AsType')\n *   Arrays = class_for_name('java.util.Arrays')\n *   ints = tuple(range(10))\n *   Arrays.toString(AsType.int1d(ints))\n * </pre>\n */\npublic class AsType\n{\n    /**\n     * Private CTOR to prevent instantiation.\n     */\n    private AsType()\n    {\n    }\n\n    /**\n     * A function for converting a value to an {@link Object}. If the given\n     * value is already an {@link Object} instance then this is just a casting\n     * operation. If the given value is a primitive then this is a boxing\n     * operation.\n     *\n     * @param v The value to convert.\n     *\n     * @return the {@link Object} version of the value.\n     */", "    public static Object asObject(final Object v)\n    {\n        return v;\n    }\n\n    // [[[cog\n    //     import cog\n    //     PRIMITIVE_NUMBERS = ('byte', 'short', 'int', 'long', 'float', 'double')\n    //     BOXES = {'char'   : 'Character',\n    //              'byte'   : 'Byte',\n    //              'short'  : 'Short',\n    //              'int'    : 'Integer',\n    //              'long'   : 'Long',\n    //              'float'  : 'Float',\n    //              'double' : 'Double'}\n    //\n    //     # Functions to convert to the different types. Some of these are\n    //     # identity functions but help with type disambiguation when going\n    //     # from Python to Java.\n    //     #\n    //     # While some of these methods exist elsewhere, in other forms, it's\n    //     # convenient to have them all in one place when it comes to using\n    //     # them on the Python side.\n    //\n    //     as_type = '''\\\n    //        /**\n    //         * A function for converting a primitive to the {{@link Object}}-based\n    //         * version of itself.\n    //         *\n    //         * <p>This is semantically {{@code {boxed_type}.valueOf(v)}}.\n    //         *\n    //         * @param v The value to box.\n    //         *\n    //         * @return the boxed value.\n    //         */\n    //        public static {boxed_type} as{boxed_type}(final {type} v)\n    //        {{\n    //            return v;\n    //        }}\n    //     '''\n    //\n    //     identity = '''\\\n    //        /**\n    //         * An identity function for converting a {ndim}-dimension {type} value to itself.\n    //         *\n    //         * @param v The value to return.\n    //         *\n    //         * @return the value given.\n    //         */\n    //        public static {type}{dims} {ltype}{ndim}d(final {type}{dims} v)\n    //        {{\n    //            return v;\n    //        }}\n    //     '''\n    //\n    //     # ------------------------------------------------------------------\n    //\n    //     #", "    //     for (type, boxed_type) in BOXES.items():\n    //         cog.outl(as_type.format(type      =type,\n    //                                 boxed_type=boxed_type))\n    //\n    //     # Do this for all the primitive numbers, and also for Object and\n    //     # String, which also can suffer from binding abiguities.\n    //     for type in (PRIMITIVE_NUMBERS + ('Object', 'String')):\n    //         for ndim in range(1, 6):\n    //             cog.outl(identity.format(type=type,\n    //                                      ltype=type.lower(),\n    //                                      ndim=ndim,\n    //                                      dims=''.join(['[]'] * ndim)))\n    // ]]]\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Character.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Character asCharacter(final char v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Byte.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Byte asByte(final byte v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Short.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Short asShort(final short v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Integer.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Integer asInteger(final int v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Long.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Long asLong(final long v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Float.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Float asFloat(final float v)\n    {\n        return v;\n    }\n\n    /**\n     * A function for converting a primitive to the {@link Object}-based\n     * version of itself.\n     *\n     * <p>This is semantically {@code Double.valueOf(v)}.\n     *\n     * @param v The value to box.\n     *\n     * @return the boxed value.\n     */", "    public static Double asDouble(final double v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension byte value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static byte[] byte1d(final byte[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension byte value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static byte[][] byte2d(final byte[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension byte value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static byte[][][] byte3d(final byte[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension byte value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static byte[][][][] byte4d(final byte[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension byte value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static byte[][][][][] byte5d(final byte[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension short value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static short[] short1d(final short[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension short value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static short[][] short2d(final short[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension short value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static short[][][] short3d(final short[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension short value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static short[][][][] short4d(final short[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension short value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static short[][][][][] short5d(final short[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension int value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static int[] int1d(final int[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension int value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static int[][] int2d(final int[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension int value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static int[][][] int3d(final int[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension int value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static int[][][][] int4d(final int[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension int value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static int[][][][][] int5d(final int[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension long value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static long[] long1d(final long[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension long value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static long[][] long2d(final long[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension long value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static long[][][] long3d(final long[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension long value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static long[][][][] long4d(final long[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension long value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static long[][][][][] long5d(final long[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension float value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static float[] float1d(final float[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension float value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static float[][] float2d(final float[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension float value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static float[][][] float3d(final float[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension float value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static float[][][][] float4d(final float[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension float value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static float[][][][][] float5d(final float[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension double value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static double[] double1d(final double[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension double value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static double[][] double2d(final double[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension double value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static double[][][] double3d(final double[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension double value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static double[][][][] double4d(final double[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension double value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static double[][][][][] double5d(final double[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension Object value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static Object[] object1d(final Object[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension Object value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static Object[][] object2d(final Object[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension Object value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static Object[][][] object3d(final Object[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension Object value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static Object[][][][] object4d(final Object[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension Object value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static Object[][][][][] object5d(final Object[][][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 1-dimension String value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static String[] string1d(final String[] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 2-dimension String value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static String[][] string2d(final String[][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 3-dimension String value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static String[][][] string3d(final String[][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 4-dimension String value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static String[][][][] string4d(final String[][][][] v)\n    {\n        return v;\n    }\n\n    /**\n     * An identity function for converting a 5-dimension String value to itself.\n     *\n     * @param v The value to return.\n     *\n     * @return the value given.\n     */", "    public static String[][][][][] string5d(final String[][][][][] v)\n    {\n        return v;\n    }\n\n    // [[[end]]] (checksum: 645ac2cb137f0df1c7d65bdc8fe4cf39)\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/JavaProxyBase.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n/**\n * An empty interface which we use for marshalling a Python {@code JavaProxyBase}\n * as an {@link Object}.\n */\npublic interface JavaProxyBase\n{\n    // Nothing\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/UnixSignals.java", "chunked_list": ["package com.deshaw.pjrmi;\n\n/**\n * Methods to work with Unix signals.\n */\npublic class UnixSignals\n{\n    /**\n     * Ignore the given signal.\n     *\n     * @param signalName The standard Unix name, like {@code INT}.\n     */", "    public static void ignoreSignal(final String signalName)\n    {\n        sun.misc.Signal.handle(new sun.misc.Signal(signalName), signal -> {});\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/SSLSocketProvider.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.FileInputStream;\n\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;", "import java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\n\nimport java.util.Objects;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;", "import javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocketFactory;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManagerFactory;\n\n/**\n * A transport provider for an SSL socket connection.\n */\npublic class SSLSocketProvider\n    implements Transport.Provider\n{\n    /**\n     * The default TLS version which we use.\n     */\n    private static final String TLS_VERSION = \"TLSv1.2\";\n\n    /**\n     * The server socket which we use.\n     */\n    private final SSLServerSocket myServerSocket;\n\n    /**\n     * Our string representation.\n     */\n    private final String myString;\n\n    /**\n     * CTOR using the default TLS 1.2 version.\n     */\n    public SSLSocketProvider(final int    port,\n                             final String storeFilename,\n                             final String storePassword)\n        throws IOException\n    {\n        this(port, TLS_VERSION, storeFilename, storePassword);\n    }\n\n    /**\n     * CTOR.\n     */\n    public SSLSocketProvider(final int    port,\n                             final String tlsVersion,\n                             final String storeFilename,\n                             final String storePassword)\n        throws IOException\n    {\n        // We need these, but we'll allow missing/empty passwords\n        Objects.requireNonNull(tlsVersion,\n                               \"TLS version was null\");\n        Objects.requireNonNull(storeFilename,\n                               \"Store filename was null\");\n\n        // Our descriptive string\n        myString = \"SSLSocket[\" +\n            port          + \":\" +\n            tlsVersion    + \":\" +\n            storeFilename +\n        \"]\";\n\n        // Build our factories by reading in the store's contents\n        final KeyManagerFactory keyFactory;\n        final TrustManagerFactory trustFactory;\n        try (InputStream is = new FileInputStream(storeFilename)) {\n            // We'll need the password as a char[]\n            final char[] password;", " * A transport provider for an SSL socket connection.\n */\npublic class SSLSocketProvider\n    implements Transport.Provider\n{\n    /**\n     * The default TLS version which we use.\n     */\n    private static final String TLS_VERSION = \"TLSv1.2\";\n\n    /**\n     * The server socket which we use.\n     */\n    private final SSLServerSocket myServerSocket;\n\n    /**\n     * Our string representation.\n     */\n    private final String myString;\n\n    /**\n     * CTOR using the default TLS 1.2 version.\n     */\n    public SSLSocketProvider(final int    port,\n                             final String storeFilename,\n                             final String storePassword)\n        throws IOException\n    {\n        this(port, TLS_VERSION, storeFilename, storePassword);\n    }\n\n    /**\n     * CTOR.\n     */\n    public SSLSocketProvider(final int    port,\n                             final String tlsVersion,\n                             final String storeFilename,\n                             final String storePassword)\n        throws IOException\n    {\n        // We need these, but we'll allow missing/empty passwords\n        Objects.requireNonNull(tlsVersion,\n                               \"TLS version was null\");\n        Objects.requireNonNull(storeFilename,\n                               \"Store filename was null\");\n\n        // Our descriptive string\n        myString = \"SSLSocket[\" +\n            port          + \":\" +\n            tlsVersion    + \":\" +\n            storeFilename +\n        \"]\";\n\n        // Build our factories by reading in the store's contents\n        final KeyManagerFactory keyFactory;\n        final TrustManagerFactory trustFactory;\n        try (InputStream is = new FileInputStream(storeFilename)) {\n            // We'll need the password as a char[]\n            final char[] password;", "            if (storePassword != null) {\n                password = new char[storePassword.length()];\n                storePassword.getChars(0, password.length, password, 0);\n            }\n            else {\n                password = new char[0];\n            }\n\n            // Open the store\n            final KeyStore store =\n                KeyStore.getInstance(KeyStore.getDefaultType());\n            store.load(is, password);\n\n            // And create our two factories\n            keyFactory = KeyManagerFactory.getInstance(\n                KeyManagerFactory.getDefaultAlgorithm()\n            );\n            keyFactory.init(store, password);\n            trustFactory = TrustManagerFactory.getInstance(\n                TrustManagerFactory.getDefaultAlgorithm()\n            );\n            trustFactory.init(store);\n        }\n        catch (CertificateException     |\n               KeyStoreException        |\n               NoSuchAlgorithmException |\n               UnrecoverableKeyException e)\n        {\n            throw new IOException(\n                \"Error reading store \" + storeFilename,\n                e\n            );\n        }\n\n        // Create the SSL socket", "        try {\n            final SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(keyFactory  .getKeyManagers(),\n                         trustFactory.getTrustManagers(),\n                         SecureRandom.getInstanceStrong());\n\n            final SSLServerSocketFactory socketFactory =\n                context.getServerSocketFactory();\n            myServerSocket =\n                (SSLServerSocket)socketFactory.createServerSocket(port);\n            myServerSocket.setNeedClientAuth(true);\n            myServerSocket.setEnabledProtocols(new String[] {tlsVersion});\n        }\n        catch (KeyManagementException |\n               NoSuchAlgorithmException e)\n        {\n            throw new IOException(\"Error creating SSL context\", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public Transport accept()\n        throws IOException\n    {\n        try {\n            return new SSLSocketTransport((SSLSocket)myServerSocket.accept());\n        }\n        catch (ClassCastException e) {\n            // Should not happen\n            throw new IOException(e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return myString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        myServerSocket.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void close()\n        throws IOException\n    {\n        myServerSocket.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return myServerSocket.isClosed();\n    }\n}\n", "    public boolean isClosed()\n    {\n        return myServerSocket.isClosed();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/MethodUtil.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * MethodUtil provides utility functions for queries related to Java methods.", "/**\n * MethodUtil provides utility functions for queries related to Java methods.\n */\npublic class MethodUtil\n{\n    /**\n     * How we wrap a Method or Constructor so that we can use the same methods\n     * in each case.\n     */\n    private static interface CallableWrapper\n    {\n        /**\n         * Get the name. For a method it's the method name, for example.\n         */", "        public String getName();\n\n        /**\n         * Get the return type.\n         */\n        public Class<?> getReturnType();\n\n        /**\n         * Get the arguments.\n         */\n        public Class<?>[] getParameterTypes();\n    }\n\n    /**\n     * The Method version of CallableWrapper.\n     */\n    private static class MethodWrapper\n        implements CallableWrapper\n    {\n        /**\n         * The method which we wrap.\n         */\n        private final Method myMethod;\n\n        /**\n         * CTOR.\n         */\n        public MethodWrapper(final Method method)\n        {\n            myMethod = method;\n        }\n\n        /**\n         * Get the method.\n         */", "        public Method get()\n        {\n            return myMethod;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String getName()\n        {\n            return myMethod.getName();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?> getReturnType()\n        {\n            return myMethod.getReturnType();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?>[] getParameterTypes()\n        {\n            return myMethod.getParameterTypes();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String getName()\n        {\n            return myMethod.getName();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?> getReturnType()\n        {\n            return myMethod.getReturnType();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?>[] getParameterTypes()\n        {\n            return myMethod.getParameterTypes();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return myMethod.toString();\n        }\n    }\n\n    /**\n     * The Constructor version of CallableWrapper.\n     */\n    private static class ConstructorWrapper\n        implements CallableWrapper\n    {\n        /**\n         * The constructor which we wrap.\n         */\n        private final Constructor<?> myConstructor;\n\n        /**\n         * CTOR.\n         */\n        public ConstructorWrapper(final Constructor<?> constructor)\n        {\n            myConstructor = constructor;\n        }\n\n        /**\n         * Get the constructor.\n         */\n        public Constructor<?> get()\n        {\n            return myConstructor;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String getName()\n        {\n            return myConstructor.getName();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?> getReturnType()\n        {\n            return myConstructor.getDeclaringClass();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Class<?>[] getParameterTypes()\n        {\n            return myConstructor.getParameterTypes();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return myConstructor.toString();\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Compare two methods according to the Java compiler binding semantics.\n     * Read the Java spec, referenced below, for the official definition of\n     * what that means.\n     *\n     * <p>We only return a non-zero value if there exists a defined binding\n     * ordering between the two methods.\n     *\n     * <p>Firstly, we check to see if the two methods overload one-another. If\n     * they do not (i.e. their names differ, or they have a different number of\n     * arguments) then we return zero, since they are not comparable.\n     *\n     * <p>At this point, we have determined that the methods overload one-\n     * another, and we need to now determine whether one method has a more\n     * specific binding that the other one.\n     *\n     * <p>For example, assume that we have three classes all linearly inheriting\n     * from one another: {@code A}, {@code B} and {@code C}; where {@code A} is\n     * at the root of the inheritance hierachy. Now consider we have the\n     * following methods:<ul>\n     *   <li>{@code void f(B x, B y)}</li>\n     *   <li>{@code void f(A x, B y)}</li>\n     *   <li>{@code void f(A x, A y)}</li>\n     * </ul>\n     * These are in the ordering of most specific to least specific. If we call\n     * the function with two {@code B} instances then we want to get the first\n     * one in the list, even though that call would work for the last one in the\n     * list too.\n     *\n     * <p>Note that, per the language spec (see below) one method is only more\n     * specific than another one if <i>all</i> of the former's arguments' types\n     * are not less specific than the corresponding ones in the latter. I.e. if\n     * we have:<ul>\n     *  <li>{@code void f(Number x, Integer y, Object  z)}</li>\n     *  <li>{@code void f(Object x, Integer y, Integer z)}</li>\n     * </ul>\n     * Then the latter method is not more specific because the {@code Number} in\n     * the former is more specific than its {@code Object}. You might think that\n     * calling {@code f} with 3 {@code Integer}s would be unambiguous, but it's\n     * not.\n     *\n     * <p>Finally, if a method in one class is overridden in a subclass then\n     * it's possible for it to have the same arguments but a more specific\n     * return type. These latter methods are considered to be more specific\n     * since the latter will shadow the former.\n     *\n     * <p>Users should note that this method does not conform to the contract of\n     * the equivalent one in {@link Comparator} because a return of zero does\n     * not imply equality. As such, this method may not be used for general\n     * purpose sorting algorithms.\n     *\n     * @see <dl>\n     *   <dt>The Java SE8 Language specification:</dt>\n     *   <dd><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\">\n     *       15.12.2.5. Choosing the Most Specific Method</a></dd>\n     * </dl>\n     *\n     * @param m1  The first method.\n     * @param m2  The second method.\n     *\n     * @return A negative value if {@code m1} was more specific than {@code m2}.\n     *         A positive value if the converse was true. Zero if the methods\n     *         have no defined ordering between them. (A zero does <b>not</b>\n     *         imply equality.\n     */", "    public static int compareBySpecificity(final Method m1, final Method m2)\n    {\n        return compareBySpecificity(new MethodWrapper(m1),\n                                    new MethodWrapper(m2));\n    }\n\n    /**\n     * The {@link Constructor} version of {@link #compareBySpecificity(Method,Method)}.\n     *\n     * @param m1  The first method.\n     * @param m2  The second method.\n     *\n     * @return the relative specificity.\n     */", "    public static int compareBySpecificity(final Constructor<?> m1,\n                                           final Constructor<?> m2)\n    {\n        return compareBySpecificity(new ConstructorWrapper(m1),\n                                    new ConstructorWrapper(m2));\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * How we actually compare any two CallableWrappers.\n     *\n     * @see #compareBySpecificity(Method,Method)\n     *\n     * @param w1  The first wrapper.\n     * @param w2  The second wrapper.\n     *\n     * @return the relative specificity.\n     */\n    private static int compareBySpecificity(final CallableWrapper w1,\n                                            final CallableWrapper w2)\n    {\n        // Simple name compare\n        final String n1 = w1.getName();\n        final String n2 = w2.getName();", "        if (!n1.equals(n2)) {\n            return 0;\n        }\n\n        // Simple num-args compare\n        final Class<?>[] a1 = w1.getParameterTypes();\n        final Class<?>[] a2 = w2.getParameterTypes();\n        if (a1.length != a2.length) {\n            return 0;\n        }\n\n        // Now compare by specificity. If m1's arguments are more specific then\n        // they are \"less than\" the those of m2. E.g. this is an ordering:\n        //   f(Integer)\n        //   f(Number)\n        //   f(Object)\n        //\n        // Note that if there is no definite ordering then we return zero, e.g.\n        // for:\n        //   f(Integer, Number)\n        //   f(Number, Integer)\n        // neither one is greater than the other.\n        //\n        // Also note that, if two methods have arguments which are not in the\n        // same inheritance tree then they are not comparable (i.e. we return\n        // zero). Consider these interfaces:\n        //   A, B-extends-A, C, D\n        // and these methods:\n        //   void f(A, C)\n        //   void f(B, D)\n        // These calls are:\n        //   f(a,    null);  <-- unique and unambiguous\n        //   f(b,    null);  <-- ambiguous (could bind to either)\n        //   f(null, null);  <-- ambiguous (could bind to either)\n        //   f(a,    c);     <-- unique and unambiguous\n        //   f(b,    d);     <-- unique and unambiguous\n        // So, in all cases, no specificity ordering exists.\n        //\n        // Finally, note that it's possible for the arguments to _exactly_ match\n        // if one class overrides a method in another class but has a more\n        // specific return type. As such, we need to know if that happens too\n        // and tie-break on the return type.\n        boolean match = true;\n        int cmp = 0;", "        for (int i=0; i < a1.length; i++) {\n            final Class<?> c1 = a1[i];\n            final Class<?> c2 = a2[i];\n            if (areEquivalent(c1, c2)) {\n                // Same class is not more or less specific\n            }\n            else if (isAssignableFrom(c1, c2)) {\n                if (cmp < 0) {\n                    // We have one argument which is more specific and one\n                    // argument which is less specific; therefore neither method\n                    // is more specific than the other. See above.\n                    return 0;\n                }\n                else {\n                    // Remember the direction of specificity, so we can check\n                    // that all the arguments don't have conflicting directions.\n                    // (As per the if block just above.)\n                    cmp  = 1;\n                    match = false;\n                }\n            }", "            else if (isAssignableFrom(c2, c1)) {\n                if (cmp > 0) {\n                    // The same one-more/one-less case, like above.\n                    return 0;\n                }\n                else {\n                    // Remember the direction, like above.\n                    cmp   = -1;\n                    match = false;\n                }\n            }\n            else {\n                // The two types have no relation and so they are uncomparable.\n                // This renders the entire method uncomparable also. Per Java\n                // semantics, it can now not be more specific than another\n                // method.\n                return 0;\n            }\n        }\n\n        // Did we get an exact match in the arguments?", "        if (match) {\n            // The more specific return type overrides the less specific one\n            final Class<?> r1 = w1.getReturnType();\n            final Class<?> r2 = w2.getReturnType();\n            if (r1.equals(r2)) {\n                // This can happen if we were passed two identical methods\n                return 0;\n            }\n            else if (isAssignableFrom(r1, r2)) {\n                // w1's overridden by w2 so it's after w2 in terms of\n                // specificity\n                return 1;\n            }", "            else if (isAssignableFrom(r1, r2)) {\n                // w1's overridden by w2 so it's after w2 in terms of\n                // specificity\n                return 1;\n            }\n            else if (isAssignableFrom(r2, r1)) {\n                // w1 overrides w2 so it's before w2 in terms of specificity\n                return -1;\n            }\n            else {\n                // The two return types are different classes and, so, they are\n                // not comparable\n                return 0;\n            }\n        }\n        else {\n            // The signed result indicates the relative specificity of the\n            // arguments\n            return cmp;\n        }\n    }\n\n    /**\n     * Whether two classes are equivalent, with understanding of auto-boxing.\n     * This is in the context of method comparison, as opposed to type equality.\n     */\n    private static boolean areEquivalent(final Class<?> c1, final Class<?> c2)\n    {\n        // If both are null or equal then they are equivalent", "        if (Objects.equals(c1, c2)) {\n            return true;\n        }\n\n        // If one of them is null then they can't be equivalent. (They can't\n        // both be null at this point since Object.equals() will have returned\n        // true above.)\n        if (c1 == null || c2 == null) {\n            return false;\n        }\n\n        // Handle one of the them being primitive.\n        //\n        // Note that we are only considering equivalence here for the purposes\n        // of method binding/overriding. That is to say that, for two methods:\n        //   void f(Integer i) { ... }\n        //   void f(int     i) { ... }\n        // there is no obvious ordering between them. If we pass in an int or an\n        // Integer in Java then it's obvious which one should be bound to.\n        // However, this is not the case on the PJRmi side of things, since a\n        // Python integer can be both an int and an Integer; in that case it is\n        // ambiguous which method we should be binding to. Or, to put it another\n        // way, without knowing the arguments with which each method may be\n        // called, it's unclear which is more specific. This is not the case if\n        // you have, say, Number and Integer, where you have well defined\n        // specificity semantics.", "        if (c1.isPrimitive() && !c2.isPrimitive()) {\n            if (c1.equals(Boolean  .TYPE)) return c2.equals(Boolean  .class);\n            if (c1.equals(Character.TYPE)) return c2.equals(Character.class);\n            if (c1.equals(Byte     .TYPE)) return c2.equals(Byte     .class);\n            if (c1.equals(Short    .TYPE)) return c2.equals(Short    .class);\n            if (c1.equals(Integer  .TYPE)) return c2.equals(Integer  .class);\n            if (c1.equals(Long     .TYPE)) return c2.equals(Long     .class);\n            if (c1.equals(Float    .TYPE)) return c2.equals(Float    .class);\n            if (c1.equals(Double   .TYPE)) return c2.equals(Double   .class);\n            if (c1.equals(Void     .TYPE)) return c2.equals(Void     .class);\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c1\n            );\n        }", "            if (c1.equals(Double   .TYPE)) return c2.equals(Double   .class);\n            if (c1.equals(Void     .TYPE)) return c2.equals(Void     .class);\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c1\n            );\n        }\n        else if (!c1.isPrimitive() && c2.isPrimitive()) {\n            if (c2.equals(Boolean  .TYPE)) return c1.equals(Boolean  .class);\n            if (c2.equals(Character.TYPE)) return c1.equals(Character.class);\n            if (c2.equals(Byte     .TYPE)) return c1.equals(Byte     .class);\n            if (c2.equals(Short    .TYPE)) return c1.equals(Short    .class);", "            if (c2.equals(Character.TYPE)) return c1.equals(Character.class);\n            if (c2.equals(Byte     .TYPE)) return c1.equals(Byte     .class);\n            if (c2.equals(Short    .TYPE)) return c1.equals(Short    .class);\n            if (c2.equals(Integer  .TYPE)) return c1.equals(Integer  .class);\n            if (c2.equals(Long     .TYPE)) return c1.equals(Long     .class);\n            if (c2.equals(Float    .TYPE)) return c1.equals(Float    .class);\n            if (c2.equals(Double   .TYPE)) return c1.equals(Double   .class);\n            if (c2.equals(Void     .TYPE)) return c1.equals(Void     .class);\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c2\n            );\n        }\n        else {\n            // Both were either primitive or non-primitive and so, per the\n            // earlier tests, they can't be equivalent\n            return false;\n        }\n    }\n\n    /**\n     * Whether one class is assignable from another class. This is just like the\n     * standard {@link Class} version of the method, except that it will handle\n     * primitives too.\n     *\n     * <p>Calling this method with non-primitive classes should be equivalent to\n     * called the code:<pre>\n     *    c1.isAssignableFrom(c2)\n     * </pre>\n     * Calling it with primitives will yield the same results as one would\n     * expect from compiled code. For example, one may assign a {@code long} to\n     * a {@code double} but not vice versa (without casting).\n     *\n     * <p>One important caveat here is how we handle auto-(un)boxing, since we\n     * break with the Java semantics. When compiling code, then the following is\n     * true:<pre>\n     *   Integer a = 1; // compiles\n     *   Long    b = 1; // does not compile: int cannot be converted to Long\n     *   Integer c = b; // does not compile: Long cannot be converted to Integer\n     *   Long    d = a; // does not compile: Integer cannot be converted to Long\n     *   int     e = a; // compiles\n     *   long    f = a; // compiles\n     *   int     g = b; // does not compile: Long cannot be converted to int\n     *   long    h = b; // compiles\n     * </pre>. This means that we have asymmetry between what happens in the\n     * {@code Object} world vs in the primitive one. While this is soluble when\n     * binding methods at compile time, it's not so when comparing methods like\n     * we do above. (This asymmetry means that<pre>\n     *   compare(m1, m2) != -compare(m2, m1)\n     * </pre>.) As such, we simply say that a boxable type is only assignable to\n     * and from its equivalent.\n     *\n     * <p>If either class is {@code null} then this method will return\n     * {@code false}.\n     */\n    private static boolean isAssignableFrom(final Class<?> c1, final Class<?> c2)\n    {\n        // You can never assign to or from a null class", "        if (c1 == null || c2 == null) {\n            return false;\n        }\n\n        // Primitives or non-primitives?\n        if (!c1.isPrimitive() && !c2.isPrimitive()) {\n            // Class semantics\n            return c1.isAssignableFrom(c2);\n        }\n        else if (c1.isPrimitive() && c2.isPrimitive()) {\n            // Primitive semantics. We disallow any lossy conversions or ones\n            // which simply aren't allowed.", "        else if (c1.isPrimitive() && c2.isPrimitive()) {\n            // Primitive semantics. We disallow any lossy conversions or ones\n            // which simply aren't allowed.\n            if (c1.equals(byte.class)) {\n                return (c2.equals(byte   .class));\n            }\n\n            if (c1.equals(short.class)) {\n                return (c2.equals(short  .class) ||\n                        c2.equals(byte   .class));\n            }\n", "            if (c1.equals(int.class)) {\n                return (c2.equals(int    .class) ||\n                        c2.equals(short  .class) ||\n                        c2.equals(byte   .class) ||\n                        c2.equals(char   .class));\n            }\n\n            if (c1.equals(long.class)) {\n                return (c2.equals(long   .class) ||\n                        c2.equals(int    .class) ||\n                        c2.equals(short  .class) ||\n                        c2.equals(byte   .class) ||\n                        c2.equals(char   .class));\n            }\n", "            if (c1.equals(float.class)) {\n                return (c2.equals(float  .class) ||\n                        c2.equals(long   .class) ||\n                        c2.equals(int    .class) ||\n                        c2.equals(short  .class) ||\n                        c2.equals(byte   .class) ||\n                        c2.equals(char   .class));\n            }\n\n            if (c1.equals(double.class)) {\n                return (c2.equals(double .class) ||\n                        c2.equals(float  .class) ||\n                        c2.equals(long   .class) ||\n                        c2.equals(int    .class) ||\n                        c2.equals(short  .class) ||\n                        c2.equals(byte   .class) ||\n                        c2.equals(char   .class));\n            }\n", "            if (c1.equals(double.class)) {\n                return (c2.equals(double .class) ||\n                        c2.equals(float  .class) ||\n                        c2.equals(long   .class) ||\n                        c2.equals(int    .class) ||\n                        c2.equals(short  .class) ||\n                        c2.equals(byte   .class) ||\n                        c2.equals(char   .class));\n            }\n\n            if (c1.equals(char.class)) {\n                return (c2.equals(char   .class));\n            }\n", "            if (c1.equals(char.class)) {\n                return (c2.equals(char   .class));\n            }\n\n            if (c1.equals(boolean.class)) {\n                return (c2.equals(boolean.class));\n            }\n\n            if (c1.equals(void.class)) {\n                return false;\n            }\n", "            if (c1.equals(void.class)) {\n                return false;\n            }\n\n            // If the if()s above are canonical then we should never get here\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c1\n            );\n        }\n        else if (c1.isPrimitive() && !c2.isPrimitive()) {\n            // We dictate that a primitive is only assignable from its boxed\n            // Object type", "        else if (c1.isPrimitive() && !c2.isPrimitive()) {\n            // We dictate that a primitive is only assignable from its boxed\n            // Object type\n            if (c1.equals(Boolean  .TYPE)) return c2.equals(Boolean  .class);\n            if (c1.equals(Character.TYPE)) return c2.equals(Character.class);\n            if (c1.equals(Byte     .TYPE)) return c2.equals(Byte     .class);\n            if (c1.equals(Short    .TYPE)) return c2.equals(Short    .class);\n            if (c1.equals(Integer  .TYPE)) return c2.equals(Integer  .class);\n            if (c1.equals(Long     .TYPE)) return c2.equals(Long     .class);\n            if (c1.equals(Float    .TYPE)) return c2.equals(Float    .class);\n            if (c1.equals(Double   .TYPE)) return c2.equals(Double   .class);", "            if (c1.equals(Long     .TYPE)) return c2.equals(Long     .class);\n            if (c1.equals(Float    .TYPE)) return c2.equals(Float    .class);\n            if (c1.equals(Double   .TYPE)) return c2.equals(Double   .class);\n            if (c1.equals(Void     .TYPE)) return c2.equals(Void     .class);\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c1\n            );\n        }\n        else if (!c1.isPrimitive() && c2.isPrimitive()) {\n            // We dictate that a boxed Object type is only assignable from its\n            // primitive type. Note that we keep the same canonical list of\n            // types in the if statements, even if it looks a little weird to\n            // order things this way.", "        else if (!c1.isPrimitive() && c2.isPrimitive()) {\n            // We dictate that a boxed Object type is only assignable from its\n            // primitive type. Note that we keep the same canonical list of\n            // types in the if statements, even if it looks a little weird to\n            // order things this way.\n            if (c2.equals(Boolean  .TYPE)) return c1.equals(Boolean  .class);\n            if (c2.equals(Character.TYPE)) return c1.equals(Character.class);\n            if (c2.equals(Byte     .TYPE)) return c1.equals(Byte     .class);\n            if (c2.equals(Short    .TYPE)) return c1.equals(Short    .class);\n            if (c2.equals(Integer  .TYPE)) return c1.equals(Integer  .class);\n            if (c2.equals(Long     .TYPE)) return c1.equals(Long     .class);", "            if (c2.equals(Short    .TYPE)) return c1.equals(Short    .class);\n            if (c2.equals(Integer  .TYPE)) return c1.equals(Integer  .class);\n            if (c2.equals(Long     .TYPE)) return c1.equals(Long     .class);\n            if (c2.equals(Float    .TYPE)) return c1.equals(Float    .class);\n            if (c2.equals(Double   .TYPE)) return c1.equals(Double   .class);\n            if (c2.equals(Void     .TYPE)) return c1.equals(Void     .class);\n            throw new UnsupportedOperationException(\n                \"Unhandled native type: \" + c2\n            );\n        }\n        else {\n            throw new IllegalStateException(\"Unreachable statement\");\n        }\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/PythonKwargsFunction.java", "chunked_list": ["package com.deshaw.pjrmi;\n\nimport java.util.Map;\n\n/**\n * A Python function which may be invoked with arguments and key-word\n * arguments.\n */\n@FunctionalInterface\npublic interface PythonKwargsFunction<T>\n    extends PythonFunction<T>\n{\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "@FunctionalInterface\npublic interface PythonKwargsFunction<T>\n    extends PythonFunction<T>\n{\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public default T invoke(final Object... args)\n        throws Throwable\n    {\n        return invoke(null, args);\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param kwargs  The method's keyword arguments, if any (may be null).\n     * @param args    The method's arguments, if any (may be null).\n     *\n     * @return the result of the call.\n     *\n     * @throws IllegalArgumentException if the arguments were incorrect.\n     * @throws NoSuchMethodException    if there was no such method in the\n     *                                  Python object.\n     */", "    public default T invoke(final Object... args)\n        throws Throwable\n    {\n        return invoke(null, args);\n    }\n\n    /**\n     * Invoke a method on the object.\n     *\n     * @param kwargs  The method's keyword arguments, if any (may be null).\n     * @param args    The method's arguments, if any (may be null).\n     *\n     * @return the result of the call.\n     *\n     * @throws IllegalArgumentException if the arguments were incorrect.\n     * @throws NoSuchMethodException    if there was no such method in the\n     *                                  Python object.\n     */", "    public T invoke(final Map<String,Object> kwargs,\n                    final Object...          args)\n        throws Throwable;\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/pjrmi/test/PJRmiTestHelpers.java", "chunked_list": ["package com.deshaw.pjrmi.test;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n/**\n * Helper classes used in python PJRmi test cases.\n */\npublic class PJRmiTestHelpers\n{\n    /**\n     * Base class for the overridden methods unit test.\n     */", " */\npublic class PJRmiTestHelpers\n{\n    /**\n     * Base class for the overridden methods unit test.\n     */\n    public static class OverriddenMethodsBase\n    {\n        public CharSequence getValue()\n        {\n            return \"BASE\";\n        }\n    }\n\n    /**\n     * Subclass for the overridden methods unit test.\n     */", "        public CharSequence getValue()\n        {\n            return \"BASE\";\n        }\n    }\n\n    /**\n     * Subclass for the overridden methods unit test.\n     */\n    public static class OverriddenMethodsDerived\n        extends OverriddenMethodsBase\n    {\n        @Override", "    public static class OverriddenMethodsDerived\n        extends OverriddenMethodsBase\n    {\n        @Override\n        public String getValue()\n        {\n            return \"DERIVED\";\n        }\n    }\n\n    /**\n     * An interface which redefines methods in Object.\n     */", "    public static interface ObjectInterface\n    {\n        /**\n         * Redefine {@code hashCode()}.\n         */\n        public int hashCode();\n    }\n\n    // ----------------------------------------------------------------------\n\n    // Misc helper methods. Some of these may look pointless, but they do have a\n    // point; honest!\n\n    /**\n     * A method which takes a boolean[] and returns its length.\n     *\n     * @param array  The arrat.\n     *\n     * @return the length.\n     */", "    public static int booleanArrayLength(final boolean[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a boolean[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static boolean[] booleanArrayIdentity(final boolean[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a byte[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static int byteArrayLength(final byte[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a byte[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static byte[] byteArrayIdentity(final byte[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a short[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int shortArrayLength(final short[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a short[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static short[] shortArrayIdentity(final short[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a int[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int intArrayLength(final int[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a int[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static int[] intArrayIdentity(final int[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a long[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int longArrayLength(final long[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a long[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static long[] longArrayIdentity(final long[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a float[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int floatArrayLength(final float[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a float[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static float[] floatArrayIdentity(final float[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes a double[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int doubleArrayLength(final double[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a double[] and returns it.\n     *\n     * @param array  The array.\n     *\n     * @return the array\n     */", "    public static double[] doubleArrayIdentity(final double[] array)\n    {\n        return array;\n    }\n\n    /**\n     * A method which takes an Object, casts it to the appropriate array, and\n     * returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n\n     */", "    public static int objectLength(final Object array)\n    {\n        if (array instanceof boolean[]) {\n            return ((boolean[])array).length;\n        }\n        else if (array instanceof byte[]) {\n            return ((byte[])array).length;\n        }\n        else if (array instanceof short[]) {\n            return ((short[])array).length;\n        }", "        else if (array instanceof short[]) {\n            return ((short[])array).length;\n        }\n        else if (array instanceof int[]) {\n            return ((int[])array).length;\n        }\n        else if (array instanceof long[]) {\n            return ((long[])array).length;\n        }\n        else if (array instanceof float[]) {\n            return ((float[])array).length;\n        }", "        else if (array instanceof float[]) {\n            return ((float[])array).length;\n        }\n        else if (array instanceof double[]) {\n            return ((double[])array).length;\n        }\n        else if (array instanceof String[]) {\n            return ((String[])array).length;\n        }\n        else {\n            return -1;\n        }\n    }\n\n    /**\n     * A method which takes an Object[] and returns its length.\n     *\n     * @param array  The array.\n     *\n     * @return the length.\n     */", "    public static int objectArrayLength(final Object[] array)\n    {\n        return array.length;\n    }\n\n    /**\n     * A method which takes a Collection and returns its size.\n     *\n     * @param collection  The collection.\n     *\n     * @return the size.\n     */", "    public static int collectionSize(final Collection<?> collection)\n    {\n        return collection.size();\n    }\n\n    /**\n     * A method returning an {@link ObjectInterface}.\n     *\n     * @return the interface instance.\n     */\n    public static ObjectInterface getObjectInterface()\n    {\n        final class Result implements ObjectInterface { }\n        return new Result();\n    }\n\n    // ----------------------------------------------------------------------\n\n    // Method required for Python-side testing.\n\n    /**\n     * Method used to check if correct parameter names are received by python\n     * side. Please don't change this method's name or parameter names as we\n     * have tests that rely directly upon these values.\n     *\n     * @param num1  The first number.\n     * @param num2  The second number.\n     */", "    public static ObjectInterface getObjectInterface()\n    {\n        final class Result implements ObjectInterface { }\n        return new Result();\n    }\n\n    // ----------------------------------------------------------------------\n\n    // Method required for Python-side testing.\n\n    /**\n     * Method used to check if correct parameter names are received by python\n     * side. Please don't change this method's name or parameter names as we\n     * have tests that rely directly upon these values.\n     *\n     * @param num1  The first number.\n     * @param num2  The second number.\n     */", "    public static int add(int num1, int num2)\n    {\n        return num1 + num2;\n    }\n\n    // ----------------------------------------------------------------------\n\n    // Methods for the binding precedence test\n\n    /**\n     * A root class.\n     */", "    public static class A\n    {\n        // Nothing\n    }\n\n    /**\n     * Subclass of {@link A}.\n     */\n    public static class B\n        extends A\n    {\n        // Nothing\n    }\n\n    /**\n     * Subclass of {@link B}.\n     */", "    public static class B\n        extends A\n    {\n        // Nothing\n    }\n\n    /**\n     * Subclass of {@link B}.\n     */\n    public static class C\n        extends B\n    {\n        // Nothing\n    }\n\n    /**\n     * A class with Methods.\n     */", "    public static class C\n        extends B\n    {\n        // Nothing\n    }\n\n    /**\n     * A class with Methods.\n     */\n    public static class PrecedenceMethods\n    {", "    public static class PrecedenceMethods\n    {\n        public final String ctor;\n\n        // Constructors, which also have ambiuity etc.\n        public PrecedenceMethods()         { ctor =  \"v\"; }\n        public PrecedenceMethods(A x)      { ctor =  \"a\"; }\n        public PrecedenceMethods(B x)      { ctor =  \"b\"; }\n        public PrecedenceMethods(C x)      { ctor =  \"c\"; }\n        public PrecedenceMethods(A x, A y) { ctor = \"aa\"; }\n        public PrecedenceMethods(B x, A y) { ctor = \"ba\"; }\n        public PrecedenceMethods(A x, B y) { ctor = \"ab\"; }\n        public PrecedenceMethods(float  x) { ctor =  \"f\"; }\n        public PrecedenceMethods(double x) { ctor =  \"d\"; }\n        public PrecedenceMethods(short  x) { ctor =  \"s\"; }\n        public PrecedenceMethods(int    x) { ctor =  \"i\"; }\n        public PrecedenceMethods(long   x) { ctor =  \"l\"; }\n\n        // Least to most specific", "        public CharSequence f(A      x) { return \"cs_f_a\"; }\n        public CharSequence f(B      x) { return \"cs_f_b\"; }\n        public CharSequence f(C      x) { return \"cs_f_c\"; }\n        public CharSequence f(float  x) { return \"cs_f_f\"; }\n        public CharSequence f(double x) { return \"cs_f_d\"; }\n        public CharSequence f(short  x) { return \"cs_f_s\"; }\n        public CharSequence f(int    x) { return \"cs_f_i\"; }\n        public CharSequence f(long   x) { return \"cs_f_l\"; }\n\n        // Most to least specific\n        public CharSequence g(C      x) { return \"cs_g_c\"; }", "        public CharSequence g(C      x) { return \"cs_g_c\"; }\n        public CharSequence g(B      x) { return \"cs_g_b\"; }\n        public CharSequence g(A      x) { return \"cs_g_a\"; }\n        public CharSequence g(double x) { return \"cs_g_d\"; }\n        public CharSequence g(float  x) { return \"cs_g_f\"; }\n        public CharSequence g(long   x) { return \"cs_g_l\"; }\n        public CharSequence g(int    x) { return \"cs_g_i\"; }\n        public CharSequence g(short  x) { return \"cs_g_s\"; }\n\n        // Least to most specific\n        public CharSequence f(A x, A y) { return \"cs_f_aa\"; }", "        public CharSequence f(A x, A y) { return \"cs_f_aa\"; }\n        public CharSequence f(B x, A y) { return \"cs_f_ba\"; }\n        public CharSequence f(A x, B y) { return \"cs_f_ab\"; }\n\n        // Methods with what looks like a circular hierachy, but are actually\n        // all incomparable\n        public CharSequence f(Integer x, String  y, Number  z) { return \"cs_f_isn\"; }\n        public CharSequence f(Number  x, Integer y, String  z) { return \"cs_f_nis\"; }\n        public CharSequence f(String  x, Number  y, Integer z) { return \"cs_f_sni\"; }\n\n        // Ditto, but with inheritance between all the arguments", "        public CharSequence f(String  x, Number  y, Integer z) { return \"cs_f_sni\"; }\n\n        // Ditto, but with inheritance between all the arguments\n        public CharSequence f(Integer x, Object  y, Number  z) { return \"cs_f_ion\"; }\n        public CharSequence f(Number  x, Integer y, Object  z) { return \"cs_f_nio\"; }\n        public CharSequence f(Object  x, Number  y, Integer z) { return \"cs_f_oni\"; }\n\n        // Methods which should not, and should, enforce strict typing owing to\n        // whether they are overloaded or not\n        public CharSequence ff(int   i) { return \"cs_ff_i\"; }\n        public CharSequence gg(short i) { return \"cs_gg_s\"; }", "        public CharSequence ff(int   i) { return \"cs_ff_i\"; }\n        public CharSequence gg(short i) { return \"cs_gg_s\"; }\n        public CharSequence gg(int   i) { return \"cs_gg_i\"; }\n    }\n\n    /**\n     * A class with more methods, some of which override those in the parent\n     * class.\n     */\n    public static class MorePrecedenceMethods\n        extends PrecedenceMethods\n    {\n        // Methods where the first two are incomparable but the last one is more\n        // specific than both. Order is important here since the Python pjrmi\n        // unittest code relies on it.", "    public static class MorePrecedenceMethods\n        extends PrecedenceMethods\n    {\n        // Methods where the first two are incomparable but the last one is more\n        // specific than both. Order is important here since the Python pjrmi\n        // unittest code relies on it.\n        public CharSequence f(String x, Object y) { return \"cs_f_so\"; }\n        public CharSequence f(Object x, String y) { return \"cs_f_os\"; }\n        public CharSequence f(String x, String y) { return \"cs_f_ss\"; }\n\n        // Overloaded return type", "        public CharSequence f(String x, String y) { return \"cs_f_ss\"; }\n\n        // Overloaded return type\n        public String f(A x, A y) { return \"s_f_aa\"; }\n    }\n\n    /**\n     * An iterator that yields 1, 2, 3.\n     */\n    public static class OneTwoThreeIterator\n        implements Iterator<Integer>\n    {\n        private static class CustomNoSuchElementException\n            extends NoSuchElementException\n        {\n        }\n\n        private int myCounter = 0;\n\n        @Override", "    public static class OneTwoThreeIterator\n        implements Iterator<Integer>\n    {\n        private static class CustomNoSuchElementException\n            extends NoSuchElementException\n        {\n        }\n\n        private int myCounter = 0;\n\n        @Override", "        public boolean hasNext()\n        {\n            return myCounter < 3;\n        }\n\n        @Override\n        public Integer next()\n        {\n            if (hasNext()) {\n                myCounter++;\n                return myCounter;\n            }\n            else {\n                // Make sure we're able to handle classes extending\n                // NoSuchElementException as well.\n                throw new CustomNoSuchElementException();\n            }\n        }\n    }\n\n    /**\n     * An iterator that throws after yielding 1, 2.\n     */", "            if (hasNext()) {\n                myCounter++;\n                return myCounter;\n            }\n            else {\n                // Make sure we're able to handle classes extending\n                // NoSuchElementException as well.\n                throw new CustomNoSuchElementException();\n            }\n        }\n    }\n\n    /**\n     * An iterator that throws after yielding 1, 2.\n     */", "    public static class OneTwoThrowIterator\n        implements Iterator<Integer>\n    {\n        private int myCounter = 0;\n\n        @Override\n        public boolean hasNext()\n        {\n            return true;\n        }\n\n        @Override", "        public Integer next()\n        {\n            myCounter++;\n            if (myCounter < 3) {\n                return myCounter;\n            }\n            else {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/io/BlockingPipe.java", "chunked_list": ["package com.deshaw.io;\n\nimport java.util.concurrent.locks.LockSupport;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * A very simple pipe of fixed length which allows users to write data in one", "/**\n * A very simple pipe of fixed length which allows users to write data in one\n * end and read it out of another. The reader or writer will block if the pipe's\n * buffer is empty or full, respectively.\n *\n * <p>This class is only safe for one reader thread and one writer thread to use\n * at any given time. Reading and writing from the same thread may cause\n * deadlocks.\n *\n * <p>See also {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream}", " *\n * <p>See also {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream}\n * which do roughly the same thing but more slowly.\n */\npublic class BlockingPipe\n{\n    /**\n     * How to read from the pipe.\n     */\n    private class Input\n        extends InputStream\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int read()\n            throws IOException\n        {\n            return BlockingPipe.this.read();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n            throws IOException\n        {\n            BlockingPipe.this.close();\n        }\n    }\n\n    /**\n     * How to write to the pipe.\n     */\n    private class Output\n        extends OutputStream\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void close()\n            throws IOException\n        {\n            BlockingPipe.this.close();\n        }\n    }\n\n    /**\n     * How to write to the pipe.\n     */\n    private class Output\n        extends OutputStream\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void write(int b)\n            throws IOException\n        {\n            BlockingPipe.this.write(b);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n            throws IOException\n        {\n            BlockingPipe.this.close();\n        }\n    }\n\n    /**\n     * The head of the pipe.\n     */\n    private volatile long myHead;\n\n    /**\n     * The tail of the pipe.\n     */\n    private volatile long myTail;\n\n    /**\n     * The reader thread.\n     */\n    private volatile Thread myReader;\n\n    /**\n     * The writer thread.\n     */\n    private volatile Thread myWriter;\n\n    /**\n     * The input stream.\n     */\n    private final InputStream myInput;\n\n    /**\n     * The output stream.\n     */\n    private final OutputStream myOutput;\n\n    /**\n     * The pipe itself.\n     */\n    private final byte[] myData;\n\n    /**\n     * Whether the pipe is closed or not.\n     */\n    private volatile boolean myClosed;\n\n    /**\n     * Constructor.\n     *\n     * @param size  The size of the pipe.\n     */\n    public BlockingPipe(final int size)\n    {", "        public void close()\n            throws IOException\n        {\n            BlockingPipe.this.close();\n        }\n    }\n\n    /**\n     * The head of the pipe.\n     */\n    private volatile long myHead;\n\n    /**\n     * The tail of the pipe.\n     */\n    private volatile long myTail;\n\n    /**\n     * The reader thread.\n     */\n    private volatile Thread myReader;\n\n    /**\n     * The writer thread.\n     */\n    private volatile Thread myWriter;\n\n    /**\n     * The input stream.\n     */\n    private final InputStream myInput;\n\n    /**\n     * The output stream.\n     */\n    private final OutputStream myOutput;\n\n    /**\n     * The pipe itself.\n     */\n    private final byte[] myData;\n\n    /**\n     * Whether the pipe is closed or not.\n     */\n    private volatile boolean myClosed;\n\n    /**\n     * Constructor.\n     *\n     * @param size  The size of the pipe.\n     */\n    public BlockingPipe(final int size)\n    {", "        if (size <= 0) {\n            throw new IllegalArgumentException(\"Bad size: \" + size);\n        }\n\n        myHead   = 0;\n        myTail   = 0;\n        myInput  = new Input();\n        myOutput = new Output();\n        myData   = new byte[size];\n        myClosed = false;\n    }\n\n    /**\n     * Get the input stream for reading from the pipe.\n     *\n     * @return the input stream.\n     */", "    public InputStream getInputStream()\n    {\n        return myInput;\n    }\n\n    /**\n     * Get the output stream for writing to the pipe.\n     *\n     * @return the output stream.\n     */\n    public OutputStream getOutputStream()\n    {\n        return myOutput;\n    }\n\n    /**\n     * Read an unsigned byte value out.\n     *\n     * <p>It is not safe to call this method from multiple threads.\n     *\n     * @return the byte we read, as an unsigned value, or {@code -1} if\n     *          end-of-file was encountered.\n     */\n    protected int read()\n    {\n        // Wait for data to appear", "    public OutputStream getOutputStream()\n    {\n        return myOutput;\n    }\n\n    /**\n     * Read an unsigned byte value out.\n     *\n     * <p>It is not safe to call this method from multiple threads.\n     *\n     * @return the byte we read, as an unsigned value, or {@code -1} if\n     *          end-of-file was encountered.\n     */\n    protected int read()\n    {\n        // Wait for data to appear", "        while (myHead == myTail) {\n            // We've got no more data so this means EOF if we're closed\n            if (myClosed) {\n                return -1;\n            }\n\n            // Otherwise we wait for data\n            myReader = Thread.currentThread();\n            LockSupport.parkNanos(10000);\n        }\n\n        // Read it out\n        final byte result = myData[(int)(myHead % myData.length)];\n        myHead++;\n\n        // Kick the other thread, which could be waiting\n        LockSupport.unpark(myWriter);\n\n        // Give back what we read\n        return Byte.toUnsignedInt(result);\n    }\n\n    /**\n     * Write a byte in.\n     *\n     * <p>It is not safe to call this method from multiple threads.\n     *\n     * @param b  The byte to write.\n     *\n     * @throws IOException if the pipe is closed.\n     */\n    protected void write(int b)\n        throws IOException\n    {\n        // Can't write to a closed pipe", "        if (myClosed) {\n            throw new IOException(\"Broken pipe\");\n        }\n\n        // Wait for the pipe to have room\n        while (myTail - myHead >= myData.length) {\n            myWriter = Thread.currentThread();\n            LockSupport.parkNanos(10000);\n        }\n\n        // Write in the byte\n        myData[(int)(myTail % myData.length)] = (byte)b;\n        myTail++;\n\n        // Kick the other thread if it's waiting\n        LockSupport.unpark(myReader);\n    }\n\n    /**\n     * Close the pipe.\n     */\n    protected void close()\n    {\n        myClosed = true;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/BinString.java", "chunked_list": ["package com.deshaw.python;\n\nimport com.deshaw.util.ThreadLocalStringBuilder;\n\nimport java.nio.ByteBuffer;\n\n/**\n * ASCII string that wraps around {@link ByteBuffer}s.\n */\npublic class BinString\n    implements CharSequence\n{\n    /**\n     * Thread local string builders.\n     */\n    private static final ThreadLocalStringBuilder ourThreadLocalStringBuilder =\n        new ThreadLocalStringBuilder(64);\n\n    /**\n     * Byte buffer containing the data. May be heap-backed or direct.\n     */\n    private final ByteBuffer myData;\n\n    /**\n     * Constructor.\n     *\n     * @param data  The {@link ByteBuffer} to copy from.\n     */\n    public BinString(ByteBuffer data)\n    {\n        this(data, data.position(), data.remaining());\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param data    The data to copy from.\n     * @param offset  Where to start in the buffer.\n     * @param length  How many bytes to wrap from {@code offset}.\n     */\n    public BinString(ByteBuffer data, int offset, int length)\n    {\n        assert offset + length <= data.capacity();\n\n        ByteBuffer bufferCopy = data.duplicate();\n        bufferCopy.limit(offset + length).position(offset);\n        myData = bufferCopy.slice();\n    }\n\n    /**\n     * Underlying byte buffer.\n     *\n     * @return The buffer backing this instance.\n     */", " */\npublic class BinString\n    implements CharSequence\n{\n    /**\n     * Thread local string builders.\n     */\n    private static final ThreadLocalStringBuilder ourThreadLocalStringBuilder =\n        new ThreadLocalStringBuilder(64);\n\n    /**\n     * Byte buffer containing the data. May be heap-backed or direct.\n     */\n    private final ByteBuffer myData;\n\n    /**\n     * Constructor.\n     *\n     * @param data  The {@link ByteBuffer} to copy from.\n     */\n    public BinString(ByteBuffer data)\n    {\n        this(data, data.position(), data.remaining());\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param data    The data to copy from.\n     * @param offset  Where to start in the buffer.\n     * @param length  How many bytes to wrap from {@code offset}.\n     */\n    public BinString(ByteBuffer data, int offset, int length)\n    {\n        assert offset + length <= data.capacity();\n\n        ByteBuffer bufferCopy = data.duplicate();\n        bufferCopy.limit(offset + length).position(offset);\n        myData = bufferCopy.slice();\n    }\n\n    /**\n     * Underlying byte buffer.\n     *\n     * @return The buffer backing this instance.\n     */", "    public ByteBuffer data()\n    {\n        return myData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int length()\n    {\n        return myData.remaining();\n    }\n\n    /**\n     * Returns the {@code byte} value at a specified index.\n     *\n     * @param index  The index to get the value at.\n     *\n     * @return the {@code byte} at that index.\n     */", "    public int length()\n    {\n        return myData.remaining();\n    }\n\n    /**\n     * Returns the {@code byte} value at a specified index.\n     *\n     * @param index  The index to get the value at.\n     *\n     * @return the {@code byte} at that index.\n     */", "    public byte byteAt(int index)\n    {\n        return myData.get(index);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public char charAt(int index)\n    {\n        return (char) byteAt(index);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public char charAt(int index)\n    {\n        return (char) byteAt(index);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CharSequence subSequence(int start, int end)\n    {\n        return new BinString(myData, start, end);\n    }\n\n    /**\n     * Compares this object for <i>contents</i> equality with another\n     * {@link CharSequence}. This makes the implementation non-symmetric,\n     * but more useful in practice.\n     */\n    @Override", "    public CharSequence subSequence(int start, int end)\n    {\n        return new BinString(myData, start, end);\n    }\n\n    /**\n     * Compares this object for <i>contents</i> equality with another\n     * {@link CharSequence}. This makes the implementation non-symmetric,\n     * but more useful in practice.\n     */\n    @Override", "    public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof CharSequence)) {\n            return false;\n        }\n\n        CharSequence rhs = (CharSequence) o;\n        if (rhs.length() != length()) {\n            return false;\n        }", "        if (rhs.length() != length()) {\n            return false;\n        }\n        for (int i = 0, length = length(); i < length; i++) {\n            if (charAt(i) != rhs.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public int hashCode()\n    {\n        // Should match String.hashCode()'s API definition\n        int result = 0;\n        for (int i = 0, length = length(); i < length; i++) {\n            result = 31*result + charAt(i);\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return ourThreadLocalStringBuilder.get().append(this).toString();\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/Dict.java", "chunked_list": ["package com.deshaw.python;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A more Pythonic version of the map: throws exceptions when trying to access\n * missing keys.", " * A more Pythonic version of the map: throws exceptions when trying to access\n * missing keys.\n */\npublic class Dict\n    extends HashMap<Object,Object>\n{\n    /**\n     * Exception thrown when the key is missing from the dictionary.\n     */\n    public static class MissingKeyException\n        extends RuntimeException\n    {\n        private static final long serialVersionUID = -963449382298809244L;\n\n        /**\n         * Constructor.\n         *\n         * @param message  The exception message.\n         */\n        public MissingKeyException(String message)\n        {\n            super(message);\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    private static final long serialVersionUID = 3896936112974357004L;\n\n    /**\n     * Return the value to which the specified key is mapped.\n     *\n     * @throws MissingKeyException if the key is not in the dict.\n     */\n    @Override", "    public static class MissingKeyException\n        extends RuntimeException\n    {\n        private static final long serialVersionUID = -963449382298809244L;\n\n        /**\n         * Constructor.\n         *\n         * @param message  The exception message.\n         */\n        public MissingKeyException(String message)\n        {\n            super(message);\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    private static final long serialVersionUID = 3896936112974357004L;\n\n    /**\n     * Return the value to which the specified key is mapped.\n     *\n     * @throws MissingKeyException if the key is not in the dict.\n     */\n    @Override", "    public Object get(final Object key)\n        throws MissingKeyException\n    {\n        final Object v = super.get(key);\n        if (v != null) {\n            return v;\n        }\n        if (containsKey(key)) {\n            return null;\n        }\n        throw new MissingKeyException(\"Missing key '\" + key + \"'\");\n    }\n\n    /**\n     * Return the value to which the specified key is mapped or the specified\n     * default value if the key is not in the dict.\n     *\n     * @param <T>   The type of the object to get.\n     * @param key   The key to use for the lookup.\n     * @param dflt  The value to return if no match was found for the key.\n     *\n     * @return the element for the given key.\n     *\n     * @throws ClassCastException if any associated value was not the same time\n     *                            as the given default.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(final Object key, final T dflt)\n    {\n        final Object v = super.get(key);", "        if (v != null) {\n            return (T) v;\n        }\n        if (containsKey(key)) {\n            return null;\n        }\n        return dflt;\n    }\n\n    /**\n     * Get the {@code int} value corresponding to the given key.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public int getInt(Object key)\n    {\n        return ((Number) get(key)).intValue();\n    }\n\n    /**\n     * Get the {@code int} value corresponding to the given key, or the default\n     * value if it doesn't exist.\n     *\n     * @param key   The key to use for the lookup.\n     * @param dflt  The value to return if no match was found for the key.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public int getInt(Object key, int dflt)\n    {\n        return containsKey(key) ? getInt(key) : dflt;\n    }\n\n    /**\n     * Get the {@code long} value corresponding to the given key.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public long getLong(Object key)\n    {\n        return ((Number) get(key)).longValue();\n    }\n\n    /**\n     * Get the {@code long} value corresponding to the given key, or the default\n     * value if it doesn't exist.\n     *\n     * @param key   The key to use for the lookup.\n     * @param dflt  The value to return if no match was found for the key.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public long getLong(Object key, long dflt)\n    {\n        return containsKey(key) ? getLong(key) : dflt;\n    }\n\n    /**\n     * Get the {@code double} value corresponding to the given key.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public double getDouble(Object key)\n    {\n        return ((Number) get(key)).doubleValue();\n    }\n\n    /**\n     * Get the {@code double} value corresponding to the given key, or the default\n     * value if it doesn't exist.\n     *\n     * @param key   The key to use for the lookup.\n     * @param dflt  The value to return if no match was found for the key.\n     *\n     * @return the value associated with the given key.\n     *\n     * @throws ClassCastException if the associated value was not numeric.\n     */", "    public double getDouble(Object key, double dflt)\n    {\n        return containsKey(key) ? getDouble(key) : dflt;\n    }\n\n    /**\n     * Get the {@link List} value corresponding to the given key.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key, if any.\n     *\n     * @throws ClassCastException if the associated value was not a {@link List}.\n     */\n    public List<?> getList(Object key)\n    {\n        return (List<?>) get(key);\n    }\n\n    /**\n     * Return the value to which the key is mapped as a list of\n     * strings. Non-null entries are converted to strings by calling\n     * {@link String#valueOf(Object)}, and null entries are left\n     * unchanged.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key, if any.\n     *\n     * @throws ClassCastException if the associated value was not a {@link List}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public List<String> getStringList(Object key)\n    {\n        final List<?> rawList = getList(key);", "        if (rawList == null || rawList.isEmpty()) {\n            return (List<String>)rawList;\n        }\n\n        final List<String> stringList = new ArrayList<>();\n        for (Object raw : rawList) {\n            stringList.add((raw != null) ? String.valueOf(raw) : null);\n        }\n        return stringList;\n    }\n\n    /**\n     * Return the {@link NumpyArray} corresponding to the given key.\n     *\n     * @param key   The key to use for the lookup.\n     *\n     * @return the value associated with the given key, if any.\n     *\n     * @throws ClassCastException if the associated value was not a\n     *                            {@link NumpyArray}.\n     */", "    public NumpyArray getArray(Object key)\n    {\n        return (NumpyArray) get(key);\n    }\n\n    /**\n     * Return the {@link NumpyArray} corresponding to the given key and validate\n     * its dimensions.\n     *\n     * <p>See also {@link NumpyArray#validateShape(String, int...)}.\n     *\n     * @param key            The key to use for the lookup.\n     * @param expectedShape  The expected shape of the return value.\n     *\n     * @return the value associated with the given key, if any.\n     *\n     * @throws ClassCastException if the associated value was not a\n     *                            {@link NumpyArray}.\n     */", "    public NumpyArray getArray(Object key, int... expectedShape)\n    {\n        NumpyArray array = getArray(key);\n        array.validateShape(String.valueOf(key), expectedShape);\n        return array;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append('{');\n        boolean first = true;\n        for (Object rawEntry: entrySet()) {\n            Map.Entry e = (Map.Entry) rawEntry;\n            if (!first) {\n                sb.append(',');\n            }\n            first = false;\n            sb.append(' ');\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            sb.append(stringify(k)).append(\": \").append(stringify(v));\n        }", "        if (!first) {\n            sb.append(' ');\n        }\n        sb.append('}');\n        return sb.toString();\n    }\n\n    /**\n     * Wrap strings in quotes, but defer to {@link String#valueOf} for\n     * other types of objects.\n     *\n     * @param o  The object to turn into a string.\n     */\n    private String stringify(Object o)\n    {\n        return (o instanceof CharSequence) ? \"'\" + o + \"'\"\n                                           : String.valueOf(o);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/Operations.java", "chunked_list": ["package com.deshaw.python;\n\n/**\n * Pickle protocol opcodes. See the publicly availble Python pickle code for\n * their definitions.\n */\npublic enum Operations\n{\n    /** See Python. */ MARK           ((byte) '('),\n    /** See Python. */ STOP           ((byte) '.'),\n    /** See Python. */ POP            ((byte) '0'),\n    /** See Python. */ POP_MARK       ((byte) '1'),\n    /** See Python. */ DUP            ((byte) '2'),\n    /** See Python. */ FLOAT          ((byte) 'F'),\n    /** See Python. */ INT            ((byte) 'I'),\n    /** See Python. */ BININT         ((byte) 'J'),\n    /** See Python. */ BININT1        ((byte) 'K'),\n    /** See Python. */ LONG           ((byte) 'L'),\n    /** See Python. */ BININT2        ((byte) 'M'),\n    /** See Python. */ NONE           ((byte) 'N'),\n    /** See Python. */ PERSID         ((byte) 'P'),\n    /** See Python. */ BINPERSID      ((byte) 'Q'),\n    /** See Python. */ REDUCE         ((byte) 'R'),\n    /** See Python. */ STRING         ((byte) 'S'),\n    /** See Python. */ BINSTRING      ((byte) 'T'),\n    /** See Python. */ SHORT_BINSTRING((byte) 'U'),\n    /** See Python. */ UNICODE        ((byte) 'V'),\n    /** See Python. */ BINUNICODE     ((byte) 'X'),\n    /** See Python. */ APPEND         ((byte) 'a'),\n    /** See Python. */ BUILD          ((byte) 'b'),\n    /** See Python. */ GLOBAL         ((byte) 'c'),\n    /** See Python. */ DICT           ((byte) 'd'),\n    /** See Python. */ EMPTY_DICT     ((byte) '}'),\n    /** See Python. */ APPENDS        ((byte) 'e'),\n    /** See Python. */ GET            ((byte) 'g'),\n    /** See Python. */ BINGET         ((byte) 'h'),\n    /** See Python. */ INST           ((byte) 'i'),\n    /** See Python. */ LONG_BINGET    ((byte) 'j'),\n    /** See Python. */ LIST           ((byte) 'l'),\n    /** See Python. */ EMPTY_LIST     ((byte) ']'),\n    /** See Python. */ OBJ            ((byte) 'o'),\n    /** See Python. */ PUT            ((byte) 'p'),\n    /** See Python. */ BINPUT         ((byte) 'q'),\n    /** See Python. */ LONG_BINPUT    ((byte) 'r'),\n    /** See Python. */ SETITEM        ((byte) 's'),\n    /** See Python. */ TUPLE          ((byte) 't'),\n    /** See Python. */ EMPTY_TUPLE    ((byte) ')'),\n    /** See Python. */ SETITEMS       ((byte) 'u'),\n    /** See Python. */ BINFLOAT       ((byte) 'G'),\n\n    // Protocol 2\n    /** See Python. */ PROTO          ((byte) 0x80),\n    /** See Python. */ NEWOBJ         ((byte) 0x81),\n    /** See Python. */ EXT1           ((byte) 0x82),\n    /** See Python. */ EXT2           ((byte) 0x83),\n    /** See Python. */ EXT4           ((byte) 0x84),\n    /** See Python. */ TUPLE1         ((byte) 0x85),\n    /** See Python. */ TUPLE2         ((byte) 0x86),\n    /** See Python. */ TUPLE3         ((byte) 0x87),\n    /** See Python. */ NEWTRUE        ((byte) 0x88),\n    /** See Python. */ NEWFALSE       ((byte) 0x89),\n    /** See Python. */ LONG1          ((byte) 0x8a),\n    /** See Python. */ LONG4          ((byte) 0x8b);\n\n    private static final Operations[] BY_CODE = new Operations[256];\n    static {", "        for (Operations op : Operations.values()) {\n            Operations.BY_CODE[((int)op.code) & 0xff] = op;\n        }\n    }\n\n    /**\n     * The identifier code for the operation.\n     */\n    public final byte code;\n\n    /**\n     * Get the {@link Operations} value for the given byte.\\\n     *\n     * @param c  The operation's byte code.\n     *\n     * @return the enum value, or {@code null} if none was found.\n     */", "    public final byte code;\n\n    /**\n     * Get the {@link Operations} value for the given byte.\\\n     *\n     * @param c  The operation's byte code.\n     *\n     * @return the enum value, or {@code null} if none was found.\n     */\n    public static Operations valueOf(byte c)\n    {\n        return BY_CODE[((int)c) & 0xff];\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param c  The operation's byte code.\n     */\n    private Operations(final byte c)\n    {\n        code = c;\n    }\n}\n", "    public static Operations valueOf(byte c)\n    {\n        return BY_CODE[((int)c) & 0xff];\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param c  The operation's byte code.\n     */\n    private Operations(final byte c)\n    {\n        code = c;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/NumpyArray.java", "chunked_list": ["package com.deshaw.python;\n\nimport com.deshaw.python.DType.Type;\nimport com.deshaw.util.StringUtil;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n", "import java.nio.ByteOrder;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Simple {@code numpy} array implementation.\n *", " * Simple {@code numpy} array implementation.\n *\n * <p>Caveats: <ul>\n *   <li>Signedness of integers is ignored.\n *   <li>Arrays greater than 2GB are not supported.\n * </ul>\n */\npublic class NumpyArray\n{\n    /**\n     * Callback interface for {@link #visitElements(ElementVisitor)}.\n     */", "    public static interface ElementVisitor\n    {\n        /**\n         * Callback visiting an element of an array at index {@code ixs}.\n         *\n         * @param array  The array to visit.\n         * @param ixs    The index.\n         */\n        public void visit(final NumpyArray array, final int[] ixs);\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Array's dtype.\n     */\n    private DType myDType;\n\n    /**\n     * Type of an array element.\n     */\n    private Type myType;\n\n    /**\n     * Byte buffer wrapping the underlying data.\n     */\n    private ByteBuffer myByteBuffer;\n\n    /**\n     * Number of dimensions.\n     */\n    private int myNumDimensions;\n\n    /**\n     * Array shape.\n     */\n    private int[] myShape;\n\n    /**\n     * Array strides.\n     */\n    private int[] myStrides;\n\n    /**\n     * Whether array data is stored in Fortran order (by column).\n     */\n    private boolean myIsFortran;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Estimate the shape of a (possibly multidimensional) array\n     * and the ultimate component type.\n     *\n     * <p>The answer may be wrong if the array is ragged.\n     *\n     * @param array  The array to get the shape of.\n     *\n     * @return the numpy-style array shape.\n     */", "        public void visit(final NumpyArray array, final int[] ixs);\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Array's dtype.\n     */\n    private DType myDType;\n\n    /**\n     * Type of an array element.\n     */\n    private Type myType;\n\n    /**\n     * Byte buffer wrapping the underlying data.\n     */\n    private ByteBuffer myByteBuffer;\n\n    /**\n     * Number of dimensions.\n     */\n    private int myNumDimensions;\n\n    /**\n     * Array shape.\n     */\n    private int[] myShape;\n\n    /**\n     * Array strides.\n     */\n    private int[] myStrides;\n\n    /**\n     * Whether array data is stored in Fortran order (by column).\n     */\n    private boolean myIsFortran;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Estimate the shape of a (possibly multidimensional) array\n     * and the ultimate component type.\n     *\n     * <p>The answer may be wrong if the array is ragged.\n     *\n     * @param array  The array to get the shape of.\n     *\n     * @return the numpy-style array shape.\n     */", "    public static int[] getJavaArrayShape(final Object array)\n    {\n        List<Integer> shape = new ArrayList<>();\n        getArrayShapeAndType(array, shape);\n        int[] result = new int[shape.size()];\n        for (int i=0; i < shape.size(); i++) {\n            result[i] = shape.get(i);\n        }\n        return result;\n    }\n\n    /**\n     * Helper for extracting an int from what we know is a\n     * 1D {@code NumpyArray}.\n     *\n     * @param array  The array to get the value from.\n     * @param ix     The index of the element to get.\n     *\n     * @return the integer at that index.\n     */", "    public static int getInt(final Object array, final int ix)\n    {\n        return ((NumpyArray) array).getInt(ix);\n    }\n\n    /**\n     * Helper for extracting a long from what we know is a\n     * 1D {@code NumpyArray}.\n     *\n     * @param array  The array to get the value from.\n     * @param ix     The index of the element to get.\n     *\n     * @return the long at that index.\n     */", "    public static long getLong(final Object array, final int ix)\n    {\n        return ((NumpyArray) array).getLong(ix);\n    }\n\n    /**\n     * Helper for extracting a double from what we know is a\n     * 1D {@code NumpyArray}.\n     *\n     * @param array  The array to get the value from.\n     * @param ix     The index of the element to get.\n     *\n     * @return the double at that index.\n     */", "    public static double getDouble(Object array, int ix)\n    {\n        return ((NumpyArray) array).getDouble(ix);\n    }\n\n    /**\n     * Construct an array of zeros.\n     *\n     * @param dtype      The type of the resultant array.\n     * @param isFortran  Whether the array layout is Fortran or C style.\n     * @param shape      The shape of the array.\n     *\n     * @return the generated array.\n     */", "    public static NumpyArray zeros(final DType   dtype,\n                                   final boolean isFortran,\n                                   final int...  shape)\n    {\n        if (shape.length == 0) {\n            throw new IllegalArgumentException(\"0-d arrays are not supported\");\n        }\n\n        int size = dtype.size();\n        for (int dimLength: shape) {\n            size = Math.multiplyExact(size, dimLength);\n        }\n\n        ByteBuffer byteBuffer = ByteBuffer.allocate(size);\n        return new NumpyArray(dtype, isFortran, shape, byteBuffer);\n    }\n\n    /**\n     * Construct a numpy array around a multi-dimensional Java array.\n     *\n     * @param dtype        The type of the resultant array.\n     * @param isFortran    Whether the array layout is Fortran or C style.\n     * @param sourceArray  The Java array to copy from.\n     *\n     * @return the generated array.\n     */", "        for (int dimLength: shape) {\n            size = Math.multiplyExact(size, dimLength);\n        }\n\n        ByteBuffer byteBuffer = ByteBuffer.allocate(size);\n        return new NumpyArray(dtype, isFortran, shape, byteBuffer);\n    }\n\n    /**\n     * Construct a numpy array around a multi-dimensional Java array.\n     *\n     * @param dtype        The type of the resultant array.\n     * @param isFortran    Whether the array layout is Fortran or C style.\n     * @param sourceArray  The Java array to copy from.\n     *\n     * @return the generated array.\n     */", "    public static NumpyArray fromObject(final DType   dtype,\n                                        final boolean isFortran,\n                                        final Object  sourceArray)\n    {\n        final int[] shape = getJavaArrayShape(sourceArray);\n\n        // Allocate storage\n        final NumpyArray rv = zeros(dtype, isFortran, shape);\n\n        // Copy data\n        final int[] ixs = new int[shape.length];\n        internalCopyArrayData(sourceArray, rv, ixs, 0, 0);\n\n        return rv;\n    }\n\n    /**\n     * Estimate the shape of a (possibly multidimensional) array\n     * and the element type.\n     *\n     * <p>The answer may be wrong if the array is ragged.\n     *\n     * @param array     The array to interrogate.\n     * @param outShape  Where to put the shape.\n     *\n     * @return the element type.\n     */", "    public static Class<?> getArrayShapeAndType(final Object        array,\n                                                final List<Integer> outShape)\n    {\n        Objects.requireNonNull(array);\n        Objects.requireNonNull(outShape);\n\n        outShape.clear();\n\n        Object   slice    = array;\n        Class<?> sliceCls = slice.getClass();\n", "        if (!sliceCls.isArray()) {\n            throw new IllegalArgumentException(\"Not at array\");\n        }\n\n        // Repeatedly descend into the 0th element along each\n        // dimension.\n        int dim = 0;\n        Class<?> elementType = null;\n        while (sliceCls.getComponentType() != null) {\n            elementType = sliceCls.getComponentType();\n\n            int dimLength;", "        while (sliceCls.getComponentType() != null) {\n            elementType = sliceCls.getComponentType();\n\n            int dimLength;\n            if (slice != null) {\n                dimLength = Array.getLength(slice);\n            }\n            else {\n                dimLength = 0;\n            }\n\n            outShape.add(dimLength);\n", "            if (dimLength != 0) {\n                slice = Array.get(slice, 0);\n                if (slice == null) {\n                    throw new NullPointerException(\n                        \"null subarray in dimension \" + dim\n                    );\n                }\n                sliceCls = slice.getClass();\n            }\n            else {\n                // Once we encounter a dimension of length 0, we\n                // generally lose all information about the types\n                // and dimensions that follow. However, we may\n                // still learn the original number of dimensions\n                // and the component type if the array was declared\n                // using a multidimensional type from the start.\n                slice = null;\n                sliceCls = sliceCls.getComponentType();\n            }\n\n            dim++;\n        }\n\n        return elementType;\n    }\n\n    /**\n     * Whether the given DType is integer, or else floating point. If neither we\n     * throw an {@link UnsupportedOperationException}.\n     *\n     * @param dtype  The type to examine.\n     *\n     * @return whether the type is integer.\n     */\n    private static boolean integralType(final DType dtype)\n        throws UnsupportedOperationException\n    {", "        if (dtype == null) {\n            throw new UnsupportedOperationException(\"Can't cast to null DType\");\n        }\n\n        switch (dtype.type()) {\n        case BOOLEAN:\n        case INT8:\n        case INT16:\n        case INT32:\n        case INT64:\n            return true;\n\n        case FLOAT32:\n        case FLOAT64:\n            return false;\n\n        default:\n            throw new UnsupportedOperationException(\"Can't cast to \" + dtype);\n        }\n    }\n\n    /**\n     * Copy data from a Java source array to a numpy destination array.\n     *\n     * @param source       Where to copy from.\n     * @param destination  Where to copy to.\n     * @param ixs          The indices to work from.\n     * @param dimStart     The dimension we are working for.\n     * @param dstLinearIx  The index into the distination array.\n     *\n     * @return the generated array.\n     */\n    private static void internalCopyArrayData(final Object     source,\n                                              final NumpyArray destination,\n                                              final int[]      ixs,\n                                              final int        dimStart,\n                                              int              dstLinearIx)\n    {\n        final int size   = destination.shape (dimStart);\n        final int stride = destination.stride(dimStart);\n", "        if (source == null) {\n            throw new NullPointerException(\n                \"null subarray at index \" +\n                    Arrays.toString(Arrays.copyOf(ixs, dimStart + 1))\n            );\n        }\n        if (Array.getLength(source) != size) {\n            throw new IllegalArgumentException(\n                \"ragged array at index \" +\n                    Arrays.toString(Arrays.copyOf(ixs, dimStart + 1))\n            );\n        }\n", "        if (dimStart < destination.numDimensions() - 1) {\n            // Recursively copy the next dimension\n            for (int i = 0; i < size; i++) {\n                ixs[dimStart] = i;\n                internalCopyArrayData(\n                    Array.get(source, i),\n                    destination,\n                    ixs,\n                    dimStart + 1,\n                    dstLinearIx\n                );\n                dstLinearIx += stride;\n            }\n            return;\n        }\n\n        // Copy the last dimension directly\n        final boolean integralDestinationType = integralType(destination.dtype());\n        final Class<?> componentType = source.getClass().getComponentType();\n", "        if (componentType.isPrimitive()) {\n            if (integralDestinationType &&\n                componentType != Float.TYPE &&\n                componentType != Double.TYPE)\n            {\n                for (int i = 0; i < size; i++) {\n                    destination.set(dstLinearIx, Array.getLong(source, i));\n                    dstLinearIx += stride;\n                }\n            }\n            else {", "                for (int i = 0; i < size; i++) {\n                    destination.set(dstLinearIx, Array.getDouble(source, i));\n                    dstLinearIx += stride;\n                }\n            }\n        }\n        else {\n            for (int i = 0; i < size; i++) {\n                Object v = Array.get(source, i);\n\n                try {\n                    Number n = (Number) v;", "                try {\n                    Number n = (Number) v;\n                    if (integralDestinationType) {\n                        destination.set(dstLinearIx, n.longValue());\n                    }\n                    else {\n                        destination.set(dstLinearIx, n.doubleValue());\n                    }\n                }\n                catch (NullPointerException e) {\n                    ixs[dimStart] = i;\n                    throw new IllegalArgumentException(\n                        \"null element at index \" + Arrays.toString(ixs)\n                    );\n                }\n                catch (ClassCastException e) {\n                    ixs[dimStart] = i;\n                    throw new IllegalArgumentException(\n                        \"non-number element \" + v + \" \" +\n                            \"at index \" + Arrays.toString(ixs)\n                    );\n                }\n\n                dstLinearIx += stride;\n            }\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Only allow the pickle framework to create uninitialized instances. Handle\n     * this by making this CTOR protected. (Not perfect but...)\n     */\n    protected NumpyArray()\n    {\n        // Nothing\n    }\n\n    /**\n     * Instantiate a contiguous array and compute strides automatically.\n     *\n     * @param dtype      The type of the resultant array.\n     * @param isFortran  Whether the array layout is Fortran or C style.\n     * @param shape      The shape of the resultant arrau.\n     * @param data       The data to initialize the array with.\n     */\n    public NumpyArray(final DType      dtype,\n                      final boolean    isFortran,\n                      final int[]      shape,\n                      final ByteBuffer data)\n    {\n        initArray(dtype, isFortran, shape, null, data);\n    }\n\n    /**\n     * Instantiate an array with explicit strides.\n     *\n     * @param dtype      The type of the resultant array.\n     * @param isFortran  Whether the array layout is Fortran or C style.\n     * @param shape      The shape of the resultant arrau.\n     * @param strides    The numpy-style array strides.\n     * @param data       The data to initialize the array with.\n     */\n    public NumpyArray(final DType      dtype,\n                      final boolean    isFortran,\n                      final int[]      shape,\n                      final int[]      strides,\n                      final ByteBuffer data)\n    {\n        initArray(dtype, isFortran, shape, strides, data);\n    }\n\n    /**\n     * Total number of elements in the array.\n     *\n     * @return the array's size.\n     */", "    public int size()\n    {\n        int size = 1;\n        for (int i = 0; i < myNumDimensions; i++) {\n            size = Math.multiplyExact(size, myShape[i]);\n        }\n        return size;\n    }\n\n    /**\n     * Returns a view into the array, selecting a particular\n     * element along a dimension.\n     *\n     * @param dim  The dimension to select along.\n     * @param ix   The index of the element in that dimension.\n     *\n     * @return the resultant view.\n     */", "    public NumpyArray select(final int dim, final int ix)\n    {\n        if (numDimensions() < 2) {\n            throw new IllegalArgumentException(\n                \"select may not be used with arrays with fewer than 2 dimensions\"\n            );\n        }\n\n        NumpyArray collapsedDim = slice(dim, ix, ix + 1);\n        assert collapsedDim.shape(dim) == 1:\n               \"dim = \" + dim + \", \" +\n               \"original shape = \" + Arrays.toString(shape()) + \", \" +\n               \"shape after selecting = \" + Arrays.toString(collapsedDim.shape());\n\n        // Drop the dimension we selected into\n        int[] oldShape = collapsedDim.shape();\n        int[] newShape = new int[oldShape.length - 1];", "        for (int i=0, j=0; i < oldShape.length; i++) {\n            if (i != dim) {\n                newShape[j++] = oldShape[i];\n            }\n        }\n        int[] oldStrides = collapsedDim.strides();\n        int[] newStrides = new int[oldStrides.length - 1];\n        for (int i=0, j=0; i < oldStrides.length; i++) {\n            if (i != dim) {\n                newStrides[j++] = oldStrides[i];\n            }\n        }\n\n        return new NumpyArray(collapsedDim.dtype(),\n                              collapsedDim.isFortran(),\n                              newShape,\n                              newStrides,\n                              collapsedDim.myByteBuffer);\n    }\n\n    /**\n     * Returns a view into the array with one of the dimensions\n     * restricted to a range.\n     *\n     * @param dim   The dimension to select along.\n     * @param from  The inclusive starting index of the element in that\n     *              dimension.\n     * @param to    The non-inclusive ending index of the element in that\n     *              dimension.\n     *\n     * @return the resultant view.\n     */", "            if (i != dim) {\n                newStrides[j++] = oldStrides[i];\n            }\n        }\n\n        return new NumpyArray(collapsedDim.dtype(),\n                              collapsedDim.isFortran(),\n                              newShape,\n                              newStrides,\n                              collapsedDim.myByteBuffer);\n    }\n\n    /**\n     * Returns a view into the array with one of the dimensions\n     * restricted to a range.\n     *\n     * @param dim   The dimension to select along.\n     * @param from  The inclusive starting index of the element in that\n     *              dimension.\n     * @param to    The non-inclusive ending index of the element in that\n     *              dimension.\n     *\n     * @return the resultant view.\n     */", "    public NumpyArray slice(int dim, int from, int to)\n    {\n        if (dim < 0 || dim >= myNumDimensions) {\n            throw new IllegalArgumentException(\n                \"Dimension must be between 0 and \" + (myNumDimensions - 1) + \", \" +\n                    \"got \" + dim\n            );\n        }\n\n        // Fancy indexing mechanisms of numpy are not supported\n        int dimSize = myShape[dim];", "        if (from < 0 || from >= dimSize || to < from || to > dimSize) {\n            throw new IllegalArgumentException(\n                \"Invalid slice range [\" + from + \", \" + to + \")\"\n            );\n        }\n\n        // Update the shape. Slicing does not affect strides, so we\n        // do not need to do anything about them.\n        int[] newShape = myShape.clone();\n        newShape[dim] = to - from;\n\n        // Offset the starting point of the data\n        ByteBuffer view = myByteBuffer.duplicate();\n        view.position(view.position() + from * myStrides[dim]);\n\n        // Create a sliced view of the array\n        return new NumpyArray(myDType, myIsFortran, newShape, myStrides, view);\n    }\n\n    /**\n     * Return data at a given linear index as an int. Will silently\n     * truncate types that don't fit in an int (matches numpy behaviour).\n     *\n     * @param linearIx  The index to get from.\n     *\n     * @return the value at the given index.\n     */", "    public int _int(int linearIx)\n    {\n        switch (myType) {\n            case INT8:    return      myByteBuffer.get      (linearIx);\n            case INT16:   return      myByteBuffer.getShort (linearIx);\n            case INT32:   return      myByteBuffer.getInt   (linearIx);\n            case INT64:   return (int)myByteBuffer.getLong  (linearIx);\n            case FLOAT32: return (int)myByteBuffer.getFloat (linearIx);\n            case FLOAT64: return (int)myByteBuffer.getDouble(linearIx);\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Set int data at a given linear index. Will silently truncate\n     * types that don't fit in a destination (matches numpy behaviour).\n     *\n     * @param linearIx  The index to set at.\n     * @param v         The value to set with.\n     */", "    public void set(int linearIx, int v)\n    {\n        switch (myType) {\n            case INT8:    myByteBuffer.put      (linearIx, (byte)  v); break;\n            case INT16:   myByteBuffer.putShort (linearIx, (short) v); break;\n            case INT32:   myByteBuffer.putInt   (linearIx,         v); break;\n            case INT64:   myByteBuffer.putLong  (linearIx,         v); break;\n            case FLOAT32: myByteBuffer.putFloat (linearIx,         v); break;\n            case FLOAT64: myByteBuffer.putDouble(linearIx,         v); break;\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Return data at a given linear index as a long. Will silently\n     * truncate types that don't fit in a long (matches numpy behaviour).\n     *\n     * @param linearIx  The index to get from.\n     *\n     * @return the value at the given index.\n     */", "    public long _long(int linearIx)\n    {\n        switch (myType) {\n            case INT8:    return       myByteBuffer.get      (linearIx);\n            case INT16:   return       myByteBuffer.getShort (linearIx);\n            case INT32:   return       myByteBuffer.getInt   (linearIx);\n            case INT64:   return       myByteBuffer.getLong  (linearIx);\n            case FLOAT32: return (long)myByteBuffer.getFloat (linearIx);\n            case FLOAT64: return (long)myByteBuffer.getDouble(linearIx);\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Return data at a given linear index as a long. Will silently\n     * truncate types that don't fit in a long (matches numpy behaviour).\n     *\n     * @param linearIx  The index to set at.\n     * @param v         The value to set with.\n     */", "    public void set(int linearIx, long v)\n    {\n        switch (myType) {\n            case INT8:    myByteBuffer.put      (linearIx, (byte)  v); break;\n            case INT16:   myByteBuffer.putShort (linearIx, (short) v); break;\n            case INT32:   myByteBuffer.putInt   (linearIx, (int)   v); break;\n            case INT64:   myByteBuffer.putLong  (linearIx,         v); break;\n            case FLOAT32: myByteBuffer.putFloat (linearIx,         v); break;\n            case FLOAT64: myByteBuffer.putDouble(linearIx,         v); break;\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Return data at a given linear index as a double.\n     *\n     * @param linearIx  The index to get from.\n     *\n     * @return the value at the given index.\n     */", "    public double _double(int linearIx)\n    {\n        switch (myType) {\n            case INT8:    return myByteBuffer.get      (linearIx);\n            case INT16:   return myByteBuffer.getShort (linearIx);\n            case INT32:   return myByteBuffer.getInt   (linearIx);\n            case INT64:   return myByteBuffer.getLong  (linearIx);\n            case FLOAT32: return myByteBuffer.getFloat (linearIx);\n            case FLOAT64: return myByteBuffer.getDouble(linearIx);\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Return data at a given linear index as a double.\n     *\n     * @param linearIx  The index to set at.\n     * @param v         The value to set with.\n     */", "    public void set(int linearIx, double v)\n    {\n        switch (myType) {\n            case INT8:    myByteBuffer.put      (linearIx, (byte)  v); break;\n            case INT16:   myByteBuffer.putShort (linearIx, (short) v); break;\n            case INT32:   myByteBuffer.putInt   (linearIx, (int)   v); break;\n            case INT64:   myByteBuffer.putLong  (linearIx, (long)  v); break;\n            case FLOAT32: myByteBuffer.putFloat (linearIx, (float) v); break;\n            case FLOAT64: myByteBuffer.putDouble(linearIx,         v); break;\n            default:\n                throw new UnsupportedOperationException(\n                    \"Unrecognized type \" + myType + \" of dtype \" + myDType\n                );\n        }\n    }\n\n    /**\n     * Length of a particular dimension.\n     *\n     * @param dim  The dimension to query.\n     *\n     * @return the shape/length in that dimension.\n     */", "    public int shape(int dim)\n    {\n        return myShape[dim];\n    }\n\n    /**\n     * Stride of a particular dimension.\n     *\n     * @param dim  The dimension to query.\n     *\n     * @return the stride in that dimension.\n     */", "    public int stride(int dim)\n    {\n        return myStrides[dim];\n    }\n\n    /**\n     * Convert index along the first axis into a linear index.\n     *\n     * @param x1  The index along the first axis.\n     *\n     * @return the linear index.\n     */", "    public int ix(int x1)\n    {\n        return myStrides[0] * x1;\n    }\n\n    /**\n     * Convert indices along the first two axes into a linear index.\n     *\n     * @param x1  The index along the first axis.\n     * @param x2  The index along the second axis.\n     *\n     * @return the linear index.\n     */", "    public int ix(int x1, int x2)\n    {\n        return myStrides[0] * x1 +\n               myStrides[1] * x2;\n    }\n\n    /**\n     * Convert indices along the first three axes into a linear index.\n     *\n     * @param x1  The index along the first axis.\n     * @param x2  The index along the second axis.\n     * @param x3  The index along the third axis.\n     *\n     * @return the linear index.\n     */", "    public int ix(int x1, int x2, int x3)\n    {\n        return myStrides[0] * x1 +\n               myStrides[1] * x2 +\n               myStrides[2] * x3;\n    }\n\n    /**\n     * Convert an arbitrary-dimensional index into a linear index.\n     * Any unspecified trailing indices are presumed to be 0.\n     *\n     * @param x  The indices.\n     *\n     * @return the linear index.\n     */\n    @SuppressWarnings({ \"OverloadedVarargsMethod\" })", "    public int ix(int... x)\n    {\n        int ix = 0;\n        for (int i = 0, l = x.length; i < l; i++) {\n            ix += x[i] * myStrides[i];\n        }\n        return ix;\n    }\n\n    /**\n     * Visit every element of the array.\n     *\n     * @param visitor  The visitor to use.\n     */", "    public void visitElements(ElementVisitor visitor)\n    {\n        int[] ixs = new int[numDimensions()];\n        internalVisitElements(visitor, ixs, 0);\n    }\n\n    /**\n     * Recursive helper used to implement {@link #visitElements(ElementVisitor)}.\n     *\n     * @param visitor  The visitor to use.\n     * @param ixs      The indices to visit along.\n     * @param dim      The dimension which we are visiting.\n     */\n    private void internalVisitElements(ElementVisitor visitor, int[] ixs, int dim)\n    {\n        boolean lastDimension = dim == numDimensions() - 1;", "        for (int i = 0, size = shape(dim); i < size; i++) {\n            ixs[dim] = i;\n            if (lastDimension) {\n                visitor.visit(this, ixs);\n            }\n            else {\n                internalVisitElements(visitor, ixs, dim + 1);\n            }\n        }\n    }\n\n    /**\n     * Roll an axis from one position to another. Returns a view into the array.\n     *\n     * <p>This method behaves like {@code moveaxis} method from numpy 1.11.\n     *\n     * @param from  Old index of an axis.\n     * @param to    New index of an axis.\n     *\n     * @return a rolled view of this array.\n     */", "    public NumpyArray rollAxis(int from, int to)\n    {\n        final int ndim = numDimensions();\n\n        // Figure out how the axes are going to move\n        final int[] srcIxs = new int[ndim];\n        for (int i=0, j=0; i < ndim; i++) {\n            if (i != from) {\n                srcIxs[j++] = i;\n            }\n            if (i == to) {\n                srcIxs[j++] = from;\n            }\n        }\n\n        final int[] newShape   = new int[ndim];\n        final int[] newStrides = new int[ndim];", "            if (i == to) {\n                srcIxs[j++] = from;\n            }\n        }\n\n        final int[] newShape   = new int[ndim];\n        final int[] newStrides = new int[ndim];\n        for (int i = 0; i < ndim; i++) {\n            newShape  [i] = myShape  [srcIxs[i]];\n            newStrides[i] = myStrides[srcIxs[i]];\n        }\n\n        return new NumpyArray(dtype(),\n                              myIsFortran,\n                              newShape,\n                              newStrides,\n                              myByteBuffer);\n    }\n\n    /**\n     * Make a copy of the array. The copy will be allocated on the heap.\n     *\n     * @return the copy.\n     */", "    public NumpyArray copy()\n    {\n        return asType(myDType, true, myIsFortran, false);\n    }\n\n    /**\n     * Return the array with the same contents as this array, cast to a specific\n     * type.\n     *\n     * @param dtype           The new dtype for the array.\n     * @param copy            When {@code false}, do not make a copy if the\n     *                        array is already of the correct type; otherwise,\n     *                        always make a copy.\n     * @param isFortran       Whether the resultant array should be Fortran style.\n     * @param allocateDirect  Whether the new array should be backed by a\n     *                        \"direct\" buffer.\n     *\n     * @throws UnsupportedOperationException if it can't be cast to the given type.\n     *\n     * @return the copy.\n     */", "    public NumpyArray asType(final DType   dtype,\n                             final boolean copy,\n                             final boolean isFortran,\n                             final boolean allocateDirect)\n        throws UnsupportedOperationException\n    {\n        if (!copy) {\n            // Verify compatibility\n            if (dtype.equals(myDType)         &&\n                isFortran      == myIsFortran &&\n                allocateDirect == myByteBuffer.isDirect())\n            {\n                return this;\n            }\n        }\n\n        // Allocate new storage\n        final int newSizeBytes = Math.multiplyExact(size(), dtype.size());\n        final NumpyArray dst =\n            new NumpyArray(\n                dtype,\n                isFortran,\n                shape(),\n                allocateDirect ? ByteBuffer.allocateDirect(newSizeBytes)\n                               : ByteBuffer.allocate      (newSizeBytes)\n            );\n\n        final boolean integralDestinationType = integralType(dtype);\n\n        visitElements(\n            (src, ixs) -> {\n                final int srcIx = src.ix(ixs);\n                final int dstIx = dst.ix(ixs);", "            if (dtype.equals(myDType)         &&\n                isFortran      == myIsFortran &&\n                allocateDirect == myByteBuffer.isDirect())\n            {\n                return this;\n            }\n        }\n\n        // Allocate new storage\n        final int newSizeBytes = Math.multiplyExact(size(), dtype.size());\n        final NumpyArray dst =\n            new NumpyArray(\n                dtype,\n                isFortran,\n                shape(),\n                allocateDirect ? ByteBuffer.allocateDirect(newSizeBytes)\n                               : ByteBuffer.allocate      (newSizeBytes)\n            );\n\n        final boolean integralDestinationType = integralType(dtype);\n\n        visitElements(\n            (src, ixs) -> {\n                final int srcIx = src.ix(ixs);\n                final int dstIx = dst.ix(ixs);", "                if (integralDestinationType) {\n                    dst.set(dstIx, _long(srcIx));\n                }\n                else {\n                    dst.set(dstIx, _double(srcIx));\n                }\n            }\n        );\n        return dst;\n    }\n\n    /**\n     * Return the underlying byte buffer. Use with care.\n     *\n     * @return the buffer backing this array.\n     */", "    public ByteBuffer getByteBuffer()\n    {\n        return myByteBuffer;\n    }\n\n    /**\n     * Array dtype.\n     *\n     * @return the dtype of this array.\n     */\n    public DType dtype()\n    {\n        return myDType;\n    }\n\n    /**\n     * Number of array dimensions (same as {@code shape().length}).\n     *\n     * @return the dimensionality of this array.\n     */", "    public DType dtype()\n    {\n        return myDType;\n    }\n\n    /**\n     * Number of array dimensions (same as {@code shape().length}).\n     *\n     * @return the dimensionality of this array.\n     */\n    public int numDimensions()\n    {\n        return myNumDimensions;\n    }\n\n    /**\n     * Array shape.\n     *\n     * @return the shape of this array.\n     */\n    public int[] shape()\n    {\n        return myShape;\n    }\n\n    /**\n     * Array strides. Use with care.\n     *\n     * @return the array containing the strides of this array.\n     */\n    public int[] strides()\n    {\n        return myStrides;\n    }\n\n    /**\n     * Whether array data is stored in Fortran order (by column).\n     *\n     * @return whether the array is Fortran ordering.\n     */", "    public int numDimensions()\n    {\n        return myNumDimensions;\n    }\n\n    /**\n     * Array shape.\n     *\n     * @return the shape of this array.\n     */\n    public int[] shape()\n    {\n        return myShape;\n    }\n\n    /**\n     * Array strides. Use with care.\n     *\n     * @return the array containing the strides of this array.\n     */\n    public int[] strides()\n    {\n        return myStrides;\n    }\n\n    /**\n     * Whether array data is stored in Fortran order (by column).\n     *\n     * @return whether the array is Fortran ordering.\n     */", "    public boolean isFortran()\n    {\n        return myIsFortran;\n    }\n\n    /**\n     * Helper for accessing an int at a given index in a 1D array.\n     *\n     * @param ix  The index to look up at.\n     *\n     * @return the value at the given index.\n     */", "    public int getInt(int ix)\n    {\n        return _int(ix(ix));\n    }\n\n    /**\n     * Helper for accessing a long at a given index in a 1D array.\n     *\n     * @param ix  The index to look up at.\n     *\n     * @return the value at the given index.\n     */", "    public long getLong(int ix)\n    {\n        return _long(ix(ix));\n    }\n\n    /**\n     * Helper for accessing a double at a given index in a 1D array.\n     *\n     * @param ix  The index to look up at.\n     *\n     * @return the value at the given index.\n     */", "    public double getDouble(int ix)\n    {\n        return _double(ix(ix));\n    }\n\n    /**\n     * Validate array's dimensions.\n     *\n     * @param name           The name of the array, for error messages.\n     * @param expectedShape  Expected shape of the array. Axes where\n     *                       the shape dimensions are -1 are excluded\n     *                       from checking, though the number of\n     *                       dimensions must still match exactly.\n     */", "    public void validateShape(String name, int... expectedShape)\n    {\n        if (numDimensions() != expectedShape.length) {\n            throw new IllegalArgumentException(\n                \"'\" + name + \"' must have exactly \" + expectedShape.length + \" \" +\n                \"dimension\" + (expectedShape.length == 1 ? \"\" : \"s\") + \"; \" +\n                \"received \" + this\n            );\n        }\n\n        int[] shape = shape();", "        for (int i = 0; i < expectedShape.length; i++) {\n            // Allow entries in expectedShape to be -1 to represent\n            // placeholders.\n            if (expectedShape[i] == -1) {\n                continue;\n            }\n\n            // Everything else must match perfectly\n            if (shape[i] != expectedShape[i]) {\n                throw new IllegalArgumentException(\n                    \"'\" + name + \"' shape must be \" +\n                    Arrays.toString(expectedShape) + \"; \" +\n                    \"received \" + this\n                );\n            }\n        }\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of doubles.\n     *\n     * @return The multi-dimensional array.\n     */", "            if (shape[i] != expectedShape[i]) {\n                throw new IllegalArgumentException(\n                    \"'\" + name + \"' shape must be \" +\n                    Arrays.toString(expectedShape) + \"; \" +\n                    \"received \" + this\n                );\n            }\n        }\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of doubles.\n     *\n     * @return The multi-dimensional array.\n     */", "    public Object toDoubleArray()\n    {\n        int[] shape = shape();\n        Object rv = Array.newInstance(Double.TYPE, shape);\n        if (shape.length == 1) {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, getDouble(i));\n            }\n        }\n        else {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toDoubleArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of ints.\n     *\n     * @return The multi-dimensional array.\n     */", "            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toDoubleArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of ints.\n     *\n     * @return The multi-dimensional array.\n     */", "    public Object toIntArray()\n    {\n        int[] shape = shape();\n        Object rv = Array.newInstance(Integer.TYPE, shape);\n        if (shape.length == 1) {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, getInt(i));\n            }\n        }\n        else {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toIntArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of longs.\n     *\n     * @return The multi-dimensional array.\n     */", "            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toIntArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * Convert a {@code NumpyArray} to the corresponding, possibly\n     * multi-dimensional, array of longs.\n     *\n     * @return The multi-dimensional array.\n     */", "    public Object toLongArray()\n    {\n        int[] shape = shape();\n        Object rv = Array.newInstance(Long.TYPE, shape);\n        if (shape.length == 1) {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, getLong(i));\n            }\n        }\n        else {\n            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toLongArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "            for (int i = 0, size = shape[0]; i < size; i++) {\n                Array.set(rv, i, select(0, i).toLongArray());\n            }\n        }\n        return rv;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        return \"<\" +\n            numDimensions() + \"-d \" +\n            dtype() + \" array: \" +\n            Arrays.toString(shape()) +\n        \">\";\n    }\n\n    /**\n     * Initialize array structures. This method builds the array around\n     * the passed-in data without making a copy.\n     *\n     * @param dtype       The type of the resultant array.\n     * @param isFortran   Whether the array layout is Fortran or C style.\n     * @param shapeArray  The shape of the resultant arrau.\n     * @param strides     The numpy-style array strides.\n     * @param data        The data to initialize the array with.\n     */\n    protected void initArray(final DType      dtype,\n                             final boolean    isFortran,\n                             final int[]      shapeArray,\n                             final int[]      strides,\n                             final ByteBuffer data)\n    {\n        myDType = dtype;\n        myIsFortran = isFortran;\n\n        myShape = shapeArray.clone();\n        myNumDimensions = myShape.length;\n\n        myType = myDType.type();\n\n        // Setup strides", "        if (strides == null) {\n            int currStride = myDType.size();\n            myStrides = new int[myNumDimensions];\n            for (int i = 0; i < myNumDimensions; i++) {\n                int dim = myIsFortran ? i : myNumDimensions - i - 1;\n                myStrides[dim] = currStride;\n                currStride = Math.multiplyExact(currStride, myShape[dim]);\n            }\n        }\n        else {\n            if (strides.length != myNumDimensions) {\n                throw new IllegalArgumentException(\n                    \"strides array must have the same length as the shape array\"\n                );\n            }\n            myStrides = strides.clone();\n        }\n\n        myByteBuffer = data.slice();\n        myByteBuffer.order(myDType.bigEndian() ? ByteOrder.BIG_ENDIAN\n                                               : ByteOrder.LITTLE_ENDIAN);\n    }\n}\n", "            if (strides.length != myNumDimensions) {\n                throw new IllegalArgumentException(\n                    \"strides array must have the same length as the shape array\"\n                );\n            }\n            myStrides = strides.clone();\n        }\n\n        myByteBuffer = data.slice();\n        myByteBuffer.order(myDType.bigEndian() ? ByteOrder.BIG_ENDIAN\n                                               : ByteOrder.LITTLE_ENDIAN);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/PythonUnpickle.java", "chunked_list": ["package com.deshaw.python;\n\nimport com.deshaw.util.StringUtil;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;", "import java.io.IOException;\nimport java.io.InputStream;\n\nimport java.math.BigInteger;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;", "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Unpickler for Python binary pickle files.", "/**\n * Unpickler for Python binary pickle files.\n *\n * <p>This unpickler will probably require more work to handle general pickle\n * files. In particular, only operations necessary for decoding tuples, lists,\n * dictionaries, and numeric numpy arrays encoded using protocol version 2 are\n * supported.\n *\n * <p>Things that won't work:\n * <ul>", " * <p>Things that won't work:\n * <ul>\n *   <li>Some protocol 0 opcodes.\n *   <li>Numpy arrays of types other than {@code int1}, ..., {@code int64},\n *       {@code float32}, and {@code float64}. That includes string arrays,\n *       recarrays, etc.\n *   <li>Generic Python objects. You can, however, use\n *       {@link #registerGlobal(String, String, Global)} to add support for\n *       specific types, which is how dtypes and numpy arrays are implemented.\n * </ul>", " *       specific types, which is how dtypes and numpy arrays are implemented.\n * </ul>\n *\n * <p>Signedness of numpy integers is ignored.\n */\npublic class PythonUnpickle\n{\n    /**\n     * {@link ArrayList} with a bulk removal operation made public.\n     */\n    private static class ShrinkableList<T>\n        extends ArrayList<T>\n    {\n        /**\n         * Constructs an empty list.\n         */\n        public ShrinkableList()\n        {\n            super();\n        }\n\n        /**\n         * Constructs an empty list with a specified initial capacity.\n         */\n        public ShrinkableList(int initialCapacity)\n        {\n            super(initialCapacity);\n        }\n\n        /**\n         * Constructs a list containing the elements of the specified\n         * collection, in the order they are returned by the collection's\n         * iterator.\n         */\n        public ShrinkableList(Collection<? extends T> c)\n        {\n            super(c);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void removeRange(int fromIndex, int toIndex)\n        {\n            super.removeRange(fromIndex, toIndex);\n        }\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * Instance of an object that may be initialized by the\n     * {@code BUILD} opcode.\n     */\n    private static interface Instance\n    {\n        /**\n         * Python's {@code __setstate__} method. Typically, the\n         * {@code state} parameter will contain a tuple (unmodifiable\n         * list) with object-specific contents.\n         */", "        public void setState(Object state)\n            throws MalformedPickleException;\n    }\n\n    /**\n     * Callable global object recognized by the pickle framework.\n     */\n    private static interface Global\n    {\n        public Object call(Object c)\n            throws MalformedPickleException;\n    }\n\n    /**\n     * Factory class for use by the pickle framework to reconstruct\n     * proper numpy arrays.\n     */\n    private static class NumpyCoreMultiarrayReconstruct\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(Object c)\n            throws MalformedPickleException;\n    }\n\n    /**\n     * Factory class for use by the pickle framework to reconstruct\n     * proper numpy arrays.\n     */\n    private static class NumpyCoreMultiarrayReconstruct\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(final Object c)\n            throws MalformedPickleException\n        {\n            // args is a 3-tuple of arguments to pass to this constructor\n            // function (type(self), (0,), self.dtypechar).\n            return new UnpickleableNumpyArray();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"numpy.core.multiarray._reconstruct()\";\n        }\n    }\n\n    /**\n     * Factory class for use by the pickle framework to reconstruct\n     * numpy arrays from 'strings'.\n     */\n    private static class NumpyFromstring\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(final Object c)\n            throws MalformedPickleException\n        {\n            // Args are a tuple of (data, dtype)\n            try {\n                return new NumpyFromstringArray((List)c);\n            }\n            catch (ClassCastException e) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to numpy.core.multiarray scalar: \" +\n                        \"expecting 2-tuple (dtype, data), got \" + c\n                );\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"numpy.fromstring()\";\n        }\n    }\n\n    /**\n     * Factory class for use by the pickle framework to reconstruct\n     * numpy scalar arrays. Python treats these as scalars so we match\n     * these semantics in Java.\n     */\n    private static class NumpyCoreMultiarrayScalar\n        implements Global\n    {\n        /**\n         * Shape to pass to {@code NumpyArray} constructor.\n         */\n        private static final int[] SCALAR_ARRAY_SHAPE = { 1 };\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(final Object c)\n            throws MalformedPickleException\n        {\n            // Parse and return a scalar\n            final List tuple = (List) c;\n            if (tuple.size() != 2) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to numpy.core.multiarray scalar: \" +\n                        \"expecting 2-tuple (dtype, data), got \" + c\n                );\n            }\n\n            // Use NumpyArray to do the actual parsing\n            final DType dtype = (DType) tuple.get(0);\n            final BinString rawData = (BinString) tuple.get(1);\n            final NumpyArray dummyArray =\n                new NumpyArray(dtype, false, SCALAR_ARRAY_SHAPE, rawData.data());\n\n            // Always reconstruct scalars as either longs or doubles\n            switch (dtype.type()) {\n            case BOOLEAN:\n            case INT8:\n            case INT16:\n            case INT32:\n            case INT64:\n                return dummyArray.getLong(0);\n\n            case FLOAT32:\n            case FLOAT64:\n                return dummyArray.getDouble(0);\n\n            default:\n                throw new MalformedPickleException(\"Can't handle \" + dtype);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"numpy.core.multiarray.scalar()\";\n        }\n    }\n\n    /**\n     * Type marker.\n     */\n    private static class NDArrayType\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(final Object c)\n            throws MalformedPickleException\n        {\n            throw new UnsupportedOperationException(\"NDArrayType is not callable\");\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return \"numpy.core.multiarray.ndarray\";\n        }\n    }\n\n    /**\n     * Factory to register with the pickle framework.\n     */\n    private static class DTypeFactory\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"numpy.core.multiarray.ndarray\";\n        }\n    }\n\n    /**\n     * Factory to register with the pickle framework.\n     */\n    private static class DTypeFactory\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(Object c)\n            throws MalformedPickleException\n        {\n            if (!(c instanceof List)) {\n                throw new MalformedPickleException(\n                    \"Argument was not a List: \" + c\n                );\n            }\n\n            final List t = (List) c;\n            final String dtype = String.valueOf(t.get(0));\n            return new UnpickleableDType(dtype);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"numpy.dtype\";\n        }\n    }\n\n    /**\n     * Factory to register with the pickle framework.\n     */\n    private static class Encoder\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(Object c)\n            throws MalformedPickleException\n        {\n            if (!(c instanceof List)) {\n                throw new MalformedPickleException(\n                    \"Argument was not a List: \" +\n                    (c != null ?\n                        \"type = \" + c.getClass().getName() + \", value = \" :\n                        \"\") +\n                    c\n                );\n            }\n\n            final List t = (List) c;", "            if (t.size() != 2) {\n                throw new MalformedPickleException(\n                    \"Expected 2 arguments to encode, but got \" +\n                    t.size() + \": \" + t\n                );\n            }\n\n            final String encodingName = String.valueOf(t.get(1));\n            if (!encodingName.equals(\"latin1\")) {\n                throw new MalformedPickleException(\n                    \"Unsupported encoding.  Expected 'latin1', but got '\" +\n                    encodingName + \"'\"\n                );\n            }\n\n            // We're being handed a string where each character corresponds to\n            // one byte and the value of the byte is the code point of the\n            // character. The code point at each location was the value of the\n            // byte in the raw data, so we know it can fit in a byte and we\n            // assert this to be true.\n            final String s = String.valueOf(t.get(0));\n            final byte[] bytes = new byte[s.length()];", "            if (!encodingName.equals(\"latin1\")) {\n                throw new MalformedPickleException(\n                    \"Unsupported encoding.  Expected 'latin1', but got '\" +\n                    encodingName + \"'\"\n                );\n            }\n\n            // We're being handed a string where each character corresponds to\n            // one byte and the value of the byte is the code point of the\n            // character. The code point at each location was the value of the\n            // byte in the raw data, so we know it can fit in a byte and we\n            // assert this to be true.\n            final String s = String.valueOf(t.get(0));\n            final byte[] bytes = new byte[s.length()];", "            for (int i = 0; i < s.length(); i++) {\n                int codePoint = s.codePointAt(i);\n                if (codePoint < 0 || codePoint >= 256) {\n                    throw new MalformedPickleException(\n                        \"Invalid byte data passed to \" +\n                        \"_codecs.encode: \" + codePoint +\n                        \" is outside range [0,255].\"\n                    );\n                }\n                bytes[i] = (byte) codePoint;\n            }\n\n            return new BinString(ByteBuffer.wrap(bytes));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"_codecs.encode\";\n        }\n    }\n\n    /**\n     * Factory to register with the pickle framework.\n     */\n    private static class BytesPlaceholder\n        implements Global\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Object call(Object c)\n            throws MalformedPickleException\n        {\n            if (!(c instanceof List)) {\n                throw new MalformedPickleException(\n                    \"Argument was not a List: \" +\n                    (c != null ?\n                        \"type = \" + c.getClass().getName() + \", value = \" :\n                        \"\") +\n                    c\n                );\n            }\n\n            List t = (List) c;", "            if (t.size() != 0) {\n                throw new MalformedPickleException(\n                    \"Expected 0 arguments to bytes, but got \" +\n                    t.size() + \": \" + t\n                );\n            }\n\n            // Return a zero-byte BinString corresponding to this\n            // empty indicator of bytes.\n            return new BinString(ByteBuffer.allocate(0));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            return \"__builtin__.bytes\";\n        }\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * A version of the NumpyArray for unpickling.\n     */\n    private static class UnpickleableNumpyArray\n        extends NumpyArray\n        implements Instance\n    {\n        /**\n         * Constructor\n         */\n        public UnpickleableNumpyArray()\n        {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void setState(Object args)\n            throws MalformedPickleException\n        {\n            List tuple = (List) args;\n            if (tuple.size() == 5) {\n                int version = ((Number) tuple.get(0)).intValue();\n                if (version < 0 || version > 1) {\n                    throw new MalformedPickleException(\n                        \"Unsupported numpy array pickle version \" + version\n                    );\n                }\n                tuple = tuple.subList(1, tuple.size());\n            }\n", "            if (tuple.size() != 4) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to ndarray.__setstate__: \" +\n                    \"expecting 4-tuple (shape, dtype, isFortran, data), got \" +\n                    render(tuple)\n                );\n            }\n\n            try {\n                // Tuple arguments\n                final List shape = (List) tuple.get(0);\n                final int[] shapeArray = new int[shape.size()];", "            try {\n                // Tuple arguments\n                final List shape = (List) tuple.get(0);\n                final int[] shapeArray = new int[shape.size()];\n                for (int i = 0; i < shape.size(); i++) {\n                    long size = ((Number) shape.get(i)).longValue();\n                    if (size < 0 || size > Integer.MAX_VALUE) {\n                        throw new MalformedPickleException(\n                            \"Bad array size, \" + size + \", in \" + render(tuple)\n                        );\n                    }\n                    shapeArray[i] = (int)size;\n                }\n\n                final DType dtype = (DType) tuple.get(1);\n\n                final boolean isFortran =\n                    (tuple.get(2) instanceof Number)\n                        ? (((Number)tuple.get(2)).intValue() != 0)\n                        : (Boolean) tuple.get(2);\n\n                final ByteBuffer data;", "                if (tuple.get(3) instanceof BinString) {\n                    data = ((BinString) tuple.get(3)).data();\n                }\n                else {\n                    data = ByteBuffer.wrap(((String)tuple.get(3)).getBytes());\n                }\n\n                initArray(dtype, isFortran, shapeArray, null, data);\n            }\n            catch (ClassCastException e) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to ndarray.__setstate__: \" +\n                    \"expecting (shape, dtype, isFortran, data), got \" +\n                    render(tuple),\n                    e\n                );\n            }\n            catch (NullPointerException e) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to ndarray.__setstate__: \" +\n                    \"nulls not allowed in (shape, dtype, isFortran, data), got \" +\n                    render(tuple),\n                    e\n                );\n            }\n        }\n    }\n\n    /**\n     * Unpickle a basic numpy array with the fromstring method.\n     */\n    private static class NumpyFromstringArray\n        extends NumpyArray\n    {\n        /**\n         * Constructor\n         */\n        public NumpyFromstringArray(List tuple)\n            throws MalformedPickleException\n        {", "            if (tuple.size() != 2) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to numpy.fromstring: \" +\n                    \"expecting 2-tuple (data, dtype), got \" + tuple\n                );\n            }\n\n            try {\n                // Tuple arguments\n                final DType     dtype   = new DType((BinString)tuple.get(1));\n                final BinString rawData = (BinString) tuple.get(0);\n                final int[]     shape   = { rawData.length() / dtype.size() };\n                initArray(dtype, false, shape, null, rawData.data());\n            }\n            catch (ClassCastException e) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to numpy.fromstring: \" +\n                    \"expecting (data, dtype), got \" + tuple,\n                    e\n                );\n            }\n            catch (NullPointerException e) {\n                throw new MalformedPickleException(\n                    \"Invalid arguments passed to numpy.fromstring: \" +\n                    \"nulls not allowed in (data, dtype), got \" + tuple\n                );\n            }\n        }\n    }\n\n    /**\n     * A version of the DType which supports unpickling.\n     */\n    private static class UnpickleableDType\n        extends    DType\n        implements Instance\n    {\n        /**\n         * Constructor.\n         */\n        public UnpickleableDType(String dtype)\n            throws IllegalArgumentException\n        {\n            super(dtype);\n        }\n\n        /**\n         * Unpickling support.\n         */\n        @Override", "        public void setState(Object state)\n        {\n            // The __reduce__() method returns a 3-tuple consisting of (callable object,\n            // args, state), where the callable object is numpy.core.multiarray.dtype and\n            // args is (typestring, 0, 1) unless the data-type inherits from void (or\n            // is user-defined) in which case args is (typeobj, 0, 1).\n            // The state is an 8-tuple with (version, endian, self.subdtype, self.names,\n            // self.fields, self.itemsize, self.alignment, self.flags).\n            // The self.itemsize and self.alignment entries are both -1 if the data-type\n            // object is built-in and not flexible (because they are fixed on creation).\n            // The setstate method takes the saved state and updates the data-type.\n            String endianness = String.valueOf(((List) state).get(1));\n            setEndianness(endianness.equals(\">\"));\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Global objects that are going to be recognized by the\n     * unpickler by their module and name. New global objects\n     * may be added by {@link #registerGlobal(String, String, Global)}.\n     */\n    private static final Map<String,Map<String,Global>> GLOBALS = new HashMap<>();\n    static\n    {\n        // Breaking the 80col convention for readability\n        registerGlobal(\"numpy.core.multiarray\", \"_reconstruct\", new NumpyCoreMultiarrayReconstruct());\n        registerGlobal(\"numpy.core.multiarray\", \"scalar\",       new NumpyCoreMultiarrayScalar());\n        registerGlobal(\"numpy\",                 \"ndarray\",      new NDArrayType());\n        registerGlobal(\"numpy\",                 \"dtype\",        new DTypeFactory());\n        registerGlobal(\"numpy\",                 \"fromstring\",   new NumpyFromstring());\n        registerGlobal(\"_codecs\",               \"encode\",       new Encoder());\n        registerGlobal(\"__builtin__\",           \"bytes\",        new BytesPlaceholder());\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Unique marker object.\n     */\n    private static final Object MARK =\n        new Object() {", "            @Override public String toString() {\n                return \"<MARK>\";\n            }\n        };\n\n    /**\n     * Stream where we read pickle data from.\n     */\n    private final InputStream myFp;\n\n    /**\n     * Object stack.\n     */\n    private final ShrinkableList<Object> myStack = new ShrinkableList<>();\n\n    /**\n     * Memo (objects indexed by integers).\n     */\n    private final Map<Integer,Object> myMemo = new HashMap<>();\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Helper method to unpickle a single object from an array of raw bytes.\n     *\n     * @param bytes  The byte array to load from.\n     *\n     * @return the object.\n     *\n     * @throws MalformedPickleException if the byte array could not be decoded.\n     * @throws IOException if the byte array could not be read.\n     */", "    public static Object loadPickle(final byte[] bytes)\n        throws MalformedPickleException,\n               IOException\n    {\n        return loadPickle(new ByteArrayInputStream(bytes));\n    }\n\n    /**\n     * Helper method to unpickle a single object from a stream.\n     *\n     * @param fp  The stream to load from.\n     *\n     * @return the object.\n     *\n     * @throws MalformedPickleException if the stream could not be decoded.\n     * @throws IOException if the stream could not be read.\n     */", "    public static Object loadPickle(final InputStream fp)\n        throws MalformedPickleException,\n               IOException\n    {\n        // We use a buffered input stream because gzip'd streams tend to\n        // interact badly with loading owing to the way in which they are read\n        // in. This seems to be especially pathological for Python3 pickled\n        // data.\n        return (fp instanceof BufferedInputStream)\n            ? new PythonUnpickle(fp).loadPickle()\n            : loadPickle(new BufferedInputStream(fp));\n    }\n\n    /**\n     * Register a global name to be recognized by the unpickler.\n     */\n    private static void registerGlobal(String module, String name, Global f)\n    {\n        GLOBALS.computeIfAbsent(\n            module,\n            k -> new HashMap<>()\n        ).put(name, f);\n    }\n\n    /**\n     * Unwind a collection as a String, with special handling of CharSequences\n     * (since they might be Pythonic data).\n     */\n    private static String render(final Collection<?> collection)\n    {\n        // What we'll build up with\n        final StringBuilder sb = new StringBuilder();\n        sb.append('[');\n\n        // Print all the elements, with some special handling\n        boolean first = true;", "        for (Object element : collection) {\n            // Separator?\n            if (!first) {\n                sb.append(\", \");\n            }\n            else {\n                first = false;\n            }\n\n            // What we'll render\n            String value = String.valueOf(element);\n\n            // Handle strings specially", "            if (element instanceof CharSequence) {\n                sb.append('\"');\n\n                // Handle the fact that strings might be data\n                boolean truncated = false;\n                if (value.length() > 1000) {\n                    value = value.substring(0, 1000);\n                    truncated = true;\n                }\n                for (int j=0; j < value.length(); j++) {\n                    char c = value.charAt(j);", "                for (int j=0; j < value.length(); j++) {\n                    char c = value.charAt(j);\n                    if (' ' <= c && c <= '~') {\n                        sb.append(c);\n                    }\n                    else {\n                        sb.append('\\\\').append(\"0x\");\n                        StringUtil.appendHexByte(sb, (byte)c);\n                    }\n                }\n", "                if (truncated) {\n                    sb.append(\"...\");\n                }\n                sb.append('\"');\n            }\n            else if (element instanceof Collection) {\n                sb.append(render((Collection<?>)element));\n            }\n            else {\n                sb.append(value);\n            }\n        }\n\n        sb.append(']');\n\n        // And give it back\n        return sb.toString();\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     */\n    public PythonUnpickle(InputStream fp)\n    {\n        myFp = fp;\n    }\n\n    /**\n     * Unpickle an object from the stream.\n     */\n    @SuppressWarnings({ \"unchecked\" })", "    public Object loadPickle()\n        throws IOException,\n               MalformedPickleException\n    {\n        while (true) {\n            byte code = (byte)read();\n            try {\n                Operations op = Operations.valueOf(code);\n                switch (op) {\n                case STOP:\n                    if (myStack.size() != 1) {", "                    if (myStack.size() != 1) {\n                        if (myStack.isEmpty()) {\n                            throw new MalformedPickleException(\n                                \"No objects on the stack when STOP is encountered\"\n                            );\n                        }\n                        else {\n                            throw new MalformedPickleException(\n                                \"More than one object on the stack \" +\n                                \"when STOP is encountered: \" + myStack.size()\n                            );\n                        }\n                    }\n                    return pop();\n\n                case GLOBAL:\n                    String module = readline();\n                    String name = readline();\n                    Global f = GLOBALS.getOrDefault(module, Collections.emptyMap())\n                                      .get(name);", "                    if (f == null) {\n                        throw new MalformedPickleException(\n                            \"Global \" + module + \".\" + name + \" is not supported\"\n                        );\n                    }\n                    myStack.add(f);\n                    break;\n\n                // Memo and mark operations\n\n                case PUT: {\n                    String repr = readline();", "                    try {\n                        myMemo.put(Integer.parseInt(repr), peek());\n                    }\n                    catch (NumberFormatException e) {\n                        throw new MalformedPickleException(\n                            \"Could not parse int \\\"\" + repr + \"\\\" for PUT\",\n                            e\n                        );\n                    }\n                    break;\n                }\n\n                case BINPUT:\n                    myMemo.put(read(), peek());\n                    break;\n\n                case LONG_BINPUT:\n                    myMemo.put(readInt32(), peek());\n                    break;\n\n                case GET: {\n                    String repr = readline();", "                    try {\n                        memoGet(Integer.parseInt(repr));\n                    }\n                    catch (NumberFormatException e) {\n                        throw new MalformedPickleException(\n                            \"Could not parse int \\\"\" + repr + \"\\\" for GET\",\n                            e\n                        );\n                    }\n                    break;\n                }\n\n                case BINGET:\n                    memoGet(read());\n                    break;\n\n                case LONG_BINGET:\n                    // Untested\n                    memoGet(readInt32());\n                    break;\n\n                case MARK:\n                    myStack.add(MARK);\n                    break;\n\n                // Integers\n\n                case INT:\n                    myStack.add(Long.parseLong(readline()));\n                    break;\n\n                case LONG1: {\n                    int c = (int)(read() & 0xff);", "                    if (c != 8) {\n                        throw new MalformedPickleException(\n                            \"Unsupported LONG1 size \" + c\n                        );\n                    }\n                    long a = ((long) readInt32() & 0xffffffffL);\n                    long b = ((long) readInt32() & 0xffffffffL);\n                    myStack.add(a + (b << 32));\n                }   break;\n\n                case BININT:\n                    myStack.add(readInt32());\n                    break;\n\n                case BININT1:\n                    myStack.add(read());\n                    break;\n\n                case BININT2:\n                    myStack.add(read() + 256 * read());\n                    break;\n\n                // Dicts\n\n                case EMPTY_DICT:\n                    myStack.add(new Dict());\n                    break;\n\n                case DICT: {\n                    int k = marker();\n                    Map dict = new Dict();", "                    for (int idx = k + 1; idx < myStack.size(); idx += 2) {\n                        dict.put(keyType(myStack.get(idx)), myStack.get(idx + 1));\n                    }\n                    myStack.removeRange(k, myStack.size());\n                    myStack.add(dict);\n                    break;\n                }\n\n                case SETITEM: {\n                    // Untested\n                    Object v = pop();\n                    Object k = pop();\n                    Object top = peek();", "                    if (!(top instanceof Dict)) {\n                        throw new MalformedPickleException(\n                            \"Not a dict on top of the stack in SETITEM: \" + top\n                        );\n                    }\n                    ((Dict) top).put(keyType(k), v);\n                    break;\n                }\n\n                case SETITEMS: {\n                    int k = marker();", "                    if (k < 1) {\n                        throw new MalformedPickleException(\n                            \"No dict to add to in SETITEMS\"\n                        );\n                    }\n\n                    Object top = myStack.get(k - 1);\n                    if (!(top instanceof Dict)) {\n                        throw new MalformedPickleException(\n                            \"Not a dict on top of the stack in SETITEMS: \" + top\n                        );\n                    }\n\n                    Dict dict = (Dict) top;", "                    for (int i = k + 1; i < myStack.size(); i += 2) {\n                        dict.put(keyType(myStack.get(i)), myStack.get(i + 1));\n                    }\n                    myStack.removeRange(k, myStack.size());\n                    break;\n                }\n\n                // Tuples\n\n                case TUPLE: {\n                    int k = marker();\n                    List<Object> tuple = new ArrayList<>(\n                        myStack.subList(k + 1, myStack.size())\n                    );\n                    myStack.removeRange(k, myStack.size());\n                    myStack.add(Collections.unmodifiableList(tuple));\n                    break;\n                }\n\n                case EMPTY_TUPLE:\n                    myStack.add(Collections.emptyList());\n                    break;\n\n                case TUPLE1:\n                    myStack.add(Collections.singletonList(pop()));\n                    break;\n\n                case TUPLE2: {\n                    Object i2 = pop();\n                    Object i1 = pop();\n                    myStack.add(Arrays.asList(i1, i2));\n                    break;\n                }\n\n                case TUPLE3: {\n                    Object i3 = pop();\n                    Object i2 = pop();\n                    Object i1 = pop();\n                    myStack.add(Arrays.asList(i1, i2, i3));\n                    break;\n                }\n\n                // Lists\n\n                case EMPTY_LIST:\n                    myStack.add(new ArrayList<>());\n                    break;\n\n                case LIST: {\n                    int k = marker();\n                    List<Object> list = new ArrayList<>(\n                        myStack.subList(k + 1, myStack.size())\n                    );\n                    myStack.removeRange(k, myStack.size());\n                    myStack.add(list);\n                    break;\n                }\n\n                case APPEND: {\n                    Object v = pop();\n                    Object top = peek();", "                    if (!(top instanceof List)) {\n                        throw new MalformedPickleException(\n                            \"Not a list on top of the stack in APPEND: \" + top\n                        );\n                    }\n                    ((List) top).add(v);\n                    break;\n                }\n\n                case APPENDS: {\n                    int k = marker();", "                    if (k < 1) {\n                        throw new MalformedPickleException(\n                            \"No list to add to in APPENDS\"\n                        );\n                    }\n\n                    Object top = myStack.get(k - 1);\n                    if (!(top instanceof List)) {\n                        throw new MalformedPickleException(\n                            \"Not a list on top of the stack in APPENDS: \" + top\n                        );\n                    }\n                    List list = (List) top;", "                    for (int i = k + 1; i < myStack.size(); i++) {\n                        list.add(myStack.get(i));\n                    }\n                    myStack.removeRange(k, myStack.size());\n                    break;\n                }\n\n                // Strings\n\n                case STRING:\n                    myStack.add(readline());\n                    break;\n\n                case BINSTRING:\n                    myStack.add(new BinString(readBytes(readInt32())));\n                    break;\n\n                case SHORT_BINSTRING:\n                    myStack.add(new BinString(readBytes(read())));\n                    break;\n\n                case BINUNICODE: {\n                    int length = readInt32();\n                    final byte[] b = new byte[length];", "                    for (int i=0; i < b.length; i++) {\n                        b[i] = (byte)read();\n                    }\n                    myStack.add(new String(b, StandardCharsets.UTF_8));\n                    break;\n                }\n\n                // Objects\n\n                case REDUCE:\n                    Object args = pop();\n                    Object func = pop();", "                    if (!(func instanceof Global)) {\n                        throw new MalformedPickleException(\n                            \"Argument \" +\n                            ((func == null) ? \"<null>\"\n                                            : \"of type \" + func.getClass()) +\n                            \" to REDUCE is not a function\"\n                        );\n                    }\n                    myStack.add(((Global) func).call(args));\n                    break;\n\n                case BUILD:\n                    Object state = pop();\n                    Object inst = peek();", "                    if (!(inst instanceof Instance)) {\n                        throw new MalformedPickleException(\n                            \"Argument \" +\n                            ((inst == null) ? \"<null>\"\n                                            : \"of type \" + inst.getClass()) +\n                            \" to BUILD is not an instance\"\n                        );\n                    }\n                    ((Instance) inst).setState(state);\n                    break;\n\n                case NONE:\n                    myStack.add(null);\n                    break;\n\n                case NEWTRUE:\n                    myStack.add(true);\n                    break;\n\n                case NEWFALSE:\n                    myStack.add(false);\n                    break;\n\n                case PROTO:\n                    int version = read();", "                    if (version < 0 || version > 2) {\n                        throw new MalformedPickleException(\n                            \"Unsupported pickle version \" + version\n                        );\n                    }\n                    break;\n\n                case POP:\n                    pop();\n                    break;\n\n                case POP_MARK: {\n                    int k = marker();\n                    myStack.removeRange(k, myStack.size());\n                    break;\n                }\n\n                case DUP:\n                    myStack.add(peek());\n                    break;\n\n                case FLOAT:\n                    myStack.add(Float.parseFloat(readline()));\n                    break;\n\n                case BINFLOAT: {\n                    long a = ((long) readInt32() & 0xffffffffL);\n                    long b = ((long) readInt32() & 0xffffffffL);\n                    long bits = Long.reverseBytes(a + (b << 32));\n                    myStack.add(Double.longBitsToDouble(bits));\n                    break;\n                }\n\n                case LONG:\n                    myStack.add(new BigInteger(readline()));\n                    break;\n\n                default:\n                    throw new MalformedPickleException(\n                        \"Unsupported operation \" + Operations.valueOf(code)\n                    );\n                }\n            }\n            catch (NumberFormatException e) {\n                throw new MalformedPickleException(\n                    \"Malformed number while handling opcode \" +\n                    Operations.valueOf(code),\n                    e\n                );\n            }\n            catch (IllegalArgumentException e) {\n                throw new MalformedPickleException(\n                    \"Could not handle opcode \" + (int)code\n                );\n            }\n            catch (ClassCastException e) {\n                throw new MalformedPickleException(\n                    \"Elements on the stack are unsuitable to opcode \" +\n                    Operations.valueOf(code),\n                    e\n                );\n            }\n        }\n    }\n\n    /**\n     * Convert {@code BinString} objects to strings for dictionary keys.\n     */\n    private Object keyType(Object o)\n    {\n        return (o instanceof BinString) ? String.valueOf(o) : o;\n    }\n\n    // Implementation\n\n    /**\n     * Return the index of the marker on the stack.\n     */\n    private int marker() throws MalformedPickleException\n    {", "        for (int i = myStack.size(); i-- > 0;) {\n            if (myStack.get(i) == MARK) {\n                return i;\n            }\n        }\n        throw new MalformedPickleException(\"No MARK on the stack\");\n    }\n\n    /**\n     * Retrieve a memo object by its key.\n     */\n    private void memoGet(int key) throws MalformedPickleException\n    {", "        if (!myMemo.containsKey(key)) {\n            throw new MalformedPickleException(\n                \"GET key \" + key + \" missing from the memo\"\n            );\n        }\n        myStack.add(myMemo.get(key));\n    }\n\n    /**\n     * Read a single byte from the stream.\n     */\n    private int read()\n        throws IOException\n    {\n        int c = myFp.read();", "        if (c == -1) {\n            throw new EOFException();\n        }\n        return c;\n    }\n\n    /**\n     * Read a 32-bit integer from the stream.\n     */\n    private int readInt32()\n        throws IOException\n    {\n        return read() + 256 * read() + 65536 * read() + 16777216 * read();\n    }\n\n    /**\n     * Read a given number of bytes from the stream and return\n     * a byte buffer.\n     */\n    private ByteBuffer readBytes(int length)\n        throws IOException\n    {\n        ByteBuffer buf = ByteBuffer.allocate(length);", "        for (int read = 0; read < length;) {\n            int bytesRead = myFp.read(buf.array(), read, length - read);\n            if (bytesRead == -1) {\n                throw new EOFException();\n            }\n            read += bytesRead;\n        }\n        buf.limit(length);\n        return buf;\n    }\n\n    /**\n     * Read a newline ({@code\\n})-terminated line from the stream. Does not do\n     * any additional parsing.\n     */\n    private String readline()\n        throws IOException\n    {\n        int c;\n        final StringBuilder sb = new StringBuilder(1024 * 1024); // might be big!", "        while ((c = read()) != '\\n') {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the top element on the stack.\n     */\n    private Object peek()\n        throws MalformedPickleException\n    {", "        if (myStack.isEmpty()) {\n            throw new MalformedPickleException(\n                \"No objects on the stack during peek()\"\n            );\n        }\n        return myStack.get(myStack.size() - 1);\n    }\n\n    /**\n     * Pop the top element from the stack.\n     */\n    private Object pop()\n        throws MalformedPickleException\n    {", "        if (myStack.isEmpty()) {\n            throw new MalformedPickleException(\n                \"No objects on the stack during pop()\"\n            );\n        }\n        return myStack.remove(myStack.size() - 1);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/MalformedPickleException.java", "chunked_list": ["package com.deshaw.python;\n\n/**\n * Exception thrown when a problem is encountered with a Python pickle.\n */\npublic class MalformedPickleException\n    extends Exception\n{\n    private static final long serialVersionUID = -8373745679492469567L;\n\n    /**\n     * Constructor.\n     *\n     * @param message  The exception message.\n     */\n    public MalformedPickleException(String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message  The exception message.\n     * @param cause    The original exception.\n     */\n    public MalformedPickleException(String message, Throwable cause)\n    {\n        super(message, cause);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/PythonPickle.java", "chunked_list": ["package com.deshaw.python;\n\nimport com.deshaw.util.ByteList;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;", "import java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.charset.StandardCharsets;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.RandomAccess;\n\n/**\n * Serialization of basic Java objects into a format compatible with Python's\n * pickle protocol. This should allow objects to be marshalled from Java into\n * Python.\n *", " * Python.\n *\n * <p>This class is not thread-safe.\n */\npublic class PythonPickle\n{\n    // Keep in sync with pickle.Pickler._BATCHSIZE. This is how many elements\n    // batch_list/dict() pumps out before doing APPENDS/SETITEMS. Nothing will\n    // break if this gets out of sync with pickle.py, but it's unclear that\n    // would help anything either.\n    private static final int  BATCHSIZE = 1000;\n    private static final byte MARK_V    = Operations.MARK.code;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * We buffer up everything in here for dumping.\n     */\n    private final ByteArrayOutputStream myStream = new ByteArrayOutputStream();\n\n    /**\n     * Used to provide a handle on objects which we have already stored (so that\n     * we don't duplicate them in the result).\n     */\n    private final IdentityHashMap<Object,Integer> myMemo = new IdentityHashMap<>();\n\n    // Scratch space\n    private final ByteBuffer myTwoByteBuffer   = ByteBuffer.allocate(2);\n    private final ByteBuffer myFourByteBuffer  = ByteBuffer.allocate(4);\n    private final ByteBuffer myEightByteBuffer = ByteBuffer.allocate(8);\n    private final ByteList   myByteList        = new ByteList();\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Dump an object out to a given stream.\n     */", "    public void toStream(Object o, OutputStream stream)\n        throws IOException\n    {\n        // Might be better to use the stream directly, rather than staging\n        // locally.\n        toPickle(o);\n        myStream.writeTo(stream);\n    }\n\n    /**\n     * Dump to a byte-array.\n     */\n    public byte[] toByteArray(Object o)\n    {\n        toPickle(o);\n        return myStream.toByteArray();\n    }\n\n    /**\n     * Pickle an arbitrary object which isn't handled by default.\n     *\n     * <p>Subclasses can override this to extend the class's behaviour.\n     *\n     * @throws UnsupportedOperationException if the object could not be pickled.\n     */\n    protected void saveObject(Object o)\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException(\n            \"Cannot pickle \" + o.getClass().getCanonicalName()\n        );\n    }\n\n    // ----------------------------------------------------------------------------\n    // Methods which subclasses might need to extend funnctionality\n\n    /**\n     * Get back the reference to a previously saved object.\n     */\n    protected final void get(Object o)\n    {\n        writeOpcodeForValue(Operations.BINGET,\n                            Operations.LONG_BINGET,\n                            myMemo.get(o));\n    }\n\n    /**\n     * Save a reference to an object.\n     */\n    protected final void put(Object o)\n    {\n        // 1-indexed; see comment about positve vs. non-negative in Python's\n        // C pickle code\n        final int n = myMemo.size() + 1;\n        myMemo.put(o, n);\n        writeOpcodeForValue(Operations.BINPUT,\n                            Operations.LONG_BINPUT,\n                            n);\n    }\n\n    /**\n     * Write out an opcode, depending on the size of the 'n' value we are\n     * encoding (i.e. if it fits in a byte).\n     */\n    protected final void writeOpcodeForValue(Operations op1, Operations op5, int n)\n    {", "        if (n < 256) {\n            write(op1);\n            write((byte) n);\n        }\n        else {\n            write(op5);\n            // The pickle protocol saves this in little-endian format.\n            writeLittleEndianInt(n);\n        }\n    }\n\n    /**\n     * Dump out a string as ASCII.\n     */\n    protected final void writeAscii(String s)\n    {\n        write(s.getBytes(StandardCharsets.US_ASCII));\n    }\n\n    /**\n     * Write out a byte.\n     */\n    protected final void write(Operations op)\n    {\n        myStream.write(op.code);\n    }\n\n    /**\n     * Write out a byte.\n     */\n    protected final void write(byte i)\n    {\n        myStream.write(i);\n    }\n\n    /**\n     * Write out a char.\n     */\n    protected final void write(char c)\n    {\n        myStream.write(c);\n    }\n\n    /**\n     * Write out an int, in little-endian format.\n     */\n    protected final void writeLittleEndianInt(final int n)\n    {\n        write(myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN).putInt(0, n));\n    }\n\n    /**\n     * Write out the contents of a ByteBuffer.\n     */\n    protected final void write(ByteBuffer b)\n    {\n        write(b.array());\n    }\n\n    /**\n     * Write out the contents of a byte array.\n     */\n    protected final void write(byte[] array)\n    {\n        myStream.write(array, 0, array.length);\n    }\n\n    /**\n     * Dump out a 32bit float.\n     */\n    protected final void saveFloat(float o)\n    {\n        myByteList.clear();\n        myByteList.append(Float.toString(o).getBytes());\n\n        write(Operations.FLOAT);\n        write(myByteList.toArray());\n        write((byte) '\\n');\n    }\n\n    /**\n     * Dump out a 64bit double.\n     */\n    protected final void saveFloat(double o)\n    {\n        write(Operations.BINFLOAT);\n        // The pickle protocol saves Python floats in big-endian format.\n        write(myEightByteBuffer.order(ByteOrder.BIG_ENDIAN).putDouble(0, o));\n    }\n\n    /**\n     * Write a 32-or-less bit integer.\n     */\n    protected final void saveInteger(int o)\n    {\n        // The pickle protocol saves Python integers in little-endian format.\n        final byte[] a =\n            myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN).putInt(0, o)\n                            .array();", "        if (a[2] == 0 && a[3] == 0) {\n            if (a[1] == 0) {\n                // BININT1 is for integers [0, 256), not [-128, 128).\n                write(Operations.BININT1);\n                write(a[0]);\n                return;\n            }\n            // BININT2 is for integers [256, 65536), not [-32768, 32768).\n            write(Operations.BININT2);\n            write(a[0]);\n            write(a[1]);\n            return;\n        }\n        write(Operations.BININT);\n        write(a);\n    }\n\n    /**\n     * Write a 64-or-less bit integer.\n     */\n    protected final void saveInteger(long o)\n    {", "        if (o <= Integer.MAX_VALUE && o >= Integer.MIN_VALUE) {\n            saveInteger((int) o);\n        }\n        else {\n            write(Operations.LONG1);\n            write((byte)8);\n            write(myEightByteBuffer.order(ByteOrder.LITTLE_ENDIAN).putLong(0, o));\n        }\n    }\n\n    /**\n     * Write out a string as real unicode.\n     */\n    protected final void saveUnicode(String o)\n    {\n        final byte[] b;\n        b = o.getBytes(StandardCharsets.UTF_8);\n        write(Operations.BINUNICODE);\n        // Pickle protocol is always little-endian\n        writeLittleEndianInt(b.length);\n        write(b);\n        put(o);\n    }\n\n    // ----------------------------------------------------------------------\n    // Serializing objects intended to be unpickled as numpy arrays\n    //\n    // Instead of serializing array-like objects exactly the way numpy\n    // arrays are serialized, we simply serialize them to be unpickled\n    // as numpy arrays.  The simplest way to do this is to use\n    // numpy.fromstring().  We write out opcodes to build the\n    // following stack:\n    //\n    //     [..., numpy.fromstring, binary_data_string, dtype_string]\n    //\n    // and then call TUPLE2 and REDUCE to get:\n    //\n    //     [..., numpy.fromstring(binary_data_string, dtype_string)]\n    //\n    // http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromstring.html\n\n    /**\n     * Save the Python function module.name.  We use this function\n     * with the REDUCE opcode to build Python objects when unpickling.\n     */\n    protected final void saveGlobal(String module, String name)\n    {\n        write(Operations.GLOBAL);\n        writeAscii(module);\n        writeAscii(\"\\n\");\n        writeAscii(name);\n        writeAscii(\"\\n\");\n    }\n\n    /**\n     * Save a boolean array as a numpy array.\n     */\n    protected final void saveNumpyBooleanArray(boolean[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader((long) n);\n", "        for (boolean d : o) {\n            write((byte) (d?1:0));\n        }\n\n        addNumpyArrayEnding(DType.Type.BOOLEAN, o);\n    }\n\n    /**\n     * Save a byte array as a numpy array.\n     */\n    protected final void saveNumpyByteArray(byte[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader((long) n);\n", "        for (byte d : o) {\n            write(d);\n        }\n\n        addNumpyArrayEnding(DType.Type.INT8, o);\n    }\n\n    /**\n     * Save a char array as a numpy array.\n     */\n    protected final void saveNumpyCharArray(char[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader((long) n);\n", "        for (char c : o) {\n            write(c);\n        }\n\n        addNumpyArrayEnding(DType.Type.CHAR, o);\n    }\n\n    /**\n     * Save a ByteList as a numpy array.\n     */\n    protected final void saveNumpyByteArray(ByteList o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.size();\n        writeBinStringHeader((long) n);\n", "        for (int i=0; i < n; ++i) {\n            write(o.getNoCheck(i));\n        }\n\n        addNumpyArrayEnding(DType.Type.INT8, o);\n    }\n\n    /**\n     * Save a short array as a numpy array.\n     */\n    protected final void saveNumpyShortArray(short[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader(2 * (long) n);\n        myTwoByteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n", "        for (short d : o) {\n            write(myTwoByteBuffer.putShort(0, d));\n        }\n\n        addNumpyArrayEnding(DType.Type.INT16, o);\n    }\n\n    /**\n     * Save an int array as a numpy array.\n     */\n    protected final void saveNumpyIntArray(int[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader(4 * (long) n);\n        myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n", "        for (int d : o) {\n            write(myFourByteBuffer.putInt(0, d));\n        }\n\n        addNumpyArrayEnding(DType.Type.INT32, o);\n    }\n\n    /**\n     * Save a long array as a numpy array.\n     */\n    protected final void saveNumpyLongArray(long[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader(8 * (long) n);\n        myEightByteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n", "        for (long d : o) {\n            write(myEightByteBuffer.putLong(0, d));\n        }\n\n        addNumpyArrayEnding(DType.Type.INT64, o);\n    }\n\n    /**\n     * Save a float array as a numpy array.\n     */\n    protected final void saveNumpyFloatArray(float[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader(4 * (long) n);\n        myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n", "        for (float f : o) {\n            write(myFourByteBuffer.putFloat(0, f));\n        }\n\n        addNumpyArrayEnding(DType.Type.FLOAT32, o);\n    }\n\n    /**\n     * Save a double array as a numpy array.\n     */\n    protected final void saveNumpyDoubleArray(double[] o)\n    {\n        saveGlobal(\"numpy\", \"fromstring\");\n        final int n = o.length;\n        writeBinStringHeader(8 * (long) n);\n        myEightByteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n", "        for (double d : o) {\n            write(myEightByteBuffer.putDouble(0, d));\n        }\n\n        addNumpyArrayEnding(DType.Type.FLOAT64, o);\n    }\n\n    // ----------------------------------------------------------------------------\n\n    /**\n     * Actually do the dump.\n     */\n    private void toPickle(Object o)\n    {\n        myStream.reset();\n\n        write(Operations.PROTO);\n        write((byte) 2);\n        save(o);\n        write(Operations.STOP);\n\n        myMemo.clear();\n    }\n\n    /**\n     * Pickle an arbitrary object.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void save(Object o)\n        throws UnsupportedOperationException\n    {", "        if (o == null) {\n            write(Operations.NONE);\n        }\n        else if (myMemo.containsKey(o)) {\n            get(o);\n        }\n        else if (o instanceof Boolean) {\n            write(((Boolean) o) ? Operations.NEWTRUE : Operations.NEWFALSE);\n        }\n        else if (o instanceof Float) {\n            saveFloat((Float) o);\n        }", "        else if (o instanceof Float) {\n            saveFloat((Float) o);\n        }\n        else if (o instanceof Double) {\n            saveFloat((Double) o);\n        }\n        else if (o instanceof Byte) {\n            saveInteger(((Byte) o).intValue());\n        }\n        else if (o instanceof Short) {\n            saveInteger(((Short) o).intValue());\n        }", "        else if (o instanceof Short) {\n            saveInteger(((Short) o).intValue());\n        }\n        else if (o instanceof Integer) {\n            saveInteger((Integer) o);\n        }\n        else if (o instanceof Long) {\n            saveInteger((Long) o);\n        }\n        else if (o instanceof String) {\n            saveUnicode((String) o);\n        }", "        else if (o instanceof String) {\n            saveUnicode((String) o);\n        }\n        else if (o instanceof boolean[]) {\n            saveNumpyBooleanArray((boolean[]) o);\n        }\n        else if (o instanceof char[]) {\n            saveNumpyCharArray((char[]) o);\n        }\n        else if (o instanceof byte[]) {\n            saveNumpyByteArray((byte[]) o);\n        }", "        else if (o instanceof byte[]) {\n            saveNumpyByteArray((byte[]) o);\n        }\n        else if (o instanceof short[]) {\n            saveNumpyShortArray((short[]) o);\n        }\n        else if (o instanceof int[]) {\n            saveNumpyIntArray((int[]) o);\n        }\n        else if (o instanceof long[]) {\n            saveNumpyLongArray((long[]) o);\n        }", "        else if (o instanceof long[]) {\n            saveNumpyLongArray((long[]) o);\n        }\n        else if (o instanceof float[]) {\n            saveNumpyFloatArray((float[]) o);\n        }\n        else if (o instanceof double[]) {\n            saveNumpyDoubleArray((double[]) o);\n        }\n        else if (o instanceof List) {\n            saveList((List<Object>) o);\n        }", "        else if (o instanceof List) {\n            saveList((List<Object>) o);\n        }\n        else if (o instanceof Map) {\n            saveDict((Map<Object,Object>) o);\n        }\n        else if (o instanceof Collection) {\n            saveCollection((Collection<Object>) o);\n        }\n        else if (o.getClass().isArray()) {\n            saveList(Arrays.asList((Object[]) o));\n        }\n        else {\n            saveObject(o);\n        }\n    }\n\n    /**\n     * Write out the header for a binary \"string\" of data.\n     */\n    private void writeBinStringHeader(long n)\n    {", "        else if (o.getClass().isArray()) {\n            saveList(Arrays.asList((Object[]) o));\n        }\n        else {\n            saveObject(o);\n        }\n    }\n\n    /**\n     * Write out the header for a binary \"string\" of data.\n     */\n    private void writeBinStringHeader(long n)\n    {", "        if (n < 256) {\n            write(Operations.SHORT_BINSTRING);\n            write((byte) n);\n        }\n        else if (n <= Integer.MAX_VALUE) {\n            write(Operations.BINSTRING);\n            // Pickle protocol is always little-endian\n            writeLittleEndianInt((int) n);\n        }\n        else {\n            throw new UnsupportedOperationException(\"String length of \" + n + \" is too large\");\n        }\n    }\n\n    /**\n     * The string for which {@code numpy.dtype(...)} returns the desired dtype.\n     */\n    private String dtypeDescr(final DType.Type type)\n    {", "        if (type == null) {\n            throw new NullPointerException(\"Null dtype\");\n        }\n\n        switch (type) {\n        case BOOLEAN: return \"|b1\";\n        case CHAR:    return \"<S1\";\n        case INT8:    return \"<i1\";\n        case INT16:   return \"<i2\";\n        case INT32:   return \"<i4\";\n        case INT64:   return \"<i8\";\n        case FLOAT32: return \"<f4\";\n        case FLOAT64: return \"<f8\";\n        default: throw new IllegalArgumentException(\"Unhandled type: \" + type);\n        }\n    }\n\n    /**\n     * Add the suffix of a serialized numpy array\n     *\n     * @param dtype type of the numpy array\n     * @param o the array (or list) being serialized\n     */\n    private void addNumpyArrayEnding(DType.Type dtype, Object o)\n    {\n        final String descr = dtypeDescr(dtype);\n        writeBinStringHeader(descr.length());\n        writeAscii(descr);\n        write(Operations.TUPLE2);\n        write(Operations.REDUCE);\n        put(o);\n    }\n\n    /**\n     * Save a Collection of arbitrary Objects as a tuple.\n     */\n    private void saveCollection(Collection<Object> x)\n    {\n        // Tuples over 3 elements in size need a \"mark\" to look back to", "        if (x.size() > 3) {\n            write(Operations.MARK);\n        }\n\n        // Save all the elements\n        for (Object o : x) {\n            save(o);\n        }\n\n        // And say what we sent\n        switch (x.size()) {\n        case 0:  write(Operations.EMPTY_TUPLE); break;\n        case 1:  write(Operations.TUPLE1);      break;\n        case 2:  write(Operations.TUPLE2);      break;\n        case 3:  write(Operations.TUPLE3);      break;\n        default: write(Operations.TUPLE);       break;\n        }\n\n        put(x);\n    }\n\n    /**\n     * Save a list of arbitrary objects.\n     */\n    private void saveList(List<Object> x)\n    {\n        // Two implementations here. For RandomAccess lists it's faster to do\n        // explicit get methods. For other ones iteration is faster.", "        if (x instanceof RandomAccess) {\n            write(Operations.EMPTY_LIST);\n            put(x);\n            for (int i=0; i < x.size(); i++) {\n                final Object first = x.get(i);\n                if (++i >= x.size()) {\n                    save(first);\n                    write(Operations.APPEND);\n                    break;\n                }\n                final Object second = x.get(i);\n                write(MARK_V);\n                save(first);\n                save(second);\n                int left = BATCHSIZE - 2;", "                while (left > 0 && ++i < x.size()) {\n                    final Object item = x.get(i);\n                    save(item);\n                    left -= 1;\n                }\n                write(Operations.APPENDS);\n            }\n        }\n        else {\n            write(Operations.EMPTY_LIST);\n            put(x);\n            final Iterator<Object> items = x.iterator();", "            while (true) {\n                if (!items.hasNext())\n                    break;\n                final Object first = items.next();\n                if (!items.hasNext()) {\n                    save(first);\n                    write(Operations.APPEND);\n                    break;\n                }\n                final Object second = items.next();\n                write(MARK_V);\n                save(first);\n                save(second);\n                int left = BATCHSIZE - 2;", "                while (left > 0 && items.hasNext()) {\n                    final Object item = items.next();\n                    save(item);\n                    left -= 1;\n                }\n                write(Operations.APPENDS);\n            }\n        }\n    }\n\n    /**\n     * Save a map of arbitrary objects as a dict.\n     */\n    private void saveDict(Map<Object,Object> x)\n    {\n        write(Operations.EMPTY_DICT);\n        put(x);\n        final Iterator<Entry<Object,Object>> items = x.entrySet().iterator();", "        while (true) {\n            if (!items.hasNext())\n                break;\n            final Entry<Object,Object> first = items.next();\n            if (!items.hasNext()) {\n                save(first.getKey());\n                save(first.getValue());\n                write(Operations.SETITEM);\n                break;\n            }\n            final Entry<Object,Object> second = items.next();\n            write(MARK_V);\n            save(first.getKey());\n            save(first.getValue());\n            save(second.getKey());\n            save(second.getValue());\n            int left = BATCHSIZE - 2;", "            while (left > 0 && items.hasNext()) {\n                final Entry<Object,Object> item = items.next();\n                save(item.getKey());\n                save(item.getValue());\n                left -= 1;\n            }\n            write(Operations.SETITEMS);\n        }\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/python/DType.java", "chunked_list": ["package com.deshaw.python;\n\nimport java.util.List;\n\n/**\n * Encapsulation of a single-element numpy dtype object.\n *\n * @see <a href=\"http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html\">Data type objects</a>\n */\npublic class DType\n{\n    /**\n     * Element types we know about.\n     */", " */\npublic class DType\n{\n    /**\n     * Element types we know about.\n     */\n    public enum Type\n    {\n        // The type numbers can be found by looking at the Python dtype.num\n        /** A bool.    */ BOOLEAN(\"bool\",                1,  0),\n        /** A bytes.   */ CHAR   (\"bytes\",               1, 18),\n        /** A int8.    */ INT8   (\"int8\",    Byte.   BYTES,  1),\n        /** A int16.   */ INT16  (\"int16\",   Short.  BYTES,  3),\n        /** A int32.   */ INT32  (\"int32\",   Integer.BYTES,  5),\n        /** A int64.   */ INT64  (\"int64\",   Long.   BYTES,  7),\n        /** A float32. */ FLOAT32(\"float32\", Float.  BYTES, 11),\n        /** A float64. */ FLOAT64(\"float64\", Double. BYTES, 12);\n", "        /** See numpy. */ public final String name;\n        /** See numpy. */ public final byte   alignment;\n        /** See numpy. */ public final byte   num;\n\n        /**\n         * Constructor.\n         *\n         * @param name      The name.\n         * @param alignment The memory alignment.\n         * @param num       The numpy number.\n         */\n        private Type(String name, int alignment, int num)\n        {\n            this.name      = name;\n            this.alignment = (byte)alignment;\n            this.num       = (byte)num;\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    // Python-like values and methods\n\n    /** Empty int[] */\n    private static int[] EMPTY_INT_ARRAY = new int[0];\n", "    /** See numpy.ndarray. */ public final byte               alignment;\n    /** See numpy.ndarray. */ public final DType              base;\n    /** See numpy.ndarray. */ public final char               byteorder;\n    /** See numpy.ndarray. */ public final List<List<String>> descr;\n    /** See numpy.ndarray. */ public final long               flags;\n    /** See numpy.ndarray. */ public final Object             fields;\n    /** See numpy.ndarray. */ public final boolean            hasobject;\n    /** See numpy.ndarray. */ public final boolean            isalignedstruct;\n    /** See numpy.ndarray. */ public final byte               isbuiltin;\n    /** See numpy.ndarray. */ public final boolean            isnative;\n    /** See numpy.ndarray. */ public final int                itemsize;", "    /** See numpy.ndarray. */ public final byte               isbuiltin;\n    /** See numpy.ndarray. */ public final boolean            isnative;\n    /** See numpy.ndarray. */ public final int                itemsize;\n    /** See numpy.ndarray. */ public final char               kind;\n    /** See numpy.ndarray. */ public final Object             metadata;\n    /** See numpy.ndarray. */ public final String             name;\n    /** See numpy.ndarray. */ public final List<String>       names;\n    /** See numpy.ndarray. */ public final byte               ndim;\n    /** See numpy.ndarray. */ public final byte               num;\n    /** See numpy.ndarray. */ public final int[]              shape;\n    /** See numpy.ndarray. */ public final String             str;", "    /** See numpy.ndarray. */ public final byte               num;\n    /** See numpy.ndarray. */ public final int[]              shape;\n    /** See numpy.ndarray. */ public final String             str;\n    /** See numpy.ndarray. */ public final DType              subdtype;\n\n    /**\n     * See numpy.ndarray.\n     *\n     * @return this dtype.\n     */\n    public final DType newbyteorder()\n    {\n        return this;\n    }\n\n    /**\n     * See numpy.ndarray.\n     *\n     * @param s  Ignored.\n     *\n     * @return this dtype.\n     */", "    public final DType newbyteorder()\n    {\n        return this;\n    }\n\n    /**\n     * See numpy.ndarray.\n     *\n     * @param s  Ignored.\n     *\n     * @return this dtype.\n     */", "    public final DType newbyteorder(String s)\n    {\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Element type char (as given).\n     */\n    private final char myTypeChar;\n\n    /**\n     * Element size.\n     */\n    private final int mySize;\n\n    /**\n     * Element type.\n     */\n    private final Type myType;\n\n    /**\n     * Whether the data is structured.\n     */\n    private boolean myIsStructured;\n\n    /**\n     * Whether the data is big- or little-endian.\n     */\n    private boolean myIsBigEndian;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     *\n     * @param dtype  The {@code str} value of the dtype.\n     */\n    public DType(final CharSequence dtype)\n        throws IllegalArgumentException\n    {\n        // Sanitise input", "        if (dtype == null) {\n            throw new NullPointerException(\"Given a null dtype\");\n        }\n\n        // Defaults\n        myIsStructured = false;\n        myIsBigEndian  = false;\n\n        // Shred the type string. It possibly has an endian char, followed by a\n        // type char and a size char.\n        int start = 0;", "        while (start < dtype.length()) {\n            // Get the char and step on\n            final char c = dtype.charAt(start++);\n            if (c == '\\'') {\n                // Ignore leading 's\n            }\n            else if (c == '|') {\n                myIsStructured = true;\n            }\n            else if (c == '<') {\n                myIsBigEndian = false;\n            }", "            else if (c == '<') {\n                myIsBigEndian = false;\n            }\n            else if (c == '>') {\n                myIsBigEndian = true;\n            }\n            else {\n                // Step back and we're done\n                start--;\n                break;\n            }\n        }\n\n        // Figure out the end (inclusive)\n        int end = dtype.length() - 1;", "        if (end > 0 && dtype.charAt(end) == '\\'') {\n            // Ignore trailing 's\n            end--;\n        }\n\n        // The type is one char now, at the start\n        myTypeChar = dtype.charAt(start);\n\n        // The size is the rest\n        int size = 0;\n        for (int i = start + 1; i <= end; i++) {\n            size = 10 * size + (dtype.charAt(i) - '0');\n        }\n        mySize = size;\n\n        // Whether we recognise it as an integer; shorthand for a test below\n        final boolean isInteger = (myTypeChar == 'b' ||\n                                   myTypeChar == 'i' ||\n                                   myTypeChar == 'u');\n", "        for (int i = start + 1; i <= end; i++) {\n            size = 10 * size + (dtype.charAt(i) - '0');\n        }\n        mySize = size;\n\n        // Whether we recognise it as an integer; shorthand for a test below\n        final boolean isInteger = (myTypeChar == 'b' ||\n                                   myTypeChar == 'i' ||\n                                   myTypeChar == 'u');\n\n        if (myIsStructured && myTypeChar == 'b' && mySize == 1) {\n            myType = Type.BOOLEAN;\n        }", "        if (myIsStructured && myTypeChar == 'b' && mySize == 1) {\n            myType = Type.BOOLEAN;\n        }\n        else if (myTypeChar == 'S' && mySize == 1) {\n            myType = Type.CHAR;\n        }\n        else if (isInteger && mySize == 1) {\n            myType = Type.INT8;\n        }\n        else if (isInteger && mySize == 2) {\n            myType = Type.INT16;\n        }", "        else if (isInteger && mySize == 2) {\n            myType = Type.INT16;\n        }\n        else if (isInteger && mySize == 4) {\n            myType = Type.INT32;\n        }\n        else if (isInteger && mySize == 8) {\n            myType = Type.INT64;\n        }\n        else if (myTypeChar == 'f' && mySize == 4) {\n            myType = Type.FLOAT32;\n        }", "        else if (myTypeChar == 'f' && mySize == 4) {\n            myType = Type.FLOAT32;\n        }\n        else if (myTypeChar == 'f' && mySize == 8) {\n            myType = Type.FLOAT64;\n        }\n        else {\n            throw new IllegalArgumentException(\n                \"Unsupported dtype \\\"\" + dtype + \"\\\"\"\n            );\n        }\n\n        // dtype values\n        alignment       = myType.alignment;\n        byteorder       ='=';\n        base            = this;\n        str             = dtype.toString();\n        descr           = List.of(List.of(\"\", str));\n        flags           = 0;\n        fields          = null;\n        hasobject       = false;\n        isalignedstruct = false;\n        isbuiltin       = 1;\n        isnative        = true;\n        itemsize        = mySize;\n        kind            = myTypeChar;\n        metadata        = null;\n        name            = myType.name;\n        names           = null;\n        ndim            = 0;\n        num             = myType.num;\n        shape           = EMPTY_INT_ARRAY;\n        subdtype        = null;\n    }\n\n    /**\n     * Element size.\n     *\n     * @return the size of the type, in bytes.\n     */", "    public int size()\n    {\n        return mySize;\n    }\n\n    /**\n     * Element type.\n     *\n     * @return the dtype's type.\n     */\n    public Type type()\n    {\n        return myType;\n    }\n\n    /**\n     * Endianness.\n     *\n     * @return whether the type is big endian, or not.\n     */", "    public Type type()\n    {\n        return myType;\n    }\n\n    /**\n     * Endianness.\n     *\n     * @return whether the type is big endian, or not.\n     */\n    public boolean bigEndian()\n    {\n        return myIsBigEndian;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean bigEndian()\n    {\n        return myIsBigEndian;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder sb = new StringBuilder();\n\n        sb.append(\"dtype('\");\n", "    public String toString()\n    {\n        final StringBuilder sb = new StringBuilder();\n\n        sb.append(\"dtype('\");\n\n        if (myIsStructured) {\n            sb.append('|');\n        }\n        sb.append(myIsBigEndian ? '>' : '<');\n        sb.append(myTypeChar);\n        sb.append(mySize);\n\n        sb.append(\"')\");\n\n        return sb.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof DType)) {\n            return false;\n        }\n\n        DType dtype = (DType) o;\n        return myIsBigEndian  == dtype.myIsBigEndian  &&\n               myIsStructured == dtype.myIsStructured &&\n               myType         == dtype.myType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public int hashCode()\n    {\n        return 2 * myType.hashCode() +\n               (myIsBigEndian  ? 1 : 0) +\n               (myIsStructured ? 1 : 0);\n    }\n\n    /**\n     * Set the {@code endian}ness of this type.\n     *\n     * @param isBigEndian  The new endianess.\n     */\n    protected void setEndianness(final boolean isBigEndian)\n    {\n        myIsBigEndian = isBigEndian;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/ByteList.java", "chunked_list": ["package com.deshaw.util;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport java.nio.ByteBuffer;\nimport java.nio.BufferOverflowException;\nimport java.nio.ReadOnlyBufferException;", "import java.nio.BufferOverflowException;\nimport java.nio.ReadOnlyBufferException;\n\nimport java.util.Arrays;\n\n/**\n * A resizable array implementation of a list of {@code byte}s.\n *\n * <p>This can be treated as a {@link CharSequence} for ASCII and Latin1\n * (i.e. byte-based) character sets. It won't work for UTF as-is.", " * <p>This can be treated as a {@link CharSequence} for ASCII and Latin1\n * (i.e. byte-based) character sets. It won't work for UTF as-is.\n */\npublic class ByteList\n    implements CharSequence\n{\n    // ----------------------------------------------------------------------\n\n    /**\n     * Used when the initial capacity isn't specified in the constructor.\n     * Makes it public so people know the default value.\n     *\n     * <p>It's important for this value to be greater than zero for\n     * some implementations to work properly.\n     */", "     * Makes it public so people know the default value.\n     *\n     * <p>It's important for this value to be greater than zero for\n     * some implementations to work properly.\n     */\n    public static final int DEFAULT_INITIAL_CAPACITY = 10;\n\n    /**\n     * An empty {@code byte[]}.\n     */\n    private static final byte[] EMPTY_ARRAY = new byte[0];\n\n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer.\n     */\n    private byte[] myData;\n\n    /**\n     * The size of the list (the number of elements it contains).\n     */\n    private int mySize;\n\n    /**\n     * Cache of the toString() result. This is to save repeated copies of the\n     * ByteList's contents.\n     */\n    private String myToString;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Constructs an empty list with zero initial capacity (but which will jump\n     * to the default initial capacity when something gets added).\n     *\n     * @see #DEFAULT_INITIAL_CAPACITY\n     */\n    public ByteList()\n    {\n        myData     = EMPTY_ARRAY;\n        mySize     = 0;\n        myToString = null;\n    }\n\n    /**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity the initial capacity of the list\n     *\n     * @throws IllegalArgumentException if the specified initial capacity\n     *                                  is negative.\n     */\n    public ByteList(int initialCapacity)\n        throws IllegalArgumentException\n    {", "        if (initialCapacity < 0) {\n            throw new IllegalArgumentException(\"Illegal capacity: \" +\n                                               initialCapacity);\n        }\n\n        myData     = new byte[initialCapacity];\n        mySize     = 0;\n        myToString = null;\n    }\n\n    /**\n     * Increases the capacity of this instance, if necessary, to ensure that it\n     * can hold at least the number of elements specified by the minimum\n     * capacity argument. Does nothing if the current capacity is either\n     * {@code Integer.MAX_VALUE} or already greater than or equal to the minimum\n     * capacity argument.\n     *\n     * <p>The instance may grow as a result. Care has been take to make sure\n     * this list doesn't contain more than {@code Integer.MAX_VALUE} elements.\n     *\n     * <p>Note this should be the single place where the array is directly\n     * grown.  Other methods shouldn't grow the array directly and should\n     * invoke this method to do so.\n     *\n     * @param  minCapacity the desired minimum capacity\n     *\n     * @throws IllegalArgumentException if the specified minimal capacity\n     *                                  is negative.  This may be caused by\n     *                                  integer addition overflow, which means\n     *                                  we are trying to store more than\n     *                                  {@code Integer.MAX_VALUE} number of\n     *                                  elements, which is impossible to handle.\n     */", "    public void ensureCapacity(int minCapacity)\n        throws IllegalArgumentException\n    {\n        if (minCapacity < 0) {\n            throw new IllegalArgumentException(\n                \"Negative minCapacity is not allowed: \" + minCapacity +\n                \".  This might be caused by trying to store more than \" +\n                \"Integer.MAX_VALUE number of elements, \" +\n                \"which is impossible to handle.\");\n        }\n\n        final int oldCapacity = myData.length;\n\n        // Check if nothing to do.", "        if (oldCapacity >= minCapacity || oldCapacity == Integer.MAX_VALUE) {\n            return;\n        }\n\n        // Let's grow the array.  Note we may start with a 0 capacity,\n        // which is valid.  The growth factor is 1.5.\n        int newCapacity = oldCapacity == 0 ?\n            DEFAULT_INITIAL_CAPACITY : (oldCapacity * 3 / 2);\n\n        // Integer overflow from growing?  Use Integer.MAX_VALUE if so.\n        if (newCapacity <= 0) {\n            newCapacity = Integer.MAX_VALUE;\n        }\n\n        // In case of rounding problems when oldCapacity is 1.  Note when\n        // we get here, oldCapacity should be < Integer.MAX_VALUE, so we\n        // won't get integer overflow again by adding one.", "        if (newCapacity <= 0) {\n            newCapacity = Integer.MAX_VALUE;\n        }\n\n        // In case of rounding problems when oldCapacity is 1.  Note when\n        // we get here, oldCapacity should be < Integer.MAX_VALUE, so we\n        // won't get integer overflow again by adding one.\n        if (newCapacity <= oldCapacity) {\n            newCapacity = oldCapacity + 1;\n        }\n\n        // The minCapacity may be large.", "        if (newCapacity < minCapacity) {\n            newCapacity = minCapacity;\n        }\n\n        // Actually grow the array buffer while keeping the data.\n        myData = Arrays.copyOf(myData, newCapacity);\n    }\n\n    /**\n     * Get the size of the list.\n     *\n     * @return the size.\n     */", "    public int size()\n    {\n        return mySize;\n    }\n\n    /**\n     * Get the capacity of the list.\n     *\n     * @return the capacity.\n     */\n    public int capacity()\n    {\n        return myData.length;\n    }\n\n    /**\n     * Set the size of this list to be the given value.\n     *\n     * @param newSize  The new size of the list.\n     *\n     * @throws IllegalArgumentException if the given size was negative.\n     */", "    public int capacity()\n    {\n        return myData.length;\n    }\n\n    /**\n     * Set the size of this list to be the given value.\n     *\n     * @param newSize  The new size of the list.\n     *\n     * @throws IllegalArgumentException if the given size was negative.\n     */", "    public void setSize(final int newSize)\n        throws IllegalArgumentException\n    {\n        if (newSize < 0) {\n            throw new IllegalArgumentException(\"Negative size\");\n        }\n\n        // Make sure there is room and set it. This change will also invalidate\n        // the cached toString() value.\n        ensureCapacity(newSize);\n        mySize     = newSize;\n        myToString = null;\n    }\n\n    /**\n     * Get the element value at the given index.\n     *\n     * @param index  The index to get the byte from.\n     *\n     * @return the byte at the given index.\n     *\n     * @throws IndexOutOfBoundsException if, surprise, the given index was out\n     *                                   of bounds.\n     */", "    public byte get(final int index)\n        throws IndexOutOfBoundsException\n    {\n        if (index >= mySize) {\n            throw new IndexOutOfBoundsException(index);\n        }\n\n        // This will throw exception on negative index.\n        return myData[index];\n    }\n\n    /**\n     * Get the element value at the given index without checking against the\n     * list size.\n     *\n     * @param index  The index to get the byte from.\n     *\n     * @return the byte at the given index.\n     *\n     * @throws IndexOutOfBoundsException if the given index was out of the\n     *                                   bounds of the underlying array.\n     */", "    public byte getNoCheck(final int index)\n        throws IndexOutOfBoundsException\n    {\n        return myData[index];\n    }\n\n    /**\n     * Give back (a possible) copy of the data held by this class. Mutating the\n     * results of this method may result in undefined behaviour.\n     *\n     * @return the array of this list's contents.\n     */\n    public byte[] toArray()\n    {", "        if (mySize == 0) {\n            return EMPTY_ARRAY;\n        }\n        else if (myData.length == mySize) {\n            return myData;\n        }\n        else {\n            return Arrays.copyOf(myData, mySize);\n        }\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param element  The value to append.\n     *\n     * @return {@code true} always.\n     */", "    public boolean add(final byte element)\n    {\n        // Yes, this check is performed in ensureCapacity() but we short-circuit\n        // it here to avoid the overhead of the method call (it does make a\n        // difference!)\n        if (mySize >= myData.length) {\n            ensureCapacity(mySize + 1);\n        }\n\n        // Append the byte, which will also invalidate cached toString() value\n        myData[mySize++] = element;\n        myToString = null;\n\n        return true;\n    }\n\n    /**\n     * Appends all of the elements in the specified list to the end of this\n     * list.  The behavior of this operation is undefined if the specified\n     * list is modified while the operation is in progress.  (Note that\n     * this will occur if the specified list is this list, and it's\n     * nonempty.)\n     *\n     * @param list  The list containing elements to be added to this list\n     *\n     * @return {@code true} if this list changed as a result of the call\n     */", "    public boolean addAll(final ByteList list)\n    {\n        final int numNew = list.size();\n\n        // Check if nothing to do.\n        if (numNew == 0) {\n            return false;\n        }\n        else {\n            appendNoCheck(list.myData, 0, list.mySize);\n            return true;\n        }\n    }\n\n    /**\n     * Appends the elements of the {@code data} array argument to this list.\n     *\n     * <p>The elements of the array argument are appended, in order, to the\n     * contents of this list. The length of this list increases by the length of\n     * the argument.\n     *\n     * @param data  The data to be appended.\n     *\n     * @return a reference to this object.\n     */", "    public ByteList append(final byte[] data)\n    {\n        return appendNoCheck(data, 0, data.length);\n    }\n\n    /**\n     * Appends the elements of a subarray of the {@code data} array argument to\n     * this list.\n     *\n     * <p>Elements of the array {@code data}, starting at index {@code offset},\n     * are appended, in order, to the contents of this list. The length of this\n     * list increases by the value of {@code len}.\n     *\n     * @param  data   the data to be appended\n     * @param  offset the index of the first element to append\n     * @param  len    the number of elements to append\n     *\n     * @return a reference to this object\n     *\n     * @throws IndexOutOfBoundsException if {@code offset} is negative, or\n     *                                   {@code len} is negative, or\n     *                                   {@code offset + len} is larger than\n     *                                   {@code data.length}.\n     */", "    public ByteList append(final byte[] data,\n                           final int offset,\n                           final int len)\n        throws IndexOutOfBoundsException\n    {\n        if (offset < 0 || len < 0 || offset + len > data.length) {\n            throw new IndexOutOfBoundsException(\n                \"offset \" + offset + \", len \" + len + \", data.len \" +\n                data.length\n            );\n        }\n\n        return appendNoCheck(data, offset, len);\n    }\n\n    /**\n     * Remove all the entries from this list.\n     */", "    public void clear()\n    {\n        mySize     = 0;\n        myToString = null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        // Need to compute the cached value?", "    public String toString()\n    {\n        // Need to compute the cached value?\n        if (myToString == null) {\n            // We don't necessarily know the encoding of this ByteList, as\n            // someone might have subclassed it to understand UTF etc. As such,\n            // it's safest to go via a StringBuilder here, which will append on\n            // a per-char basis.\n            myToString = new StringBuilder(this).toString();\n        }\n        return myToString;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public CharSequence subSequence(int start, int end)\n    {\n        if (start < 0 || end < 0 || start > end || end > mySize) {\n            throw new IndexOutOfBoundsException(\n                \"start \" + start + \", end \" + end + \", size \" + mySize\n            );\n        }\n\n        final int len = end - start;\n\n        final ByteList list = new ByteList(len);\n\n        list.append(myData, start, len);\n\n        return list;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This is equivalent to size().\n     *\n     * @see #size()\n     */\n    @Override", "    public int length()\n    {\n        return size();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This is equivalent to get(int).\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @see    #get(int)\n     */\n    @Override", "    public char charAt(int index)\n    {\n        return (char) get(index);\n    }\n\n    /**\n     * Appends the elements of a subarray of the {@code data} array argument to\n     * this list without doing any boundary checking.\n     *\n     * <p>Elements of the array {@code data}, starting at index {@code offset},\n     * are appended, in order, to the contents of this list. The length of this\n     * list increases by the value of {@code len}.\n     *\n     * @param  data   the data to be appended\n     * @param  offset the index of the first element to append\n     * @param  len    the number of elements to append\n     *\n     * @return A reference to this object.\n     *\n     * @throws IndexOutOfBoundsException if {@code offset} is negative, or\n     *                                   {@code len} is negative, or\n     *                                   {@code offset + len} is larger than\n     *                                   {@code data.length}.\n     */\n    private ByteList appendNoCheck(final byte[] data,\n                                   final int offset,\n                                   final int len)\n    {\n        // You must make sure the following is NOT true before invoking this\n        // method:\n        //   offset < 0 || len < 0 || offset + len > data.length\n\n        // Check if nothing to do.", "        if (len == 0) {\n            return this;\n        }\n\n        // Ensure we have space, append the bytes, and update meta-data etc.\n        ensureCapacity(mySize + len);\n        System.arraycopy(data, offset, myData, mySize, len);\n        mySize += len;\n        myToString = null;\n\n        return this;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/Instrumentor.java", "chunked_list": ["package com.deshaw.util;\n\n/**\n * How we might instrument some code.\n */\npublic interface Instrumentor\n{\n    /**\n     * How we might create Instrumentor instances.\n     */\n    public static interface Factory\n    {\n        /**\n         * Get the unique instance for the given name.\n         *\n         * @param name  The name to get.\n         *\n         * @return the instance for the given name.\n         */", "    public static interface Factory\n    {\n        /**\n         * Get the unique instance for the given name.\n         *\n         * @param name  The name to get.\n         *\n         * @return the instance for the given name.\n         */\n        public Instrumentor getInstance(final String name);\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * The factory instance which users of this interface should be getting\n     * their implementations from.\n     *\n     * <p>This should likely only be set by the {@code main()} method in the\n     * controlling class for the application.\n     */", "        public Instrumentor getInstance(final String name);\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * The factory instance which users of this interface should be getting\n     * their implementations from.\n     *\n     * <p>This should likely only be set by the {@code main()} method in the\n     * controlling class for the application.\n     */", "    public static Factory INSTRUMENTOR_FACTORY =\n        new Factory() {\n            @Override public Instrumentor getInstance(final String name) {\n                return NULL_INSTRUMENTOR;\n            }\n        };\n\n    /**\n     * An {@link Instrumentor} instance which does nothing.\n     */\n    public static final Instrumentor NULL_INSTRUMENTOR =\n        new Instrumentor() {", "    public static final Instrumentor NULL_INSTRUMENTOR =\n        new Instrumentor() {\n            @Override public void setIntervalMod(int intervalMod) { }\n            @Override public long start() { return NULL_START; }\n            @Override public void end(long start) { }\n        };\n\n    /**\n     * The null value which {@link #start()} should return to indicate that end\n     * should not register the measurement.\n     */", "    public static final long NULL_START = -1L;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Set the sampling interval. This will typically determine whether\n     * {@link #start()} returns {@link #NULL_START} or not.\n     *\n     * @param intervalMod  The new mod to use.\n     */\n    public void setIntervalMod(int intervalMod);\n\n    /**\n     * Call to start a measurement.\n     *\n     * @return {@link #NULL_START} if no measurement should be made.\n     */", "    public void setIntervalMod(int intervalMod);\n\n    /**\n     * Call to start a measurement.\n     *\n     * @return {@link #NULL_START} if no measurement should be made.\n     */\n    public long start();\n\n    /**\n     * Call to finish a measurement.\n     *\n     * <p>Will do nothing if {@code start} is {@code NULL_START};\n     *\n     * @param start  The associated start value.\n     */", "    public void end(long start);\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/SwappingPool.java", "chunked_list": ["package com.deshaw.util;\n\n/**\n * A pool of objects which are available for reuse by various threads. (This\n * class is threadsafe.) The idea is that you take and get objects from the\n * pool instead of new()'ing them.\n *\n * <p>We also allow ourselves to move pools between threads as they fill or\n * empty. This has the advantage of not needing many locks but still allows us\n * to pool objects between threads. In the case of no threading this is still", " * empty. This has the advantage of not needing many locks but still allows us\n * to pool objects between threads. In the case of no threading this is still\n * very fast.\n */\npublic abstract class SwappingPool<T>\n    extends Pool<T>\n{\n    /**\n     * A simple stack.\n     */\n    private static class Stack<T>\n    {\n        /**\n         * The stack'd elements.\n         */\n        private final T myElements[];\n\n        /**\n         * The next free element's index. Zero means this stack is empty; if\n         * it equals myElements.length then it's full.\n         */\n        private volatile int myNextElement;\n\n        /**\n         * Constructor.\n         */\n        @SuppressWarnings(\"unchecked\")\n        public Stack(final int size)\n        {\n            myElements = (T[]) new Object[size];\n        }\n\n        /**\n         * Get an element, if any exists.\n         */", "        public T pop()\n        {\n            if (myNextElement > 0) {\n                T element = myElements[--myNextElement];\n                myElements[myNextElement] = null;\n                return element;\n            }\n            else {\n                return null;\n            }\n        }\n\n        /**\n         * Put an element on the stack; possibly failing it if the stack is\n         * full.\n         *\n         * @return success\n         */", "        public boolean push(T t)\n        {\n            if (myNextElement < myElements.length) {\n                myElements[myNextElement++] = t;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n\n        /**\n         * Is this stack empty?\n         */", "        public boolean isEmpty()\n        {\n            return myNextElement == 0;\n        }\n\n        /**\n         * Is this stack full?\n         */\n        public boolean isFull()\n        {\n            return myNextElement == myElements.length;\n        }\n\n        /**\n         * How much room.\n         */", "        public boolean isFull()\n        {\n            return myNextElement == myElements.length;\n        }\n\n        /**\n         * How much room.\n         */\n        public int capacity()\n        {\n            return myElements.length;\n        }\n\n        /**\n         * How many elements.\n         */", "        public int capacity()\n        {\n            return myElements.length;\n        }\n\n        /**\n         * How many elements.\n         */\n        public int size()\n        {\n            return myNextElement;\n        }\n    }\n\n    /**\n     * The shared pool of elements.\n     */\n    private volatile Stack<T> mySharedStack;\n\n    /**\n     * The local pool of elements.\n     */\n    private final ThreadLocal<Stack<T>> myStack;\n\n    /**\n     * Constructor.\n     */\n    public SwappingPool(final int size)\n    {\n        this(size, 0);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SwappingPool(final int size, final int numPreallocate)\n    {", "        public int size()\n        {\n            return myNextElement;\n        }\n    }\n\n    /**\n     * The shared pool of elements.\n     */\n    private volatile Stack<T> mySharedStack;\n\n    /**\n     * The local pool of elements.\n     */\n    private final ThreadLocal<Stack<T>> myStack;\n\n    /**\n     * Constructor.\n     */\n    public SwappingPool(final int size)\n    {\n        this(size, 0);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SwappingPool(final int size, final int numPreallocate)\n    {", "        if (size < 1) {\n            throw new IllegalArgumentException(\n                \"Pool size must be greater than zero, not \" + size\n            );\n        }\n\n        // Use a capped value\n        final long prealloc = Math.min(size, numPreallocate);\n\n        // Build\n        mySharedStack = new Stack<>(size);", "        for (int i=0; i < prealloc; i++) {\n            mySharedStack.push(newInstance());\n        }\n\n        myStack =\n            new ThreadLocal<Stack<T>>()\n            {\n                @Override\n                protected Stack<T> initialValue()\n                {\n                    final Stack<T> stack = new Stack<>(size);", "                    for (int i=0; i < prealloc; i++) {\n                        stack.push(newInstance());\n                    }\n                    return stack;\n                }\n            };\n    }\n\n    /**\n     * The max size of the pool.  Really, this is the capacity of the\n     * shared stack plus the capacity of our thread-local pool, ignoring\n     * all other thread-local pools.\n     */", "    public int capacity()\n    {\n        // One could argue that we should use\n        //   mySharedStack.capacity() + myStack.get().capacity()\n        // but, since all stacks have the same capacity, this should still\n        // return the same value, but a little bit faster. Be careful to handle\n        // overflow here (unlikely but...).\n        final int capacity = (mySharedStack.capacity() << 1);\n        return (capacity < 0) ? Integer.MAX_VALUE : capacity;\n    }\n\n    /**\n     * The current number of elements in the pool.\n     *\n     * <p>Really, this returns the number of shared elements plus the number of\n     * elements in our thread-local pool, ignoring all other thread-local pools.\n     */", "    public int size()\n    {\n        // Watch out for overflow (unlikely but...)\n        final int size = mySharedStack.size() + myStack.get().size();\n        return (size < 0) ? Integer.MAX_VALUE : size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public T getInstance()\n    {\n        // See if the local pool has any elements, if not then grab a load\n        // from the shared pool\n        Stack<T> local = myStack.get();\n        T result = local.pop();\n        if (result == null && !mySharedStack.isEmpty()) {\n            // Swap this pool with the shared one in the hope that it still\n            // has enough elements to satisfy us (note that the call to\n            // isEmpty() is optimistically done outside the lock)\n            synchronized (this) {\n                Stack<T> tmp = mySharedStack;\n                mySharedStack = local;\n                local = tmp;\n                myStack.set(local);\n            }\n\n            // Try again\n            result = local.pop();\n        }\n\n        // Attempt to grab an element from the local pool, if it has anything\n        // in it", "        if (result == null) {\n            // We failed to get an element, so we construct a new one and give\n            // it back\n            result = newInstance();\n        }\n\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean releaseInstance(T t)\n    {\n        // Ignore NOPs\n        if (t == null) {\n            return false;\n        }\n\n        // Tell the object to clean itself up now, so that if it's\n        // holding any references to objects that can be garbage-collected,\n        // the garbage collector gets a chance reclaim those objects\n        // before they get moved to the old generation.\n        prepareForReuse(t);\n\n        // Attempt to return this element to the local pool\n        Stack<T> local = myStack.get();", "        if (local.push(t)) {\n            return true;\n        }\n        else if (!mySharedStack.isFull()) {\n            // Swap the stacks around in the hope that the shared one still\n            // has room (note that the call to isFull() is optimistically done\n            // outside the lock)\n            synchronized (this) {\n                Stack<T> tmp = mySharedStack;\n                mySharedStack = local;\n                local = tmp;\n                myStack.set(local);\n            }\n\n            // Try again", "            if (local.push(t)) {\n                return true;\n            }\n        }\n\n        // Must have failed to return it\n        return false;\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/Pool.java", "chunked_list": ["package com.deshaw.util;\n\n/**\n * A pool of objects which are available for reuse by various threads.\n */\npublic abstract class Pool<T>\n{\n    /**\n     * Get an instance of the element from the pool.\n     *\n     * @return the new element, or the result of newInstance() if none existed in\n     *         the pool.\n     */", "    public abstract T getInstance();\n\n    /**\n     * Give an element back to the pool.\n     *\n     * @param t  The instance to release.\n     *\n     * @return whether the element was accepted back into the pool.\n     */\n    public abstract boolean releaseInstance(T t);\n\n    /**\n     * Create a new instance of a {@code T}.\n     *\n     * @return the new instance.\n     */\n    protected abstract T newInstance();\n\n    /**\n     * Prepare a {@code T} instance for reuse, making it like new.\n     *\n     * @param t  The instance to reuse.\n     */\n    protected abstract void prepareForReuse(T t);\n}\n", "    public abstract boolean releaseInstance(T t);\n\n    /**\n     * Create a new instance of a {@code T}.\n     *\n     * @return the new instance.\n     */\n    protected abstract T newInstance();\n\n    /**\n     * Prepare a {@code T} instance for reuse, making it like new.\n     *\n     * @param t  The instance to reuse.\n     */\n    protected abstract void prepareForReuse(T t);\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/ThreadLocalStringBuilder.java", "chunked_list": ["package com.deshaw.util;\n\n/**\n * Provides thread local {@link StringBuilder}s.\n */\npublic class ThreadLocalStringBuilder\n    extends ThreadLocal<StringBuilder>\n{\n    /**\n     * The initial size for the {@link StringBuilder} buffer.\n     */\n    private final int mySize;\n\n    /**\n     * CTOR\n     *\n     * @param size The initial size for the created\n     *             {@link StringBuilder}'s buffer.\n     */\n    public ThreadLocalStringBuilder(int size)\n    {\n        mySize = size;\n    }\n\n    /**\n     * Returns an empty thread local {@link StringBuilder}.\n     */\n    @Override", "    public StringBuilder get()\n    {\n        StringBuilder sb = super.get();\n        sb.setLength(0);\n        return sb;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected StringBuilder initialValue()\n    {\n        return new StringBuilder(mySize);\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/StringUtil.java", "chunked_list": ["package com.deshaw.util;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.RandomAccessFile;\nimport java.io.StringWriter;\n\nimport java.nio.ByteBuffer;", "\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\n\nimport java.text.ParseException;\n\nimport java.util.ArrayList;\nimport java.util.Collection;", "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**", "\n/**\n * Provides utility methods to deal with {@link String}s and\n * {@link CharSequence}s.\n */\npublic class StringUtil\n{\n    /**\n     * {@link CharSequence} that is based on a segment of another\n     * sequence.\n     *\n     * <p>This class is written such that it should specifically match\n     * {@code hashCode()} and {@code equals()} for Strings, per their API. Thus\n     * allowing us to use it in Maps etc.\n     *\n     * @see String#hashCode\n     */", "    public static class HashableSubSequence\n        implements CharSequence\n    {\n        /**\n         * What we wrap.\n         */\n        private CharSequence mySequence;\n\n        /**\n         * Starting offset of this segment in the underlying sequence;\n         */\n        private int myStart;\n\n        /**\n         * Length of the (sub-)sequence.\n         */\n        private int myLength;\n\n        /**\n         * Default constructor.\n         */\n        public HashableSubSequence()\n        {\n            this(null, 0, 0);\n        }\n\n        /**\n         * Initializing constructor.\n         */\n        public HashableSubSequence(CharSequence seq)\n        {\n            wrap(seq, 0, seq.length());\n        }\n\n        /**\n         * Initializing constructor.\n         */\n        public HashableSubSequence(CharSequence seq, int start, int length)\n        {\n            wrap(seq, start, length);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int length()\n        {\n            return myLength;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public char charAt(int index)\n        {", "        public char charAt(int index)\n        {\n            if (index < 0 || index >= myLength) {\n                throw new IndexOutOfBoundsException(\n                    \"Asked for index \" + index + \", length \" + myLength\n                );\n            }\n            return mySequence.charAt(myStart + index);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public CharSequence subSequence(int start, int end)\n        {\n            return new HashableSubSequence(\n                mySequence,\n                start + myStart,\n                Math.min(end - start, myLength - start)\n            );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int hashCode()\n        {\n            // Should match String.hashCode()'s API definition\n            int result = 0;\n            for (int i = myStart, end = myStart + myLength; i < end; i++) {\n                result = 31*result + mySequence.charAt(i);\n            }\n            return result;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean equals(Object o)\n        {\n            // Null never equals\n            if (o == null) {\n                return false;\n            }\n\n            // Ignore the wrong types\n            if (!CharSequence.class.isAssignableFrom(o.getClass())) {\n                return false;\n            }\n            CharSequence that = (CharSequence)o;\n\n            // Check for me (unlikely)", "            if (!CharSequence.class.isAssignableFrom(o.getClass())) {\n                return false;\n            }\n            CharSequence that = (CharSequence)o;\n\n            // Check for me (unlikely)\n            if (that == this) {\n                return true;\n            }\n\n            // Different length means different string", "            if (that.length() != myLength) {\n                return false;\n            }\n\n            // Compare all the bytes\n            for (int i=0; i < myLength; i++) {\n                if (that.charAt(i) != charAt(i)) {\n                    return false;\n                }\n            }\n\n            // Must have matched\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String toString()\n        {\n            if (myLength == 0) {\n                return \"\";\n            }\n            else {\n                // We need this condition because our own subSequence()\n                // will actually create another HashableSubSequence instance\n                // which would result in an infinite recursion.\n                CharSequence seq = mySequence;\n                while (seq instanceof HashableSubSequence) {\n                    seq = ((HashableSubSequence) seq).mySequence;\n                }\n\n                return seq.subSequence(myStart, myStart + myLength).toString();\n            }\n        }\n\n        /**\n         * Fully wrap a CharSequence.\n         *\n         * <p>This will hold a reference to the given {@link CharSequence}.\n         *\n         * @return This instance.\n         */", "                while (seq instanceof HashableSubSequence) {\n                    seq = ((HashableSubSequence) seq).mySequence;\n                }\n\n                return seq.subSequence(myStart, myStart + myLength).toString();\n            }\n        }\n\n        /**\n         * Fully wrap a CharSequence.\n         *\n         * <p>This will hold a reference to the given {@link CharSequence}.\n         *\n         * @return This instance.\n         */", "        public HashableSubSequence wrap(CharSequence seq)\n        {\n            // A simple hand-off in both cases. If the sequence is null than we\n            // have to deal with that with default values for start and length\n            // which will be ignored anyhow.\n            return (seq == null) ? wrap(seq, 0, 0)\n                                 : wrap(seq, 0, seq.length());\n        }\n\n        /**\n         * Assign the segment to a portion of {@code seq}.\n         *\n         * <p>This will hold a reference to the given {@link CharSequence}.\n         *\n         * @return This instance.\n         *\n         * @throws IndexOutOfBoundsException If {@code start} or {@code length}\n         *                                   parameters were invalid in some\n         *                                   way (negative, out of bounds,\n         *                                   etc.).\n         */", "        public HashableSubSequence wrap(CharSequence seq, int start, int length)\n        {\n            // Handle wrapping nothing\n            if (seq == null) {\n                mySequence = null;\n                myStart    = 0;\n                myLength   = 0;\n                return this;\n            }\n\n            // Sanity check inputs", "            if (start < 0 || (seq.length() > 0 && start >= seq.length()) ||\n                length < 0 || start + length > seq.length())\n            {\n                throw new IndexOutOfBoundsException(\n                    \"start or length are out of bounds: \" +\n                    \"start=\" + start + \", \" +\n                    \"length=\" + length + \", \" +\n                    \"input array length=\" + seq.length()\n                );\n            }\n            mySequence = seq;\n            myStart    = start;\n            myLength   = length;\n\n            return this;\n        }\n    }\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * A thread-local instance of a StringBuilder class for use by this class\n     * only.\n     */\n    private static final ThreadLocalStringBuilder ourStringBuilder =\n        new ThreadLocalStringBuilder(1024);\n\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Convert stack trace from a {@link Throwable} to a string.\n     */", "    public static String stackTraceToString(Throwable e)\n    {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        e.printStackTrace(pw);\n        return sw.toString();\n    }\n\n    /**\n     * Append the hex representation of a byte to a {@link StringBuilder}.\n     */", "    public static StringBuilder appendHexByte(StringBuilder app, byte b)\n    {\n        app.append(HEX_DIGITS[(b & 0xf0) >>> 4]);\n        app.append(HEX_DIGITS[(b & 0x0f) >>> 0]);\n        return app;\n    }\n    /** For use by appendHexByte */\n    private static final char[] HEX_DIGITS = { '0','1','2','3','4','5','6','7',\n                                               '8','9','A','B','C','D','E','F' };\n\n    /**\n     * Returns true if the two CharSequence instances are identical.\n     */", "    public static boolean equals(CharSequence a, CharSequence b)\n    {\n        if (a == b) {\n            // If they're the same object, then they're identical.\n            return true;\n        }\n        else if (a == null || b == null) {\n            // One is null and one is non-null, so they can't be identical.\n            // Note that if we get here, they can't both be null since then\n            // we would have fallen into the first block of the if..else\n            // above.\n            return false;\n        }", "        else if (a.length() != b.length()) {\n            // Different lengths implies not identical.\n            return false;\n        }\n        else {\n            // Check that the individual characters match up. We do this\n            // backwards since, more likely than not, a prefix might match.\n            // Probably...\n            for (int i = a.length() - 1; i >= 0; i--) {\n                if (a.charAt(i) != b.charAt(i)) {\n                    // Characters at this index don't match.\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    /**\n     * Returns true if the two CharSequence instances are identical, ignoring\n     * case.\n     */", "            for (int i = a.length() - 1; i >= 0; i--) {\n                if (a.charAt(i) != b.charAt(i)) {\n                    // Characters at this index don't match.\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    /**\n     * Returns true if the two CharSequence instances are identical, ignoring\n     * case.\n     */", "    public static boolean equalsIgnoreCase(CharSequence a, CharSequence b)\n    {\n        if (a == b) {\n            // If they're the same object, then they're identical.\n            return true;\n        }\n        else if (a == null || b == null) {\n            // One is null and one is non-null, so they can't be identical.\n            // Note that if we get here, they can't both be null since then\n            // we would have fallen into the first block of the if..else\n            // above.\n            return false;\n        }", "        else if (a.length() != b.length()) {\n            // Different lengths => not identical.\n            return false;\n        }\n        else {\n            // Check that the individual characters match up. We do this\n            // backwards since, more likely than not, a prefix might match.\n            // Probably...\n            for (int i = a.length() - 1; i >= 0; i--) {\n                if (Character.toLowerCase(a.charAt(i)) !=\n                    Character.toLowerCase(b.charAt(i)))\n                {\n                    // Characters at this index don't match.\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    /**\n     * Parses the given string into a boolean value, ignoring case, and throws\n     * an exception if the string does not describe a boolean value.\n     */", "            for (int i = a.length() - 1; i >= 0; i--) {\n                if (Character.toLowerCase(a.charAt(i)) !=\n                    Character.toLowerCase(b.charAt(i)))\n                {\n                    // Characters at this index don't match.\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    /**\n     * Parses the given string into a boolean value, ignoring case, and throws\n     * an exception if the string does not describe a boolean value.\n     */", "    public static boolean parseBoolean(CharSequence s)\n        throws ParseException\n    {\n        if (equalsIgnoreCase(\"true\", s)) {\n            return true;\n        }\n        else if (equalsIgnoreCase(\"false\", s)) {\n            return false;\n        }\n        else {\n            throw new ParseException(\n                \"'\" + s + \"' does not describe a boolean value\", 0\n            );\n        }\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/concurrent/VirtualThreadLock.java", "chunked_list": ["package com.deshaw.util.concurrent;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * A reentrant lock whose notion of which thread holds it corresponds to a\n * virtual thread.", " * A reentrant lock whose notion of which thread holds it corresponds to a\n * virtual thread.\n *\n * <p>The idea is that, one may have multiple threads all comprising a single\n * \"virtual\" thread. If one of these threads has acquired the lock then another\n * thread, which is part of the same virtual thread, may also acquire it. A\n * thread which is not a part of that virtual thread, may not. This mirrors what\n * a ReentrantLock does in a regular thread.\n */\npublic class VirtualThreadLock\n    implements Lock\n{\n    /**\n     * A virtual thread.\n     */", " */\npublic class VirtualThreadLock\n    implements Lock\n{\n    /**\n     * A virtual thread.\n     */\n    public static final class VirtualThread\n        extends Thread\n    {\n        /**\n         * The thread's toString representation.\n         */\n        private final String myString;\n\n        /**\n         * Constructor.\n         */\n        public VirtualThread(final String name)\n        {\n            super(name);\n            myString = \"VirtualThread[\" + name + \"]\";\n        }\n\n        /**\n         * We don't support actually running...\n         */\n        @Override", "        public void run()\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return myString;\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * How this thread determines what its virtual thread is\n     */\n    private static final ThreadLocal<VirtualThread> ourVirtualThread =\n        new ThreadLocal<VirtualThread>() {", "        public String toString()\n        {\n            return myString;\n        }\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * How this thread determines what its virtual thread is\n     */\n    private static final ThreadLocal<VirtualThread> ourVirtualThread =\n        new ThreadLocal<VirtualThread>() {", "            @Override public VirtualThread initialValue() { return null; }\n        };\n\n    /**\n     * The lock we use to protect myCount and myHolder (as well as for\n     * signalling).\n     */\n    private final Lock myLock = new ReentrantLock();\n\n    /**\n     * The condition on which we can signal that the virtual lock may attempt to\n     * be acquired.\n     */\n    private final Condition myCondition = myLock.newCondition();\n\n    /**\n     * How many holders there are of this lock.\n     */\n    private int myCount = 0;\n\n    /**\n     * The thread which is holding the lock.\n     */\n    private VirtualThread myHolder = null;\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Set the \"virtual thread\" for this thread.\n     * <p>\n     * If the given thread was null then this will unset any association. You\n     * must explicitly remove <i>any</i> existing association (even if you are\n     * trying to associate with the same VirtualThread) before creating a new\n     * one; this is to guard against errors.\n     *\n     * @throws IllegalArgumentException if there was already an associated\n     *                                  thread.\n     */", "    public static void setThread(final VirtualThread thread)\n        throws IllegalArgumentException\n    {\n        // Ensure we are not overwriting\n        if (thread != null && ourVirtualThread.get() != null) {\n            throw new IllegalArgumentException(\n                \"Thread \" + Thread.currentThread() + \" \" +\n                \"tried to associate with \" + thread + \" \" +\n                \"but is already associated with \" + ourVirtualThread.get()\n            );\n        }\n\n        // Okay to set\n        ourVirtualThread.set(thread);\n    }\n\n    /**\n     * Get the \"virtual thread\" for this thread.\n     *\n     * @throws IllegalArgumentException if there is no associated thread.\n     */", "    public static VirtualThread getThread()\n        throws IllegalArgumentException\n    {\n        final VirtualThread thread = ourVirtualThread.get();\n        if (thread == null) {\n            throw new IllegalArgumentException(\n                \"No virtual thread associated with \" + Thread.currentThread()\n            );\n        }\n        return thread;\n    }\n\n    // ----------------------------------------------------------------------\n\n    /**\n     * Our name, if any.\n     */\n    private final String myName;\n\n    /**\n     * Default constructor.\n     */\n    public VirtualThreadLock()\n    {\n        this(null);\n    }\n\n    /**\n     * Constructor with a name.\n     */\n    public VirtualThreadLock(final String name)\n    {\n        myName = name;\n    }\n\n    /**\n     * Get our name, if any (may be null).\n     */", "    public String getName()\n    {\n        return myName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void lock()\n    {\n        final VirtualThread thread = getThread();\n        myLock.lock();", "    public void lock()\n    {\n        final VirtualThread thread = getThread();\n        myLock.lock();\n        try {\n            while (true) {\n                // Different states of the world:\n                if (myCount == 0) {\n                    // We are the first to acquire the lock; remember our\n                    // virtual thread and up the count and we're done\n                    myCount++;\n                    myHolder = thread;\n                    return;\n                }", "                else if (myHolder == thread) {\n                    // We're not the first but we have the right virtual thread\n                    // so just up the count\n                    myCount++;\n                    return;\n                }\n                else {\n                    // This lock is being held by another virtual thread; wait\n                    // for it to be released\n                    try {\n                        myCondition.await();\n                    }\n                    catch (InterruptedException e) {\n                        // Nothing, just go around and try again\n                    }\n                }\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "                    try {\n                        myCondition.await();\n                    }\n                    catch (InterruptedException e) {\n                        // Nothing, just go around and try again\n                    }\n                }\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void lockInterruptibly()\n        throws InterruptedException\n    {\n        final VirtualThread thread = getThread();\n        myLock.lock();\n        try {\n            while (true) {\n                // Different states of the world:\n                if (myCount == 0) {\n                    // We are the first to acquire the lock; remember our\n                    // virtual thread and up the count and we're done\n                    myCount++;\n                    myHolder = thread;\n                    return;\n                }", "                if (myCount == 0) {\n                    // We are the first to acquire the lock; remember our\n                    // virtual thread and up the count and we're done\n                    myCount++;\n                    myHolder = thread;\n                    return;\n                }\n                else if (myHolder == thread) {\n                    // We're not the first but we have the right virtual thread\n                    // so just up the count\n                    myCount++;\n                    return;\n                }\n                else {\n                    // This lock is being held by another virtual thread; wait\n                    // for it to be released\n                    myCondition.await();\n                }\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean tryLock()\n    {\n        final VirtualThread thread = getThread();\n        myLock.lock();\n        try {\n            while (true) {\n                // Different states of the world:\n                if (myCount == 0) {\n                    // We are the first to acquire the lock; remember our\n                    // virtual thread and up the count and we're done\n                    myCount++;\n                    myHolder = thread;\n                    return true;\n                }", "                else if (myHolder == thread) {\n                    // We're not the first but we have the right virtual thread\n                    // so just up the count\n                    myCount++;\n                    return true;\n                }\n                else {\n                    // This lock is being held by another virtual thread, failed to lock\n                    return false;\n                }\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public boolean tryLock(long time, TimeUnit unit)\n        throws InterruptedException\n    {\n        // Bail after this amount of time\n        final long startNs   = System.nanoTime();\n        final long timeoutNs = unit.toNanos(time);\n\n        final VirtualThread thread = getThread();\n        myLock.lock();\n        try {\n            do {\n                // Different states of the world:", "        try {\n            do {\n                // Different states of the world:\n                if (myCount == 0) {\n                    // We are the first to acquire the lock; remember our\n                    // virtual thread and up the count and we're done\n                    myCount++;\n                    myHolder = thread;\n                    return true;\n                }\n                else if (myHolder == thread) {\n                    // We're not the first but we have the right virtual thread\n                    // so just up the count\n                    myCount++;\n                    return true;\n                }\n                else {\n                    // This lock is being held by another virtual thread; wait\n                    // for it to be released", "                else if (myHolder == thread) {\n                    // We're not the first but we have the right virtual thread\n                    // so just up the count\n                    myCount++;\n                    return true;\n                }\n                else {\n                    // This lock is being held by another virtual thread; wait\n                    // for it to be released\n                    try {\n                        myCondition.awaitNanos(timeoutNs - (System.nanoTime() - startNs));\n                    }\n                    catch (InterruptedException e) {\n                        // Nothing, just go around and try again, provided that\n                        // we're under the timeout\n                    }\n                }", "                    try {\n                        myCondition.awaitNanos(timeoutNs - (System.nanoTime() - startNs));\n                    }\n                    catch (InterruptedException e) {\n                        // Nothing, just go around and try again, provided that\n                        // we're under the timeout\n                    }\n                }\n            } while (System.nanoTime() - startNs < timeoutNs);\n        }\n        finally {\n            myLock.unlock();\n        }\n\n        // If we got here we failed to lock\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "            } while (System.nanoTime() - startNs < timeoutNs);\n        }\n        finally {\n            myLock.unlock();\n        }\n\n        // If we got here we failed to lock\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public void unlock()\n        throws IllegalMonitorStateException\n    {\n        final VirtualThread thread = getThread();\n        myLock.lock();\n        try {\n            // Different states of the world:\n            if (myCount == 0) {\n                // This lock isn't held by anyone\n                throw new IllegalMonitorStateException(\"Lock is not held\");\n            }", "            else if (myHolder != thread) {\n                // This lock isn't held by us\n                throw new IllegalMonitorStateException(\n                    \"Lock is held by \" + myHolder + \", not by \" + thread\n                );\n            }\n            else {\n                // We were the holder so we drop it\n                if (--myCount == 0) {\n                    // We were the last holder\n                    myHolder = null;\n                }\n\n                // Tell everyone that the lock has been released; they will have\n                // to figure out who is actually trying to acquire it\n                myCondition.signalAll();\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>Not supported (yet).\n     *\n     * @throws UnsupportedOperationException always.\n     */\n    @Override", "                if (--myCount == 0) {\n                    // We were the last holder\n                    myHolder = null;\n                }\n\n                // Tell everyone that the lock has been released; they will have\n                // to figure out who is actually trying to acquire it\n                myCondition.signalAll();\n            }\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>Not supported (yet).\n     *\n     * @throws UnsupportedOperationException always.\n     */\n    @Override", "    public Condition newCondition()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Get the number of holds on this lock by the current virtual thread (if\n     * any).\n     */\n    public int getHoldCount()\n    {\n        myLock.lock();", "    public int getHoldCount()\n    {\n        myLock.lock();\n        try {\n            return (myHolder == getThread()) ? myCount : 0;\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * Return whether the lock is held by the current virtual thread.\n     */", "    public boolean isHeldByCurrentThread()\n    {\n        myLock.lock();\n        try {\n            return (myHolder == getThread());\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * Return whether the lock is held by any virtual thread.\n     */", "    public boolean isLocked()\n    {\n        myLock.lock();\n        try {\n            return (myCount > 0);\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * Returns the virtual thread that currently owns this lock (if any).\n     */", "    public VirtualThread getOwner()\n    {\n        myLock.lock();\n        try {\n            return myHolder;\n        }\n        finally {\n            myLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override", "    public String toString()\n    {\n        VirtualThread o = getOwner();\n        return ((myName == null) ? super.toString() : myName) +\n               ((o == null) ?\n                \"[Unlocked]\" :\n                \"[Locked by thread \" + o + \"]\");\n    }\n}\n"]}
{"filename": "java/src/main/java/com/deshaw/util/concurrent/LockManager.java", "chunked_list": ["package com.deshaw.util.concurrent;\n\nimport com.deshaw.util.Instrumentor;\nimport com.deshaw.util.Pool;\nimport com.deshaw.util.StringUtil;\nimport com.deshaw.util.SwappingPool;\nimport com.deshaw.util.ThreadLocalStringBuilder;\n\nimport java.util.ArrayList;\nimport java.util.Collections;", "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;", "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Predicate;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n", "import java.util.stream.Collectors;\n\nimport static com.deshaw.util.Instrumentor.INSTRUMENTOR_FACTORY;\n\n// There are some alternative approaches to using this LockManager class which I\n// will outline here. They all have their trade-offs.\n//\n//  o Spawn a watcher thread to periodically call the findDeadlockedThreads in\n//    java.lang.management.ThreadMXBean (accessed via the\n//    java.lang.management.ManagementFactory.getThreadMXBean() method) and deal", "//    java.lang.management.ThreadMXBean (accessed via the\n//    java.lang.management.ManagementFactory.getThreadMXBean() method) and deal\n//    with any deadlocks which it finds. (Unclear how though.)\n//\n//  o Rather than using Lock.lock() we can always use tryLock(long,TimeUnit)\n//    with a long timeout and assume that its failure implies a deadlock. (This\n//    might not actually be the case however.)\n//\n// The below LockManager implementation is pretty good but it still employs a\n// global lock in certain circumstances. Making this lock-free would be good but", "// The below LockManager implementation is pretty good but it still employs a\n// global lock in certain circumstances. Making this lock-free would be good but\n// is non-trivial.\n\n/**\n * A lock manager for reentrant locks. This provides basic locking primitives\n * and deadlock detection. All the locks which this class provides are\n * referenced by {@link CharSequence} handles. If you wish to avoid garbage\n * creation then you should use one of {@link StringUtil}'s hash-friendly\n * {@link CharSequence} implementations for these handles.", " * creation then you should use one of {@link StringUtil}'s hash-friendly\n * {@link CharSequence} implementations for these handles.\n *\n * <p>This class manages deadlock detection since it's possible for external\n * threads to acquire locks in ways which would cause them to hang forever. As\n * such it is important that _all_ locking is done via this class's methods.\n *\n * <p>Currently, if many short-lived threads interact with this class, it's\n * possible to exhaust the JVM's heap.\n */\npublic class LockManager\n{\n    /**\n     * Our default logger.\n     */\n    private static final Logger LOG =\n        Logger.getLogger(\"com.deshaw.util.concurrent.LockManager\");\n\n    /**\n     * Thrown when we encounter a deadlock when trying to acquire a lock.\n     * <p>\n     * This is a RuntimeException since it may be thrown from Lock#lock() which\n     * only throws RuntimeExceptions.\n     */", " * possible to exhaust the JVM's heap.\n */\npublic class LockManager\n{\n    /**\n     * Our default logger.\n     */\n    private static final Logger LOG =\n        Logger.getLogger(\"com.deshaw.util.concurrent.LockManager\");\n\n    /**\n     * Thrown when we encounter a deadlock when trying to acquire a lock.\n     * <p>\n     * This is a RuntimeException since it may be thrown from Lock#lock() which\n     * only throws RuntimeExceptions.\n     */", "    public static class DeadlockException\n        extends RuntimeException\n    {\n        /**\n         * CTOR.\n         *\n         * @param message  The exception message.\n         */\n        public DeadlockException(final String message)\n        {\n            super(message);\n        }\n    }\n\n    /**\n     * A Lock shim over a NamedLock instance. This will perform its various\n     * operations via the LockManager so should be safe from deadlock.\n     *\n     * <p>These locks may be used in an {@link AutoCloseable} try-with-resources\n     * context:<pre>\n     *    try (SafeLock l = lock.acquire()) {\n     *       // Do things under the lock\n     *       ...\n     *    }\n     * </pre>\n     */", "    public class SafeLock\n        implements AutoCloseable,\n                   Lock\n    {\n        /**\n         * The exception thrown when {@code tryAcquire()} fails.\n         */\n        public class AcquireFailedException\n            extends Exception\n        {\n            /**\n             * CTOR.\n             */\n            private AcquireFailedException()\n            {\n                super(\"Failed to get lock for \" + myLock.getName());\n            }\n        }\n\n        /**\n         * What we're wrapped around.\n         */\n        private final LockManagerLock myLock;\n\n        /**\n         * Whether the lock is exclusive or not.\n         */\n        private final boolean myExclusive;\n\n        /**\n         * CTOR.\n         */\n        private SafeLock(final LockManagerLock lock, final boolean isExclusive)\n        {\n            myLock      = lock;\n            myExclusive = isExclusive;\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws DeadlockException if acquiring the lock would result in deadlock.\n         */\n        @Override", "        public void lock()\n        {\n            LockManager.this.lock(myLock, myExclusive);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * <b>Not supported.</b>\n         */\n        @Override", "        public void lockInterruptibly()\n            throws InterruptedException\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean tryLock()\n        {\n            return LockManager.this.tryLock(myLock, myExclusive);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean tryLock()\n        {\n            return LockManager.this.tryLock(myLock, myExclusive);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean tryLock(long time, TimeUnit unit)\n            throws InterruptedException\n        {\n            return LockManager.this.tryLock(myLock, myExclusive, time, unit);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws IllegalMonitorStateException If the current thread does not hold\n         *                                      this lock.\n         */\n        @Override", "        public boolean tryLock(long time, TimeUnit unit)\n            throws InterruptedException\n        {\n            return LockManager.this.tryLock(myLock, myExclusive, time, unit);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws IllegalMonitorStateException If the current thread does not hold\n         *                                      this lock.\n         */\n        @Override", "        public void unlock()\n        {\n            LockManager.this.unlock(myLock, myExclusive);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Condition newCondition()\n        {\n            return myLock.newCondition(myExclusive);\n        }\n\n        /**\n         * A synonym for {@link #lock()} which returns the instance back. This\n         * is intended for use in an {@link AutoCloseable} try-with-resources\n         * context.\n         *\n         * @return the safe-lock which was acquired.\n         *\n         * @throws DeadlockException if acquiring the lock would result in deadlock.\n         */", "        public Condition newCondition()\n        {\n            return myLock.newCondition(myExclusive);\n        }\n\n        /**\n         * A synonym for {@link #lock()} which returns the instance back. This\n         * is intended for use in an {@link AutoCloseable} try-with-resources\n         * context.\n         *\n         * @return the safe-lock which was acquired.\n         *\n         * @throws DeadlockException if acquiring the lock would result in deadlock.\n         */", "        public SafeLock acquire()\n        {\n            LockManager.this.lock(myLock, myExclusive);\n            return this;\n        }\n\n        /**\n         * A synonym for {@link #tryLock()} which returns the instance back.\n         * This is intended for use in an {@link AutoCloseable}\n         * try-with-resources context:\n         * <pre>\n         *     try (SafeLock l = lock.tryAcquire()) {\n         *         do things...\n         *     }\n         *     catch (AcquireFailedException e) {\n         *         do other things...\n         *     }\n         * </pre>\n         * We could return {@code null} upon failure here but that would mean\n         * that, unless the user explicitly checks the value of {@code l} is not\n         * {@code null} then they might assume that they got the lock. This\n         * method, instead, provides a simple equivalent to the {@code if...else}\n         * idiom of the sibling {@code tryLock()} method.\n         *\n         * @return the safe-lock which was acquired.\n         *\n         * @throws AcquireFailedException if the lock wasn't acquired.\n         */", "        public SafeLock tryAcquire()\n            throws AcquireFailedException\n        {\n            if (LockManager.this.tryLock(myLock, myExclusive)) {\n                return this;\n            }\n            else {\n                throw new AcquireFailedException();\n            }\n        }\n\n        /**\n         * A synonym for {@link #tryLock(long,TimeUnit)} which returns the\n         * instance back. This is intended for use in an {@link AutoCloseable}\n         * try-with-resources context:\n         * <pre>\n         *     try (SafeLock l = lock.tryAcquire(1, TimeUnit.SECONDS)) {\n         *         do things...\n         *     }\n         *     catch (AcquireFailedException | InterruptedException e) {\n         *         do other things...\n         *     }\n         * </pre>\n         * We could return {@code null} upon failure here but that would mean\n         * that, unless the user explicitly checks the value of {@code l} is not\n         * {@code null} then they might assume that they got the lock. This\n         * method, instead, provides a simple equivalent to the {@code if...else}\n         * idiom of the sibling {@code tryLock()} method.\n         *\n         * @param time  How long to wait before timing out.\n         * @param unit  The units of {@code time}.\n         *\n         * @return the safe-lock which was acquired.\n         *\n         * @throws AcquireFailedException if the lock wasn't acquired.\n         * @throws InterruptedException   if the acquisition was interrupted.\n         */", "        public SafeLock tryAcquire(long time, TimeUnit unit)\n            throws AcquireFailedException,\n                   InterruptedException\n        {\n            if (LockManager.this.tryLock(myLock, myExclusive, time, unit)) {\n                return this;\n            }\n            else {\n                throw new AcquireFailedException();\n            }\n        }\n\n        /**\n         * Unlock this lock. This is provided for use in a {@link AutoCloseable}\n         * try-with-resources context.\n         *\n         * @throws IllegalMonitorStateException If the current thread does not hold\n         *                                      this lock.\n         */\n        @Override", "        public void close()\n        {\n            unlock();\n        }\n\n        /**\n         * Whether this is an exclusive lock or, else, a shared one.\n         *\n         * @return whether it is exclusive.\n         */\n        public boolean isExclusive()\n        {\n            return myExclusive;\n        }\n\n        /**\n         * Whether the named lock is held by the current thread.\n         *\n         * @return whether it is held.\n         */", "        public boolean isExclusive()\n        {\n            return myExclusive;\n        }\n\n        /**\n         * Whether the named lock is held by the current thread.\n         *\n         * @return whether it is held.\n         */\n        public boolean isHeldByCurrentThread()\n        {\n            return myLock.isHeldByCurrentThread(myExclusive);\n        }\n\n        /**\n         * Set the log level associated with this lock, to enable lock\n         * debugging.\n         *\n         * @param level  The new level.\n         */", "        public boolean isHeldByCurrentThread()\n        {\n            return myLock.isHeldByCurrentThread(myExclusive);\n        }\n\n        /**\n         * Set the log level associated with this lock, to enable lock\n         * debugging.\n         *\n         * @param level  The new level.\n         */", "        public void setLogLevel(final Level level)\n        {\n            myLock.setLogLevel(level);\n        }\n    }\n\n    /**\n     * The \"safe\" version of a read-write lock pair.\n     *\n     * <p>In the semantics of this class a read lock is a shared lock, and a\n     * write lock is an exclusive lock.\n     */", "    public static class SafeReadWriteLock\n        implements ReadWriteLock\n    {\n        /**\n         * The read (shared) lock.\n         */\n        private final SafeLock myReadLock;\n\n        /**\n         * The write (exclusive) lock.\n         */\n        private final SafeLock myWriteLock;\n\n        /**\n         * CTOR.\n         */\n        private SafeReadWriteLock(final SafeLock readLock,\n                                  final SafeLock writeLock)\n        {\n            myReadLock  = readLock;\n            myWriteLock = writeLock;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public SafeLock readLock()\n        {\n            return myReadLock;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public SafeLock writeLock()\n        {\n            return myWriteLock;\n        }\n\n        /**\n         * Get the shared lock.\n         *\n         * <p>This is a semantic sugar method which is a synonym for\n         * {@link #readLock()}.\n         *\n         * @return the shared lock.\n         */", "        public SafeLock writeLock()\n        {\n            return myWriteLock;\n        }\n\n        /**\n         * Get the shared lock.\n         *\n         * <p>This is a semantic sugar method which is a synonym for\n         * {@link #readLock()}.\n         *\n         * @return the shared lock.\n         */", "        public SafeLock sharedLock()\n        {\n            return readLock();\n        }\n\n        /**\n         * Get the exclusive lock.\n         *\n         * <p>This is a semantic sugar method which is a synonym for\n         * {@link #writeLock()}.\n         *\n         * @return the exclusive lock.\n         */", "        public SafeLock exclusiveLock()\n        {\n            return writeLock();\n        }\n    }\n\n    /**\n     * The state of a thread's locks. This can be used to remember what a\n     * particular thread holds at any one time and, at a later point, to release\n     * any locks acquired in the interim. It may be used in a try-with-resources\n     * context or standalone.\n     *\n     * <p>For example:<pre>\n     *     // Acquire Lock1 and Lock2\n     *     lm.lock(\"Lock1\");\n     *     lm.lock(\"Lock2\");\n     *\n     *     // At this point we have 1 lock on each of Lock1 and Lock2\n     *     try (ThreadLockState state = lm.saveLockState()) {\n     *         lm.lock(\"Lock2\");\n     *         lm.lock(\"Lock3\");\n     *         // We now have 1 lock on Lock1 and Lock3 and 2 locks on Lock2\n     *     }\n     *     // Upon exiting the try block we now are back to 1 lock on Lock1 and Lock2\n     * </pre>\n     *\n     * <p>Note that, if any locks have been freed in the interim, such that\n     * restoring the locking state would actually entail <i>acquiring</i> locks,\n     * then this is considered an illegal state. This is to catch programming\n     * errors.\n     */", "    public class ThreadLockState\n        implements AutoCloseable\n    {\n        /**\n         * The details of a lock which we hold.\n         */\n        public class Details\n        {\n            /**\n             * The entry in the map which we correspond to.\n             */\n            private final Map.Entry<LockManagerLock,int[]> myEntry;\n\n            /**\n             * CTOR.\n             *\n             * @param entry  The entry in the map which we correspond to.\n             */\n            protected Details(final Map.Entry<LockManagerLock,int[]> entry)\n            {\n                myEntry = entry;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public String toString()\n            {\n                final StringBuilder sb = new StringBuilder();\n                sb.append(getName()).append('[');\n                sb.append(\"EXCL:\").append(numExclusive()).append(',');\n                sb.append(\"SHRD:\").append(numShared());\n                sb.append(']');\n                return sb.toString();\n            }\n\n            /**\n             * Get the name of the lock.\n             *\n             * @return the name.\n             */", "            public String getName()\n            {\n                return myEntry.getKey().getName();\n            }\n\n            /**\n             * Get the number of exclusive holds this thread has on the lock.\n             *\n             * @return the number of exclusive holds.\n             */\n            public int numExclusive()\n            {\n                return myEntry.getValue()[0];\n            }\n\n            /**\n             * Get the number of shared holds this thread has on the lock.\n             *\n             * @return the number of shared holds.\n             */", "            public int numExclusive()\n            {\n                return myEntry.getValue()[0];\n            }\n\n            /**\n             * Get the number of shared holds this thread has on the lock.\n             *\n             * @return the number of shared holds.\n             */\n            public int numShared()\n            {\n                return myEntry.getValue()[1];\n            }\n        }\n\n        /**\n         * The thread associated with this state.\n         */\n        private final Thread myThread;\n\n        /**\n         * Mapping from lock to {@code (exclusive,shared)} lock counts.\n         */\n        private final Map<LockManagerLock,int[]> myLockCounts;\n\n        /**\n         * CTOR. Only called by {@code LockManager#saveLockState().}\n\n         * @param thread  The thread.\n         * @param counts  The locks and their counts.\n         */\n        protected ThreadLockState(final Thread thread,\n                                  final Map<LockManagerLock,int[]> counts)\n        {\n            myThread     = thread;\n            myLockCounts = counts;\n        }\n\n        /**\n         * Restore the lock state.\n         *\n         * @throws IllegalMonitorStateException if we would have to acquire a\n         *                                      lock in order to restore the\n         *                                      state correctly.\n         */", "            public int numShared()\n            {\n                return myEntry.getValue()[1];\n            }\n        }\n\n        /**\n         * The thread associated with this state.\n         */\n        private final Thread myThread;\n\n        /**\n         * Mapping from lock to {@code (exclusive,shared)} lock counts.\n         */\n        private final Map<LockManagerLock,int[]> myLockCounts;\n\n        /**\n         * CTOR. Only called by {@code LockManager#saveLockState().}\n\n         * @param thread  The thread.\n         * @param counts  The locks and their counts.\n         */\n        protected ThreadLockState(final Thread thread,\n                                  final Map<LockManagerLock,int[]> counts)\n        {\n            myThread     = thread;\n            myLockCounts = counts;\n        }\n\n        /**\n         * Restore the lock state.\n         *\n         * @throws IllegalMonitorStateException if we would have to acquire a\n         *                                      lock in order to restore the\n         *                                      state correctly.\n         */", "        public void restore()\n            throws IllegalMonitorStateException\n        {\n            restoreLockState(this);\n        }\n\n        /**\n         * Filter out any locks for which the given {@code acceptor} predicate\n         * returns {@code false}. A {@code null} acceptor will be ignored.\n         *\n         * <p>The {@code acceptor} should not retain any {@link Details} pointer\n         * outside the duration of its {@code test()} invocation.\n         *\n         * @param acceptor  How to filter.\n         *\n         * @return whether the collection of locks changed at all.\n         */", "        public boolean filter(final Predicate<Details> acceptor)\n        {\n            // NOP\n            if (acceptor == null) {\n                return false;\n            }\n\n            // What we will return\n            boolean changed = false;\n\n            // Walk and check\n            final Iterator<Map.Entry<LockManagerLock,int[]>> itr =\n                myLockCounts.entrySet().iterator();", "            while (itr.hasNext()) {\n                final Details details = new Details(itr.next());\n                if (!acceptor.test(details)) {\n                    if (getLogger().isLoggable(Level.FINEST)) {\n                        getLogger().finest(\"Removing entry \" + details);\n                    }\n                    itr.remove();\n                    changed = true;\n                }\n                else if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().finest(\"Keeping entry \" + details);\n                }\n            }\n\n            // Give back whether we changed the collection at all\n            return changed;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "                else if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().finest(\"Keeping entry \" + details);\n                }\n            }\n\n            // Give back whether we changed the collection at all\n            return changed;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void close()\n        {\n            restore();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(getThread().getName()).append('{');\n            String comma = \"\";", "        public String toString()\n        {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(getThread().getName()).append('{');\n            String comma = \"\";\n            for (Map.Entry<LockManagerLock,int[]> entry :\n                     getLockCounts().entrySet())\n            {\n                sb.append(comma);\n                sb.append(new Details(entry));\n                comma = \",\";\n            }\n            sb.append('}');\n            return sb.toString();\n        }\n\n        /**\n         * Get the thread associated with this state.\n         *\n         * @return the thread.\n         */\n        protected Thread getThread()\n        {\n            return myThread;\n        }\n\n        /**\n         * Get the lock counts.\n         *\n         * @return the counts.\n         */\n        protected Map<LockManagerLock,int[]> getLockCounts()\n        {\n            return myLockCounts;\n        }\n    }\n\n    /**\n     * A {@link List} implementation tagged with a \"colour\". This basically\n     * allows us to mark the list in some way.\n     */\n    protected static class ColouredList<T>\n        extends ArrayList<T>\n    {\n        /**\n         * The colour all instances start with. The result of getNextColour()\n         * must never return this else we might accidently \"match\".\n         */\n        private static final int START_COLOUR = 0;\n\n        /**\n         * The next \"colour\" from a global stash.\n         *\n         * Technically we want all the colours to be unique. However, since we\n         * are going to visit all the instances of this class in lockWalksTo()\n         * it probably just needs to be a different value from the previous one.\n         * Given that, 2^32-1 different values should suffice (and will be\n         * aligned on a word boundary in the instance).\n         */\n        private static int ourNextColour = START_COLOUR + 1;\n\n        /**\n         * The colour of our list. This starts off at a value which will never\n         * match the result of getNextColour().\n         */\n        private int myColour = START_COLOUR;\n\n        /**\n         * Get the next colour to use for colouring.\n         *\n         * Should only be called under the state lock.\n         *\n         * @return The next value.\n         */", "        public static int getNextColour()\n        {\n            final int result = ourNextColour++;\n            if (ourNextColour == START_COLOUR) {\n                ourNextColour++;\n            }\n            return result;\n        }\n\n        /**\n         * CTOR with capacity.\n         *\n         * @param capacity  The desired capacity.\n         */\n        public ColouredList(int capacity)\n        {\n            super(capacity);\n        }\n\n        /**\n         * Set the colour of our list, returning true if it was different from\n         * the previous colour.\n         *\n         * @param colour  The colour of the list.\n         *\n         * @return whether the colour was changed.\n         */", "        public boolean setColour(int colour)\n        {\n            final boolean result = (colour != myColour);\n            myColour = colour;\n            return result;\n        }\n    }\n\n    /**\n     * A lock which has all the functions required by the LockManager.\n     */\n    protected static interface LockManagerLock\n    {\n        /**\n         * Details of a possible holder of a lock, and how.\n         *\n         * <p>This is something which is keyed by the locking thread and the\n         * lock type (exclusive or shared). It also carries state, denoting\n         * whether the lock is actually held by the thread.\n         */", "        public static class Locker\n        {\n            /**\n             * The locking thread. This makes part of the Locker \"key\".\n             */\n            private Thread myThread = null;\n\n            /**\n             * The type of lock being held; exclusive or, else, shared. This\n             * makes part of the Locker \"key\".\n             */\n            private boolean myExclusive = false;\n\n            /**\n             * Whether the lock is actually being held.\n             */\n            private boolean myHolding = false;\n\n            /**\n             * The stack-traces of each acquire for this lock. Mainly for debugging.\n             */\n            private final List<Throwable> myLockStackTraces =\n                ourLogLockStackTraces ? new ArrayList<>() : null;\n\n            /**\n             * Get the locking thread.\n             *\n             * @return the thread.\n             */", "            public Thread getThread()\n            {\n                return myThread;\n            }\n\n            /**\n             * Get the if type of lock being held is exclusive or, else, shared.\n             *\n             * @return whether the lock is held exclusively.\n             */\n            public boolean isExclusive()\n            {\n                return myExclusive;\n            }\n\n            /**\n             * Set the thread and lock type.\n             *\n             * @param thread       The thread to set with.\n             * @param isExclusive  Whether the lock is held exclusively.\n             */", "            public boolean isExclusive()\n            {\n                return myExclusive;\n            }\n\n            /**\n             * Set the thread and lock type.\n             *\n             * @param thread       The thread to set with.\n             * @param isExclusive  Whether the lock is held exclusively.\n             */", "            public void set(final Thread thread, final boolean isExclusive)\n            {\n                myThread    = thread;\n                myExclusive = isExclusive;\n            }\n\n            /**\n             * Set the thread and lock type, and whether it's being held.\n             *\n             * @param thread       The thread to set with.\n             * @param isExclusive  Whether the lock is held exclusively.\n             * @param isHolding    Whether the lock is actually held.\n             */", "            public void set(final Thread  thread,\n                            final boolean isExclusive,\n                            final boolean isHolding)\n            {\n                myThread    = thread;\n                myExclusive = isExclusive;\n                myHolding   = isHolding;\n            }\n\n            /**\n             * Make like new.\n             */", "            public void clear()\n            {\n                myThread    = null;\n                myExclusive = false;\n                myHolding   = false;\n                if (myLockStackTraces != null) {\n                    myLockStackTraces.clear();\n                }\n            }\n\n            /**\n             * Get whether the lock is actually being held.\n             *\n             * @return whether the lock is held.\n             */", "            public boolean isHolding()\n            {\n                return myHolding;\n            }\n\n            /**\n             * Set whether the lock is being held.\n             *\n             * @param isHolding  Whether the lock is held.\n             */\n            public void setHolding(final boolean isHolding)\n            {\n                myHolding = isHolding;\n            }\n\n            /**\n             * If we are tracking lock stack-traces then record one.\n             */", "            public void setHolding(final boolean isHolding)\n            {\n                myHolding = isHolding;\n            }\n\n            /**\n             * If we are tracking lock stack-traces then record one.\n             */\n            public void logLock()\n            {\n                if (myLockStackTraces != null) {\n                    myLockStackTraces.add(new Throwable(myThread.getName()));\n                }\n            }\n\n            /**\n             * Whether this instance matches the given thread and lock type.\n             *\n             * @param thread       The thread to check against.\n             * @param isExclusive  The type of holding.\n             *\n             * @return Whether the details match.\n             */", "            public void logLock()\n            {\n                if (myLockStackTraces != null) {\n                    myLockStackTraces.add(new Throwable(myThread.getName()));\n                }\n            }\n\n            /**\n             * Whether this instance matches the given thread and lock type.\n             *\n             * @param thread       The thread to check against.\n             * @param isExclusive  The type of holding.\n             *\n             * @return Whether the details match.\n             */", "            public boolean matches(final Thread  thread,\n                                   final boolean isExclusive)\n            {\n                return (myThread.equals(thread) && myExclusive == isExclusive);\n            }\n\n            /**\n             * Get the lock stack-traces, if any.\n             *\n             * @return the stack-traces, if any.\n             */\n            public List<Throwable> getLockStackTraces()\n            {\n                return myLockStackTraces;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override", "            public String toString()\n            {\n                return \"'\" + getThread().getName() + \"'[\" +\n                    (isHolding()   ? \"HOLDS\" : \"WANTS\") + \":\" +\n                    (isExclusive() ? \"EXCL\"  : \"SHRD\" ) +\n                    (myLockStackTraces == null\n                     ? \"\"\n                     : \"\\n\" + myLockStackTraces.stream()\n                                              .map(StringUtil::stackTraceToString)\n                                              .collect(Collectors.joining(\"\\n\"))) +\n                \"]\";\n            }\n        }\n\n        /**\n         * Get the name of the lock.\n         *\n         * @return the lock name.\n         */", "        public String getName();\n\n        /**\n         * Acquire this lock in an exclusive or shared manner.\n         *\n         * @param isExclusive  Whether to lock exclusively.\n         */\n        public void lock(final boolean isExclusive);\n\n        /**\n         * Attempt to acquire this lock in an exclusive or shared manner.\n         *\n         * @param isExclusive  Whether to lock exclusively.\n         *\n         * @return whether the lock was acquired.\n         */", "        public boolean tryLock(final boolean isExclusive);\n\n        /**\n         * Attempt to acquire this lock in an exclusive or shared manner, within\n         * the specified time limit.\n         *\n         * @param isExclusive  Whether the lock should be acquired exclusively.\n         * @param time         How long to wait before timing out.\n         * @param unit         The units of {@code time}.\n         *\n         * @return whether the lock was acquired.\n         *\n         * @throws InterruptedException if the acquisition was interrupted.\n         */", "        public boolean tryLock(final boolean isExclusive,\n                               final long time,\n                               final TimeUnit unit)\n            throws InterruptedException;\n\n        /**\n         * Release a lock.\n         *\n         * @param isExclusive  Whether to release a lock which was acquired\n         *                     exclusively.\n         */", "        public void unlock(final boolean isExclusive);\n\n        /**\n         * Returns a new {@link Condition} instance that is bound to this\n         * instance, for the exclusive or shared lock.\n         *\n         * @param isExclusive  Whether to lock exclusively.\n         *\n         * @return the new condition.\n         */\n        public Condition newCondition(final boolean isExclusive);\n\n        /**\n         * Whether this lock is held by the current thread in an exclusive\n         * or shared manner.\n         *\n         * @param isExclusive  Whether the check is for an exclusive lock.\n         *\n         * @return whether the lock is held.\n         */", "        public Condition newCondition(final boolean isExclusive);\n\n        /**\n         * Whether this lock is held by the current thread in an exclusive\n         * or shared manner.\n         *\n         * @param isExclusive  Whether the check is for an exclusive lock.\n         *\n         * @return whether the lock is held.\n         */\n        public boolean isHeldByCurrentThread(final boolean isExclusive);\n\n        /**\n         * Get the hold count for this thread, either in an exclusive\n         * or shared manner.\n         *\n         * @param isExclusive  Whether the check is for an exclusive lock.\n         *\n         * @return how many times this thread holds the lock.\n         */", "        public boolean isHeldByCurrentThread(final boolean isExclusive);\n\n        /**\n         * Get the hold count for this thread, either in an exclusive\n         * or shared manner.\n         *\n         * @param isExclusive  Whether the check is for an exclusive lock.\n         *\n         * @return how many times this thread holds the lock.\n         */\n        public int getHoldCountForCurrentThread(final boolean isExclusive);\n\n        /**\n         * Get the list of threads which are holding, or trying to acquire, this\n         * lock. This should only be accessed under the state lock.\n         *\n         * @return the list of lockers.\n         */\n        public ColouredList<Locker> getLockers();\n\n        /**\n         * Add a thread which will be locking this lock. This should only be\n         * called under the state lock.\n         *\n         * <p>Callers should take care not to add any {@code (Thread,LockType)}\n         * more than once. This will not be checked here.\n         *\n         * @param thread       The thread to add.\n         * @param isHolding    Whether the thread is already holding the lock.\n         * @param isExclusive  Whether the lock is held exclusively.\n         */", "        public int getHoldCountForCurrentThread(final boolean isExclusive);\n\n        /**\n         * Get the list of threads which are holding, or trying to acquire, this\n         * lock. This should only be accessed under the state lock.\n         *\n         * @return the list of lockers.\n         */\n        public ColouredList<Locker> getLockers();\n\n        /**\n         * Add a thread which will be locking this lock. This should only be\n         * called under the state lock.\n         *\n         * <p>Callers should take care not to add any {@code (Thread,LockType)}\n         * more than once. This will not be checked here.\n         *\n         * @param thread       The thread to add.\n         * @param isHolding    Whether the thread is already holding the lock.\n         * @param isExclusive  Whether the lock is held exclusively.\n         */", "        public default void addLocker(final Thread  thread,\n                                      final boolean isHolding,\n                                      final boolean isExclusive)\n        {\n            final Locker locker = ourLockerPool.getInstance();\n            locker.set(thread, isExclusive, isHolding);\n            locker.logLock();\n            getLockers().add(locker);\n        }\n\n        /**\n         * Mark this thread as actually holding the lock. This should only be\n         * called under the state lock.\n         *\n         * @param thread       The thread to mark with.\n         * @param isExclusive  Whether the lock is held exclusively.\n         *\n         * @return whether the call was successful.\n         */", "        public default boolean setLockerHolding(final Thread  thread,\n                                                final boolean isExclusive)\n        {\n            final List<Locker> lockers = getLockers();\n            for (int i=0; i < lockers.size(); i++) {\n                final Locker locker = lockers.get(i);\n                if (locker.matches(thread, isExclusive)) {\n                    locker.setHolding(true);\n                    locker.logLock();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Remove the given thread as a locker. This should only be called under\n         * the state lock.\n         *\n         * @param thread       The thread to unmark with.\n         * @param isExclusive  Whether the lock is held exclusively.\n         *\n         * @return whether the call was successful.\n         */", "        public default boolean removeLocker(final Thread thread,\n                                            final boolean isExclusive)\n        {\n            final List<Locker> lockers = getLockers();\n            int i;\n            for (i=0; i < lockers.size(); i++) {\n                final Locker locker = lockers.get(i);\n                if (locker.matches(thread, isExclusive)) {\n                    break;\n                }\n            }", "            if (i < lockers.size()) {\n                ourLockerPool.releaseInstance(lockers.remove(i));\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n\n        /**\n         * Whether the given thread is blocked waiting to acquire this lock.\n         * This should only be called under the state lock.\n         *\n         * @param thread  The thread to check.\n         *\n         * @return whether the thread is blocked.\n         */", "        public default boolean isThreadAwaiting(final Thread thread)\n        {\n            // Null threads can't be waiting\n            if (thread == null) {\n                return false;\n            }\n\n            // Look for all the occurances of this thread, if it is marked as\n            // not actually holding the lock then it is waiting on it. We have\n            // to do an exhaustive search until we find unheld instances since\n            // we could be locking the lock either shared or exclusively.\n            boolean awaiting = false;\n            final List<Locker> lockers = getLockers();", "            for (int i=0; i < lockers.size(); i++) {\n                final Locker locker = lockers.get(i);\n                if (thread.equals(locker.getThread()) && !locker.isHolding()) {\n                    awaiting = true;\n                    break;\n                }\n            }\n            return awaiting;\n        }\n\n        /**\n         * Get the log level associated with this lock, to enable lock\n         * debugging.\n         *\n         * @return the logging level.\n         */", "        public Level getLogLevel();\n\n        /**\n         * Set the log level associated with this lock, to enable lock\n         * debugging.\n         *\n         * @param level  The new logging level.\n         */\n        public void setLogLevel(final Level level);\n    }\n    /** Pool for the Locker instances -- for use in the above only. */\n    private static final Pool<LockManagerLock.Locker> ourLockerPool =\n        new SwappingPool<>(1024, 8) {\n            @Override protected void prepareForReuse(LockManagerLock.Locker locker) {\n                // Release any references held etc.\n                locker.clear();\n            }\n            @Override protected LockManagerLock.Locker newInstance() {\n                return new LockManagerLock.Locker();\n            }\n        };\n\n    /**\n     * A re-entrant lock with a name.\n     */\n    private static class NamedReentrantLock\n        extends    ReentrantReadWriteLock\n        implements LockManagerLock\n    {\n        /**\n         * Our name.\n         */\n        private final String myName;\n\n        /**\n         * Our list of threads which hold us, or are trying to acquire us, and\n         * how they hold us.\n         */\n        private final ColouredList<Locker> myLockers;\n\n        /**\n         * Our logging level.\n         */\n        private volatile Level myLogLevel;\n\n        /**\n         * CTOR\n         */\n        public NamedReentrantLock(final CharSequence name)\n        {", "        public void setLogLevel(final Level level);\n    }\n    /** Pool for the Locker instances -- for use in the above only. */\n    private static final Pool<LockManagerLock.Locker> ourLockerPool =\n        new SwappingPool<>(1024, 8) {\n            @Override protected void prepareForReuse(LockManagerLock.Locker locker) {\n                // Release any references held etc.\n                locker.clear();\n            }\n            @Override protected LockManagerLock.Locker newInstance() {\n                return new LockManagerLock.Locker();\n            }\n        };\n\n    /**\n     * A re-entrant lock with a name.\n     */\n    private static class NamedReentrantLock\n        extends    ReentrantReadWriteLock\n        implements LockManagerLock\n    {\n        /**\n         * Our name.\n         */\n        private final String myName;\n\n        /**\n         * Our list of threads which hold us, or are trying to acquire us, and\n         * how they hold us.\n         */\n        private final ColouredList<Locker> myLockers;\n\n        /**\n         * Our logging level.\n         */\n        private volatile Level myLogLevel;\n\n        /**\n         * CTOR\n         */\n        public NamedReentrantLock(final CharSequence name)\n        {", "            if (name == null) {\n                throw new NullPointerException(\"Given a null name\");\n            }\n            myName     = name.toString();\n            myLockers  = new ColouredList<>(4);\n            myLogLevel = Level.FINEST;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public String getName()\n        {\n            return myName;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void lock(final boolean isExclusive)\n        {", "        public void lock(final boolean isExclusive)\n        {\n            if (isExclusive) {\n                writeLock().lock();\n            }\n            else {\n                readLock().lock();\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean tryLock(final boolean isExclusive)\n        {\n            if (isExclusive) {\n                return writeLock().tryLock();\n            }\n            else {\n                if (readLock().tryLock()) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean tryLock(final boolean isExclusive,\n                               final long time,\n                               final TimeUnit unit)\n            throws InterruptedException\n        {\n            if (isExclusive) {\n                return writeLock().tryLock(time, unit);\n            }\n            else {\n                if (readLock().tryLock(time, unit)) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "                if (readLock().tryLock(time, unit)) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public void unlock(final boolean isExclusive)\n        {\n            if (isExclusive) {\n                writeLock().unlock();\n            }\n            else {\n                readLock().unlock();\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Condition newCondition(final boolean isExclusive)\n        {\n            return (isExclusive ? writeLock() : readLock()).newCondition();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isHeldByCurrentThread(final boolean isExclusive)\n        {\n            return getHoldCountForCurrentThread(isExclusive) > 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public boolean isHeldByCurrentThread(final boolean isExclusive)\n        {\n            return getHoldCountForCurrentThread(isExclusive) > 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getHoldCountForCurrentThread(final boolean isExclusive)\n        {\n            return isExclusive ? getWriteHoldCount() : getReadHoldCount();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ColouredList<Locker> getLockers()\n        {\n            return myLockers;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public int getHoldCountForCurrentThread(final boolean isExclusive)\n        {\n            return isExclusive ? getWriteHoldCount() : getReadHoldCount();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ColouredList<Locker> getLockers()\n        {\n            return myLockers;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override", "        public Level getLogLevel()\n        {\n            return myLogLevel;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setLogLevel(final Level level)\n        {", "        public void setLogLevel(final Level level)\n        {\n            if (level == null) {\n                throw new NullPointerException(\"Given a null level\");\n            }\n            myLogLevel = level;\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * <p>This should only be called under the synchronized(LockManager.this)\n         * lock since it references myLockers.\n         */\n        @Override", "        public String toString()\n        {\n            // We add the name to the parent's toString() information. We don't\n            // cache this since what the parent's method can return may change\n            // depending on if it's held or not.\n            final StringBuilder sb = new StringBuilder();\n            sb.append(myName).append(':')\n              .append(super.toString())\n              .append(\"[Lockers = \")\n              .append(myLockers.stream()\n                               .map(Locker::toString)\n                               .collect(Collectors.joining(\",\")))\n              .append(']');\n            return sb.toString();\n        }\n    }\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * Whether to log stacktraces of locks. Mostly for debugging.\n     */\n    private static final boolean ourLogLockStackTraces;\n    static {\n        final String prop =\n            \"com.deshaw.util.concurrent.LockManager.logStackTraces\";", "        try {\n            ourLogLockStackTraces =\n                StringUtil.parseBoolean(System.getProperty(prop, \"false\"));\n        }\n        catch (Exception e) {\n            throw new RuntimeException(\"Bad value for \" + prop, e);\n        }\n    }\n\n    /**\n     * The StringBuilder used to track calls to lockWalksTo(), if any.\n     */\n    private static final ThreadLocalStringBuilder ourLockWalksToSb =\n        ourLogLockStackTraces ? new ThreadLocalStringBuilder(1024) : null;\n\n    // Instrumentation\n    private static final Instrumentor ourGetNamedLockInstr;\n    private static final Instrumentor ourLockInstr;\n    private static final Instrumentor ourLockWalksToInstr;\n    private static final Instrumentor ourTryLockTUInstr;\n    private static final Instrumentor ourTryLockInstr;\n    private static final Instrumentor ourUnlockInstr;\n    static {\n        ourGetNamedLockInstr = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#getNamedLock()\");\n        ourLockInstr         = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#lock()\");\n        ourLockWalksToInstr  = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#lockWalksTo()\");\n        ourTryLockTUInstr    = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#tryLock(time,unit)\");\n        ourTryLockInstr      = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#tryLock()\");\n        ourUnlockInstr       = INSTRUMENTOR_FACTORY.getInstance(\"LockManager#unlock()\");\n\n        // We get a lot of these\n        ourLockInstr  .setIntervalMod(1000);\n        ourUnlockInstr.setIntervalMod(1000);\n    }\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * User-defined locks. These allow clients to coordinate with one another\n     * since we are effectively dealing with a multi-threaded application\n     */\n    private final ConcurrentMap<CharSequence,LockManagerLock> myNamedLocks;\n\n    // We effectively two maps, these are from threads to locks and locks to\n    // threads. Together they form a dependency graph which we will walk in\n    // lockWalksTo(). It's that walk which we perform in order to detect\n    // deadlock. The lock-threads map is actually done by associating the\n    // threads with the lock instance itself (in getLockers()).\n    //\n    // We use Lists since, though their remove() operation is potentially slow,\n    // it's fast to iterate over them. Also, we expect the lists to be\n    // relatively short which makes operations on them slightly quicker than\n    // using Sets. Since we're using Lists and not Sets it's important that we\n    // only add to them if the element is not there already.\n\n    /**\n     * Mapping from threads to locks which they hold or locks they are\n     * trying to acquire.\n     *\n     * This should only be accessed under synchronized(this).\n     */\n    private final Map<Thread,ColouredList<LockManagerLock>> myThreadToLocks;\n\n    /**\n     * An empty lock state for the \"current\" thread which, for example, can be\n     * used to drop all the thread locks.\n     */\n    private final ThreadLockState myEmptyLockState =\n        new ThreadLockState(null, Collections.emptyMap()) {\n            @Override protected Thread getThread() {\n                return currentThread();\n            }\n        };\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * CTOR.\n     */\n    public LockManager()\n    {\n        myNamedLocks    = new ConcurrentHashMap<>();\n        myThreadToLocks = new HashMap<>();\n    }\n\n    /**\n     * Get an exclusive {@link SafeLock} instance for a lock of a given name.\n     *\n     * <p>The implementation returned will perform all its locking operations via\n     * the lock manager.\n     *\n     * @param lockName  The name of the lock.\n     *\n     * @return the lock.\n     *\n     * @throws UnsupportedOperationException if the lock type is not supported.\n     */", "    public SafeLock getExclusiveLockFor(final CharSequence lockName)\n        throws UnsupportedOperationException\n    {\n        return new SafeLock(getNamedLock(lockName), true);\n    }\n\n    /**\n     * Get a shared {@link SafeLock} instance for a lock of a given name.\n     *\n     * <p>The implementation returned will perform all its locking operations via\n     * the lock manager.\n     *\n     * @param lockName  The name of the lock.\n     *\n     * @return the lock.\n     *\n     * @throws UnsupportedOperationException if the lock type is not supported.\n     */", "    public SafeLock getSharedLockFor(final CharSequence lockName)\n        throws UnsupportedOperationException\n    {\n        return new SafeLock(getNamedLock(lockName), false);\n    }\n\n    /**\n     * Get a read-write version of a {@link SafeLock} instance for a lock of a\n     * given name. For out purposes \"read\" means \"shared\" and \"write\" means\n     * \"exclusive\".\n     *\n     * <p>The implementation returned will perform all its locking operations via\n     * the lock manager.\n     *\n     * @param lockName  The name of the lock.\n     *\n     * @return the lock.\n     */", "    public SafeReadWriteLock getReadWriteLockFor(final CharSequence lockName)\n    {\n        return new SafeReadWriteLock(getSharedLockFor   (lockName),\n                                     getExclusiveLockFor(lockName));\n    }\n\n    /**\n     * Drop any locks held by the current thread, returning whether any were\n     * dropped or not.\n     *\n     * @return any dropped.\n     */", "    public boolean dropAllThreadLocks()\n    {\n        // Drop all the locks by \"restoring\" an empty state\n        if (getLogger().isLoggable(Level.FINEST)) {\n            getLogger().finest(\"Releasing all locks\");\n        }\n        return restoreLockState(myEmptyLockState);\n    }\n\n    /**\n     * Save the lock state for this thread.\n     *\n     * @return the lock state.\n     */", "    public ThreadLockState saveLockState()\n    {\n        // What we'll build up. This is a map from lock to (exclusive,shared)\n        // counts.\n        final Map<LockManagerLock,int[]> counts;\n\n        // The thread which we are working for\n        final Thread me = currentThread();\n\n        // We need to do this under the lock, since we are accessing our locks'\n        // state\n        synchronized(this) {\n            final ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);", "            if (locks != null && !locks.isEmpty()) {\n                // We have data to build up the map with\n                counts = new HashMap<>();\n                for (LockManagerLock lock : locks) {\n                    final int exclusive = lock.getHoldCountForCurrentThread(true);\n                    final int shared    = lock.getHoldCountForCurrentThread(false);\n                    if (exclusive > 0 || shared > 0) {\n                        counts.put(lock, new int[] { exclusive, shared });\n                    }\n                }\n            }\n            else {\n                // No locks means no counts\n                counts = Collections.emptyMap();\n            }\n        }\n\n        // Finally we can give back the state\n        final ThreadLockState state = new ThreadLockState(me, counts);", "        if (getLogger().isLoggable(Level.FINEST)) {\n            getLogger().finest(\"Created state: \" + state);\n        }\n        return state;\n    }\n\n    /**\n     * Restore the lock state for this thread. A {@code null} state is ignored.\n     *\n     * @param state  The state to restore with.\n     *\n     * @return whether any locks were dropped.\n     *\n     * @throws IllegalArgumentException     if we were given a state for a\n     *                                      different thread.\n     * @throws IllegalMonitorStateException if we would have to acquire a lock\n     *                                      in order to restore the state\n     *                                      correctly.\n     */", "    public boolean restoreLockState(final ThreadLockState state)\n        throws IllegalArgumentException,\n               IllegalMonitorStateException\n    {\n        // Just ignore a null state\n        if (state == null) {\n            return false;\n        }\n        if (getLogger().isLoggable(Level.FINER)) {\n            getLogger().finer(\"Restoring state: \" + state);\n        }\n\n        // Should be the same thread\n        final Thread me = currentThread();", "        if (getLogger().isLoggable(Level.FINER)) {\n            getLogger().finer(\"Restoring state: \" + state);\n        }\n\n        // Should be the same thread\n        final Thread me = currentThread();\n        if (!me.equals(state.getThread())) {\n            throw new IllegalArgumentException(\n                \"Given a state for a different thread: \" +\n                me + \" \" + state.getThread()\n            );\n        }\n\n        // Say what we are restoring to. We copy this so that we may mutate it.\n        final Map<LockManagerLock,int[]> stateLockCounts =\n            new HashMap<>(state.getLockCounts());\n\n        // What we will return\n        boolean anyDropped = false;\n\n        // Need to go under the lock for this since we are accessing the\n        // collective lock state\n        synchronized(this) {\n            // The locks which this thread currently holds\n            final ColouredList<LockManagerLock> threadLocks =\n                myThreadToLocks.get(me);\n\n            // Ensure that we are not trying to acquire locks", "            if (threadLocks == null) {\n                if (!stateLockCounts.isEmpty()) {\n                    throw new IllegalMonitorStateException(\n                        \"Hold no locks but restoring state: \" + state\n                    );\n                }\n                else {\n                    // Nothing to do\n                    return false;\n                }\n            }\n\n            // Walk through and drop the locks held\n            final Iterator<LockManagerLock> lockItr = threadLocks.iterator();", "            while (lockItr.hasNext()) {\n                // Move on\n                final LockManagerLock lock = lockItr.next();\n\n                // Desired counts. It's possible for us to be holding a lock now\n                // which we were not before and so there may be no counts for it\n                // in the state.\n                final int[] pair = stateLockCounts.remove(lock);\n                final int wantNumExcl = (pair == null) ? 0 : pair[0];\n                final int wantNumShrd = (pair == null) ? 0 : pair[1];\n\n                // Actual counts\n                final int curNumExcl = lock.getHoldCountForCurrentThread(true);\n                final int curNumShrd = lock.getHoldCountForCurrentThread(false);\n\n                // Checks", "                if (curNumExcl < wantNumExcl) {\n                    throw new IllegalMonitorStateException(\n                        \"Restoring \" + wantNumExcl + \" exclusive lock(s) \" +\n                        \"but currently hold \" + curNumExcl + \" in \" + state\n                    );\n                }\n                if (curNumShrd < wantNumShrd) {\n                    throw new IllegalMonitorStateException(\n                        \"Restoring \" + wantNumShrd + \" shared lock(s) \" +\n                        \"but currently hold \" + curNumShrd + \" in \" + state\n                    );\n                }\n\n                // Now we can drop", "                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\n                        lock.getName() + \" \" +\n                        \"EXCL: \" + curNumExcl + \" -> \" + wantNumExcl + \"; \" +\n                        \"SHRD: \" + curNumShrd + \" -> \" + wantNumShrd\n                    );\n                }\n                for (int i = curNumExcl; i > wantNumExcl; i--) {\n                    lock.unlock(true);\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Dropped exclusive lock on \" + lock);\n                    }\n                }", "                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Dropped exclusive lock on \" + lock);\n                    }\n                }\n                for (int i = curNumShrd; i > wantNumShrd; i--) {\n                    lock.unlock(false);\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Dropped shared lock on \" + lock);\n                    }\n                }\n\n                // If we dropped all the locks then ensure that the lock does\n                // not know this thread as a locker still", "                if (wantNumExcl <= 0 && curNumExcl > 0 &&\n                    !lock.removeLocker(me, true))\n                {\n                    throw new IllegalStateException(\n                        \"Failed to remove exclusive holding thread \" +\n                        \"'\" + me.getName() + \"' for lock: \" + lock\n                    );\n                }\n                if (wantNumShrd <= 0 && curNumShrd > 0 &&\n                    !lock.removeLocker(me, false))\n                {\n                    throw new IllegalStateException(\n                        \"Failed to remove shared holding thread \" +\n                        \"'\" + me.getName() + \"' for lock: \" + lock\n                    );\n                }\n\n                // Is the thread still holding this lock? If not we remove the\n                // entry from the thread's list.", "                if (wantNumShrd <= 0 && curNumShrd > 0 &&\n                    !lock.removeLocker(me, false))\n                {\n                    throw new IllegalStateException(\n                        \"Failed to remove shared holding thread \" +\n                        \"'\" + me.getName() + \"' for lock: \" + lock\n                    );\n                }\n\n                // Is the thread still holding this lock? If not we remove the\n                // entry from the thread's list.", "                if (wantNumExcl == 0 && wantNumShrd == 0) {\n                    lockItr.remove();\n                }\n\n                // Remember if we dropped any\n                anyDropped |= ((wantNumExcl < curNumExcl) ||\n                               (wantNumShrd < curNumShrd));\n            }\n\n            // Any locks still held?\n            if (threadLocks.isEmpty()) {\n                // No, so remove the mapping\n                myThreadToLocks.remove(me);\n            }\n        }\n\n        // Finally, we should have handled all the state", "            if (threadLocks.isEmpty()) {\n                // No, so remove the mapping\n                myThreadToLocks.remove(me);\n            }\n        }\n\n        // Finally, we should have handled all the state\n        if (!stateLockCounts.isEmpty()) {\n            throw new IllegalArgumentException(\n                \"Locks not currently held when restoring \" + state + \": \" +\n                stateLockCounts\n            );\n        }\n\n        // Say if we dropped any at all\n        return anyDropped;\n    }\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * Get the logger for this instance.\n     *\n     * @return the logger.\n     */\n    protected Logger getLogger()\n    {\n        return LOG;\n    }\n\n    /**\n     * Create a named LockManagerLock instance. May be overridden by subclasses\n     * which want to provide different implementations.\n     *\n     * @param name  The name for the lock.\n     *\n     * @return the newly-created lock.\n     */\n    protected LockManagerLock newNamedLock(final CharSequence name)\n    {\n        return new NamedReentrantLock(name);\n    }\n\n    /**\n     * Returns the current thread which calls this method.\n     *\n     * <p>Note that, in some cases where the semantics of the LockManagerLock\n     * implementations are special, this might not be what you'd get back from\n     * {@code Thread.currentThread()}. In which case subclasses should override\n     * this method.\n     *\n     * @return the current thread, per the class's semantics.\n     */\n    protected Thread currentThread()\n    {\n        return Thread.currentThread();\n    }\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * Get a named lock. This allows external clients to get a lock which they\n     * may use to coordinate multiple instances of themselves.\n     *\n     * @param name The handle which we'll use for lookups.\n     *\n     * @return The named LockManagerLock instance, never null.\n     */\n    private LockManagerLock getNamedLock(CharSequence name)\n    {\n        final long start = ourGetNamedLockInstr.start();", "        try {\n            if (name == null) {\n                throw new NullPointerException(\"Given a null lock name\");\n            }\n\n            // Save a bit of time and garbage\n            if (!(name instanceof StringUtil.HashableSubSequence)) {\n                name = name.toString();\n            }\n\n            // Look for it\n            LockManagerLock lock = myNamedLocks.get(name);", "            if (lock == null) {\n                // It doesn't yet exist so create it, handling the race\n                // condition case\n                lock = newNamedLock(name);\n                final LockManagerLock previous =\n                    myNamedLocks.putIfAbsent(name.toString(), lock);\n                if (previous == null) {\n                    // We were the first, say so\n                    getLogger().finer(\"Created named lock \\\"\" + name + \"\\\"\");\n                }\n                else {\n                    // We hit the race condition and someone else created it\n                    // before us, use theirs\n                    lock = previous;\n                }\n            }\n\n            // Give back our final result\n            return lock;\n        }\n        finally {\n            ourGetNamedLockInstr.end(start);\n        }\n    }\n\n    /**\n     * Attempt to acquire a named lock if no-one else is holding it, creating\n     * the lock if needbe.\n     *\n     * @param lock         The lock to acquire.\n     * @param isExclusive  Whether the lock should be acquired exclusively.\n     *\n     * @return whether the lock was successfully acquired.\n     */\n    private boolean tryLock(final LockManagerLock lock, final boolean isExclusive)\n    {\n        final String how = isExclusive ? \"exclusive\" : \"shared\";\n        final long start = ourTryLockInstr.start();", "        try {\n            // By whom\n            final Thread me = currentThread();\n\n            // Acquire under the global lock\n            synchronized(this) {\n                // For the devlopers out there\n                if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().log(\n                        Level.FINEST,\n                        \"Looking to acquire \" + how + \" \" + lock,\n                        new Throwable(\"Call tree\")\n                    );\n                }", "                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Looking to acquire \" + how + \" \" + lock);\n                }\n\n                // If we're already holding the lock then it's trivial. It's\n                // _important_ that we make this check since we mustn't add this\n                // lock-and-thread pair to the state more than once.\n                if (lock.isHeldByCurrentThread(isExclusive)) {\n                    // Just lock it again and we're done\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Already \" + how + \"-holding \" + lock);\n                    }\n                    lock.lock(isExclusive);\n                    return true;\n                }\n\n                // Attempt to acquire it, this can never result in deadlock if\n                // no-one else is holding it", "                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Already \" + how + \"-holding \" + lock);\n                    }\n                    lock.lock(isExclusive);\n                    return true;\n                }\n\n                // Attempt to acquire it, this can never result in deadlock if\n                // no-one else is holding it\n                if (!lock.tryLock(isExclusive)) {\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Failed to acquire \" + how + \" \" + lock);\n                    }\n                    return false;\n                }", "                if (!lock.tryLock(isExclusive)) {\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Failed to acquire \" + how + \" \" + lock);\n                    }\n                    return false;\n                }\n                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Acquired \" + how + \" \" + lock);\n                }\n\n                // Since we acquired it we need to update our lock state\n                ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);", "                if (locks == null) {\n                    locks = new ColouredList<>(4);\n                    myThreadToLocks.put(me, locks);\n                }\n                locks.add(lock);\n                lock .addLocker(me, true, isExclusive);\n                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s):\"\n                    );", "                    for (LockManagerLock l : locks) {\n                        getLogger().finer(\"  \" + l);\n                    }\n                }\n\n                // Log information if the lock wants us to\n                if (LOG.isLoggable(lock.getLogLevel())) {\n                    LOG.log(lock.getLogLevel(),\n                            \"Thread '\" + me.getName() + \"' acquired \" +\n                            how + \" \" + lock,\n                            new Throwable());\n                }\n\n                // Log each time we seem to have a \"lot\" of locks", "                if (getLogger().isLoggable(Level.FINE) && (locks.size() % 25) == 0) {\n                    getLogger().log(\n                        Level.FINE,\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s): \",\n                        new Throwable()\n                    );\n                }\n            }\n\n            // Got it\n            return true;\n        }\n        finally {\n            ourTryLockInstr.end(start);\n        }\n    }\n\n    /**\n     * Attempt to acquire a named lock if no-one else is holding it, creating\n     * the lock if needbe and timing out after a given period.\n     *\n     * @param lock         The lock to acquire.\n     * @param isExclusive  Whether the lock should be acquired exclusively.\n     * @param time         How long to wait before timing out.\n     * @param unit         The units of {@code time}.\n     *\n     * @return whether the lock was successfully acquired.\n     */\n    private boolean tryLock(final LockManagerLock lock,\n                            final boolean isExclusive,\n                            final long time, final TimeUnit unit)\n        throws InterruptedException\n    {\n        final String how = isExclusive ? \"exclusive\" : \"shared\";\n        final long start = ourTryLockTUInstr.start();", "        try {\n            // By whom\n            final Thread me = currentThread();\n\n            // Acquire under the global lock\n            synchronized(this) {\n                // For the developers out there\n                if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().log(\n                        Level.FINEST,\n                        \"Looking to acquire \" + how + \" \" + lock,\n                        new Throwable(\"Call tree\")\n                    );\n                }", "                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Looking to acquire \" + how + \" \" + lock);\n                }\n\n                // If we're already holding the lock then it's trivial. It's\n                // _important_ that we make this check since we mustn't add this\n                // lock-and-thread pair to the state more than once.\n                if (lock.isHeldByCurrentThread(isExclusive)) {\n                    // Just lock it again and we're done\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Already holding \" + how + \" \" + lock);\n                    }\n                    lock.lock(isExclusive);\n                    return true;\n                }\n\n                // Attempt to acquire it, this can never result in deadlock if\n                // no-one else is holding it", "                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Already holding \" + how + \" \" + lock);\n                    }\n                    lock.lock(isExclusive);\n                    return true;\n                }\n\n                // Attempt to acquire it, this can never result in deadlock if\n                // no-one else is holding it\n                if (!lock.tryLock(isExclusive, time, unit)) {\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\n                            \"Failed to acquire \" + how + \" \" + lock + \" \" +\n                            \"after \" + time + \" \" + unit + (time == 1 ? \"\" : \"s\")\n                        );\n                    }\n                    return false;\n                }", "                if (!lock.tryLock(isExclusive, time, unit)) {\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\n                            \"Failed to acquire \" + how + \" \" + lock + \" \" +\n                            \"after \" + time + \" \" + unit + (time == 1 ? \"\" : \"s\")\n                        );\n                    }\n                    return false;\n                }\n                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Acquired \" + lock);\n                }\n\n                // Since we acquired it we need to update our lock state\n                ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);", "                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Acquired \" + lock);\n                }\n\n                // Since we acquired it we need to update our lock state\n                ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);\n                if (locks == null) {\n                    locks = new ColouredList<>(4);\n                    myThreadToLocks.put(me, locks);\n                }\n                locks.add(lock);\n                lock .addLocker(me, true, isExclusive);", "                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s):\"\n                    );\n                    for (LockManagerLock l : locks) {\n                        getLogger().finer(\"  \" + l);\n                    }\n                }\n\n                // Log information if the lock wants us to", "                if (LOG.isLoggable(lock.getLogLevel())) {\n                    LOG.log(lock.getLogLevel(),\n                            \"Thread '\" + me.getName() + \"' acquired \" +\n                            how + \" \" + lock,\n                            new Throwable());\n                }\n\n                // Log each time we seem to have a \"lot\" of locks\n                if (getLogger().isLoggable(Level.FINE) && (locks.size() % 25) == 0) {\n                    getLogger().log(\n                        Level.FINE,\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s): \",\n                        new Throwable()\n                    );\n                }\n            }\n\n            // Got it\n            return true;\n        }\n        finally {\n            ourTryLockTUInstr.end(start);\n        }\n    }\n\n    /**\n     * Attempt to acquire a named lock, creating if needbe.\n     *\n     * @param lock         The lock to acquire.\n     * @param isExclusive  Whether the lock should be acquired exclusively.\n     *\n     * @throws DeadlockException if acquiring the lock would result in deadlock.\n     */\n    private void lock(final LockManagerLock lock, final boolean isExclusive)\n        throws DeadlockException\n    {\n        final String how = isExclusive ? \"exclusive\" : \"shared\";\n        final long start = ourLockInstr.start();", "                if (getLogger().isLoggable(Level.FINE) && (locks.size() % 25) == 0) {\n                    getLogger().log(\n                        Level.FINE,\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s): \",\n                        new Throwable()\n                    );\n                }\n            }\n\n            // Got it\n            return true;\n        }\n        finally {\n            ourTryLockTUInstr.end(start);\n        }\n    }\n\n    /**\n     * Attempt to acquire a named lock, creating if needbe.\n     *\n     * @param lock         The lock to acquire.\n     * @param isExclusive  Whether the lock should be acquired exclusively.\n     *\n     * @throws DeadlockException if acquiring the lock would result in deadlock.\n     */\n    private void lock(final LockManagerLock lock, final boolean isExclusive)\n        throws DeadlockException\n    {\n        final String how = isExclusive ? \"exclusive\" : \"shared\";\n        final long start = ourLockInstr.start();", "        try {\n            // By whom\n            final Thread me = currentThread();\n\n            // We do all this under the global lock for simplicity. This avoids\n            // race conditions where we the lock might be released by another\n            // user of the same virtual-thread (which is trying to tear itself\n            // down). This can happen in PJRmi where you have workers servicing\n            // requests and a worked thread might still be associated with the\n            // virtual thread even though it's returned control to the Python\n            // side. (Then the Python side makes another request using the same\n            // virtual thread and we trigger the race condition.)\n            synchronized(this) {\n                // Hello developers", "                if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().log(\n                        Level.FINEST,\n                        \"Looking to acquire \" + how + \" \" + lock,\n                        new Throwable(\"Call tree\")\n                    );\n                }\n                else if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Looking to acquire \" + how + \" \" + lock);\n                }\n\n                // If we're already holding the lock then it's trivial. It's\n                // _important_ that we make this check since lockWalksTo() relies\n                // on being called only when we are not already holding the lock in\n                // question. Also we mustn't add this lock-and-thread pair to the\n                // state more than once.", "                if (lock.isHeldByCurrentThread(isExclusive)) {\n                    // Just lock it again and we're done\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Already holding \" + how + \" \" + lock);\n                    }\n                    lock.lock(isExclusive);\n                    return;\n                }\n\n                // First, attempt to acquire the lock speculatively, if we can\n                // do this then we can avoid doing the deadlock detection. We\n                // must do this in the synchronized block since, if we are\n                // successful then it's very important that the state reflects\n                // that we are now holding the lock.\n                final boolean gotLock = lock.tryLock(isExclusive);\n\n                // If we didn't get the lock then see if acquiring it would\n                // cause a deadlock", "                if (!gotLock) {\n                    // Attempting to upgrade a shared lock to an exclusive one\n                    // will always fail, and doing so effectively deadlocks the\n                    // thread with itself\n                    if (isExclusive && lock.isHeldByCurrentThread(false)) {\n                        throw new DeadlockException(\n                            \"Attempt to upgrade lock from shared to exclusive: \" +\n                            lock\n                        );\n                    }\n\n                    // Okay, no upgrade so just do a regular deadlock check\n                    final long lwtStart = ourLockWalksToInstr.start();", "                    try {\n                        final StringBuilder sb =\n                            (ourLockWalksToSb == null) ? null\n                                                       : ourLockWalksToSb.get();\n                        if (lockWalksTo(lock, me, ColouredList.getNextColour(), sb)) {\n                            // Add the locks which we also hold, to the error\n                            // message. This can help the caller figure out what\n                            // is going on.\n                            final ColouredList<LockManagerLock> locks =\n                                myThreadToLocks.get(me);\n\n                            // Dump the current state into the logs. We don't\n                            // expect to see deadlocks happen that often and so,\n                            // when we do get them; it can be handy to know\n                            // what's going on, in addition to the information in\n                            // the exception.\n                            getLogger().warning(\n                                \"Deadlock detected in thread \" + me + \" \" +\n                                \"when acquiring \" +\n                                (isExclusive ? \"exclusive \" : \"shared \") +\n                                \"lock \" + lock + \" and holding \" +\n                                ((locks == null) ? \"[]\" : locks.toString()) +\n                                \"; \" + ((sb == null) ? \"\" : sb + \"; \") +\n                                \"myThreadToLocks = \" + myThreadToLocks\n                            );\n\n                            // Now we can throw the exception\n                            throw new DeadlockException(\n                                \"Deadlock detected in thread \" + me + \" \" +\n                                \"when acquiring \" +\n                                (isExclusive ? \"exclusive \" : \"shared \") +\n                                \"lock \" + lock + \" and holding \" +\n                                ((locks == null) ? \"[]\" : locks.toString()) +\n                                ((sb == null) ? \"\" : \": \" + sb)\n\n                            );\n                        }\n                    }\n                    finally {\n                        ourLockWalksToInstr.end(lwtStart);\n                    }\n                }\n\n                // Okay, we've either got the lock or we're going to acquire it\n                // below so update our state accordingly\n                ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);", "                if (locks == null) {\n                    locks = new ColouredList<>(4);\n                    myThreadToLocks.put(me, locks);\n                }\n                locks.add(lock);\n                lock .addLocker(me, gotLock, isExclusive);\n                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s):\"\n                    );", "                    for (LockManagerLock l : locks) {\n                        getLogger().finer(\"  \" + l);\n                    }\n                }\n\n                // Log information if the lock wants us to\n                if (LOG.isLoggable(lock.getLogLevel())) {\n                    LOG.log(lock.getLogLevel(),\n                            \"Thread '\" + me.getName() + \"' acquired \" +\n                            how + \" \" + lock,\n                            new Throwable());\n                }\n\n                // Log each time we seem to have a \"lot\" of locks", "                if (getLogger().isLoggable(Level.FINE) && (locks.size() % 25) == 0) {\n                    getLogger().log(\n                        Level.FINE,\n                        \"Thread '\" + me.getName() + \"' now holds \" +\n                        locks.size() + \" lock(s): \",\n                        new Throwable()\n                    );\n                }\n\n                // If we managed to get the lock above then we can bail at this\n                // point since the state is now updated.", "                if (gotLock) {\n                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\"Speculatively acquired \" + lock);\n                    }\n                    return;\n                }\n            }\n\n            // Okay, we don't have it already and it's safe to acquire. We must\n            // do this _outside_ the synchronized block above since we might\n            // deadlock otherwise (oh, the irony). This is fine however, since\n            // we have updated our state to reflect that we are holding this\n            // lock now.", "            if (getLogger().isLoggable(Level.FINER)) {\n                synchronized (this) {\n                    getLogger().finer(\"Locking \" + how + \" \" + lock);\n                }\n            }\n            lock.lock(isExclusive);\n            synchronized (this) {\n                // Mark this lock as actually held now. We had set \"holding\" to\n                // false above, since we had not acquired the lock at that\n                // point. Now we have it.\n                //\n                // Note that actually getting the lock and setting this value is\n                // not an atomic operation. This is okay though since nothing\n                // relies on this being the case (and it should not).\n                lock.setLockerHolding(me, isExclusive);", "                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Locked \" + how + \" \" + lock);\n                }\n            }\n        }\n        finally {\n            ourLockInstr.end(start);\n        }\n    }\n\n    /**\n     * Release a lock.\n     *\n     * @param lock         The lock to release.\n     * @param isExclusive  Whether the lock should be released exclusively.\n     *\n     * @throws IllegalMonitorStateException If the current thread does not hold\n     *                                      this lock.\n     */\n    private void unlock(final LockManagerLock lock,\n                        final boolean isExclusive)\n        throws IllegalMonitorStateException\n    {\n        final String how = isExclusive ? \"exclusive\" : \"shared\";\n        final long start = ourUnlockInstr.start();", "        try {\n            // By whom\n            final Thread me = currentThread();\n\n            // Go under the global state lock here since releasing the lock and\n            // updating the state need to be done atomically in order for the\n            // lock() code to correctly work.\n            synchronized(this) {\n                // Release the lock\n                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Releasing \" + how + \" \" + lock);\n                }\n                lock.unlock(isExclusive);", "                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Releasing \" + how + \" \" + lock);\n                }\n                lock.unlock(isExclusive);\n                if (getLogger().isLoggable(Level.FINER)) {\n                    getLogger().finer(\"Released \" + how + \" \" + lock);\n                }\n                if (LOG.isLoggable(lock.getLogLevel())) {\n                    LOG.log(lock.getLogLevel(),\n                            \"Thread '\" + me.getName() + \"' released \" +\n                            how + \" \" + lock,\n                            new Throwable());\n                }\n\n                // And update the sets, if we are no longer holding the lock", "                if (!lock.isHeldByCurrentThread(isExclusive)) {\n                    // These should never be null if we were able to lock it in the\n                    // first place but...\n                    final ColouredList<LockManagerLock> locks = myThreadToLocks.get(me);\n                    if (locks != null) {\n                        locks.remove(lock);\n                    }\n                    if (!lock.removeLocker(me, isExclusive)) {\n                        throw new IllegalMonitorStateException(\n                            \"Failed to remove holding thread \" +\n                            \"'\" + me.getName() + \"' for lock: \" + lock\n                        );\n                    }", "                    if (getLogger().isLoggable(Level.FINER)) {\n                        getLogger().finer(\n                            \"Thread '\" + me.getName() + \"' now holds \" +\n                            locks.size() + \" lock(s):\"\n                        );\n                        for (LockManagerLock l : locks) {\n                            getLogger().finer(\"  \" + l);\n                        }\n                    }\n\n                    // To avoid the maps growing without bound, we should consider\n                    // adding garbage collection here to remove threads/locks with\n                    // no corresponding sets, if:\n                    //  1. The myFooToBar maps are getting \"large\"\n                    //  2. We've not done one in the last N calls to unlock()\n                }\n            }\n        }\n        finally {\n            ourUnlockInstr.end(start);\n        }\n    }\n\n    /**\n     * See if the given lock walks to the given thread. That is to say, can we\n     * navigate the graph comprised of locks-to-threads and thread-to-locks\n     * edges to get from a lock to a thread. We only traverse edges where the\n     * thread is actually blocked on acquiring a lock, since that is the only\n     * route by which we can encounter deadlock.\n     *\n     * <p>It's important that this method is called before we update the state with\n     * the thread and lock being passed in.\n     *\n     * @param lock   The lock we are walking from.\n     * @param thread The thread which we are trying to walk to.\n     * @param colour The colour we're using to mark lists which we've seen.\n     * @param sb     The buffer to use for returning a helpful message in.\n     *\n     * @return whether a loop was detected.\n     */\n    private boolean lockWalksTo(final LockManagerLock lock,\n                                final Thread          thread,\n                                final int             colour,\n                                final StringBuilder   sb)\n    {\n        // We are effectively edge-chasing in a directed dependency graph here.\n        // There exists a bidirectional thread-lock edge in the graph if a\n        // thread holds a lock; if a thread is blocked on acquiring a lock then\n        // there is a unidirectional edge from thread-to-lock.\n        //\n        // We will start at the given lock and look at all the threads which\n        // currently are blocked on acquiring that lock. If we find the thread\n        // we're looking for in this lot then we're done. Otherwise, for each of\n        // those threads we see what locks it is trying to acquire, and recurse.\n        //\n        // An example, imagine that T1 holds L1 and is blocked trying to acquire\n        // L2, and that T2 holds L2, and we enter this method at the moment that\n        // T2 is trying to acquire L1. Here we are looking to find a path to T2\n        // from L1, via blocked threads by calling lockWalksTo(L1, T2, colour):\n        //\n        //                              [wants]\n        //                       [L2] < = = = = = [T1]\n        //                        ^                 ^\n        //                        |                 |\n        //                [holds] |                 | [holds]\n        //                        |                 |\n        //                        v                 v\n        //                       [T2] = = = = = > [L1]\n        //                              [wants]\n        //\n        // So, in the above we walk from L1 to T1, since T1 holds L1 (and so\n        // there is a bidirectional edge between them). We then walk from, T1 to\n        // L2 (since there is a unidirectional edge from T1 to L2, as T1 is\n        // blocked on acquiring L2). Now we also have a bidirectional edge from\n        // L2 to T2, and so we walk from L2 to T2. At this point we have found\n        // T2, which was the thread we were looking for.\n        //\n        // It's similar for when we have three threads and three locks.\n        //\n        // Finally, note that we only care about whether a thread is blocked on\n        // getting a lock, not what the type of lock is. This is because, if a\n        // thread holds a lock which another is blocked on, it doesn't matter on\n        // how it's being held, it's still a blocker.\n\n        // Look at the threads which are holding this lock\n        final ColouredList<LockManagerLock.Locker> lockers = lock.getLockers();\n\n        // If we resolve to nothing then we're done", "        if (lockers.isEmpty()) {\n            if (getLogger().isLoggable(Level.FINEST)) {\n                getLogger().finest(lock + \" is not held by any threads\");\n            }\n            return false;\n        }\n\n        // Say that we've seen this set of threads now. If we discover that we\n        // have looked here already then we can bail at this point.\n        if (!lockers.setColour(colour)) {\n            if (getLogger().isLoggable(Level.FINEST)) {\n                getLogger().finest(lock + \"'s threads have already been checked\");\n            }\n            return false;\n        }\n\n        // First we see if the thread we want is in this list; this is quicker\n        // than recursing first and finding it later on.", "        if (!lockers.setColour(colour)) {\n            if (getLogger().isLoggable(Level.FINEST)) {\n                getLogger().finest(lock + \"'s threads have already been checked\");\n            }\n            return false;\n        }\n\n        // First we see if the thread we want is in this list; this is quicker\n        // than recursing first and finding it later on.\n        for (int i=0; i < lockers.size(); i++) {\n            if (lockers.get(i).getThread().equals(thread)) {", "        for (int i=0; i < lockers.size(); i++) {\n            if (lockers.get(i).getThread().equals(thread)) {\n                if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().finest(\n                        lock + \" walked to thread '\" + thread.getName() + \"'\"\n                    );\n                }\n                return true;\n            }\n        }\n\n        // Okay, time to do the recursive walk", "        for (int i=0; i < lockers.size(); i++) {\n            // Examine all the locks upon which each candidate thread is blocked\n            // acquiring\n            final LockManagerLock.Locker locker = lockers.get(i);\n            final ColouredList<LockManagerLock> locks =\n                myThreadToLocks.get(locker.getThread());\n\n            // If there's anything to inspect then say we've seen these now,\n            // checking to see if we already have at the same time.\n            if (locks != null && !locks.isEmpty() && locks.setColour(colour)) {\n                // We have some locks which we haven't checked before so we need\n                // to inspect them all", "            if (locks != null && !locks.isEmpty() && locks.setColour(colour)) {\n                // We have some locks which we haven't checked before so we need\n                // to inspect them all\n                if (getLogger().isLoggable(Level.FINEST)) {\n                    getLogger().finest(\n                        \"Walking locks of thread \" +\n                        \"'\" + locker.getThread().getName() + \"': \" + locks\n                    );\n                }\n\n                // Recurse on blocked threads", "                for (int j=0; j < locks.size(); j++) {\n                    final LockManagerLock lml = locks.get(j);\n                    if (lml.isThreadAwaiting(locker.getThread())) {\n                        if (getLogger().isLoggable(Level.FINER)) {\n                            getLogger().finer(\n                                \"Thread '\" + locker.getThread().getName() + \"' \" +\n                                \"is blocked acquiring \" + lml\n                            );\n                        }\n\n                        // Update the StringBuilder with the details\n                        int sbLen = 0;", "                        if (sb != null) {\n                            sbLen = sb.length();\n                            if (sbLen > 0) {\n                                sb.append(\"; \");\n                            }\n                            sb.append(locker.getThread().getName())\n                              .append(\" is blocked acquiring \")\n                              .append(lml.getName());\n                        }\n\n                        // And see if we want to the lock from here", "                        if (lockWalksTo(lml, thread, colour, sb)) {\n                            return true;\n                        }\n                        else if (sb != null) {\n                            // We didn't, so the sb can forget this blocking\n                            // information\n                            sb.setLength(sbLen);\n                        }\n                    }\n                    else if (getLogger().isLoggable(Level.FINEST)) {\n                        getLogger().finest(\n                            \"Thread '\" + locker.getThread().getName() + \"' \" +\n                            \"is not blocked acquiring \" + lml + \" \" +\n                            \"so not walking to it\"\n                        );\n                    }\n                }\n            }\n        }\n\n        // If we got here, then no deadlock was detected", "                    else if (getLogger().isLoggable(Level.FINEST)) {\n                        getLogger().finest(\n                            \"Thread '\" + locker.getThread().getName() + \"' \" +\n                            \"is not blocked acquiring \" + lml + \" \" +\n                            \"so not walking to it\"\n                        );\n                    }\n                }\n            }\n        }\n\n        // If we got here, then no deadlock was detected", "        if (getLogger().isLoggable(Level.FINEST)) {\n            getLogger().finest(\n                \"Thread '\" + thread.getName() + \"' \" +\n                \"was not found from lock \" + lock\n            );\n        }\n        return false;\n    }\n}\n"]}
