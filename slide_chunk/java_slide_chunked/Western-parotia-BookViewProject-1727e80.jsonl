{"filename": "gpu_test/src/test/java/com/juziml/content/gpu_test/ExampleUnitTest.java", "chunked_list": ["package com.juziml.content.gpu_test;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>", " *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() {\n        assertEquals(4, 2 + 2);\n    }\n}"]}
{"filename": "gpu_test/src/main/java/com/juziml/content/gpu_test/GpuTestCurlAnimView.java", "chunked_list": ["package com.juziml.content.gpu_test;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;", "import android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Region;\nimport android.util.AttributeSet;\nimport android.view.View;\n\nimport androidx.annotation.Nullable;\n\n/**\n * create by zhusw on 2020-07-29 10:54", "/**\n * create by zhusw on 2020-07-29 10:54\n */\npublic class GpuTestCurlAnimView extends View {\n\n    Paint pointPaint;\n    FPoint a, f, g, e, h, c, j, b, k, d, i;\n\n    int width;\n    int height;\n\n    //\u56fe\u5f62\n    Paint pathAPaint;\n    Path pathA;\n    Bitmap holderBitmap;\n    Canvas bitmapCanvas = new Canvas();\n\n    Paint pathCPaint;\n    Path pathC;\n    Paint pathBPaint;\n    Path pathB;\n    PorterDuffXfermode xfDST_ATOP = new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP);\n\n    public GpuTestCurlAnimView(Context context) {\n        this(context, null);\n    }\n\n\n    public GpuTestCurlAnimView(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        width = w;\n        height = h;\n        a.setXY(-1, -1);\n        holderBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n\n    }\n\n    public GpuTestCurlAnimView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        pointPaint = new Paint();\n        pointPaint.setColor(Color.RED);\n        pointPaint.setTextSize(25);\n        a = new FPoint();\n        f = new FPoint();\n        g = new FPoint();\n        e = new FPoint();\n        h = new FPoint();\n        c = new FPoint();\n        j = new FPoint();\n        b = new FPoint();\n        k = new FPoint();\n        d = new FPoint();\n        i = new FPoint();\n\n\n        pathAPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        pathAPaint.setColor(Color.GREEN);\n        pathA = new Path();\n\n        pathCPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        pathCPaint.setColor(Color.YELLOW);\n        pathCPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));//\u6d88\u9664c\u533a \u4e0ea\u533a\u91cd\u53e0\u90e8\u5206,\u539f\u6587\u6ce8\u91ca\uff1a\u4e22\u5f03\u539f\u56fe\u60f3\u8986\u76d6\u76ee\u6807\u56fe\u50cf\u7684\u533a\u57df\n        pathC = new Path();\n\n        pathBPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        pathBPaint.setColor(Color.BLUE);\n        pathB = new Path();\n    }\n", "    public void flipPrepare(float x, float y) {\n        if (y < height / 2) {\n            f.setXY(width, 0);\n        } else {\n            f.setXY(width, height);\n        }\n    }\n\n    public void flipSetToDefault() {\n        a.setXY(-1, -1);\n        f.setXY(0, 0);\n        calculatePointXY(a, f);\n        postInvalidate();\n    }\n", "    public void flipSetToDefault() {\n        a.setXY(-1, -1);\n        f.setXY(0, 0);\n        calculatePointXY(a, f);\n        postInvalidate();\n    }\n\n    public void flipCurl(float x, float y) {\n        a.x = x;\n        a.y = y;\n        calculatePointXY(a, f);\n\n        //\u4fee\u6b63c\u70b9\u8303\u56f4 \u4e0d\u53ef\u5c0f\u4e8e0", "        if (calculateCxRange(a.x, a.y, f) < 0) {\n            calcPointAByTouchPoint();\n            calculatePointXY(a, f);\n        }\n        postInvalidate();\n    }\n\n    private float calculateCxRange(float ax, float ay, FPoint f) {\n        float gx = (ax + f.x) / 2;\n        float gy = (ay + f.y) / 2;\n        float ex = gx - (f.y - gy) * (f.y - gy) / (f.x - gx);\n        return ex - (f.x - ex) / 2;\n    }\n\n    /**\n     * \u5982\u679cc\u70b9x\u5750\u6807\u5c0f\u4e8e0,\u6839\u636e\u89e6\u6478\u70b9\u91cd\u65b0\u6d4b\u91cfa\u70b9\u5750\u6807\n     */\n    private void calcPointAByTouchPoint() {\n        float w0 = width - c.x;\n        float w1 = Math.abs(f.x - a.x);\n        float w2 = width * w1 / w0;\n        a.x = Math.abs(f.x - w2);\n        float h1 = Math.abs(f.y - a.y);\n        float h2 = w2 * h1 / w1;\n        a.y = Math.abs(f.y - h2);\n    }\n\n    @Override", "    public void onDrawForeground(Canvas canvas) {\n        super.onDrawForeground(canvas);\n        //\u628a\u70b9\u7ed8\u5236\u5728\u524d\u666f\u4e0a \u65b9\u4fbf\u89c2\u5bdf\n        drawPoint(canvas);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (a.x == -1 && a.y == -1) {\n            canvas.drawPath(getDefaultPath(), pathAPaint);\n        } else {\n            Path pathA = getPathAFromRightTop();", "        if (a.x == -1 && a.y == -1) {\n            canvas.drawPath(getDefaultPath(), pathAPaint);\n        } else {\n            Path pathA = getPathAFromRightTop();\n            if (f.x == width && f.y == height) {\n                pathA = getPathAFromRightBottom();\n            }\n            Path pathC = getPathC();\n            canvas.drawPath(pathC, pathCPaint);//\u5148\u7ed9C\u533a\u753b\u4e0a\u5e95\u8272\n            canvas.drawPath(pathA, pathAPaint);//\u5148\u7ed9A\u533a\u753b\u4e0a\u5e95\u8272\n\n            canvas.save();//\u6263\u51faB\u533a\n            canvas.clipPath(pathC, Region.Op.DIFFERENCE);\n            canvas.clipPath(pathA, Region.Op.DIFFERENCE);\n            canvas.drawPath(getPathB(), pathBPaint);\n            canvas.restore();\n        }\n    }\n", "    public Path getDefaultPath() {\n        pathA.reset();\n        pathA.lineTo(0, height);\n        pathA.lineTo(width, height);\n        pathA.lineTo(width, 0);\n        pathA.close();\n        return pathA;\n    }\n\n    /**\n     * \u4ee5\u53f3\u4e0b\u89d2\u4e3a\u89e6\u53d1\u8d77\u70b9\n     *\n     * @return\n     */\n    private Path getPathAFromRightBottom() {\n        pathA.reset();\n        //\u5212\u7ebf\u4ece 0\uff0c0\u5f00\u59cb\n        pathA.lineTo(0, height);//\u5212\u7ebf\u5230\u5de6\u4e0b\u89d2\n        pathA.lineTo(c.x, c.y);//\u5212\u7ebf\u5230c\u70b9\n        pathA.quadTo(e.x, e.y, b.x, b.y);//\u4ee5c\u4e3a\u8d77\u70b9\uff0cb\u4e3a\u7ec8\u70b9\uff0ce\u4e3a\u52a8\u70b9 \u753b\u66f2\u7ebf\n        pathA.lineTo(a.x, a.y);\n        pathA.lineTo(k.x, k.y);\n        pathA.quadTo(h.x, h.y, j.x, j.y);//\u4ee5k\u4e3a\u8d77\u70b9\uff0cj\u4e3a\u7ec8\u70b9 h\u4e3a\u52a8\u70b9 \u753b\u66f2\u7ebf\n        pathA.lineTo(width, 0);\n        pathA.close();\n        return pathA;\n    }\n\n    private Path getPathAFromRightTop() {\n        pathA.reset();\n        pathA.lineTo(c.x, c.y);//\u5212\u7ebf\u5230c\n        pathA.quadTo(e.x, e.y, b.x, b.y);//c-b\u7684\u66f2\u7ebf\n        pathA.lineTo(a.x, a.y);//\u5212\u7ebf\u5230a\n        pathA.lineTo(k.x, k.y);//\u5212\u7ebf\u5230k\n        pathA.quadTo(h.x, h.y, j.x, j.y);//k-j\u7684\u66f2\u7ebf\n        pathA.lineTo(width, height);\n        pathA.lineTo(0, height);\n        pathA.close();\n        return pathA;\n    }\n\n\n    private Path getPathC() {\n        pathC.reset();\n        pathC.moveTo(d.x, d.y);\n        pathC.lineTo(b.x, b.y);\n        pathC.lineTo(a.x, a.y);\n        pathC.lineTo(k.x, k.y);\n        pathC.lineTo(i.x, i.y);\n        pathC.close();\n        return pathC;\n    }\n\n    private Path getPathB() {\n        pathB.reset();\n        pathB.lineTo(0, height);\n        pathB.lineTo(width, height);\n        pathB.lineTo(width, 0);\n        pathB.close();\n        return pathB;\n    }\n\n\n    private void drawPoint(Canvas canvas) {\n        canvas.drawText(\"a\", a.x, a.y, pointPaint);\n\n        canvas.drawText(\"f\", f.x, f.y, pointPaint);\n\n        canvas.drawText(\"g\", g.x, g.y, pointPaint);\n\n        canvas.drawText(\"e\", e.x, e.y, pointPaint);\n        canvas.drawText(\"h\", h.x, h.y, pointPaint);\n\n        canvas.drawText(\"c\", c.x, c.y, pointPaint);\n        canvas.drawText(\"j\", j.x, j.y, pointPaint);\n\n        canvas.drawText(\"b\", b.x, b.y, pointPaint);\n        canvas.drawText(\"k\", k.x, k.y, pointPaint);\n\n        canvas.drawText(\"d\", d.x, d.y, pointPaint);\n        canvas.drawText(\"i\", i.x, i.y, pointPaint);\n\n\n    }\n\n    /**\n     * \u8ba1\u7b97\u5207\u70b9\u5750\u6807\uff0c\u8fd9\u91cc\u5c31\u6ca1\u6709\u63a8\u5bfc\u516c\u5f0f\u4e86\uff0c\u76f4\u63a5\u62ff\u6765\u7528\u4e86\n     *\n     * @param lineOne_My_pointOne\n     * @param lineOne_My_pointTwo\n     * @param lineTwo_My_pointOne\n     * @param lineTwo_My_pointTwo\n     * @return\n     */\n    private FPoint getIntersectionPoint(FPoint lineOne_My_pointOne,\n                                        FPoint lineOne_My_pointTwo,\n                                        FPoint lineTwo_My_pointOne,\n                                        FPoint lineTwo_My_pointTwo) {\n        float x1, y1, x2, y2, x3, y3, x4, y4;\n        x1 = lineOne_My_pointOne.x;\n        y1 = lineOne_My_pointOne.y;\n        x2 = lineOne_My_pointTwo.x;\n        y2 = lineOne_My_pointTwo.y;\n        x3 = lineTwo_My_pointOne.x;\n        y3 = lineTwo_My_pointOne.y;\n        x4 = lineTwo_My_pointTwo.x;\n        y4 = lineTwo_My_pointTwo.y;\n\n        float pointX = ((x1 - x2) * (x3 * y4 - x4 * y3)\n                - (x3 - x4) * (x1 * y2 - x2 * y1)) / ((x3 - x4)\n                * (y1 - y2) - (x1 - x2) * (y3 - y4));\n        float pointY = ((y1 - y2) * (x3 * y4 - x4 * y3)\n                - (x1 * y2 - x2 * y1) * (y3 - y4)) / ((y1 - y2)\n                * (x3 - x4) - (x1 - x2) * (y3 - y4));\n\n        return new FPoint(pointX, pointY);\n    }\n\n    /**\n     * \u8ba1\u7b97\u5404\u70b9\u5750\u6807\n     */\n    private void calculatePointXY(FPoint a, FPoint f) {\n        g.x = (a.x + f.x) / 2;\n        g.y = (a.y + f.y) / 2;\n\n        e.x = g.x - (f.y - g.y) * (f.y - g.y) / (f.x - g.x);\n        e.y = f.y;\n\n        h.x = f.x;\n        h.y = g.y - (f.x - g.x) * (f.x - g.x) / (f.y - g.y);\n\n        c.x = e.x - (f.x - e.x) / 2;\n        c.y = f.y;\n\n        j.x = f.x;\n        j.y = h.y - (f.y - h.y) / 2;\n\n        b = getIntersectionPoint(a, e, c, j);\n        k = getIntersectionPoint(a, h, c, j);\n\n        d.x = (c.x + 2 * e.x + b.x) / 4;\n        d.y = (2 * e.y + c.y + b.y) / 4;\n\n        i.x = (j.x + 2 * h.x + k.x) / 4;\n        i.y = (2 * h.y + j.y + k.y) / 4;\n    }\n\n}\n"]}
{"filename": "gpu_test/src/main/java/com/juziml/content/gpu_test/FPoint.java", "chunked_list": ["package com.juziml.content.gpu_test;\n\n/**\n * create by zhusw on 2020-07-30 17:05\n */\npublic class FPoint {\n    public float x, y;\n\n    public FPoint() {\n    }\n\n    public FPoint(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n", "    public void setXY(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n"]}
{"filename": "gpu_test/src/main/java/com/juziml/content/gpu_test/GpuTestAct.java", "chunked_list": ["package com.juziml.content.gpu_test;\n\nimport android.os.Bundle;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport androidx.annotation.Nullable;\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport com.juziml.content.R;", "\nimport com.juziml.content.R;\n\n/**\n * create by zhusw on 2020-07-29 10:55\n */\npublic class GpuTestAct extends AppCompatActivity {\n\n    GpuTestCurlAnimView gpuTestCurlAnimView;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.act_gputest);\n        gpuTestCurlAnimView = findViewById(R.id.curlView);\n\n        gpuTestCurlAnimView.setOnTouchListener(new View.OnTouchListener() {\n            @Override", "            public boolean onTouch(View v, MotionEvent event) {\n                switch (event.getAction()) {\n                    case MotionEvent.ACTION_DOWN:\n                        gpuTestCurlAnimView.flipPrepare(event.getRawX(), event.getRawY());\n                        break;\n                    case MotionEvent.ACTION_MOVE:\n                        gpuTestCurlAnimView.flipCurl(event.getRawX(), event.getRawY());\n                        break;\n                    case MotionEvent.ACTION_UP:\n                    case MotionEvent.ACTION_CANCEL:\n                        gpuTestCurlAnimView.flipSetToDefault();\n                        break;\n                    default:\n                        break;\n                }\n                return true;\n            }\n        });\n    }\n\n\n}\n"]}
{"filename": "gpu_test/src/androidTest/java/com/juziml/content/gpu_test/ExampleInstrumentedTest.java", "chunked_list": ["package com.juziml.content.gpu_test;\n\nimport static org.junit.Assert.*;\n\nimport android.content.Context;\nimport android.support.test.InstrumentationRegistry;\nimport android.support.test.runner.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;", "import org.junit.Test;\nimport org.junit.runner.RunWith;\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test", "@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getTargetContext();\n\n        assertEquals(\"com.lzx.content.gpu_test\", appContext.getPackageName());\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/BookMockData.java", "chunked_list": ["package com.juziml.read.business;\n\n/**\n * create by zhusw on 2020-03-27 14:51\n */\npublic class BookMockData {\n    public String content = \"\u7531\u4e8e\u56fd\u5916\u5927\u90e8\u5206\u516c\u53f8\u4ecd\u5728\u8fdc\u7a0b\u529e\u516c\uff0c\u6240\u4ee5\u90e8\u5206\u670d\u52a1\u4e0e\u75ab\u60c5\u4e4b\u524d\u76f8\u6bd4\u6709\u6240\u4e0b\u964d\uff0c\u6bd4\u5982 Netflix\u3001YouTube\u3001Facebook \u5148\u540e\u5ba3\u5e03\u4e0b\u8c03\u6b27\u6d32\u89c6\u9891\u6d41\u8d28\u91cf\uff0c\u4ee5\u5e2e\u52a9\u7f13\u89e3\u65b0\u51a0\u75c5\u6bd2\u75ab\u60c5\u671f\u95f4\u4efb\u4f55\u6f5c\u5728\u7684\u7f51\u7edc\u62e5\u5835\uff0c\u8c37\u6b4c\u6b64\u524d\u5ba3\u5e03\u6682\u505c Chrome \u6d4f\u89c8\u5668\u66f4\u65b0\u7b49\u3002\u7136\u800c\uff0c\u9ed1\u5ba2\u5728\u6b64\u671f\u95f4\u5374\u52a8\u4f5c\u9891\u9891\uff0c\u5148\u540e\u66dd\u51fa\u4e16\u536b\u7ec4\u7ec7\u906d\u5230\u4e0d\u660e\u9ed1\u5ba2\u653b\u51fb\u3001GitHub pages \u88ab\u653b\u51fb\u7b49\u6d88\u606f\u3002\" +\n            \"\\n\u6b64\u524d\uff0c\u4e1a\u5185\u5c31\u6709\u4e13\u5bb6\u9884\u6d4b\u8fd1\u671f\u53ef\u80fd\u4f1a\u6709\u5f88\u591a\u653b\u51fb\u51fa\u73b0\uff0c\u5c24\u5176\u662f\u533b\u7597\u884c\u4e1a\u3002\u533b\u7597\u673a\u6784\u4e00\u822c\u9632\u5fa1\u63aa\u65bd\u6709\u9650\uff0c\u4e00\u65e6\u88ab\u653b\u51fb\u4f1a\u9020\u6210\u4e25\u91cd\u540e\u679c\u3002\u968f\u7740\u66f4\u591a\u7684\u9ed1\u5ba2\u7ec4\u7ec7\u5728\u6b64\u523b\u5173\u6ce8\u5230\u76f8\u5173\u70ed\u70b9\uff0c\u5f88\u6709\u53ef\u80fd\u4f1a\u6709\u66f4\u591a\u653b\u51fb\u624b\u6cd5\u51fa\u73b0\u3002\u5982\u679c\u518d\u51fa\u73b0\u50cf\u53bb\u5e74\u9488\u5bf9\u533b\u7597\u884c\u4e1a\u7684\u9488\u5bf9\u6027\u52d2\u7d22\u653b\u51fb\u7684\u8bdd\uff0c\u5c06\u4f1a\u5bf9\u76f8\u5173\u76ee\u6807\u9020\u6210\u707e\u96be\u6027\u540e\u679c\uff0c\u53ef\u76f4\u63a5\u9020\u6210\u6574\u4e2a\u533b\u9662\u4e1a\u52a1\u505c\u6446\u3002\u5982\u679c\u76f8\u5173\u7684\u653b\u51fb\u53d1\u751f\u5728\u75ab\u60c5\u4e25\u91cd\u5730\u533a\u7684\u8bdd\uff0c\u5176\u540e\u679c\u4e0d\u582a\u60f3\u8c61\u3002\u5efa\u8bae\u91c7\u53d6\u4ee5\u4e0b\u9632\u8303\u63aa\u65bd\uff1a\" +\n            \"1\u3001\u53ca\u65f6\u5347\u7ea7\u64cd\u4f5c\u7cfb\u7edf\u4ee5\u53ca\u5e94\u7528\u8f6f\u4ef6\uff0c\u6253\u5168\u8865\u4e01\uff0c\u5c24\u5176\u662f MS17-010\u3001CVE-2019-0708 \u7b49\u9ad8\u5371\u6f0f\u6d1e\u7684\u8865\u4e01\u3002\u7531\u4e8e Windows 7 \u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u505c\u6b62\u63a8\u9001\u66f4\u65b0\u8865\u4e01\uff0c\u5efa\u8bae\u6709\u6761\u4ef6\u7684\u66f4\u65b0\u5230 Windows 10 \u64cd\u4f5c\u7cfb\u7edf\u3002\\n\" +\n            \"\\n\" +\n            \"2\u3001\u53ca\u65f6\u66f4\u65b0\u5df2\u90e8\u7f72\u7684\u7ec8\u7aef\u3001\u8fb9\u754c\u9632\u62a4\u4ea7\u54c1\u89c4\u5219\u3002\\n\" +\n            \"\\n\" +\n            \"3\u3001\u5c3d\u91cf\u51cf\u5c11\u5404\u79cd\u5916\u90e8\u670d\u52a1\u7684\u66b4\u9732\u9762\uff08\u5982 RDP\uff0cVNC \u7b49\u8fdc\u7a0b\u670d\u52a1\uff09\uff0c\u5982\u679c\u4e00\u5b9a\u8981\u5f00\u542f\u7684\u8bdd\uff0c\u9700\u8981\u8bbe\u7f6e\u767d\u540d\u5355\u8bbf\u95ee\u7b56\u7565\uff0c\u8bbe\u7f6e\u8db3\u591f\u5f3a\u58ee\u7684\u767b\u9646\u5bc6\u7801\uff0c\u907f\u514d\u9ed1\u5ba2\u5229\u7528\u8fdc\u7a0b\u670d\u52a1\u653b\u5165\u3002\\n\" +\n            \"\\n\" +\n            \"4\u3001\u589e\u5f3a\u4eba\u5458\u7684\u7f51\u7edc\u5b89\u5168\u610f\u8bc6\uff0c\u4e0d\u6253\u5f00\u4e0d\u660e\u90ae\u4ef6\uff0c\u90ae\u4ef6\u4e2d\u7684\u4e0d\u660e\u94fe\u63a5\u3001\u9644\u4ef6\u7b49\u3002\\n\" +\n            \"\\n\" +\n            \"5\u3001\u5e38\u7528\u529e\u516c\u8f6f\u4ef6\u5e94\u4fdd\u6301\u4e25\u683c\u7684\u5b89\u5168\u7b56\u7565\uff0c\u5982\u7981\u6b62\u8fd0\u884c Office \u5b8f\u7b49\u3002\\n\" +\n            \"\\n\" +\n            \"\u5f88\u591a\u4f01\u4e1a\u7eb7\u7eb7\u5f00\u59cb\u8fdc\u7a0b\u529e\u516c\u6a21\u5f0f\uff0c\u9700\u8981\u5bf9\u66b4\u9732\u5728\u4e92\u8054\u7f51\u4e0a\u7684\u4e3b\u673a\u5e94\u91c7\u53d6\u4e00\u4e9b\u5fc5\u8981\u7684\u9632\u8303\u63aa\u65bd\u3002\\n\" +\n            \"\\n\" +\n            \"1\u3001\u53ca\u65f6\u5347\u7ea7\u76f8\u5173\u4e3b\u673a\u7684\u8865\u4e01\uff0c\u5c24\u5176\u662f 2019 \u5e74\u51fa\u73b0\u7684 CVE-2019-0708 \u7b49\u4e00\u7cfb\u5217 RDP \u6f0f\u6d1e\u3002\\n\" +\n            \"\\n\" +\n            \"2\u3001\u8bbe\u7f6e\u8db3\u591f\u5f3a\u58ee\u7684\u767b\u9646\u5bc6\u7801\uff0c\u5e76\u5f00\u542f\u5f3a\u5236\u8eab\u4efd\u8ba4\u8bc1\uff0c\u907f\u514d\u9ed1\u5ba2\u5229\u7528\u8fdc\u7a0b\u670d\u52a1\u653b\u5165\u3002\";\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/anim/AnimHelper.java", "chunked_list": ["package com.juziml.read.business.read.anim;\n\nimport android.graphics.drawable.GradientDrawable;\n\n/**\n * create by zhusw on 2020-08-06 15:53\n */\npublic final class AnimHelper {\n\n    public final static float MOVE_SLOP = 1;\n", "    public final static float MOVE_SLOP = 1;\n\n    public final static int SLID_DIRECTION_UNKNOWN = 0;\n\n    public final static int SLID_DIRECTION_LEFT = 1;\n\n    public final static int SLID_DIRECTION_RIGHT = 2;\n\n    public final static int RELAY_ANIM_DURATION = 400;\n    public final static int CANCEL_ANIM_DURATION = 200;\n\n    private GradientDrawable topLeftGradientDrawable;\n    private GradientDrawable topRightGradientDrawable;\n\n    private GradientDrawable bottomLeftGradientDrawable;\n    private GradientDrawable bottomRightGradientDrawable;\n\n    private GradientDrawable topBGradientDrawable;\n    private GradientDrawable bottomBGradientDrawable;\n\n    private GradientDrawable topCGradientDrawable;\n    private GradientDrawable bottomCGradientDrawable;\n\n    private GradientDrawable coverGradientDrawable;\n\n    public AnimHelper() {\n        initGradient();\n    }\n\n    private void initGradient() {\n        int deepColor = 0x33333333;\n        int lightColor = 0x01333333;\n        int[] gradientColors = new int[]{lightColor, deepColor};//\u6e10\u53d8\u989c\u8272\u6570\u7ec4\n        topLeftGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topLeftGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomLeftGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomLeftGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x22333333;\n        lightColor = 0x01333333;\n        gradientColors = new int[]{deepColor, lightColor, lightColor};\n        topRightGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.BOTTOM_TOP, gradientColors);\n        topRightGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomRightGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, gradientColors);\n        bottomRightGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x55111111;\n        lightColor = 0x00111111;\n        gradientColors = new int[]{deepColor, lightColor};\n        topBGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topBGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomBGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomBGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n\n        deepColor = 0x55333333;\n        lightColor = 0x00333333;\n        gradientColors = new int[]{lightColor, deepColor};\n        topCGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topCGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomCGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomCGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x55333333;\n        lightColor = 0x00333333;\n        gradientColors = new int[]{deepColor, lightColor};\n        coverGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        coverGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n    }\n\n", "    public final static int RELAY_ANIM_DURATION = 400;\n    public final static int CANCEL_ANIM_DURATION = 200;\n\n    private GradientDrawable topLeftGradientDrawable;\n    private GradientDrawable topRightGradientDrawable;\n\n    private GradientDrawable bottomLeftGradientDrawable;\n    private GradientDrawable bottomRightGradientDrawable;\n\n    private GradientDrawable topBGradientDrawable;\n    private GradientDrawable bottomBGradientDrawable;\n\n    private GradientDrawable topCGradientDrawable;\n    private GradientDrawable bottomCGradientDrawable;\n\n    private GradientDrawable coverGradientDrawable;\n\n    public AnimHelper() {\n        initGradient();\n    }\n\n    private void initGradient() {\n        int deepColor = 0x33333333;\n        int lightColor = 0x01333333;\n        int[] gradientColors = new int[]{lightColor, deepColor};//\u6e10\u53d8\u989c\u8272\u6570\u7ec4\n        topLeftGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topLeftGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomLeftGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomLeftGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x22333333;\n        lightColor = 0x01333333;\n        gradientColors = new int[]{deepColor, lightColor, lightColor};\n        topRightGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.BOTTOM_TOP, gradientColors);\n        topRightGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomRightGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, gradientColors);\n        bottomRightGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x55111111;\n        lightColor = 0x00111111;\n        gradientColors = new int[]{deepColor, lightColor};\n        topBGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topBGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomBGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomBGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n\n        deepColor = 0x55333333;\n        lightColor = 0x00333333;\n        gradientColors = new int[]{lightColor, deepColor};\n        topCGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        topCGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        bottomCGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, gradientColors);\n        bottomCGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n\n        deepColor = 0x55333333;\n        lightColor = 0x00333333;\n        gradientColors = new int[]{deepColor, lightColor};\n        coverGradientDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, gradientColors);\n        coverGradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n    }\n\n", "    public GradientDrawable getTopLeftGradientDrawable() {\n        return topLeftGradientDrawable;\n    }\n\n    public GradientDrawable getTopRightGradientDrawable() {\n        return topRightGradientDrawable;\n    }\n\n    public GradientDrawable getBottomLeftGradientDrawable() {\n        return bottomLeftGradientDrawable;\n    }\n", "    public GradientDrawable getBottomLeftGradientDrawable() {\n        return bottomLeftGradientDrawable;\n    }\n\n    public GradientDrawable getBottomRightGradientDrawable() {\n        return bottomRightGradientDrawable;\n    }\n\n    public GradientDrawable getTopBGradientDrawable() {\n        return topBGradientDrawable;\n    }\n", "    public GradientDrawable getTopBGradientDrawable() {\n        return topBGradientDrawable;\n    }\n\n    public GradientDrawable getBottomBGradientDrawable() {\n        return bottomBGradientDrawable;\n    }\n\n    public GradientDrawable getTopCGradientDrawable() {\n        return topCGradientDrawable;\n    }\n", "    public GradientDrawable getTopCGradientDrawable() {\n        return topCGradientDrawable;\n    }\n\n    public GradientDrawable getBottomCGradientDrawable() {\n        return bottomCGradientDrawable;\n    }\n\n    public GradientDrawable getCoverGradientDrawable() {\n        return coverGradientDrawable;\n    }\n}\n", "    public GradientDrawable getCoverGradientDrawable() {\n        return coverGradientDrawable;\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/anim/IAnimationEffecter.java", "chunked_list": ["package com.juziml.read.business.read.anim;\n\nimport android.graphics.Canvas;\nimport android.view.MotionEvent;\n\n/**\n * create by zhusw on 2020-08-24 14:05\n */\npublic interface IAnimationEffecter {\n\n    void onScroll();\n\n    void handlerEvent(MotionEvent event);\n\n    void draw(Canvas canvas);\n\n    boolean animInEffect();\n\n    void onViewSizeChanged(int vWidth, int vHeight);\n\n    void onViewAttachedToWindow();\n\n    void onViewDetachedFromWindow();\n}\n", "public interface IAnimationEffecter {\n\n    void onScroll();\n\n    void handlerEvent(MotionEvent event);\n\n    void draw(Canvas canvas);\n\n    boolean animInEffect();\n\n    void onViewSizeChanged(int vWidth, int vHeight);\n\n    void onViewAttachedToWindow();\n\n    void onViewDetachedFromWindow();\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/anim/CoverAnimationEffecter.java", "chunked_list": ["package com.juziml.read.business.read.anim;\n\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.RectF;\nimport android.graphics.drawable.GradientDrawable;\nimport android.view.MotionEvent;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.Scroller;", "import android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.Scroller;\n\nimport com.juziml.read.business.read.view.PuppetView;\nimport com.juziml.read.utils.DLog;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**", "\n/**\n * create by zhusw on 2020-08-24 14:06\n */\npublic class CoverAnimationEffecter implements IAnimationEffecter {\n    private final static int DOWN_AREA_NONE = -1;\n    private final static int DOWN_AREA_MENU = 1;\n    private final static int DOWN_AREA_LEFT = 2;\n    private final static int DOWN_AREA_RIGHT = 3;\n\n    int vWidth = 1;\n    int vHeight = 1;\n    private final PuppetView readAnimView;\n\n    private boolean isCancelFlip = false;\n\n    private boolean coverAnimationRunning = false;\n\n    private boolean isTouching = false;\n\n    private final Scroller scroller;\n    private final ScrollRunnable scrollRunnable;\n    private final RectF menuBounds;\n\n    private final Path pathA;\n    private final Path pathB;\n    private final Paint paint;\n    private final int shadowWidth;\n\n    public CoverAnimationEffecter(PuppetView readAnimView) {\n        this.readAnimView = readAnimView;\n        scroller = new Scroller(readAnimView.getContext(), new AccelerateDecelerateInterpolator());\n        scrollRunnable = new ScrollRunnable();\n        menuBounds = new RectF();\n        pathA = new Path();\n        pathB = new Path();\n        paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        shadowWidth = 20;\n    }\n\n    private int downArea = DOWN_AREA_NONE;\n    private float downX = 0F;\n    private int coverSlideDirection = AnimHelper.SLID_DIRECTION_UNKNOWN;\n    private final List<Float> moveSampling = new LinkedList<>();\n    private final int MAX_COUNT = 5;\n    private boolean prepareDrawCoverAnimEffect = false;\n\n    private float currentX = -1;\n\n    @Override", "    public void handlerEvent(MotionEvent event) {\n        if (coverAnimationRunning) return;\n        float x = event.getRawX();\n        float y = event.getY();\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                moveSampling.clear();\n                downX = x;\n                prepareDrawCoverAnimEffect = false;\n                isTouching = true;\n                currentX = -1;\n                downArea = DOWN_AREA_NONE;\n                coverSlideDirection = AnimHelper.SLID_DIRECTION_UNKNOWN;", "                if (x > menuBounds.left && y > menuBounds.top\n                        && x < menuBounds.right && y < menuBounds.bottom) {\n                    downArea = DOWN_AREA_MENU;\n                } else if (x < vWidth / 2F) {\n                    downArea = DOWN_AREA_LEFT;\n                } else {\n                    downArea = DOWN_AREA_RIGHT;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                isTouching = true;\n                float curDistance = x - downX;", "                if (coverSlideDirection == AnimHelper.SLID_DIRECTION_UNKNOWN && checkDownArea(downArea)) {\n                    if (curDistance > 0) {\n                        coverSlideDirection = AnimHelper.SLID_DIRECTION_RIGHT;\n                    } else {\n                        coverSlideDirection = AnimHelper.SLID_DIRECTION_LEFT;\n                    }\n                    readAnimView.buildBitmap(coverSlideDirection);\n                    prepareDrawCoverAnimEffect = checkAnimCondition(coverSlideDirection);\n                }\n\n                if (prepareDrawCoverAnimEffect) {", "                if (prepareDrawCoverAnimEffect) {\n                    if (moveSampling.size() == 0\n                            || x != moveSampling.get(moveSampling.size() - 1)) {\n                        moveSampling.add(x);\n                    }\n                    if (moveSampling.size() > MAX_COUNT) {\n                        moveSampling.remove(0);\n                    }\n                    currentX = x;\n                    invalidate();\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL:\n                isTouching = false;\n                break;\n            case MotionEvent.ACTION_UP:\n                currentX = x;", "                if (prepareDrawCoverAnimEffect) {\n                    if (moveSampling.size() > 0) {\n                        float lastMoveX = moveSampling.get(moveSampling.size() - 1);\n                        float firstMoveX = moveSampling.get(0);\n                        float finallyMoveX = lastMoveX - firstMoveX;\n                        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                            boolean lastFingerLeftSlop = finallyMoveX < 10;\n                            touchUp(lastFingerLeftSlop);\n                        } else if (coverSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                            finallyMoveX = lastMoveX - firstMoveX;\n                            touchUp(finallyMoveX < 0);\n                        }\n                    } else {\n                        touchUp(false);\n                    }", "                        } else if (coverSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                            finallyMoveX = lastMoveX - firstMoveX;\n                            touchUp(finallyMoveX < 0);\n                        }\n                    } else {\n                        touchUp(false);\n                    }\n                } else if (downArea == DOWN_AREA_MENU) {\n                    if (x > menuBounds.left && x < menuBounds.right\n                            && y > menuBounds.top && y < menuBounds.bottom) {\n                        readAnimView.onClickMenuArea();\n                    }", "                    if (x > menuBounds.left && x < menuBounds.right\n                            && y > menuBounds.top && y < menuBounds.bottom) {\n                        readAnimView.onClickMenuArea();\n                    }\n                } else if (downArea != DOWN_AREA_NONE) {\n                    if (x == downX && downX >= vWidth / 2F) {//\u4e0b\u4e00\u9875\n                        coverSlideDirection = AnimHelper.SLID_DIRECTION_LEFT;\n                        readAnimView.buildBitmap(coverSlideDirection);\n                        if (checkAnimCondition(coverSlideDirection)) {\n                            touchUp(true);\n                        }", "                        if (checkAnimCondition(coverSlideDirection)) {\n                            touchUp(true);\n                        }\n                    } else if (x == downX && downX < vWidth / 2F) {//\u4e0a\u4e00\u9875\n                        coverSlideDirection = AnimHelper.SLID_DIRECTION_RIGHT;\n                        readAnimView.buildBitmap(coverSlideDirection);\n                        if (checkAnimCondition(coverSlideDirection)) {\n                            touchUp(false);\n                        }\n                    }\n                }\n                moveSampling.clear();\n                isTouching = false;\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void touchUp(boolean lastFingerLeftSlop) {\n        DLog.log(\"touchUp coverAnimationRunning=%s\", coverAnimationRunning);\n        coverAnimationRunning = true;\n        isCancelFlip = (coverSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && lastFingerLeftSlop)\n                || (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT && !lastFingerLeftSlop);\n\n        int duration = isCancelFlip ? AnimHelper.CANCEL_ANIM_DURATION : AnimHelper.RELAY_ANIM_DURATION;\n        duration = (int) (duration * 0.7F);//cover\u52a8\u753b\u65f6\u95f4\u51cf\u5c11\u4e00\u70b9\n//        duration = 1000;//cover\u52a8\u753b\u65f6\u95f4\u51cf\u5c11\u4e00\u70b9\n        int startX = (int) currentX;\n        int startY = 0;\n        int dy = 0;\n        int dx;\n", "        if (lastFingerLeftSlop) {\n\n            dx = (int) -(vWidth - (downX - currentX));\n        } else {\n            dx = vWidth - (int) currentX;\n        }\n        scroller.startScroll(startX, startY, dx, dy, duration);\n        invalidate();\n    }\n\n\n    @Override", "    public void draw(Canvas canvas) {\n        if (currentX == -1) {\n            DLog.log(\"CoverAnimationEffect draw 1\");\n            return;\n        }\n        if (coverSlideDirection != AnimHelper.SLID_DIRECTION_LEFT && coverSlideDirection != AnimHelper.SLID_DIRECTION_RIGHT) {\n            DLog.log(\"CoverAnimationEffect draw 2\");\n            return;\n        }\n        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT\n                && (null == readAnimView.getCurrentBitmap() || null == readAnimView.getNextBitmap())) {\n            DLog.log(\"CoverAnimationEffect draw 3\");\n            return;\n        }", "        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT\n                && (null == readAnimView.getCurrentBitmap() || null == readAnimView.getNextBitmap())) {\n            DLog.log(\"CoverAnimationEffect draw 3\");\n            return;\n        }\n        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && null == readAnimView.getPreviousBitmap()) {\n            DLog.log(\"CoverAnimationEffect draw 4\");\n            return;\n        }\n        DLog.log(\"CoverAnimationEffect draw 5\");\n        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            float offset = downX - currentX;\n            offset = Math.max(0, offset);\n            canvas.save();\n            canvas.clipPath(getPathAToLeft());\n            canvas.drawBitmap(readAnimView.getCurrentBitmap(), -offset, 0, paint);\n            canvas.restore();\n            canvas.save();\n            canvas.clipPath(getPathB());\n            canvas.drawBitmap(readAnimView.getNextBitmap(), 0, 0, paint);\n            canvas.restore();\n            drawShadow((int) (vWidth - offset), canvas);\n        } else {\n            float leftOffset = vWidth - currentX;\n            canvas.save();\n            canvas.clipPath(getPathAToRight());\n            canvas.drawBitmap(readAnimView.getPreviousBitmap(), -leftOffset, 0, paint);\n            canvas.restore();\n            drawShadow((int) currentX, canvas);\n        }\n    }\n\n    private void drawShadow(int left, Canvas canvas) {\n        GradientDrawable drawable = readAnimView.getAnimHelper().getCoverGradientDrawable();\n        drawable.setBounds(left, 0, left + shadowWidth, vHeight);\n        drawable.draw(canvas);\n    }\n\n    private Path getPathAToLeft() {\n        pathA.reset();\n        float x = vWidth - (downX - currentX);\n        x = Math.min(vWidth, x);\n        pathA.lineTo(x, 0);\n        pathA.lineTo(x, vHeight);\n        pathA.lineTo(0, vHeight);\n        pathA.close();\n        return pathA;\n    }\n\n    private Path getPathB() {\n        pathB.reset();\n        float x = vWidth - (downX - currentX);\n        x = Math.min(vWidth, x);\n        pathB.moveTo(x, 0);\n        pathB.lineTo(vWidth, 0);\n        pathB.lineTo(vWidth, vHeight);\n        pathB.lineTo(x, vHeight);\n        pathB.close();\n        return pathB;\n    }\n\n    private Path getPathAToRight() {\n        pathA.reset();\n        pathA.lineTo(currentX, 0);\n        pathA.lineTo(currentX, vHeight);\n        pathA.lineTo(0, vHeight);\n        pathA.close();\n        return pathA;\n    }\n\n\n    private boolean checkDownArea(int downArea) {\n        return downArea != DOWN_AREA_MENU && downArea != DOWN_AREA_NONE;\n    }\n\n    private boolean checkAnimCondition(int slideDirection) {", "        if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            float offset = downX - currentX;\n            offset = Math.max(0, offset);\n            canvas.save();\n            canvas.clipPath(getPathAToLeft());\n            canvas.drawBitmap(readAnimView.getCurrentBitmap(), -offset, 0, paint);\n            canvas.restore();\n            canvas.save();\n            canvas.clipPath(getPathB());\n            canvas.drawBitmap(readAnimView.getNextBitmap(), 0, 0, paint);\n            canvas.restore();\n            drawShadow((int) (vWidth - offset), canvas);\n        } else {\n            float leftOffset = vWidth - currentX;\n            canvas.save();\n            canvas.clipPath(getPathAToRight());\n            canvas.drawBitmap(readAnimView.getPreviousBitmap(), -leftOffset, 0, paint);\n            canvas.restore();\n            drawShadow((int) currentX, canvas);\n        }\n    }\n\n    private void drawShadow(int left, Canvas canvas) {\n        GradientDrawable drawable = readAnimView.getAnimHelper().getCoverGradientDrawable();\n        drawable.setBounds(left, 0, left + shadowWidth, vHeight);\n        drawable.draw(canvas);\n    }\n\n    private Path getPathAToLeft() {\n        pathA.reset();\n        float x = vWidth - (downX - currentX);\n        x = Math.min(vWidth, x);\n        pathA.lineTo(x, 0);\n        pathA.lineTo(x, vHeight);\n        pathA.lineTo(0, vHeight);\n        pathA.close();\n        return pathA;\n    }\n\n    private Path getPathB() {\n        pathB.reset();\n        float x = vWidth - (downX - currentX);\n        x = Math.min(vWidth, x);\n        pathB.moveTo(x, 0);\n        pathB.lineTo(vWidth, 0);\n        pathB.lineTo(vWidth, vHeight);\n        pathB.lineTo(x, vHeight);\n        pathB.close();\n        return pathB;\n    }\n\n    private Path getPathAToRight() {\n        pathA.reset();\n        pathA.lineTo(currentX, 0);\n        pathA.lineTo(currentX, vHeight);\n        pathA.lineTo(0, vHeight);\n        pathA.close();\n        return pathA;\n    }\n\n\n    private boolean checkDownArea(int downArea) {\n        return downArea != DOWN_AREA_MENU && downArea != DOWN_AREA_NONE;\n    }\n\n    private boolean checkAnimCondition(int slideDirection) {", "        if (slideDirection == AnimHelper.SLID_DIRECTION_LEFT && (null != readAnimView.getNextBitmap() && null != readAnimView.getCurrentBitmap())) {\n            return true;\n        } else if (slideDirection == AnimHelper.SLID_DIRECTION_RIGHT && null != readAnimView.getPreviousBitmap()) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean animInEffect() {\n        return isTouching || coverAnimationRunning;\n    }\n\n    @Override", "    public boolean animInEffect() {\n        return isTouching || coverAnimationRunning;\n    }\n\n    @Override\n    public void onViewSizeChanged(int vWidth, int vHeight) {\n        this.vWidth = vWidth;\n        this.vHeight = vHeight;\n        menuBounds.left = vWidth / 3F;\n        menuBounds.top = vHeight / 3F;\n        menuBounds.right = vWidth * 2 / 3F;\n        menuBounds.bottom = vHeight * 2 / 3F;\n    }\n\n    @Override", "    public void onViewAttachedToWindow() {\n\n    }\n\n    @Override\n    public void onViewDetachedFromWindow() {\n        readAnimView.removeCallbacks(scrollRunnable);\n    }\n\n    private void invalidate() {\n        readAnimView.postInvalidate();\n    }\n\n    @Override", "    public void onScroll() {\n        if (scroller.computeScrollOffset()) {\n\n            int x = scroller.getCurrX();\n            int y = scroller.getCurrY();\n            if (x == scroller.getFinalX() && y == scroller.getFinalY()) {\n                scroller.forceFinished(true);\n                //\u8865\u4e00\u70b9\u65f6\u95f4\uff0c\u907f\u514d\u52a8\u753b\u592a\u5feb\u7ed3\u675f\uff0c\u63d0\u4f9b\u4e24\u6b21\u52a8\u753b\u89e6\u53d1\u95f4\u9694\n                DLog.log(\"coverAnimationRunning coverAnimationRunning=%s \u7ed3\u675f\uff0c\u5ef6\u65f6\u5f00\u542f \u72b6\u6001\u91cd\u7f6e\", coverAnimationRunning);\n                readAnimView.post(scrollRunnable);\n            } else {\n                currentX = x;\n                invalidate();\n            }\n        }\n\n    }\n\n\n    protected class ScrollRunnable implements Runnable {\n        @Override", "        public void run() {\n            readAnimView.reset();\n            coverAnimationRunning = false;\n            if (!isCancelFlip) {\n                if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                    readAnimView.onExpectNext();\n                } else if (coverSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                    readAnimView.onExpectPrevious();\n                }\n            }\n            invalidate();\n\n        }\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/anim/SimulationAnimationEffecter.java", "chunked_list": ["package com.juziml.read.business.read.anim;\n\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ColorMatrixColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;", "import android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.RectF;\nimport android.graphics.Region;\nimport android.graphics.drawable.GradientDrawable;\nimport android.util.TypedValue;\nimport android.view.MotionEvent;\nimport android.view.animation.LinearInterpolator;\nimport android.widget.Scroller;", "import android.view.animation.LinearInterpolator;\nimport android.widget.Scroller;\n\nimport com.juziml.read.business.read.view.FPoint;\nimport com.juziml.read.business.read.view.PuppetView;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**", "\n/**\n * create by zhusw on 2020-08-24 14:06\n */\npublic class SimulationAnimationEffecter implements IAnimationEffecter {\n    private final static int DOWN_AREA_TOP_RIGHT = 1;\n    private final static int DOWN_AREA_BOTTOM_RIGHT = 2;\n    private final static int DOWN_AREA_LEFT = 3;\n    private final static int DOWN_AREA_CENTRE_RIGHT = 4;\n    private final static int DOWN_AREA_NONE = 5;\n    private final static int DOWN_AREA_MENU = 6;\n\n\n    int vWidth = 1;\n    int vHeight = 1;\n    private final PuppetView readAnimView;\n    private boolean isCancelFlip = false;\n    private boolean curlAnimationRunning = false;\n    private boolean isTouching = false;\n    private final Scroller scroller;\n\n    Paint pointPaint;\n\n    Paint pathPaint;\n    Paint bitmapPaint;\n    Path pathA;\n    Path pathC;\n    Path pathRightShadow;\n    Path pathLeftShadow;\n    FPoint a, f, g, e, h, c, j, b, k, d, i;\n\n    FPoint g2, e2;\n\n\n    private final float[] matrixArray = {0, 0, 0, 0, 0, 0, 0, 0, 1.0f};\n    private final Matrix matrix = new Matrix();\n\n    float lPathAShadowDis = 0F;\n    float rPathAShadowDis = 0F;\n    private final RectF menuBounds = new RectF();\n\n    private final ColorMatrixColorFilter colorMatrixColorFilter;\n\n    private final ScrollRunnable scrollRunnable = new ScrollRunnable();\n\n\n    public SimulationAnimationEffecter(PuppetView readAnimView) {\n        this.readAnimView = readAnimView;\n        pointPaint = new Paint();\n        pointPaint.setColor(Color.RED);\n        pointPaint.setTextSize(25);\n\n        a = new FPoint(-1, -1);\n        f = new FPoint();\n        g = new FPoint();\n        e = new FPoint();\n        h = new FPoint();\n        c = new FPoint();\n        j = new FPoint();\n        b = new FPoint();\n        k = new FPoint();\n        d = new FPoint();\n        i = new FPoint();\n\n        g2 = new FPoint();\n        e2 = new FPoint();\n\n        pathPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\n        bitmapPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        pathA = new Path();\n        pathC = new Path();\n        pathRightShadow = new Path();\n        pathLeftShadow = new Path();\n\n        ColorMatrix cm = new ColorMatrix();//\u8bbe\u7f6e\u989c\u8272\u6570\u7ec4\n        float[] array = {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0};\n        cm.set(array);\n        colorMatrixColorFilter = new ColorMatrixColorFilter(cm);\n        scroller = new Scroller(readAnimView.getContext(), new LinearInterpolator());\n\n    }\n\n\n    @Override", "    public void onScroll() {\n        if (scroller.computeScrollOffset()) {\n            int x = scroller.getCurrX();\n            int y = scroller.getCurrY();\n            int finalX = scroller.getFinalX();\n            int finalY = scroller.getFinalY();\n            if (x == finalX && y == finalY) {\n                if (!isCancelFlip) {\n                    if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                        readAnimView.onExpectNext();\n                    } else if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                        readAnimView.onExpectPrevious();\n                    }\n                }\n                readAnimView.post(scrollRunnable);\n            } else {\n                touchMove(x, y, curlSlideDirection, false, true);\n            }\n        }\n\n    }\n\n    @Override", "                    if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                        readAnimView.onExpectNext();\n                    } else if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                        readAnimView.onExpectPrevious();\n                    }\n                }\n                readAnimView.post(scrollRunnable);\n            } else {\n                touchMove(x, y, curlSlideDirection, false, true);\n            }\n        }\n\n    }\n\n    @Override", "    public void handlerEvent(MotionEvent event) {\n        if (curlAnimationRunning) return;\n        float x = event.getRawX();\n        float y = event.getRawY();\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                isTouching = true;\n                drawCurlAnimBefore = false;\n                moveSampling.clear();\n                downX = x;\n                curlSlideDirection = AnimHelper.SLID_DIRECTION_UNKNOWN;", "                if (x < menuBounds.left) {\n                    downArea = DOWN_AREA_LEFT;\n                } else if (x > menuBounds.left && y < menuBounds.top) {\n                    downArea = DOWN_AREA_TOP_RIGHT;\n                } else if (x > menuBounds.left && y > menuBounds.bottom) {\n                    downArea = DOWN_AREA_BOTTOM_RIGHT;\n                } else if (x > menuBounds.right) {\n                    downArea = DOWN_AREA_CENTRE_RIGHT;\n                } else if (x > menuBounds.left && y > menuBounds.top && x < menuBounds.right && y < menuBounds.bottom) {\n                    downArea = DOWN_AREA_MENU;\n                } else {\n                    downArea = DOWN_AREA_NONE;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE://\u786e\u5b9a\u6ed1\u52a8\u65b9\u5411\n                isTouching = true;", "                } else if (x > menuBounds.left && y > menuBounds.top && x < menuBounds.right && y < menuBounds.bottom) {\n                    downArea = DOWN_AREA_MENU;\n                } else {\n                    downArea = DOWN_AREA_NONE;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE://\u786e\u5b9a\u6ed1\u52a8\u65b9\u5411\n                isTouching = true;\n                if (checkDownArea(downArea)) {\n                    float moveDistance = x - downX;\n                    //\u6ed1\u52a8\u8ddd\u79bb\u8d85\u8fc75px\uff0c\u4e14\u5355\u6b21\u4e8b\u4ef6\u5468\u671f\u53ea\u8bbe\u7f6e\u4e00\u4e2a\u65b9\u5411\uff0c\u9996\u6b21\u6ed1\u52a8\u8ddd\u79bb\u5927\u4e8e5px\u65f6\u4e3a\u65b9\u5411\u5224\u65ad\u4f9d\u636e", "                if (checkDownArea(downArea)) {\n                    float moveDistance = x - downX;\n                    //\u6ed1\u52a8\u8ddd\u79bb\u8d85\u8fc75px\uff0c\u4e14\u5355\u6b21\u4e8b\u4ef6\u5468\u671f\u53ea\u8bbe\u7f6e\u4e00\u4e2a\u65b9\u5411\uff0c\u9996\u6b21\u6ed1\u52a8\u8ddd\u79bb\u5927\u4e8e5px\u65f6\u4e3a\u65b9\u5411\u5224\u65ad\u4f9d\u636e\n                    if (downArea != DOWN_AREA_MENU && Math.abs(moveDistance) > AnimHelper.MOVE_SLOP && curlSlideDirection == AnimHelper.SLID_DIRECTION_UNKNOWN) {\n                        if (moveDistance > 0) {\n                            curlSlideDirection = AnimHelper.SLID_DIRECTION_RIGHT;\n                        } else {\n                            curlSlideDirection = AnimHelper.SLID_DIRECTION_LEFT;\n                        }\n                        touchDown(downArea, curlSlideDirection);\n                        readAnimView.buildBitmap(curlSlideDirection);\n                        drawCurlAnimBefore = checkAnimCondition(curlSlideDirection, downArea);\n                    }", "                    if (drawCurlAnimBefore) {\n                        if (moveSampling.size() == 0 || x != moveSampling.get(moveSampling.size() - 1)) {\n                            moveSampling.add(x);\n                        }\n                        if (moveSampling.size() > MAX_COUNT) {\n                            moveSampling.remove(0);\n                        }\n                        touchMoveAndInvalidate(x, y, curlSlideDirection, true);\n                    }\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL://[\u907f\u514dcurl\u52a8\u753b\u6267\u884c\u65f6\uff0c\u5207\u6362\u4e86flipMode \u54cd\u5e94ACTION_CANCEL]\n                isTouching = false;\n                break;\n            case MotionEvent.ACTION_UP://\u9700\u8981\u5bf9\u6700\u540e\u624b\u52bf\u8fdb\u884c\u91c7\u6837\uff0c\u5224\u65ad\u662f \u53d6\u6d88\u8fd8\u662f\u81ea\u52a8\u7ffb\u9875", "                if (drawCurlAnimBefore) {\n                    if (moveSampling.size() > 0) {\n                        float lastMoveX = moveSampling.get(moveSampling.size() - 1);\n                        float firstMoveX = moveSampling.get(0);\n                        float finallyMoveX = lastMoveX - firstMoveX;\n                        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                            boolean lastFingerLeftSlop = finallyMoveX < 10;\n                            touchUp(lastFingerLeftSlop);\n                        } else if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                            finallyMoveX = lastMoveX - firstMoveX;\n\n                            touchUp(finallyMoveX < 0);\n                        }\n                        moveSampling.clear();\n                    } else {\n                        touchUp(false);\n                    }", "                        } else if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n                            finallyMoveX = lastMoveX - firstMoveX;\n\n                            touchUp(finallyMoveX < 0);\n                        }\n                        moveSampling.clear();\n                    } else {\n                        touchUp(false);\n                    }\n                } else if (downArea == DOWN_AREA_MENU) {\n                    if (x > menuBounds.left && x < menuBounds.right && y > menuBounds.top && y < menuBounds.bottom) {\n                        readAnimView.onClickMenuArea();\n                    }", "                } else if (downArea == DOWN_AREA_MENU) {\n                    if (x > menuBounds.left && x < menuBounds.right && y > menuBounds.top && y < menuBounds.bottom) {\n                        readAnimView.onClickMenuArea();\n                    }\n                } else if (downArea != DOWN_AREA_NONE) {\n\n                    if (x == downX && downX >= vWidth / 2F) {//\u4e0b\u4e00\u9875\n                        curlSlideDirection = AnimHelper.SLID_DIRECTION_LEFT;\n                        touchDown(downArea, curlSlideDirection);\n                        readAnimView.buildBitmap(curlSlideDirection);\n                        if (checkAnimCondition(curlSlideDirection, downArea)) {\n                            touchMove(x, y, curlSlideDirection, true, false);\n                            touchUp(true);\n                        }\n", "                        if (checkAnimCondition(curlSlideDirection, downArea)) {\n                            touchMove(x, y, curlSlideDirection, true, false);\n                            touchUp(true);\n                        }\n\n                    } else if (x == downX && downX < vWidth / 2F) {//\u4e0a\u4e00\u9875\n                        curlSlideDirection = AnimHelper.SLID_DIRECTION_RIGHT;\n                        touchDown(downArea, curlSlideDirection);\n                        readAnimView.buildBitmap(curlSlideDirection);\n                        if (checkAnimCondition(curlSlideDirection, downArea)) {\n                            touchMove(x, y, curlSlideDirection, true, false);\n                            touchUp(false);\n                        }\n                    }\n                }\n                isTouching = false;\n                downX = 0F;\n                drawCurlAnimBefore = false;\n                break;\n        }\n\n    }\n\n\n    @Override", "                        if (checkAnimCondition(curlSlideDirection, downArea)) {\n                            touchMove(x, y, curlSlideDirection, true, false);\n                            touchUp(false);\n                        }\n                    }\n                }\n                isTouching = false;\n                downX = 0F;\n                drawCurlAnimBefore = false;\n                break;\n        }\n\n    }\n\n\n    @Override", "    public void onViewSizeChanged(int vWidth, int vHeight) {\n        this.vWidth = vWidth;\n        this.vHeight = vHeight;\n        a.x = -1;\n        a.y = -1;\n        menuBounds.left = vWidth / 3F;\n        menuBounds.top = vHeight / 3F;\n        menuBounds.right = vWidth * 2 / 3F;\n        menuBounds.bottom = vHeight * 2 / 3F;\n    }\n\n    @Override", "    public void onViewAttachedToWindow() {\n\n    }\n\n    @Override\n    public void onViewDetachedFromWindow() {\n        readAnimView.removeCallbacks(scrollRunnable);\n    }\n\n    @Override\n    public void draw(Canvas canvas) {", "    public void draw(Canvas canvas) {\n        if (a.x == -1 && a.y == -1) {\n            return;\n        }\n        if (curlSlideDirection != AnimHelper.SLID_DIRECTION_LEFT && curlSlideDirection != AnimHelper.SLID_DIRECTION_RIGHT) {\n            return;\n        }\n        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT && (null == readAnimView.getCurrentBitmap() || null == readAnimView.getNextBitmap())) {\n            return;\n        }\n        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && null == readAnimView.getPreviousBitmap()) {\n            return;\n        }\n\n        Path pathA;", "        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && null == readAnimView.getPreviousBitmap()) {\n            return;\n        }\n\n        Path pathA;\n        if (f.x == vWidth && f.y == 0) {\n            pathA = getPathAFromRightTop();\n        } else {\n            pathA = getPathAFromRightBottom();\n        }\n        Path pathC = getPathC();\n        drawContent(canvas, pathA, pathC, readAnimView.getCurrentBitmap(), readAnimView.getNextBitmap(), readAnimView.getPreviousBitmap());\n        drawShaDow(canvas, pathA, pathC);\n    }\n\n    @Override", "    public boolean animInEffect() {\n        return curlAnimationRunning || isTouching;\n    }\n\n    /**\n     * @param lastFingerLeftSlop true:\u6700\u540e\u624b\u6307\u5de6\u503e\u659c \uff0cfalse\uff1a\u6700\u540e\u624b\u6307\u53f3\u503e\u659c\n     */\n    public void touchUp(final boolean lastFingerLeftSlop) {\n\n        int ax = (int) a.x;\n        int ay = (int) a.y;\n        boolean isCancelFlip;\n        int dx;\n        int dy;", "        if (lastFingerLeftSlop) {\n            dx = -vWidth - ax;\n        } else {\n            dx = vWidth - ax;\n        }\n        isCancelFlip = (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && lastFingerLeftSlop) || (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT && !lastFingerLeftSlop);\n\n        if (downArea == DOWN_AREA_TOP_RIGHT) {\n            dy = -ay;\n        } else {\n            dy = (vHeight - ay);\n        }\n        this.isCancelFlip = isCancelFlip;\n        int duration = isCancelFlip ? AnimHelper.CANCEL_ANIM_DURATION : AnimHelper.RELAY_ANIM_DURATION;\n        curlAnimationRunning = true;\n        scroller.startScroll(ax, ay, dx, dy, duration);\n        invalidate();//\u731b\u7136\u60f3\u8d77startScroll \u9700\u8981\u5728\u4e0b\u4e00\u5e27\u91cd\u7ed8\u65f6\u624d\u751f\u6548\n    }\n\n\n    private int downArea = DOWN_AREA_NONE;\n    private float downX = 0F;\n    private int curlSlideDirection = AnimHelper.SLID_DIRECTION_UNKNOWN;\n    private final List<Float> moveSampling = new LinkedList<>();\n    private final int MAX_COUNT = 5;\n    private boolean drawCurlAnimBefore = false;\n\n\n    private boolean checkDownArea(int downArea) {\n\n        return downArea != DOWN_AREA_MENU && downArea != DOWN_AREA_NONE;\n    }\n\n    private boolean checkAnimCondition(int curlSlideDirection, int downArea) {\n\n        boolean notAtSlideArea = !checkDownArea(downArea);\n", "        if (curlAnimationRunning || notAtSlideArea) return false;\n\n        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT && (null != readAnimView.getNextBitmap() && null != readAnimView.getCurrentBitmap())) {\n            return true;\n        } else if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT && null != readAnimView.getPreviousBitmap()) {\n            return true;\n        }\n        return false;\n    }\n\n    public void touchDown(int downArea, int curlSlideDirection) {\n        //\u5224\u65ad\u89e6\u6478\u8d77\u59cb\u70b9\u4f4d\u7f6e\uff0c\u786e\u5b9af\u70b9", "    public void touchDown(int downArea, int curlSlideDirection) {\n        //\u5224\u65ad\u89e6\u6478\u8d77\u59cb\u70b9\u4f4d\u7f6e\uff0c\u786e\u5b9af\u70b9\n        if (downArea == DOWN_AREA_TOP_RIGHT && curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            f.x = vWidth;\n            f.y = 0;\n        } else {\n            f.x = vWidth;\n            f.y = vHeight;\n        }\n\n    }\n\n\n    private float dpToPx(float dp) {\n        return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, Resources.getSystem().getDisplayMetrics());\n    }\n\n    /**\n     * @param x\n     * @param y\n     * @param curlSlideDirection\n     * @param offset             C.x <0 \u81ea\u52a8\u4fee\u6b63\u65f6A\u70b9\u5750\u6807 \u907f\u514da\u70b9\u4e0d\u52a8\n     * @param invalidate\n     */\n    private void touchMove(float x, float y, int curlSlideDirection, boolean offset, boolean invalidate) {\n        a.x = x;\n        final float minGap = dpToPx(5F);", "        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_RIGHT || (downArea == DOWN_AREA_LEFT || downArea == DOWN_AREA_CENTRE_RIGHT)) {\n            a.y = vHeight - minGap;\n        } else {\n            a.y = y;\n        }\n        calcPointsXY(a, f);\n        if (offset) {\n            //\u4fee\u6b63c\u70b9\u8303\u56f4 \u4e0d\u53ef\u5c0f\u4e8e0\n            if (calcPointCX(f) < 0) {\n                calcPointAByTouchPoint();\n                calcPointsXY(a, f);\n            }\n        }", "            if (calcPointCX(f) < 0) {\n                calcPointAByTouchPoint();\n                calcPointsXY(a, f);\n            }\n        }\n        if (invalidate) {\n            invalidate();\n        }\n    }\n\n    private void invalidate() {\n        readAnimView.postInvalidate();\n    }\n\n    private void touchMoveAndInvalidate(float x, float y, int curlSlideDirection, boolean offset) {\n        touchMove(x, y, curlSlideDirection, offset, true);\n    }\n\n\n    private void drawShaDow(Canvas canvas, Path pathA, Path pathC) {\n        drawPathARightShadow(canvas, pathA);\n        drawPathALeftShadow(canvas, pathA);\n        drawPathBShadow(canvas, pathA, pathC);\n        drawPathCShadow(canvas, pathA);\n\n    }\n\n    private void drawContent(Canvas canvas, Path pathA, Path pathC, Bitmap curBitmap, Bitmap nextBitmap, Bitmap preBitmap) {\n\n        //B\u56fe\u5c42\u5c31\u662f\u5e95\u56fe\uff0c\u4e5f\u5c31\u662f backgroundBitmap \u5373\u53ef\n        float eh = (float) Math.hypot(f.x - e.x, h.y - f.y);\n        float sin0 = (f.x - e.x) / eh;\n        float cos0 = (h.y - f.y) / eh;\n        //\u8bbe\u7f6e\u56fe\u5f62\u7ffb\u8f6c\u548c\u65cb\u8f6c\u77e9\u9635\n        matrixArray[0] = -(1 - 2 * sin0 * sin0);\n        matrixArray[1] = 2 * sin0 * cos0;\n        matrixArray[3] = 2 * sin0 * cos0;\n        matrixArray[4] = 1 - 2 * sin0 * sin0;\n        matrix.reset();\n        matrix.setValues(matrixArray);\n        matrix.preTranslate(-e.x, -e.y);\n        matrix.postTranslate(e.x, e.y);\n\n", "        if (curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n\n            //\u5bf9Bitmap\u8fdb\u884c\u53d6\u8272\n            int color = curBitmap.getPixel(1, 1);\n            //\u83b7\u53d6\u5bf9\u5e94\u7684\u4e09\u8272\n            int red = (color & 0xff0000) >> 16;\n            int green = (color & 0x00ff00) >> 8;\n            int blue = (color & 0x0000ff);\n            //\u8f6c\u6362\u6210\u542b\u6709\u900f\u660e\u5ea6\u7684\u989c\u8272\n            int tempColor = Color.argb(200, red, green, blue);\n\n            canvas.save();\n            canvas.clipPath(pathC);\n            canvas.clipPath(pathA, Region.Op.DIFFERENCE);\n            canvas.drawColor(readAnimView.getBackgroundColor());\n            bitmapPaint.setColorFilter(colorMatrixColorFilter);\n            canvas.drawBitmap(curBitmap, matrix, bitmapPaint);//\u7ed8\u5236\u80cc\u9762\u5230C\u533a\n            canvas.drawColor(tempColor);//\u53e0\u52a0\u80cc\u666f\n            bitmapPaint.setColorFilter(null);\n\n            canvas.restore();\n\n            canvas.save();\n            canvas.clipPath(pathC, Region.Op.DIFFERENCE);\n            canvas.clipPath(pathA, Region.Op.DIFFERENCE);\n            canvas.drawBitmap(nextBitmap, 0, 0, bitmapPaint);//\u7ed8\u5236B\u533a\n            canvas.restore();\n        } else {\n            //\u5bf9Bitmap\u8fdb\u884c\u53d6\u8272\n            int color = preBitmap.getPixel(1, 1);\n            //\u83b7\u53d6\u5bf9\u5e94\u7684\u4e09\u8272\n            int red = (color & 0xff0000) >> 16;\n            int green = (color & 0x00ff00) >> 8;\n            int blue = (color & 0x0000ff);\n            //\u8f6c\u6362\u6210\u542b\u6709\u900f\u660e\u5ea6\u7684\u989c\u8272\n            int tempColor = Color.argb(200, red, green, blue);\n\n            bitmapPaint.setColorFilter(colorMatrixColorFilter);\n            canvas.save();\n            canvas.clipPath(pathC);\n            canvas.clipPath(pathA, Region.Op.DIFFERENCE);\n            bitmapPaint.setColorFilter(colorMatrixColorFilter);\n            canvas.drawBitmap(preBitmap, matrix, bitmapPaint);//\u7ed8\u5236\u80cc\u9762\u5230C\u533a\n            canvas.drawColor(tempColor);//\u53e0\u52a0\u80cc\u666f\n            bitmapPaint.setColorFilter(null);\n            canvas.restore();\n\n            canvas.save();\n            canvas.clipPath(pathA);//\u7ed8\u5236\u6b63\u9762\u5230A\u533a\n            canvas.drawBitmap(preBitmap, 0, 0, bitmapPaint);\n            canvas.restore();\n        }\n    }\n\n    /**\n     * \u7ed8\u5236B\u533a\u57df\u9634\u5f71\uff0c\u9634\u5f71\u5de6\u6df1\u53f3\u6d45\n     *\n     * @param canvas\n     */\n    private void drawPathBShadow(Canvas canvas, Path pathA, Path pathC) {\n        int deepOffset = 0;//\u6df1\u8272\u7aef\u7684\u504f\u79fb\u503c\n        int lightOffset = 0;//\u6d45\u8272\u7aef\u7684\u504f\u79fb\u503c\n        float aTof = (float) Math.hypot((a.x - f.x), (a.y - f.y));//a\u5230f\u7684\u8ddd\u79bb\n        float viewDiagonalLength = (float) Math.hypot(vWidth, vHeight);//\u5bf9\u89d2\u7ebf\u957f\u5ea6\n\n        int left;\n        int right;\n        int top = (int) c.y;\n        int bottom = (int) (viewDiagonalLength + c.y);\n        GradientDrawable gradientDrawable;", "        if (downArea == DOWN_AREA_TOP_RIGHT && curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            //\u4ece\u5de6\u5411\u53f3\u7ebf\u6027\u6e10\u53d8\n            gradientDrawable = readAnimView.getAnimHelper().getTopBGradientDrawable();\n\n            left = (int) (c.x - deepOffset);//c\u70b9\u4f4d\u4e8e\u5de6\u4e0a\u89d2\n            right = (int) (c.x + aTof / 4 + lightOffset);\n        } else {\n            //\u4ece\u53f3\u5411\u5de6\u7ebf\u6027\u6e10\u53d8\n            gradientDrawable = readAnimView.getAnimHelper().getBottomBGradientDrawable();\n\n            left = (int) (c.x - aTof / 4 - lightOffset);//c\u70b9\u4f4d\u4e8e\u5de6\u4e0b\u89d2\n            right = (int) (c.x + deepOffset);\n        }\n        gradientDrawable.setBounds(left, top, right, bottom);//\u8bbe\u7f6e\u9634\u5f71\u77e9\u5f62\n        canvas.save();\n        canvas.clipPath(pathA, Region.Op.DIFFERENCE);\n        canvas.clipPath(pathC, Region.Op.DIFFERENCE);//\u7559\u51fab\u533a\n\n        float rotateDegrees = (float) Math.toDegrees(Math.atan2(e.x - f.x, h.y - f.y));//\u65cb\u8f6c\u89d2\u5ea6\n        canvas.rotate(rotateDegrees, c.x, c.y);//\u4ee5c\u4e3a\u4e2d\u5fc3\u70b9\u65cb\u8f6c\n        gradientDrawable.draw(canvas);\n        canvas.restore();\n    }\n\n    /**\n     * \u7ed8\u5236C\u533a\u57df\u9634\u5f71\uff0c\u9634\u5f71\u5de6\u6d45\u53f3\u6df1\n     *\n     * @param canvas\n     */\n    private void drawPathCShadow(Canvas canvas, Path pathA) {\n        int deepOffset = 1;//\u6df1\u8272\u7aef\u7684\u504f\u79fb\u503c\n        int lightOffset = 0;//\u6d45\u8272\u7aef\u7684\u504f\u79fb\u503c\n        float viewDiagonalLength = (float) Math.hypot(vWidth, vHeight);//view\u5bf9\u89d2\u7ebf\u957f\u5ea6\n        int midpoint_ce = (int) (c.x + e.x) / 2;//ce\u4e2d\u70b9\n        int midpoint_jh = (int) (j.y + h.y) / 2;//jh\u4e2d\u70b9\n        float minDisToControlPoint = Math.min(Math.abs(midpoint_ce - e.x), Math.abs(midpoint_jh - h.y));//\u4e2d\u70b9\u5230\u63a7\u5236\u70b9\u7684\u6700\u5c0f\u503c\n\n        int left;\n        int right;\n        int top = (int) c.y;\n        int bottom = (int) (viewDiagonalLength + c.y);\n        GradientDrawable gradientDrawable;", "        if (downArea == DOWN_AREA_TOP_RIGHT && curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            gradientDrawable = readAnimView.getAnimHelper().getTopCGradientDrawable();\n            left = (int) (c.x - lightOffset);\n            right = (int) (c.x + minDisToControlPoint + deepOffset);\n        } else {\n            gradientDrawable = readAnimView.getAnimHelper().getBottomCGradientDrawable();\n            left = (int) (c.x - minDisToControlPoint - deepOffset);\n            right = (int) (c.x + lightOffset);\n        }\n        gradientDrawable.setBounds(left, top, right, bottom);\n        canvas.save();\n        canvas.clipPath(pathC);\n        canvas.clipPath(pathA, Region.Op.DIFFERENCE);//\u671f\u671b\u7684C\u533a\n        float mDegrees = (float) Math.toDegrees(Math.atan2(e.x - f.x, h.y - f.y));\n        canvas.rotate(mDegrees, c.x, c.y);\n        gradientDrawable.draw(canvas);\n\n        canvas.restore();\n\n    }\n\n    /**\n     * \u7ed8\u5236A\u533a\u57df\u5de6\u9634\u5f71\n     *\n     * @param canvas\n     */\n    private void drawPathALeftShadow(Canvas canvas, Path pathA) {\n\n        int left;\n        int right;\n        int top = (int) e.y;\n        int bottom = (int) (e.y + vHeight);\n        GradientDrawable gradientDrawable;", "        if (downArea == DOWN_AREA_TOP_RIGHT && curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            gradientDrawable = readAnimView.getAnimHelper().getTopLeftGradientDrawable();\n            left = (int) (e.x - lPathAShadowDis / 2);\n            right = (int) (e.x);\n        } else {\n            gradientDrawable = readAnimView.getAnimHelper().getBottomLeftGradientDrawable();\n            left = (int) (e.x);\n            right = (int) (e.x + lPathAShadowDis / 2);\n        }\n        //\u88c1\u526a\u51fa\u6211\u4eec\u9700\u8981\u7684\u533a\u57df\n        pathLeftShadow.reset();\n        pathLeftShadow.moveTo(a.x - Math.max(rPathAShadowDis, lPathAShadowDis) / 2, a.y);\n        pathLeftShadow.lineTo(d.x, d.y);\n        pathLeftShadow.lineTo(e.x, e.y);\n        pathLeftShadow.lineTo(a.x, a.y);\n        pathLeftShadow.close();\n        canvas.save();\n\n        canvas.clipPath(pathA);\n        canvas.clipPath(pathLeftShadow, Region.Op.INTERSECT);\n        float mDegrees = (float) Math.toDegrees(Math.atan2(e.x - a.x, a.y - e.y));\n        canvas.rotate(mDegrees, e.x, e.y);\n        gradientDrawable.setBounds(left, top, right, bottom);\n        gradientDrawable.draw(canvas);\n        canvas.restore();\n\n    }\n\n    /**\n     * \u7ed8\u5236A\u533a\u57df\u53f3\u9634\u5f71\n     *\n     * @param canvas\n     */\n    private void drawPathARightShadow(Canvas canvas, Path pathA) {\n\n        float viewDiagonalLength = (float) Math.hypot(vWidth, vHeight);//view\u5bf9\u89d2\u7ebf\u957f\u5ea6\n        int left = (int) h.x;\n        int right = (int) (h.x + viewDiagonalLength * 10);//\u9700\u8981\u8db3\u591f\u957f\u7684\u957f\u5ea6\n        int top;\n        int bottom;\n        int offset = 0;\n        GradientDrawable gradientDrawable;", "        if (downArea == DOWN_AREA_TOP_RIGHT && curlSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            gradientDrawable = readAnimView.getAnimHelper().getTopRightGradientDrawable();\n            top = (int) (h.y - rPathAShadowDis / 2) + offset;\n            bottom = (int) h.y;\n        } else {\n            gradientDrawable = readAnimView.getAnimHelper().getBottomRightGradientDrawable();\n            top = (int) h.y;\n            bottom = (int) (h.y + rPathAShadowDis / 2);\n        }\n        gradientDrawable.setBounds(left, top, right, bottom);\n\n        //\u88c1\u526a\u51fa\u6211\u4eec\u9700\u8981\u7684\u533a\u57df\n        pathRightShadow.reset();\n        pathRightShadow.moveTo(a.x - Math.max(rPathAShadowDis, lPathAShadowDis) / 2, a.y);\n        pathRightShadow.lineTo(h.x, h.y);\n        pathRightShadow.lineTo(a.x, a.y);\n        pathRightShadow.close();\n        canvas.save();\n        canvas.clipPath(pathA);\n        canvas.clipPath(pathRightShadow);\n        float mDegrees = (float) Math.toDegrees(Math.atan2(a.y - h.y, a.x - h.x));\n        canvas.rotate(mDegrees, h.x, h.y);\n        gradientDrawable.draw(canvas);\n        canvas.restore();\n\n    }\n\n    /**\n     * \u89e6\u53d1\u533a\u57df \u53f3\u4e0b\n     *\n     * @return\n     */\n    private Path getPathAFromRightBottom() {\n        pathA.reset();\n        pathA.lineTo(0, vHeight);//\u79fb\u52a8\u5230\u5de6\u4e0b\u89d2\n        pathA.lineTo(c.x, c.y);//\u79fb\u52a8\u5230c\u70b9\n        pathA.quadTo(e.x, e.y, b.x, b.y);//\u4ecec\u5230b\u753b\u8d1d\u585e\u5c14\u66f2\u7ebf\uff0c\u63a7\u5236\u70b9\u4e3ae\n        pathA.lineTo(a.x, a.y);//\u79fb\u52a8\u5230a\u70b9\n        pathA.lineTo(k.x, k.y);//\u79fb\u52a8\u5230k\u70b9\n        pathA.quadTo(h.x, h.y, j.x, j.y);//\u4ecek\u5230j\u753b\u8d1d\u585e\u5c14\u66f2\u7ebf\uff0c\u63a7\u5236\u70b9\u4e3ah\n        pathA.lineTo(vWidth, 0);//\u79fb\u52a8\u5230\u53f3\u4e0a\u89d2\n        pathA.close();//\u95ed\u5408\u533a\u57df\n        return pathA;\n    }\n\n    /**\n     * \u89e6\u53d1\u533a\u57df \u53f3\u4e0a\n     *\n     * @return\n     */\n    private Path getPathAFromRightTop() {\n        pathA.reset();\n        pathA.moveTo(0, 0);\n        pathA.lineTo(c.x, c.y);//\u79fb\u52a8\u5230c\u70b9\n        pathA.quadTo(e.x, e.y, b.x, b.y);//\u4ecec\u5230b\u753b\u8d1d\u585e\u5c14\u66f2\u7ebf\uff0c\u63a7\u5236\u70b9\u4e3ae\n        pathA.lineTo(a.x, a.y);//\u79fb\u52a8\u5230a\u70b9\n        pathA.lineTo(k.x, k.y);//\u79fb\u52a8\u5230k\u70b9\n        pathA.quadTo(h.x, h.y, j.x, j.y);//\u4ecek\u5230j\u753b\u8d1d\u585e\u5c14\u66f2\u7ebf\uff0c\u63a7\u5236\u70b9\u4e3ah\n        pathA.lineTo(vWidth, vHeight);//\u79fb\u52a8\u5230\u53f3\u4e0b\u89d2\n        pathA.lineTo(0, vHeight);//\u79fb\u52a8\u5230\u5de6\u4e0b\u89d2\n        pathA.close();\n        return pathA;\n    }\n\n    private Path getPathC() {\n        pathC.reset();\n        pathC.moveTo(d.x, d.y);\n        pathC.lineTo(b.x, b.y);\n        pathC.lineTo(a.x, a.y);\n        pathC.lineTo(k.x, k.y);\n        pathC.lineTo(i.x, i.y);\n        pathC.close();\n        return pathC;\n    }\n\n    /**\n     * \u4ec5\u7528\u4e8e\u786e\u8ba4\u70b9\u4f4d\u65f6\u4f7f\u7528\n     *\n     * @param canvas\n     */\n    private void drawPoint(Canvas canvas) {\n        calcPointsXY(a, f);\n        canvas.drawText(\"a\", a.x, a.y, pointPaint);\n\n        canvas.drawText(\"f\", f.x, f.y, pointPaint);\n\n        canvas.drawText(\"g\", g.x, g.y, pointPaint);\n\n        canvas.drawText(\"e\", e.x, e.y, pointPaint);\n        canvas.drawText(\"h\", h.x, h.y, pointPaint);\n\n        canvas.drawText(\"c\", c.x, c.y, pointPaint);\n        canvas.drawText(\"j\", j.x, j.y, pointPaint);\n\n        canvas.drawText(\"b\", b.x, b.y, pointPaint);\n        canvas.drawText(\"k\", k.x, k.y, pointPaint);\n\n        canvas.drawText(\"d\", d.x, d.y, pointPaint);\n        canvas.drawText(\"i\", i.x, i.y, pointPaint);\n\n\n    }\n\n    /**\n     * \u5982\u679cc\u70b9x\u5750\u6807\u5c0f\u4e8e0,\u6839\u636e\u89e6\u6478\u70b9\u91cd\u65b0\u6d4b\u91cfa\u70b9\u5750\u6807\n     */\n    private void calcPointAByTouchPoint() {\n        float w0 = vWidth - c.x;\n        float w1 = Math.abs(f.x - a.x);\n        float w2 = vWidth * w1 / w0;\n        a.x = Math.abs(f.x - w2);\n        float h1 = Math.abs(f.y - a.y);\n        float h2 = w2 * h1 / w1;\n        a.y = Math.abs(f.y - h2);\n    }\n\n\n    private float calcPointCX(FPoint f) {\n        g2.setXY(0F, 0F);\n        e2.setXY(0F, 0F);\n\n        g2.x = (a.x + f.x) / 2;\n        g2.y = (a.y + f.y) / 2;\n\n        e2.x = g2.x - (f.y - g2.y) * (f.y - g2.y) / (f.x - g2.x);\n        e2.y = f.y;\n\n        return e2.x - (f.x - e2.x) / 2;\n    }\n\n\n    /**\n     * \u8ba1\u7b97\u5207\u70b9\u5750\u6807\uff0c\u8fd9\u91cc\u5c31\u6ca1\u6709\u63a8\u5bfc\u516c\u5f0f\u4e86\uff0c\u76f4\u63a5\u62ff\u6765\u7528\u4e86\n     *\n     * @param lineOne_My_pointOne\n     * @param lineOne_My_pointTwo\n     * @param lineTwo_My_pointOne\n     * @param lineTwo_My_pointTwo\n     * @return\n     */\n    private void caculateIntersectionPoint(FPoint save, FPoint lineOne_My_pointOne, FPoint lineOne_My_pointTwo, FPoint lineTwo_My_pointOne, FPoint lineTwo_My_pointTwo) {\n        float x1, y1, x2, y2, x3, y3, x4, y4;\n        x1 = lineOne_My_pointOne.x;\n        y1 = lineOne_My_pointOne.y;\n        x2 = lineOne_My_pointTwo.x;\n        y2 = lineOne_My_pointTwo.y;\n        x3 = lineTwo_My_pointOne.x;\n        y3 = lineTwo_My_pointOne.y;\n        x4 = lineTwo_My_pointTwo.x;\n        y4 = lineTwo_My_pointTwo.y;\n\n        float pointX = ((x1 - x2) * (x3 * y4 - x4 * y3) - (x3 - x4) * (x1 * y2 - x2 * y1)) / ((x3 - x4) * (y1 - y2) - (x1 - x2) * (y3 - y4));\n        float pointY = ((y1 - y2) * (x3 * y4 - x4 * y3) - (x1 * y2 - x2 * y1) * (y3 - y4)) / ((y1 - y2) * (x3 - x4) - (x1 - x2) * (y3 - y4));\n        save.setXY(pointX, pointY);\n    }\n\n\n    /**\n     * \u8ba1\u7b97\u5404\u70b9\u5750\u6807\n     *\n     * @param a\n     * @param f\n     */\n    private void calcPointsXY(FPoint a, FPoint f) {\n        g.x = (a.x + f.x) / 2;\n        g.y = (a.y + f.y) / 2;\n\n        e.x = g.x - (f.y - g.y) * (f.y - g.y) / (f.x - g.x);\n        e.y = f.y;\n\n        h.x = f.x;\n        h.y = g.y - (f.x - g.x) * (f.x - g.x) / (f.y - g.y);\n\n        c.x = e.x - (f.x - e.x) / 2;\n        c.y = f.y;\n\n        j.x = f.x;\n        j.y = h.y - (f.y - h.y) / 2;\n\n        caculateIntersectionPoint(b, a, e, c, j);\n        caculateIntersectionPoint(k, a, h, c, j);\n\n        d.x = (c.x + 2 * e.x + b.x) / 4;\n        d.y = (2 * e.y + c.y + b.y) / 4;\n\n        i.x = (j.x + 2 * h.x + k.x) / 4;\n        i.y = (2 * h.y + j.y + k.y) / 4;\n\n        //\u8ba1\u7b97d\u70b9\u5230ae\u7684\u8ddd\u79bb\n        float lA = a.y - e.y;\n        float lB = e.x - a.x;\n        float lC = a.x * e.y - e.x * a.y;\n        lPathAShadowDis = Math.abs((lA * d.x + lB * d.y + lC) / (float) Math.hypot(lA, lB));\n\n        //\u8ba1\u7b97i\u70b9\u5230ah\u7684\u8ddd\u79bb\n        float rA = a.y - h.y;\n        float rB = h.x - a.x;\n        float rC = a.x * h.y - h.x * a.y;\n        rPathAShadowDis = Math.abs((rA * i.x + rB * i.y + rC) / (float) Math.hypot(rA, rB));\n    }\n\n    protected class ScrollRunnable implements Runnable {\n        @Override", "        public void run() {\n            readAnimView.reset();\n            curlAnimationRunning = false;\n            invalidate();\n        }\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/PuppetView.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewParent;\n", "import android.view.ViewParent;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\n\nimport com.juziml.read.business.read.anim.AnimHelper;\nimport com.juziml.read.business.read.anim.CoverAnimationEffecter;\nimport com.juziml.read.business.read.anim.IAnimationEffecter;\nimport com.juziml.read.business.read.anim.SimulationAnimationEffecter;\n", "import com.juziml.read.business.read.anim.SimulationAnimationEffecter;\n\n\n/**\n * \u6b64View\u7684\u4f5c\u7528\u5c31\u50cf\u5e55\u540e\u4e00\u6837\uff0c\u8d1f\u8d23\u63a5\u53d7\u4e8b\u4ef6\u5e76\u4f20\u9012\u5230\u52a8\u753b\uff0cEffecter\n * create by zhusw on 2020-08-14 17:37\n */\npublic class PuppetView extends View implements EventProxy, AnimParentView {\n\n    IAnimationEffecter animationEffecter;\n    AnimParentView parentView;\n    private Bitmap previousViewBitmap;\n    private Bitmap currentViewBitmap;\n    private Bitmap nextViewBitmap;\n    boolean performDrawCurlTexture = false;\n    private int vWidth, vHeight;\n\n    public PuppetView(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public PuppetView(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public PuppetView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        /*\n            view \u53ef\u4ee5\u5355\u72ec\u5173\uff0c\u4f46\u662f\u4e0d\u80fd\u5355\u72ec\u6253\u5f00\u786c\u4ef6\u52a0\u901f\n            \u5173\u95ed\u786c\u4ef6\u52a0\u901f \u5361\u5230\u7206\u70b8\n            \u5f00\u542f\u786c\u4ef6\u52a0\u901f\uff0c\u8bf1\u53d1 OpenGLRenderer: Path too large to be rendered into a texture\n            setLayerType(LAYER_TYPE_SOFTWARE,null);\n         */\n    }\n", "    public boolean animRunningOrTouching() {\n        boolean animRunningOrTouching = false;\n        if (null != animationEffecter) {\n            animRunningOrTouching = animRunning();\n        }\n        return animRunningOrTouching;\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        ViewParent viewParent = getParent();\n        parentView = (AnimParentView) viewParent;", "        if (null != animationEffecter) {\n            animationEffecter.onViewAttachedToWindow();\n        }\n    }\n\n\n    public void setAnimMode(int animMode) {\n        //\u91cd\u7f6e\u67d0\u4e9b\u5c5e\u6027 \u4e0e\u53d8\u91cf\n        animationEffecter = null;\n        if (animMode == BookLayoutManager.BookFlipMode.MODE_COVER) {\n            animationEffecter = new CoverAnimationEffecter(this);", "        if (animMode == BookLayoutManager.BookFlipMode.MODE_COVER) {\n            animationEffecter = new CoverAnimationEffecter(this);\n        } else if (animMode == BookLayoutManager.BookFlipMode.MODE_CURL) {\n            animationEffecter = new SimulationAnimationEffecter(this);\n        }\n        if (null != animationEffecter) {\n            animationEffecter.onViewSizeChanged(vWidth, vHeight);\n        }\n    }\n\n    @Override", "    public void draw(Canvas canvas) {\n        if (performDrawCurlTexture && null != animationEffecter) {\n            animationEffecter.draw(canvas);\n        } else {\n            super.draw(canvas);\n        }\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();", "        if (null != animationEffecter) {\n            animationEffecter.onViewDetachedFromWindow();\n        }\n    }\n\n    /**\n     * \u8fd9\u4e2a\u4f1a\u88ab\u8c03\u7528\u591a\u6b21\uff0c\u6700\u7ec8\u5bbd\u5ea6\u4e3a\u5b9e\u9645\u6d4b\u91cf\u5bbd\u5ea6-2px\n     * \u8fd9\u6837\u5728 layoutmanager \u8fdb\u884c\u5e03\u5c40\u65f6 \u624d\u53ef\u4ee5\u540c\u65f6\u4fdd\u63013\u4e2aitem\u88ab\u663e\u793a\n     *\n     * @param widthMeasureSpec\n     * @param heightMeasureSpec\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int height = measureSize(5, heightMeasureSpec);\n        int width = measureSize(5, widthMeasureSpec) - 2;\n        setMeasuredDimension(width - 2, height);\n        vWidth = width;\n        vHeight = height;", "        if (null != animationEffecter) {\n            animationEffecter.onViewSizeChanged(vWidth, vHeight);\n        }\n    }\n\n\n    private int measureSize(int defaultSize, int measureSpec) {\n        int result = defaultSize;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n        if (specMode == MeasureSpec.EXACTLY) {\n            result = specSize;", "        if (specMode == MeasureSpec.EXACTLY) {\n            result = specSize;\n        } else if (specMode == MeasureSpec.AT_MOST) {\n            result = Math.min(result, specSize);\n        }\n        return result;\n    }\n\n\n    public void buildBitmap(int slideDirection) {\n        performDrawCurlTexture = false;", "    public void buildBitmap(int slideDirection) {\n        performDrawCurlTexture = false;\n        if (slideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            currentViewBitmap = parentView.getCurrentBitmap();\n            nextViewBitmap = parentView.getNextBitmap();\n        } else if (slideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n            previousViewBitmap = parentView.getPreviousBitmap();\n        }\n        performDrawCurlTexture = true;\n    }\n\n\n    @Override", "    public boolean onItemViewTouchEvent(MotionEvent event) {\n        if (null != animationEffecter) {\n            animationEffecter.handlerEvent(event);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean animRunning() {\n        if (null != animationEffecter) {\n            return animationEffecter.animInEffect();\n        }\n        return false;\n    }\n\n    @Override", "    public boolean animRunning() {\n        if (null != animationEffecter) {\n            return animationEffecter.animInEffect();\n        }\n        return false;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (null != animationEffecter) {\n            animationEffecter.onScroll();\n        }\n    }\n\n    @Override", "    public void computeScroll() {\n        if (null != animationEffecter) {\n            animationEffecter.onScroll();\n        }\n    }\n\n    @Override\n    public void onExpectNext() {\n        parentView.onExpectNext();\n    }\n\n    @Override", "    public void onExpectPrevious() {\n        parentView.onExpectPrevious();\n    }\n\n    @Override\n    public Bitmap getPreviousBitmap() {\n        return previousViewBitmap;\n    }\n\n    @Override\n    public Bitmap getCurrentBitmap() {\n        return currentViewBitmap;\n    }\n\n    @Override", "    public Bitmap getCurrentBitmap() {\n        return currentViewBitmap;\n    }\n\n    @Override\n    public Bitmap getNextBitmap() {\n        return nextViewBitmap;\n    }\n\n    @Override\n    public int getBackgroundColor() {\n        return parentView.getBackgroundColor();\n    }\n\n    @Override", "    public int getBackgroundColor() {\n        return parentView.getBackgroundColor();\n    }\n\n    @Override\n    public AnimHelper getAnimHelper() {\n        return parentView.getAnimHelper();\n    }\n\n    @Override\n    public void onClickMenuArea() {\n        parentView.onClickMenuArea();\n    }\n\n    @Override", "    public void onClickMenuArea() {\n        parentView.onClickMenuArea();\n    }\n\n    @Override\n    public void onClickNextArea() {\n        parentView.onClickNextArea();\n    }\n\n    @Override\n    public void onClickPreviousArea() {\n        parentView.onClickPreviousArea();\n    }\n", "    public void onClickPreviousArea() {\n        parentView.onClickPreviousArea();\n    }\n\n    public void reset() {\n        previousViewBitmap = null;\n        nextViewBitmap = null;\n        currentViewBitmap = null;\n        performDrawCurlTexture = false;\n    }\n\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/FPoint.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\n/**\n * create by zhusw on 2020-07-30 17:05\n */\npublic class FPoint {\n    public float x, y;\n\n    public FPoint() {\n    }\n\n    public FPoint(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n", "    public void setXY(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/PaperLayout.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.RectF;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.widget.LinearLayout;", "import android.view.MotionEvent;\nimport android.widget.LinearLayout;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\n\n/**\n * \u4f5c\u4e3a\u6839\u5e03\u5c40\u4f7f\u7528\uff0c\u6700\u597d\u518d\u586b\u5145\u4e00\u4e2aViewGroup\u5e76\u8bbe\u7f6ematch_parent\n * \u5fc5\u987b\u5f00\u542f\u786c\u4ef6\u52a0\u901f\uff0c\u5426\u5219\u6389\u5e27\n * create by zhusw on 2020-07-28 16:00", " * \u5fc5\u987b\u5f00\u542f\u786c\u4ef6\u52a0\u901f\uff0c\u5426\u5219\u6389\u5e27\n * create by zhusw on 2020-07-28 16:00\n */\npublic class PaperLayout extends LinearLayout {\n    private final Canvas viewScreenShotCanvas;\n\n    private BookRecyclerView bookRecyclerView;\n    private final RectF menuBounds;\n\n    public PaperLayout(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public PaperLayout(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public PaperLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        viewScreenShotCanvas = new Canvas();\n        menuBounds = new RectF();\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        bookRecyclerView = (BookRecyclerView) getParent();\n\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);", "        if (bookRecyclerView.getFlipMode() == BookLayoutManager.BookFlipMode.MODE_CURL\n                || bookRecyclerView.getFlipMode() == BookLayoutManager.BookFlipMode.MODE_COVER) {\n            requestDisallowInterceptTouchEvent(true);\n        } else {\n            requestDisallowInterceptTouchEvent(false);\n        }\n        menuBounds.left = getWidth() / 3F;\n        menuBounds.top = getHeight() / 3F;\n        menuBounds.right = getWidth() * 2 / 3F;\n        menuBounds.bottom = getHeight() * 2 / 3F;\n    }\n\n    private int offset = -2;\n\n    /**\n     * \u8fd9\u4e2a\u4f1a\u88ab\u8c03\u7528\u591a\u6b21\uff0c\u6700\u7ec8\u5bbd\u5ea6\u4e3a\u5b9e\u9645\u6d4b\u91cf\u5bbd\u5ea6-2px\n     * \u8fd9\u6837\u5728 layoutManager \u8fdb\u884c\u5e03\u5c40\u65f6 \u624d\u53ef\u4ee5\u540c\u65f6\u4fdd\u63013\u4e2aitem\u88ab\u663e\u793a\n     *\n     * @param widthMeasureSpec\n     * @param heightMeasureSpec\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int height = measureSize(5, heightMeasureSpec);\n        int width = measureSize(5, widthMeasureSpec);\n        setMeasuredDimension(width + offset, height);\n    }\n\n\n    private int measureSize(int defaultSize, int measureSpec) {\n        int result = defaultSize;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n", "        if (specMode == MeasureSpec.EXACTLY) {\n            result = specSize;\n        } else if (specMode == MeasureSpec.AT_MOST) {\n            result = Math.min(result, specSize);\n        }\n        return result;\n    }\n\n    public Bitmap drawViewScreenShotToBitmap(Bitmap bitmap) {\n        viewScreenShotCanvas.setBitmap(bitmap);\n        draw(viewScreenShotCanvas);\n        return bitmap;\n    }\n\n    @Override", "    public Bitmap drawViewScreenShotToBitmap(Bitmap bitmap) {\n        viewScreenShotCanvas.setBitmap(bitmap);\n        draw(viewScreenShotCanvas);\n        return bitmap;\n    }\n\n    @Override\n    public boolean isScrollContainer() {\n        return false;\n    }\n\n\n    private float interceptDownX;\n\n    @Override", "    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        //\u52a8\u753b\u6267\u884c\u671f\u95f4 \u5b50view \u4e5f\u4e0d\u53ef\u83b7\u53d6\u4e8b\u4ef6\n        if (bookRecyclerView.animRunning()) return true;\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            interceptDownX = ev.getRawX();\n        } else if (ev.getAction() == MotionEvent.ACTION_MOVE) {\n            float currentX = ev.getRawX();\n            float distance = Math.abs(currentX - interceptDownX);\n            if (distance > 1F) {\n                return true;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    private float receiveDownX = -1;\n    private float downX = -1;\n    private float downY = -1;\n\n    @SuppressLint(\"ClickableViewAccessibility\")\n    @Override", "            if (distance > 1F) {\n                return true;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    private float receiveDownX = -1;\n    private float downX = -1;\n    private float downY = -1;\n\n    @SuppressLint(\"ClickableViewAccessibility\")\n    @Override", "    public boolean onTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            receiveDownX = ev.getRawX();\n            downX = ev.getRawX();\n            downY = ev.getRawY();\n        } else if (ev.getAction() == MotionEvent.ACTION_MOVE) {\n            if (receiveDownX == -1) {\n                ev.setAction(MotionEvent.ACTION_DOWN);\n                receiveDownX = ev.getRawX();\n            }\n        } else if (ev.getAction() == MotionEvent.ACTION_UP\n                || ev.getAction() == MotionEvent.ACTION_CANCEL) {\n            receiveDownX = -1;\n        }", "        } else if (ev.getAction() == MotionEvent.ACTION_UP\n                || ev.getAction() == MotionEvent.ACTION_CANCEL) {\n            receiveDownX = -1;\n        }\n        if (bookRecyclerView.getFlipMode() == BookLayoutManager.BookFlipMode.MODE_NORMAL) {\n            if (ev.getAction() == MotionEvent.ACTION_UP) {\n                float upX = ev.getRawX();\n                float upY = ev.getRawY();\n                if (downX > menuBounds.left\n                        && downY > menuBounds.top\n                        && downX < menuBounds.right\n                        && downY < menuBounds.bottom\n                        && upX > menuBounds.left\n                        && upY > menuBounds.top\n                        && upX < menuBounds.right\n                        && upY < menuBounds.bottom) {\n                    bookRecyclerView.onClickMenu();", "                if (downX > menuBounds.left\n                        && downY > menuBounds.top\n                        && downX < menuBounds.right\n                        && downY < menuBounds.bottom\n                        && upX > menuBounds.left\n                        && upY > menuBounds.top\n                        && upX < menuBounds.right\n                        && upY < menuBounds.bottom) {\n                    bookRecyclerView.onClickMenu();\n                } else if (upX >= getWidth() / 2F) {\n                    bookRecyclerView.onExpectNext(true);", "                } else if (upX >= getWidth() / 2F) {\n                    bookRecyclerView.onExpectNext(true);\n                } else if (upX < getWidth() / 2F) {\n                    bookRecyclerView.onExpectPrevious(true);\n                }\n            }\n        } else {\n            bookRecyclerView.onItemViewTouchEvent(ev);\n        }\n        return true;\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/AnimParentView.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.graphics.Bitmap;\n\nimport com.juziml.read.business.read.anim.AnimHelper;\n\n/**\n * create by zhusw on 2020-08-03 11:28\n */\npublic interface AnimParentView {\n    void onExpectNext();\n\n    void onExpectPrevious();\n\n    Bitmap getPreviousBitmap();\n\n    Bitmap getCurrentBitmap();\n\n    Bitmap getNextBitmap();\n\n    int getBackgroundColor();\n\n    AnimHelper getAnimHelper();\n\n    void onClickMenuArea();\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    void onClickNextArea();\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    void onClickPreviousArea();\n\n}\n", " */\npublic interface AnimParentView {\n    void onExpectNext();\n\n    void onExpectPrevious();\n\n    Bitmap getPreviousBitmap();\n\n    Bitmap getCurrentBitmap();\n\n    Bitmap getNextBitmap();\n\n    int getBackgroundColor();\n\n    AnimHelper getAnimHelper();\n\n    void onClickMenuArea();\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    void onClickNextArea();\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    void onClickPreviousArea();\n\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/BookLayoutManager.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.ValueAnimator;\nimport android.content.Context;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.animation.LinearInterpolator;\n", "import android.view.animation.LinearInterpolator;\n\nimport androidx.annotation.IntDef;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.List;", "import java.lang.annotation.Target;\nimport java.util.List;\n\n\n/**\n * create by zhusw on 2020-03-29 17:11\n */\npublic class BookLayoutManager extends RecyclerView.LayoutManager {\n    private int bookFlipMode = BookFlipMode.MODE_CURL;\n\n    private Context context;\n    /**\n     * \u4e00\u6b21\u5b8c\u6574\u7684\u805a\u7126\u6ed1\u52a8\u6240\u9700\u8981\u7684\u79fb\u52a8\u8ddd\u79bb\n     */\n    private float onceCompleteScrollLength = -1;\n\n    /**\n     * \u7b2c\u4e00\u4e2a\u5b50view\u7684\u504f\u79fb\u91cf\n     */\n    private float firstChildCompleteScrollLength = -1;\n\n    /**\n     * \u5c4f\u5e55\u53ef\u89c1\u7b2c\u4e00\u4e2aview\u7684position\n     */\n    private int firstVisiPos;\n\n    /**\n     * \u5c4f\u5e55\u53ef\u89c1\u7684\u6700\u540e\u4e00\u4e2aview\u7684position\n     */\n    private int fastVisiPos;\n\n    /**\n     * \u6c34\u5e73\u65b9\u5411\u7d2f\u8ba1\u504f\u79fb\u91cf\n     */\n    private long horizontalOffset;\n\n    private int childWidth = 0;\n    private ValueAnimator selectAnimator;\n\n    private boolean autoLeftScroll = false;\n\n    private OnStopScroller onStopScroller;\n    private OnForceLayoutCompleted onForceLayoutCompleted;\n\n    public BookLayoutManager(Context context) {\n        this.context = context;\n    }\n", "    public void setonStopScroller(OnStopScroller onStopScroller) {\n        this.onStopScroller = onStopScroller;\n    }\n\n    @Override\n    public RecyclerView.LayoutParams generateDefaultLayoutParams() {\n        return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,\n                ViewGroup.LayoutParams.WRAP_CONTENT);\n    }\n\n    public void setBookFlipMode(@BookFlipMode int bookFlipMode) {\n        this.bookFlipMode = bookFlipMode;\n        requestLayout();\n    }\n", "    public void setBookFlipMode(@BookFlipMode int bookFlipMode) {\n        this.bookFlipMode = bookFlipMode;\n        requestLayout();\n    }\n\n    public int getBookFlipMode() {\n        return bookFlipMode;\n    }\n\n    public void setAutoLeftScroll(boolean autoLeftScroll) {\n        this.autoLeftScroll = autoLeftScroll;\n    }\n", "    public void setAutoLeftScroll(boolean autoLeftScroll) {\n        this.autoLeftScroll = autoLeftScroll;\n    }\n\n    public void setOnForceLayoutCompleted(OnForceLayoutCompleted onForceLayoutCompleted) {\n        this.onForceLayoutCompleted = onForceLayoutCompleted;\n    }\n\n    //\u786e\u8ba4\u5141\u8bb8\u6c34\u5e73\u6eda\u52a8\n    @Override\n    public boolean canScrollHorizontally() {\n        return true;\n    }\n\n\n    @Override", "    public boolean canScrollHorizontally() {\n        return true;\n    }\n\n\n    @Override\n    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        // \u8fd4\u56de\u7528\u4e8e\u5e03\u5c40\u7684view\u6570\u91cf\uff0c\uff01= adapter \u7684 \u5143\u7d20\u4e2a\u6570\n        if (state.getItemCount() == 0) {\n            removeAndRecycleAllViews(recycler);\n            return;\n        }\n        // \u5206\u79bb\u5168\u90e8\u5df2\u6709\u7684view \u653e\u5165\u4e34\u65f6\u7f13\u5b58  mAttachedScrap \u96c6\u5408\u4e2d\n        detachAndScrapAttachedViews(recycler);\n        //\u786e\u5b9a\u5e03\u5c40\uff0c\u7c7b\u4f3c\u4e8e viewGroup\u7684 onLayout\n        layout(recycler, 0);\n    }\n\n\n    private int layout(RecyclerView.Recycler recycler, int dx) {\n        int resultDelta = horizontalLayout(recycler, dx);\n        recycleChildren(recycler);\n        return resultDelta;\n    }\n\n    /**\n     * \u6700\u5927\u504f\u79fb\u91cf\n     *\n     * @return\n     */\n    private float getMaxOffset() {", "        if (state.getItemCount() == 0) {\n            removeAndRecycleAllViews(recycler);\n            return;\n        }\n        // \u5206\u79bb\u5168\u90e8\u5df2\u6709\u7684view \u653e\u5165\u4e34\u65f6\u7f13\u5b58  mAttachedScrap \u96c6\u5408\u4e2d\n        detachAndScrapAttachedViews(recycler);\n        //\u786e\u5b9a\u5e03\u5c40\uff0c\u7c7b\u4f3c\u4e8e viewGroup\u7684 onLayout\n        layout(recycler, 0);\n    }\n\n\n    private int layout(RecyclerView.Recycler recycler, int dx) {\n        int resultDelta = horizontalLayout(recycler, dx);\n        recycleChildren(recycler);\n        return resultDelta;\n    }\n\n    /**\n     * \u6700\u5927\u504f\u79fb\u91cf\n     *\n     * @return\n     */\n    private float getMaxOffset() {", "        if (childWidth == 0 || getItemCount() == 0) return 0;\n        return (childWidth) * (getItemCount() - 1);\n    }\n\n    @Override\n    public void onScrollStateChanged(int state) {\n        switch (state) {\n            case RecyclerView.SCROLL_STATE_DRAGGING://\u6ed1\u52a8\u624b\u52bf\u5f00\u59cb\n                cancelAnimator();\n                break;\n\n            case RecyclerView.SCROLL_STATE_IDLE://\u505c\u6b62\u6ed1\u52a8\n                final int selectPosition = findShouldSelectPosition();\n                smoothScrollToPosition(selectPosition);", "                if (null != onStopScroller) {\n                    onStopScroller.onStop(autoLeftScroll, selectPosition);\n                }\n                break;\n            default:\n                break;\n        }\n\n    }\n\n    /**\n     * \u5f3a\u5236\u6eda\u52a8\u5230\u6307\u5b9a\u4f4d\u7f6e\n     *\n     * @param position\n     */", "    public void forceScrollToPosition(int position) {\n        if (position > -1 && position < getItemCount()) {\n            scrollToPosition(position, false);\n        }\n    }\n\n    /**\n     * \u5e73\u6ed1\u6eda\u52a8\u5230\u67d0\u4e2a\u4f4d\u7f6e\n     *\n     * @param position \u76ee\u6807Item\u7d22\u5f15\n     */", "    public void smoothScrollToPosition(int position) {\n        if (position > -1 && position < getItemCount()) {\n            scrollToPosition(position, true);\n        }\n    }\n\n    public int findShouldSelectPosition() {\n        if (onceCompleteScrollLength == -1 || firstVisiPos == -1) {\n            return -1;\n        }\n        int position;", "        if (autoLeftScroll) {\n            position = (int) (Math.abs(horizontalOffset) / childWidth);\n//            int remainder = (int) (Math.abs(horizontalOffset) % childWidth);\n            // \u8d85\u8fc7\u4e34\u754c\u8ddd\u79bb \u9009\u4e2d\u4e0b\u4e00\u9875\uff0c108 \u4e3a 1/10\u7684 1080 \u5c4f\u5e55\n            //\u56fa\u5b9a\u4e34\u754c\u503c\uff0c\u907f\u514d\u5c4f\u5e55\u8d8a\u5927\u9700\u8981\u6ed1\u52a8\u7684\u8ddd\u79bb\u8d8a\u8fdc\n//            if (remainder >= ReadRecyclerView.MOVE_LEFT_MIN) {\n            if (position + 1 <= getItemCount() - 1) {\n                return position + 1;\n            }\n//            }\n        } else {\n            position = (int) (Math.abs(horizontalOffset) / childWidth);\n        }\n\n        return position;\n    }\n\n    private float getScrollToPositionOffset(int position) {\n        return position * childWidth - Math.abs(horizontalOffset);\n    }\n\n    private void scrollToPosition(final int position, boolean withAnim) {\n        cancelAnimator();\n        final float distance = getScrollToPositionOffset(position);", "        if (distance == 0) return;\n        if (withAnim) {\n\n            long minDuration = 100;\n            long maxDuration = 300;\n            long duration;\n\n            float distanceFraction = (Math.abs(distance) / childWidth);\n\n            if (distance <= childWidth) {\n                duration = (long) (minDuration + (maxDuration - minDuration) * distanceFraction);\n            } else {\n                duration = (long) (maxDuration * distanceFraction);\n            }\n            selectAnimator = ValueAnimator.ofFloat(0.0f, distance);\n            selectAnimator.setDuration(duration);\n            selectAnimator.setInterpolator(new LinearInterpolator());\n            final float startedOffset = horizontalOffset;\n            selectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override", "            if (distance <= childWidth) {\n                duration = (long) (minDuration + (maxDuration - minDuration) * distanceFraction);\n            } else {\n                duration = (long) (maxDuration * distanceFraction);\n            }\n            selectAnimator = ValueAnimator.ofFloat(0.0f, distance);\n            selectAnimator.setDuration(duration);\n            selectAnimator.setInterpolator(new LinearInterpolator());\n            final float startedOffset = horizontalOffset;\n            selectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override", "                public void onAnimationUpdate(ValueAnimator animation) {\n                    float value = (float) animation.getAnimatedValue();\n                    horizontalOffset = (long) (startedOffset + value);\n                    requestLayout();\n                    if (value == distance) {//\u4e3b\u52a8\u7ed9\u4e00\u4e2a\u6eda\u52a8\u56de\u8c03\uff0c\u56e0\u4e3a\u4e0d\u4f1a\u5904\u7f5aonScrollstop\n                        if (null != onStopScroller) {\n                            onStopScroller.onStop(distance > 0, position);\n                        }\n                    }\n                }\n            });\n            selectAnimator.addListener(new AnimatorListenerAdapter() {\n                @Override", "                public void onAnimationEnd(Animator animation) {\n                    super.onAnimationEnd(animation);\n                }\n            });\n            selectAnimator.start();\n\n        } else {\n            horizontalOffset += (long) distance;\n            requestLayout();\n            if (null != onForceLayoutCompleted) {\n                onForceLayoutCompleted.onLayoutCompleted(position);\n            }\n        }\n\n\n    }\n", "            if (null != onForceLayoutCompleted) {\n                onForceLayoutCompleted.onLayoutCompleted(position);\n            }\n        }\n\n\n    }\n\n    public void cancelAnimator() {\n        if (selectAnimator != null && (selectAnimator.isStarted() || selectAnimator.isRunning())) {\n            selectAnimator.cancel();\n        }\n    }\n", "    public void cancelAnimator() {\n        if (selectAnimator != null && (selectAnimator.isStarted() || selectAnimator.isRunning())) {\n            selectAnimator.cancel();\n        }\n    }\n\n    public boolean animIsRunning() {\n        return selectAnimator != null && (selectAnimator.isStarted() || selectAnimator.isRunning());\n    }\n\n    private int horizontalLayout(RecyclerView.Recycler recycler, int dx) {\n        //-----------------------1 \u8fb9\u754c\u68c0\u6d4b---------------\n        //\u5df2\u8fbe\u5de6\u8fb9\u754c", "        if (dx < 0) {\n            if (horizontalOffset < 0) {\n                dx = 0;\n                horizontalOffset = dx;\n            }\n        }\n        //\u786e\u8ba4\u53f3\u8fb9\u754c\n        if (dx > 0) {\n            if (horizontalOffset >= getMaxOffset()) {\n                horizontalOffset = (long) getMaxOffset();\n                dx = 0;\n            }\n        }\n        // \u5206\u79bb\u5168\u90e8\u7684view\uff0c\u52a0\u5165\u5230\u4e34\u65f6\u7f13\u5b58\uff0c\u8fd9\u91cc\u8c03\u7528\uff0c\u56e0\u4e3a\u5728\u6ed1\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u663eview \u53ef\u80fd\u53d1\u751f\u6539\u53d8\n        detachAndScrapAttachedViews(recycler);\n\n        //-----------------------2 \u8ba1\u7b97\u7528\u4e8e view \u786e\u5b9a\u4f4d\u7f6e\u7684\u53c2\u6570---------------\n\n        float layoutX = 0;\n        float fraction = 0;\n\n        View tempView = null;\n\n        int tempPosition = -1;\n", "            if (horizontalOffset >= getMaxOffset()) {\n                horizontalOffset = (long) getMaxOffset();\n                dx = 0;\n            }\n        }\n        // \u5206\u79bb\u5168\u90e8\u7684view\uff0c\u52a0\u5165\u5230\u4e34\u65f6\u7f13\u5b58\uff0c\u8fd9\u91cc\u8c03\u7528\uff0c\u56e0\u4e3a\u5728\u6ed1\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u663eview \u53ef\u80fd\u53d1\u751f\u6539\u53d8\n        detachAndScrapAttachedViews(recycler);\n\n        //-----------------------2 \u8ba1\u7b97\u7528\u4e8e view \u786e\u5b9a\u4f4d\u7f6e\u7684\u53c2\u6570---------------\n\n        float layoutX = 0;\n        float fraction = 0;\n\n        View tempView = null;\n\n        int tempPosition = -1;\n", "        if (onceCompleteScrollLength == -1) {\n            // \u56e0\u4e3afirstVisiPos\u5728\u4e0b\u9762\u53ef\u80fd\u88ab\u6539\u53d8\uff0c\u6240\u4ee5\u7528tempPosition\u6682\u5b58\u4e00\u4e0b\n            tempPosition = firstVisiPos;\n            tempView = recycler.getViewForPosition(tempPosition);\n            measureChildWithMargins(tempView, 0, 0);\n            //\u4ee5\u7b2c\u4e00\u4e2a\u5b50view\u5bbd\u5ea6\u4e3a\u8ba1\u7b97\u6807\u51c6\uff0c\u8fd9\u6837\u5c31\u4e0d\u652f\u6301 itemType \u4e86\u3002\u5168\u90e8item\u8981\u4fdd\u6301\u5bbd\u5ea6\u4e00\u6837\uff0cmargin\u53c2\u6570\u4e00\u6837\n            childWidth = getDecoratedMeasurementHorizontal(tempView);\n        }\n        // \u4fee\u6b63\u7b2c\u4e00\u4e2a\u53ef\u89c1view firstVisiPos \u5df2\u7ecf\u6ed1\u52a8\u4e86\u591a\u5c11\u4e2a\u5b8c\u6574\u7684onceCompleteScrollLength\u5c31\u4ee3\u8868\u6ed1\u52a8\u4e86\u591a\u5c11\u4e2aitem\n\n        firstChildCompleteScrollLength = getWidth() / 2 + childWidth / 2;\n", "        if (horizontalOffset >= firstChildCompleteScrollLength) {\n            layoutX = 0;\n            onceCompleteScrollLength = childWidth;\n            //\u8ba1\u7b97 \u6eda\u52a8\u5230\u4e86 \u54ea\u4e2aview\u7684\u533a\u57df\n            firstVisiPos = (int) Math.floor(Math.abs(horizontalOffset - firstChildCompleteScrollLength) / onceCompleteScrollLength) + 1;\n            fraction = (Math.abs(horizontalOffset - firstChildCompleteScrollLength) % onceCompleteScrollLength) / (onceCompleteScrollLength * 1.0f);\n        } else {\n            firstVisiPos = 0;\n            layoutX = getMinOffset();\n            //\u8bb0\u5f55\u5355\u4e2aview \u9700\u8981\u6eda\u52a8\u7684\u8ddd\u79bb\n            onceCompleteScrollLength = firstChildCompleteScrollLength;\n            fraction = (Math.abs(horizontalOffset) % onceCompleteScrollLength) / (onceCompleteScrollLength * 1.0f);\n        }\n        // \u4e34\u65f6\u5c06fastVisiPos\u8d4b\u503c\u4e3agetItemCount() - 1\uff0c\u653e\u5fc3\uff0c\u4e0b\u9762\u904d\u5386\u65f6\u4f1a\u5224\u65adview\u662f\u5426\u5df2\u6ea2\u51fa\u5c4f\u5e55\uff0c\u5e76\u53ca\u65f6\u4fee\u6b63\u8be5\u503c\u5e76\u7ed3\u675f\u5e03\u5c40\n        //\u6ce8\u610f\u8fd9\u91cc \u662fadapter \u7684 \u4e2a\u6570\uff0c\u800c\u4e0d\u662f state \u4fdd\u5b58\u7684view \u663e\u793a\u6570\u91cf\n        fastVisiPos = getItemCount() - 1;\n        //\u8fd9\u91cc\u4f3c\u4e4e\u591a\u6b64\u4e00\u4e3e\u4e86 \uff0c\u53ef\u4ee5\u628a \u5206\u6bcd\u76f4\u63a5\u66ff\u6362\u4e3a normalViewOffset \u5728\u4e0a\u9762\u7684\u903b\u8f91\u4e2d\u8ba1\u7b97\u51fa\u6765\n        float normalViewOffset = onceCompleteScrollLength * fraction;\n        boolean isNormalViewOffsetSetted = false;\n\n        //-----------------------3 \u786e\u8ba4view\u4f4d\u7f6e---------------", "        for (int itemIndex = firstVisiPos; itemIndex <= fastVisiPos; itemIndex++) {\n\n            View itemView;\n\n            // \u5982\u679c\u521d\u59cb\u5316\u6570\u636e\u65f6\u5df2\u7ecf\u53d6\u4e86\u4e00\u4e2a\u4e34\u65f6view\n            if (itemIndex == tempPosition && null != tempView) {\n                itemView = tempView;\n            } else {\n                itemView = recycler.getViewForPosition(itemIndex);\n            }\n            //\u8ba1\u7b97\u65b0view \u4f4d\u7f6e\n            int focusPosition = (int) (Math.abs(horizontalOffset) / (childWidth));\n", "            if (itemIndex <= focusPosition) {\n                addView(itemView);\n            } else {\n                addView(itemView, 0);\n            }\n            //\u6d4b\u91cf\u65b0view\n            measureChildWithMargins(itemView, 0, 0);\n            if (!isNormalViewOffsetSetted) {\n                layoutX -= normalViewOffset;\n                isNormalViewOffsetSetted = true;\n            }\n            //\u8ba1\u7b97view layout \u5750\u6807\n            int left, top, right, bottom;\n            left = (int) layoutX;\n            top = 0;\n            right = left + getDecoratedMeasurementHorizontal(itemView);\n            bottom = top + getDecoratedMeasurementVertical(itemView);\n            layoutDecoratedWithMargins(itemView, left, top, right, bottom);\n            //\u66f4\u65b0\u4e0b\u4e00\u4e2aview X \u8f74\u5750\u6807\n            layoutX += childWidth;\n            //\u4fee\u6b63\u6ea2\u51fa\u5c4f\u5e55\u7684view\u4e2a\u6570", "            if (layoutX > getWidth() - getPaddingRight()) {\n                fastVisiPos = itemIndex;\n                break;\n            }\n        }//end for\n        return dx;\n    }\n\n    @Override\n    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {\n", "    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {\n\n        if (dx == 0 || getChildCount() == 0) {\n\n            return 0;\n        }\n        horizontalOffset += dx;\n        dx = layout(recycler, dx);\n\n        return dx;\n    }\n\n    /**\n     * \u56de\u6536\u9700\u56de\u6536\u7684item\n     */\n    private void recycleChildren(RecyclerView.Recycler recycler) {\n        List<RecyclerView.ViewHolder> scrapList = recycler.getScrapList();", "        for (int i = 0; i < scrapList.size(); i++) {\n            RecyclerView.ViewHolder holder = scrapList.get(i);\n            removeAndRecycleView(holder.itemView, recycler);\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u67d0\u4e2achildView\u5728\u7ad6\u76f4\u65b9\u5411\u6240\u5360\u7684\u7a7a\u95f4,\u5c06margin\u8003\u8651\u8fdb\u53bb\n     * \u5305\u542b\u4e86\u6307\u793a\u5668\n     *\n     * @param view\n     * @return\n     */", "    public int getDecoratedMeasurementVertical(View view) {\n        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)\n                view.getLayoutParams();\n        return getDecoratedMeasuredHeight(view) + params.topMargin\n                + params.bottomMargin;\n    }\n\n    /**\n     * \u83b7\u53d6\u67d0\u4e2achildView\u5728\u6c34\u5e73\u65b9\u5411\u6240\u5360\u7684\u7a7a\u95f4\uff0c\u5c06margin\u8003\u8651\u8fdb\u53bb\n     *\n     * @param view\n     * @return\n     */", "    public int getDecoratedMeasurementHorizontal(View view) {\n        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)\n                view.getLayoutParams();\n        return getDecoratedMeasuredWidth(view) + params.leftMargin\n                + params.rightMargin;\n    }\n\n    /**\n     * \u83b7\u53d6\u6700\u5c0f\u7684\u504f\u79fb\u91cf\n     *\n     * @return\n     */\n    private float getMinOffset() {", "        if (childWidth == 0) return 0;\n        return (getWidth() - childWidth) / 2;\n    }\n\n    protected void onRecyclerViewSizeChange() {\n        onceCompleteScrollLength = -1;\n    }\n\n    @Retention(RetentionPolicy.SOURCE)\n    @Target(ElementType.PARAMETER)\n    @IntDef({\n            BookFlipMode.MODE_NORMAL,\n            BookFlipMode.MODE_COVER,\n            BookFlipMode.MODE_CURL,\n\n    })\n    public @interface BookFlipMode {\n        int MODE_NORMAL = 1;\n        int MODE_COVER = 2;\n        int MODE_CURL = 3;\n\n    }\n", "    public interface OnStopScroller {\n        void onStop(boolean autoLeftScroll, int curPos);\n    }\n\n    public interface OnForceLayoutCompleted {\n        void onLayoutCompleted(final int curPos);\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/RVInnerItemFunction.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.view.MotionEvent;\n\n/**\n * -recyclerview \u5185\u90e8\u529f\u80fd\u63a5\u53e3\n * create by zhusw on 2020-08-17 10:07\n */\npublic interface RVInnerItemFunction {\n    void onItemViewTouchEvent(MotionEvent event);\n\n    boolean animRunning();\n\n    void onClickMenu();\n\n}\n", "public interface RVInnerItemFunction {\n    void onItemViewTouchEvent(MotionEvent event);\n\n    boolean animRunning();\n\n    void onClickMenu();\n\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/RVOuterFunction.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.graphics.Bitmap;\n\n/**\n * create by zhusw on 2020-08-17 10:15\n */\npublic interface RVOuterFunction {\n    void onExpectNext(boolean smooth);\n\n    void onExpectPrevious(boolean smooth);\n\n    Bitmap getPreviousBitmap();\n\n    Bitmap getCurrentBitmap();\n\n    Bitmap getNextBitmap();\n\n    int getFlipMode();\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/BookView.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Color;\nimport android.util.AttributeSet;\nimport android.view.Gravity;\nimport android.view.View;\nimport android.widget.FrameLayout;\n", "import android.widget.FrameLayout;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport com.juziml.read.business.read.anim.AnimHelper;\n\n/**\n * create by zhusw on 2020-08-14 17:33", "/**\n * create by zhusw on 2020-08-14 17:33\n */\npublic class BookView extends FrameLayout implements AnimParentView {\n\n    private BookRecyclerView bookRecyclerView;\n    private PuppetView puppetView;\n    private final AnimHelper animHelper;\n\n    private OnClickMenuListener onClickMenuListener;\n\n    private int itemViewBackgroundColor = Color.WHITE;\n    private Runnable dataPendIntentTask;\n\n    public BookView(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public BookView(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public BookView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        animHelper = new AnimHelper();\n        init();\n    }\n\n    private void init() {\n        removeAllViews();\n        bookRecyclerView = new BookRecyclerView(getContext());\n        puppetView = new PuppetView(getContext());\n        puppetView.setAnimMode(bookRecyclerView.getFlipMode());\n        bookRecyclerView.bindReadCurlAnimProxy(puppetView);\n        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);\n        params.gravity = Gravity.CENTER;\n        addView(bookRecyclerView, params);\n\n        LayoutParams params2 = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);\n        params2.gravity = Gravity.CENTER;\n        addView(puppetView, params2);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n\n        bookRecyclerView.bindReadCurlAnimProxy(puppetView);\n\n    }\n", "    public void setOnPositionChangedListener(OnPositionChangedListener onPositionChangedListener) {\n        bookRecyclerView.setOnPositionChangedListener(onPositionChangedListener);\n\n    }\n\n    public void setOnClickMenuListener(OnClickMenuListener onClickMenuListener) {\n        this.onClickMenuListener = onClickMenuListener;\n    }\n\n    public void scrollToPosition(int position) {\n        bookRecyclerView.scrollToPosition(position);\n    }\n", "    public void scrollToPosition(int position) {\n        bookRecyclerView.scrollToPosition(position);\n    }\n\n    public void smoothScrollToPosition(int position) {\n        bookRecyclerView.smoothScrollToPosition(position);\n    }\n\n    public void setAdapter(RecyclerView.Adapter adapter) {\n        bookRecyclerView.setAdapter(adapter);\n    }\n", "    public void setAdapter(RecyclerView.Adapter adapter) {\n        bookRecyclerView.setAdapter(adapter);\n    }\n\n    public void setItemViewBackgroundColor(int itemViewBackgroundColor) {\n        this.itemViewBackgroundColor = itemViewBackgroundColor;\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();", "        if (null != dataPendIntentTask) {\n            bookRecyclerView.removeCallbacks(dataPendIntentTask);\n        }\n    }\n\n    @Override\n    public void onExpectNext() {\n        bookRecyclerView.onExpectNext(false);\n        if (null != dataPendIntentTask) {\n            bookRecyclerView.post(dataPendIntentTask);\n            dataPendIntentTask = null;\n        }\n    }\n\n    @Override", "        if (null != dataPendIntentTask) {\n            bookRecyclerView.post(dataPendIntentTask);\n            dataPendIntentTask = null;\n        }\n    }\n\n    @Override\n    public void onExpectPrevious() {\n        bookRecyclerView.onExpectPrevious(false);\n        if (null != dataPendIntentTask) {\n            bookRecyclerView.post(dataPendIntentTask);\n            dataPendIntentTask = null;\n        }\n    }\n\n    @Override", "        if (null != dataPendIntentTask) {\n            bookRecyclerView.post(dataPendIntentTask);\n            dataPendIntentTask = null;\n        }\n    }\n\n    @Override\n    public Bitmap getPreviousBitmap() {\n        return bookRecyclerView.getPreviousBitmap();\n    }\n\n    @Override", "    public Bitmap getCurrentBitmap() {\n        return bookRecyclerView.getCurrentBitmap();\n    }\n\n    @Override\n    public Bitmap getNextBitmap() {\n        return bookRecyclerView.getNextBitmap();\n    }\n\n    @Override\n    public int getBackgroundColor() {\n        return itemViewBackgroundColor;\n    }\n\n", "    public int getBackgroundColor() {\n        return itemViewBackgroundColor;\n    }\n\n\n    public void setFlipMode(int flipMode) {\n        if (flipMode == BookLayoutManager.BookFlipMode.MODE_CURL\n                || flipMode == BookLayoutManager.BookFlipMode.MODE_COVER) {\n            puppetView.setVisibility(View.VISIBLE);\n        } else {\n            puppetView.setVisibility(View.INVISIBLE);//\u4e0d\u53ef\u4ee5\u8bbe\u7f6e\u4e3agone\uff0c\u907f\u514danimView \u65e0\u6cd5\u83b7\u53d6\u5c3a\u5bf8\n        }\n        bookRecyclerView.setFlipMode(flipMode);\n        puppetView.setAnimMode(flipMode);\n\n    }\n\n    @Override", "    public AnimHelper getAnimHelper() {\n        return animHelper;\n    }\n\n    @Override\n    public void onClickMenuArea() {\n        if (null != onClickMenuListener) {\n            onClickMenuListener.onClickMenu();\n        }\n    }\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    @Override", "    public void onClickNextArea() {\n        bookRecyclerView.onExpectNext(true);\n    }\n\n    /**\n     * \u53ea\u5728\u975e\u5377\u66f2\u6a21\u5f0f\u4e0b\u8c03\u7528\n     */\n    @Override\n    public void onClickPreviousArea() {\n        bookRecyclerView.onExpectPrevious(true);\n    }\n", "    public void onClickPreviousArea() {\n        bookRecyclerView.onExpectPrevious(true);\n    }\n\n    public boolean checkAllowChangeData() {\n        return !puppetView.animRunningOrTouching()\n                || bookRecyclerView.getFlipMode() == BookLayoutManager.BookFlipMode.MODE_NORMAL;\n    }\n\n    /**\n     * @param dataPendIntentTask\n     */", "    public void setDataPendIntentTask(Runnable dataPendIntentTask) {\n        this.dataPendIntentTask = dataPendIntentTask;\n    }\n\n    public interface OnPositionChangedListener {\n        void onChanged(boolean arriveNext, int curPosition);\n    }\n\n    public interface OnClickMenuListener {\n        void onClickMenu();\n    }\n\n\n}\n", "    public interface OnClickMenuListener {\n        void onClickMenu();\n    }\n\n\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/EventProxy.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.view.MotionEvent;\n\n/**\n * create by zhusw on 2020-08-14 18:37\n */\npublic interface EventProxy {\n    boolean onItemViewTouchEvent(MotionEvent event);\n\n    boolean animRunning();\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/business/read/view/BookRecyclerView.java", "chunked_list": ["package com.juziml.read.business.read.view;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport androidx.annotation.Nullable;", "\nimport androidx.annotation.Nullable;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport java.lang.ref.WeakReference;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\n/**", "\n/**\n * \u5173\u95ed\u4e86\u629b\u6295\u6548\u679c\n * create by zhusw on 2020-03-30 11:51\n */\npublic class BookRecyclerView extends RecyclerView implements RVInnerItemFunction, RVOuterFunction {\n\n    private final BookLayoutManager readLayoutManger;\n\n    private boolean allowInterceptTouchEvent = true;\n\n    private int currentPosition = 0;\n    private WeakReference<EventProxy> eventProxyWeakReference;\n    private AnimParentView animParentView;\n    private BookView.OnPositionChangedListener onPositionChangedListener;\n\n    public BookRecyclerView(Context context) {\n        this(context, null);\n    }\n\n    public BookRecyclerView(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public BookRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        readLayoutManger = new BookLayoutManager(context);\n        setLayoutManager(readLayoutManger);\n        readLayoutManger.setOnForceLayoutCompleted(new ItemOnForceLayoutCompleted());\n        readLayoutManger.setonStopScroller(new ItemOnScrollStop());\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        animParentView = (AnimParentView) getParent();\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        eventProxyWeakReference.clear();\n    }\n\n    protected void bindReadCurlAnimProxy(EventProxy ic) {", "        if (null != eventProxyWeakReference) {\n            eventProxyWeakReference.clear();\n        }\n        eventProxyWeakReference = new WeakReference<>(ic);\n    }\n\n\n    protected void setOnPositionChangedListener(BookView.OnPositionChangedListener onPositionChangedListener) {\n        this.onPositionChangedListener = onPositionChangedListener;\n    }\n\n    @Override", "    public boolean fling(int velocityX, int velocityY) {\n        return false;\n    }\n\n    @Override\n    public void scrollToPosition(int position) {\n        readLayoutManger.forceScrollToPosition(position);\n    }\n\n    @Override\n    public void smoothScrollToPosition(int position) {\n        readLayoutManger.smoothScrollToPosition(position);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        readLayoutManger.onRecyclerViewSizeChange();\n    }\n\n\n    private final List<Float> moveSampling = new LinkedList<>();\n    private final int MAX_COUNT = 5;\n\n    @Override", "    public void smoothScrollToPosition(int position) {\n        readLayoutManger.smoothScrollToPosition(position);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        readLayoutManger.onRecyclerViewSizeChange();\n    }\n\n\n    private final List<Float> moveSampling = new LinkedList<>();\n    private final int MAX_COUNT = 5;\n\n    @Override", "    public boolean isScrollContainer() {\n        if (allowInterceptTouchEvent) {\n            return super.isScrollContainer();\n        } else {\n            return false;\n        }\n\n    }\n\n    private float downX = 0F;\n\n    @SuppressLint(\"ClickableViewAccessibility\")\n    @Override", "    public boolean onTouchEvent(MotionEvent e) {\n        if (!allowInterceptTouchEvent) return false;//[\u5076\u73b0 \u52a8\u753b\u671f\u95f4 \u4ea7\u751f\u4e86item\u6ed1\u52a8\uff0c\u8fd9\u91cc\u6700\u540e\u6740\u624b\u950f\u518d\u5c4f\u853d\u4e0b]\n\n        switch (e.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                moveSampling.clear();\n                downX = e.getRawX();\n                break;\n            case MotionEvent.ACTION_MOVE:\n                float mx = e.getRawX();\n", "                if (moveSampling.size() == 0\n                        || mx != moveSampling.get(moveSampling.size() - 1)) {\n                    moveSampling.add(mx);\n                }\n                if (moveSampling.size() > MAX_COUNT) {\n                    moveSampling.remove(0);\n                }\n\n                break;\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:", "                if (moveSampling.size() > 0) {\n                    float lastMoveX = moveSampling.get(moveSampling.size() - 1);\n                    float firstMoveX = moveSampling.get(0);\n                    float finallyMoveX = lastMoveX - firstMoveX;\n                    if (lastMoveX - downX < 0) {//\u5de6\u6ed1\n                        readLayoutManger.setAutoLeftScroll(finallyMoveX < 10);\n                    } else {\n                        readLayoutManger.setAutoLeftScroll(finallyMoveX < 0);\n                    }\n                    moveSampling.clear();\n                } else {\n                    readLayoutManger.setAutoLeftScroll(false);\n                }\n\n                break;\n            default:\n                break;\n        }\n        return super.onTouchEvent(e);\n    }\n\n    @Override", "    public boolean onInterceptTouchEvent(MotionEvent e) {\n        //\u4ea4\u7531\u7236\u7c7b\u5904\u7406\u6ed1\u52a8\uff0cflip = BookFlipMode.MODE_NORMAL,\n        if (allowInterceptTouchEvent) {\n            return super.onInterceptTouchEvent(e);\n        }\n        //\u4ea4\u7531\u5b50View\u81ea\u884c\u5904\u7406,flip = BookFlipMode.MODE_COVER| BookFlipMode.MODE_CURL\n        return false;\n    }\n\n    @Override\n    public void onExpectNext(boolean smooth) {\n        Adapter adapter = getAdapter();\n        final int dataCount = adapter.getItemCount();\n        final int nextPos = currentPosition + 1;\n", "    public void onExpectNext(boolean smooth) {\n        Adapter adapter = getAdapter();\n        final int dataCount = adapter.getItemCount();\n        final int nextPos = currentPosition + 1;\n\n        if (nextPos < dataCount) {\n            if (smooth) {\n                smoothScrollToPosition(nextPos);\n            } else {\n                scrollToPosition(nextPos);\n            }\n        }\n    }\n\n    @Override", "    public void onExpectPrevious(boolean smooth) {\n        if (currentPosition - 1 >= 0) {\n            if (smooth) {\n                smoothScrollToPosition(currentPosition - 1);\n            } else {\n                scrollToPosition(currentPosition - 1);\n            }\n        }\n\n    }\n\n    protected void setFlipMode(int flipMode) {\n        readLayoutManger.setBookFlipMode(flipMode);", "        if (flipMode == BookLayoutManager.BookFlipMode.MODE_CURL\n                || flipMode == BookLayoutManager.BookFlipMode.MODE_COVER) {\n            allowInterceptTouchEvent = false;\n        } else {\n            allowInterceptTouchEvent = true;\n        }\n        readLayoutManger.requestLayout();\n    }\n\n    @Override\n    public int getFlipMode() {\n        return readLayoutManger.getBookFlipMode();\n    }\n\n    @Override", "    public int getFlipMode() {\n        return readLayoutManger.getBookFlipMode();\n    }\n\n    @Override\n    public void onItemViewTouchEvent(MotionEvent event) {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().onItemViewTouchEvent(event);\n        }\n    }\n\n    @Override", "    public boolean animRunning() {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().animRunning();\n        }\n        return false;\n    }\n\n    @Override\n    public void onClickMenu() {\n        animParentView.onClickMenuArea();\n    }\n\n    private class ItemOnScrollStop implements BookLayoutManager.OnStopScroller {\n        @Override", "    public void onClickMenu() {\n        animParentView.onClickMenuArea();\n    }\n\n    private class ItemOnScrollStop implements BookLayoutManager.OnStopScroller {\n        @Override\n        public void onStop(boolean autoLeftScroll, int curPos) {\n            boolean arriveNext = currentPosition < curPos;\n            currentPosition = curPos;\n            if (null != onPositionChangedListener) {\n                onPositionChangedListener.onChanged(arriveNext, curPos);\n            }\n        }\n\n    }\n\n    private class ItemOnForceLayoutCompleted implements BookLayoutManager.OnForceLayoutCompleted {\n\n        @Override", "            if (null != onPositionChangedListener) {\n                onPositionChangedListener.onChanged(arriveNext, curPos);\n            }\n        }\n\n    }\n\n    private class ItemOnForceLayoutCompleted implements BookLayoutManager.OnForceLayoutCompleted {\n\n        @Override\n        public void onLayoutCompleted(final int curPos) {\n            boolean arriveNext = currentPosition < curPos;\n            currentPosition = curPos;", "        public void onLayoutCompleted(final int curPos) {\n            boolean arriveNext = currentPosition < curPos;\n            currentPosition = curPos;\n            if (null != onPositionChangedListener) {\n                onPositionChangedListener.onChanged(arriveNext, curPos);\n            }\n        }\n    }\n\n    @Override\n    public Bitmap getPreviousBitmap() {\n        int prePos = currentPosition - 1;\n        Bitmap pb = null;", "    public Bitmap getPreviousBitmap() {\n        int prePos = currentPosition - 1;\n        Bitmap pb = null;\n        if (prePos >= 0) {\n            pb = printViewToBitmap(prePos);\n        }\n        return pb;\n    }\n\n    @Override\n    public Bitmap getCurrentBitmap() {\n        return printViewToBitmap(currentPosition);\n    }\n\n    @Override", "    public Bitmap getCurrentBitmap() {\n        return printViewToBitmap(currentPosition);\n    }\n\n    @Override\n    public Bitmap getNextBitmap() {\n        final int dataCount = getAdapter().getItemCount();\n        int nextPos = currentPosition + 1;\n        Bitmap nb = null;\n        if (nextPos < dataCount) {\n            nb = printViewToBitmap(nextPos);\n        }\n        return nb;\n    }\n\n    /**\n     * \u5c06view\u6e32\u67d3\u7ed3\u679c \u6253\u5370\u5230\u4e00\u4e2abitmap\u4e0a\n     *\n     * @param pos\n     * @return\n     */\n    private Bitmap printViewToBitmap(int pos) {\n        View view = readLayoutManger.findViewByPosition(pos);", "        if (nextPos < dataCount) {\n            nb = printViewToBitmap(nextPos);\n        }\n        return nb;\n    }\n\n    /**\n     * \u5c06view\u6e32\u67d3\u7ed3\u679c \u6253\u5370\u5230\u4e00\u4e2abitmap\u4e0a\n     *\n     * @param pos\n     * @return\n     */\n    private Bitmap printViewToBitmap(int pos) {\n        View view = readLayoutManger.findViewByPosition(pos);", "        if (null != view) {\n            if (view instanceof PaperLayout) {\n                PaperLayout pageView = (PaperLayout) view;\n                Bitmap bitmapTarget = Bitmap.createBitmap(pageView.getWidth(), pageView.getHeight(), Bitmap.Config.ARGB_4444);\n                pageView.drawViewScreenShotToBitmap(bitmapTarget);\n                return bitmapTarget;\n            } else {\n                throw new IllegalArgumentException(\"item \u6839View\u5fc5\u987b\u4f7f\u7528 PaperLayout\");\n            }\n        }\n        return null;\n    }\n\n\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/utils/DLog.java", "chunked_list": ["package com.juziml.read.utils;\n\nimport android.util.Log;\n\n/**\n * create by zhusw on 2020-03-27 15:46\n */\npublic class DLog {\n\n    public static void log(String rules, Object... args) {\n        Log.i(\"DLog:\", String.format(rules, args));\n    }\n}\n", "    public static void log(String rules, Object... args) {\n        Log.i(\"DLog:\", String.format(rules, args));\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/utils/TraceUtils.java", "chunked_list": ["package com.juziml.read.utils;\n\nimport android.util.Log;\n\nimport com.juziml.read.BuildConfig;\n\n/**\n * create by zhusw on 2020-08-13 13:43\n */\npublic class TraceUtils {\n    private static String msg = null;\n    private static long time = 0;\n", " */\npublic class TraceUtils {\n    private static String msg = null;\n    private static long time = 0;\n\n    public static void startTrace(String format, Object... o) {\n        if (BuildConfig.DEBUG) {\n            msg = String.format(format, o);\n            time = System.currentTimeMillis();\n        }\n    }\n", "    public static void endTrace() {\n        if (BuildConfig.DEBUG) {\n            String content = String.format(\"TAG:%s time:%s\", msg, System.currentTimeMillis() - time);\n            Log.i(\"TraceUtils\", content);\n            time = 0l;\n        }\n    }\n}\n"]}
{"filename": "app/src/main/java/com/juziml/read/core/App.java", "chunked_list": ["package com.juziml.read.core;\n\nimport android.content.Context;\n\nimport androidx.annotation.NonNull;\n\nimport com.bumptech.glide.Glide;\n\n/**\n * Created by victor on 2020/9/10.", "/**\n * Created by victor on 2020/9/10.\n * Email : victorhhl@163.com\n * Description :\n */\npublic class App extends ArchApplication {\n\n    public static App instance;\n\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        instance = this;\n    }\n\n    /**\n     * \u83b7\u53d6Application\u5b9e\u4f8b\n     */\n    @NonNull", "    public static App get() {\n        return instance;\n    }\n\n    @Override\n    public void onTrimMemory(int level) {\n        super.onTrimMemory(level);\n        Glide.get(this).trimMemory(level);\n    }\n\n    @Override", "    public void onLowMemory() {\n        super.onLowMemory();\n        Glide.get(this).onLowMemory();\n        System.gc();\n    }\n}\n\n\n"]}
