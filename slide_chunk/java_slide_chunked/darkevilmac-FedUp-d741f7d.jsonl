{"filename": "fedup-generator/src/main/java/com/tridevmc/Main.java", "chunked_list": ["package com.tridevmc;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello world!\");\n    }\n\n}"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/FedUpExtractCLI.java", "chunked_list": ["package com.tridevmc.fedup.extract;\n\nimport com.tridevmc.fedup.extract.internal.cli.CommandExtract;\nimport picocli.CommandLine;\n\npublic class FedUpExtractCLI {\n\n    public static void main(String[] args) {\n        int exitCode = new CommandLine(new CommandExtract()).execute(args);\n        System.exit(exitCode);\n    }\n\n}"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/api/apk/IAPKAnalysisResult.java", "chunked_list": ["package com.tridevmc.fedup.extract.api.apk;\n\nimport com.google.common.collect.ImmutableList;\nimport com.tridevmc.fedup.extract.api.gql.IRedditGQLOperation;\n\n/**\n * Represents the result of an APK analysis, containing GQL operations and any other necessary data to build a client\n */\npublic interface IAPKAnalysisResult {\n\n    /**\n     * Gets the GQL operations found in the APK.\n     *\n     * @return an immutable list of the GQL operations.\n     */\n    ImmutableList<IRedditGQLOperation> getGQLOperations();\n\n    /**\n     * Gets the raw OAuth client ID found in the APK.\n     *\n     * @return the raw OAuth client ID.\n     */\n    String getRawOAuthClientId();\n\n}\n", "public interface IAPKAnalysisResult {\n\n    /**\n     * Gets the GQL operations found in the APK.\n     *\n     * @return an immutable list of the GQL operations.\n     */\n    ImmutableList<IRedditGQLOperation> getGQLOperations();\n\n    /**\n     * Gets the raw OAuth client ID found in the APK.\n     *\n     * @return the raw OAuth client ID.\n     */\n    String getRawOAuthClientId();\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/api/apk/IAPKAnalyzer.java", "chunked_list": ["package com.tridevmc.fedup.extract.api.apk;\n\nimport com.tridevmc.fedup.extract.internal.apk.APKAnalyzer;\n\nimport java.io.File;\n\n/**\n * Performs analysis on an APK file.\n */\npublic interface IAPKAnalyzer {\n\n    /**\n     * Creates an APK analyzer for the given APK file.\n     *\n     * @param apkFile the APK file to analyze.\n     * @return an APK analyzer for the given APK file.\n     */\n    static IAPKAnalyzer createFor(File apkFile) {\n        return new APKAnalyzer(apkFile);\n    }\n\n    /**\n     * Analyzes the APK file and returns the result, initial calls to this method may take a while as the APK is decompiled by jadx.\n     *\n     * @return the result of the APK analysis.\n     */\n    IAPKAnalysisResult analyzeAPK();\n\n}\n", " */\npublic interface IAPKAnalyzer {\n\n    /**\n     * Creates an APK analyzer for the given APK file.\n     *\n     * @param apkFile the APK file to analyze.\n     * @return an APK analyzer for the given APK file.\n     */\n    static IAPKAnalyzer createFor(File apkFile) {\n        return new APKAnalyzer(apkFile);\n    }\n\n    /**\n     * Analyzes the APK file and returns the result, initial calls to this method may take a while as the APK is decompiled by jadx.\n     *\n     * @return the result of the APK analysis.\n     */\n    IAPKAnalysisResult analyzeAPK();\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/api/gql/IRedditGQLOperation.java", "chunked_list": ["package com.tridevmc.fedup.extract.api.gql;\n\npublic interface IRedditGQLOperation {\n\n    String getId();\n\n    String getName();\n\n    String getDefinition();\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/cli/CommandExtract.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.cli;\n\n\nimport com.google.gson.GsonBuilder;\nimport com.tridevmc.fedup.extract.api.apk.IAPKAnalyzer;\nimport org.tinylog.Logger;\nimport org.tinylog.TaggedLogger;\nimport org.tinylog.configuration.Configuration;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;", "import picocli.CommandLine;\nimport picocli.CommandLine.Command;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.util.concurrent.Callable;\n\n@Command(name = \"extract\", description = \"Extracts data from an APK and exports it to the given JSON file or stdout.\")\npublic class CommandExtract implements Callable<Integer> {\n\n    @CommandLine.Option(names = {\"-i\", \"--input\"}, description = \"The APK to extract data from.\", required = true)\n    private String input;\n\n    @CommandLine.Option(names = {\"-o\", \"--output\"}, description = \"The JSON file to export data to. If not specified, will export to stdout.\", required = false)\n    private String output;\n\n    @Override", "public class CommandExtract implements Callable<Integer> {\n\n    @CommandLine.Option(names = {\"-i\", \"--input\"}, description = \"The APK to extract data from.\", required = true)\n    private String input;\n\n    @CommandLine.Option(names = {\"-o\", \"--output\"}, description = \"The JSON file to export data to. If not specified, will export to stdout.\", required = false)\n    private String output;\n\n    @Override\n    public Integer call() throws Exception {\n        var exportToStdout = this.output == null;\n        var inputFile = new File(this.input);\n        TaggedLogger LOG = null;", "    public Integer call() throws Exception {\n        var exportToStdout = this.output == null;\n        var inputFile = new File(this.input);\n        TaggedLogger LOG = null;\n        if (!exportToStdout) {\n            LOG = Logger.tag(\"fedup-extract\");\n        }\n        if (inputFile.exists()) {\n            if (inputFile.getName().endsWith(\".apk\")) {\n                if (exportToStdout) {\n                    // Set the tinylog logging level to OFF to prevent any logging from being output to stdout.\n                    Configuration.set(\"level\", \"off\");\n                    var out = this.generateOutputString(inputFile);\n                    System.out.println(out);\n                } else {\n                    var outputFile = new File(this.output);", "            if (inputFile.getName().endsWith(\".apk\")) {\n                if (exportToStdout) {\n                    // Set the tinylog logging level to OFF to prevent any logging from being output to stdout.\n                    Configuration.set(\"level\", \"off\");\n                    var out = this.generateOutputString(inputFile);\n                    System.out.println(out);\n                } else {\n                    var outputFile = new File(this.output);\n                    if (outputFile.exists()) {\n                        LOG.info(\"Output file already exists, please select a different output file.\");\n                        return 1;\n                    }\n                    var outputString = this.generateOutputString(inputFile);\n                    Files.writeString(outputFile.toPath(), outputString);\n                }\n                return 0;\n            } else {\n                LOG.info(\"Input file is not an APK.\");\n                return 1;\n            }\n        } else {\n            LOG.info(\"Input file does not exist.\");\n            return 1;\n        }\n    }\n\n    private String generateOutputString(File inputFile) {\n        var analyzer = IAPKAnalyzer.createFor(inputFile);\n        var result = analyzer.analyzeAPK();\n        var gson = new GsonBuilder().setPrettyPrinting().create();\n        return gson.toJson(result);\n    }\n\n}\n", "                    if (outputFile.exists()) {\n                        LOG.info(\"Output file already exists, please select a different output file.\");\n                        return 1;\n                    }\n                    var outputString = this.generateOutputString(inputFile);\n                    Files.writeString(outputFile.toPath(), outputString);\n                }\n                return 0;\n            } else {\n                LOG.info(\"Input file is not an APK.\");\n                return 1;\n            }\n        } else {\n            LOG.info(\"Input file does not exist.\");\n            return 1;\n        }\n    }\n\n    private String generateOutputString(File inputFile) {\n        var analyzer = IAPKAnalyzer.createFor(inputFile);\n        var result = analyzer.analyzeAPK();\n        var gson = new GsonBuilder().setPrettyPrinting().create();\n        return gson.toJson(result);\n    }\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/apk/APKAnalysisResult.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.apk;\n\nimport com.google.common.collect.ImmutableList;\nimport com.tridevmc.fedup.extract.api.apk.IAPKAnalysisResult;\nimport com.tridevmc.fedup.extract.api.gql.IRedditGQLOperation;\n\npublic record APKAnalysisResult(\n        ImmutableList<IRedditGQLOperation> gqlOperations,\n        String oAuthClientId\n) implements IAPKAnalysisResult {\n\n    @Override\n    public ImmutableList<IRedditGQLOperation> getGQLOperations() {\n        return this.gqlOperations;\n    }\n\n    @Override", "    public String getRawOAuthClientId() {\n        return this.oAuthClientId;\n    }\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/apk/APKAnalysisStepOAuthClientID.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.apk;\n\nimport jadx.api.JadxDecompiler;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;", "import java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Objects;\n\npublic class APKAnalysisStepOAuthClientID implements IAPKAnalysisStep<String> {\n\n    @Override\n    public String perform(JadxDecompiler jadx) {\n        return findRawOAuthClientId(jadx);\n    }\n\n    private String determineOAuthClientIdKey() {\n        // TODO: Actually use JADX to find the authorization header setup code, then work backwards to find the key. Odds are it's always going to be \"oauth_client_id\" but it's better to be safe than sorry.\n        return \"oauth_client_id\";\n    }\n\n    private String findRawOAuthClientId(JadxDecompiler jadx) {\n        // Iterate over the entries in the APK file and find any XML files to scan.\n        // For each XML file, scan it for the string \"oauth_client_id\" and extract the value.\n        // Return the first value found.\n        var oauthClientIdKey = this.determineOAuthClientIdKey();\n\n        return jadx.getResources().stream().flatMap(p -> p.loadContent().getSubFiles().stream()).filter(p -> p.getName().endsWith(\".xml\"))\n                .flatMap(\n                        p -> {", "    public String perform(JadxDecompiler jadx) {\n        return findRawOAuthClientId(jadx);\n    }\n\n    private String determineOAuthClientIdKey() {\n        // TODO: Actually use JADX to find the authorization header setup code, then work backwards to find the key. Odds are it's always going to be \"oauth_client_id\" but it's better to be safe than sorry.\n        return \"oauth_client_id\";\n    }\n\n    private String findRawOAuthClientId(JadxDecompiler jadx) {\n        // Iterate over the entries in the APK file and find any XML files to scan.\n        // For each XML file, scan it for the string \"oauth_client_id\" and extract the value.\n        // Return the first value found.\n        var oauthClientIdKey = this.determineOAuthClientIdKey();\n\n        return jadx.getResources().stream().flatMap(p -> p.loadContent().getSubFiles().stream()).filter(p -> p.getName().endsWith(\".xml\"))\n                .flatMap(\n                        p -> {", "                            try {\n                                var s = p.getText().getCodeStr();\n                                // Make a temp file to hold the XML data.\n                                var tempFile = File.createTempFile(\"fedup-extract\", \".xml\");\n                                Files.write(tempFile.toPath(), s.getBytes(StandardCharsets.UTF_8));\n                                var documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                                var document = documentBuilder.parse(tempFile);\n                                document.normalize();\n\n                                var nodesOut = new ArrayList<OAuthClientIDCandidate>();\n                                var nodesToParse = new ArrayList<Node>();\n                                nodesToParse.add(document.getDocumentElement());", "                                while (!nodesToParse.isEmpty()) {\n                                    var node = nodesToParse.remove(0);\n                                    if (node.hasChildNodes()) {\n                                        for (int i = 0; i < node.getChildNodes().getLength(); i++) {\n                                            nodesToParse.add(node.getChildNodes().item(i));\n                                        }\n                                    }\n                                    if (node.hasAttributes()) {\n                                        // Scan all the attributes of this node to see if any of them are the OAuth client ID key.\n                                        for (int i = 0; i < node.getAttributes().getLength(); i++) {\n                                            var attribute = node.getAttributes().item(i);", "                                        for (int i = 0; i < node.getAttributes().getLength(); i++) {\n                                            var attribute = node.getAttributes().item(i);\n                                            if (attribute.getNodeName().equals(oauthClientIdKey)) {\n                                                // Found the OAuth client ID key, return the value.\n                                                nodesOut.add(new OAuthClientIDCandidate(attribute.getNodeName(),\n                                                                                        attribute.getNodeValue()));\n                                            } else if (attribute.getNodeValue().equals(oauthClientIdKey)) {\n                                                if (attribute.getNodeName().equals(\"name\")) {\n                                                    // This likely contains the value as raw text in a child node, extract it.\n                                                    var childValue = node.getFirstChild().getTextContent();\n                                                    nodesOut.add(new OAuthClientIDCandidate(attribute.getNodeValue(),\n                                                                                            childValue));\n                                                } else {\n                                                    // Found the OAuth client ID key, return the value.\n                                                    nodesOut.add(new OAuthClientIDCandidate(attribute.getNodeValue(),\n                                                                                            attribute.getNodeName()));\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                return nodesOut.stream();\n                            } catch (IOException | ParserConfigurationException | SAXException e) {\n                                throw new RuntimeException(e);\n                            }\n                        }\n                ).filter(\n                        Objects::nonNull\n                ).findFirst().map(\n                        OAuthClientIDCandidate::value\n                ).orElseThrow(\n                        () -> new RuntimeException(\"Failed to find raw OAuth client ID.\")\n                );\n    }\n\n    private record OAuthClientIDCandidate(String name, String value) {\n\n    }\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/apk/APKAnalyzer.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.apk;\n\nimport com.google.common.collect.ImmutableList;\nimport com.tridevmc.fedup.extract.api.apk.IAPKAnalysisResult;\nimport com.tridevmc.fedup.extract.api.apk.IAPKAnalyzer;\nimport com.tridevmc.fedup.extract.api.gql.IRedditGQLOperation;\nimport jadx.api.JadxArgs;\nimport jadx.api.JadxDecompiler;\nimport org.tinylog.Logger;\nimport org.tinylog.TaggedLogger;", "import org.tinylog.Logger;\nimport org.tinylog.TaggedLogger;\n\nimport java.io.File;\n\n\npublic class APKAnalyzer implements IAPKAnalyzer {\n\n    private final File apkFile;\n    private JadxDecompiler jadx;\n\n    private static final TaggedLogger LOG = Logger.tag(APKAnalyzer.class.getCanonicalName());\n\n    public APKAnalyzer(File apkFile) {\n        this.apkFile = apkFile;\n    }\n\n    @Override", "    public IAPKAnalysisResult analyzeAPK() {\n        var oAuthClientIdAnalysisStep = new APKAnalysisStepOAuthClientID();\n        var gqlOperationAnalysisStep = new APKAnalysisStepGQLOperations();\n        var gqlOperations = gqlOperationAnalysisStep.perform(getJadxDecompiler());\n        var rawOAuthTokenId = oAuthClientIdAnalysisStep.perform(getJadxDecompiler());\n        ImmutableList<IRedditGQLOperation> gqlOperationsImmutable = ImmutableList.copyOf(gqlOperations);\n        return new APKAnalysisResult(gqlOperationsImmutable, rawOAuthTokenId);\n    }\n\n    private JadxDecompiler getJadxDecompiler() {\n        if (this.jadx == null) {\n            var jadxArgs = new JadxArgs();\n            jadxArgs.setInputFile(\n                    this.apkFile\n            );\n            jadxArgs.setOutDir(\n                    new File(\"jadx-out\")\n            );\n            var jadx = new JadxDecompiler(jadxArgs);\n            jadx.load();\n            jadx.save();\n            this.jadx = jadx;\n        }\n        return this.jadx;\n    }\n\n}\n", "        if (this.jadx == null) {\n            var jadxArgs = new JadxArgs();\n            jadxArgs.setInputFile(\n                    this.apkFile\n            );\n            jadxArgs.setOutDir(\n                    new File(\"jadx-out\")\n            );\n            var jadx = new JadxDecompiler(jadxArgs);\n            jadx.load();\n            jadx.save();\n            this.jadx = jadx;\n        }\n        return this.jadx;\n    }\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/apk/IAPKAnalysisStep.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.apk;\n\nimport jadx.api.JadxDecompiler;\n\n/**\n * Performs a step in the APK analysis process and returns the result.\n *\n * @param <T> the type of the result of the analysis step.\n */\npublic interface IAPKAnalysisStep<T> {\n\n    T perform(JadxDecompiler jadx);\n\n}\n", " */\npublic interface IAPKAnalysisStep<T> {\n\n    T perform(JadxDecompiler jadx);\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/apk/APKAnalysisStepGQLOperations.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.apk;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.tridevmc.fedup.extract.internal.gql.RedditGQLOperation;\nimport jadx.api.JadxDecompiler;\nimport jadx.api.JavaClass;\nimport jadx.api.JavaMethod;\nimport jadx.core.dex.attributes.AType;\nimport jadx.core.dex.attributes.AttrNode;", "import jadx.core.dex.attributes.AType;\nimport jadx.core.dex.attributes.AttrNode;\nimport jadx.core.dex.attributes.AttributeStorage;\nimport jadx.core.dex.attributes.FieldInitInsnAttr;\nimport jadx.core.dex.instructions.ConstStringNode;\nimport jadx.core.dex.nodes.FieldNode;\nimport org.tinylog.Logger;\nimport org.tinylog.TaggedLogger;\n\nimport java.lang.reflect.Field;", "\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class APKAnalysisStepGQLOperations implements IAPKAnalysisStep<List<RedditGQLOperation>> {\n\n    private static final Field ATTR_NODE_STORAGE;\n\n    private static final TaggedLogger LOG = Logger.tag(APKAnalyzer.class.getCanonicalName());\n\n    static {", "\npublic class APKAnalysisStepGQLOperations implements IAPKAnalysisStep<List<RedditGQLOperation>> {\n\n    private static final Field ATTR_NODE_STORAGE;\n\n    private static final TaggedLogger LOG = Logger.tag(APKAnalyzer.class.getCanonicalName());\n\n    static {\n        try {\n            ATTR_NODE_STORAGE = AttrNode.class.getDeclaredField(\"storage\");\n            ATTR_NODE_STORAGE.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public List<RedditGQLOperation> perform(JadxDecompiler jadx) {\n        return findGQLOperations(jadx);\n    }\n\n    private List<RedditGQLOperation> findGQLOperations(JadxDecompiler jadx) {\n        // Find all classes with 3 final fields and a constructor that takes 3 strings.\n        Predicate<JavaClass> operationClassPredicate = javaClass -> {\n            var fields = javaClass.getFields();", "        try {\n            ATTR_NODE_STORAGE = AttrNode.class.getDeclaredField(\"storage\");\n            ATTR_NODE_STORAGE.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public List<RedditGQLOperation> perform(JadxDecompiler jadx) {\n        return findGQLOperations(jadx);\n    }\n\n    private List<RedditGQLOperation> findGQLOperations(JadxDecompiler jadx) {\n        // Find all classes with 3 final fields and a constructor that takes 3 strings.\n        Predicate<JavaClass> operationClassPredicate = javaClass -> {\n            var fields = javaClass.getFields();", "            if (fields.size() != 3) {\n                return false;\n            }\n            for (var field : fields) {\n                if (!field.getAccessFlags().isFinal()\n                        || !field.getType().isObject()\n                        || !field.getType().getObject().equals(\"java.lang.String\")) {\n                    return false;\n                }\n            }\n            return javaClass.getMethods().stream().anyMatch(\n                    m -> {", "                        if (!m.getAccessFlags().isConstructor()) {\n                            return false;\n                        }\n                        var args = m.getArguments();\n                        if (args.size() != 3) {\n                            return false;\n                        }\n                        for (var arg : args) {\n                            if (!arg.isObject() || !arg.getObject().equals(\"java.lang.String\")) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n            );\n        };\n        List<JavaClass> classesWithInners = jadx.getClassesWithInners();\n        List<JavaClass> potentialRedditGQLOperationClasses = classesWithInners.stream().filter(\n                operationClassPredicate\n        ).toList();\n\n        // Find all instances where the constructor of the previous classes are called, then store the values of all the strings passed to the constructor.\n        List<PotentialRedditGQLOperationClass> potentialOperations = potentialRedditGQLOperationClasses.stream().map(\n                clazz -> new PotentialRedditGQLOperationClass(clazz, clazz.getMethods().stream().filter(\n                        m -> m.getAccessFlags().isConstructor()\n                ).flatMap(constructor -> getArgumentSetsForConstructor(constructor).stream().filter(Objects::nonNull)).toList())\n        ).filter(PotentialRedditGQLOperationClass::hasAnyArgumentSets).toList();\n\n        return potentialOperations.stream().flatMap(\n                p -> p.argumentSets.stream().map(\n                        a -> new RedditGQLOperation(\n                                a.arg0,\n                                a.arg1,\n                                a.arg2\n                        )\n                )\n        ).toList();\n    }\n\n    private List<ArgumentSet> getArgumentSetsForConstructor(JavaMethod constructor) {\n\n        var stringArguments = constructor.getArguments().stream().filter(\n                a -> a.isObject() && a.getObject().equals(\"java.lang.String\")\n        ).toList();", "                            if (!arg.isObject() || !arg.getObject().equals(\"java.lang.String\")) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n            );\n        };\n        List<JavaClass> classesWithInners = jadx.getClassesWithInners();\n        List<JavaClass> potentialRedditGQLOperationClasses = classesWithInners.stream().filter(\n                operationClassPredicate\n        ).toList();\n\n        // Find all instances where the constructor of the previous classes are called, then store the values of all the strings passed to the constructor.\n        List<PotentialRedditGQLOperationClass> potentialOperations = potentialRedditGQLOperationClasses.stream().map(\n                clazz -> new PotentialRedditGQLOperationClass(clazz, clazz.getMethods().stream().filter(\n                        m -> m.getAccessFlags().isConstructor()\n                ).flatMap(constructor -> getArgumentSetsForConstructor(constructor).stream().filter(Objects::nonNull)).toList())\n        ).filter(PotentialRedditGQLOperationClass::hasAnyArgumentSets).toList();\n\n        return potentialOperations.stream().flatMap(\n                p -> p.argumentSets.stream().map(\n                        a -> new RedditGQLOperation(\n                                a.arg0,\n                                a.arg1,\n                                a.arg2\n                        )\n                )\n        ).toList();\n    }\n\n    private List<ArgumentSet> getArgumentSetsForConstructor(JavaMethod constructor) {\n\n        var stringArguments = constructor.getArguments().stream().filter(\n                a -> a.isObject() && a.getObject().equals(\"java.lang.String\")\n        ).toList();", "        if (constructor.getArguments().size() == 3 && stringArguments.size() == 3) {\n            return getArgumentSetsForDataClassStyleConstructor(constructor);\n        } else if (constructor.getArguments().size() == 0) {\n            return Lists.newArrayList(getArgumentSetsForNoArgConstructor(constructor));\n        } else if (stringArguments.size() >= 3) {\n            return getArgumentSetsForStringConstructor(constructor);\n        } else {\n            LOG.debug(\"Found unknown constructor: \" + constructor.toString());\n            return ImmutableList.of();\n        }\n    }\n\n    /**\n     * This is assumed to be a constructor that takes at least three string arguments, so we just want to find the ones that are most likely to be the operation id, name, and definition.\n     *\n     * @param constructor The constructor to find the argument sets for.\n     * @return The list of argument sets found.\n     */\n    private List<ArgumentSet> getArgumentSetsForStringConstructor(JavaMethod constructor) {\n        LOG.debug(\"Found potential RedditGQLOperation constructor: \" + constructor.toString());\n        Predicate<String> operationIdPredicate = s -> {\n            // An operationId is 12 characters long and contains only numbers and lowercase letters.\n            return s.length() == 12 && s.chars().allMatch(\n                    c -> (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')\n            );\n        };\n        Predicate<String> operationNamePredicate = s -> {\n            // An operation name is a string that starts with an uppercase letter and contains only letters and numbers.\n            var firstChar = s.charAt(0);\n            var isAlphaNumeric = s.chars().allMatch(\n                    c -> (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')\n            );\n            return firstChar == Character.toUpperCase(firstChar) && isAlphaNumeric;\n        };\n        Predicate<String> operationDefinitionPredicate = s -> {\n            // An operation definition is a string that contains the word \"query\" or \"mutation\".\n            var sLower = s.toLowerCase();\n            return sLower.contains(\"query\") || sLower.contains(\"mutation\");\n        };\n\n        var argCount = constructor.getArguments().size();\n        return constructor.getUseIn().stream().flatMap(\n                javaNode -> {", "                    if (javaNode instanceof JavaMethod && javaNode.getFullName().contains(\"<clinit>\")) {\n                        // Static initializer, this is likely a class used to store constants.\n                        var declaringClass = javaNode.getDeclaringClass();\n                        return declaringClass.getFields().stream().map(\n                                field -> {\n                                    FieldNode fieldNode = field.getFieldNode();\n                                    if (fieldNode.getType().isObject() &&\n                                            Objects.equals(fieldNode.getType().getObject(), constructor.getDeclaringClass().getRawName())) {\n                                        var attributeStorageFromNode = getAttributeStorageFromNode(fieldNode);\n                                        var fieldInitInsnAttr = (FieldInitInsnAttr) attributeStorageFromNode.get(AType.FIELD_INIT_INSN);\n                                        if (fieldInitInsnAttr != null) {\n                                            var arguments = fieldInitInsnAttr.getInsn().getArguments();\n                                            var insnArgs = StreamSupport.stream(arguments.spliterator(), false).toList();\n                                            return insnArgs;\n                                        }\n                                    }\n                                    return null;\n                                }\n                        ).filter(f -> f != null && f.size() == argCount);\n                    }\n                    return Stream.empty();\n                }\n        ).map(\n                f -> {\n                    var stringArgs = f.stream().filter(a -> a.getType().isObject() && a.getType().getObject().equals(\"java.lang.String\")).map(a -> {\n                        var s = a.toString();\n                        var l = s.length();\n                        return s.substring(2, l - 2);\n                    }).toList();", "                                        if (fieldInitInsnAttr != null) {\n                                            var arguments = fieldInitInsnAttr.getInsn().getArguments();\n                                            var insnArgs = StreamSupport.stream(arguments.spliterator(), false).toList();\n                                            return insnArgs;\n                                        }\n                                    }\n                                    return null;\n                                }\n                        ).filter(f -> f != null && f.size() == argCount);\n                    }\n                    return Stream.empty();\n                }\n        ).map(\n                f -> {\n                    var stringArgs = f.stream().filter(a -> a.getType().isObject() && a.getType().getObject().equals(\"java.lang.String\")).map(a -> {\n                        var s = a.toString();\n                        var l = s.length();\n                        return s.substring(2, l - 2);\n                    }).toList();", "                    if (stringArgs.size() >= 3) {\n                        var operationId = stringArgs.stream().filter(operationIdPredicate).findFirst().orElse(null);\n                        var operationName = stringArgs.stream().filter(operationNamePredicate).findFirst().orElse(null);\n                        var operationDefinition = stringArgs.stream().filter(operationDefinitionPredicate).findFirst().orElse(null);\n                        if (operationId != null && operationName != null && operationDefinition != null) {\n                            return new ArgumentSet(operationId, operationName, operationDefinition);\n                        } else {\n                            LOG.debug(\"Unknown constructor: \" + constructor);\n                        }\n                    }\n                    return null;\n                }\n        ).filter(Objects::nonNull).toList();\n    }\n\n    /**\n     * Gets arguments that are passed to the given data class style constructor.\n     * This constructor is assumed to take three String arguments and nothing else.\n     * The order is assumed to be operationId, operationName, operationDefinition.\n     *\n     * @param constructor The constructor to get the arguments for.\n     * @return The list of argument sets found.\n     */\n    private List<ArgumentSet> getArgumentSetsForDataClassStyleConstructor(JavaMethod constructor) {\n        LOG.debug(\"Found data class style constructor: \" + constructor);\n        // This is assumed to be a constructor that takes three string arguments, so we just want to find the uses and extract the values passed.\n        var clazz = constructor.getDeclaringClass();\n        return constructor.getUseIn().stream().flatMap(\n                javaNode -> {", "                    if (constructor.getFullName().contains(\"firebase\")) {\n                        LOG.debug(\"Found use in: \" + javaNode);\n                    }\n                    if (javaNode instanceof JavaMethod && javaNode.getFullName().contains(\"<clinit>\")) {\n                        // Static initializer, this is likely a class used to store constants.\n                        var declaringClass = javaNode.getDeclaringClass();\n                        return declaringClass.getFields().stream().map(\n                                field -> {\n                                    FieldNode fieldNode = field.getFieldNode();\n                                    if (fieldNode.getType().isObject() &&\n                                            Objects.equals(fieldNode.getType().getObject(), clazz.getFullName())) {\n                                        var attributeStorageFromNode = getAttributeStorageFromNode(fieldNode);\n                                        var fieldInitInsnAttr = (FieldInitInsnAttr) attributeStorageFromNode.get(AType.FIELD_INIT_INSN);", "                                    if (fieldNode.getType().isObject() &&\n                                            Objects.equals(fieldNode.getType().getObject(), clazz.getFullName())) {\n                                        var attributeStorageFromNode = getAttributeStorageFromNode(fieldNode);\n                                        var fieldInitInsnAttr = (FieldInitInsnAttr) attributeStorageFromNode.get(AType.FIELD_INIT_INSN);\n                                        if (fieldInitInsnAttr != null) {\n                                            var arguments = fieldInitInsnAttr.getInsn().getArguments();\n                                            var insnArgs = StreamSupport.stream(arguments.spliterator(), false).toList();\n                                            return insnArgs;\n                                        }\n                                    }\n                                    return null;\n                                }\n                        ).filter(f -> f != null && f.size() == 3);\n                    }\n                    return Stream.empty();\n                }\n        ).map(\n                f -> {\n                    var arg0 = f.get(0).toString();\n                    var arg1 = f.get(1).toString();\n                    var arg2 = f.get(2).toString();\n                    arg0 = arg0.substring(2, arg0.length() - 2);\n                    arg1 = arg1.substring(2, arg1.length() - 2);\n                    arg2 = arg2.substring(2, arg2.length() - 2);\n                    // Remove any \\n characters from arg2.\n                    arg2 = arg2.replace(\"\\\\n\", \"\");\n                    return new ArgumentSet(\n                            arg0,\n                            arg1,\n                            arg2\n                    );\n                }\n        ).toList();\n    }\n\n    /**\n     * Gets the values assigned to the fields of the class by the given default constructor.\n     * <p>\n     * This seems to be caused by a compiler optimization/obfuscation, or just some weird Kotlin thing.\n     *\n     * @param constructor The constructor to get the values from.\n     * @return The values assigned to the fields of the class by the given default constructor.\n     */\n    private ArgumentSet getArgumentSetsForNoArgConstructor(JavaMethod constructor) {\n        LOG.debug(\"Found no-arg constructor: \" + constructor);\n        // This is assumed to be a constructor that takes no arguments, so we need to scan the actual code to find any string literals.\n        var methodNode = constructor.getMethodNode();\n        methodNode.reload();\n        var constStrings = Arrays.stream(methodNode.getInstructions())\n                .filter(i -> i instanceof ConstStringNode)\n                .map(n -> ((ConstStringNode) n).getString())\n                .toList();", "        if (methodNode.getInstructions().length == 0) {\n            LOG.debug(\"No instructions for method: \" + constructor.getFullName());\n            return null;\n        }\n        if (constStrings.size() == 0) {\n            LOG.debug(\"No const strings for method: \" + constructor.getFullName());\n            LOG.debug(Arrays.toString(methodNode.getInstructions()));\n            return null;\n        }\n        if (constStrings.size() == 3) {\n            var arg0 = constStrings.get(0);\n            var arg1 = constStrings.get(1);\n            var arg2 = constStrings.get(2);\n            return new ArgumentSet(\n                    arg0,\n                    arg1,\n                    arg2\n            );\n        } else {\n            LOG.debug(\"Unknown constructor: \" + constructor.getFullName());\n            LOG.debug(\"Const strings: \" + constStrings);\n        }\n        return null;\n    }\n\n    private AttributeStorage getAttributeStorageFromNode(AttrNode node) {", "        if (constStrings.size() == 3) {\n            var arg0 = constStrings.get(0);\n            var arg1 = constStrings.get(1);\n            var arg2 = constStrings.get(2);\n            return new ArgumentSet(\n                    arg0,\n                    arg1,\n                    arg2\n            );\n        } else {\n            LOG.debug(\"Unknown constructor: \" + constructor.getFullName());\n            LOG.debug(\"Const strings: \" + constStrings);\n        }\n        return null;\n    }\n\n    private AttributeStorage getAttributeStorageFromNode(AttrNode node) {", "        try {\n            AttributeStorage storage = (AttributeStorage) ATTR_NODE_STORAGE.get(node);\n            return storage;\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private record ArgumentSet(\n            String arg0,\n            String arg1,\n            String arg2\n    ) {\n\n    }\n\n    private static final class PotentialRedditGQLOperationClass {\n\n        private JavaClass clazz;\n        private List<ArgumentSet> argumentSets;\n\n        private PotentialRedditGQLOperationClass(\n                JavaClass clazz,\n                List<ArgumentSet> argumentSets\n        ) {\n            this.clazz = clazz;\n            this.argumentSets = argumentSets;\n        }\n\n        private void addArgumentSet(ArgumentSet argumentSet) {\n            this.argumentSets.add(argumentSet);\n        }\n", "        public boolean hasAnyArgumentSets() {\n            return !this.argumentSets.isEmpty();\n        }\n\n        @Override\n        public String toString() {\n            return \"PotentialRedditGQLOperationClass{\" +\n                    \"clazz=\" + clazz +\n                    \", argumentSets=\" + argumentSets +\n                    '}';\n        }\n\n    }\n\n}\n"]}
{"filename": "fedup-extract/src/main/java/com/tridevmc/fedup/extract/internal/gql/RedditGQLOperation.java", "chunked_list": ["package com.tridevmc.fedup.extract.internal.gql;\n\nimport com.tridevmc.fedup.extract.api.gql.IRedditGQLOperation;\n\npublic record RedditGQLOperation(\n        String id,\n        String name,\n        String definition\n) implements IRedditGQLOperation {\n\n    @Override", "    public String getId() {\n        return this.id;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public String getDefinition() {\n        return this.definition;\n    }\n\n}\n", "    public String getDefinition() {\n        return this.definition;\n    }\n\n}\n"]}
