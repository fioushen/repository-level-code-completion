{"filename": "src/main/java/module-info.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nopen module net.dragondelve.downfall {\n    requires javafx.fxml;\n    requires jakarta.xml.bind;\n    requires javafx.controls;", "    requires jakarta.xml.bind;\n    requires javafx.controls;\n\n    exports net.dragondelve.mabel.fetcher;\n    exports net.dragondelve.downfall;\n}"]}
{"filename": "src/main/java/net/dragondelve/downfall/DownfallLaunch.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall;\n\n/**\n * A simple class whose only purpose is to have a main method which calls the actual main method of the program", "/**\n * A simple class whose only purpose is to have a main method which calls the actual main method of the program\n * This enables building of jars that will properly include and reference the javaFX runtime components\n */\npublic class DownfallLaunch {\n    /**\n     * Calls the main method of\n     * @param args program arguments that will be passed to DownfallMain where they will be ignored.\n     */\n    public static void main(String[] args) {\n        DownfallMain.main(args);\n    }\n}\n", "    public static void main(String[] args) {\n        DownfallMain.main(args);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/DownfallMain.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall;\n\nimport net.dragondelve.downfall.ui.main.DownfallMainController;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.ui.main.DownfallMainController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.application.Application;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\nimport javafx.stage.StageStyle;\n\n/**", "\n/**\n * Main application class of Downfall.\n */\npublic final class DownfallMain extends Application {\n    /**\n     * Launches the JavaFX application.\n     * @param args Program arguments. Ignored.\n     */\n    public static void main(String[] args) {\n        launch();\n    }\n\n    /**\n     * start method of the client application\n     * @param stage primary stage of the application\n     * @throws Exception any uncaught exception.\n     */\n    @Override", "    public static void main(String[] args) {\n        launch();\n    }\n\n    /**\n     * start method of the client application\n     * @param stage primary stage of the application\n     * @throws Exception any uncaught exception.\n     */\n    @Override\n    public void start(Stage stage) throws Exception {\n        Configurator configurator = Configurator.getInstance();\n        configurator.loadConfiguration();\n        configurator.loadAndApplyRules();\n\n        stage.setTitle(\"Downfall v0.1.1\");\n        stage.initStyle(StageStyle.UNDECORATED);\n\n        stage.setOnCloseRequest(e -> {\n            configurator.saveRules();\n            configurator.saveConfiguration();\n        });\n\n        stage.setWidth(1260);\n        stage.setHeight(700);\n        stage.setMinHeight(650);\n        stage.setMinWidth(1200);\n        FXMLLoader loader = new FXMLLoader(DownfallUtil.getInstance().getURLDownfallMainFXML());\n        DownfallMainController controller = new DownfallMainController();\n        controller.setStage(stage);\n        loader.setController(controller);\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n        stage.show();\n    }\n}\n", "    public void start(Stage stage) throws Exception {\n        Configurator configurator = Configurator.getInstance();\n        configurator.loadConfiguration();\n        configurator.loadAndApplyRules();\n\n        stage.setTitle(\"Downfall v0.1.1\");\n        stage.initStyle(StageStyle.UNDECORATED);\n\n        stage.setOnCloseRequest(e -> {\n            configurator.saveRules();\n            configurator.saveConfiguration();\n        });\n\n        stage.setWidth(1260);\n        stage.setHeight(700);\n        stage.setMinHeight(650);\n        stage.setMinWidth(1200);\n        FXMLLoader loader = new FXMLLoader(DownfallUtil.getInstance().getURLDownfallMainFXML());\n        DownfallMainController controller = new DownfallMainController();\n        controller.setStage(stage);\n        loader.setController(controller);\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n        stage.show();\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Actor.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlElementWrapper;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlElementWrapper;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.SimpleIntegerProperty;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\n\n/**", "\n/**\n * Actor is a basis common for all entities that can build or store or act on the board in any way shape or form.\n */\npublic abstract class Actor {\n    private final IntegerProperty id = new SimpleIntegerProperty();\n    private final StringProperty name = new SimpleStringProperty();\n    private final IntegerProperty treasury = new SimpleIntegerProperty();\n    private ObservableList<Material> stockpile = FXCollections.observableArrayList();\n    private ObservableList<Building> ownedBuildings = FXCollections.observableArrayList();\n    private ObservableList<Tag> tags = FXCollections.observableArrayList();\n\n    /**\n     * Default constructor. Does not provide default values\n     */\n    public Actor() {\n        super();\n    }\n\n    /**\n     * Using this constructor stockpile, ownedBuildings, and tags remain empty lists.\n     * @param id Unique actor identifier. Should be unique for every save file\n     * @param name A human-readable name of the actor as a property.\n     * @param treasury Amount of money in the treasury as a property.\n     */\n    public Actor(Integer id, String name, Integer treasury ) {\n        super();\n        this.id.set(id);\n        this.name.set(name);\n        this.treasury.set(treasury);\n    }\n\n    /**\n     *\n     * @param id Unique actor identifier. Should be unique for every save file\n     * @param name A human-readable name of the actor as a property.\n     * @param treasury Amount of money in the treasury as a property.\n     * @param stockpile List of all materials in actor's stockpile\n     * @param ownedBuildings List of all owned buildings\n     * @param tags List of all tags applied to the actor\n     */\n    public Actor(Integer id, String name, Integer treasury, ObservableList<Material> stockpile, ObservableList<Building> ownedBuildings, ObservableList<Tag> tags) {\n        super();\n        this.id.set(id);\n        this.name.set(name);\n        this.treasury.set(treasury);\n        this.stockpile = stockpile;\n        this.ownedBuildings = ownedBuildings;\n        this.tags = tags;\n    }\n\n\n    /**\n     * Lightweight Accessor Method.\n     * @return Unique realm identifier. Should be unique for every save file as a property.\n     */", "    public IntegerProperty idProperty() {\n        return id;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return A human-readable name of the actor as a property.\n     */\n    public StringProperty nameProperty() {\n        return name;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return amount of money in the treasury as a property\n     */", "    public StringProperty nameProperty() {\n        return name;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return amount of money in the treasury as a property\n     */\n    public IntegerProperty treasuryProperty() {\n        return treasury;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Unique actor identifier. Should be unique for every save file.\n     */\n    @XmlElement(name = \"id\")", "    public IntegerProperty treasuryProperty() {\n        return treasury;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Unique actor identifier. Should be unique for every save file.\n     */\n    @XmlElement(name = \"id\")\n    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return A human-readable name of the realm.\n     */\n    @XmlElement(name = \"name\")", "    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return A human-readable name of the realm.\n     */\n    @XmlElement(name = \"name\")\n    public String getName() {\n        return name.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Amount of money in the treasury\n     */\n    @XmlElement(name = \"treasury\")", "    public String getName() {\n        return name.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Amount of money in the treasury\n     */\n    @XmlElement(name = \"treasury\")\n    public Integer getTreasury() {\n        return treasury.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return list of all materials in actor's stockpile\n     */\n    @XmlElementWrapper(name = \"stockpile\")\n    @XmlElement(name = \"material\")\n    public ObservableList<Material> getStockpile() {\n        return stockpile;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return List of all owned buildings\n     */\n    @XmlElementWrapper(name = \"owned-buildings\")\n    @XmlElement(name = \"building\")\n    public ObservableList<Building> getOwnedBuildings() {\n        return ownedBuildings;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return List of all tags applied to the actor\n     */\n    @XmlElementWrapper(name = \"tags\")\n    @XmlElement(name = \"tag\")\n    public ObservableList<Tag> getTags() {\n        return tags;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param id Unique actor identifier. Should be unique for every save file.\n     */", "    public Integer getTreasury() {\n        return treasury.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return list of all materials in actor's stockpile\n     */\n    @XmlElementWrapper(name = \"stockpile\")\n    @XmlElement(name = \"material\")\n    public ObservableList<Material> getStockpile() {\n        return stockpile;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return List of all owned buildings\n     */\n    @XmlElementWrapper(name = \"owned-buildings\")\n    @XmlElement(name = \"building\")\n    public ObservableList<Building> getOwnedBuildings() {\n        return ownedBuildings;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return List of all tags applied to the actor\n     */\n    @XmlElementWrapper(name = \"tags\")\n    @XmlElement(name = \"tag\")\n    public ObservableList<Tag> getTags() {\n        return tags;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param id Unique actor identifier. Should be unique for every save file.\n     */", "    public void setId(Integer id) {\n        this.id.set(id);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param name Actor name\n     */\n    public void setName(String name) {\n        this.name.set(name);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param treasury Amount of money in the treasury\n     */", "    public void setName(String name) {\n        this.name.set(name);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param treasury Amount of money in the treasury\n     */\n    public void setTreasury(Integer treasury) {\n        this.treasury.set(treasury);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param stockpile list of all materials in actor's stockpile\n     */", "    public void setTreasury(Integer treasury) {\n        this.treasury.set(treasury);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param stockpile list of all materials in actor's stockpile\n     */\n    public void setStockpile(ObservableList<Material> stockpile) {\n        this.stockpile = stockpile;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param ownedBuildings List of all owned buildings\n     */", "    public void setStockpile(ObservableList<Material> stockpile) {\n        this.stockpile = stockpile;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param ownedBuildings List of all owned buildings\n     */\n    public void setOwnedBuildings(ObservableList<Building> ownedBuildings) {\n        this.ownedBuildings = ownedBuildings;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param tags List of all tags applied to the actor\n     */", "    public void setOwnedBuildings(ObservableList<Building> ownedBuildings) {\n        this.ownedBuildings = ownedBuildings;\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param tags List of all tags applied to the actor\n     */\n    public void setTags(ObservableList<Tag> tags) {\n        this.tags = tags;\n    }\n}\n", "    public void setTags(ObservableList<Tag> tags) {\n        this.tags = tags;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Building.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport javafx.beans.property.BooleanProperty;", "import jakarta.xml.bind.annotation.XmlElement;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.SimpleBooleanProperty;\nimport javafx.beans.property.SimpleIntegerProperty;\n\n/**\n * Building represents an actual building. Each building must refer to a valid BuildingTemplate by id.\n * References its template by ID.\n * This class if fully annotated for JAXB", " * References its template by ID.\n * This class if fully annotated for JAXB\n */\npublic class Building {\n    private final IntegerProperty id = new SimpleIntegerProperty(-1);\n\n    private final BooleanProperty isOperating = new SimpleBooleanProperty(false);\n\n    /**\n     * Default Constructor. Generates an invalid Building with id = -1 and isOperating set to false.\n     */\n    public Building() {\n        this.id.set(-1);\n        this.isOperating.set(false);\n    }\n\n    /**\n     *\n     * @param id id of the building template associated with this building.\n     * @param isOperating flag that determines if the building is operating right now.\n     */\n    public Building(Integer id, Boolean isOperating) {\n        this.id.set(id);\n        this.isOperating.set(isOperating);\n    }\n    /**\n     * Lightweight accessor method\n     * @return id of the building template associated with this building as a property.\n     */", "    public IntegerProperty idProperty() {\n        return id;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return flag that determines if the building is operating right now as a property.\n     */\n    public BooleanProperty isOperatingProperty() {\n        return isOperating;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return id of the building template associated with this building.\n     */\n    @XmlElement(name=\"id\")", "    public BooleanProperty isOperatingProperty() {\n        return isOperating;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return id of the building template associated with this building.\n     */\n    @XmlElement(name=\"id\")\n    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return flag that determines if the building is operating right now as a property.\n     */\n    @XmlElement(name=\"is-operating\")", "    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return flag that determines if the building is operating right now as a property.\n     */\n    @XmlElement(name=\"is-operating\")\n    public Boolean isOperating() {\n        return isOperating.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param id id of the building template associated with this building. Should be set to -1 to mark that this building is invalid.\n     */", "    public Boolean isOperating() {\n        return isOperating.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param id id of the building template associated with this building. Should be set to -1 to mark that this building is invalid.\n     */\n    public void setId(Integer id) {\n        this.id.setValue(id);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param isOperating flag that determines if the building is operating right now\n     */", "    public void setId(Integer id) {\n        this.id.setValue(id);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param isOperating flag that determines if the building is operating right now\n     */\n    public void setOperating(Boolean isOperating) {\n        this.isOperating.setValue(isOperating);\n    }\n}\n", "    public void setOperating(Boolean isOperating) {\n        this.isOperating.setValue(isOperating);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Material.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport net.dragondelve.downfall.realm.template.MaterialTemplate;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;", "import net.dragondelve.downfall.realm.template.MaterialTemplate;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.SimpleIntegerProperty;\n\n/**\n * Represents a bundle of materials, like 30 Wood or 15 Stone.\n * Each Material has a template and is used to both show income and amount stockpiled. It is also used to show costs of operating a building", " * Represents a bundle of materials, like 30 Wood or 15 Stone.\n * Each Material has a template and is used to both show income and amount stockpiled. It is also used to show costs of operating a building\n */\n@XmlRootElement(name=\"material\")\npublic class Material {\n\n    private final IntegerProperty idProperty = new SimpleIntegerProperty(-1);\n\n    //I honestly would have overloaded +- operators for Material because you can just add/subtract their amounts if they have the same ID\n    private final IntegerProperty amountProperty = new SimpleIntegerProperty(0);\n\n    /**\n     * Initializes amount to a default value of 0.\n     * @param template Template from which this material will be generated from\n     */\n    public Material(VisualMaterialTemplate template) {\n        this(template, 0);\n    }\n\n    /**\n     *\n     * @param template Template from which this material will be generated from\n     * @param amount Amount of materials in this bundle.\n     */\n    public Material(MaterialTemplate template, Integer amount) {\n        idProperty.setValue(template.getId());\n        amountProperty.setValue(amount);\n    }\n\n    /**\n     * Default Constructor. it creates an invalid material. Its id is set to -1 and amount is set 0.\n     */\n    public Material(){\n        this(-1, 0);\n    }\n\n    /**\n     *\n     * @param id Material Template id of a template that this bundle of materials represents\n     * @param amount Amount of materials in this bundle.\n     */\n    public Material(Integer id, Integer amount) {\n        idProperty.setValue(id);\n        amountProperty.setValue(amount);\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Material Template id of a template that this bundle of materials represents\n     */", "    public IntegerProperty idProperty() {\n        return idProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Amount of materials in this bundle as a property.\n     */\n    public IntegerProperty amountProperty() {\n        return amountProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Material Template id of a template that this bundle of materials represents\n     */\n    @XmlElement(name = \"template-id\")", "    public IntegerProperty amountProperty() {\n        return amountProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Material Template id of a template that this bundle of materials represents\n     */\n    @XmlElement(name = \"template-id\")\n    public Integer getTemplateId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Amount of materials in this bundle.\n     */\n    @XmlElement(name = \"amount\")", "    public Integer getTemplateId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Amount of materials in this bundle.\n     */\n    @XmlElement(name = \"amount\")\n    public Integer getAmount() {\n        return amountProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param id Material Template id of a template that this bundle of materials represents\n     */", "    public Integer getAmount() {\n        return amountProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param id Material Template id of a template that this bundle of materials represents\n     */\n    public void setTemplateId(Integer id) {\n        idProperty.setValue(id);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param amount Amount of materials in this bundle.\n     */", "    public void setTemplateId(Integer id) {\n        idProperty.setValue(id);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param amount Amount of materials in this bundle.\n     */\n    public void setAmount(Integer amount) {\n        amountProperty.setValue(amount);\n    }\n}", "    public void setAmount(Integer amount) {\n        amountProperty.setValue(amount);\n    }\n}"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Tag.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.*;\n\n/**\n * A Tag is a String value that can be applied to Actors. This is used in certain scripts, events can determine access to special mechanics.\n * This class is fully annotated for serialization with JAXB\n */\n@XmlRootElement(name = \"tag\")\npublic class Tag {\n    private final IntegerProperty id = new SimpleIntegerProperty();\n    private final StringProperty tag = new SimpleStringProperty();\n    private final BooleanProperty isFactional = new SimpleBooleanProperty();\n\n    public Tag() {\n        super();\n        id.set(-1);\n        tag.set(\"\");\n        isFactional.set(false);\n    }\n\n    public Tag(Integer id, String tag, Boolean isFactional) {\n        super();\n        this.id.set(id);\n        this.tag.set(tag);\n        this.isFactional.set(isFactional);\n    }\n\n    /**\n     * returns the tag value of the tag so that it can be made human-readable.\n     * @return Tag name of this instance.\n     */\n    @Override", "@XmlRootElement(name = \"tag\")\npublic class Tag {\n    private final IntegerProperty id = new SimpleIntegerProperty();\n    private final StringProperty tag = new SimpleStringProperty();\n    private final BooleanProperty isFactional = new SimpleBooleanProperty();\n\n    public Tag() {\n        super();\n        id.set(-1);\n        tag.set(\"\");\n        isFactional.set(false);\n    }\n\n    public Tag(Integer id, String tag, Boolean isFactional) {\n        super();\n        this.id.set(id);\n        this.tag.set(tag);\n        this.isFactional.set(isFactional);\n    }\n\n    /**\n     * returns the tag value of the tag so that it can be made human-readable.\n     * @return Tag name of this instance.\n     */\n    @Override", "    public String toString(){\n        return this.tag.get();\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return unique tag identifier as a property.\n     */\n    public IntegerProperty idProperty() {\n        return id;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Tag title as a property\n     */", "    public IntegerProperty idProperty() {\n        return id;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Tag title as a property\n     */\n    public StringProperty tagProperty() {\n        return tag;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Flag that determines if this tag is used to assign faction memberships to a realm, as a property.\n     */", "    public StringProperty tagProperty() {\n        return tag;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Flag that determines if this tag is used to assign faction memberships to a realm, as a property.\n     */\n    public BooleanProperty isFactionalProperty() {\n        return isFactional;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return unique tag identifier.\n     */\n    @XmlElement(name=\"id\")", "    public BooleanProperty isFactionalProperty() {\n        return isFactional;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return unique tag identifier.\n     */\n    @XmlElement(name=\"id\")\n    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Tag title as value\n     */\n    @XmlElement(name=\"value\")", "    public Integer getId() {\n        return id.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Tag title as value\n     */\n    @XmlElement(name=\"value\")\n    public String getTag() {\n        return tag.get();\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Flag that determines if this tag is used to assign faction memberships to a realm.\n     */\n    @XmlElement(name=\"factional\")", "    public String getTag() {\n        return tag.get();\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Flag that determines if this tag is used to assign faction memberships to a realm.\n     */\n    @XmlElement(name=\"factional\")\n    public Boolean isFactional() {\n        return isFactional.get();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param id Unique tag identifier.\n     */", "    public Boolean isFactional() {\n        return isFactional.get();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param id Unique tag identifier.\n     */\n    public void setId(Integer id) {\n        this.id.set(id);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param tag Tag name\n     */", "    public void setId(Integer id) {\n        this.id.set(id);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param tag Tag name\n     */\n    public void setTag(String tag) {\n        this.tag.set(tag);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param isFactional Flag that determines if this tag is used to assign faction memberships to a realm.\n     */", "    public void setTag(String tag) {\n        this.tag.set(tag);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param isFactional Flag that determines if this tag is used to assign faction memberships to a realm.\n     */\n    public void setFactional(Boolean isFactional) {\n        this.isFactional.set(isFactional);\n    }\n}\n", "    public void setFactional(Boolean isFactional) {\n        this.isFactional.set(isFactional);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Savegame.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\n\n/**\n * a Save class that holds the information about a user's Realm and the Ruleset on which the Realm was created.\n */\n@XmlRootElement(name=\"downfall-save\")\npublic final class Savegame {\n    private String pathToRules = \"\";\n    private Realm userRealm = new Realm();\n\n    /**\n     * Default constructor. Default values are \"\" pathToRules, and an empty Realm\n     */\n    public Savegame() {\n        super();\n    }\n\n    /**\n     *\n     * @param pathToRules pathname to the rules that were used for this Save\n     * @param userRealm user's realm data.\n     */\n    public Savegame(String pathToRules, Realm userRealm) {\n        this.pathToRules = pathToRules;\n        this.userRealm = userRealm;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return pathname to the rules that were used for this Realm\n     */\n    @XmlElement(name = \"path-to-rules\")", "    public String getPathToRules() {\n        return pathToRules;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return user's realm data.\n     */\n    @XmlElement(name = \"user-realm\")\n    public Realm getUserRealm() {\n        return userRealm;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param pathToRules pathname to the rules that were used for this Save\n     */", "    public Realm getUserRealm() {\n        return userRealm;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param pathToRules pathname to the rules that were used for this Save\n     */\n    public void setPathToRules(String pathToRules) {\n        this.pathToRules = pathToRules;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param userRealm user's realm data.\n     */", "    public void setPathToRules(String pathToRules) {\n        this.pathToRules = pathToRules;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param userRealm user's realm data.\n     */\n    public void setUserRealm(Realm userRealm) {\n        this.userRealm = userRealm;\n    }\n}\n", "    public void setUserRealm(Realm userRealm) {\n        this.userRealm = userRealm;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/Realm.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.*;\nimport javafx.collections.ObservableList;\n\n/**\n * Realm is a data model class that represents an actor who possesses diplomatic attributes and is capable of having characters in its court.\n */\n@XmlRootElement(name = \"realm\")\npublic class Realm extends Actor{\n    private final IntegerProperty diplomaticReputation = new SimpleIntegerProperty();\n    private final IntegerProperty powerProjection = new SimpleIntegerProperty();\n    private final IntegerProperty legitimacy = new SimpleIntegerProperty();\n    private final IntegerProperty prestige = new SimpleIntegerProperty();\n    private final IntegerProperty infamy = new SimpleIntegerProperty();\n    private final DoubleProperty stability = new SimpleDoubleProperty();\n    private final StringProperty realmPathToGFX = new SimpleStringProperty();\n    private final StringProperty rulerPathToGFX = new SimpleStringProperty();\n\n    /**\n     * Default constructor. Does not provide any default values\n     */\n    public Realm() {\n        super();\n    }\n\n    /**\n     *\n     * @param id Unique realm identifier. Should be unique for every save file\n     * @param name A human-readable name of the realm.\n     * @param treasury Amount of money in the treasury.\n     * @param stockpile List of all materials in realm's stockpile\n     * @param ownedBuildings List of all owned buildings\n     * @param tags List of all tags applied to the realm\n     */\n    public Realm(Integer id, String name, Integer treasury, ObservableList<Material> stockpile, ObservableList<Building> ownedBuildings, ObservableList<Tag> tags) {\n        super(id, name, treasury, stockpile, ownedBuildings, tags);\n    }\n\n    /**\n     *\n     * @param id Unique realm identifier. Should be unique for every save file\n     * @param name A human-readable name of the realm.\n     * @param treasury Amount of money in the treasury.\n     * @param stockpile List of all materials in realm's stockpile\n     * @param ownedBuildings List of all owned buildings\n     * @param tags List of all tags applied to the realm\n     * @param diplomaticReputation a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     * @param powerProjection a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions\n     * @param legitimacy a measure of legitimacy of the ruler. Affects unrest.\n     * @param prestige a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     * @param infamy a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     * @param stability a measure of the realm's stability. affects unrest.\n     * @param realmPathToGFX path to the image of a flag/coat of arms that represents the realm.\n     * @param rulerPathToGFX path to the image of a flag/coat of arms that represents the ruling body.\n     */\n    public Realm(Integer id, String name, Integer treasury, ObservableList<Material> stockpile, ObservableList<Building> ownedBuildings, ObservableList<Tag> tags, Integer diplomaticReputation, Integer powerProjection, Integer legitimacy, Integer prestige, Integer infamy,Double stability, String realmPathToGFX, String rulerPathToGFX) {\n        super(id, name, treasury, stockpile, ownedBuildings, tags);\n        this.diplomaticReputation.set(diplomaticReputation);\n        this.powerProjection.set(powerProjection);\n        this.legitimacy.set(legitimacy);\n        this.prestige.set(prestige);\n        this.infamy.set(infamy);\n        this.stability.set(stability);\n        this.realmPathToGFX.set(realmPathToGFX);\n        this.rulerPathToGFX.set(rulerPathToGFX);\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions as a property.\n     */", "@XmlRootElement(name = \"realm\")\npublic class Realm extends Actor{\n    private final IntegerProperty diplomaticReputation = new SimpleIntegerProperty();\n    private final IntegerProperty powerProjection = new SimpleIntegerProperty();\n    private final IntegerProperty legitimacy = new SimpleIntegerProperty();\n    private final IntegerProperty prestige = new SimpleIntegerProperty();\n    private final IntegerProperty infamy = new SimpleIntegerProperty();\n    private final DoubleProperty stability = new SimpleDoubleProperty();\n    private final StringProperty realmPathToGFX = new SimpleStringProperty();\n    private final StringProperty rulerPathToGFX = new SimpleStringProperty();\n\n    /**\n     * Default constructor. Does not provide any default values\n     */\n    public Realm() {\n        super();\n    }\n\n    /**\n     *\n     * @param id Unique realm identifier. Should be unique for every save file\n     * @param name A human-readable name of the realm.\n     * @param treasury Amount of money in the treasury.\n     * @param stockpile List of all materials in realm's stockpile\n     * @param ownedBuildings List of all owned buildings\n     * @param tags List of all tags applied to the realm\n     */\n    public Realm(Integer id, String name, Integer treasury, ObservableList<Material> stockpile, ObservableList<Building> ownedBuildings, ObservableList<Tag> tags) {\n        super(id, name, treasury, stockpile, ownedBuildings, tags);\n    }\n\n    /**\n     *\n     * @param id Unique realm identifier. Should be unique for every save file\n     * @param name A human-readable name of the realm.\n     * @param treasury Amount of money in the treasury.\n     * @param stockpile List of all materials in realm's stockpile\n     * @param ownedBuildings List of all owned buildings\n     * @param tags List of all tags applied to the realm\n     * @param diplomaticReputation a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     * @param powerProjection a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions\n     * @param legitimacy a measure of legitimacy of the ruler. Affects unrest.\n     * @param prestige a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     * @param infamy a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     * @param stability a measure of the realm's stability. affects unrest.\n     * @param realmPathToGFX path to the image of a flag/coat of arms that represents the realm.\n     * @param rulerPathToGFX path to the image of a flag/coat of arms that represents the ruling body.\n     */\n    public Realm(Integer id, String name, Integer treasury, ObservableList<Material> stockpile, ObservableList<Building> ownedBuildings, ObservableList<Tag> tags, Integer diplomaticReputation, Integer powerProjection, Integer legitimacy, Integer prestige, Integer infamy,Double stability, String realmPathToGFX, String rulerPathToGFX) {\n        super(id, name, treasury, stockpile, ownedBuildings, tags);\n        this.diplomaticReputation.set(diplomaticReputation);\n        this.powerProjection.set(powerProjection);\n        this.legitimacy.set(legitimacy);\n        this.prestige.set(prestige);\n        this.infamy.set(infamy);\n        this.stability.set(stability);\n        this.realmPathToGFX.set(realmPathToGFX);\n        this.rulerPathToGFX.set(rulerPathToGFX);\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions as a property.\n     */", "    public IntegerProperty diplomaticReputationProperty() {\n        return diplomaticReputation;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return a measure of perceived power of the realm as a property. Used when evaluating threats and taking DoW decisions.\n     */\n    public IntegerProperty powerProjectionProperty() {\n        return powerProjection;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of legitimacy of the ruler as a property. Affects unrest.\n     */", "    public IntegerProperty powerProjectionProperty() {\n        return powerProjection;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of legitimacy of the ruler as a property. Affects unrest.\n     */\n    public IntegerProperty legitimacyProperty() {\n        return legitimacy;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of a ruler's prestige. Expended and gained as a diplomatic resource as a property.\n     */", "    public IntegerProperty legitimacyProperty() {\n        return legitimacy;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of a ruler's prestige. Expended and gained as a diplomatic resource as a property.\n     */\n    public IntegerProperty prestigeProperty() {\n        return prestige;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the ruler's infamy as a property. Affects unrest, used when taking diplomatic actions.\n     */", "    public IntegerProperty prestigeProperty() {\n        return prestige;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the ruler's infamy as a property. Affects unrest, used when taking diplomatic actions.\n     */\n    public IntegerProperty infamyProperty() {\n        return infamy;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the realm's stability as a property. affects unrest.\n     */", "    public IntegerProperty infamyProperty() {\n        return infamy;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the realm's stability as a property. affects unrest.\n     */\n    public DoubleProperty stabilityProperty() {\n        return stability;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the realm as a property.\n     */", "    public DoubleProperty stabilityProperty() {\n        return stability;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the realm as a property.\n     */\n    public StringProperty realmPathToGFXProperty() {\n        return realmPathToGFX;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the ruling body as a property.\n     */", "    public StringProperty realmPathToGFXProperty() {\n        return realmPathToGFX;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the ruling body as a property.\n     */\n    public StringProperty rulerPathToGFXProperty() {\n        return rulerPathToGFX;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     */\n    @XmlElement(name = \"diplomatic-reputation\")", "    public StringProperty rulerPathToGFXProperty() {\n        return rulerPathToGFX;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     */\n    @XmlElement(name = \"diplomatic-reputation\")\n    public Integer getDiplomaticReputation() {\n        return diplomaticReputation.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions.\n     */\n    @XmlElement(name = \"power-projection\")", "    public Integer getDiplomaticReputation() {\n        return diplomaticReputation.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions.\n     */\n    @XmlElement(name = \"power-projection\")\n    public Integer getPowerProjection() {\n        return powerProjection.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of legitimacy of the ruler. Affects unrest.\n     */\n    @XmlElement(name = \"legitimacy\")", "    public Integer getPowerProjection() {\n        return powerProjection.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of legitimacy of the ruler. Affects unrest.\n     */\n    @XmlElement(name = \"legitimacy\")\n    public Integer getLegitimacy() {\n        return legitimacy.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     */\n    @XmlElement(name = \"prestige\")", "    public Integer getLegitimacy() {\n        return legitimacy.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     */\n    @XmlElement(name = \"prestige\")\n    public Integer getPrestige() {\n        return prestige.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     */\n    @XmlElement(name = \"infamy\")", "    public Integer getPrestige() {\n        return prestige.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     */\n    @XmlElement(name = \"infamy\")\n    public Integer getInfamy() {\n        return infamy.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the realm's stability. affects unrest.\n     */\n    @XmlElement(name = \"stability\")", "    public Integer getInfamy() {\n        return infamy.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return a measure of the realm's stability. affects unrest.\n     */\n    @XmlElement(name = \"stability\")\n    public Double getStability() {\n        return stability.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the realm.\n     */\n    @XmlElement(name = \"realm-path-to-gfx\")", "    public Double getStability() {\n        return stability.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the realm.\n     */\n    @XmlElement(name = \"realm-path-to-gfx\")\n    public String getRealmPathToGFX() {\n        return realmPathToGFX.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the ruling body.\n     */\n    @XmlElement(name = \"ruler-path-to-gfx\")", "    public String getRealmPathToGFX() {\n        return realmPathToGFX.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return path to the image of a flag/coat of arms that represents the ruling body.\n     */\n    @XmlElement(name = \"ruler-path-to-gfx\")\n    public String getRulerPathToGFX() {\n        return rulerPathToGFX.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param diplomaticReputation a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     */", "    public String getRulerPathToGFX() {\n        return rulerPathToGFX.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param diplomaticReputation a measure of diplomatic reputation of the Realm. Used when taking diplomatic actions.\n     */\n    public void setDiplomaticReputation(Integer diplomaticReputation) {\n        this.diplomaticReputation.set(diplomaticReputation);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param powerProjection a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions\n     */", "    public void setDiplomaticReputation(Integer diplomaticReputation) {\n        this.diplomaticReputation.set(diplomaticReputation);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param powerProjection a measure of perceived power of the realm. Used when evaluating threats and taking DoW decisions\n     */\n    public void setPowerProjection(Integer powerProjection) {\n        this.powerProjection.set(powerProjection);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param legitimacy a measure of legitimacy of the ruler. Affects unrest.\n     */", "    public void setPowerProjection(Integer powerProjection) {\n        this.powerProjection.set(powerProjection);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param legitimacy a measure of legitimacy of the ruler. Affects unrest.\n     */\n    public void setLegitimacy(Integer legitimacy) {\n        this.legitimacy.set(legitimacy);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param prestige a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     */", "    public void setLegitimacy(Integer legitimacy) {\n        this.legitimacy.set(legitimacy);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param prestige a measure of a ruler's prestige. Expended and gained as a diplomatic resource\n     */\n    public void setPrestige(Integer prestige) {\n        this.prestige.set(prestige);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param infamy a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     */", "    public void setPrestige(Integer prestige) {\n        this.prestige.set(prestige);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param infamy a measure of the ruler's infamy. Affects unrest, used when taking diplomatic actions.\n     */\n    public void setInfamy(Integer infamy) {\n        this.infamy.set(infamy);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param stability a measure of the realm's stability. affects unrest.\n     */", "    public void setInfamy(Integer infamy) {\n        this.infamy.set(infamy);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param stability a measure of the realm's stability. affects unrest.\n     */\n    public void setStability(Double stability) {\n        this.stability.set(stability);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param realmPathToGFX path to the image of a flag/coat of arms that represents the realm.\n     */", "    public void setStability(Double stability) {\n        this.stability.set(stability);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param realmPathToGFX path to the image of a flag/coat of arms that represents the realm.\n     */\n    public void setRealmPathToGFX(String realmPathToGFX) {\n        this.realmPathToGFX.set(realmPathToGFX);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param rulerPathToGFX path to the image of a flag/coat of arms that represents the ruling body.\n     */", "    public void setRealmPathToGFX(String realmPathToGFX) {\n        this.realmPathToGFX.set(realmPathToGFX);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param rulerPathToGFX path to the image of a flag/coat of arms that represents the ruling body.\n     */\n    public void setRulerPathToGFX(String rulerPathToGFX) {\n        this.rulerPathToGFX.set(rulerPathToGFX);\n    }\n}\n", "    public void setRulerPathToGFX(String rulerPathToGFX) {\n        this.rulerPathToGFX.set(rulerPathToGFX);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/template/VisualMaterialTemplate.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm.template;\n\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;", "import net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.scene.image.Image;\n\n/**\n * Template that is used when new materials are generated. It stores a pathname that leads to its GFX and an JavaFX Image if a reference to that is required.", "/**\n * Template that is used when new materials are generated. It stores a pathname that leads to its GFX and an JavaFX Image if a reference to that is required.\n * This Class if fully annotated for use with JAXB to be exported to an XML File.\n */\n@XmlRootElement(name=\"gfx-material-template\")\npublic final class VisualMaterialTemplate extends MaterialTemplate{\n    private final StringProperty pathToGFXProperty = new SimpleStringProperty();\n    private Image GFX;\n    private Boolean gfxInitialized = false;\n\n    /**\n     * Default Constructor. it generates an invalid VisualMaterialTemplate with an id of -1\n     */\n    public VisualMaterialTemplate() {\n        this(\"\",-1,-1,-1,false, false);\n    }\n\n    /**\n     * Initializes pathToGFX to the default MaterialGFXPathname defined in the current configuration.\n     * @param name Human-readable name of the materials to be generated with this template\n     * @param id Unique identifier used to differentiate different material templates\n     * @param defExportPrice Default export price\n     * @param defImportPrice Default import price\n     * @param isExportable Value that determines if the material will be exportable from the realm\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     */\n    public VisualMaterialTemplate(String name, Integer id,Integer defExportPrice, Integer defImportPrice, Boolean isExportable, Boolean isEphemeral) {\n        this(name, id, defExportPrice, defImportPrice, isExportable, isEphemeral, Configurator.getInstance().getDefMaterialGFXPathname());\n    }\n\n    /**\n     *\n     * @param name Human-readable name of the materials to be generated with this template\n     * @param id Unique identifier used to differentiate different material templates\n     * @param defExportPrice Default export price\n     * @param defImportPrice Default import price\n     * @param isExportable Value that determines if the material will be exportable from the realm\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     * @param pathToGFX String pathname to an image file that represents this material. That Image should be square, but isn't required to be square\n     */\n    public VisualMaterialTemplate(String name, Integer id,Integer defExportPrice, Integer defImportPrice, Boolean isExportable, Boolean isEphemeral, String pathToGFX) {\n        super(name, id, defExportPrice, defImportPrice, isExportable, isEphemeral);\n        this.pathToGFXProperty.setValue(pathToGFX);\n        this.pathToGFXProperty.setValue(Configurator.getInstance().getDefMaterialGFXPathname());\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return pathname to an image file that represents this material as a property.\n     */", "    public StringProperty pathToGFXProperty() {\n        return pathToGFXProperty;\n    }\n\n    /**\n     * Updates the Image representation material to comply with the current value of pathToGFXProperty\n     * @return new Image that has been updated.\n     */\n    public Image updateGFX() {\n        //TODO: contemplate removing GFX from here or doing something better with loading (?)\n        //TODO: I think something second loads these Graphics. MaterialEditorController (?)\n        GFX = DownfallUtil.getInstance().loadImage(pathToGFXProperty.get());\n        gfxInitialized = true;\n        return GFX;\n    }\n\n    /**\n     * Lightweight accessor method that initiates graphics if they haven't been initialized\n     * @return Image that represents this material.\n     */", "    public Image updateGFX() {\n        //TODO: contemplate removing GFX from here or doing something better with loading (?)\n        //TODO: I think something second loads these Graphics. MaterialEditorController (?)\n        GFX = DownfallUtil.getInstance().loadImage(pathToGFXProperty.get());\n        gfxInitialized = true;\n        return GFX;\n    }\n\n    /**\n     * Lightweight accessor method that initiates graphics if they haven't been initialized\n     * @return Image that represents this material.\n     */", "    public Image getGFX() {\n        if(!gfxInitialized)\n            return updateGFX();\n        else\n            return GFX;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return String pathname to an image file that represents this material.\n     */\n    @XmlElement(name=\"path-to-gfx\")", "    public String getPathToGFX() {\n        return pathToGFXProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param pathToGFX String pathname to an image file that represents this material. That Image should be square, but isn't required to be square\n     */\n    public void setPathToGFX(String pathToGFX) {\n        this.pathToGFXProperty.setValue(pathToGFX);\n    }\n}\n", "    public void setPathToGFX(String pathToGFX) {\n        this.pathToGFXProperty.setValue(pathToGFX);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/template/BuildingTemplate.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm.template;\n\nimport net.dragondelve.downfall.realm.Material;\nimport jakarta.xml.bind.annotation.XmlElement;", "import net.dragondelve.downfall.realm.Material;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlElementWrapper;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.*;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport java.util.List;\n\n/**", "\n/**\n * Used to generate new buildings. This class is annotated for conversion Integero a serializable form using JAXB\n */\n@XmlRootElement(name=\"building-template\")\npublic abstract class BuildingTemplate {\n    private final IntegerProperty idProperty = new SimpleIntegerProperty(-1);\n\n    private final StringProperty nameProperty = new SimpleStringProperty();\n\n    private ObservableList<Material> inputMaterials = FXCollections.observableArrayList();\n\n    private ObservableList<Material> outputMaterials = FXCollections.observableArrayList();\n\n    private final IntegerProperty defConstructionCostProperty = new SimpleIntegerProperty();\n\n    private ObservableList<Material> constructionMaterials = FXCollections.observableArrayList();\n\n    private final IntegerProperty defConstructionTimeProperty = new SimpleIntegerProperty();\n\n    private final BooleanProperty operatesImmediatelyProperty = new SimpleBooleanProperty();\n\n    private final BooleanProperty ephemeralProperty = new SimpleBooleanProperty();\n\n    /**\n     * Default constructor. Does not provide any default values\n     */\n    public BuildingTemplate() {\n        super();\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     * @param defConstructionCost construction cost per turn of construction\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     * @param defConstructionTime number of turns it takes to construct a building\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     */\n    public BuildingTemplate(Integer id, String name, List<Material> inputMaterials, List<Material> outputMaterials, Integer defConstructionCost, List<Material> constructionMaterials, Integer defConstructionTime, Boolean operatesImmediately) {\n        this.idProperty.setValue(id);\n\n        this.inputMaterials.clear();", "        if(inputMaterials != null)\n            this.inputMaterials.addAll(inputMaterials);\n\n        this.outputMaterials.clear();\n        if(outputMaterials != null)\n            this.outputMaterials.addAll(outputMaterials);\n\n        this.defConstructionCostProperty.setValue(defConstructionCost);\n\n        this.constructionMaterials.clear();\n        if (constructionMaterials != null)\n            this.constructionMaterials.addAll(constructionMaterials);\n\n        this.defConstructionTimeProperty.setValue(id);\n        this.operatesImmediatelyProperty.set(operatesImmediately);\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return unique identifier used to differentiate different templates as a property\n     */", "        if (constructionMaterials != null)\n            this.constructionMaterials.addAll(constructionMaterials);\n\n        this.defConstructionTimeProperty.setValue(id);\n        this.operatesImmediatelyProperty.set(operatesImmediately);\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return unique identifier used to differentiate different templates as a property\n     */", "    public IntegerProperty idPropertyProperty() {\n        return idProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a human-readable name of the template as a property\n     */\n    public StringProperty nameProperty() {\n        return nameProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return construction cost per turn of construction as a property\n     */", "    public StringProperty nameProperty() {\n        return nameProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return construction cost per turn of construction as a property\n     */\n    public IntegerProperty defConstructionCostProperty() {\n        return defConstructionCostProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return number of turns it takes to construct a building as a property\n     */", "    public IntegerProperty defConstructionCostProperty() {\n        return defConstructionCostProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return number of turns it takes to construct a building as a property\n     */\n    public IntegerProperty defConstructionTimeProperty() {\n        return defConstructionTimeProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return umber of turns it takes to construct a building as a property\n     */", "    public IntegerProperty defConstructionTimeProperty() {\n        return defConstructionTimeProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return umber of turns it takes to construct a building as a property\n     */\n    public BooleanProperty operatesImmediatelyProperty() {\n        return operatesImmediatelyProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return unique identifier used to differentiate different templates\n     */\n    @XmlElement(name=\"id\")", "    public BooleanProperty operatesImmediatelyProperty() {\n        return operatesImmediatelyProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return unique identifier used to differentiate different templates\n     */\n    @XmlElement(name=\"id\")\n    public Integer getId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a human-readable name of the template\n     */\n    @XmlElement(name = \"name\")", "    public Integer getId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a human-readable name of the template\n     */\n    @XmlElement(name = \"name\")\n    public String getName() {\n        return nameProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a list of input materials that are used in production in this building per turn\n     */\n    @XmlElementWrapper(name=\"input-materials\")\n    @XmlElement(name=\"material\")\n    public ObservableList<Material> getInputMaterials() {\n        return inputMaterials;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a list of output materials that are produced in this building per turn\n     */\n    @XmlElementWrapper(name=\"output-materials\")\n    @XmlElement(name=\"material\")\n    public ObservableList<Material> getOutputMaterials() {\n        return outputMaterials;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return construction cost per turn of construction\n     */\n    @XmlElement(name=\"def-construction-cost\")", "    public String getName() {\n        return nameProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a list of input materials that are used in production in this building per turn\n     */\n    @XmlElementWrapper(name=\"input-materials\")\n    @XmlElement(name=\"material\")\n    public ObservableList<Material> getInputMaterials() {\n        return inputMaterials;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a list of output materials that are produced in this building per turn\n     */\n    @XmlElementWrapper(name=\"output-materials\")\n    @XmlElement(name=\"material\")\n    public ObservableList<Material> getOutputMaterials() {\n        return outputMaterials;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return construction cost per turn of construction\n     */\n    @XmlElement(name=\"def-construction-cost\")", "    public Integer getDefConstructionCost() {\n        return defConstructionCostProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return a list of materials consumed during construction per turn of construction\n     */\n    @XmlElementWrapper(name=\"construction-materials\")\n    @XmlElement(name=\"material\")\n    public ObservableList<Material> getConstructionMaterials() {\n        return constructionMaterials;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return number of turns it takes to construct a building\n     */\n    @XmlElement(name=\"def-construction-time\")", "    public Integer getDefConstructionTime() {\n        return defConstructionTimeProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return does the building operate immediately or do you need to finish its construction as a property\n     */\n    @XmlElement(name=\"operates-immediately\")\n    public Boolean getOperatesImmediately() {\n        return operatesImmediatelyProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param id unique identifier used to differentiate different templates\n     */", "    public Boolean getOperatesImmediately() {\n        return operatesImmediatelyProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param id unique identifier used to differentiate different templates\n     */\n    public void setId(Integer id) {\n        this.idProperty.setValue(id);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param name a human-readable name of the template\n     */", "    public void setId(Integer id) {\n        this.idProperty.setValue(id);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param name a human-readable name of the template\n     */\n    public void setName(String name) {\n        this.nameProperty.setValue(name);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     */", "    public void setName(String name) {\n        this.nameProperty.setValue(name);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     */\n    public void setInputMaterials(ObservableList<Material> inputMaterials) {\n        this.inputMaterials = inputMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     */", "    public void setInputMaterials(ObservableList<Material> inputMaterials) {\n        this.inputMaterials = inputMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     */\n    public void setOutputMaterials(ObservableList<Material> outputMaterials) {\n        this.outputMaterials = outputMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param defConstructionCost construction cost per turn of construction\n     */", "    public void setOutputMaterials(ObservableList<Material> outputMaterials) {\n        this.outputMaterials = outputMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param defConstructionCost construction cost per turn of construction\n     */\n    public void setDefConstructionCost(Integer defConstructionCost) {\n        this.defConstructionCostProperty.setValue(defConstructionCost);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     */", "    public void setDefConstructionCost(Integer defConstructionCost) {\n        this.defConstructionCostProperty.setValue(defConstructionCost);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     */\n    public void setConstructionMaterials(ObservableList<Material> constructionMaterials) {\n        this.constructionMaterials = constructionMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param defConstructionTime number of turns it takes to construct a building\n     */", "    public void setConstructionMaterials(ObservableList<Material> constructionMaterials) {\n        this.constructionMaterials = constructionMaterials;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param defConstructionTime number of turns it takes to construct a building\n     */\n    public void setDefConstructionTime(Integer defConstructionTime) {\n        this.defConstructionTimeProperty.setValue(defConstructionTime);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     */", "    public void setDefConstructionTime(Integer defConstructionTime) {\n        this.defConstructionTimeProperty.setValue(defConstructionTime);\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     */\n    public void setOperatesImmediately(Boolean operatesImmediately) {\n        this.operatesImmediatelyProperty.set(operatesImmediately);\n    }\n}\n", "    public void setOperatesImmediately(Boolean operatesImmediately) {\n        this.operatesImmediatelyProperty.set(operatesImmediately);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/template/MaterialTemplate.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm.template;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.*;\n\n/**\n * Used to generate new materials. This class is annotated for conversion Integero a serializable form using JAXB\n */\n@XmlRootElement(name = \"material-template\")\npublic abstract class MaterialTemplate {\n    private final StringProperty nameProperty = new SimpleStringProperty();\n    private final IntegerProperty idProperty = new SimpleIntegerProperty(-1);\n    private final IntegerProperty defExportPriceProperty = new SimpleIntegerProperty(-1);\n    private final IntegerProperty defImportPriceProperty = new SimpleIntegerProperty(-1);\n    private final BooleanProperty isExportableProperty = new SimpleBooleanProperty(false);\n    private final BooleanProperty isEphemeralProperty = new SimpleBooleanProperty(false);\n\n    /**\n     * Default Constructor. Does not provide default values\n     */\n    public MaterialTemplate() {\n        super();\n    }\n\n    /**\n     *\n     * @param name Human-readable name of the materials to be generated with this template\n     * @param id Unique identifier used to differentiate different material templates\n     * @param defExportPrice Default export price\n     * @param defImportPrice Default import price\n     * @param isExportable Value that determines if the material will be exportable from the realm\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     */\n    public MaterialTemplate(String name, Integer id, Integer defExportPrice, Integer defImportPrice, Boolean isExportable, Boolean isEphemeral) {\n        super();\n        this.nameProperty.setValue(name);\n        this.idProperty.setValue(id);\n        this.defExportPriceProperty .setValue(defExportPrice);\n        this.defImportPriceProperty.setValue(defImportPrice);\n        this.isExportableProperty.setValue(isExportable);\n        this.isEphemeralProperty.set(isEphemeral);\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Human readable name of the materials to be generated with this template as a property\n     */", "public abstract class MaterialTemplate {\n    private final StringProperty nameProperty = new SimpleStringProperty();\n    private final IntegerProperty idProperty = new SimpleIntegerProperty(-1);\n    private final IntegerProperty defExportPriceProperty = new SimpleIntegerProperty(-1);\n    private final IntegerProperty defImportPriceProperty = new SimpleIntegerProperty(-1);\n    private final BooleanProperty isExportableProperty = new SimpleBooleanProperty(false);\n    private final BooleanProperty isEphemeralProperty = new SimpleBooleanProperty(false);\n\n    /**\n     * Default Constructor. Does not provide default values\n     */\n    public MaterialTemplate() {\n        super();\n    }\n\n    /**\n     *\n     * @param name Human-readable name of the materials to be generated with this template\n     * @param id Unique identifier used to differentiate different material templates\n     * @param defExportPrice Default export price\n     * @param defImportPrice Default import price\n     * @param isExportable Value that determines if the material will be exportable from the realm\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     */\n    public MaterialTemplate(String name, Integer id, Integer defExportPrice, Integer defImportPrice, Boolean isExportable, Boolean isEphemeral) {\n        super();\n        this.nameProperty.setValue(name);\n        this.idProperty.setValue(id);\n        this.defExportPriceProperty .setValue(defExportPrice);\n        this.defImportPriceProperty.setValue(defImportPrice);\n        this.isExportableProperty.setValue(isExportable);\n        this.isEphemeralProperty.set(isEphemeral);\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Human readable name of the materials to be generated with this template as a property\n     */", "    public StringProperty nameProperty() {\n        return nameProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Unique identifier used to differentiate different material templates as a property\n     */\n    public IntegerProperty idProperty() {\n        return idProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default export price as a property\n     */", "    public IntegerProperty idProperty() {\n        return idProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default export price as a property\n     */\n    public IntegerProperty defExportPriceProperty() {\n        return defExportPriceProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default import price as a property\n     */", "    public IntegerProperty defExportPriceProperty() {\n        return defExportPriceProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default import price as a property\n     */\n    public IntegerProperty defImportPriceProperty() {\n        return defImportPriceProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material will be exportable from the realm as a property\n     */", "    public IntegerProperty defImportPriceProperty() {\n        return defImportPriceProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material will be exportable from the realm as a property\n     */\n    public BooleanProperty isExportableProperty() {\n        return isExportableProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material can be stockpiled or stored as a property\n     */", "    public BooleanProperty isExportableProperty() {\n        return isExportableProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material can be stockpiled or stored as a property\n     */\n    public BooleanProperty isEphemeralProperty() {\n        return isEphemeralProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Human-readable name of the materials to be generated with this template\n     */\n    @XmlElement(name = \"name\")", "    public BooleanProperty isEphemeralProperty() {\n        return isEphemeralProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Human-readable name of the materials to be generated with this template\n     */\n    @XmlElement(name = \"name\")\n    public String getName() {\n        return nameProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Unique identifier used to differentiate different material templates\n     */\n    @XmlElement(name = \"id\")", "    public String getName() {\n        return nameProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Unique identifier used to differentiate different material templates\n     */\n    @XmlElement(name = \"id\")\n    public Integer getId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default export price\n     */\n    @XmlElement(name = \"def-export-template\")", "    public Integer getId() {\n        return idProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default export price\n     */\n    @XmlElement(name = \"def-export-template\")\n    public Integer getDefExportPrice() {\n        return defExportPriceProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default import price\n     */\n    @XmlElement(name = \"def-import-price\")", "    public Integer getDefExportPrice() {\n        return defExportPriceProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Default import price\n     */\n    @XmlElement(name = \"def-import-price\")\n    public Integer getDefImportPrice() {\n        return defImportPriceProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material will be exportable from the realm\n     */\n    @XmlElement(name = \"exportable\")", "    public Integer getDefImportPrice() {\n        return defImportPriceProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material will be exportable from the realm\n     */\n    @XmlElement(name = \"exportable\")\n    public Boolean isExportable() {\n        return isExportableProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material can be stockpiled or stored\n     */\n    @XmlElement(name = \"ephemeral\")", "    public Boolean isExportable() {\n        return isExportableProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Value that determines if the material can be stockpiled or stored\n     */\n    @XmlElement(name = \"ephemeral\")\n    public Boolean isEphemeral() { return  isEphemeralProperty.get();}\n\n\n    /**\n     * Lightweight mutator method\n     * @param name Human-readable name of the materials to be generated with this template\n     */", "    public Boolean isEphemeral() { return  isEphemeralProperty.get();}\n\n\n    /**\n     * Lightweight mutator method\n     * @param name Human-readable name of the materials to be generated with this template\n     */\n    public void setName(String name) {\n        this.nameProperty.setValue(name);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param idProperty Unique identifier used to differentiate different material templates\n     */", "    public void setId(Integer idProperty) {\n        this.idProperty.setValue(idProperty);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param defExportPriceProperty Default export price\n     */\n    public void setDefExportPrice(Integer defExportPriceProperty) {\n        this.defExportPriceProperty.setValue(defExportPriceProperty);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param defImportPriceProperty Default import price\n     */", "    public void setDefExportPrice(Integer defExportPriceProperty) {\n        this.defExportPriceProperty.setValue(defExportPriceProperty);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param defImportPriceProperty Default import price\n     */\n    public void setDefImportPrice(Integer defImportPriceProperty) {\n        this.defImportPriceProperty.setValue(defImportPriceProperty);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param exportable  Value that determines if the material will be exportable from the realm\n     */", "    public void setDefImportPrice(Integer defImportPriceProperty) {\n        this.defImportPriceProperty.setValue(defImportPriceProperty);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param exportable  Value that determines if the material will be exportable from the realm\n     */\n    public void setExportable(Boolean exportable) {\n        isExportableProperty.setValue(exportable);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     */", "    public void setExportable(Boolean exportable) {\n        isExportableProperty.setValue(exportable);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param isEphemeral Value that determines if the material can be stockpiled or stored\n     */\n    public void setIsEphemeral(Boolean isEphemeral) {\n        this.isEphemeralProperty.set(isEphemeral);\n    }\n}\n", "    public void setIsEphemeral(Boolean isEphemeral) {\n        this.isEphemeralProperty.set(isEphemeral);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/realm/template/VisualBuildingTemplate.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.realm.template;\n\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.scene.image.Image;\n\nimport java.util.List;", "\nimport java.util.List;\n\n/**\n * Template that is used when new buildings are generated. It stores a pathname that leads to its GFX and an JavaFX Image if a reference to that is required.\n * This Class if fully annotated for use with JAXB to be exported to an XML File.\n */\n@XmlRootElement(name=\"visual-building-template\")\npublic final class VisualBuildingTemplate extends BuildingTemplate{\n    private final StringProperty pathToGFXProperty = new SimpleStringProperty();\n    private Image GFX;\n    private Boolean gfxInitialized = false;\n\n    /**\n     * Default Constructor. Generates an invalid instance with id set to -1\n     */\n    public VisualBuildingTemplate() {\n        this(-1, \"\",-1,-1,false);\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param defConstructionCost construction cost per turn of construction\n     * @param defConstructionTime number of turns it takes to construct a building\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     */\n    public VisualBuildingTemplate(Integer id, String name, Integer defConstructionCost, Integer defConstructionTime, Boolean operatesImmediately) {\n        this(id, name, null, null, defConstructionCost, null, defConstructionTime, operatesImmediately, Configurator.getInstance().getDefBuildingGFXPathname());\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     * @param defConstructionCost construction cost per turn of construction\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     * @param defConstructionTime number of turns it takes to construct a building\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     * @param pathToGFX String pathname to an image file that represents this building. That Image should be square, but isn't required to be square\n     */\n    public VisualBuildingTemplate(Integer id, String name, List<Material> inputMaterials, List<Material> outputMaterials, Integer defConstructionCost, List<Material> constructionMaterials, Integer defConstructionTime, Boolean operatesImmediately, String pathToGFX) {\n        super(id, name, inputMaterials, outputMaterials, defConstructionCost, constructionMaterials, defConstructionTime, operatesImmediately);\n        this.pathToGFXProperty.setValue(pathToGFX);\n        this.pathToGFXProperty.setValue(Configurator.getInstance().getDefBuildingGFXPathname());\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to an image file that represents this building as a property. That Image should be square, but isn't required to be square\n     */", "public final class VisualBuildingTemplate extends BuildingTemplate{\n    private final StringProperty pathToGFXProperty = new SimpleStringProperty();\n    private Image GFX;\n    private Boolean gfxInitialized = false;\n\n    /**\n     * Default Constructor. Generates an invalid instance with id set to -1\n     */\n    public VisualBuildingTemplate() {\n        this(-1, \"\",-1,-1,false);\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param defConstructionCost construction cost per turn of construction\n     * @param defConstructionTime number of turns it takes to construct a building\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     */\n    public VisualBuildingTemplate(Integer id, String name, Integer defConstructionCost, Integer defConstructionTime, Boolean operatesImmediately) {\n        this(id, name, null, null, defConstructionCost, null, defConstructionTime, operatesImmediately, Configurator.getInstance().getDefBuildingGFXPathname());\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     * @param defConstructionCost construction cost per turn of construction\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     * @param defConstructionTime number of turns it takes to construct a building\n     * @param operatesImmediately does the building operate immediately or do you need to finish its construction\n     * @param pathToGFX String pathname to an image file that represents this building. That Image should be square, but isn't required to be square\n     */\n    public VisualBuildingTemplate(Integer id, String name, List<Material> inputMaterials, List<Material> outputMaterials, Integer defConstructionCost, List<Material> constructionMaterials, Integer defConstructionTime, Boolean operatesImmediately, String pathToGFX) {\n        super(id, name, inputMaterials, outputMaterials, defConstructionCost, constructionMaterials, defConstructionTime, operatesImmediately);\n        this.pathToGFXProperty.setValue(pathToGFX);\n        this.pathToGFXProperty.setValue(Configurator.getInstance().getDefBuildingGFXPathname());\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to an image file that represents this building as a property. That Image should be square, but isn't required to be square\n     */", "    public StringProperty pathToGFXProperty() {\n        return pathToGFXProperty;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return String pathname to an image file that represents this building.\n     */\n    @XmlElement(name=\"path-to-gfx\")\n    public String getPathToGFX() {\n        return pathToGFXProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method that initiates graphics if they haven't been initialized\n     * @return Image that represents this Building.\n     */", "    public String getPathToGFX() {\n        return pathToGFXProperty.get();\n    }\n\n    /**\n     * Lightweight Accessor Method that initiates graphics if they haven't been initialized\n     * @return Image that represents this Building.\n     */\n    public Image getGFX() {\n        if(!gfxInitialized)\n            return updateGFX();\n        else\n            return GFX;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param pathToGFX String pathname to an image file that represents this building. That Image should be square, but isn't required to be square\n     */", "    public Image getGFX() {\n        if(!gfxInitialized)\n            return updateGFX();\n        else\n            return GFX;\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param pathToGFX String pathname to an image file that represents this building. That Image should be square, but isn't required to be square\n     */", "    public void setPathToGFX(String pathToGFX) {\n        this.pathToGFXProperty.set(pathToGFX);\n    }\n\n    /**\n     * Updates the Image representation building to comply with the current value of pathToGFXProperty\n     * @return new Image that has been updated.\n     */\n    public Image updateGFX() {\n        //TODO: contemplate removing GFX from here or doing something better with loading (?)\n        GFX = DownfallUtil.getInstance().loadImage(pathToGFXProperty.get());\n        gfxInitialized = true;\n        return GFX;\n    }\n\n\n}\n", "    public Image updateGFX() {\n        //TODO: contemplate removing GFX from here or doing something better with loading (?)\n        GFX = DownfallUtil.getInstance().loadImage(pathToGFXProperty.get());\n        gfxInitialized = true;\n        return GFX;\n    }\n\n\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/DownfallUtil.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport javafx.scene.image.Image;\nimport javafx.scene.paint.Color;", "import javafx.scene.image.Image;\nimport javafx.scene.paint.Color;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Utility Class of the application. It defines a lot of static parameters that should not change.", "/**\n * Utility Class of the application. It defines a lot of static parameters that should not change.\n * This class is not instatiable if you want to get its only instance use getInstance() method.\n */\npublic final class DownfallUtil {\n    public final static String BUILDINGS_EDITOR_FXML_PATHNAME = \"fxml/editors/BuildingsEditor.fxml\";\n    public final static String MATERIALS_EDITOR_FXML_PATHNAME = \"fxml/editors/MaterialsEditor.fxml\";\n    public final static String TAGS_EDITOR_FXML_PATHNAME = \"fxml/editors/TagsEditor.fxml\";\n    public final static String REALM_EDITOR_FXML_PATHNAME = \"fxml/editors/RealmEditor.fxml\";\n    public final static String DOWNFALL_MAIN_FXML_PATHNAME = \"fxml/main/DownfallMain.fxml\";\n    public final static String REALM_SCREEN_FXML_PATHNAME = \"fxml/main/tabs/RealmScreen.fxml\";\n\n", "    public final static String REALM_EDITOR_FXML_PATHNAME = \"fxml/editors/RealmEditor.fxml\";\n    public final static String DOWNFALL_MAIN_FXML_PATHNAME = \"fxml/main/DownfallMain.fxml\";\n    public final static String REALM_SCREEN_FXML_PATHNAME = \"fxml/main/tabs/RealmScreen.fxml\";\n\n\n    public final static String DEFAULT_SAVEGAME_PATHNAME = \"save/testsave.xml\";\n    public final static String DEFAULT_MATERIAL_GFX_PATHNAME = \"gfx/materials/orb.png\";\n    public final static String DEFAULT_BUILDING_GFX_PATHNAME = \"gfx/buildings/houseSmall.png\";\n\n    public final static String DEFAULT_CONFIG_PATHNAME = \"conf.xml\";\n    public final static String DEFAULT_RULES_PATHNAME = \"rules/default.xml\";\n", "    public final static String DEFAULT_CONFIG_PATHNAME = \"conf.xml\";\n    public final static String DEFAULT_RULES_PATHNAME = \"rules/default.xml\";\n\n    public final static String MAIN_CSS_RESOURCE = \"css/Eraconstas.css\";\n\n    public final static Integer DEFAULT_MATERIAL_AMOUNT = 10;\n    public final static String DEFAULT_LOGGER = \"DownfallEAM\";\n\n    public final static Color BACKGROUND_COLOR = Color.web(\"#181e21\");\n    public final static Color HIGHLIGHT_COLOR = Color.web(\"#a34097\");\n    public final static Color CONFIRM_COLOR = Color.web(\"#40A34C\");\n\n\n    private URL URLRealmScreenFXML;\n    private URL URLMaterialsEditorFXML;\n    private URL URLRealmEditorFXML;\n    private URL URLBuildingsEditorFXML;\n    private URL URLTagsEditorFXML;\n    private URL URLDownfallMainFXML;\n\n    private final static DownfallUtil instance = new DownfallUtil();\n", "    public final static Color BACKGROUND_COLOR = Color.web(\"#181e21\");\n    public final static Color HIGHLIGHT_COLOR = Color.web(\"#a34097\");\n    public final static Color CONFIRM_COLOR = Color.web(\"#40A34C\");\n\n\n    private URL URLRealmScreenFXML;\n    private URL URLMaterialsEditorFXML;\n    private URL URLRealmEditorFXML;\n    private URL URLBuildingsEditorFXML;\n    private URL URLTagsEditorFXML;\n    private URL URLDownfallMainFXML;\n\n    private final static DownfallUtil instance = new DownfallUtil();\n", "    public static DownfallUtil getInstance() {\n        return instance;\n    }\n\n    /**\n     * Default Constructor method. Constructs all necessary URLs to all fxml files\n     */\n    private DownfallUtil() {\n        try {\n            URLMaterialsEditorFXML = new URL(\"file:\" + MATERIALS_EDITOR_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + MATERIALS_EDITOR_FXML_PATHNAME);\n        }\n", "        try {\n            URLMaterialsEditorFXML = new URL(\"file:\" + MATERIALS_EDITOR_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + MATERIALS_EDITOR_FXML_PATHNAME);\n        }\n\n        try {\n            URLBuildingsEditorFXML = new URL(\"file:\" + BUILDINGS_EDITOR_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + BUILDINGS_EDITOR_FXML_PATHNAME);\n        }\n", "        try {\n            URLTagsEditorFXML = new URL(\"file:\" + TAGS_EDITOR_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + TAGS_EDITOR_FXML_PATHNAME);\n        }\n\n        try {\n            URLDownfallMainFXML = new URL(\"file:\" + DOWNFALL_MAIN_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + DOWNFALL_MAIN_FXML_PATHNAME);\n        }\n", "        try {\n            URLRealmScreenFXML = new URL(\"file:\" + REALM_SCREEN_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + REALM_SCREEN_FXML_PATHNAME);\n        }\n\n        try {\n            URLRealmEditorFXML = new URL(\"file:\" + REALM_EDITOR_FXML_PATHNAME);\n        } catch (MalformedURLException e) {\n            informOfMalformedURL(\"file:\" + REALM_EDITOR_FXML_PATHNAME);\n        }\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Materials Editor.\n     */", "    public URL getURLMaterialsEditorFXML() {\n        return URLMaterialsEditorFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Buildings Editor.\n     */\n    public URL getURLBuildingsEditorFXML() {\n        return URLBuildingsEditorFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Tags Editor.\n     */", "    public URL getURLBuildingsEditorFXML() {\n        return URLBuildingsEditorFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Tags Editor.\n     */\n    public URL getURLTagsEditorFXML() {\n        return URLTagsEditorFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return  URL to an FXML file that contains the Realm Editor.\n     */", "    public URL getURLTagsEditorFXML() {\n        return URLTagsEditorFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return  URL to an FXML file that contains the Realm Editor.\n     */\n    public URL getURLRealmEditorFXML() { return URLRealmEditorFXML; }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Downfall Main UI.\n     */", "    public URL getURLRealmEditorFXML() { return URLRealmEditorFXML; }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Downfall Main UI.\n     */\n    public URL getURLDownfallMainFXML() {\n        return URLDownfallMainFXML;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return URL to an FXML file that contains Realm Screen.\n     */", "    public URL getURLRealmScreenFXML() {\n        return URLRealmScreenFXML;\n    }\n\n    /**\n     *  Loads an image from a given pathname.\n     *  Lightweight method. Quickly constructs a URL by adding \"file:\" to a given pathname and returns a new image made from that URL\n     * @param pathname pathname to an image file\n     * @return Image loaded from the pathname.\n     */\n    public Image loadImage(String pathname) {\n       return new Image(\"file:\" + pathname);\n    }\n\n    /**\n     * Informs the logger that a given URL seems to be malformed.\n     * @param URL URL that returned a MalformedURException upon being constructed\n     */\n    private void informOfMalformedURL(String URL) {\n        Logger.getLogger(DEFAULT_LOGGER).log(Level.SEVERE, \"URL: \"+URL+\" seems to be malformed.\");\n    }\n}\n", "    public Image loadImage(String pathname) {\n       return new Image(\"file:\" + pathname);\n    }\n\n    /**\n     * Informs the logger that a given URL seems to be malformed.\n     * @param URL URL that returned a MalformedURException upon being constructed\n     */\n    private void informOfMalformedURL(String URL) {\n        Logger.getLogger(DEFAULT_LOGGER).log(Level.SEVERE, \"URL: \"+URL+\" seems to be malformed.\");\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/SaveManager.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\n/**\n * Interface for any class responsible for loading, saving and keeping track", "/**\n * Interface for any class responsible for loading, saving and keeping track\n * of the last location to which the last load or to which last save was done.\n */\npublic interface SaveManager {\n    /**\n     * Loads and applies the savegame from last pathname used and attempts to find,\n     * load and validate the rules that are referenced in the savegame.\n     */\n    void loadFromLast();\n\n    /**\n     * Loads and applies the savegame from a given pathname and attempts to find,\n     * load and validate the rules that are referenced in the savegame.\n     * @param pathname pathname to a savegame file.\n     */\n    void loadFrom(String pathname);\n\n    /**\n     * Formulates a new Savegame based on the state of the Configurator and then saves it\n     * to the last pathname used.\n     */\n    void saveToLast();\n\n    /**\n     * Formulates a new Savegame ba\n     * @param pathname pathname to a file in which the savegame data will be recorded.\n     */\n    void saveTo(String pathname);\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/Configuration.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;", "import jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.SimpleBooleanProperty;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\n\n/**\n * Determines the configuration of the program, currently chosen Ruleset and default values for gfx files.\n */", " * Determines the configuration of the program, currently chosen Ruleset and default values for gfx files.\n */\n@XmlRootElement(name = \"configuration\")\npublic final class Configuration {\n    private final StringProperty lastRulesPathname = new SimpleStringProperty(DownfallUtil.DEFAULT_RULES_PATHNAME);\n\n    private final StringProperty defMaterialGFXPathname = new SimpleStringProperty(DownfallUtil.DEFAULT_MATERIAL_GFX_PATHNAME);\n\n    private final StringProperty defBuildingGFXPathname = new SimpleStringProperty(DownfallUtil.DEFAULT_BUILDING_GFX_PATHNAME);\n\n    private final BooleanProperty autoloadLastSave = new SimpleBooleanProperty(false);\n\n    private final StringProperty lastSavegamePathname = new SimpleStringProperty(DownfallUtil.DEFAULT_SAVEGAME_PATHNAME);\n\n    /**\n     * Lightweight Accessor Method\n     * @return Pathname to the last loaded rules.\n     */\n    @XmlElement(name = \"rules-pathname\")", "    public String getLastRulesPathname() {\n        return lastRulesPathname.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Pathname to the default image used for VisualMaterialTemplate\n     */\n    @XmlElement(name = \"def-materials-gfx-pathname\")\n    public String getDefMaterialGFXPathname() {\n        return defMaterialGFXPathname.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Pathname to the default image used for VisualBuildingTemplate\n     */\n    @XmlElement(name = \"def-buildings-gfx-pathname\")", "    public String getDefMaterialGFXPathname() {\n        return defMaterialGFXPathname.get();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return Pathname to the default image used for VisualBuildingTemplate\n     */\n    @XmlElement(name = \"def-buildings-gfx-pathname\")\n    public String getDefBuildingGFXPathname() {\n        return defBuildingGFXPathname.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Flag that determines if the last savegame should be loaded at startup.\n     */\n    @XmlElement(name = \"autoload-last-savegame\")", "    public String getDefBuildingGFXPathname() {\n        return defBuildingGFXPathname.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Flag that determines if the last savegame should be loaded at startup.\n     */\n    @XmlElement(name = \"autoload-last-savegame\")\n    public Boolean getAutoloadLastSave() {\n        return autoloadLastSave.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Pathname to last savegame that was loaded/saved.\n     */\n    @XmlElement(name = \"last-savegame-pathname\")", "    public Boolean getAutoloadLastSave() {\n        return autoloadLastSave.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Pathname to last savegame that was loaded/saved.\n     */\n    @XmlElement(name = \"last-savegame-pathname\")\n    public String getLastSavegamePathname() {\n        return lastSavegamePathname.get();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param lastRulesPathname Pathname to the last loaded rules.\n     */", "    public String getLastSavegamePathname() {\n        return lastSavegamePathname.get();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param lastRulesPathname Pathname to the last loaded rules.\n     */\n    public void setLastRulesPathname(String lastRulesPathname) {\n        this.lastRulesPathname.set(lastRulesPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param defMaterialGFXPathname Pathname to the default image used for VisualMaterialTemplate\n     */", "    public void setLastRulesPathname(String lastRulesPathname) {\n        this.lastRulesPathname.set(lastRulesPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param defMaterialGFXPathname Pathname to the default image used for VisualMaterialTemplate\n     */\n    public void setDefMaterialGFXPathname(String defMaterialGFXPathname) {\n        this.defMaterialGFXPathname.set(defMaterialGFXPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param defBuildingGFXPathname Pathname to the default image used for VisualBuildingTemplate\n     */", "    public void setDefMaterialGFXPathname(String defMaterialGFXPathname) {\n        this.defMaterialGFXPathname.set(defMaterialGFXPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param defBuildingGFXPathname Pathname to the default image used for VisualBuildingTemplate\n     */\n    public void setDefBuildingGFXPathname(String defBuildingGFXPathname) {\n        this.defBuildingGFXPathname.set(defBuildingGFXPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param autoloadLastSave Flag that determines if the last savegame should be loaded at startup.\n     */", "    public void setDefBuildingGFXPathname(String defBuildingGFXPathname) {\n        this.defBuildingGFXPathname.set(defBuildingGFXPathname);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param autoloadLastSave Flag that determines if the last savegame should be loaded at startup.\n     */\n    public void setAutoloadLastSave(Boolean autoloadLastSave) {\n        this.autoloadLastSave.set(autoloadLastSave);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param lastSavegamePathname Pathname to the last loaded rules.\n     */", "    public void setAutoloadLastSave(Boolean autoloadLastSave) {\n        this.autoloadLastSave.set(autoloadLastSave);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param lastSavegamePathname Pathname to the last loaded rules.\n     */\n    public void setLastSavegamePathname(String lastSavegamePathname) {\n        this.lastSavegamePathname.set(lastSavegamePathname);\n    }\n}\n", "    public void setLastSavegamePathname(String lastSavegamePathname) {\n        this.lastSavegamePathname.set(lastSavegamePathname);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/PathRelativisor.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport java.io.File;\nimport java.nio.file.Path;", "import java.io.File;\nimport java.nio.file.Path;\n\n/**\n * Relativizes path to an executable path, a given path or a file.\n * If the path provided does not lie inside the user.dir or another file, path provided as an argument it returns the absolute path instead.\n */\npublic final class PathRelativisor {\n    Path path;\n\n    /**\n     * Default constructor. does not provide the path to be relativized.\n     * If you're using this constructor you should provide the path later with setPath();\n     */\n    public PathRelativisor() { super();}\n\n    /**\n     *\n     * @param path Path to be relativized as a Path.\n     */\n    public PathRelativisor(Path path) {\n        this.path = path;\n    }\n\n    /**\n     *\n     * @param file File, a path to which you want to relativize.\n     */\n    public PathRelativisor(File file) {\n        this.path = file.toPath();\n    }\n\n    /**\n     *\n     * @param pathname Pathname which you want to relativize.\n     */\n    public PathRelativisor(String pathname) {\n        this.path = Path.of(pathname);\n    }\n\n    /**\n     * Relativizes the path to user.dir, which is the directory from which the application was launched.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside user.dir returns absolute path instead.\n     */", "    public String relativize() {\n        return relativizeTo(System.getProperty(\"user.dir\"));\n    }\n\n    /**\n     * Relativizes the path to the file provided.\n     * @param file File to which you want to relativize your path.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside the file it returns absolute path instead.\n     */\n    public String relativizeTo(File file) {\n        return relativizeTo(file.getPath());\n    }\n\n    /**\n     * Relativizes the path to the pathname provided.\n     * @param pathname Pathname which you want to relativize your path. This pathname has to be absolute, otherwise it will return what's already stored wether it's absolute or not.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside the file it returns absolute path instead.\n     */", "    public String relativizeTo(File file) {\n        return relativizeTo(file.getPath());\n    }\n\n    /**\n     * Relativizes the path to the pathname provided.\n     * @param pathname Pathname which you want to relativize your path. This pathname has to be absolute, otherwise it will return what's already stored wether it's absolute or not.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside the file it returns absolute path instead.\n     */\n    public String relativizeTo(String pathname) {\n        return relativizeTo(Path.of(pathname));\n    }\n\n    /**\n     * Relativizes the path to the pathname provided.\n     * @param path which you want to relativize your path. This path has to be absolute, otherwise it will return what's already stored wether it's absolute or not.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside the file it returns absolute path instead.\n     */", "    public String relativizeTo(String pathname) {\n        return relativizeTo(Path.of(pathname));\n    }\n\n    /**\n     * Relativizes the path to the pathname provided.\n     * @param path which you want to relativize your path. This path has to be absolute, otherwise it will return what's already stored wether it's absolute or not.\n     * @return Relative path of the path set in the PathRelativisor. If the path is not inside the file it returns absolute path instead.\n     */\n    public String relativizeTo(Path path) {\n        if(!this.path.isAbsolute())\n            return this.path.toString();", "    public String relativizeTo(Path path) {\n        if(!this.path.isAbsolute())\n            return this.path.toString();\n        if(!path.isAbsolute())\n            return this.path.toString();\n\n        Path relative = path.relativize(this.path);\n        if(relative.toString().contains(\"src/main\" +File.separator))\n            return this.path.toString();\n        else\n            return relative.toString();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param path Path to be relativized as a Path.\n     */", "    public void setPath(Path path) {\n        this.path = path;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param file File, a path to which you want to relativize;\n     */\n    public void setPath(File file) {\n        this.path = file.toPath();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param pathname Pathname which you want to relativize.\n     */", "    public void setPath(File file) {\n        this.path = file.toPath();\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param pathname Pathname which you want to relativize.\n     */\n    public void setPath(String pathname) {\n        this.path = Path.of(pathname);\n    }\n}\n", "    public void setPath(String pathname) {\n        this.path = Path.of(pathname);\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/Rules.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.realm.template.VisualBuildingTemplate;", "import net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.realm.template.VisualBuildingTemplate;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlElementWrapper;\nimport jakarta.xml.bind.annotation.XmlRootElement;\n\nimport java.util.ArrayList;\nimport java.util.List;\n", "import java.util.List;\n\n/**\n * Contains reference to a user defined Ruleset. Ruleset determines Templates that can be used for different Materials and Buildings.\n * This class if fully annotated and can be saved to an XML file with JAXB\n */\n@XmlRootElement(name=\"rules\")\npublic final class Rules {\n    private List<VisualMaterialTemplate> materialTemplates = new ArrayList<>();\n    private List<VisualBuildingTemplate> buildingTemplates = new ArrayList<>();\n    private List<Tag> actorTags = new ArrayList<>();\n\n    /**\n     * Lightweight accessor method.\n     * @return Full list of all available material templates.\n     */\n    @XmlElementWrapper(name = \"material-templates\")\n    @XmlElement(name = \"material-template\")\n    public List<VisualMaterialTemplate> getMaterialTemplates() {\n        return materialTemplates;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Full list of all available building templates.\n     */\n    @XmlElementWrapper(name = \"building-templates\")\n    @XmlElement(name = \"building-template\")\n    public List<VisualBuildingTemplate> getBuildingTemplates() {\n        return buildingTemplates;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Full list of possible tags that can be applied to an Actor.\n     */\n    @XmlElementWrapper(name = \"tags\")\n    @XmlElement(name = \"tag\")\n    public List<Tag> getActorTags() { return actorTags; }\n\n    /**\n     * Lightweight mutator method.\n     * @param materialTemplates Full list of all available material templates.\n     */", "    public void setMaterialTemplates(List<VisualMaterialTemplate> materialTemplates) {\n        this.materialTemplates = materialTemplates;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param buildingTemplates Full list of all available building templates.\n     */\n    public void setBuildingTemplates(List<VisualBuildingTemplate> buildingTemplates) {\n        this.buildingTemplates = buildingTemplates;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param actorTags Full list of possible tags that can be applied to an Actor.\n     */", "    public void setBuildingTemplates(List<VisualBuildingTemplate> buildingTemplates) {\n        this.buildingTemplates = buildingTemplates;\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param actorTags Full list of possible tags that can be applied to an Actor.\n     */\n    public void setActorTags(List<Tag> actorTags) {\n        this.actorTags = actorTags;\n    }\n}\n", "    public void setActorTags(List<Tag> actorTags) {\n        this.actorTags = actorTags;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/Configurator.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.realm.Realm;", "import net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.realm.Realm;\nimport net.dragondelve.downfall.realm.template.VisualBuildingTemplate;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Marshaller;\nimport jakarta.xml.bind.Unmarshaller;\n\nimport java.io.File;", "\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**", "\n/**\n *  Non Instantiable configurator class that is responsible for loading, and storing the Configuration of the program.\n */\npublic final class Configurator {\n    private static final String CONFIG_PATH = DownfallUtil.DEFAULT_CONFIG_PATHNAME;\n    private static final String DEFAULT_RULES_PATH = \"rules/default.xml\";\n\n    private static final Configurator instance = new Configurator();\n\n    private Configuration configuration = new Configuration();\n    private Rules rules = new Rules();\n    private final Realm userRealm = new Realm();\n    private final SaveManager saveManager = new SimpleSaveManager();\n\n    /**\n     * Private constructor to make this class non instantiable.\n     */\n    private Configurator() {super();}\n\n    /**\n     * loads and applies rules stored as lastLoadedRules in the current configuration\n     */", "    public void loadAndApplyRules() {\n        loadAndApplyRules(configuration.getLastRulesPathname());\n    }\n\n    /**\n     * loads and applies rules stored at pathname and changes the configuration to remember the new pathname as lastLoaderRules\n     * @param pathname pathname to rules to be loaded and applied\n     */\n    public void loadAndApplyRules(String pathname) {\n        rules = loadRules(pathname);\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Currently applied rules.\n     */", "    public void loadAndApplyRules(String pathname) {\n        rules = loadRules(pathname);\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Currently applied rules.\n     */\n    public Rules getRules() {\n        return rules;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Pathname to the last loaded savegame.\n     */", "    public Rules getRules() {\n        return rules;\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Pathname to the last loaded savegame.\n     */\n    public String getLastSavegamePathname() {\n        return configuration.getLastSavegamePathname();\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Pathname to the last loaded rules\n     */", "    public String getLastSavegamePathname() {\n        return configuration.getLastSavegamePathname();\n    }\n\n    /**\n     * Lightweight accessor method.\n     * @return Pathname to the last loaded rules\n     */\n    public String getLastRulesPathname() {\n        return configuration.getLastRulesPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to the default GFX of VisualMaterialTemplate in the current configuration.\n     */", "    public String getLastRulesPathname() {\n        return configuration.getLastRulesPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to the default GFX of VisualMaterialTemplate in the current configuration.\n     */\n    public String getDefMaterialGFXPathname() {\n        return configuration.getDefMaterialGFXPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to the default GFX of VisualBuildingTemplate in the current configuration.\n     */", "    public String getDefMaterialGFXPathname() {\n        return configuration.getDefMaterialGFXPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to the default GFX of VisualBuildingTemplate in the current configuration.\n     */\n    public String getDefBuildingGFXPathname() {\n        return configuration.getDefBuildingGFXPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return User Realm. This realm gets saved and loaded by the save manager and should be treated as the one and only realm that represents the user/\n     */", "    public String getDefBuildingGFXPathname() {\n        return configuration.getDefBuildingGFXPathname();\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return User Realm. This realm gets saved and loaded by the save manager and should be treated as the one and only realm that represents the user/\n     */\n    public Realm getUserRealm() {\n        return userRealm;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Save Manager instance that is used to manage savegames.\n     */", "    public Realm getUserRealm() {\n        return userRealm;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return Save Manager instance that is used to manage savegames.\n     */\n    public SaveManager getSaveManager() {\n        return saveManager;\n    }\n\n    /**\n     * NOT a lightweight mutator method, executes save configuration when called.\n     * @param lastSavegamePathname Pathname to the last loaded rules.\n     */", "    public SaveManager getSaveManager() {\n        return saveManager;\n    }\n\n    /**\n     * NOT a lightweight mutator method, executes save configuration when called.\n     * @param lastSavegamePathname Pathname to the last loaded rules.\n     */\n    public void setLastSavegamePathname(String lastSavegamePathname) {\n        configuration.setLastSavegamePathname(new PathRelativisor(lastSavegamePathname).relativize());\n        saveConfiguration();\n    }\n\n    /**\n     * Relatively lightweight accessor method, overrides all fields of the original final reference to userRealm\n     * @param realm realm whose values are going to override the current values of userRealm\n     */", "    public void setLastSavegamePathname(String lastSavegamePathname) {\n        configuration.setLastSavegamePathname(new PathRelativisor(lastSavegamePathname).relativize());\n        saveConfiguration();\n    }\n\n    /**\n     * Relatively lightweight accessor method, overrides all fields of the original final reference to userRealm\n     * @param realm realm whose values are going to override the current values of userRealm\n     */\n    public void setUserRealm(Realm realm) {\n        userRealm.setId(realm.getId());\n        userRealm.setName(realm.getName());\n        userRealm.setTreasury(realm.getTreasury());\n        userRealm.setInfamy(realm.getInfamy());\n        userRealm.setLegitimacy(realm.getLegitimacy());\n        userRealm.setDiplomaticReputation(realm.getDiplomaticReputation());\n        userRealm.setPowerProjection(realm.getPowerProjection());\n        userRealm.setPrestige(realm.getPrestige());\n        userRealm.setStability(realm.getStability());\n        userRealm.setRealmPathToGFX(realm.getRealmPathToGFX());\n        userRealm.setRulerPathToGFX(realm.getRulerPathToGFX());\n\n        userRealm.getStockpile().clear();\n        userRealm.getStockpile().addAll(realm.getStockpile());\n\n        userRealm.getOwnedBuildings().clear();\n        userRealm.getOwnedBuildings().addAll(realm.getOwnedBuildings());\n\n        userRealm.getTags().clear();\n        userRealm.getTags().addAll(realm.getTags());\n    }\n\n    /**\n     * Searches the list of all VisualMaterialTemplates in the currently loaded ruleset for a matching id of a given material.\n     * @param material material that has an id set to represent a specific template.\n     * @return VisualMaterialTemplate that is associated with that material. If none found returns null.\n     */", "    public void setUserRealm(Realm realm) {\n        userRealm.setId(realm.getId());\n        userRealm.setName(realm.getName());\n        userRealm.setTreasury(realm.getTreasury());\n        userRealm.setInfamy(realm.getInfamy());\n        userRealm.setLegitimacy(realm.getLegitimacy());\n        userRealm.setDiplomaticReputation(realm.getDiplomaticReputation());\n        userRealm.setPowerProjection(realm.getPowerProjection());\n        userRealm.setPrestige(realm.getPrestige());\n        userRealm.setStability(realm.getStability());\n        userRealm.setRealmPathToGFX(realm.getRealmPathToGFX());\n        userRealm.setRulerPathToGFX(realm.getRulerPathToGFX());\n\n        userRealm.getStockpile().clear();\n        userRealm.getStockpile().addAll(realm.getStockpile());\n\n        userRealm.getOwnedBuildings().clear();\n        userRealm.getOwnedBuildings().addAll(realm.getOwnedBuildings());\n\n        userRealm.getTags().clear();\n        userRealm.getTags().addAll(realm.getTags());\n    }\n\n    /**\n     * Searches the list of all VisualMaterialTemplates in the currently loaded ruleset for a matching id of a given material.\n     * @param material material that has an id set to represent a specific template.\n     * @return VisualMaterialTemplate that is associated with that material. If none found returns null.\n     */", "    public VisualMaterialTemplate findMaterialTemplate(Material material) {\n        if(material == null)\n            return null;\n        List<VisualMaterialTemplate> list = rules.getMaterialTemplates().stream().filter(visualMaterialTemplate -> visualMaterialTemplate.getId().equals(material.getTemplateId())).collect(Collectors.toList());\n        if(list.size() > 1) {\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"Multiple(\"+list.size()+\") IDs found for template with id = \"+material.getTemplateId());\n        } else if(list.size() <= 0) {\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.SEVERE, \"No Template found for id = \"+material.getTemplateId());\n            return null;\n        }\n        return list.get(0);\n    }\n\n    /**\n     * Loads configuration from CONFIG_PATH defined in this class.\n     */", "    public void loadConfiguration() {\n        File config = new File(CONFIG_PATH);\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Configuration loading initiated with path: \" + CONFIG_PATH);\n        try {\n            JAXBContext context = JAXBContext.newInstance(Configuration.class);\n            Unmarshaller unmarshaller = context.createUnmarshaller();\n            configuration = (Configuration) unmarshaller.unmarshal(config);\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING,\"Configuration loading failed, attempting to save a default configuration\");\n            saveConfiguration();\n        }\n    }\n\n    /**\n     * Saves configuration to an XML file at CONFIG_PATH defined in this class\n     */", "    public void saveConfiguration() {\n        File config = new File(CONFIG_PATH);\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Configuration saving initiated with path: \" + CONFIG_PATH);\n        try {\n            JAXBContext context = JAXBContext.newInstance(Configuration.class);\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n            marshaller.marshal(configuration, config);\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING,\"Configuration saving failed =C\");\n        }\n    }\n\n    /**\n     * Loads rules from a specific provided pathname.\n     * @param pathname pathname to an xml file where rules to be downloaded are located.\n     * @return rules that have been loaded. If loading from pathname fails, returns defaultRules isnted.\n     */\n    private Rules loadRules(String pathname) {\n        File rulesFile = new File(pathname);\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE,\"Rules loading initiated with path: \"+pathname);", "        try {\n            JAXBContext context = JAXBContext.newInstance(Rules.class);\n            Unmarshaller unmarshaller = context.createUnmarshaller();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE,\"Rules config loading successfully completed.\");\n            Rules rules = (Rules) unmarshaller.unmarshal(rulesFile);\n            configuration.setLastRulesPathname(new PathRelativisor(pathname).relativize());\n            saveConfiguration();\n            return rules;\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING,\"Rules config loading failed, loading default \");\n            Rules rules = loadDefaultRules();\n            saveRules(rules, pathname);\n            return rules;\n        }\n    }\n\n    /**\n     * Saves currently applied rules to an XML file at DEFAULT_RULES_PATH defined in this class\n     */", "    public void saveRules() {\n        saveRules(DEFAULT_RULES_PATH);\n    }\n\n    /**\n     * Saves currently applied rules to an XML file at a given pathname\n     * @param pathname pathname to a file that can be written.\n     */\n    public void saveRules(String pathname){\n        saveRules(rules, pathname);\n    }\n\n    /**\n     * Saves given rules to an XML files at a given pathname\n     * @param rules rules to be saved.\n     * @param pathname pathname to a file that can be written.\n     */\n    private void saveRules(Rules rules, String pathname) {\n        File file = new File(pathname);", "    public void saveRules(String pathname){\n        saveRules(rules, pathname);\n    }\n\n    /**\n     * Saves given rules to an XML files at a given pathname\n     * @param rules rules to be saved.\n     * @param pathname pathname to a file that can be written.\n     */\n    private void saveRules(Rules rules, String pathname) {\n        File file = new File(pathname);", "        try {\n            file.createNewFile();\n        } catch (IOException ioException) {\n            ioException.printStackTrace();\n        }\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Rules saving initiated with path: \"+pathname);\n        try {\n            JAXBContext context = JAXBContext.newInstance(Rules.class);\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n            marshaller.marshal(rules, file);\n            configuration.setLastRulesPathname(new PathRelativisor(pathname).relativize());\n            saveConfiguration();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Rules saving successfully completed\");\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"Couldn't save Rules to path: \"+pathname);\n        }\n    }\n\n    /**\n     * Loads predefined default rules that are hard coded.\n     * @return default rules that .\n     */\n    private Rules loadDefaultRules() {\n        Rules rules = new Rules();\n        List<VisualMaterialTemplate> materialTemplates = new ArrayList<>();\n        materialTemplates.add(new VisualMaterialTemplate(\"Grain\",1,5,8,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Meat\",2,8,12,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Cloth\",3,12,16,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Clay\",4,4,7,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Bricks\",5,9,14,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Wood\",6,5,8,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Hardwood\",7,6,12,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Furniture\",8,16,22,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Copper\",9,3,6,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Bronze\",10,4,8,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Iron\",11,6,12,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Steel\",12,9,18,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Thaumium\",13,20,30,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Gold\",14,50,50,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Bronze Tools\",15,20,24,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Iron Tools\",16,24,30,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Steel Tools\",17,32,44,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Magic Tools\",18,44,72,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Bronze Weapons\",19,24,30,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Iron Weapons\",20,28,36,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Steel Weapons\",21,36,50,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Magic Weapons\",22,48,78,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Siege Equipment\",23,50,75,true, false));\n        materialTemplates.add(new VisualMaterialTemplate(\"Services\",24,-1,10,false, false));\n\n        List<VisualBuildingTemplate> buildingTemplates = new ArrayList<>();\n\n        VisualBuildingTemplate farmTemplate = new VisualBuildingTemplate();\n        farmTemplate.setId(1);\n        farmTemplate.setName(\"Farm (Iron Tools)\");\n        farmTemplate.setDefConstructionTime(30);\n        farmTemplate.setDefConstructionCost(30);\n        farmTemplate.getInputMaterials().add(new Material(17, 1));\n        farmTemplate.getOutputMaterials().add(new Material(1, 10));\n        farmTemplate.getConstructionMaterials().add(new Material(7, 10));\n        farmTemplate.getConstructionMaterials().add(new Material(17, 1));\n        buildingTemplates.add(farmTemplate);\n\n        VisualBuildingTemplate barnTemplate = new VisualBuildingTemplate();\n        barnTemplate.setId(2);\n        barnTemplate.setName(\"Barn (Iron Tools)\");\n        barnTemplate.setDefConstructionTime(30);\n        barnTemplate.setDefConstructionCost(30);\n        barnTemplate.getInputMaterials().add(new Material(17, 1));\n        barnTemplate.getInputMaterials().add(new Material(1,10));\n        barnTemplate.getOutputMaterials().add(new Material(2, 10));\n        barnTemplate.getConstructionMaterials().add(new Material(7, 10));\n        barnTemplate.getConstructionMaterials().add(new Material(17, 1));\n        buildingTemplates.add(barnTemplate);\n\n        VisualBuildingTemplate mineTemplate = new VisualBuildingTemplate();\n        mineTemplate.setId(3);\n        mineTemplate.setName(\"Iron Mine (Iron Tools)\");\n        mineTemplate.setDefConstructionTime(30);\n        mineTemplate.setDefConstructionCost(30);\n        mineTemplate.getInputMaterials().add(new Material(17, 1));\n        mineTemplate.getOutputMaterials().add(new Material(12, 10));\n        mineTemplate.getConstructionMaterials().add(new Material(6, 5));\n        mineTemplate.getConstructionMaterials().add(new Material(7, 5));\n        mineTemplate.getConstructionMaterials().add(new Material(17, 1));\n        buildingTemplates.add(mineTemplate);\n\n        rules.setMaterialTemplates(materialTemplates);\n        rules.setBuildingTemplates(buildingTemplates);\n        return rules;\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return The only instance of this class.\n     */", "    public static Configurator getInstance() {\n        return instance;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/util/SimpleSaveManager.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.util;\n\nimport net.dragondelve.downfall.realm.Savegame;\nimport jakarta.xml.bind.JAXBContext;", "import net.dragondelve.downfall.realm.Savegame;\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Marshaller;\nimport jakarta.xml.bind.Unmarshaller;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;", "import java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Simple implementation of save manager that uses the Configurator class to store the LastSavegamePathname.\n * If a savegame is loaded it also tries to find, load and apply the rules that were used when last saving this savegame.\n */\nfinal class SimpleSaveManager implements SaveManager{\n    /**\n     * Loads and applies the savegame from last pathname used and attempts to find,", "    /**\n     * Loads and applies the savegame from last pathname used and attempts to find,\n     * load and validate the rules that are referenced in the savegame.\n     */\n    @Override\n    public void loadFromLast() {\n        loadFrom(Configurator.getInstance().getLastSavegamePathname());\n    }\n\n    /**\n     * Loads and applies the savegame from a given pathname and attempts to find,\n     * load and validate the rules that are referenced in the savegame.\n     * @param pathname pathname to a savegame file.\n     */\n    @Override", "    public void loadFrom(String pathname) {\n        File saveFile = new File(pathname);\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE,\"Savegame loading initiated with path: \"+pathname);\n        try {\n            JAXBContext context = JAXBContext.newInstance(Savegame.class);\n            Unmarshaller unmarshaller = context.createUnmarshaller();\n            Savegame savegame = (Savegame) unmarshaller.unmarshal(saveFile);\n\n            Configurator.getInstance().setUserRealm(savegame.getUserRealm());\n            Configurator.getInstance().loadAndApplyRules(savegame.getPathToRules());\n            Configurator.getInstance().setLastSavegamePathname(pathname);\n\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE,\"Savegame config loading successfully completed.\");\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING,\"Savegame config loading failed, loading default \");\n        }\n    }\n\n    /**\n     * Formulates a new Savegame based on the state of the Configurator and then saves it\n     * to the last pathname used.\n     */\n    @Override", "    public void saveToLast() {\n        saveTo(Configurator.getInstance().getLastSavegamePathname());\n    }\n\n    /**\n     * Formulates a new Savegame ba\n     * @param pathname pathname to a file in which the savegame data will be recorded.\n     */\n    @Override\n    public void saveTo(String pathname) {\n        Savegame savegame = new Savegame();\n        savegame.setPathToRules(Configurator.getInstance().getLastRulesPathname());\n        savegame.setUserRealm(Configurator.getInstance().getUserRealm());\n\n        File file = new File(pathname);", "    public void saveTo(String pathname) {\n        Savegame savegame = new Savegame();\n        savegame.setPathToRules(Configurator.getInstance().getLastRulesPathname());\n        savegame.setUserRealm(Configurator.getInstance().getUserRealm());\n\n        File file = new File(pathname);\n        try {\n            file.createNewFile();\n        } catch (IOException ioException) {\n            ioException.printStackTrace();\n        }\n        Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Savegame saving initiated with path: \"+pathname);", "        try {\n            JAXBContext context = JAXBContext.newInstance(Savegame.class);\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n            marshaller.marshal(savegame, file);\n            Configurator.getInstance().setLastSavegamePathname(pathname);\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.FINE, \"Savegame saving successfully completed\");\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"Couldn't save Savegame to path: \"+pathname);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/StageController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui;\n\nimport javafx.stage.Stage;\n", "import javafx.stage.Stage;\n\n/**\n * Interface for every JavaFX FXML controller that controls an entire Stage.\n * If you create a controller that controls the entire stage you should pass them the stage on which\n * they are displayed for convenience.\n */\npublic interface StageController {\n    //TODO:Consider this becoming a class instead of an interface (?)\n    /**\n     * Should be a Lightweight mutator method. Always pass the stage before the UI content becomes visible for the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    void setStage(Stage stage);\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/editor/BuildingsEditorController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.editor;\n\nimport net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;", "import net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.mabel.button.SimpleTableEditor;\nimport net.dragondelve.mabel.fetcher.ConversionFetcher;\nimport net.dragondelve.mabel.fetcher.ConversionMaterialFetcher;\nimport net.dragondelve.mabel.fetcher.SimpleBuildingTemplateFetcher;\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.realm.template.VisualBuildingTemplate;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.ui.StageController;", "import net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.*;\nimport javafx.scene.control.cell.TextFieldTableCell;\nimport javafx.scene.layout.BorderPane;", "import javafx.scene.control.cell.TextFieldTableCell;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\nimport javafx.util.converter.IntegerStringConverter;\nimport javafx.util.converter.NumberStringConverter;\n\nimport java.util.Objects;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n", "import java.util.logging.Logger;\n\n/**\n * Controller class for the Buildings Editor. It is responsible for the creation and editing of VisualBuildingTemplates in the current ruleset.\n * Controls /fxml/editors/BuildingsEditor.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic final class BuildingsEditorController implements StageController {\n\n    @FXML\n    private SimpleTableEditor<VisualBuildingTemplate> buildingEditor;\n\n    @FXML\n    private TextField constructionCostField;\n\n    @FXML\n    private SimpleTableEditor<Material> inputMaterialEditor;\n\n    @FXML\n    private TextField constructionTimeField;\n\n    @FXML\n    private SimpleTableEditor<Material> outputMaterialEditor;\n\n    @FXML\n    private TextField nameTextField;\n\n    @FXML\n    private SimpleTableEditor<Material> constructionMaterialEditor;\n\n    @FXML\n    private ImageChooserButton pathToGFXButton;\n\n    @FXML\n    private TextField pathToGFXTextField;\n\n    @FXML\n    private Button okButton;\n\n    @FXML\n    private CheckBox operatesImmediatelyCheckBox;\n\n    @FXML\n    private BorderPane rootPane;\n\n    ObservableList<VisualBuildingTemplate> buildingTemplates = FXCollections.emptyObservableList();\n\n    ObservableList<Material> inputMaterials = FXCollections.emptyObservableList();\n\n    ObservableList<Material> outputMaterials = FXCollections.emptyObservableList();\n\n    ObservableList<Material> constructionMaterials = FXCollections.emptyObservableList();\n\n    Stage stage;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "    public void initialize() {\n        //init css\n        rootPane.getStylesheets().clear();\n        rootPane.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        //gets all available building instances from the current configuration\n        buildingTemplates = FXCollections.observableList(Configurator.getInstance().getRules().getBuildingTemplates());\n\n        //Configuring editor\n        buildingEditor.setItems(buildingTemplates);\n        buildingEditor.setFetcher(new SimpleBuildingTemplateFetcher());\n        buildingEditor.getTableView().getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {", "            if(oldValue != null)\n                unbindBuilding(oldValue);\n            displayBuilding(newValue);\n        });\n\n        //Configuring table columns\n        LogoTableColumn<VisualBuildingTemplate> buildingLogoColumn = new LogoTableColumn<>();\n        buildingLogoColumn.setDefaultSizePolicy();\n        buildingLogoColumn.setCellValueFactory(e-> e.getValue().pathToGFXProperty());\n\n        TableColumn<VisualBuildingTemplate, String> buildingNameColumn = new TableColumn<>(\"Building\");\n        buildingNameColumn.setCellValueFactory(e -> e.getValue().nameProperty());\n        buildingEditor.getTableView().getColumns().addAll(buildingLogoColumn, buildingNameColumn);\n\n        //configuring material editors\n        configureMaterialEditor(inputMaterialEditor, \"Material\", \"Amount\");\n        configureMaterialEditor(outputMaterialEditor, \"Material\", \"Amount\");\n        configureMaterialEditor(constructionMaterialEditor, \"Material\", \"Amount\");\n\n        //other inits\n        pathToGFXButton.setOutput(pathToGFXTextField);\n        okButton.setOnAction(e -> stage.close());\n    }\n\n    /**\n     * Lightweight mutator method.\n     * Always should be called before the editor is displayed to the user.\n     * @param stage the stage that is displaying the editor.\n     */\n    @Override", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Configures a SimpleTableEditor to have two columns. a Name column that will display the name of its template and an amount column that will display its amount.\n     * It makes the amount column editable using TextFieldTableCell and sets up a ConversionFetcher that will generate a new material based on\n     * @param editor Material editor to be configured.\n     * @param nameColumnTitle title text to be used for the name column\n     * @param amountColumnTitle title text to be used for the amount column\n     */\n    private void configureMaterialEditor(SimpleTableEditor<Material> editor, String nameColumnTitle, String amountColumnTitle) {\n        LogoTableColumn<Material> logoColumn = new LogoTableColumn<>();\n        logoColumn.setDefaultSizePolicy();\n        logoColumn.setCellValueFactory(e-> {\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).pathToGFXProperty();\n        });\n\n        TableColumn<Material, String> nameColumn = new TableColumn<>(nameColumnTitle);\n        nameColumn.setCellValueFactory(e ->{\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());\n            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n\n        TableColumn<Material, Integer> amountColumn = new TableColumn<>(amountColumnTitle);\n        amountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        amountColumn.setEditable(true);\n        amountColumn.setCellValueFactory(e -> e.getValue().amountProperty().asObject());\n\n        editor.getTableView().getColumns().addAll(logoColumn, nameColumn, amountColumn);\n\n        ConversionFetcher<Material, VisualMaterialTemplate> conversionFetcher = new ConversionMaterialFetcher();\n        //TODO: Investigate whether this conversion is a good idea;\n        conversionFetcher.initialize(stage, FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates()));\n        editor.setFetcher(conversionFetcher);\n    }\n\n    /**\n     * removes all bindings from a Building Template\n     * @param template template to be unbound from the textFields\n     */\n    private void unbindBuilding(VisualBuildingTemplate template) {\n        nameTextField.textProperty().unbindBidirectional(template.nameProperty());\n        pathToGFXTextField.textProperty().unbindBidirectional(template.pathToGFXProperty());\n        constructionCostField.textProperty().unbindBidirectional(template.defConstructionCostProperty());\n        constructionTimeField.textProperty().unbindBidirectional(template.defConstructionTimeProperty());\n        operatesImmediatelyCheckBox.selectedProperty().unbindBidirectional(template.operatesImmediatelyProperty());\n    }\n\n    /**\n     * binds all properties of the building to GUI TextFields and sets the data of all tables to correspond with the selected template.\n     * @param template template that was selected by the user to be displayed and edited.\n     */\n    private void displayBuilding(VisualBuildingTemplate template) {\n        nameTextField.textProperty().bindBidirectional(template.nameProperty());\n        pathToGFXTextField.textProperty().bindBidirectional(template.pathToGFXProperty());\n        constructionCostField.textProperty().bindBidirectional(template.defConstructionCostProperty(), new NumberStringConverter());\n        constructionTimeField.textProperty().bindBidirectional(template.defConstructionTimeProperty(), new NumberStringConverter());\n        operatesImmediatelyCheckBox.selectedProperty().bindBidirectional(template.operatesImmediatelyProperty());\n\n        inputMaterialEditor.setItems(template.getInputMaterials());\n        outputMaterialEditor.setItems(template.getOutputMaterials());\n        constructionMaterialEditor.setItems(template.getConstructionMaterials());\n    }\n}\n", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n\n        TableColumn<Material, Integer> amountColumn = new TableColumn<>(amountColumnTitle);\n        amountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        amountColumn.setEditable(true);\n        amountColumn.setCellValueFactory(e -> e.getValue().amountProperty().asObject());\n\n        editor.getTableView().getColumns().addAll(logoColumn, nameColumn, amountColumn);\n\n        ConversionFetcher<Material, VisualMaterialTemplate> conversionFetcher = new ConversionMaterialFetcher();\n        //TODO: Investigate whether this conversion is a good idea;\n        conversionFetcher.initialize(stage, FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates()));\n        editor.setFetcher(conversionFetcher);\n    }\n\n    /**\n     * removes all bindings from a Building Template\n     * @param template template to be unbound from the textFields\n     */\n    private void unbindBuilding(VisualBuildingTemplate template) {\n        nameTextField.textProperty().unbindBidirectional(template.nameProperty());\n        pathToGFXTextField.textProperty().unbindBidirectional(template.pathToGFXProperty());\n        constructionCostField.textProperty().unbindBidirectional(template.defConstructionCostProperty());\n        constructionTimeField.textProperty().unbindBidirectional(template.defConstructionTimeProperty());\n        operatesImmediatelyCheckBox.selectedProperty().unbindBidirectional(template.operatesImmediatelyProperty());\n    }\n\n    /**\n     * binds all properties of the building to GUI TextFields and sets the data of all tables to correspond with the selected template.\n     * @param template template that was selected by the user to be displayed and edited.\n     */\n    private void displayBuilding(VisualBuildingTemplate template) {\n        nameTextField.textProperty().bindBidirectional(template.nameProperty());\n        pathToGFXTextField.textProperty().bindBidirectional(template.pathToGFXProperty());\n        constructionCostField.textProperty().bindBidirectional(template.defConstructionCostProperty(), new NumberStringConverter());\n        constructionTimeField.textProperty().bindBidirectional(template.defConstructionTimeProperty(), new NumberStringConverter());\n        operatesImmediatelyCheckBox.selectedProperty().bindBidirectional(template.operatesImmediatelyProperty());\n\n        inputMaterialEditor.setItems(template.getInputMaterials());\n        outputMaterialEditor.setItems(template.getOutputMaterials());\n        constructionMaterialEditor.setItems(template.getConstructionMaterials());\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/editor/TagsEditorController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.editor;\n\nimport net.dragondelve.mabel.button.SimpleTableEditor;\nimport net.dragondelve.mabel.fetcher.SimpleTagFetcher;", "import net.dragondelve.mabel.button.SimpleTableEditor;\nimport net.dragondelve.mabel.fetcher.SimpleTagFetcher;\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.*;", "import javafx.fxml.FXML;\nimport javafx.scene.control.*;\nimport javafx.stage.Stage;\n\n/**\n *  Controller class for the Materials Editor. It is responsible for the creation and editing of VisualMaterialTemplates in the current ruleset.\n *  Controls /fxml/editors/MaterialsEditor.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic final class TagsEditorController implements StageController {\n    @FXML\n    CheckBox isFactionalCheckBox;\n\n    @FXML\n    Button okButton;\n\n    @FXML\n    TextField tagTextField;\n\n    @FXML\n    SimpleTableEditor<Tag> tagTableEditor;\n\n    @FXML\n    SplitPane rootPane;\n\n    ObservableList<Tag> tags = FXCollections.emptyObservableList();\n\n    Stage stage;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed.\n     */\n    @FXML", "public final class TagsEditorController implements StageController {\n    @FXML\n    CheckBox isFactionalCheckBox;\n\n    @FXML\n    Button okButton;\n\n    @FXML\n    TextField tagTextField;\n\n    @FXML\n    SimpleTableEditor<Tag> tagTableEditor;\n\n    @FXML\n    SplitPane rootPane;\n\n    ObservableList<Tag> tags = FXCollections.emptyObservableList();\n\n    Stage stage;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed.\n     */\n    @FXML", "    public void initialize() {\n        //init css\n        rootPane.getStylesheets().clear();\n        rootPane.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        //retrieving full list of tags in current rules.\n        tags = FXCollections.observableList(Configurator.getInstance().getRules().getActorTags());\n\n        //configuring Table Editor\n        tagTableEditor.setFetcher(new SimpleTagFetcher());\n\n        //Configuring Table View\n        tagTableEditor.getTableView().setItems(tags);\n        tagTableEditor.getTableView().setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n\n        //Configuring Columns\n        TableColumn<Tag, String> tagColumn = new TableColumn<>();\n        tagColumn.setText(\"Tag\");\n        tagColumn.setCellValueFactory(param -> param.getValue().tagProperty());\n\n        tagTableEditor.getTableView().getColumns().add(tagColumn);\n\n        //Listening for changes in selection made by the user in tag table view to update data displayed.\n        tagTableEditor.getTableView().getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {", "            if(oldValue != null)\n                unbindTag(oldValue);\n            displayTag(newValue);\n        });\n\n        //other inits\n        okButton.setOnAction(e-> this.stage.close());\n    }\n\n    /**\n     * Lightweight mutator method.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Binds the properties of a given tag to all TextFields and CheckBoxes.\n     * @param tag Tag to be unbound.\n     */\n    private void unbindTag(Tag tag) {\n        tagTextField.textProperty()             .unbindBidirectional(tag.tagProperty());\n        isFactionalCheckBox.selectedProperty()  .unbindBidirectional(tag.isFactionalProperty());\n    }\n\n    /**\n     * Unbinds the properties of a given tag from all TextFields and CheckBoxes.\n     * @param tag Tag to be displayed.\n     */\n    private void displayTag(Tag tag) {\n        tagTextField.textProperty()             .bindBidirectional(tag.tagProperty());\n        isFactionalCheckBox.selectedProperty()  .bindBidirectional(tag.isFactionalProperty());\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/editor/MaterialsEditorController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.editor;\n\nimport net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;", "import net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.mabel.button.SimpleTableEditor;\nimport net.dragondelve.mabel.fetcher.SimpleMaterialTemplateFetcher;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;", "import javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.*;\nimport javafx.scene.layout.AnchorPane;\nimport javafx.stage.Stage;\nimport javafx.util.converter.NumberStringConverter;\n\nimport java.io.File;\nimport java.util.logging.Level;", "import java.io.File;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n *  Controller class for the Materials Editor. It is responsible for the creation and editing of VisualMaterialTemplates in the current ruleset.\n *  Controls /fxml/editors/MaterialsEditor.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic final class MaterialsEditorController implements StageController {\n    @FXML\n    private TextField exportPriceTextField;\n\n    @FXML\n    private TextField importPriceTextField;\n\n    @FXML\n    private SimpleTableEditor<VisualMaterialTemplate> materialTemplateEditor;\n\n    @FXML\n    private CheckBox isExportableCheckBox;\n\n    @FXML\n    private AnchorPane leftAnchor;\n\n    @FXML\n    private TextField nameTextField;\n\n    @FXML\n    private Button okButton;\n\n    @FXML\n    private TextField pathToGFXTextField;\n\n    @FXML\n    private ImageChooserButton fileChooserButton;\n\n    @FXML\n    private SplitPane rootPane;\n\n    ObservableList<VisualMaterialTemplate> materials = FXCollections.emptyObservableList();\n\n    Stage stage;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "public final class MaterialsEditorController implements StageController {\n    @FXML\n    private TextField exportPriceTextField;\n\n    @FXML\n    private TextField importPriceTextField;\n\n    @FXML\n    private SimpleTableEditor<VisualMaterialTemplate> materialTemplateEditor;\n\n    @FXML\n    private CheckBox isExportableCheckBox;\n\n    @FXML\n    private AnchorPane leftAnchor;\n\n    @FXML\n    private TextField nameTextField;\n\n    @FXML\n    private Button okButton;\n\n    @FXML\n    private TextField pathToGFXTextField;\n\n    @FXML\n    private ImageChooserButton fileChooserButton;\n\n    @FXML\n    private SplitPane rootPane;\n\n    ObservableList<VisualMaterialTemplate> materials = FXCollections.emptyObservableList();\n\n    Stage stage;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "    public void initialize() {\n        //init css\n        rootPane.getStylesheets().clear();\n        rootPane.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        //retrieving the list of material templates in current rules.\n        materials = FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates());\n\n        //Configuring Template Editor\n        materialTemplateEditor.setFetcher(new SimpleMaterialTemplateFetcher());\n\n        //Configuring Table View\n        materialTemplateEditor.getTableView().setItems(materials);\n        materialTemplateEditor.getTableView().setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n\n        //Creating Table Columns for the editor to display\n        TableColumn<VisualMaterialTemplate, String> materialNameColumn = new TableColumn<>();\n        materialNameColumn.setText(\"Material\");\n        materialNameColumn.setCellValueFactory(param -> param.getValue().nameProperty());\n\n        LogoTableColumn<VisualMaterialTemplate> materialImageColumn = new LogoTableColumn<>();\n        materialImageColumn.setDefaultSizePolicy();\n        materialImageColumn.setCellValueFactory(param -> param.getValue().pathToGFXProperty());\n\n        materialTemplateEditor.getTableView().getColumns().addAll(materialImageColumn, materialNameColumn);\n\n        //listening for changes in selection made by the user in materials table view to update data displayed.\n        materialTemplateEditor.getTableView().getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {", "            if(oldValue != null) {\n                if (!validateMaterial(oldValue))\n                    Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"Material Editor Controller saving an invalid tag\");\n                else\n                    unbindMaterial(oldValue);\n            }\n\n            displayMaterial(newValue);\n        });\n\n        //other inits\n        disableTradable();\n\n        isExportableCheckBox.selectedProperty().addListener((observable, oldValue, newValue) -> {", "            if(newValue)\n                enableTradable();\n            else\n                disableTradable();\n        });\n\n        fileChooserButton.setOutput(pathToGFXTextField);\n        okButton.setOnAction(e-> stage.close());\n    }\n\n    /**\n     * Lightweight mutator method.\n     * Always should be called before the editor is displayed to the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Disables the exportPriceTextField as you should not set a price for non-tradeable materials.\n     */\n    private void disableTradable() {\n        exportPriceTextField.setDisable(true);\n    }\n\n    /**\n     * Enables the exportPriceTextField as you should be abel to set a price for tradeable materials.\n     */\n    private void enableTradable() {\n        exportPriceTextField.setDisable(false);\n    }\n\n    /**\n     * Unbinds the properties of a given materials from all TextFields and CheckBoxes.\n     * @param template template to be unbound.\n     */\n    private void unbindMaterial(VisualMaterialTemplate template) {\n        nameTextField.textProperty()            .unbindBidirectional(template.nameProperty());\n        isExportableCheckBox.selectedProperty() .unbindBidirectional(template.isExportableProperty());\n        pathToGFXTextField.textProperty()       .unbindBidirectional(template.pathToGFXProperty());\n        exportPriceTextField.textProperty()     .unbindBidirectional(template.defExportPriceProperty());\n        importPriceTextField.textProperty()     .unbindBidirectional(template.defImportPriceProperty());\n    }\n\n    /**\n     * Binds the properties of a given material to all TextFields and CheckBoxes.\n     * @param materialTemplate template to be displayed\n     */\n    private void displayMaterial(VisualMaterialTemplate materialTemplate) {\n        nameTextField.textProperty()            .bindBidirectional(materialTemplate.nameProperty());\n        isExportableCheckBox.selectedProperty() .bindBidirectional(materialTemplate.isExportableProperty());\n        pathToGFXTextField.textProperty()       .bindBidirectional(materialTemplate.pathToGFXProperty());\n        exportPriceTextField.textProperty()     .bindBidirectional(materialTemplate.defExportPriceProperty(), new NumberStringConverter());\n        importPriceTextField.textProperty()     .bindBidirectional(materialTemplate.defImportPriceProperty(), new NumberStringConverter());\n    }\n\n    /**\n     * Checks that it can read a file that is set as a pathToGFX.\n     * @param materialTemplate VisualMaterialTemplate to be validated.\n     * @return true if file can be read. False if it cannot be read.\n     */\n    private boolean validateMaterial(VisualMaterialTemplate materialTemplate) {\n        File checkFile = new File(pathToGFXTextField.getText());", "        if(checkFile.canRead()) {\n            return true;\n        } else {\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"Could not Find file: \"+pathToGFXTextField.getText()+\" when trying to check integrity during material template save.\");\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setHeaderText(\"Could not find file: \"+pathToGFXTextField.getText());\n            alert.setContentText(pathToGFXTextField.getText()+\" must be a path to a valid readable file\");\n            alert.showAndWait();\n            return false;\n        }\n    }\n\n    /**\n     * Removes the old Material Templates from the current Ruleset, adds all materialTemplates in materials field, and then force saves the rules at a lastLoadedRules location.\n     */\n    @Deprecated\n    private void saveChanges() {\n        Configurator.getInstance().getRules().getMaterialTemplates().clear();\n        Configurator.getInstance().getRules().getMaterialTemplates().addAll(materials);\n        Configurator.getInstance().saveRules();\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/editor/RealmEditorController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.editor;\n\nimport net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;", "import net.dragondelve.mabel.button.ImageChooserButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.mabel.button.SimpleTableEditor;\nimport net.dragondelve.mabel.fetcher.*;\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.realm.Realm;\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.collections.FXCollections;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TableColumn;\nimport javafx.scene.control.TextField;\nimport javafx.scene.control.cell.TextFieldTableCell;\nimport javafx.scene.layout.BorderPane;", "import javafx.scene.control.cell.TextFieldTableCell;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\nimport javafx.util.converter.IntegerStringConverter;\nimport javafx.util.converter.NumberStringConverter;\n\nimport java.util.Objects;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n", "import java.util.logging.Logger;\n\n/**\n * Controller class for the Realm Editor. It is responsible for the creation of new Realms.\n * Controls /fxml/editors/RealmEditor.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic class RealmEditorController implements StageController {\n    @FXML\n    private Button cancelButton;\n\n    @FXML\n    private Button createButton;\n\n    @FXML\n    private TextField diploRepTextField;\n\n    @FXML\n    private TextField infamyTextField;\n\n    @FXML\n    private TextField legitimacyTextField;\n\n    @FXML\n    private TextField powerProjectionTextField;\n\n    @FXML\n    private TextField prestigeTextField;\n\n    @FXML\n    private ImageChooserButton realmGFXButton;\n\n    @FXML\n    private TextField realmGFXTextField;\n\n    @FXML\n    private TextField realmNameTextField;\n\n    @FXML\n    private BorderPane rootPane;\n\n    @FXML\n    private ImageChooserButton rulerGFXButton;\n\n    @FXML\n    private TextField rulerGFXTextField;\n\n    @FXML\n    private TextField treasuryTextField;\n\n    @FXML\n    private TextField stabilityTextField;\n\n    @FXML\n    private SimpleTableEditor<Tag> tagEditor;\n\n    @FXML\n    private SimpleTableEditor<Material> stockpileEditor;\n\n    private static final String STOCKPILE_NAME_COLUMN_NAME = \"Stockpile\";\n    private static final String STOCKPILE_AMOUNT_COLUMN_NAME = \"Amount\";\n\n    Stage stage = new Stage();\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "    public void initialize() {\n\n        //init css\n        rootPane.getStylesheets().clear();\n        rootPane.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        Realm realm = new Realm();\n\n        //bind textFields\n        realmNameTextField.textProperty()       .bindBidirectional(realm.nameProperty());\n        treasuryTextField.textProperty()        .bindBidirectional(realm.treasuryProperty(),                new NumberStringConverter());\n        diploRepTextField.textProperty()        .bindBidirectional(realm.diplomaticReputationProperty(),    new NumberStringConverter());\n        powerProjectionTextField.textProperty() .bindBidirectional(realm.powerProjectionProperty(),         new NumberStringConverter());\n        legitimacyTextField.textProperty()      .bindBidirectional(realm.legitimacyProperty(),              new NumberStringConverter());\n        prestigeTextField.textProperty()        .bindBidirectional(realm.prestigeProperty(),                new NumberStringConverter());\n        infamyTextField.textProperty()          .bindBidirectional(realm.infamyProperty(),                  new NumberStringConverter());\n        stabilityTextField.textProperty()       .bindBidirectional(realm.stabilityProperty(),               new NumberStringConverter());\n        realmGFXTextField.textProperty()        .bindBidirectional(realm.realmPathToGFXProperty());\n        rulerGFXTextField.textProperty()        .bindBidirectional(realm.rulerPathToGFXProperty());\n\n        //init Tag Editor\n        TableColumn<Tag, String> tagColumn = new TableColumn<>(\"Tag\");\n        tagColumn.setCellValueFactory(e->e.getValue().tagProperty());\n\n        VisualFetcher<Tag> visualTagFetcher = new VisualTagFetcher();\n        visualTagFetcher.initialize(stage, FXCollections.observableList(Configurator.getInstance().getRules().getActorTags()));\n        tagEditor.setFetcher(visualTagFetcher);\n        tagEditor.setItems(realm.getTags());\n        tagEditor.getTableView().getColumns().add(tagColumn);\n\n        //Init file chooser buttons\n        realmGFXButton.setOutput(realmGFXTextField);\n        rulerGFXButton.setOutput(rulerGFXTextField);\n\n        //init other buttons.\n        cancelButton.setOnAction(e-> stage.close());\n        createButton.setOnAction(e-> {\n            Configurator.getInstance().setUserRealm(realm);\n            stage.close();\n        });\n\n        //init stockpile editor\n        LogoTableColumn<Material> stockpileLogoColumn = new LogoTableColumn<>();\n        stockpileLogoColumn.setDefaultSizePolicy();\n        stockpileLogoColumn.setCellValueFactory(e-> {\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).pathToGFXProperty();\n        });\n\n        TableColumn<Material, String> stockpileNameColumn = new TableColumn<>(STOCKPILE_NAME_COLUMN_NAME);\n        stockpileNameColumn.setCellValueFactory(e ->{\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());\n            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n        TableColumn<Material, Integer> stockpileAmountColumn = new TableColumn<>(STOCKPILE_AMOUNT_COLUMN_NAME);\n        stockpileAmountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        stockpileAmountColumn.setCellValueFactory(e-> e.getValue().amountProperty().asObject());\n        stockpileAmountColumn.setEditable(true);\n\n        ConversionFetcher<Material, VisualMaterialTemplate> visualMaterialFetcher = new ConversionMaterialFetcher();\n        visualMaterialFetcher.initialize(stage, FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates()));\n        stockpileEditor.setFetcher(visualMaterialFetcher);\n        stockpileEditor.setItems(realm.getStockpile());\n        stockpileEditor.getTableView().getColumns().addAll(stockpileLogoColumn, stockpileNameColumn, stockpileAmountColumn);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * Always should be called before the editor is displayed to the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n        TableColumn<Material, Integer> stockpileAmountColumn = new TableColumn<>(STOCKPILE_AMOUNT_COLUMN_NAME);\n        stockpileAmountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        stockpileAmountColumn.setCellValueFactory(e-> e.getValue().amountProperty().asObject());\n        stockpileAmountColumn.setEditable(true);\n\n        ConversionFetcher<Material, VisualMaterialTemplate> visualMaterialFetcher = new ConversionMaterialFetcher();\n        visualMaterialFetcher.initialize(stage, FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates()));\n        stockpileEditor.setFetcher(visualMaterialFetcher);\n        stockpileEditor.setItems(realm.getStockpile());\n        stockpileEditor.getTableView().getColumns().addAll(stockpileLogoColumn, stockpileNameColumn, stockpileAmountColumn);\n    }\n\n    /**\n     * Lightweight mutator method.\n     * Always should be called before the editor is displayed to the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/main/DownfallMainController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.main;\n\nimport net.dragondelve.mabel.button.ExitButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;", "import net.dragondelve.mabel.button.ExitButton;\nimport net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.mabel.button.MaximizeButton;\nimport net.dragondelve.mabel.button.MinimizeButton;\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.realm.*;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.ui.StageController;\nimport net.dragondelve.downfall.ui.editor.BuildingsEditorController;\nimport net.dragondelve.downfall.ui.editor.MaterialsEditorController;", "import net.dragondelve.downfall.ui.editor.BuildingsEditorController;\nimport net.dragondelve.downfall.ui.editor.MaterialsEditorController;\nimport net.dragondelve.downfall.ui.editor.RealmEditorController;\nimport net.dragondelve.downfall.ui.editor.TagsEditorController;\nimport net.dragondelve.downfall.ui.main.tabs.RealmScreenController;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Node;", "import javafx.fxml.FXMLLoader;\nimport javafx.scene.Node;\nimport javafx.scene.Scene;\nimport javafx.scene.control.*;\nimport javafx.scene.control.cell.TextFieldTableCell;\nimport javafx.scene.layout.AnchorPane;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.FileChooser;\nimport javafx.stage.Stage;\nimport javafx.util.converter.IntegerStringConverter;", "import javafx.stage.Stage;\nimport javafx.util.converter.IntegerStringConverter;\nimport javafx.util.converter.NumberStringConverter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Objects;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;", "import java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Controller for the main GUI of Downfall EAM.\n * Controls /fxml/main/DownfallMain.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic class DownfallMainController implements StageController {\n    @FXML\n    private MenuItem buildingsEditItem;\n\n    @FXML\n    private MenuItem materialsEditItem;\n\n    @FXML\n    private MenuItem tagsEditItem;\n\n    @FXML\n    private MenuItem importRulesItem;\n\n    @FXML\n    private MenuItem newRealm;\n\n    @FXML\n    private MenuItem loadRealm;\n\n    @FXML\n    private MenuItem saveRealm;\n\n    @FXML\n    private MenuItem saveRealmTo;\n\n    @FXML\n    private MenuItem configureItem;\n\n    @FXML\n    private MenuItem exportRulesItem;\n\n    @FXML\n    private AnchorPane realmAnchorPane;\n\n    @FXML\n    private BorderPane rootPane;\n\n    @FXML\n    private MinimizeButton minimizeButton;\n\n    @FXML\n    private MaximizeButton maximizeButton;\n\n    @FXML\n    private ExitButton exitButton;\n\n    @FXML\n    private MenuBar menuBar;\n\n    @FXML\n    private Label treasuryLabel;\n\n    @FXML\n    private TableView<Material> stockpileTableView;\n\n    private Stage stage;\n\n    private Double xOffset;\n\n    private Double yOffset;\n\n    final RealmScreenController realmScreenController = new RealmScreenController();\n\n    private static final String STOCKPILE_NAME_COLUMN_NAME = \"Stockpile\";\n    private static final String STOCKPILE_AMOUNT_COLUMN_NAME = \"#\";\n    private static final Integer STOCKPILE_AMOUNT_COLUMN_WIDTH = 50;\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "    public void initialize() {\n        materialsEditItem.setOnAction(e -> openEditor(DownfallUtil.getInstance().getURLMaterialsEditorFXML(), new MaterialsEditorController(), \"Materials Editor\"));\n        buildingsEditItem.setOnAction(e -> openEditor(DownfallUtil.getInstance().getURLBuildingsEditorFXML(), new BuildingsEditorController(), \"Buildings Editor\"));\n        tagsEditItem     .setOnAction(e -> openEditor(DownfallUtil.getInstance().getURLTagsEditorFXML(),      new TagsEditorController(),      \"Tags Editor\"));\n\n        newRealm.setOnAction(e -> {\n            openEditor(DownfallUtil.getInstance().getURLRealmEditorFXML(), new RealmEditorController(), \"New Realm\");\n            update();\n        });\n\n        importRulesItem.setOnAction(e -> importRules());\n        exportRulesItem.setOnAction(e -> exportRules());\n        loadRealm.setOnAction(e -> loadRealmAction());\n        saveRealm.setOnAction(e -> saveRealmAction());\n        saveRealmTo.setOnAction(e -> saveRealmToAction());\n\n        rootPane.getStylesheets().clear();\n        rootPane.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        minimizeButton.setStage(stage);\n        maximizeButton.setStage(stage);\n        exitButton.setStage(stage);\n\n        menuBar.setOnMousePressed(e->{\n            xOffset = stage.getX() - e.getScreenX();\n            yOffset = stage.getY() - e.getScreenY();\n        });\n\n        menuBar.setOnMouseDragged(e-> {", "            if (!stage.isMaximized()) {\n                stage.setX(e.getScreenX() + xOffset);\n                stage.setY(e.getScreenY() + yOffset);\n            }\n        });\n\n        //intialize Stockpile TableView\n        LogoTableColumn<Material> stockpileLogoColumn = new LogoTableColumn<>();\n        stockpileLogoColumn.setDefaultSizePolicy();\n        stockpileLogoColumn.setCellValueFactory(e-> {\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).pathToGFXProperty();\n        });\n\n        TableColumn<Material, String> stockpileNameColumn = new TableColumn<>(STOCKPILE_NAME_COLUMN_NAME);\n        stockpileNameColumn.setCellValueFactory(e ->{\n            VisualMaterialTemplate template = Configurator.getInstance().findMaterialTemplate(e.getValue());\n            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n        TableColumn<Material, Integer> stockpileAmountColumn = new TableColumn<>(STOCKPILE_AMOUNT_COLUMN_NAME);\n        stockpileAmountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        stockpileAmountColumn.setCellValueFactory(e -> e.getValue().amountProperty().asObject());\n        stockpileAmountColumn.setEditable(true);\n        stockpileAmountColumn.setPrefWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH);\n        stockpileAmountColumn.setMinWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH*1.5);\n        stockpileAmountColumn.setMaxWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH*2);\n\n        stockpileTableView.getColumns().addAll(stockpileLogoColumn, stockpileNameColumn, stockpileAmountColumn);\n        stockpileTableView.setItems(Configurator.getInstance().getUserRealm().getStockpile());\n\n        initializeTabs();\n\n        update();\n    }\n\n    /**\n     * Lightweight Mutator Method.\n     * Always should be called before the stage is displayed to the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "            if(template == null)\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"VisualMaterialTemplate expected from Configuration returned null\");\n            return Objects.requireNonNull(template).nameProperty();\n        });\n\n        TableColumn<Material, Integer> stockpileAmountColumn = new TableColumn<>(STOCKPILE_AMOUNT_COLUMN_NAME);\n        stockpileAmountColumn.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));\n        stockpileAmountColumn.setCellValueFactory(e -> e.getValue().amountProperty().asObject());\n        stockpileAmountColumn.setEditable(true);\n        stockpileAmountColumn.setPrefWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH);\n        stockpileAmountColumn.setMinWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH*1.5);\n        stockpileAmountColumn.setMaxWidth(STOCKPILE_AMOUNT_COLUMN_WIDTH*2);\n\n        stockpileTableView.getColumns().addAll(stockpileLogoColumn, stockpileNameColumn, stockpileAmountColumn);\n        stockpileTableView.setItems(Configurator.getInstance().getUserRealm().getStockpile());\n\n        initializeTabs();\n\n        update();\n    }\n\n    /**\n     * Lightweight Mutator Method.\n     * Always should be called before the stage is displayed to the user.\n     * @param stage Stage on which this controller is displayed.\n     */\n    @Override", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Creates a stage on which an editor controlled by a StageController can be displayed.\n     * Loads an FXML File from the URL, sets the controller and finally displays the stage.\n     * @param editorFXMLURL URL to a FXML file that contains the editor's gui information.\n     * @param controller controller to be used for the new Stage.\n     * @param title text title to be displayed on the new Stage.\n     */\n    private void openEditor(URL editorFXMLURL, StageController controller, String title) {\n        Stage stage = new Stage();", "        try {\n            FXMLLoader loader = new FXMLLoader(editorFXMLURL);\n            loader.setController(controller);\n            controller.setStage(stage);\n            Scene scene = new Scene(loader.load());\n            stage.setScene(scene);\n            stage.initOwner(this.stage);\n            stage.setTitle(title);\n            stage.showAndWait();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Exports current ruleset to an XML File at a destination selected by a user with a JavaFX FileChooser.\n     * Saves the new destination as lastLoadedRules in the Configuration.\n     */\n    private void exportRules() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Export Rules\");\n        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"xml rules file\",\"*.xml\"));\n        fileChooser.setInitialDirectory(new File(\"rules\"));\n        File selectedFile = fileChooser.showSaveDialog(stage);", "        if(selectedFile != null)\n            Configurator.getInstance().saveRules(selectedFile.getPath());\n    }\n\n    /**\n     * Imports and applies a ruleset from an XML File at a destination selected by a user with a JavaFX FileChooser.\n     * Saves the new destination as lastLoadedRules in the Configuration\n     */\n    private void importRules() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Import Rules\");\n        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"xml rules file\",\"*.xml\"));\n        fileChooser.setInitialDirectory(new File(\"rules\"));\n        File selectedFile = fileChooser.showOpenDialog(stage);", "        if(selectedFile != null)\n            Configurator.getInstance().loadAndApplyRules(selectedFile.getPath());\n    }\n\n    /**\n     * loads the content of RealmScreen.fxml and puts its root node into the \"Realm\" tab.\n     */\n    private void initializeRealmTab() {\n        try {\n            FXMLLoader loader = new FXMLLoader(DownfallUtil.getInstance().getURLRealmScreenFXML());\n            loader.setController(realmScreenController);\n            Node screen = loader.load();\n            realmAnchorPane.getChildren().add(screen);\n            AnchorPane.setBottomAnchor(screen, 0.0);\n            AnchorPane.setLeftAnchor(screen, 0.0);\n            AnchorPane.setRightAnchor(screen, 0.0);\n            AnchorPane.setTopAnchor(screen, 0.0);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Initializes all Tabs with their respective content.\n     */\n    private void initializeTabs() {\n        initializeRealmTab();\n    }\n\n    /**\n     * Executes general update sequence for all scene elements.\n     */\n    private void update() {\n        treasuryLabel.textProperty().bindBidirectional(Configurator.getInstance().getUserRealm().treasuryProperty(), new NumberStringConverter());\n\n        updateTabs();\n    }\n\n    /**\n     * Forces an update on all tabs.\n     */\n    private void updateTabs() {\n        updateRealmTab();\n    }\n\n    /**\n     * Forces an upgrade on Realm Tab\n     */\n    private void updateRealmTab() {\n        realmScreenController.update();\n    }\n\n    /**\n     * Loads test realm\n     */\n    private void loadRealmAction() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Choose Savegame\");\n        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"xml save file\",\"*.xml\"));\n        fileChooser.setInitialDirectory(new File(\"save\"));\n        File selectedFile = fileChooser.showOpenDialog(stage);", "        try {\n            FXMLLoader loader = new FXMLLoader(DownfallUtil.getInstance().getURLRealmScreenFXML());\n            loader.setController(realmScreenController);\n            Node screen = loader.load();\n            realmAnchorPane.getChildren().add(screen);\n            AnchorPane.setBottomAnchor(screen, 0.0);\n            AnchorPane.setLeftAnchor(screen, 0.0);\n            AnchorPane.setRightAnchor(screen, 0.0);\n            AnchorPane.setTopAnchor(screen, 0.0);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Initializes all Tabs with their respective content.\n     */\n    private void initializeTabs() {\n        initializeRealmTab();\n    }\n\n    /**\n     * Executes general update sequence for all scene elements.\n     */\n    private void update() {\n        treasuryLabel.textProperty().bindBidirectional(Configurator.getInstance().getUserRealm().treasuryProperty(), new NumberStringConverter());\n\n        updateTabs();\n    }\n\n    /**\n     * Forces an update on all tabs.\n     */\n    private void updateTabs() {\n        updateRealmTab();\n    }\n\n    /**\n     * Forces an upgrade on Realm Tab\n     */\n    private void updateRealmTab() {\n        realmScreenController.update();\n    }\n\n    /**\n     * Loads test realm\n     */\n    private void loadRealmAction() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Choose Savegame\");\n        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"xml save file\",\"*.xml\"));\n        fileChooser.setInitialDirectory(new File(\"save\"));\n        File selectedFile = fileChooser.showOpenDialog(stage);", "        if(selectedFile != null) {\n            Configurator.getInstance().getSaveManager().loadFrom(selectedFile.getPath());\n            updateTabs();\n        }\n    }\n\n    /**\n     * Saves test realm\n     */\n    private void saveRealmAction() {\n        Configurator.getInstance().getSaveManager().saveToLast();\n    }\n\n    /**\n     * Saves test realm to filepath\n     */\n    private void saveRealmToAction() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Choose Savegame\");\n        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"xml save file\",\"*.xml\"));\n        fileChooser.setInitialDirectory(new File(\"save\"));\n        File selectedFile = fileChooser.showSaveDialog(stage);", "        if(selectedFile != null)\n            Configurator.getInstance().getSaveManager().saveTo(selectedFile.getPath());\n    }\n }\n"]}
{"filename": "src/main/java/net/dragondelve/downfall/ui/main/tabs/RealmScreenController.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.downfall.ui.main.tabs;\n\nimport net.dragondelve.downfall.realm.Realm;\nimport net.dragondelve.downfall.realm.Tag;", "import net.dragondelve.downfall.realm.Realm;\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.beans.property.SimpleObjectProperty;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Accordion;\nimport javafx.scene.control.Label;", "import javafx.scene.control.Accordion;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.ListView;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.layout.*;\n\n/**\n * A controller that controls the content of the Realm Tab.\n * It displays user's realm Data allowing the user to see a quick overview of the state of their realm.", " * A controller that controls the content of the Realm Tab.\n * It displays user's realm Data allowing the user to see a quick overview of the state of their realm.\n * Controls /fxml/main/tabs/RealmScreenController.fxml and is annotated with @FXML where it references that FXML file.\n */\npublic class RealmScreenController {\n    @FXML\n    private Label diploRepLabel;\n\n    @FXML\n    private ImageView dynastyImageView;\n\n    @FXML\n    private Label govRankLabel;\n\n    @FXML\n    private Label infamyLabel;\n\n    @FXML\n    private Label legitimacyLabel;\n\n    @FXML\n    private Label nationalUnrestLabel;\n\n    @FXML\n    private Label nuicpLabel;\n\n    @FXML\n    private Label powerProjectionLabel;\n\n    @FXML\n    private Label prestigeLabel;\n\n    @FXML\n    private ImageView realmImageView;\n\n    @FXML\n    private GridPane stabilityNegativeGrid;\n\n    @FXML\n    private Label stabilityPerMonthLabel;\n\n    @FXML\n    private GridPane stabilityPositiveGrid;\n\n    @FXML\n    private VBox rootPane;\n\n    @FXML\n    private Label stabilityLabel;\n\n    @FXML\n    private Label realmNameLabel;\n\n    @FXML\n    private Pane stabilityCirclePane;\n\n    @FXML\n    private ListView<Tag> realmTagListView;\n\n    @FXML\n    private ListView<Tag> nonRealmTagListView;\n\n    @FXML\n    private Accordion tagsAccordion;\n\n    @FXML\n    private Pane realmPane;\n\n    @FXML\n    private Pane dynastyPane;\n\n    @FXML\n    private Pane negStabilityPane1;\n\n    @FXML\n    private Pane negStabilityPane2;\n\n    @FXML\n    private Pane negStabilityPane3;\n\n    @FXML\n    private Pane negStabilityPane4;\n\n    @FXML\n    private Pane negStabilityPane5;\n    \n    @FXML\n    private Pane posStabilityPane1;\n\n    @FXML\n    private Pane posStabilityPane2;\n\n    @FXML\n    private Pane posStabilityPane3;\n\n    @FXML\n    private Pane posStabilityPane4;\n\n    @FXML\n    private Pane posStabilityPane5;\n\n    private final static Double IMAGE_PANE_GAP = 10.0;\n    private final static Double IMAGE_PANE_HEIGHT = 200.0;\n\n    private final ObservableList<Tag> realmTags = FXCollections.observableArrayList();\n    private final ObservableList<Tag> nonRealmTags = FXCollections.observableArrayList();\n\n    /**\n     * Initialize method that is called automatically after the FXML has finished loading. Initializes all UI elements before they are displayed\n     */\n    @FXML", "    public void initialize() {\n        realmTagListView.setItems(realmTags);\n        nonRealmTagListView.setItems(nonRealmTags);\n        tagsAccordion.setExpandedPane(tagsAccordion.getPanes().get(0));\n\n        //Update ImageView Positions.\n        realmImageView.setX(10);\n        realmImageView.setY(10);\n        dynastyImageView.setX(10);\n        dynastyImageView.setY(10);\n\n        update();\n    }\n\n    /**\n     * Updates values on all labels if there was an action or an event that could have changed them.\n     * Also updates ImageViews and the tag table.\n     */", "    public void update() {\n        //update user realm\n        Realm userRealm = Configurator.getInstance().getUserRealm();\n\n        //update Labels\n        realmNameLabel          .setText(userRealm.getName());\n        diploRepLabel           .setText(userRealm.getDiplomaticReputation().toString());\n        stabilityLabel          .setText(userRealm.getStability().toString());\n        legitimacyLabel         .setText(userRealm.getLegitimacy().toString());\n        powerProjectionLabel    .setText(userRealm.getPowerProjection().toString());\n        infamyLabel             .setText(userRealm.getInfamy().toString());\n        prestigeLabel           .setText(userRealm.getPrestige().toString());\n        //TODO: Add Gouvernment Rank\n        //govRankLabel.setText(userRealm.getGouvernmentRank());\n\n        //update Image views\n        updateImageView(realmPane, new Image(\"file:\"+userRealm.getRealmPathToGFX()), realmImageView);\n        updateImageView(dynastyPane, new Image(\"file:\"+userRealm.getRulerPathToGFX()), dynastyImageView);\n\n        //update Stability Bar\n        updateStabilityBar();\n\n        //update realm tags\n        realmTags.clear();\n        nonRealmTags.clear();\n        userRealm.getTags().forEach(e->{", "            if(e.isFactional())\n                realmTags.add(e);\n            else\n                nonRealmTags.add(e);\n        });\n    }\n\n    /**\n     * Updates the given ImageView to contain the given Image, if image provided is not null, forces the width of the container to conform to the ImageView's Image width\n     * modified so that the image keeps its aspect ratio, plus some gaps that are defined in IMAGE_PANE_GAP. If the image equals to null it forces the ImageView\n     * to conform to IMAGE_PANE_HEIGHT in both Width and Height.\n     * @param container Container Pane that contains the ImageView. It will be resized to have a height of IMAGE_PANE_HEIGHT. It's width will depend on the aspect ratio of the Image provided.\n     * @param image Image to be set into the ImageView. It's aspect ratio is used to define container's width.\n     * @param imageView Image view to be set with a given image. It's best if ImageView's parent is the container argument, but it's not required.\n     */\n    private void updateImageView(Pane container, Image image, ImageView imageView) {\n        imageView.setImage(image);", "        if(image != null && !image.isError()) {\n            double ratio = imageView.getFitHeight()/image.getHeight();\n            forceDimensions(container, IMAGE_PANE_HEIGHT, realmImageView.getImage().getWidth() * ratio + IMAGE_PANE_GAP * 2);\n        } else\n            forceDimensions(container, IMAGE_PANE_HEIGHT, IMAGE_PANE_HEIGHT);\n    }\n\n    /**\n     * Forces the dimension of the pane to conform to the parameters specified.\n     * @param pane Pane whose width and height you want to fix to particular values.\n     * @param height Height to which you want to set the pane's height.\n     * @param width Width to which you want to set the pane's width.\n     */\n    private void forceDimensions(Pane pane, Double height, Double width) {\n        pane.setMinWidth(width);\n        pane.setMaxWidth(width);\n        pane.setPrefWidth(width);\n\n        pane.setMinHeight(height);\n        pane.setPrefHeight(height);\n        pane.setMaxHeight(height);\n    }\n\n    /**\n     * Updates the Stability bar to display the current stability in a visual way.\n     */\n    private void updateStabilityBar() {\n        //update user realm\n        BackgroundFill negFill = new BackgroundFill(DownfallUtil.HIGHLIGHT_COLOR, null, null);\n        BackgroundFill posFill = new BackgroundFill(DownfallUtil.CONFIRM_COLOR, null, null);\n        BackgroundFill neutralFill = new BackgroundFill(DownfallUtil.BACKGROUND_COLOR, null, null);\n\n        updateStabilityPane(negStabilityPane5, neutralFill, negFill, -5.0, true);\n        updateStabilityPane(negStabilityPane4, neutralFill, negFill, -4.0, true);\n        updateStabilityPane(negStabilityPane3, neutralFill, negFill, -3.0, true);\n        updateStabilityPane(negStabilityPane2, neutralFill, negFill, -2.0, true);\n        updateStabilityPane(negStabilityPane1, neutralFill, negFill, -1.0, true);\n\n        updateStabilityPane(posStabilityPane1, neutralFill, posFill, 1.0, false);\n        updateStabilityPane(posStabilityPane2, neutralFill, posFill, 2.0, false);\n        updateStabilityPane(posStabilityPane3, neutralFill, posFill, 3.0, false);\n        updateStabilityPane(posStabilityPane4, neutralFill, posFill, 4.0, false);\n        updateStabilityPane(posStabilityPane5, neutralFill, posFill, 5.0, false);\n    }\n\n    /**\n     *  Binds the background property to a new Background that is created with one of the two fills depending on whether the Stability of the realm \"exceeds\" the threshold given.\n     *  \"exceeds\" for the purposes of this method means less than or equal to threshold if lessThanThreshold is true and greater or equal to the threshold if it is false.\n     * @param stabilityPane Pane whose background needs to be updated.\n     * @param neutralFill BackgroundFill to be used if the userRealm's stability does not \"exceed\" the threshold.\n     * @param activeFill BackgroundFill to be used if the userRealm's stability \"exceeds\" the threshold.\n     * @param threshold Value of the threshold that needs to be \"exceeded\" in order for the active fill to be used instead of neutralFill.\n     * @param lessThanThreshold Controls if the threshold is \"exceeded\" when the UserRealm's stability is less than or equal to, or greater than or equal to the threshold provided.\n     */\n    private void updateStabilityPane( Pane stabilityPane, BackgroundFill neutralFill, BackgroundFill activeFill, Double threshold,Boolean lessThanThreshold) {\n        //TODO:Find a more refined way of doing this.", "        if (lessThanThreshold) {\n            if (Configurator.getInstance().getUserRealm().getStability() <= threshold)\n                stabilityPane.backgroundProperty().bind(new SimpleObjectProperty<>(new Background(activeFill)));\n            else\n                stabilityPane.backgroundProperty().bind(new SimpleObjectProperty<>(new Background(neutralFill)));\n        } else {\n            if (Configurator.getInstance().getUserRealm().getStability() >= threshold)\n                stabilityPane.backgroundProperty().bind(new SimpleObjectProperty<>(new Background(activeFill)));\n            else\n                stabilityPane.backgroundProperty().bind(new SimpleObjectProperty<>(new Background(neutralFill)));\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/ExitButton.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.downfall.util.DownfallUtil;\n", "import net.dragondelve.downfall.util.DownfallUtil;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Button that closes the stage that is provided to it, on action.\n */\npublic class ExitButton extends StageControlButton {\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will close that stage.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e-> {", "public class ExitButton extends StageControlButton {\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will close that stage.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e-> {\n            if(stage != null) {\n                stage.close();\n            } else {\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"ExitButton attempted to maximize a stage that was equal to null.\");\n            }\n        });\n    }\n}\n", "            if(stage != null) {\n                stage.close();\n            } else {\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"ExitButton attempted to maximize a stage that was equal to null.\");\n            }\n        });\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/LogoTableColumn.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.beans.property.DoubleProperty;", "import net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.beans.property.DoubleProperty;\nimport javafx.beans.property.SimpleDoubleProperty;\nimport javafx.scene.control.TableCell;\nimport javafx.scene.control.TableColumn;\nimport javafx.scene.image.ImageView;\n\n/**\n * a JavaFX TableColumn that displays an image for each row that corresponds to pathname of this cell's String value\n * @param <S> Class of an object that is displayed in the TableView", " * a JavaFX TableColumn that displays an image for each row that corresponds to pathname of this cell's String value\n * @param <S> Class of an object that is displayed in the TableView\n */\npublic class LogoTableColumn<S> extends TableColumn<S, String> {\n    public static final double DEFAULT_IMAGE_HEIGHT = 24;\n    public static final double DEFAULT_IMAGE_WIDTH = 24;\n    public static final double DEFAULT_COLUMN_WIDTH = 42;\n\n    private final DoubleProperty imageHeightProperty = new SimpleDoubleProperty(DEFAULT_IMAGE_HEIGHT);\n    private final DoubleProperty imageWidthProperty = new SimpleDoubleProperty(DEFAULT_IMAGE_WIDTH);\n\n    /**\n     * Lightweight accessor method\n     * @return image height property\n     */\n    DoubleProperty ImageHeightProperty() {\n        return imageHeightProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return image width property\n     */\n    DoubleProperty ImageWidthProperty() {\n        return imageWidthProperty;\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return numeric value of imageHeightProperty\n     */", "    public Double getImageHeight() {\n        return imageHeightProperty.get();\n    }\n\n    /**\n     * Lightweight accessor method\n     * @return numeric value of imageWidthProperty\n     */\n    public Double getImageWidth() {\n        return imageWidthProperty.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param height desired height of the image inside the column\n     */", "    public Double getImageWidth() {\n        return imageWidthProperty.get();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param height desired height of the image inside the column\n     */\n    public void setImageHeight(Double height) {\n        imageHeightProperty.setValue(height);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param width desired width of the image inside the column\n     */", "    public void setImageHeight(Double height) {\n        imageHeightProperty.setValue(height);\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param width desired width of the image inside the column\n     */\n    public void setImageWidth(Double width) {\n        imageWidthProperty.setValue(width);\n    }\n\n    /**\n     * Default constructor. does not initialize the column title.\n     */\n    public LogoTableColumn() {\n        super();\n        initializeCells();\n    }\n\n    /**\n     * Constructor that initializes the column title\n     * @param name title text of the column.\n     */\n    public LogoTableColumn(String name) {\n        super(name);\n        initializeCells();\n    }\n\n    /**\n     * Sets default resize policy for the column. It is recommended to call this method before the column is displayed.\n     */", "    public void setImageWidth(Double width) {\n        imageWidthProperty.setValue(width);\n    }\n\n    /**\n     * Default constructor. does not initialize the column title.\n     */\n    public LogoTableColumn() {\n        super();\n        initializeCells();\n    }\n\n    /**\n     * Constructor that initializes the column title\n     * @param name title text of the column.\n     */\n    public LogoTableColumn(String name) {\n        super(name);\n        initializeCells();\n    }\n\n    /**\n     * Sets default resize policy for the column. It is recommended to call this method before the column is displayed.\n     */", "    public void setDefaultSizePolicy() {\n        this.minWidthProperty().setValue(DEFAULT_COLUMN_WIDTH);\n        this.prefWidthProperty().setValue(DEFAULT_COLUMN_WIDTH);\n        this.maxWidthProperty().setValue(DEFAULT_COLUMN_WIDTH);\n    }\n\n    /**\n     * Initializes the cell factory for this column to display an image that is loaded from pathname of the String value of the column\n     */\n    private void initializeCells() {\n        setCellFactory(param -> {\n            ImageView view = new ImageView();\n            view.fitHeightProperty().bind(imageHeightProperty);\n            view.fitWidthProperty().bind(imageWidthProperty);\n            TableCell<S, String> cell = new TableCell<>() {", "                public void updateItem(String item, boolean empty) {\n                    if (item != null) {\n                        view.setImage(DownfallUtil.getInstance().loadImage(item));\n                    } else\n                        view.setImage(null);\n                }\n            };\n            cell.setGraphic(view);\n            return cell;\n        });\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/MinimizeButton.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.downfall.util.DownfallUtil;\n", "import net.dragondelve.downfall.util.DownfallUtil;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Button that iconifies (minimizes) the stage that is provided to it on action.\n */\npublic class MinimizeButton extends StageControlButton{\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will iconify (minimize) the stage.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e -> {", "public class MinimizeButton extends StageControlButton{\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will iconify (minimize) the stage.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e -> {\n        if(stage != null)\n            stage.setIconified(true);\n        else\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"MinimizeButton attempted to minimize a stage that was equal to null.\");\n        });\n    }\n}\n", "        if(stage != null)\n            stage.setIconified(true);\n        else\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"MinimizeButton attempted to minimize a stage that was equal to null.\");\n        });\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/MaximizeButton.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.downfall.util.DownfallUtil;\n", "import net.dragondelve.downfall.util.DownfallUtil;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Button that maximizes the stage that is provided to it on action if it isn't maximized already.\n * If the stage provided is already maximized it unmaximizes it.\n */\npublic class MaximizeButton extends StageControlButton{\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will maximize that stage if it isn't maximized.\n     * If the stage provided to it is already maximized it will unmaximize it.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e-> {", " */\npublic class MaximizeButton extends StageControlButton{\n\n    /**\n     * Initializes the behaviour of the button.\n     * onAction if the stage provided to it is not null it will maximize that stage if it isn't maximized.\n     * If the stage provided to it is already maximized it will unmaximize it.\n     */\n    @Override\n    protected void initBehaviour() {\n        this.setOnAction(e-> {", "            if(stage != null)\n                stage.setMaximized(!stage.isMaximized());\n            else {\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"MaximizeButton attempted to maximize a stage that was equal to null.\");\n            }\n        });\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/ImageChooserButton.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport net.dragondelve.downfall.util.PathRelativisor;", "import net.dragondelve.downfall.util.DownfallUtil;\nimport net.dragondelve.downfall.util.PathRelativisor;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TextInputControl;\nimport javafx.stage.FileChooser;\n\nimport java.io.File;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n", "import java.util.logging.Logger;\n\n/**\n * JavaFX Button that creates a FileChooser on action. the FileChooser is pre-configured to filter for images. Its initial directory is the gfx folder in the installation directory\n */\npublic class ImageChooserButton extends Button {\n    TextInputControl output;\n\n    /**\n     *  Default constructor. If you use the default constructor you must set output before the button can be triggered by the user.\n     */\n    public ImageChooserButton() {\n        this(null);\n    }\n\n    /**\n     * If you use this constructor the text title of the button will be set the default value of to \"...\"\n     * @param output a TextInputControl into which pathname to the chosen image will be written\n     */\n    public ImageChooserButton(TextInputControl output) {\n        super();\n        textProperty().set(\"...\");\n        this.output = output;\n        initBehaviour();\n    }\n\n    /**\n     *\n     * @param output a TextInputControl into which pathname to the chosen image will be written\n     * @param title text that is going to be displayed on the button.\n     */\n    public ImageChooserButton(TextInputControl output,String title) {\n        super(title);\n        this.output = output;\n        initBehaviour();\n    }\n\n    /**\n     * Lightweight mutator method\n     * @param output a TextInputControl into which pathname to the chosen image will be written\n     */", "    public void setOutput(TextInputControl output) {\n        this.output = output;\n    }\n\n    /**\n     * Initializes the default behaviour of the button.\n     */\n    private void initBehaviour() {\n        setOnAction(e->{\n            FileChooser chooser = new FileChooser();\n            chooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(\"image\",\"*.png\"));\n            chooser.setInitialDirectory(new File(\"gfx\"));\n            chooser.setTitle(\"Choose Your Image Wisely\");\n            File fileChosen = chooser.showOpenDialog(this.getScene().getWindow());", "            if(output != null)\n                if(fileChosen != null) {\n                    PathRelativisor relativisor = new PathRelativisor(fileChosen);\n                    output.setText(relativisor.relativize());\n                }\n                else\n                    Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.INFO, \"ImageChooserButton: No File Chosen, content of output was not changed.\");\n            else\n                Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.SEVERE, \"Attempting to set Text without setting an output first.\");\n        });\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/SimpleTableEditor.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport net.dragondelve.mabel.fetcher.Fetcher;\nimport javafx.collections.ObservableList;", "import net.dragondelve.mabel.fetcher.Fetcher;\nimport javafx.collections.ObservableList;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TableColumn;\nimport javafx.scene.control.TableView;\nimport javafx.scene.control.ToolBar;\nimport javafx.scene.layout.Priority;\nimport javafx.scene.layout.VBox;\n\n/**", "\n/**\n *  JavaFX GUI element that contains a table, content of which can be edited with add and remove actions.\n * @param <T> Type of item that is edited in the SimpleTableEditor.\n */\npublic class SimpleTableEditor<T> extends VBox {\n    final TableView<T> tableView = new TableView<>();\n    final ToolBar toolBar = new ToolBar();\n    final Button addButton = new Button(\"Add\");\n    final Button removeButton = new Button(\"Remove\");\n    Fetcher<T> fetcher;\n\n    /**\n     * Default constructor sets items and fetcher and columns to null.\n     */\n    public SimpleTableEditor() {\n        this(null, null);\n    }\n\n    /**\n     * Constructor that sets columns to null\n     * @param items Items to be displayed by the TableView.\n     * @param fetcher A fetcher that will be used when adding new items to the list. This fetcher should be initialized before providing it to the SimpleTableEditor.\n     */\n    SimpleTableEditor(ObservableList<T> items, Fetcher<T> fetcher) {\n        this(items, fetcher, null);\n    }\n\n    /**\n     *\n     * @param items items to be displayed by the TableView\n     * @param fetcher A fetcher that will be used when adding new items to the list. This fetcher should be initialized before providing it to the SimpleTableEditor.\n     * @param columns columns that will be added to the TableView\n     */\n    SimpleTableEditor(ObservableList<T> items, Fetcher<T> fetcher, TableColumn<T, ?>... columns) {\n        //Add Error Checking;\n        this.fetcher = fetcher;\n\n        tableView.setEditable(true);\n\n        VBox.setVgrow(tableView, Priority.ALWAYS);\n\n        toolBar.getItems().addAll(addButton, removeButton);\n        getChildren().addAll(toolBar, tableView);\n        tableView.setItems(items);\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n\n        addButton.setOnAction(event -> tableView.getItems().add(this.fetcher.retrieve()));\n\n        removeButton.setOnAction(event -> {", "            if(tableView.getSelectionModel().getSelectedItem() != null)\n                tableView.getItems().removeAll(tableView.getSelectionModel().getSelectedItems());\n        });\n\n        if(columns != null && columns.length != 0)\n            tableView.getColumns().addAll(columns);\n    }\n\n    /**\n     * Lightweight accessor.\n     * @return tableView that is used inside\n     */\n    public TableView<T> getTableView() {\n        return tableView;\n    }\n\n    /**\n     * Lightweight mutator. Sets items directly into the TableView\n     * @param items items to be set to the TableView.\n     */", "    public void setItems(ObservableList<T> items) {\n        tableView.setItems(items);\n    }\n\n    /**\n     * Lightweight mutator.\n     * @param fetcher fetcher whose retrieve method will be used to generate new items when adding them to the TableView\n     */\n    public void setFetcher(Fetcher<T> fetcher) {\n        this.fetcher = fetcher;\n    }\n}\n", "    public void setFetcher(Fetcher<T> fetcher) {\n        this.fetcher = fetcher;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/button/StageControlButton.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.button;\n\nimport javafx.scene.control.Button;\nimport javafx.stage.Stage;", "import javafx.scene.control.Button;\nimport javafx.stage.Stage;\n\n/**\n * A type of button that controls a JavaFX Stage state.\n * IE: closes it, minimizes it, maximizes it, etc.\n */\npublic class StageControlButton extends Button {\n    protected Stage stage;\n\n    /**\n     * Default constructor. Stage is set to null and button Text is set to \"\".\n     * You should set the controlled stage later if using this constructor with setStage.\n     */\n    public StageControlButton() {\n        this(\"\");\n    }\n\n    /**\n     * Stage is set to null. You should set the controlled stage later if using this constructor with setStage.\n     * @param text text that is displayed on the button.\n     */\n    public StageControlButton(String text) {\n        this(text, null);\n    }\n\n    /**\n     *\n     * @param text text that is displayed on the button.\n     * @param stage the JavaFX stage that will be controlled by this button.\n     */\n    public StageControlButton(String text, Stage stage) {\n        super(text);\n        this.stage = stage;\n        initBehaviour();\n    }\n\n    /**\n     * Semi-Lightweight Mutator Method.\n     * @param stage the JavaFX stage that will be controlled by this button.\n     */", "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Overridden in subclasses to init the setOnAction to a particular action\n     */\n    protected void initBehaviour() {\n\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/VisualTagFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.util.Configurator;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.scene.Scene;\nimport javafx.scene.control.TableColumn;\nimport javafx.stage.Stage;\n\nimport java.util.Objects;\n", "import java.util.Objects;\n\n/**\n * Implementation of a VisualFetcher that returns a Tag selected in the Table\n * it uses TableView to display items provided to it in its initialize method. It does not support multiple selections being made.\n */\npublic class VisualTagFetcher extends TableFetcherBase<Tag> implements VisualFetcher<Tag> {\n\n    /**\n     * Default Constructor\n     */\n    public VisualTagFetcher() {\n        TableColumn<Tag, String> tagColumn = new TableColumn<>();\n        tagColumn.setCellValueFactory(e-> e.getValue().tagProperty());\n\n        tableView.getColumns().add(tagColumn);\n    }\n\n    /**\n     * Creates a new stage that will be owned by the parent Stage. sets the provided list of items to the Table View.  It should always be run before its retrieve method.\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the VisualTagFetcher\n     * @param items a list of items to be displayed by the VisualTagFetcher\n     */\n    @Override", "    public void initialize(Stage parent, ObservableList<Tag> items) {\n        stage = new Stage();\n        if(parent != null)\n            stage.initOwner(parent);\n\n        Scene scene = new Scene(this);\n        stage.setScene(scene);\n        tableView.setItems(Objects.requireNonNullElseGet(items, () -> FXCollections.observableList(Configurator.getInstance().getRules().getActorTags())));\n    }\n\n    /**\n     * This method will show a new stage with showAndWait(). after a selection is made by the user this function will return a Tag selected.\n     * @return a tag selected from a TableView if a selection is made in the table, if there is no selection made returns null instead.\n     */\n    @Override", "    public Tag retrieve() {\n        stage.showAndWait();\n\n        if(selectionIsMade)\n            return tableView.getSelectionModel().getSelectedItem();\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/SimpleTagFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.realm.Tag;\nimport net.dragondelve.downfall.util.Configurator;\n\n/**\n * Simple implementation of Fetcher class that returns a new instance of Tag on request\n */\npublic final class SimpleTagFetcher implements Fetcher<Tag> {\n\n    /**\n     * This method is used to return a new instance of Tag on request.\n     * @return a new instance of Tag with its id set to be one larger than the last Tag in the currently selected rules\n     */\n    @Override", "    public Tag retrieve() {\n        Tag tag = new Tag();\n        //TODO:Replace this mess with a proper solution distributing IDs.\n        //if there are any Tags in the current rules\n        if(Configurator.getInstance().getRules().getActorTags().size() > 1)\n            //set the new instance's id to be equal of the last item in that list incremented by one\n            tag.setId(Configurator.getInstance().getRules().getMaterialTemplates().get(Configurator.getInstance().getRules().getMaterialTemplates().size()-1).getId()+1);\n        else\n            tag.setId(1);\n        tag.setTag(\"New Tag\");\n        return tag;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/SimpleBuildingTemplateFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport net.dragondelve.downfall.realm.template.VisualBuildingTemplate;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.realm.template.VisualBuildingTemplate;\nimport net.dragondelve.downfall.util.Configurator;\n\n/**\n * Simple implementation of Fetcher class that returns a new instance of VisualBuildingTemplate on request\n */\npublic final class SimpleBuildingTemplateFetcher implements Fetcher<VisualBuildingTemplate> {\n    /**\n     * This method is used to return a new instance of VisualBuildingTemplate on request.\n     * @return A new instance of VisualBuildingTemplate with its id set to be one larger than the last VisualBuildingTemplate in the currently selected rules\n     */\n    @Override", "    public VisualBuildingTemplate retrieve() {\n        VisualBuildingTemplate template = new VisualBuildingTemplate();\n        //TODO:Replace this mess with a proper solution distributing IDs.\n        if(Configurator.getInstance().getRules().getBuildingTemplates().size() > 1)\n            template.setId(Configurator.getInstance().getRules().getBuildingTemplates().get(Configurator.getInstance().getRules().getBuildingTemplates().size()-1).getId()+1);\n        else\n            template.setId(1);\n        template.setName(\"New Building\");\n        template.setDefConstructionCost(30);\n        template.setDefConstructionTime(3);\n        return template;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/Fetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\n/**\n * A simple interface for any class that returns an instance of T on request", "/**\n * A simple interface for any class that returns an instance of T on request\n * @param <T> class of an instance to be returned by the retrieve method\n */\npublic interface Fetcher<T> {\n    /**\n     * This method is used to return an instance of T on request. It is not necessarily lightweight, don't use it as a get method.\n     * @return an instance of T that can be selected from a pre generated list or newly created\n     */\n    T retrieve();\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/VisualFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport javafx.collections.ObservableList;\nimport javafx.stage.Stage;", "import javafx.collections.ObservableList;\nimport javafx.stage.Stage;\n\n/**\n * An interface for a visual fetcher that uses JavaFX to display a selection of instances of T before returning an instance of T on request\n * @param <T> class of an instance to be returned by the retrieve method\n */\npublic interface VisualFetcher<T> extends Fetcher<T>{\n    /**\n     * A method that initializes the visual elements of the VisualFetcher. It should always be run before its retrieve method\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the VisualFetcher\n     * @param items a list of items to be displayed by the VisualFetcher\n     */\n    void initialize(Stage parent, ObservableList<T> items);\n\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/SimpleMaterialTemplateFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.util.Configurator;", "import net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.util.Configurator;\n\n/**\n * Simple implementation of Fetcher class that returns a new instance of VisualMaterialTemplate on request\n */\npublic final class SimpleMaterialTemplateFetcher implements Fetcher<VisualMaterialTemplate>{\n    /**\n     * This method is used to return a new instance of VisualMaterialTemplate on request.\n     * @return a new instance of VisualMaterialTemplate with its id set to be one larger than the last VisualMaterialTemplate in the currently selected rules\n     */\n    @Override", "    public VisualMaterialTemplate retrieve() {\n        VisualMaterialTemplate template = new VisualMaterialTemplate();\n        //TODO:Replace this mess with a proper solution distributing IDs.\n        //if there are any MaterialTemplates in the current rules\n        if(Configurator.getInstance().getRules().getMaterialTemplates().size() > 1)\n            //set the new instance's id to be equal of the last item in that list incremented by one\n            template.setId(Configurator.getInstance().getRules().getMaterialTemplates().get(Configurator.getInstance().getRules().getMaterialTemplates().size()-1).getId()+1);\n        else\n            template.setId(1);\n        template.setName(\"New Template\");\n        return template;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/ConversionMaterialFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.downfall.realm.Material;", "import net.dragondelve.mabel.button.LogoTableColumn;\nimport net.dragondelve.downfall.realm.Material;\nimport net.dragondelve.downfall.realm.template.VisualMaterialTemplate;\nimport net.dragondelve.downfall.util.Configurator;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.scene.Scene;\nimport javafx.scene.control.TableColumn;\nimport javafx.stage.Stage;", "import javafx.scene.control.TableColumn;\nimport javafx.stage.Stage;\n\nimport java.util.Objects;\n\n/**\n * Implementation of a ConversionFetcher that generates a new instance Material based on a user selected VisualMaterialTemplate\n * it uses TableView to display items provided to it in its initialize method. It does not support multiple selections being made\n */\npublic class ConversionMaterialFetcher extends TableFetcherBase<VisualMaterialTemplate> implements ConversionFetcher<Material, VisualMaterialTemplate>{\n\n    /**\n     * Constructs all the visual elements of the ConversionMaterialFetcher\n     */\n    public ConversionMaterialFetcher() {\n        LogoTableColumn<VisualMaterialTemplate> logoColumn = new LogoTableColumn<>();\n        logoColumn.setDefaultSizePolicy();\n        logoColumn.setCellValueFactory(e-> e.getValue().pathToGFXProperty());\n\n        TableColumn<VisualMaterialTemplate, String> nameColumn = new TableColumn<>();\n        nameColumn.setCellValueFactory(e-> e.getValue().nameProperty());\n\n        tableView.getColumns().addAll(logoColumn, nameColumn);\n    }\n\n    /**\n     * Creates a new stage that will be owned by the parent Stage. sets the provided list of items to the Table View.  It should always be run before its retrieve method.\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the ConversionMaterialFetcher if a null is provided it will not set any owners for the stage.\n     * @param items a list of items to be displayed in the TableView if a null is provided it will load a list in the current ruleset\n     */\n    @Override", " */\npublic class ConversionMaterialFetcher extends TableFetcherBase<VisualMaterialTemplate> implements ConversionFetcher<Material, VisualMaterialTemplate>{\n\n    /**\n     * Constructs all the visual elements of the ConversionMaterialFetcher\n     */\n    public ConversionMaterialFetcher() {\n        LogoTableColumn<VisualMaterialTemplate> logoColumn = new LogoTableColumn<>();\n        logoColumn.setDefaultSizePolicy();\n        logoColumn.setCellValueFactory(e-> e.getValue().pathToGFXProperty());\n\n        TableColumn<VisualMaterialTemplate, String> nameColumn = new TableColumn<>();\n        nameColumn.setCellValueFactory(e-> e.getValue().nameProperty());\n\n        tableView.getColumns().addAll(logoColumn, nameColumn);\n    }\n\n    /**\n     * Creates a new stage that will be owned by the parent Stage. sets the provided list of items to the Table View.  It should always be run before its retrieve method.\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the ConversionMaterialFetcher if a null is provided it will not set any owners for the stage.\n     * @param items a list of items to be displayed in the TableView if a null is provided it will load a list in the current ruleset\n     */\n    @Override", "    public void initialize(Stage parent, ObservableList<VisualMaterialTemplate> items) {\n        stage = new Stage();\n        if(parent != null)\n            stage.initOwner(parent);\n\n        Scene scene = new Scene(this);\n        stage.setScene(scene);\n        tableView.setItems(Objects.requireNonNullElseGet(items, () -> FXCollections.observableList(Configurator.getInstance().getRules().getMaterialTemplates())));\n    }\n\n    /**\n     * This method will show a new stage with showAndWait(). after a selection is made by the user this function will return a new Material\n     * @return a new instance of Material created from a VisualMaterialTemplate if a selection is made in the table, if it wasn't made returns null instead.\n     */\n    @Override", "    public Material retrieve() {\n        stage.showAndWait();\n        if(selectionIsMade)\n            return new Material(tableView.getSelectionModel().getSelectedItem(), DownfallUtil.DEFAULT_MATERIAL_AMOUNT);\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/TableFetcherBase.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport downfall.fx.css.DarkerHBox;\nimport net.dragondelve.downfall.util.DownfallUtil;", "import downfall.fx.css.DarkerHBox;\nimport net.dragondelve.downfall.util.DownfallUtil;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TableView;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.Priority;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;", "import javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\n/**\n * Base for all Fetchers that feature some kind of a table from which a selection is made.\n * @param <T> Type that is going to be used as items for the fetcher.\n */\nabstract class TableFetcherBase<T> extends VBox {\n    protected final TableView<T> tableView = new TableView<>();\n    protected Boolean selectionIsMade = false;", "    protected final TableView<T> tableView = new TableView<>();\n    protected Boolean selectionIsMade = false;\n    protected Stage stage;\n\n    /**\n     * Default Constructor.\n     */\n    public TableFetcherBase() {\n        //init css\n        this.getStylesheets().clear();", "        //init css\n        this.getStylesheets().clear();\n        this.getStylesheets().add(DownfallUtil.MAIN_CSS_RESOURCE);\n\n        //sets the alignment of  the buttons at the bottom of the scene\n        Button okButton = new Button(\"Ok\");\n        Button cancelButton = new Button(\"Cancel\");\n        HBox buttonHBox = new DarkerHBox();\n        buttonHBox.getChildren().addAll(okButton, cancelButton);\n        buttonHBox.setPadding(new Insets(10));", "        buttonHBox.getChildren().addAll(okButton, cancelButton);\n        buttonHBox.setPadding(new Insets(10));\n        buttonHBox.setSpacing(10.0);\n        buttonHBox.setAlignment(Pos.CENTER_RIGHT);\n\n        tableView.setMaxHeight(Double.MAX_VALUE);\n        getChildren().addAll(tableView, buttonHBox);\n        VBox.setVgrow(tableView, Priority.ALWAYS);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);", "\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n\n        okButton.setOnAction(e -> {\n            if(tableView.getSelectionModel().getSelectedItem() != null)\n                selectionIsMade = true;\n            stage.close();\n        });\n\n        cancelButton.setOnAction(e -> stage.close());\n    }\n}\n"]}
{"filename": "src/main/java/net/dragondelve/mabel/fetcher/ConversionFetcher.java", "chunked_list": ["// Copyright 2023 Prokhor Kalinin\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,", "// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage net.dragondelve.mabel.fetcher;\n\nimport javafx.collections.ObservableList;\nimport javafx.stage.Stage;", "import javafx.collections.ObservableList;\nimport javafx.stage.Stage;\n\n/**\n * An interface for a visual fetcher that uses JavaFX to display a selection of instances of C before returning an instance of T on request.\n * @param <T> an instance of this class will be returned by the retrieve method.\n * @param <C> a list of this class will be displayed to the user\n */\npublic interface ConversionFetcher<T, C> extends Fetcher<T> {\n    /**\n     * A method that initializes the visual elements of the VisualFetcher. It should always be run before its retrieve method\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the VisualFetcher\n     * @param items a list of items to be displayed by the VisualFetcher\n     */\n    void initialize(Stage parent, ObservableList<C> items);\n}\n", "public interface ConversionFetcher<T, C> extends Fetcher<T> {\n    /**\n     * A method that initializes the visual elements of the VisualFetcher. It should always be run before its retrieve method\n     * @param parent a parent stage that will be set as an owner of the stage displayed by the VisualFetcher\n     * @param items a list of items to be displayed by the VisualFetcher\n     */\n    void initialize(Stage parent, ObservableList<C> items);\n}\n"]}
