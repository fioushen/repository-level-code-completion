{"filename": "src/main/java/ho/artisan/lib/recipe/RIP.java", "chunked_list": ["package ho.artisan.lib.recipe;\n\nimport net.fabricmc.api.ModInitializer;\n\npublic class RIP implements ModInitializer {\n    @Override\n    public void onInitialize() {\n    }\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/BaseRecipeHandler.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api;\n", "package ho.artisan.lib.recipe.api;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport org.jetbrains.annotations.ApiStatus;\nimport org.jetbrains.annotations.Nullable;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;", "import net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\n/**\n * Represents common recipe handler methods.\n */\n@ApiStatus.NonExtendable\npublic interface BaseRecipeHandler {\n\t/**\n\t * Returns the recipe type of the specified recipe.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return the recipe type if the recipe is present, else {@code null}\n\t */\n\t@Nullable RecipeType<?> getTypeOf(Identifier id);\n\n\t/**\n\t * Returns whether the {@link net.minecraft.recipe.RecipeManager} contains the specified recipe.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return {@code true} if the recipe is present in the {@link net.minecraft.recipe.RecipeManager}, else {@code false}\n\t */\n\tboolean contains(Identifier id);\n\n\t/**\n\t * Returns whether the {@link net.minecraft.recipe.RecipeManager} contains the specified recipe of the specified recipe type.\n\t *\n\t * @param id   the identifier of the recipe\n\t * @param type the type of the recipe\n\t * @return {@code true} if the recipe is present in the {@link net.minecraft.recipe.RecipeManager}, else {@code false}\n\t */\n\tboolean contains(Identifier id, RecipeType<?> type);\n\n\t/**\n\t * Returns the recipe in {@link net.minecraft.recipe.RecipeManager} from its identifier.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return the recipe if present, else {@code null}\n\t */\n\t@Nullable Recipe<?> getRecipe(Identifier id);\n\n\t/**\n\t * Returns the recipe of the specified recipe type in {@link net.minecraft.recipe.RecipeManager} from its identifier.\n\t *\n\t * @param id   the identifier of the recipe\n\t * @param type the type of the recipe\n\t * @param <T>  the type of the recipe\n\t * @return the recipe if present and of the correct type, else {@code null}\n\t */\n\t@Nullable <T extends Recipe<?>> T getRecipe(Identifier id, RecipeType<T> type);\n\n\t/**\n\t * Returns all registered recipes.\n\t *\n\t * @return a view of the registered recipes\n\t */\n\tMap<RecipeType<?>, Map<Identifier, Recipe<?>>> getRecipes();\n\n\t/**\n\t * Returns all registered recipes of the specified type.\n\t *\n\t * @param type the recipe type\n\t * @param <T>  the type of the recipe\n\t * @return a view of all the registered recipes of the specified type\n\t */\n\t<T extends Recipe<?>> Collection<T> getRecipesOfType(RecipeType<T> type);\n}\n", "public interface BaseRecipeHandler {\n\t/**\n\t * Returns the recipe type of the specified recipe.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return the recipe type if the recipe is present, else {@code null}\n\t */\n\t@Nullable RecipeType<?> getTypeOf(Identifier id);\n\n\t/**\n\t * Returns whether the {@link net.minecraft.recipe.RecipeManager} contains the specified recipe.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return {@code true} if the recipe is present in the {@link net.minecraft.recipe.RecipeManager}, else {@code false}\n\t */\n\tboolean contains(Identifier id);\n\n\t/**\n\t * Returns whether the {@link net.minecraft.recipe.RecipeManager} contains the specified recipe of the specified recipe type.\n\t *\n\t * @param id   the identifier of the recipe\n\t * @param type the type of the recipe\n\t * @return {@code true} if the recipe is present in the {@link net.minecraft.recipe.RecipeManager}, else {@code false}\n\t */\n\tboolean contains(Identifier id, RecipeType<?> type);\n\n\t/**\n\t * Returns the recipe in {@link net.minecraft.recipe.RecipeManager} from its identifier.\n\t *\n\t * @param id the identifier of the recipe\n\t * @return the recipe if present, else {@code null}\n\t */\n\t@Nullable Recipe<?> getRecipe(Identifier id);\n\n\t/**\n\t * Returns the recipe of the specified recipe type in {@link net.minecraft.recipe.RecipeManager} from its identifier.\n\t *\n\t * @param id   the identifier of the recipe\n\t * @param type the type of the recipe\n\t * @param <T>  the type of the recipe\n\t * @return the recipe if present and of the correct type, else {@code null}\n\t */\n\t@Nullable <T extends Recipe<?>> T getRecipe(Identifier id, RecipeType<T> type);\n\n\t/**\n\t * Returns all registered recipes.\n\t *\n\t * @return a view of the registered recipes\n\t */\n\tMap<RecipeType<?>, Map<Identifier, Recipe<?>>> getRecipes();\n\n\t/**\n\t * Returns all registered recipes of the specified type.\n\t *\n\t * @param type the recipe type\n\t * @param <T>  the type of the recipe\n\t * @return a view of all the registered recipes of the specified type\n\t */\n\t<T extends Recipe<?>> Collection<T> getRecipesOfType(RecipeType<T> type);\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/RecipeManagerHelper.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api;\n", "package ho.artisan.lib.recipe.api;\n\nimport net.minecraft.recipe.Recipe;\n\nimport ho.artisan.lib.recipe.impl.RecipeManagerImpl;\n\n/**\n * Represents a helper for the {@link net.minecraft.recipe.RecipeManager}.\n */\npublic final class RecipeManagerHelper {\n\tprivate RecipeManagerHelper() {\n\t\tthrow new UnsupportedOperationException(\"RecipeManagerHelper only contains static definitions.\");\n\t}\n\n\t/**\n\t * Registers a static recipe.\n\t * <p>\n\t * A static recipe is a recipe that is registered at mod startup (or later) and is kept during the whole lifecycle\n\t * of the game.\n\t * <p>\n\t * Static recipes are automatically added to the {@linkplain net.minecraft.recipe.RecipeManager recipe manager}\n\t * when recipes are loaded, and only is added if no other recipe with the same identifier is already loaded.\n\t * <p>\n\t * Static recipes can be added at any time, but are only applied after a data pack reload.\n\t *\n\t * @param recipe the recipe to register\n\t * @return the registered recipe\n\t * @throws IllegalStateException if another recipe with the same identifier is already registered\n\t */", " */\npublic final class RecipeManagerHelper {\n\tprivate RecipeManagerHelper() {\n\t\tthrow new UnsupportedOperationException(\"RecipeManagerHelper only contains static definitions.\");\n\t}\n\n\t/**\n\t * Registers a static recipe.\n\t * <p>\n\t * A static recipe is a recipe that is registered at mod startup (or later) and is kept during the whole lifecycle\n\t * of the game.\n\t * <p>\n\t * Static recipes are automatically added to the {@linkplain net.minecraft.recipe.RecipeManager recipe manager}\n\t * when recipes are loaded, and only is added if no other recipe with the same identifier is already loaded.\n\t * <p>\n\t * Static recipes can be added at any time, but are only applied after a data pack reload.\n\t *\n\t * @param recipe the recipe to register\n\t * @return the registered recipe\n\t * @throws IllegalStateException if another recipe with the same identifier is already registered\n\t */", "\tpublic static Recipe<?> registerStaticRecipe(Recipe<?> recipe) {\n\t\tRecipeManagerImpl.registerStaticRecipe(recipe);\n\t\treturn recipe;\n\t}\n\n\t/**\n\t * Registers a dynamic recipe provider.\n\t * <p>\n\t * The dynamic recipe provider is called when the recipes are loaded.\n\t * <p>\n\t * Triggered before {@link #modifyRecipes(RecipeLoadingEvents.ModifyRecipesCallback)}\n\t * and {@link #removeRecipes(RecipeLoadingEvents.RemoveRecipesCallback)}.\n\t *\n\t * @param callback the callback to add recipes\n\t * @see RecipeLoadingEvents#ADD\n\t */", "\tpublic static void addRecipes(RecipeLoadingEvents.AddRecipesCallback callback) {\n\t\tRecipeLoadingEvents.ADD.register(callback);\n\t}\n\n\t/**\n\t * Modifies recipes in the {@link net.minecraft.recipe.RecipeManager} when it is being built.\n\t * <p>\n\t * Triggered after {@link #addRecipes(RecipeLoadingEvents.AddRecipesCallback)}\n\t * and before {@link #removeRecipes(RecipeLoadingEvents.RemoveRecipesCallback)}.\n\t *\n\t * @param callback the callback to modify recipes\n\t * @see RecipeLoadingEvents#MODIFY\n\t */", "\tpublic static void modifyRecipes(RecipeLoadingEvents.ModifyRecipesCallback callback) {\n\t\tRecipeLoadingEvents.MODIFY.register(callback);\n\t}\n\n\t/**\n\t * Removes recipes in the {@link net.minecraft.recipe.RecipeManager} when it is being built.\n\t * <p>\n\t * Triggered after {@link #addRecipes(RecipeLoadingEvents.AddRecipesCallback)}\n\t * and {@link #modifyRecipes(RecipeLoadingEvents.ModifyRecipesCallback)}.\n\t *\n\t * @param callback the callback to remove recipes\n\t * @see RecipeLoadingEvents#REMOVE\n\t */", "\tpublic static void removeRecipes(RecipeLoadingEvents.RemoveRecipesCallback callback) {\n\t\tRecipeLoadingEvents.REMOVE.register(callback);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/package-info.java", "chunked_list": ["/**\n * <h2>The Recipe API.</h2>\n * <p>\n * <h3>Quick note about vocabulary in the Recipe API:</h3>\n * <ul>\n *     <li>A static recipe is a recipe which is registered with the API once and is automatically added to\n *     the {@linkplain net.minecraft.recipe.RecipeManager recipe manager} when recipes are loaded.</li>\n *     <li>A dynamic recipe is a recipe which is registered when recipes are loaded.</li>\n * </ul>\n * <p>", " * </ul>\n * <p>\n * <h3>{@link ho.artisan.lib.recipe.api.RecipeManagerHelper RecipeManagerHelper}</h3>\n * The {@link ho.artisan.lib.recipe.api.RecipeManagerHelper RecipeManagerHelper} is a helper class focused\n * on the {@link net.minecraft.recipe.RecipeManager}, it allows you to register static and dynamic recipes,\n * it also allows you to modify, replace, and remove recipes.\n * <p>\n * <h3>{@link ho.artisan.lib.recipe.api.RecipeLoadingEvents RecipeLoadingEvents}</h3>\n * Contains some events to register, modify, and remove recipes.\n * <p>", " * Contains some events to register, modify, and remove recipes.\n * <p>\n * <h3>When to use the Recipe API?</h3>\n * This API targets specific use-cases:\n * <ul>\n *     <li>Dynamic recipe registration, in the case the recipes cannot be determined at compile-time.</li>\n *     <li>Modification and removal of recipes.</li>\n * </ul>\n * This API is <b>NOT</b> supposed to be used for known at compile-time data-generation, please use the appropriate tools instead.\n */", " * This API is <b>NOT</b> supposed to be used for known at compile-time data-generation, please use the appropriate tools instead.\n */\n\npackage ho.artisan.lib.recipe.api;\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/RecipeLoadingEvents.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api;\n", "package ho.artisan.lib.recipe.api;\n\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport net.fabricmc.fabric.api.event.EventFactory;\nimport org.jetbrains.annotations.ApiStatus;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;", "import net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\nimport net.fabricmc.fabric.api.event.Event;\n\n/**\n * Represents the recipe loading events.\n * <p>\n * Triggered when the recipes are being loaded in the {@link net.minecraft.recipe.RecipeManager}.", " * <p>\n * Triggered when the recipes are being loaded in the {@link net.minecraft.recipe.RecipeManager}.\n * <p>\n * Events are triggered in the following order:\n * <ol>\n *     <li>{@link #ADD}</li>\n *     <li>{@link #MODIFY}</li>\n *     <li>{@link #REMOVE}</li>\n * </ol>\n */\npublic final class RecipeLoadingEvents {\n\t/**\n\t * Event to add new recipes while the {@link net.minecraft.recipe.RecipeManager} is being built.\n\t * <p>\n\t * Triggered before {@link #MODIFY} and {@link #REMOVE}.\n\t */", " * </ol>\n */\npublic final class RecipeLoadingEvents {\n\t/**\n\t * Event to add new recipes while the {@link net.minecraft.recipe.RecipeManager} is being built.\n\t * <p>\n\t * Triggered before {@link #MODIFY} and {@link #REMOVE}.\n\t */\n\tpublic static final Event<AddRecipesCallback> ADD = EventFactory.createArrayBacked(AddRecipesCallback.class,\n\t\t\tcallbacks -> handler -> {\n\t\t\t\tfor (var callback : callbacks) {\n\t\t\t\t\tcallback.addRecipes(handler);\n\t\t\t\t}\n\t\t\t});\n\t/**\n\t * Event to modify recipes while the {@link net.minecraft.recipe.RecipeManager} is being built.\n\t * <p>\n\t * Triggered after {@link #ADD} and before {@link #REMOVE}.\n\t */", "\tpublic static final Event<AddRecipesCallback> ADD = EventFactory.createArrayBacked(AddRecipesCallback.class,\n\t\t\tcallbacks -> handler -> {\n\t\t\t\tfor (var callback : callbacks) {\n\t\t\t\t\tcallback.addRecipes(handler);\n\t\t\t\t}\n\t\t\t});\n\t/**\n\t * Event to modify recipes while the {@link net.minecraft.recipe.RecipeManager} is being built.\n\t * <p>\n\t * Triggered after {@link #ADD} and before {@link #REMOVE}.\n\t */", "\tpublic static final Event<ModifyRecipesCallback> MODIFY = EventFactory.createArrayBacked(ModifyRecipesCallback.class,\n\t\t\tcallbacks -> handler -> {\n\t\t\t\tfor (var callback : callbacks) {\n\t\t\t\t\tcallback.modifyRecipes(handler);\n\t\t\t\t}\n\t\t\t});\n\t/**\n\t * Event to remove recipes while the {@link net.minecraft.recipe.RecipeManager} is being built.\n\t * <p>\n\t * Triggered after {@link #ADD} and {@link #MODIFY}.\n\t */", "\tpublic static final Event<RemoveRecipesCallback> REMOVE = EventFactory.createArrayBacked(RemoveRecipesCallback.class,\n\t\t\tcallbacks -> handler -> {\n\t\t\t\tfor (var callback : callbacks) {\n\t\t\t\t\tcallback.removeRecipes(handler);\n\t\t\t\t}\n\t\t\t});\n\n\tprivate RecipeLoadingEvents() {\n\t\tthrow new UnsupportedOperationException(\"RecipeLoadingEvents only contains static definitions.\");\n\t}\n\n\t/**\n\t * Callback called to register additional recipes when recipes are loaded.\n\t */\n\t@FunctionalInterface", "\tpublic interface AddRecipesCallback {\n\t\t/**\n\t\t * Called when recipes are loaded.\n\t\t * <p>\n\t\t * {@code handler} is used to add recipes into the {@linkplain net.minecraft.recipe.RecipeManager recipe manager}.\n\t\t *\n\t\t * @param handler the recipe handler\n\t\t */\n\t\tvoid addRecipes(RecipeHandler handler);\n\n\t\t/**\n\t\t * This interface should not be extended by users.\n\t\t */\n\t\t@ApiStatus.NonExtendable\n\t\tinterface RecipeHandler {\n\t\t\t/**\n\t\t\t * Registers a recipe into the {@link net.minecraft.recipe.RecipeManager}.\n\t\t\t * <p>\n\t\t\t * The recipe factory is only called if the recipe is not already present.\n\t\t\t *\n\t\t\t * @param id      identifier of the recipe\n\t\t\t * @param factory the recipe factory\n\t\t\t */\n\t\t\tvoid register(Identifier id, Function<Identifier, Recipe<?>> factory);\n\t\t}\n\t}\n\n\t/**\n\t * Callback called to modify or replace recipes after recipes are loaded.\n\t */\n\t@FunctionalInterface", "\tpublic interface ModifyRecipesCallback {\n\t\t/**\n\t\t * Called after recipes are loaded to modify and replace recipes.\n\t\t *\n\t\t * @param handler the recipe handler\n\t\t */\n\t\tvoid modifyRecipes(RecipeHandler handler);\n\n\t\t/**\n\t\t * This interface should not be extended by users.\n\t\t */\n\t\t@ApiStatus.NonExtendable\n\t\tinterface RecipeHandler extends BaseRecipeHandler {\n\t\t\t/**\n\t\t\t * Replaces a recipe in the {@link net.minecraft.recipe.RecipeManager}.\n\t\t\t *\n\t\t\t * @param recipe the recipe\n\t\t\t */\n\t\t\tvoid replace(Recipe<?> recipe);\n\t\t}\n\t}\n\n\t/**\n\t * Callback called to remove recipes after recipes are loaded.\n\t */\n\t@FunctionalInterface", "\tpublic interface RemoveRecipesCallback {\n\t\t/**\n\t\t * Called after recipes are loaded to remove recipes.\n\t\t *\n\t\t * @param handler the recipe handler\n\t\t */\n\t\tvoid removeRecipes(RecipeHandler handler);\n\n\t\t/**\n\t\t * This interface should not be extended by users.\n\t\t */\n\t\t@ApiStatus.NonExtendable\n\t\tinterface RecipeHandler extends BaseRecipeHandler {\n\t\t\t/**\n\t\t\t * Removes a recipe in the {@link net.minecraft.recipe.RecipeManager}.\n\t\t\t *\n\t\t\t * @param recipe the recipe identifier\n\t\t\t */\n\t\t\tvoid remove(Identifier recipe);\n\n\t\t\t/**\n\t\t\t * Removes a recipe if the predicate returns {@code true}.\n\t\t\t *\n\t\t\t * @param recipeType             the recipe type of the recipes to conditionally remove\n\t\t\t * @param recipeRemovalPredicate the recipe removal predicate\n\t\t\t * @param <T>                    the type of the recipe\n\t\t\t */\n\t\t\t<T extends Recipe<?>> void removeIf(RecipeType<T> recipeType, Predicate<T> recipeRemovalPredicate);\n\n\t\t\t/**\n\t\t\t * Removes a recipe if the predicate returns {@code true}.\n\t\t\t *\n\t\t\t * @param recipeRemovalPredicate the recipe removal predicate\n\t\t\t */\n\t\t\tvoid removeIf(Predicate<Recipe<?>> recipeRemovalPredicate);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/serializer/FabricRecipeSerializer.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api.serializer;\n", "package ho.artisan.lib.recipe.api.serializer;\n\nimport com.google.gson.JsonObject;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeSerializer;\n\n/**\n * Represents a recipe serializer for mods to implement.\n * <p>", " * Represents a recipe serializer for mods to implement.\n * <p>\n * This will allow serialization to JSON of recipes. Useful for recipe dumping.\n *\n * @param <T> the recipe\n */\npublic interface FabricRecipeSerializer<T extends Recipe<?>> extends RecipeSerializer<T> {\n\t/**\n\t * Serializes the recipe to JSON.\n\t *\n\t * @param recipe the recipe\n\t * @return the serialized recipe\n\t */\n\tJsonObject toJson(T recipe);\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/builder/ShapelessRecipeBuilder.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api.builder;\n", "package ho.artisan.lib.recipe.api.builder;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemConvertible;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.ShapelessRecipe;", "import net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.ShapelessRecipe;\nimport net.minecraft.tag.TagKey;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\n\n/**\n * Builder to build shapeless crafting recipes.\n */\npublic class ShapelessRecipeBuilder extends RecipeBuilder<ShapelessRecipeBuilder, ShapelessRecipe> {\n\tprivate final Set<Ingredient> ingredients = new HashSet<>();\n\n\tpublic ShapelessRecipeBuilder(ItemStack output) {\n\t\tthis.output = output;\n\t}\n\n\t/**\n\t * Adds an ingredient.\n\t *\n\t * @param ingredient the ingredient\n\t * @return this builder\n\t */", " */\npublic class ShapelessRecipeBuilder extends RecipeBuilder<ShapelessRecipeBuilder, ShapelessRecipe> {\n\tprivate final Set<Ingredient> ingredients = new HashSet<>();\n\n\tpublic ShapelessRecipeBuilder(ItemStack output) {\n\t\tthis.output = output;\n\t}\n\n\t/**\n\t * Adds an ingredient.\n\t *\n\t * @param ingredient the ingredient\n\t * @return this builder\n\t */", "\tpublic ShapelessRecipeBuilder ingredient(Ingredient ingredient) {\n\t\tthis.ingredients.add(ingredient);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds items as a single ingredient.\n\t *\n\t * @param items the items as ingredient\n\t * @return this builder\n\t * @see #ingredient(Ingredient)\n\t * @see Ingredient#ofItems(ItemConvertible...)\n\t */", "\tpublic ShapelessRecipeBuilder ingredient(ItemConvertible... items) {\n\t\treturn this.ingredient(Ingredient.ofItems(items));\n\t}\n\n\t/**\n\t * Adds the specified item tag as a single ingredient.\n\t *\n\t * @param tag the item tag as ingredient\n\t * @return this builder\n\t * @see #ingredient(Ingredient)\n\t * @see Ingredient#fromTag(TagKey) (TagKey)\n\t */", "\tpublic ShapelessRecipeBuilder ingredient(TagKey<Item> tag) {\n\t\treturn this.ingredient(Ingredient.fromTag(tag));\n\t}\n\n\t/**\n\t * Adds item stacks as a single ingredient.\n\t *\n\t * @param stacks the item stacks as ingredient\n\t * @return this builder\n\t * @see #ingredient(Ingredient)\n\t * @see Ingredient#ofStacks(ItemStack...)\n\t */", "\tpublic ShapelessRecipeBuilder ingredient(ItemStack... stacks) {\n\t\treturn this.ingredient(Ingredient.ofStacks(stacks));\n\t}\n\n\t/**\n\t * Builds the shapeless crafting recipe.\n\t *\n\t * @param id    the identifier of the recipe\n\t * @param group the group of the recipe\n\t * @return the shapeless crafting recipe\n\t */", "\tpublic ShapelessRecipe build(Identifier id, String group) {\n\t\tthis.checkOutputItem();\n\n\t\tif (this.ingredients.size() == 0) throw new IllegalStateException(\"Cannot build a recipe without ingredients.\");\n\n\t\tDefaultedList<Ingredient> ingredients = DefaultedList.ofSize(this.ingredients.size(), Ingredient.EMPTY);\n\t\tint i = 0;\n\n\t\tfor (var ingredient : this.ingredients) {\n\t\t\tingredients.set(i, ingredient);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new ShapelessRecipe(id, group, this.output, ingredients);\n\t}\n}\n", "\t\tfor (var ingredient : this.ingredients) {\n\t\t\tingredients.set(i, ingredient);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new ShapelessRecipe(id, group, this.output, ingredients);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/builder/VanillaRecipeBuilders.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api.builder;\n", "package ho.artisan.lib.recipe.api.builder;\n\n\nimport it.unimi.dsi.fastutil.chars.Char2ObjectMap;\n\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.recipe.BlastingRecipe;\nimport net.minecraft.recipe.CampfireCookingRecipe;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.SmeltingRecipe;", "import net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.SmeltingRecipe;\nimport net.minecraft.recipe.SmokingRecipe;\nimport net.minecraft.recipe.StonecuttingRecipe;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\n\nimport ho.artisan.lib.recipe.impl.VanillaRecipeBuildersImpl;\n\n/**", "\n/**\n * Provides some recipe builders for Vanilla recipes.\n */\npublic final class VanillaRecipeBuilders {\n\tprivate VanillaRecipeBuilders() {\n\t\tthrow new UnsupportedOperationException(\"VanillaRecipeBuilders only contains static definitions.\");\n\t}\n\n\t/**\n\t * Returns the list of ingredients for shaped crafting recipes.\n\t *\n\t * @param pattern the pattern of the shaped crafting recipe\n\t * @param keys    the keys and ingredients of the recipe\n\t * @param width   the width of the shaped crafting recipe\n\t * @param height  the height of the shaped crafting recipe\n\t * @return the ingredients\n\t * @throws IllegalStateException if a key has no assigned ingredient or if there is an ingredient but no assigned key\n\t */", "\tpublic static DefaultedList<Ingredient> getIngredients(String[] pattern, Char2ObjectMap<Ingredient> keys, int width, int height) {\n\t\treturn VanillaRecipeBuildersImpl.getIngredients(pattern, keys, width, height);\n\t}\n\n\t/**\n\t * Returns a new shaped crafting recipe builder.\n\t *\n\t * @param pattern the pattern of the shaped crafting recipe\n\t * @return the builder\n\t */\n\tpublic static ShapedRecipeBuilder shapedRecipe(String... pattern) {\n\t\treturn new ShapedRecipeBuilder(pattern);\n\t}\n\n\t/**\n\t * Returns a new shapeless crafting recipe builder.\n\t *\n\t * @param output the output stack\n\t * @return the builder\n\t */", "\tpublic static ShapedRecipeBuilder shapedRecipe(String... pattern) {\n\t\treturn new ShapedRecipeBuilder(pattern);\n\t}\n\n\t/**\n\t * Returns a new shapeless crafting recipe builder.\n\t *\n\t * @param output the output stack\n\t * @return the builder\n\t */\n\tpublic static ShapelessRecipeBuilder shapelessRecipe(ItemStack output) {\n\t\treturn new ShapelessRecipeBuilder(output);\n\t}\n\n\t/**\n\t * Returns a new stone cutting recipe.\n\t *\n\t * @param id     the identifier of the recipe\n\t * @param group  the group of the recipe\n\t * @param input  the input ingredient\n\t * @param output the output item stack\n\t * @return the stone cutting recipe\n\t */", "\tpublic static ShapelessRecipeBuilder shapelessRecipe(ItemStack output) {\n\t\treturn new ShapelessRecipeBuilder(output);\n\t}\n\n\t/**\n\t * Returns a new stone cutting recipe.\n\t *\n\t * @param id     the identifier of the recipe\n\t * @param group  the group of the recipe\n\t * @param input  the input ingredient\n\t * @param output the output item stack\n\t * @return the stone cutting recipe\n\t */", "\tpublic static StonecuttingRecipe stonecuttingRecipe(Identifier id, String group, Ingredient input, ItemStack output) {\n\t\treturn VanillaRecipeBuildersImpl.stonecuttingRecipe(id, group, input, output);\n\t}\n\n\t/**\n\t * Returns a new smelting recipe.\n\t *\n\t * @param id         the identifier of the recipe\n\t * @param group      the group of the recipe\n\t * @param input      the input ingredient\n\t * @param output     the output item stack\n\t * @param experience the experience given\n\t * @param cookTime   the cook time in ticks\n\t * @return the smelting recipe\n\t */", "\tpublic static SmeltingRecipe smeltingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\treturn VanillaRecipeBuildersImpl.smeltingRecipe(id, group, input, output, experience, cookTime);\n\t}\n\n\t/**\n\t * Returns a new blasting recipe.\n\t *\n\t * @param id         the identifier of the recipe\n\t * @param group      the group of the recipe\n\t * @param input      the input ingredient\n\t * @param output     the output item stack\n\t * @param experience the experience given\n\t * @param cookTime   the cook time in ticks\n\t * @return the blasting recipe\n\t */", "\tpublic static BlastingRecipe blastingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\treturn VanillaRecipeBuildersImpl.blastingRecipe(id, group, input, output, experience, cookTime);\n\t}\n\n\t/**\n\t * Returns a new smoking recipe.\n\t *\n\t * @param id         the identifier of the recipe\n\t * @param group      the group of the recipe\n\t * @param input      the input ingredient\n\t * @param output     the output item stack\n\t * @param experience the experience given\n\t * @param cookTime   the cook time in ticks\n\t * @return the smoking recipe\n\t */", "\tpublic static SmokingRecipe smokingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\treturn VanillaRecipeBuildersImpl.smokingRecipe(id, group, input, output, experience, cookTime);\n\t}\n\n\t/**\n\t * Returns a new campfire cooking recipe.\n\t *\n\t * @param id         the identifier of the recipe\n\t * @param group      the group of the recipe\n\t * @param input      the input ingredient\n\t * @param output     the output item stack\n\t * @param experience the experience given\n\t * @param cookTime   the cook time in ticks\n\t * @return the campfire cooking recipe\n\t */", "\tpublic static CampfireCookingRecipe campfireCookingRecipe(Identifier id, String group, Ingredient input,\n\t\t\tItemStack output, float experience, int cookTime) {\n\t\treturn VanillaRecipeBuildersImpl.campfireCookingRecipe(id, group, input, output, experience, cookTime);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/builder/ShapedRecipeBuilder.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api.builder;\n", "package ho.artisan.lib.recipe.api.builder;\n\nimport it.unimi.dsi.fastutil.chars.Char2ObjectMap;\nimport it.unimi.dsi.fastutil.chars.Char2ObjectOpenHashMap;\n\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemConvertible;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.ShapedRecipe;", "import net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.ShapedRecipe;\nimport net.minecraft.tag.TagKey;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\n\n/**\n * Builder to build shaped crafting recipes.\n */\npublic class ShapedRecipeBuilder extends RecipeBuilder<ShapedRecipeBuilder, ShapedRecipe> {\n\tprivate final String[] pattern;\n\tprivate final int width;\n\tprivate final int height;\n\tprivate final Char2ObjectMap<Ingredient> ingredients = new Char2ObjectOpenHashMap<>();\n\n\t/**\n\t * Creates a new shaped recipe builder.\n\t *\n\t * @param pattern the pattern of the shaped recipe. Each string in this array is a line of ingredients.\n\t *                A character represents an ingredient and space is no ingredient\n\t */\n\tpublic ShapedRecipeBuilder(String... pattern) {\n\t\tthis.pattern = pattern;\n\t\tthis.width = pattern[0].length();\n\t\tthis.height = pattern.length;\n\t\tthis.ingredients.put(' ', Ingredient.EMPTY); // By default, space is an empty ingredient.\n\t}\n\n\t/**\n\t * Associates an ingredient with a specified key.\n\t *\n\t * @param key        the key of the ingredient\n\t * @param ingredient the ingredient\n\t * @return this builder\n\t */", " */\npublic class ShapedRecipeBuilder extends RecipeBuilder<ShapedRecipeBuilder, ShapedRecipe> {\n\tprivate final String[] pattern;\n\tprivate final int width;\n\tprivate final int height;\n\tprivate final Char2ObjectMap<Ingredient> ingredients = new Char2ObjectOpenHashMap<>();\n\n\t/**\n\t * Creates a new shaped recipe builder.\n\t *\n\t * @param pattern the pattern of the shaped recipe. Each string in this array is a line of ingredients.\n\t *                A character represents an ingredient and space is no ingredient\n\t */\n\tpublic ShapedRecipeBuilder(String... pattern) {\n\t\tthis.pattern = pattern;\n\t\tthis.width = pattern[0].length();\n\t\tthis.height = pattern.length;\n\t\tthis.ingredients.put(' ', Ingredient.EMPTY); // By default, space is an empty ingredient.\n\t}\n\n\t/**\n\t * Associates an ingredient with a specified key.\n\t *\n\t * @param key        the key of the ingredient\n\t * @param ingredient the ingredient\n\t * @return this builder\n\t */", "\tpublic ShapedRecipeBuilder ingredient(char key, Ingredient ingredient) {\n\t\tboolean success = false;\n\n\t\tfor (String line : this.pattern) {\n\t\t\tfor (int i = 0; i < line.length(); i++) {\n\t\t\t\tchar c = line.charAt(i);\n\n\t\t\t\tif (c == key) {\n\t\t\t\t\tthis.ingredients.put(key, ingredient);\n\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n", "\t\t\tif (success) break;\n\t\t}\n\n\t\tif (!success) {\n\t\t\tthrow new IllegalArgumentException(\"The pattern key '\" + key + \"' doesn't exist in the given pattern.\");\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Puts the specified items as the accepted ingredient at the specified key.\n\t *\n\t * @param key   the key of the ingredient\n\t * @param items the items as ingredient\n\t * @return this builder\n\t * @see #ingredient(char, Ingredient)\n\t * @see Ingredient#ofItems(ItemConvertible...)\n\t */", "\tpublic ShapedRecipeBuilder ingredient(char key, ItemConvertible... items) {\n\t\treturn this.ingredient(key, Ingredient.ofItems(items));\n\t}\n\n\t/**\n\t * Puts the specified item tag as the accepted ingredient at the specified key.\n\t *\n\t * @param key the key of the ingredient\n\t * @param tag the item tag as ingredient\n\t * @return this builder\n\t * @see #ingredient(char, Ingredient)\n\t * @see Ingredient#fromTag(TagKey) (TagKey)\n\t */", "\tpublic ShapedRecipeBuilder ingredient(char key, TagKey<Item> tag) {\n\t\treturn this.ingredient(key, Ingredient.fromTag(tag));\n\t}\n\n\t/**\n\t * Puts the specified item stacks as the accepted ingredient at the specified key.\n\t *\n\t * @param key    the key of the ingredient\n\t * @param stacks the item stacks as ingredient\n\t * @return this builder\n\t * @see #ingredient(char, Ingredient)\n\t * @see Ingredient#ofStacks(ItemStack...)\n\t */", "\tpublic ShapedRecipeBuilder ingredient(char key, ItemStack... stacks) {\n\t\treturn this.ingredient(key, Ingredient.ofStacks(stacks));\n\t}\n\n\t/**\n\t * Builds the shaped crafting recipe.\n\t *\n\t * @param id    the identifier of the recipe\n\t * @param group the group of the recipe\n\t * @return the shaped recipe\n\t */\n\t@Override", "\tpublic ShapedRecipe build(Identifier id, String group) {\n\t\tthis.checkOutputItem();\n\t\tDefaultedList<Ingredient> ingredients = VanillaRecipeBuilders.getIngredients(this.pattern, this.ingredients, this.width, this.height);\n\t\treturn new ShapedRecipe(id, group, this.width, this.height, ingredients, this.output);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/api/builder/RecipeBuilder.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.api.builder;\n", "package ho.artisan.lib.recipe.api.builder;\n\nimport java.util.Objects;\n\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.util.Identifier;\n\n/**\n * Represents the basis of a recipe builder.", "/**\n * Represents the basis of a recipe builder.\n *\n * @param <SELF>   the type of the recipe builder\n * @param <RESULT> the type of the recipe\n */\npublic abstract class RecipeBuilder<SELF extends RecipeBuilder<SELF, RESULT>, RESULT extends Recipe<?>> {\n\tprotected ItemStack output;\n\n\t/**\n\t * Sets the output of the shaped crafting recipe.\n\t *\n\t * @param stack the output item stack.\n\t * @return this builder\n\t */\n\t@SuppressWarnings(\"unchecked\")", "\tpublic SELF output(ItemStack stack) {\n\t\tthis.output = stack;\n\t\treturn (SELF) this;\n\t}\n\n\tprotected void checkOutputItem() {\n\t\tObjects.requireNonNull(this.output, \"The output stack cannot be null.\");\n\t}\n\n\t/**\n\t * Builds the recipe.\n\t *\n\t * @param id    the identifier of the recipe\n\t * @param group the group of the recipe\n\t * @return the shaped recipe\n\t */", "\tpublic abstract RESULT build(Identifier id, String group);\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/RecipeManagerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport java.util.Collections;\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.gson.JsonElement;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Overwrite;\nimport org.spongepowered.asm.mixin.Shadow;", "import org.spongepowered.asm.mixin.Overwrite;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.Redirect;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\nimport org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;", "import net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.resource.ResourceManager;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.profiler.Profiler;\n\nimport ho.artisan.lib.recipe.impl.ImmutableMapBuilderUtil;\nimport ho.artisan.lib.recipe.impl.RecipeManagerImpl;\n", "import ho.artisan.lib.recipe.impl.RecipeManagerImpl;\n\n@Mixin(RecipeManager.class)\npublic class RecipeManagerMixin {\n\t@Shadow\n\tprivate Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes;\n\n\t@Shadow\n\tprivate Map<Identifier, Recipe<?>> recipesById;\n\n\t@Inject(\n\t\t\tmethod = \"apply\",\n\t\t\tat = @At(value = \"INVOKE\", target = \"Ljava/util/Map;entrySet()Ljava/util/Set;\", remap = false, ordinal = 0),\n\t\t\tlocals = LocalCapture.CAPTURE_FAILHARD\n\t)\n\tprivate void onReload(Map<Identifier, JsonElement> map, ResourceManager resourceManager, Profiler profiler,\n\t\t\tCallbackInfo ci,\n\t\t\tMap<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap,\n\t\t\tImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder) {\n\t\tRecipeManagerImpl.apply(map, builderMap, globalRecipeMapBuilder);\n\t}\n\n\t/**\n\t * Synthetic method in {@link RecipeManager#apply(Map, ResourceManager, Profiler)} as an argument of {@code toImmutableMap}.\n\t *\n\t * @author QuiltMC, LambdAurora\n\t * @reason Replaces immutable maps for mutable maps instead.\n\t */\n\t@Overwrite\n\tprivate static Map<Identifier, Recipe<?>> method_20703(Map.Entry<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> entry) {\n\t\t// This is cursed. Do not look.\n\t\treturn ImmutableMapBuilderUtil.specialBuild(entry.getValue());\n\t}\n\n\t@Redirect(\n\t\t\tmethod = \"apply\",\n\t\t\tat = @At(\n\t\t\t\t\tvalue = \"INVOKE\",\n\t\t\t\t\ttarget = \"Lcom/google/common/collect/ImmutableMap$Builder;build()Lcom/google/common/collect/ImmutableMap;\",\n\t\t\t\t\tremap = false\n\t\t\t)\n\t)\n\tprivate ImmutableMap<Identifier, Recipe<?>> onCreateGlobalRecipeMap(ImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder) {\n\t\treturn null; // The original method bounds us to return an immutable map, but we do not want that!\n\t}\n\n\t@Inject(\n\t\t\tmethod = \"apply\",\n\t\t\tat = @At(value = \"INVOKE\", target = \"Lorg/slf4j/Logger;info(Ljava/lang/String;Ljava/lang/Object;)V\", remap = false),\n\t\t\tlocals = LocalCapture.CAPTURE_FAILHARD\n\t)\n\tprivate void onReloadEnd(Map<Identifier, JsonElement> map, ResourceManager resourceManager, Profiler profiler,\n\t\t\tCallbackInfo ci,\n\t\t\tMap<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap,\n\t\t\tImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder) {\n\t\tMap<Identifier, Recipe<?>> globalRecipes = ImmutableMapBuilderUtil.specialBuild(globalRecipeMapBuilder);\n\n\t\tRecipeManagerImpl.applyModifications((RecipeManager) (Object) this, this.recipes, globalRecipes);\n\n\t\tthis.recipesById = Collections.unmodifiableMap(globalRecipes);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/SpecialRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport java.util.Objects;\n\nimport com.google.gson.JsonObject;\nimport org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.SpecialRecipeSerializer;\nimport net.minecraft.util.registry.Registry;", "import net.minecraft.recipe.SpecialRecipeSerializer;\nimport net.minecraft.util.registry.Registry;\n\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@Mixin(SpecialRecipeSerializer.class)\npublic abstract class SpecialRecipeSerializerMixin<T extends Recipe<?>> implements FabricRecipeSerializer<T> {\n\t@Override\n\tpublic JsonObject toJson(T recipe) {\n\t\tvar json = new JsonObject();\n\t\tjson.addProperty(\"type\", Objects.requireNonNull(Registry.RECIPE_SERIALIZER.getId(this)).toString());\n\t\treturn json;\n\t}\n}\n", "\tpublic JsonObject toJson(T recipe) {\n\t\tvar json = new JsonObject();\n\t\tjson.addProperty(\"type\", Objects.requireNonNull(Registry.RECIPE_SERIALIZER.getId(this)).toString());\n\t\treturn json;\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/ShapelessRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport com.google.gson.JsonObject;\nimport org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.data.server.recipe.ShapelessRecipeJsonBuilder;\nimport net.minecraft.recipe.ShapelessRecipe;\n\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n", "import ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@Mixin(ShapelessRecipe.Serializer.class)\npublic abstract class ShapelessRecipeSerializerMixin implements FabricRecipeSerializer<ShapelessRecipe> {\n\t@Override\n\tpublic JsonObject toJson(ShapelessRecipe recipe) {\n\t\treturn new ShapelessRecipeJsonBuilder.ShapelessRecipeJsonProvider(recipe.getId(),\n\t\t\t\trecipe.getOutput().getItem(), recipe.getOutput().getCount(),\n\t\t\t\trecipe.getGroup(), recipe.getIngredients(), null, null)\n\t\t\t\t.toJson();\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/CookingRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport com.google.gson.JsonObject;\nimport org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.data.server.recipe.CookingRecipeJsonBuilder;\nimport net.minecraft.recipe.AbstractCookingRecipe;\nimport net.minecraft.recipe.CookingRecipeSerializer;\n\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;", "\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@Mixin(CookingRecipeSerializer.class)\npublic abstract class CookingRecipeSerializerMixin<T extends AbstractCookingRecipe> implements FabricRecipeSerializer<T> {\n\t@Override\n\tpublic JsonObject toJson(T recipe) {\n\t\treturn new CookingRecipeJsonBuilder.CookingRecipeJsonProvider(recipe.getId(), recipe.getGroup(),\n\t\t\t\trecipe.getIngredients().get(0), recipe.getOutput().getItem(),\n\t\t\t\trecipe.getExperience(), recipe.getCookTime(), null, null, this)\n\t\t\t\t.toJson();\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/ShapedRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport java.util.ArrayList;\n\nimport com.google.gson.JsonObject;\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\nimport it.unimi.dsi.fastutil.chars.Char2ObjectOpenHashMap;\nimport it.unimi.dsi.fastutil.objects.Object2CharOpenHashMap;\nimport org.spongepowered.asm.mixin.Mixin;\n", "import org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.data.server.recipe.ShapedRecipeJsonBuilder;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.ShapedRecipe;\nimport net.minecraft.util.collection.DefaultedList;\n\n\n@Mixin(ShapedRecipe.Serializer.class)\npublic abstract class ShapedRecipeSerializerMixin implements FabricRecipeSerializer<ShapedRecipe> {\n\t@Override", "@Mixin(ShapedRecipe.Serializer.class)\npublic abstract class ShapedRecipeSerializerMixin implements FabricRecipeSerializer<ShapedRecipe> {\n\t@Override\n\tpublic JsonObject toJson(ShapedRecipe recipe) {\n\t\tDefaultedList<Ingredient> recipeIngredients = recipe.getIngredients();\n\t\tvar ingredients = new Object2CharOpenHashMap<Ingredient>();\n\t\tvar inputs = new Char2ObjectOpenHashMap<Ingredient>();\n\t\tingredients.defaultReturnValue(' ');\n\t\tchar currentChar = 'A';\n\n\t\tfor (Ingredient ingredient : recipeIngredients) {", "\t\tfor (Ingredient ingredient : recipeIngredients) {\n\t\t\tif (!ingredient.isEmpty()\n\t\t\t\t\t&& ingredients.putIfAbsent(ingredient, currentChar) == ingredients.defaultReturnValue()) {\n\t\t\t\tinputs.putIfAbsent(currentChar, ingredient);\n\t\t\t\tcurrentChar++;\n\t\t\t}\n\t\t}\n\n\t\tvar pattern = new ArrayList<String>();\n\t\tvar patternLine = new StringBuilder();\n", "\t\tfor (int i = 0; i < recipeIngredients.size(); i++) {\n\t\t\tif (i != 0 && i % recipe.getWidth() == 0) {\n\t\t\t\tpattern.add(patternLine.toString());\n\t\t\t\tpatternLine.setLength(0);\n\t\t\t}\n\n\t\t\tIngredient ingredient = recipeIngredients.get(i);\n\t\t\tpatternLine.append(ingredients.getChar(ingredient));\n\t\t}\n\n\t\tpattern.add(patternLine.toString());\n\n\n\t\treturn new ShapedRecipeJsonBuilder.ShapedRecipeJsonProvider(\n\t\t\t\trecipe.getId(),\n\t\t\t\trecipe.getOutput().getItem(),\n\t\t\t\trecipe.getOutput().getCount(),\n\t\t\t\trecipe.getGroup(),\n\t\t\t\tpattern,\n\t\t\t\tinputs,\n\t\t\t\tnull, null\n\t\t).toJson();\n\t\t//return null;\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/SmithingRecipeAccessor.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\n\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.SmithingRecipe;\n\n@Mixin(SmithingRecipe.class)\npublic interface SmithingRecipeAccessor {\n\t@Accessor\n\tIngredient getBase();\n\n\t@Accessor\n\tIngredient getAddition();\n}\n", "@Mixin(SmithingRecipe.class)\npublic interface SmithingRecipeAccessor {\n\t@Accessor\n\tIngredient getBase();\n\n\t@Accessor\n\tIngredient getAddition();\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/CuttingRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport com.google.gson.JsonObject;\nimport org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.data.server.recipe.SingleItemRecipeJsonBuilder;\nimport net.minecraft.recipe.CuttingRecipe;\n\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n", "import ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@Mixin(CuttingRecipe.Serializer.class)\npublic abstract class CuttingRecipeSerializerMixin<T extends CuttingRecipe> implements FabricRecipeSerializer<T> {\n\t@Override\n\tpublic JsonObject toJson(T recipe) {\n\t\treturn new SingleItemRecipeJsonBuilder.SingleItemRecipeJsonProvider(recipe.getId(), this, recipe.getGroup(),\n\t\t\t\trecipe.getIngredients().get(0), recipe.getOutput().getItem(), recipe.getOutput().getCount(),\n\t\t\t\tnull, null)\n\t\t\t\t.toJson();\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/mixin/SmithingRecipeSerializerMixin.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.mixin;\n", "package ho.artisan.lib.recipe.mixin;\n\nimport com.google.gson.JsonObject;\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\nimport org.spongepowered.asm.mixin.Mixin;\n\nimport net.minecraft.data.server.recipe.SmithingRecipeJsonBuilder;\nimport net.minecraft.recipe.SmithingRecipe;\n\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;", "\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@Mixin(SmithingRecipe.Serializer.class)\npublic abstract class SmithingRecipeSerializerMixin implements FabricRecipeSerializer<SmithingRecipe> {\n\t@Override\n\tpublic JsonObject toJson(SmithingRecipe recipe) {\n\t\tvar accessor = (SmithingRecipeAccessor) recipe;\n\n\t\treturn new SmithingRecipeJsonBuilder.SmithingRecipeJsonProvider(\n\t\t\t\trecipe.getId(),\n\t\t\t\tthis,\n\t\t\t\taccessor.getBase(), accessor.getAddition(), recipe.getOutput().getItem(),\n\t\t\t\tnull, null\n\t\t).toJson();\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/BasicRecipeHandlerImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;", "import net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\nimport ho.artisan.lib.recipe.api.BaseRecipeHandler;\n\nclass BasicRecipeHandlerImpl implements BaseRecipeHandler {\n\tfinal RecipeManager recipeManager;\n\tfinal Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes;", "\tfinal RecipeManager recipeManager;\n\tfinal Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes;\n\tfinal Map<Identifier, Recipe<?>> globalRecipes;\n\n\tBasicRecipeHandlerImpl(RecipeManager recipeManager, Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes,\n\t\t\tMap<Identifier, Recipe<?>> globalRecipes) {\n\t\tthis.recipeManager = recipeManager;\n\t\tthis.recipes = recipes;\n\t\tthis.globalRecipes = globalRecipes;\n\t}", "\t\tthis.globalRecipes = globalRecipes;\n\t}\n\n\t@Override\n\tpublic @Nullable RecipeType<?> getTypeOf(Identifier id) {\n\t\treturn this.recipes.entrySet().stream()\n\t\t\t\t.filter(entry -> entry.getValue().containsKey(id))\n\t\t\t\t.findFirst()\n\t\t\t\t.map(Map.Entry::getKey)\n\t\t\t\t.orElse(null);", "\t\t\t\t.map(Map.Entry::getKey)\n\t\t\t\t.orElse(null);\n\t}\n\n\t@Override\n\tpublic boolean contains(Identifier id) {\n\t\treturn this.globalRecipes.containsKey(id);\n\t}\n\n\t@Override\n\tpublic boolean contains(Identifier id, RecipeType<?> type) {\n\t\tMap<Identifier, Recipe<?>> recipes = this.recipes.get(type);\n", "\tpublic boolean contains(Identifier id, RecipeType<?> type) {\n\t\tMap<Identifier, Recipe<?>> recipes = this.recipes.get(type);\n\n\t\tif (recipes == null) return false;\n\n\t\treturn recipes.containsKey(id);\n\t}\n\n\t@Override\n\tpublic @Nullable Recipe<?> getRecipe(Identifier id) {\n\t\treturn this.globalRecipes.get(id);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Recipe<?>> @Nullable T getRecipe(Identifier id, RecipeType<T> type) {\n\t\tMap<Identifier, Recipe<?>> recipes = this.recipes.get(type);\n", "\t\tif (recipes == null) return null;\n\n\t\treturn (T) recipes.get(id);\n\t}\n\n\t@Override\n\tpublic Map<RecipeType<?>, Map<Identifier, Recipe<?>>> getRecipes() {\n\t\treturn Collections.unmodifiableMap(this.recipes);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Recipe<?>> Collection<T> getRecipesOfType(RecipeType<T> type) {\n\t\tMap<Identifier, Recipe<?>> recipes = this.recipes.get(type);\n", "\t\tif (recipes == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn Collections.unmodifiableCollection((Collection<T>) recipes.values());\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/VanillaRecipeBuildersImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport it.unimi.dsi.fastutil.chars.Char2ObjectMap;\nimport it.unimi.dsi.fastutil.chars.CharArraySet;\nimport org.jetbrains.annotations.ApiStatus;\n\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.recipe.BlastingRecipe;\nimport net.minecraft.recipe.CampfireCookingRecipe;\nimport net.minecraft.recipe.Ingredient;", "import net.minecraft.recipe.CampfireCookingRecipe;\nimport net.minecraft.recipe.Ingredient;\nimport net.minecraft.recipe.SmeltingRecipe;\nimport net.minecraft.recipe.SmokingRecipe;\nimport net.minecraft.recipe.StonecuttingRecipe;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.collection.DefaultedList;\n\n@ApiStatus.Internal\npublic final class VanillaRecipeBuildersImpl {\n\tprivate VanillaRecipeBuildersImpl() {\n\t\tthrow new UnsupportedOperationException(\"VanillaRecipeBuildersImpl only contains static definitions.\");\n\t}\n", "@ApiStatus.Internal\npublic final class VanillaRecipeBuildersImpl {\n\tprivate VanillaRecipeBuildersImpl() {\n\t\tthrow new UnsupportedOperationException(\"VanillaRecipeBuildersImpl only contains static definitions.\");\n\t}\n\n\tpublic static DefaultedList<Ingredient> getIngredients(String[] pattern, Char2ObjectMap<Ingredient> keys, int width, int height) {\n\t\tDefaultedList<Ingredient> ingredients = DefaultedList.ofSize(width * height, Ingredient.EMPTY);\n\t\tvar unusedKeys = new CharArraySet(keys.keySet());\n\t\tunusedKeys.remove(' ');\n", "\t\tfor (int i = 0; i < pattern.length; ++i) {\n\t\t\tfor (int j = 0; j < pattern[i].length(); ++j) {\n\t\t\t\tchar key = pattern[i].charAt(j);\n\t\t\t\tIngredient ingredient = keys.get(key);\n\n\t\t\t\tif (ingredient == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Pattern references symbol '\" + key + \"' but it's not defined in the key\");\n\t\t\t\t}\n\n\t\t\t\tunusedKeys.remove(key);\n\t\t\t\tingredients.set(j + width * i, ingredient);\n\t\t\t}\n\t\t}\n", "\t\tif (!unusedKeys.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"Key defines symbols that aren't used in pattern: \" + unusedKeys);\n\t\t}\n\n\t\treturn ingredients;\n\t}\n\n\tpublic static StonecuttingRecipe stonecuttingRecipe(Identifier id, String group, Ingredient input, ItemStack output) {\n\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\n\t\treturn new StonecuttingRecipe(id, group, input, output);\n\t}\n", "\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\n\t\treturn new StonecuttingRecipe(id, group, input, output);\n\t}\n\n\tpublic static SmeltingRecipe smeltingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new SmeltingRecipe(id, group, input, output, experience, cookTime);\n\t}\n", "\tpublic static BlastingRecipe blastingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new BlastingRecipe(id, group, input, output, experience, cookTime);\n\t}\n\n\tpublic static SmokingRecipe smokingRecipe(Identifier id, String group, Ingredient input, ItemStack output, float experience, int cookTime) {\n\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new SmokingRecipe(id, group, input, output, experience, cookTime);\n\t}\n", "\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new SmokingRecipe(id, group, input, output, experience, cookTime);\n\t}\n\n\tpublic static CampfireCookingRecipe campfireCookingRecipe(Identifier id, String group, Ingredient input,\n\t\t\tItemStack output, float experience, int cookTime) {\n\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new CampfireCookingRecipe(id, group, input, output, experience, cookTime);\n\t}\n}\n", "\t\tif (input == Ingredient.EMPTY) throw new IllegalArgumentException(\"Input cannot be empty.\");\n\t\tif (cookTime < 0) throw new IllegalArgumentException(\"Cook time must be equal or greater than 0\");\n\n\t\treturn new CampfireCookingRecipe(id, group, input, output, experience, cookTime);\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/ModifyRecipeHandlerImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.util.Map;\n\nimport org.jetbrains.annotations.ApiStatus;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;", "import net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\nimport ho.artisan.lib.recipe.api.RecipeLoadingEvents;\n\n@ApiStatus.Internal\nfinal class ModifyRecipeHandlerImpl extends BasicRecipeHandlerImpl implements RecipeLoadingEvents.ModifyRecipesCallback.RecipeHandler {\n\tint counter = 0;\n\n\tModifyRecipeHandlerImpl(RecipeManager recipeManager, Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes,", "\n\tModifyRecipeHandlerImpl(RecipeManager recipeManager, Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes,\n\t\t\tMap<Identifier, Recipe<?>> globalRecipes) {\n\t\tsuper(recipeManager, recipes, globalRecipes);\n\t}\n\n\tprivate void add(Recipe<?> recipe) {\n\t\tMap<Identifier, Recipe<?>> type = this.recipes.get(recipe.getType());\n\n\t\tif (type == null) {\n\t\t\tthrow new IllegalStateException(\"The given recipe \" + recipe.getId()\n\t\t\t\t\t+ \" does not have its recipe type \" + recipe.getType() + \" in the recipe manager.\");\n\t\t}\n\n\t\ttype.put(recipe.getId(), recipe);\n\t\tthis.globalRecipes.put(recipe.getId(), recipe);\n\t}\n\n\t@Override", "\n\t\tif (type == null) {\n\t\t\tthrow new IllegalStateException(\"The given recipe \" + recipe.getId()\n\t\t\t\t\t+ \" does not have its recipe type \" + recipe.getType() + \" in the recipe manager.\");\n\t\t}\n\n\t\ttype.put(recipe.getId(), recipe);\n\t\tthis.globalRecipes.put(recipe.getId(), recipe);\n\t}\n\n\t@Override", "\tpublic void replace(Recipe<?> recipe) {\n\t\tRecipeType<?> oldType = this.getTypeOf(recipe.getId());\n\n\t\tif (oldType == null) {\n\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Add new recipe {} with type {} in modify phase.\", recipe.getId(), recipe.getType());\n\t\t\t}\n\n\t\t\tthis.add(recipe);\n\t\t} else if (oldType == recipe.getType()) {\n\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Replace recipe {} with same type {} in modify phase.\", recipe.getId(), recipe.getType());\n\t\t\t}\n\n\t\t\tthis.recipes.get(oldType).put(recipe.getId(), recipe);\n\t\t\tthis.globalRecipes.put(recipe.getId(), recipe);\n\t\t} else {", "\t\t} else if (oldType == recipe.getType()) {\n\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Replace recipe {} with same type {} in modify phase.\", recipe.getId(), recipe.getType());\n\t\t\t}\n\n\t\t\tthis.recipes.get(oldType).put(recipe.getId(), recipe);\n\t\t\tthis.globalRecipes.put(recipe.getId(), recipe);\n\t\t} else {\n\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Replace new recipe {} with type {} (and old type {}) in modify phase.\",\n\t\t\t\t\t\trecipe.getId(), recipe.getType(), oldType);\n\t\t\t}\n\n\t\t\tthis.recipes.get(oldType).remove(recipe.getId());\n\t\t\tthis.add(recipe);\n\t\t}\n\n\t\tthis.counter++;\n\t}\n}\n", "\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Replace new recipe {} with type {} (and old type {}) in modify phase.\",\n\t\t\t\t\t\trecipe.getId(), recipe.getType(), oldType);\n\t\t\t}\n\n\t\t\tthis.recipes.get(oldType).remove(recipe.getId());\n\t\t\tthis.add(recipe);\n\t\t}\n\n\t\tthis.counter++;\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/RegisterRecipeHandlerImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.gson.JsonElement;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;", "import net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\nimport ho.artisan.lib.recipe.api.RecipeLoadingEvents;\n\nfinal class RegisterRecipeHandlerImpl implements RecipeLoadingEvents.AddRecipesCallback.RecipeHandler {\n\tprivate final Map<Identifier, JsonElement> resourceMap;\n\tprivate final Map<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap;\n\tprivate final ImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder;", "\tprivate final Map<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap;\n\tprivate final ImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder;\n\tint registered = 0;\n\n\tRegisterRecipeHandlerImpl(Map<Identifier, JsonElement> resourceMap,\n\t\t\tMap<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap,\n\t\t\tImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder) {\n\t\tthis.resourceMap = resourceMap;\n\t\tthis.builderMap = builderMap;\n\t\tthis.globalRecipeMapBuilder = globalRecipeMapBuilder;", "\t\tthis.builderMap = builderMap;\n\t\tthis.globalRecipeMapBuilder = globalRecipeMapBuilder;\n\t}\n\n\tprivate void register(Recipe<?> recipe) {\n\t\tImmutableMap.Builder<Identifier, Recipe<?>> recipeBuilder =\n\t\t\t\tthis.builderMap.computeIfAbsent(recipe.getType(), o -> ImmutableMap.builder());\n\t\trecipeBuilder.put(recipe.getId(), recipe);\n\t\tthis.globalRecipeMapBuilder.put(recipe.getId(), recipe);\n\t\tthis.registered++;", "\t\tthis.globalRecipeMapBuilder.put(recipe.getId(), recipe);\n\t\tthis.registered++;\n\n\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\tRecipeManagerImpl.LOGGER.info(\"Added recipe {} with type {} in register phase.\", recipe.getId(), recipe.getType());\n\t\t}\n\t}\n\n\tvoid tryRegister(Recipe<?> recipe) {\n\t\tif (!this.resourceMap.containsKey(recipe.getId())) {\n\t\t\tthis.register(recipe);\n\t\t}\n\t}\n\n\t@Override", "\t\tif (!this.resourceMap.containsKey(recipe.getId())) {\n\t\t\tthis.register(recipe);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void register(Identifier id, Function<Identifier, Recipe<?>> factory) {\n\t\t// Add the recipe only if nothing already provides the recipe.\n\t\tif (!this.resourceMap.containsKey(id)) {\n\t\t\tvar recipe = factory.apply(id);\n", "\t\tif (!this.resourceMap.containsKey(id)) {\n\t\t\tvar recipe = factory.apply(id);\n\n\t\t\tif (!id.equals(recipe.getId())) {\n\t\t\t\tthrow new IllegalStateException(\"The recipe \" + recipe.getId() + \" tried to be registered as \" + id);\n\t\t\t}\n\n\t\t\tthis.register(recipe);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/RemoveRecipeHandlerImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.util.Map;\nimport java.util.function.Predicate;\n\nimport org.jetbrains.annotations.ApiStatus;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;", "import net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\n\nimport ho.artisan.lib.recipe.api.RecipeLoadingEvents;\n\n@ApiStatus.Internal\nfinal class RemoveRecipeHandlerImpl extends BasicRecipeHandlerImpl implements RecipeLoadingEvents.RemoveRecipesCallback.RecipeHandler {\n\tint counter = 0;\n", "\tint counter = 0;\n\n\tRemoveRecipeHandlerImpl(RecipeManager recipeManager, Map<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes,\n\t\t\tMap<Identifier, Recipe<?>> globalRecipes) {\n\t\tsuper(recipeManager, recipes, globalRecipes);\n\t}\n\n\t@Override\n\tpublic void remove(Identifier id) {\n\t\tRecipeType<?> recipeType = this.getTypeOf(id);\n", "\tpublic void remove(Identifier id) {\n\t\tRecipeType<?> recipeType = this.getTypeOf(id);\n\n\t\tif (recipeType == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.recipes.get(recipeType).remove(id) != null) {\n\t\t\tthis.globalRecipes.remove(id);\n\n\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Remove recipe {} with type {} in removal phase.\", id, recipeType);\n\t\t\t}\n\n\t\t\tthis.counter++;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Recipe<?>> void removeIf(RecipeType<T> recipeType, Predicate<T> recipeRemovalPredicate) {\n\t\tthis.removeIf((Map<Identifier, T>) this.recipes.get(recipeType), recipeRemovalPredicate);\n\t}\n\n\t@Override", "\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Remove recipe {} with type {} in removal phase.\", id, recipeType);\n\t\t\t}\n\n\t\t\tthis.counter++;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Recipe<?>> void removeIf(RecipeType<T> recipeType, Predicate<T> recipeRemovalPredicate) {\n\t\tthis.removeIf((Map<Identifier, T>) this.recipes.get(recipeType), recipeRemovalPredicate);\n\t}\n\n\t@Override", "\tpublic void removeIf(Predicate<Recipe<?>> recipeRemovalPredicate) {\n\t\tfor (var entry : this.getRecipes().entrySet()) {\n\t\t\tthis.removeIf(entry.getValue(), recipeRemovalPredicate);\n\t\t}\n\t}\n\n\tprivate <T extends Recipe<?>> void removeIf(Map<Identifier, T> recipeMap, Predicate<T> recipeRemovalPredicate) {\n\t\tif (recipeMap == null) return;\n\n\t\tvar it = recipeMap.entrySet().iterator();\n", "\t\twhile (it.hasNext()) {\n\t\t\tvar entry = it.next();\n\n\t\t\tif (recipeRemovalPredicate.test(entry.getValue())) {\n\t\t\t\tif (RecipeManagerImpl.DEBUG_MODE) {\n\t\t\t\t\tRecipeManagerImpl.LOGGER.info(\"Remove recipe {} with type {} in removal phase.\", entry.getKey(), entry.getValue().getType());\n\t\t\t\t}\n\n\t\t\t\tthis.globalRecipes.remove(entry.getKey());\n\t\t\t\tit.remove();\n\t\t\t\tthis.counter++;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/RecipeManagerImpl.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Map;\n", "import java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.internal.Streams;\nimport com.google.gson.stream.JsonWriter;\nimport com.mojang.logging.LogUtils;\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\nimport net.fabricmc.loader.api.FabricLoader;", "import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\nimport net.fabricmc.loader.api.FabricLoader;\nimport org.jetbrains.annotations.ApiStatus;\nimport org.slf4j.Logger;\n\nimport net.minecraft.recipe.Recipe;\nimport net.minecraft.recipe.RecipeManager;\nimport net.minecraft.recipe.RecipeType;\nimport net.minecraft.util.Identifier;\nimport net.minecraft.util.registry.Registry;", "import net.minecraft.util.Identifier;\nimport net.minecraft.util.registry.Registry;\n\nimport ho.artisan.lib.recipe.api.RecipeLoadingEvents;\nimport ho.artisan.lib.recipe.api.serializer.FabricRecipeSerializer;\n\n@ApiStatus.Internal\npublic final class RecipeManagerImpl {\n\t/**\n\t * Stores the static recipes which are added to the {@link RecipeManager} when recipes are\n\t * loaded.\n\t */\n\tprivate static final Map<Identifier, Recipe<?>> STATIC_RECIPES = new Object2ObjectOpenHashMap<>();\n\tstatic final boolean DEBUG_MODE = Boolean.getBoolean(\"rip.recipe.debug\");\n\tprivate static final boolean DUMP_MODE = Boolean.getBoolean(\"rip.recipe.dump\");\n\tstatic final Logger LOGGER = LogUtils.getLogger();\n\n\tprivate RecipeManagerImpl() {\n\t\tthrow new UnsupportedOperationException(\"RecipeManagerImpl only contains static definitions.\");\n\t}\n", "\tpublic static void registerStaticRecipe(Recipe<?> recipe) {\n\t\tif (STATIC_RECIPES.putIfAbsent(recipe.getId(), recipe) != null) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot register \" + recipe.getId()\n\t\t\t\t\t+ \" as another recipe with the same identifier already exists.\");\n\t\t}\n\t}\n\n\tpublic static void apply(Map<Identifier, JsonElement> map,\n\t\t\tMap<RecipeType<?>, ImmutableMap.Builder<Identifier, Recipe<?>>> builderMap,\n\t\t\tImmutableMap.Builder<Identifier, Recipe<?>> globalRecipeMapBuilder) {\n\t\tvar handler = new RegisterRecipeHandlerImpl(map, builderMap, globalRecipeMapBuilder);\n\t\tRecipeLoadingEvents.ADD.invoker().addRecipes(handler);\n\t\tSTATIC_RECIPES.values().forEach(handler::tryRegister);\n\t\tLOGGER.info(\"Registered {} custom recipes.\", handler.registered);\n\t}\n", "\tpublic static void applyModifications(RecipeManager recipeManager,\n\t\t\tMap<RecipeType<?>, Map<Identifier, Recipe<?>>> recipes,\n\t\t\tMap<Identifier, Recipe<?>> globalRecipes) {\n\t\tvar handler = new ModifyRecipeHandlerImpl(recipeManager, recipes, globalRecipes);\n\t\tRecipeLoadingEvents.MODIFY.invoker().modifyRecipes(handler);\n\t\tLOGGER.info(\"Modified {} recipes.\", handler.counter);\n\n\t\tvar removeHandler = new RemoveRecipeHandlerImpl(recipeManager, recipes, globalRecipes);\n\t\tRecipeLoadingEvents.REMOVE.invoker().removeRecipes(removeHandler);\n\t\tLOGGER.info(\"Removed {} recipes.\", removeHandler.counter);\n", "\t\tif (DUMP_MODE) {\n\t\t\tdump(globalRecipes);\n\t\t}\n\n\t\tif (DEBUG_MODE || FabricLoader.getInstance().isDevelopmentEnvironment()) {\n\t\t\tfor (var serializerEntry : Registry.RECIPE_SERIALIZER.getEntrySet()) {\n\t\t\t\tif (!(serializerEntry.getValue() instanceof FabricRecipeSerializer)) {\n\t\t\t\t\tLOGGER.warn(\n\t\t\t\t\t\t\t\"Recipe serializer {} doesn't implement QuiltRecipeSerializer. For full compatibility, the interface should be implemented.\",\n\t\t\t\t\t\t\tserializerEntry.getKey().getValue()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static void dump(Map<Identifier, Recipe<?>> recipes) {\n\t\tPath debugPath = Paths.get(\"debug\", \"rip\", \"recipe\").normalize();\n", "\t\tif (!Files.exists(debugPath)) {\n\t\t\ttry {\n\t\t\t\tFiles.createDirectories(debugPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(\"Failed to create debug directory for recipe dumping.\", e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (Recipe<?> recipe : recipes.values()) {\n\t\t\tif (!(recipe.getSerializer() instanceof FabricRecipeSerializer)) continue;\n\n\t\t\tvar serializer = (FabricRecipeSerializer<Recipe<?>>) recipe.getSerializer();\n\t\t\tJsonObject serialized = serializer.toJson(recipe);\n\n\t\t\tPath path = debugPath.resolve(recipe.getId().getNamespace() + \"/recipes/\" + recipe.getId().getPath() + \".json\");\n\t\t\tPath parent = path.getParent();\n", "\t\tfor (Recipe<?> recipe : recipes.values()) {\n\t\t\tif (!(recipe.getSerializer() instanceof FabricRecipeSerializer)) continue;\n\n\t\t\tvar serializer = (FabricRecipeSerializer<Recipe<?>>) recipe.getSerializer();\n\t\t\tJsonObject serialized = serializer.toJson(recipe);\n\n\t\t\tPath path = debugPath.resolve(recipe.getId().getNamespace() + \"/recipes/\" + recipe.getId().getPath() + \".json\");\n\t\t\tPath parent = path.getParent();\n\n\t\t\tif (!Files.exists(parent)) {\n\t\t\t\ttry {\n\t\t\t\t\tFiles.createDirectories(parent);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(\"Failed to create parent recipe directory {}. Cannot dump recipe {}.\",\n\t\t\t\t\t\t\tparent, recipe.getId(), e);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar stringWriter = new StringWriter();\n\t\t\tvar jsonWriter = new JsonWriter(stringWriter);\n\t\t\tjsonWriter.setLenient(true);\n\t\t\tjsonWriter.setIndent(\"  \");\n", "\t\t\tif (!Files.exists(parent)) {\n\t\t\t\ttry {\n\t\t\t\t\tFiles.createDirectories(parent);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(\"Failed to create parent recipe directory {}. Cannot dump recipe {}.\",\n\t\t\t\t\t\t\tparent, recipe.getId(), e);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar stringWriter = new StringWriter();\n\t\t\tvar jsonWriter = new JsonWriter(stringWriter);\n\t\t\tjsonWriter.setLenient(true);\n\t\t\tjsonWriter.setIndent(\"  \");\n", "\t\t\ttry {\n\t\t\t\tStreams.write(serialized, jsonWriter);\n\t\t\t\tFiles.writeString(path, stringWriter.toString(),\n\t\t\t\t\t\tStandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(\"Failed to write JSON for recipe {}.\", recipe.getId(), e);\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tjsonWriter.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(\"Failed to close JSON writer for recipe {}.\", recipe.getId(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/ho/artisan/lib/recipe/impl/ImmutableMapBuilderUtil.java", "chunked_list": ["/*\n * Copyright 2022 QuiltMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ho.artisan.lib.recipe.impl;\n", "package ho.artisan.lib.recipe.impl;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.mojang.logging.LogUtils;\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;", "import com.mojang.logging.LogUtils;\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\nimport org.jetbrains.annotations.ApiStatus;\nimport org.slf4j.Logger;\n\n@ApiStatus.Internal\npublic final class ImmutableMapBuilderUtil {\n\tprivate static final Logger LOGGER = LogUtils.getLogger();\n\tprivate static final MethodHandle ENTRIES_GETTER;\n\tprivate static final MethodHandle SIZE_GETTER;\n\n\tprivate ImmutableMapBuilderUtil() {\n\t\tthrow new UnsupportedOperationException(\"Someone tampered with the universe.\");\n\t}\n\n\tstatic {", "\t\ttry {\n\t\t\tField field = ImmutableMap.Builder.class.getDeclaredField(\"entries\");\n\t\t\tfield.setAccessible(true);\n\t\t\tENTRIES_GETTER = MethodHandles.lookup().unreflectGetter(field);\n\t\t\tfield = ImmutableMap.Builder.class.getDeclaredField(\"size\");\n\t\t\tfield.setAccessible(true);\n\t\t\tSIZE_GETTER = MethodHandles.lookup().unreflectGetter(field);\n\t\t} catch (NoSuchFieldException | IllegalAccessException e) {\n\t\t\tLOGGER.error(\"Could not access ImmutableMap$Builder entries or size fields, which is necessary for the Recipe API.\");\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Builds a mutable map from an immutable map.\n\t * <p>This exists only because a builder will throw if a value is added 2 times. And copying a map is a bit bad.</p>\n\t *\n\t * @param builder the builder\n\t * @param <K>     the key type\n\t * @param <V>     the value type\n\t * @return a mutable map\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <K, V> Map<K, V> specialBuild(ImmutableMap.Builder<K, V> builder) {", "\t\ttry {\n\t\t\tvar entries = (Map.Entry<K, V>[]) ENTRIES_GETTER.invoke(builder);\n\t\t\tint size = (int) SIZE_GETTER.invoke(builder);\n\t\t\tvar map = new Object2ObjectOpenHashMap<K, V>(size);\n\n\t\t\tfor (var entry : entries) {\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmap.put(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\treturn map;\n\t\t} catch (Throwable throwable) {\n\t\t\tLOGGER.error(\"Could not get values of ImmutableMap$Builder entries or size fields.\");\n\t\t\tthrow new IllegalStateException(throwable);\n\t\t}\n\t}\n}\n"]}
