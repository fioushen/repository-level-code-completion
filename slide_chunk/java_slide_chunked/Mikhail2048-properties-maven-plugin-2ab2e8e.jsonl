{"filename": "src/test/java/io/polivakha/mojo/properties/WriteActiveProfilePropertiesMojoTest.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.project.MavenProject;\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.BufferedReader;\nimport java.nio.file.Files;", "import java.io.BufferedReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;", "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class WriteActiveProfilePropertiesMojoTest {\n\n    private MavenProject mavenProject;\n    private WriteActiveProfileProperties writeActiveProfileProperties;\n\n    @Before\n    public void setUp() {\n        mavenProject = new MavenProject();\n        writeActiveProfileProperties = new WriteActiveProfileProperties();\n        writeActiveProfileProperties.setProject(mavenProject);\n    }\n\n    @Test", "    public void setUp() {\n        mavenProject = new MavenProject();\n        writeActiveProfileProperties = new WriteActiveProfileProperties();\n        writeActiveProfileProperties.setProject(mavenProject);\n    }\n\n    @Test\n    public void givenSystemPropertiesBySomeProfile_whenWritePropertiesWithSortASC_thenPropertiesInFileASC() throws Exception {\n        Path temp = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(temp.toString(), \"properties-from-pom.properties\"));\n        writeActiveProfileProperties.setOutputFile(file.toFile());\n        writeActiveProfileProperties.setSort(true);\n        Profile profile = new Profile();\n        profile.setId(\"someProfile\");\n        Properties properties = new Properties();\n        properties.setProperty(\"some.version\", \"1234\");\n        properties.setProperty(\"another.version\", \"9098\");\n        properties.setProperty(\"other.version\", \"8080\");\n        profile.setProperties(properties);\n        mavenProject.setActiveProfiles(List.of(profile));\n\n        writeActiveProfileProperties.execute();\n\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(file)) {\n            assertTrue(bufferedReader.readLine().contains(\"#\"));\n            assertEquals(\"another.version=9098\", bufferedReader.readLine());\n            assertEquals(\"other.version=8080\", bufferedReader.readLine());\n            assertEquals(\"some.version=1234\", bufferedReader.readLine());\n        }\n    }\n\n    @Test", "    public void givenSystemPropertiesBySomeProfile_whenWritePropertiesWithoutSort_thenPropertiesInFileInOrderOfAddition() throws Exception {\n        Path temp = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(temp.toString(), \"properties-from-pom.properties\"));\n        writeActiveProfileProperties.setOutputFile(file.toFile());\n        writeActiveProfileProperties.setSort(false);\n        Profile profile = new Profile();\n        profile.setId(\"someProfile\");\n        Properties properties = new Properties();\n        properties.setProperty(\"some.version\", \"1234\");\n        properties.setProperty(\"another.version\", \"9098\");\n        properties.setProperty(\"other.version\", \"8080\");\n        profile.setProperties(properties);\n        mavenProject.setActiveProfiles(List.of(profile));\n\n        writeActiveProfileProperties.execute();\n\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(file)) {\n            Assertions.assertThat(bufferedReader.lines()).containsAll(getPropertiesList(properties));\n        }\n    }\n\n    private List<String> getPropertiesList(Properties properties) {\n        return properties.entrySet().stream()\n                .map(entry -> entry.getKey() + \"=\" + entry.getValue())\n                .collect(Collectors.toList());\n    }\n}\n"]}
{"filename": "src/test/java/io/polivakha/mojo/properties/ReadPropertiesMojoTest.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;", "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;", "import org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class ReadPropertiesMojoTest {\n    private static final String NEW_LINE = System.lineSeparator();\n\n    private MavenProject projectStub;\n    private ReadPropertiesMojo readPropertiesMojo;\n\n    @Before", "    public void setUp() {\n        projectStub = new MavenProject();\n        readPropertiesMojo = new ReadPropertiesMojo();\n        readPropertiesMojo.setProject( projectStub );\n    }\n\n    @Test\n    public void givenTwoPropertiesFiles_whenResolvingExistingProperties_thenMavenProjectContainsThem() throws IOException, MojoExecutionException, MojoFailureException {\n        Path tempDirectory = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(tempDirectory.toString(), \"temp-file.properties\"));\n\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file.toFile()))) {\n            writer.write(\"some.version=1234\\n\");\n            writer.write(\"another.version=9098\");\n        }\n\n        readPropertiesMojo.setIncludes(new String[]{Path.of(tempDirectory.toString(), \"*.properties\").toString()});\n        readPropertiesMojo.execute();\n\n        String firstValue = projectStub.getProperties().getProperty(\"some.version\");\n        String secondValue = projectStub.getProperties().getProperty(\"another.version\");\n        String nonExistingProperty = projectStub.getProperties().getProperty(\"non.existing.version\");\n\n        Assertions.assertThat(firstValue).isEqualTo(\"1234\");\n        Assertions.assertThat(secondValue).isEqualTo(\"9098\");\n        Assertions.assertThat(nonExistingProperty).isNull();\n    }\n\n    @Test", "    public void givenSeveralPropertyFiles_whenReadingFromBoth_thenPropertiesFromAllFilesRead() throws IOException, MojoExecutionException, MojoFailureException {\n        Path tempDirectory = Files.createTempDirectory(\"mytmp\");\n        Path firstFile = Files.createFile(Paths.get(tempDirectory.toString(), \"first.properties\"));\n        Path secondFile = Files.createFile(Paths.get(tempDirectory.toString(), \"second.properties\"));\n\n        try (FileWriter writer = new FileWriter(firstFile.toFile())) {\n            writer.write(\"first.version=1.0.1\\n\");\n            writer.write(\"second.version=1.4.2\");\n        }\n\n        try (FileWriter writer = new FileWriter(secondFile.toFile())) {\n            writer.write(\"third.version=5.8.8\\n\");\n        }\n\n        readPropertiesMojo.setIncludes(new String[]{Path.of(tempDirectory.toString(), \"*.properties\").toString()});\n        readPropertiesMojo.execute();\n\n        String one = projectStub.getProperties().getProperty(\"first.version\");\n        String two = projectStub.getProperties().getProperty(\"second.version\");\n        String three = projectStub.getProperties().getProperty(\"third.version\");\n\n        Assertions.assertThat(one).isEqualTo(\"1.0.1\");\n        Assertions.assertThat(two).isEqualTo(\"1.4.2\");\n        Assertions.assertThat(three).isEqualTo(\"5.8.8\");\n    }\n\n    @Test", "    public void givenTwoPropertiesFileWithTwoPatterns_whenResolvingExistingProperties_thenLastPatternFilesTakePrecedence() throws IOException, MojoExecutionException, MojoFailureException {\n        Path parentFirst = Files.createTempDirectory(\"parent1\");\n        Path parenSecond = Files.createTempDirectory(\"parent2\");\n\n        Path firstFile = Files.createFile(Paths.get(parentFirst.toString(), \"first.properties\"));\n        Path secondFile = Files.createFile(Paths.get(parenSecond.toString(), \"second.properties\"));\n\n        try (FileWriter writer = new FileWriter(firstFile.toFile())) {\n            writer.write(\"first.version=1.0.1\\n\");\n            writer.write(\"second.version=1.4.2\");\n        }\n\n        try (FileWriter writer = new FileWriter(secondFile.toFile())) {\n            writer.write(\"third.version=5.8.8\\n\");\n            writer.write(\"first.version=0.0.1\\n\");\n        }\n\n        readPropertiesMojo.setIncludes(\n          new String[]{\n            Path.of(parentFirst.toString(), \"*.properties\").toString(),\n            Path.of(parenSecond.toString(), \"*.properties\").toString()\n          }\n        );\n\n        readPropertiesMojo.execute();\n\n        String one = projectStub.getProperties().getProperty(\"first.version\");\n        String two = projectStub.getProperties().getProperty(\"second.version\");\n        String three = projectStub.getProperties().getProperty(\"third.version\");\n\n        Assertions.assertThat(one).isEqualTo(\"0.0.1\");\n        Assertions.assertThat(two).isEqualTo(\"1.4.2\");\n        Assertions.assertThat(three).isEqualTo(\"5.8.8\");\n    }\n\n    @Test", "    public void readPropertiesWithoutKeyprefix() throws Exception {\n        try ( FileReader fr = new FileReader( getPropertyFileForTesting() ) )\n        {\n            // load properties directly for comparison later\n            Properties testProperties = new Properties();\n            testProperties.load( fr );\n\n            // do the work\n            readPropertiesMojo.setFiles( new File[] {getPropertyFileForTesting()} );\n            readPropertiesMojo.execute();\n\n            // check results\n            Properties projectProperties = projectStub.getProperties();\n            assertNotNull( projectProperties );\n            // it should not be empty\n            assertNotEquals( 0, projectProperties.size() );\n\n            // we are not adding prefix, so properties should be same as in file\n            assertEquals( testProperties.size(), projectProperties.size() );\n            assertEquals( testProperties, projectProperties );\n        }\n    }\n\n    @Test", "    public void readPropertiesWithKeyprefix() throws Exception {\n        String keyPrefix = \"testkey-prefix.\";\n\n        try ( FileReader fs1 = new FileReader( getPropertyFileForTesting( keyPrefix ) );\n              FileReader fs2 = new FileReader( getPropertyFileForTesting() ) ) {\n\n            Properties testPropertiesWithoutPrefix = new Properties();\n            testPropertiesWithoutPrefix.load( fs2 );\n\n            // do the work\n            readPropertiesMojo.setKeyPrefix( keyPrefix );\n            readPropertiesMojo.setFiles( new File[] {getPropertyFileForTesting()} );\n            readPropertiesMojo.execute();\n\n            // load properties directly and add prefix for comparison later\n            Properties testPropertiesPrefix = new Properties();\n            testPropertiesPrefix.load( fs1 );\n\n            // check results\n            Properties projectProperties = projectStub.getProperties();\n            assertNotNull( projectProperties );\n            // it should not be empty\n            assertNotEquals( 0, projectProperties.size() );\n\n            // we are adding prefix, so prefix properties should be same as in projectProperties\n            assertEquals( testPropertiesPrefix.size(), projectProperties.size() );\n            assertEquals( testPropertiesPrefix, projectProperties );\n\n            // properties with and without prefix shouldn't be same\n            assertNotEquals( testPropertiesPrefix, testPropertiesWithoutPrefix );\n            assertNotEquals( testPropertiesWithoutPrefix, projectProperties );\n        }\n    }\n\n    private File getPropertyFileForTesting() throws IOException {\n        return getPropertyFileForTesting( null );\n    }\n\n    private File getPropertyFileForTesting( String keyPrefix ) throws IOException {\n        File f = File.createTempFile( \"prop-test\", \".properties\" );\n        f.deleteOnExit();\n\n        String prefix = keyPrefix == null ? \"\" : keyPrefix;\n\n        try (FileWriter writer = new FileWriter( f )) {\n            writer.write( prefix + \"test.property1=value1\" + NEW_LINE );\n            writer.write( prefix + \"test.property2=value2\" + NEW_LINE );\n            writer.write( prefix + \"test.property3=value3\" + NEW_LINE );\n            writer.flush();\n        }\n\n        return f;\n    }\n}\n"]}
{"filename": "src/test/java/io/polivakha/mojo/properties/WriteProjectPropertiesMojoTest.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\nimport org.apache.maven.project.MavenProject;\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.BufferedReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;", "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class WriteProjectPropertiesMojoTest {\n\n    private MavenProject mavenProject;\n    private WriteProjectProperties writeProjectProperties;\n\n    @Before", "import static org.junit.Assert.assertTrue;\n\npublic class WriteProjectPropertiesMojoTest {\n\n    private MavenProject mavenProject;\n    private WriteProjectProperties writeProjectProperties;\n\n    @Before\n    public void setUp() {\n        mavenProject = new MavenProject();\n        writeProjectProperties = new WriteProjectProperties();\n        writeProjectProperties.setProject(mavenProject);\n    }\n\n\n    @Test", "    public void setUp() {\n        mavenProject = new MavenProject();\n        writeProjectProperties = new WriteProjectProperties();\n        writeProjectProperties.setProject(mavenProject);\n    }\n\n\n    @Test\n    public void givenSystemProperties_whenWritePropertiesWithSortASC_thenPropertiesInFileASC() throws Exception {\n        Path temp = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(temp.toString(), \"properties-from-pom.properties\"));\n        writeProjectProperties.setOutputFile(file.toFile());\n        writeProjectProperties.setSort(true);\n        mavenProject.getProperties().setProperty(\"some.version\", \"1234\");\n        mavenProject.getProperties().setProperty(\"another.version\", \"9098\");\n        mavenProject.getProperties().setProperty(\"other.version\", \"8080\");\n\n        writeProjectProperties.execute();\n\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(file)) {\n            assertTrue(bufferedReader.readLine().contains(\"#\"));\n            assertEquals(\"another.version=9098\", bufferedReader.readLine());\n            assertEquals(\"other.version=8080\", bufferedReader.readLine());\n            assertEquals(\"some.version=1234\", bufferedReader.readLine());\n        }\n\n    }\n\n    @Test", "    public void givenSystemProperties_whenWritePropertiesWithSortASC_thenPropertiesInFileASC() throws Exception {\n        Path temp = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(temp.toString(), \"properties-from-pom.properties\"));\n        writeProjectProperties.setOutputFile(file.toFile());\n        writeProjectProperties.setSort(true);\n        mavenProject.getProperties().setProperty(\"some.version\", \"1234\");\n        mavenProject.getProperties().setProperty(\"another.version\", \"9098\");\n        mavenProject.getProperties().setProperty(\"other.version\", \"8080\");\n\n        writeProjectProperties.execute();\n\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(file)) {\n            assertTrue(bufferedReader.readLine().contains(\"#\"));\n            assertEquals(\"another.version=9098\", bufferedReader.readLine());\n            assertEquals(\"other.version=8080\", bufferedReader.readLine());\n            assertEquals(\"some.version=1234\", bufferedReader.readLine());\n        }\n\n    }\n\n    @Test", "    public void givenSystemProperties_whenWritePropertiesWithoutSort_thenPropertiesInFileInOrderOfAddition() throws Exception {\n        Path temp = Files.createTempDirectory(\"mytmp\");\n        Path file = Files.createFile(Paths.get(temp.toString(), \"properties-from-pom.properties\"));\n        writeProjectProperties.setOutputFile(file.toFile());\n        mavenProject.getProperties().setProperty(\"some.version\", \"1234\");\n        mavenProject.getProperties().setProperty(\"another.version\", \"9098\");\n        mavenProject.getProperties().setProperty(\"other.version\", \"8080\");\n\n        writeProjectProperties.execute();\n\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(file)) {\n            Assertions.assertThat(bufferedReader.lines()).containsAll(getPropertiesList(mavenProject.getProperties()));\n        }\n    }\n\n    private List<String> getPropertiesList(Properties properties) {\n        return properties.entrySet().stream()\n                .map(entry -> entry.getKey() + \"=\" + entry.getValue())\n                .collect(Collectors.toList());\n    }\n}\n"]}
{"filename": "src/test/java/io/polivakha/mojo/properties/PropertyResolverTest.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.*;\n\nimport org.assertj.core.api.Assertions;", "\nimport org.assertj.core.api.Assertions;\nimport org.junit.Test;\n\nimport java.util.Properties;\n\nimport io.polivakha.mojo.properties.exception.PropertyCircularDefinitionException;\n\n/**\n * Tests the support class that produces concrete values from a set of properties.", "/**\n * Tests the support class that produces concrete values from a set of properties.\n */\npublic class PropertyResolverTest {\n    private final PropertyResolver resolver = new PropertyResolver();\n\n    @Test\n    public void validPlaceholderIsResolved() {\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${p2}\" );\n        properties.setProperty( \"p2\", \"value\" );\n\n        String value1 = resolver.getPropertyValue( \"p1\", properties, new Properties() );\n        String value2 = resolver.getPropertyValue( \"p2\", properties, new Properties() );\n\n        assertEquals( \"value\", value1 );\n        assertEquals( \"value\", value2 );\n    }\n\n    @Test", "    public void givenPropertyContainsPlaceholders_whenContainsTwoSamePlaceholders_thenResolved() {\n        Properties properties = new Properties();\n        properties.setProperty(\"p1\", \"First : ${p2}, second : ${p2}\");\n        properties.setProperty(\"p2\", \"value\");\n\n        String resolved = resolver.getPropertyValue(\"p1\", properties, new Properties());\n\n        Assertions.assertThat(resolved).isEqualTo(\"First : value, second : value\");\n    }\n\n    @Test", "    public void unknownPlaceholderIsLeftAsIs() {\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${p2}\" );\n        properties.setProperty( \"p2\", \"value\" );\n        properties.setProperty( \"p3\", \"${unknown}\" );\n\n        String value1 = resolver.getPropertyValue( \"p1\", properties, new Properties() );\n        String value2 = resolver.getPropertyValue( \"p2\", properties, new Properties() );\n        String value3 = resolver.getPropertyValue( \"p3\", properties, new Properties() );\n\n        assertEquals( \"value\", value1 );\n        assertEquals( \"value\", value2 );\n        assertEquals( \"${unknown}\", value3 );\n    }\n\n    @Test", "    public void multipleValuesAreResolved() {\n        Properties properties = new Properties();\n        properties.setProperty( \"hostname\", \"localhost\" );\n        properties.setProperty( \"port\", \"8080\" );\n        properties.setProperty( \"base.url\", \"http://${hostname}:${port}/\" );\n\n        String value = resolver.getPropertyValue( \"base.url\", properties, new Properties() );\n\n        assertEquals( \"http://localhost:8080/\", value );\n    }\n\n    @Test", "    public void malformedPlaceholderIsLeftAsIs() {\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${p2}\" );\n        properties.setProperty( \"p2\", \"value\" );\n        properties.setProperty( \"p4\", \"${malformed\" );\n\n        String value1 = resolver.getPropertyValue( \"p1\", properties, new Properties() );\n        String value2 = resolver.getPropertyValue( \"p2\", properties, new Properties() );\n        String value4 = resolver.getPropertyValue( \"p4\", properties, new Properties() );\n\n        assertEquals( \"value\", value1 );\n        assertEquals( \"value\", value2 );\n        assertEquals( \"${malformed\", value4 );\n    }\n\n    @Test", "    public void propertyDefinedAsItselfIsIllegal() {\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${p2}\" );\n        properties.setProperty( \"p2\", \"value\" );\n        properties.setProperty( \"p5\", \"${p5}\" );\n        properties.setProperty( \"p6\", \"${p7}\" );\n        properties.setProperty( \"p7\", \"${p6}\" );\n\n        String value1 = resolver.getPropertyValue( \"p1\", properties, new Properties() );\n        String value2 = resolver.getPropertyValue( \"p2\", properties, new Properties() );\n\n        Assertions.assertThat(value1).isEqualTo(\"value\");\n        Assertions.assertThat(value2).isEqualTo(\"value\");\n        Assertions.assertThatThrownBy(\n          () -> resolver.getPropertyValue( \"p5\", properties, new Properties() )\n        ).isInstanceOf(PropertyCircularDefinitionException.class);\n        Assertions.assertThatThrownBy(\n          () -> resolver.getPropertyValue( \"p6\", properties, new Properties() )\n        ).isInstanceOf(PropertyCircularDefinitionException.class);\n        Assertions.assertThatThrownBy(\n          () -> resolver.getPropertyValue( \"p7\", properties, new Properties() )\n        ).isInstanceOf(PropertyCircularDefinitionException.class);\n    }\n\n    @Test", "    public void valueIsObtainedFromSystemProperty() {\n        Properties saved = System.getProperties();\n        System.setProperty( \"system.property\", \"system.value\" );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${system.property}\" );\n\n        String value = resolver.getPropertyValue( \"p1\", properties, new Properties() );\n\n        try\n        {\n            assertEquals( \"system.value\", value );\n        }\n        finally\n        {\n            System.setProperties( saved );\n        }\n    }\n\n    @Test", "    public void valueIsObtainedFromEnvironmentProperty() {\n        Properties environment = new Properties();\n        environment.setProperty( \"PROPERTY\", \"env.value\" );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"p1\", \"${env.PROPERTY}\" );\n\n        String value = resolver.getPropertyValue( \"p1\", properties, environment );\n\n        assertEquals( \"env.value\", value );\n    }\n\n    @Test", "    public void missingPropertyIsTolerated() {\n        assertNull(resolver.getPropertyValue(\"non-existent\", new Properties(), null));\n    }\n}\n"]}
{"filename": "src/test/java/io/polivakha/mojo/properties/utils/PathParserTest.java", "chunked_list": ["package io.polivakha.mojo.properties.utils;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.Assertions;\nimport org.junit.Assert;\nimport org.junit.Test;", "import org.junit.Assert;\nimport org.junit.Test;\n\npublic class PathParserTest {\n\n    @Test\n    public void given2FilesInTargetDirectory_whenOnlyOneMatches_thenReturnThisOnlyFileInStream() throws IOException {\n        Path tempDirectory = Files.createTempDirectory(\"my_temp\");\n        Path propertiesFile = Path.of(tempDirectory.toString(), \"application.properties\");\n\n        Files.createFile(propertiesFile);\n        Files.createFile(Path.of(tempDirectory.toString(), \"config.yml\"));\n        Stream<Path> pathStream = new PathParser().streamFilesMatchingAntPath(Path.of(tempDirectory.toString(), \"*.properties\").toString());\n        Assertions.assertThat(pathStream).containsOnly(propertiesFile);\n    }\n\n    @Test", "    public void given3FilesInTargetDirectory_whenNoOneMatches_thenReturnEmptyStream() throws IOException {\n        Path tempDirectory = Files.createTempDirectory(\"my_temp\");\n        Files.createFile(Path.of(tempDirectory.toString(), \"application.yaml\"));\n        Files.createFile(Path.of(tempDirectory.toString(), \"another.xml\"));\n        Files.createFile(Path.of(tempDirectory.toString(), \"config.yml\"));\n\n        Stream<Path> pathStream = new PathParser().streamFilesMatchingAntPath(Path.of(tempDirectory.toString(), \"*.properties\").toString());\n        Assertions.assertThat(pathStream).isEmpty();\n    }\n\n    @Test", "    public void given4FilesInDifferentDirectories_whenTwoFilesMatchInDifferentDirectories_thenReturnStreamOfThese2Files() throws IOException {\n        Path parent = Files.createTempDirectory(\"parent\");\n        Path one = Files.createTempDirectory(parent, \"temp_one\");\n        Path two = Files.createTempDirectory(parent, \"temp_two\");\n\n        Files.createFile(Path.of(one.toString(), \"application.yaml\"));\n        Path first = Files.createFile(Path.of(one.toString(), \"another.properties\"));\n        Files.createFile(Path.of(two.toString(), \"config.yml\"));\n        Path second = Files.createFile(Path.of(two.toString(), \"application.properties\"));\n\n        Stream<Path> pathStream = new PathParser().streamFilesMatchingAntPath(Path.of(parent.toString(), \"**\", \"*.properties\").toString());\n        Assertions.assertThat(pathStream).containsOnly(first, second);\n    }\n\n    @Test", "    public void whenEmptyString_thenJustForwardSlashReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"\"));\n\n        Assert.assertEquals(\"/\", s);\n    }\n\n    @Test\n    public void whenOnlyFileNameIsMasked_thenReturnedPathToOwningDirectory() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/does/not/really/matter/*.properties\"));\n\n        Assert.assertEquals(\"/does/not/really/matter\", s);\n    }\n\n    @Test", "    public void whenTwoAsterisksSomewhereInTheMiddleProvidedWithFileNameMasked_thenReturnedPathUntilDoubleAsterisks() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/does/not/**/matter/*.properties\"));\n\n        Assert.assertEquals(\"/does/not\", s);\n    }\n\n    @Test\n    public void whenTwoAsterisksSomewhereInTheMiddleProvided_thenTheSamePathReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/does/not/**/matter\"));\n\n        Assert.assertEquals(\"/does/not\", s);\n    }\n\n    @Test", "    public void whenExactDirectoryProvided_thenTheSamePathReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/does/not/really/matter\"));\n\n        Assert.assertEquals(\"/does/not/really/matter\", s);\n    }\n\n    @Test\n    public void whenDoubleAsterisksAtRoot_thenJustForwardSlashReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/**/does/not/really/matter\"));\n\n        Assert.assertEquals(\"/\", s);\n    }\n\n    @Test", "    public void whenQuotationMarkEncounteredAtRoot_thenJustForwardSlashReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/th?t/does/not/really/matter\"));\n\n        Assert.assertEquals(\"/\", s);\n    }\n\n    @Test\n    public void whenGivenFirstDirectoryNameWithQuotationMark_thenJustForwardSlashReturned() {\n        String s = new PathParser().extractExactDirectory(Path.of(\"/**\"));\n\n        Assert.assertEquals(\"/\", s);\n    }\n\n    @Test", "    public void whenEmptyString_thenResultFalse() {\n        boolean result = new PathParser().containsAntTokens(\"\");\n        Assert.assertFalse(result);\n    }\n\n    @Test\n    public void whenGivenLiteralStringWithoutAntTokens_thenResultFalse() {\n        boolean result = new PathParser().containsAntTokens(\"just_some_string\");\n        Assert.assertFalse(result);\n    }\n\n    @Test", "    public void whenGivenStringWithQuotationMark_thenResultTrue() {\n        boolean result = new PathParser().containsAntTokens(\"just_s?me_string\");\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void whenGivenStringWithAsteriskMark_thenResultTrue() {\n        boolean result = new PathParser().containsAntTokens(\"just_some_*\");\n        Assert.assertTrue(result);\n    }\n\n    @Test", "    public void whenGivenStringContainingTwoAsterisk_thenResultTrue() {\n        boolean result = new PathParser().containsAntTokens(\"**\");\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void whenGivenStringContainingMultiple_thenResultTrue() {\n        boolean result = new PathParser().containsAntTokens(\"som?e.*\");\n        Assert.assertTrue(result);\n    }\n}"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/ReadPropertiesMojo.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file \n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, \n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n * KIND, either express or implied.  See the License for the \n * specific language governing permissions and limitations ", " * KIND, either express or implied.  See the License for the \n * specific language governing permissions and limitations \n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.List;", "import java.nio.file.Path;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;", "import org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.util.cli.CommandLineUtils;\n\nimport io.polivakha.mojo.properties.models.FileResource;\nimport io.polivakha.mojo.properties.models.Resource;\nimport io.polivakha.mojo.properties.models.UrlResource;", "import io.polivakha.mojo.properties.models.Resource;\nimport io.polivakha.mojo.properties.models.UrlResource;\nimport io.polivakha.mojo.properties.utils.PathParser;\n\n/**\n * The read-project-properties goal reads property files and URLs and stores the properties as project properties. It\n * serves as an alternate to specifying properties in pom.xml. It is especially useful when making properties defined in\n * a runtime resource available at build time.\n *\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>", " *\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>\n * @author <a href=\"mailto:Krystian.Nowak@gmail.com\">Krystian Nowak</a>\n * @author Mikhail Polivakha\n */\n@Mojo( name = \"read-project-properties\", defaultPhase = LifecyclePhase.NONE, threadSafe = true )\npublic class ReadPropertiesMojo extends AbstractMojo {\n\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * The properties files that will be used when reading properties.\n     */\n    @Parameter\n    private File[] files = new File[0];\n\n    @Parameter(name = \"includes\", required = false, alias = \"includes\")\n    private String[] includes = new String[0];\n\n    private final PathParser pathParser;\n\n    public ReadPropertiesMojo() {\n        this.pathParser = new PathParser();\n    }\n\n    /**\n     * @param files The files to set for tests.\n     */", "    public void setFiles( File[] files ) {\n        if (files == null) {\n            this.files = new File[0];\n        } else {\n            this.files = new File[files.length];\n            System.arraycopy( files, 0, this.files, 0, files.length );\n        }\n    }\n\n    public void setIncludes(String[] includes) {\n        this.includes = includes;\n    }\n\n    /**\n     * The URLs that will be used when reading properties. These may be non-standard URLs of the form\n     * <code>classpath:com/company/resource.properties</code>. Note that the type is not <code>URL</code> for this\n     * reason and therefore will be explicitly checked by this Mojo.\n     */\n    @Parameter\n    private String[] urls = new String[0];\n\n    /**\n     * If the plugin should be quiet if any of the files was not found\n     */\n    @Parameter( defaultValue = \"false\" )\n    private boolean quiet;\n\n    /**\n     * Prefix that will be added before name of each property.\n     * Can be useful for separating properties with same name from different files.\n     */\n    @Parameter\n    private String keyPrefix = null;\n", "    public void setIncludes(String[] includes) {\n        this.includes = includes;\n    }\n\n    /**\n     * The URLs that will be used when reading properties. These may be non-standard URLs of the form\n     * <code>classpath:com/company/resource.properties</code>. Note that the type is not <code>URL</code> for this\n     * reason and therefore will be explicitly checked by this Mojo.\n     */\n    @Parameter\n    private String[] urls = new String[0];\n\n    /**\n     * If the plugin should be quiet if any of the files was not found\n     */\n    @Parameter( defaultValue = \"false\" )\n    private boolean quiet;\n\n    /**\n     * Prefix that will be added before name of each property.\n     * Can be useful for separating properties with same name from different files.\n     */\n    @Parameter\n    private String keyPrefix = null;\n", "    public void setKeyPrefix( String keyPrefix ) {\n        this.keyPrefix = keyPrefix;\n    }\n\n    @Parameter( defaultValue = \"false\", property = \"prop.skipLoadProperties\" )\n    private boolean skipLoadProperties;\n\n    /**\n     * Boolean flag that says, should the plugin log duplicated proeprties or not\n     */\n    @Parameter( defaultValue = \"false\", property = \"logOverridingProperties\", required = false)\n    private boolean logOverridingProperties;\n", "    public void setLogOverridingProperties(boolean logOverridingProperties) {\n        this.logOverridingProperties = logOverridingProperties;\n    }\n\n    /**\n     * Used for resolving property placeholders.\n     */\n    private final PropertyResolver resolver = new PropertyResolver();\n\n    /** {@inheritDoc} */\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        setKeyPrefix();", "    public void execute() throws MojoExecutionException, MojoFailureException {\n        setKeyPrefix();\n        if ( !skipLoadProperties ) {\n            loadFiles();\n            loadUrls();\n            loadFilesByPattern();\n            resolveProperties();\n        } else {\n            getLog().warn( \"The properties are ignored\" );\n        }\n    }\n\n    private void loadFiles() throws MojoExecutionException {", "        for ( File file : files ) {\n            load( new FileResource( file ) );\n        }\n    }\n\n    private void loadFilesByPattern() throws MojoExecutionException {\n        if (includes == null) {\n            return;\n        }\n\n        for (String antPattern : includes) {", "        for (String antPattern : includes) {\n            if (antPattern == null || antPattern.isEmpty()) {\n                throw new MojoExecutionException(\"Provided <pattern/> element value is empty. Please, put corresponding ant path pattern in this element\");\n            }\n\n            try (Stream<Path> pathStream = pathParser.streamFilesMatchingAntPath(antPattern)) {\n\n                List<FileResource> fileResources = pathStream.map(Path::toFile)\n                  .peek(it -> getLog().debug(String.format(\"Found potential properties file '%s' by ant path pattern : '%s'\", it, antPattern)))\n                  .map(FileResource::new)\n                  .collect(Collectors.toList());\n", "                for (FileResource fileResource : fileResources) {\n                    loadProperties(fileResource);\n                }\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Error while traversing file tree to find properties files by ant pattern\", e);\n            }\n        }\n    }\n\n    private void loadUrls() throws MojoExecutionException {\n        for ( String url : urls ) {\n            load( new UrlResource( url ) );\n        }\n    }\n\n    private void load( Resource resource ) throws MojoExecutionException {", "        for ( String url : urls ) {\n            load( new UrlResource( url ) );\n        }\n    }\n\n    private void load( Resource resource ) throws MojoExecutionException {\n        if ( resource.canBeOpened() ) {\n            loadProperties( resource );\n        } else {\n            missing( resource );\n        }\n    }\n\n    private void loadProperties( Resource resource ) throws MojoExecutionException {", "        try {\n            getLog().debug( \"Loading properties from \" + resource );\n\n            try ( InputStream stream = resource.getInputStream() ) {\n                Properties properties = new Properties();\n                properties.load( stream );\n                Properties projectProperties = project.getProperties();\n\n                for ( String key : properties.stringPropertyNames() ) {\n                    String propertyFinalName = keyPrefix + key;\n                    checkIsPropertyAlreadyDefined(projectProperties, propertyFinalName);\n                    projectProperties.put(propertyFinalName, properties.get( key ) );\n                }\n            }\n\n        } catch ( IOException e ) {\n            throw new MojoExecutionException( \"Error reading properties from \" + resource, e );\n        }\n    }\n\n    private void setKeyPrefix() {", "                for ( String key : properties.stringPropertyNames() ) {\n                    String propertyFinalName = keyPrefix + key;\n                    checkIsPropertyAlreadyDefined(projectProperties, propertyFinalName);\n                    projectProperties.put(propertyFinalName, properties.get( key ) );\n                }\n            }\n\n        } catch ( IOException e ) {\n            throw new MojoExecutionException( \"Error reading properties from \" + resource, e );\n        }\n    }\n\n    private void setKeyPrefix() {", "        if ( keyPrefix == null ) {\n            keyPrefix = \"\";\n        }\n    }\n\n    private void checkIsPropertyAlreadyDefined(Properties definedProperties, String newPropertyKey) {\n        if (logOverridingProperties && getLog().isInfoEnabled() && definedProperties.containsKey(newPropertyKey) ) {\n            getLog().info( String.format(\"Property %s is already defined. Value was overridden in Properties\", newPropertyKey) );\n        }\n    }\n\n    private void missing( Resource resource ) throws MojoExecutionException {", "        if ( quiet ) {\n            getLog().info( \"Quiet processing - ignoring properties cannot be loaded from \" + resource );\n        } else {\n            throw new MojoExecutionException( \"Properties could not be loaded from \" + resource );\n        }\n    }\n\n    private void resolveProperties() throws MojoExecutionException, MojoFailureException {\n        Properties environment = loadSystemEnvironmentPropertiesWhenDefined();\n        Properties projectProperties = project.getProperties();\n", "        for (Object key : projectProperties.keySet()) {\n            projectProperties.setProperty( (String) key, getPropertyValue( (String) key, projectProperties, environment ) );\n        }\n    }\n\n    private Properties loadSystemEnvironmentPropertiesWhenDefined() throws MojoExecutionException {\n\n        boolean useEnvVariables = project.getProperties()\n          .values()\n          .stream()\n          .anyMatch(o -> ((String) o).startsWith(\"${env.\"));\n\n        Properties environment = null;", "        if ( useEnvVariables ) {\n            try {\n                environment = getSystemEnvVars();\n            } catch ( IOException e ) {\n                throw new MojoExecutionException( \"Error getting system environment variables: \", e );\n            }\n        }\n        return environment;\n    }\n\n    private String getPropertyValue( String propertyName, Properties mavenPropertiesFromResource, Properties processEnvironment) throws MojoFailureException {", "        try {\n            return resolver.getPropertyValue(propertyName, mavenPropertiesFromResource, processEnvironment);\n        } catch (IllegalArgumentException e) {\n            throw new MojoFailureException(e.getMessage());\n        }\n    }\n\n    /**\n     * Override-able for test purposes.\n     * \n     * @return The shell environment variables, can be empty but never <code>null</code>.\n     * @throws IOException If the environment variables could not be queried from the shell.\n     */\n    Properties getSystemEnvVars() throws IOException {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    /**\n     * Default scope for test access.\n     * \n     * @param quiet Set to <code>true</code> if missing files can be skipped.\n     */\n    void setQuiet( boolean quiet )\n    {\n        this.quiet = quiet;\n    }\n\n    /**\n     *\n     * @param skipLoadProperties Set to <code>true</code> if you don't want to load properties.\n     */\n    void setSkipLoadProperties( boolean skipLoadProperties )\n    {\n        this.skipLoadProperties = skipLoadProperties;\n    }\n\n    /**\n     * Default scope for test access.\n     * \n     * @param project The test project.\n     */\n    void setProject( MavenProject project )\n    {\n        this.project = project;\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/SetSystemPropertiesMojo.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file \n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, \n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n * KIND, either express or implied.  See the License for the \n * specific language governing permissions and limitations ", " * KIND, either express or implied.  See the License for the \n * specific language governing permissions and limitations \n * under the License.\n */\n\nimport java.util.Enumeration;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;", "import org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\n/**\n * Sets system properties.\n * ", " * Sets system properties.\n * \n * @author <a href=\"mailto:markh@apache.org\">Mark Hobson</a>\n */\n@Mojo( name = \"set-system-properties\", defaultPhase = LifecyclePhase.INITIALIZE, threadSafe = true )\npublic class SetSystemPropertiesMojo\n    extends AbstractMojo\n{\n    // fields -----------------------------------------------------------------\n\n    /**\n     * The system properties to set.\n     */\n    @Parameter( required = true )\n    private Properties properties;\n\n    // Mojo methods -----------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */", "    public void execute()\n    {\n        if ( properties.isEmpty() )\n        {\n            getLog().debug( \"No system properties found\" );\n\n            return;\n        }\n\n        getLog().debug( \"Setting system properties:\" );\n", "        for ( Enumeration<?> propertyNames = properties.propertyNames(); propertyNames.hasMoreElements(); )\n        {\n            String propertyName = propertyNames.nextElement().toString();\n            String propertyValue = properties.getProperty( propertyName );\n\n            getLog().debug( \"- \" + propertyName + \" = \" + propertyValue );\n\n            System.setProperty( propertyName, propertyValue );\n        }\n\n        int count = properties.size();\n\n        getLog().info( \"Set \" + count + \" system \" + ( count > 1 ? \"properties\" : \"property\" ) );\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/PropertyResolver.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class PropertyResolver {\n", "\npublic class PropertyResolver {\n\n    public String getPropertyValue(String key, Properties mavenProjectProperties, Properties environment) {\n        return this.getPropertyValue(key, mavenProjectProperties, environment, new CircularDefinitionPreventer());\n    }\n\n    /**\n     * Retrieves a property value, replacing values like ${token} using the Properties to look them up. Shamelessly\n     * adapted from:\n     * http://maven.apache.org/plugins/maven-war-plugin/xref/org/apache/maven/plugin/war/PropertyUtils.html It will\n     * leave unresolved properties alone, trying for System properties, and environment variables and implements\n     * reparsing (in the case that the value of a property contains a key), and will not loop endlessly on a pair like\n     * test = ${test}\n     *\n     * @param key property key\n     * @param mavenProjectProperties project properties\n     * @param environment environment variables\n     * @return resolved property value, or property placeholder, if it was not resolved\n     * @throws IllegalArgumentException when properties are circularly defined\n     */\n    private String getPropertyValue(String key, Properties mavenProjectProperties, Properties environment, CircularDefinitionPreventer circularDefinitionPreventer) {\n", "        if (circularDefinitionPreventer.isPropertyAlreadyVisited(key)) {\n            circularDefinitionPreventer.throwCircularDefinitionException();\n        }\n\n        String rawValue = fromPropertiesThenSystemThenEnvironment(key, mavenProjectProperties, environment);\n\n        if (StringUtils.isEmpty(rawValue)) {\n            return null;\n        }\n\n        ExpansionBuffer buffer = new ExpansionBuffer(rawValue);\n        String newKey;\n", "        while ((newKey = buffer.extractNextPropertyKey()) != null) {\n            buffer.moveResolvedPartToNextProperty();\n            String newValue = getPropertyValue(newKey, mavenProjectProperties, environment, circularDefinitionPreventer.cloneWithAdditionalKey(key));\n            if (newValue == null) {\n                buffer.add(\"${\" + newKey + \"}\");\n            } else {\n                buffer.add(newValue);\n            }\n        }\n\n        return buffer.getFullyResolved();\n    }\n\n    private String fromPropertiesThenSystemThenEnvironment( String key, Properties properties, Properties environment ) {\n        String value = StringUtils.defaultIfEmpty(\n          properties.getProperty(key),\n          System.getProperty(key)\n        );\n\n        // try environment variable", "        if ( value == null && key.startsWith( \"env.\" ) && environment != null ) {\n            value = environment.getProperty( key.substring( 4 ) );\n        }\n\n        return value;\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/AbstractWritePropertiesMojo.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\n", "import org.apache.maven.project.MavenProject;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.text.MessageFormat;\nimport java.util.Collections;\nimport java.util.Comparator;", "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>", "/**\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>\n * @author Sergey Korotaev\n */\npublic abstract class AbstractWritePropertiesMojo\n        extends AbstractMojo {\n\n    @Parameter(defaultValue = \"${project}\", required = true, readonly = true)\n    private MavenProject project;\n\n    @Parameter(required = true, property = \"properties.outputFile\")\n    private File outputFile;\n\n    @Parameter(property = \"properties.sort\")\n    private boolean sort;\n\n    /**\n     * @param properties {@link Properties}\n     * @param file       {@link File}\n     * @throws MojoExecutionException {@link MojoExecutionException}\n     */\n    protected void writeProperties(Properties properties, File file) throws MojoExecutionException {", "        try {\n            storeWithoutTimestamp(new StoreProperties(properties), file);\n        } catch (FileNotFoundException e) {\n            getLog().error(\"Could not create FileOutputStream: \" + file);\n            throw new MojoExecutionException(e.getMessage(), e);\n        } catch (IOException e) {\n            getLog().error(\"Error writing properties: \" + file);\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n    }\n\n    private void storeWithoutTimestamp(StoreProperties properties, File outputFile) throws IOException {\n\n        try (FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {", "            if (isSort()) {\n                properties.sortedStore(fileOutputStream, null);\n            } else {\n                properties.store(fileOutputStream, null);\n            }\n        }\n\n    }\n\n    /**\n     * @throws MojoExecutionException {@link MojoExecutionException}\n     */\n    protected void validateOutputFile() throws MojoExecutionException {", "        if (outputFile.isDirectory()) {\n            throw new MojoExecutionException(\"outputFile must be a file and not a directory\");\n        }\n        // ensure path exists\n        if (outputFile.getParentFile() != null) {\n            outputFile.getParentFile().mkdirs();\n        }\n//        getLog().info(MessageFormat.format(\"Writing properties into : {0}\", outputFile.getPath()));\n    }\n\n    /**\n     * @return {@link MavenProject}\n     */", "    public MavenProject getProject() {\n        return project;\n    }\n\n    public void setProject(MavenProject project) {\n        this.project = project;\n    }\n\n    /**\n     * @return {@link #outputFile}\n     */", "    public File getOutputFile() {\n        return outputFile;\n    }\n\n    public void setOutputFile(File outputFile) {\n        this.outputFile = outputFile;\n    }\n\n    public boolean isSort() {\n        return sort;\n    }\n", "    public boolean isSort() {\n        return sort;\n    }\n\n    public void setSort(boolean sort) {\n        this.sort = sort;\n    }\n\n    private static class StoreProperties extends Properties {\n\n        public StoreProperties(Properties defaults) {\n            this.putAll(defaults);\n        }\n", "        public void sortedStore(OutputStream out, String comments) throws IOException {\n\n            Properties sortedProps = new Properties() {\n                @Override\n                public Set<Map.Entry<Object, Object>> entrySet() {\n                    Set<Map.Entry<Object, Object>> sortedSet = new TreeSet<>(Comparator.comparing(o -> o.getKey().toString()));\n                    sortedSet.addAll(super.entrySet());\n                    return sortedSet;\n                }\n\n                @Override\n                public Set<Object> keySet() {\n                    return new TreeSet<>(super.keySet());\n                }\n\n                @Override", "                public synchronized Enumeration<Object> keys() {\n                    return Collections.enumeration(new TreeSet<>(super.keySet()));\n                }\n\n            };\n\n            sortedProps.putAll(this);\n            sortedProps.store(out, comments);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/ExpansionBuffer.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.lang.NonNull;", "import org.apache.commons.lang3.StringUtils;\nimport org.springframework.lang.NonNull;\nimport org.springframework.lang.Nullable;\n\nclass ExpansionBuffer {\n\n    private boolean isFullyResolved;\n\n    private final StringBuilder resolved = new StringBuilder();\n", "    private final StringBuilder resolved = new StringBuilder();\n\n    /**\n     * RegExp pattern to locate the leftest nested property\n     */\n    private static final Pattern NESTED_PROPERTY_PATTERN = Pattern.compile(\"\\\\$\\\\{(.*?)}\");\n\n    @NonNull\n    private String unresolved;\n", "    private String unresolved;\n\n    public ExpansionBuffer(String unresolved) {\n        this.unresolved = StringUtils.defaultString(unresolved);\n        this.isFullyResolved = !hasMoreLegalPlaceholders();\n    }\n\n    private boolean hasMoreLegalPlaceholders() {\n        return NESTED_PROPERTY_PATTERN.matcher(unresolved).matches();\n    }", "        return NESTED_PROPERTY_PATTERN.matcher(unresolved).matches();\n    }\n\n    @Nullable\n    public String extractNextPropertyKey() {\n        String nextKeyToSearchFor = null;\n        Matcher matcher = NESTED_PROPERTY_PATTERN.matcher(unresolved);\n        if (matcher.find()) {\n            nextKeyToSearchFor = matcher.group(1);\n        } else {\n            resolved.append(unresolved);\n            isFullyResolved = true;\n        }\n        return nextKeyToSearchFor;\n    }\n", "    public void moveResolvedPartToNextProperty() {\n        int start = unresolved.indexOf(\"${\");\n        resolved.append(unresolved, 0, start);\n        unresolved = unresolved.substring(unresolved.indexOf(\"}\", start) + 1);\n    }\n\n    public String getFullyResolved() {\n        if (!isFullyResolved) {\n            throw new IllegalStateException(\"Property value is not fully resolved yet\");\n        }\n        return resolved.toString();\n    }\n\n    @Override", "    public String toString() {\n        return \"ExpansionBuffer{\" + \"isFullyResolved=\" + isFullyResolved + \", resolved=\" + resolved + \", unresolved='\" + unresolved + '\\'' + '}';\n    }\n\n    public void add(String resolvedProperty) {\n        resolved.append(resolvedProperty);\n    }\n}"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/WriteActiveProfileProperties.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\n", "import org.apache.maven.plugins.annotations.Mojo;\n\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Writes properties of all active profiles to a file.\n *\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>\n * @author Sergey Korotaev", " * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>\n * @author Sergey Korotaev\n */\n@Mojo(name = \"write-active-profile-properties\", defaultPhase = LifecyclePhase.NONE, threadSafe = true)\npublic class WriteActiveProfileProperties extends AbstractWritePropertiesMojo {\n    /**\n     * {@inheritDoc}\n     */\n    public void execute() throws MojoExecutionException {\n        validateOutputFile();\n        List<Profile> profileList = getProject().getActiveProfiles();\n", "    public void execute() throws MojoExecutionException {\n        validateOutputFile();\n        List<Profile> profileList = getProject().getActiveProfiles();\n\n        if (getLog().isDebugEnabled()) {\n            getLog().debug(profileList.size() + \" profile(s) active\");\n        }\n        Properties properties = new Properties();\n        profileList.stream()\n                .filter(profile -> profile.getProperties() != null)\n                .forEach(profile -> properties.putAll(profile.getProperties()));\n\n        writeProperties(properties, getOutputFile());\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/WriteProjectProperties.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\n\nimport java.util.Properties;", "\nimport java.util.Properties;\n\n/**\n * Writes project properties to a file.\n *\n * @author <a href=\"mailto:zarars@gmail.com\">Zarar Siddiqi</a>\n * @author Sergey Korotaev\n */\n@Mojo(name = \"write-project-properties\", defaultPhase = LifecyclePhase.NONE, threadSafe = true)\npublic class WriteProjectProperties extends AbstractWritePropertiesMojo {\n    /**\n     * {@inheritDoc}\n     */", " */\n@Mojo(name = \"write-project-properties\", defaultPhase = LifecyclePhase.NONE, threadSafe = true)\npublic class WriteProjectProperties extends AbstractWritePropertiesMojo {\n    /**\n     * {@inheritDoc}\n     */\n    public void execute() throws MojoExecutionException {\n        validateOutputFile();\n        Properties projProperties = new Properties();\n        projProperties.putAll(getProject().getProperties());\n\n        Properties systemProperties = System.getProperties();\n\n        // allow system properties to overwrite key/value found in maven properties", "        for (Object key : systemProperties.keySet()) {\n            String value = systemProperties.getProperty( (String) key);\n            if (projProperties.get(key) != null) {\n                projProperties.put(key, value);\n            }\n        }\n\n        writeProperties(projProperties, getOutputFile());\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/CircularDefinitionPreventer.java", "chunked_list": ["package io.polivakha.mojo.properties;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at", " * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations", " * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport io.polivakha.mojo.properties.exception.PropertyCircularDefinitionException;\n\npublic class CircularDefinitionPreventer {\n\n    private final Set<String> keysUsed;\n\n    public CircularDefinitionPreventer(Set<String> usedKeySet) {\n        this.keysUsed = usedKeySet;\n    }\n\n    public CircularDefinitionPreventer() {\n        this(new LinkedHashSet<>());\n    }\n\n    /**\n     * Checks if property is already visited\n     * @param key - key which defines the property\n     * @return true if property was already visited during value resolution, false otherwise\n     */", "import io.polivakha.mojo.properties.exception.PropertyCircularDefinitionException;\n\npublic class CircularDefinitionPreventer {\n\n    private final Set<String> keysUsed;\n\n    public CircularDefinitionPreventer(Set<String> usedKeySet) {\n        this.keysUsed = usedKeySet;\n    }\n\n    public CircularDefinitionPreventer() {\n        this(new LinkedHashSet<>());\n    }\n\n    /**\n     * Checks if property is already visited\n     * @param key - key which defines the property\n     * @return true if property was already visited during value resolution, false otherwise\n     */", "    public boolean isPropertyAlreadyVisited(String key) {\n        return keysUsed.contains(key);\n    }\n\n    /**\n     * Check that the expanded property does not provide a circular definition.\n     * For instance:\n     * <p>\n     * some.key = ${some.property}\n     * some.property = ${some.key}\n     * <p>\n     * This is a circular properties definition\n     * @param key The key.\n     * @return {@link CircularDefinitionPreventer}\n     */", "    public CircularDefinitionPreventer cloneWithAdditionalKey( String key ) {\n        var keysUsedCopy = new LinkedHashSet<>(keysUsed);\n        keysUsedCopy.add(key);\n        return new CircularDefinitionPreventer(keysUsedCopy);\n    }\n\n    public void throwCircularDefinitionException() {\n        StringBuilder buffer = new StringBuilder( \"Circular property definition detected: \\n\");\n        keysUsed.forEach(key -> buffer.append(key).append(\" --> \"));\n        buffer.append(keysUsed.stream().findFirst());\n        throw new PropertyCircularDefinitionException( buffer.toString() );\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/loader/PropertiesLoader.java", "chunked_list": ["package io.polivakha.mojo.properties.loader;\n\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Represents an abstract resource loader that is capable to load properties from some resource\n *\n * @param <RESOURCE> - the abstract resource from which properties should be loaded\n * @author Mikhail Polivakha", " * @param <RESOURCE> - the abstract resource from which properties should be loaded\n * @author Mikhail Polivakha\n */\npublic interface PropertiesLoader<RESOURCE> {\n\n    /**\n     * Loading the properties from the specified resources. Note that the order of {@code resources}\n     * list elements <b>matters</b>, because each next resource, in case of conflict, will override\n     * the properties loaded from previous resource. for example, if there is a property 'abc' defined in\n     * 3 resources, then the value of 'abc' property in the last resource in the passed list will be contained\n     * in the returned {@link Properties} object.\n     *\n     * @param resources - resources list, from which the {@link Properties} should be loaded\n     * @return Properties object, containing the loaded properties\n     */\n    Properties loadProperties(List<RESOURCE> resources);\n}"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/loader/AbstractPropertiesLoader.java", "chunked_list": ["package io.polivakha.mojo.properties.loader;\n\nimport java.util.List;\nimport java.util.Properties;\n\nimport io.polivakha.mojo.properties.models.Resource;\n\n/**\n * Common class for all {@link PropertiesLoader}'s. Assembles the properties from each resource one by one\n *", " * Common class for all {@link PropertiesLoader}'s. Assembles the properties from each resource one by one\n *\n * @author Mikhail Polivakha\n */\npublic abstract class AbstractPropertiesLoader<RESOURCE> implements PropertiesLoader<RESOURCE> {\n\n    @Override\n    public Properties loadProperties(List<RESOURCE> resources) {\n        Properties result = new Properties();\n        for (RESOURCE resource : resources) {\n            Properties properties = loadInternally(resource);\n            result.putAll(properties);\n        }\n        return result;\n    }\n\n    /**\n     * Method to be implemented by child classes, that will do the actual proeprties loading\n     * @param resources - abstract {@link Resource} from which the properties should be loaded\n     * @return loaded {@link Properties} object from provided {@link Resource}\n     */\n    protected abstract Properties loadInternally(RESOURCE resources);\n}\n", "        for (RESOURCE resource : resources) {\n            Properties properties = loadInternally(resource);\n            result.putAll(properties);\n        }\n        return result;\n    }\n\n    /**\n     * Method to be implemented by child classes, that will do the actual proeprties loading\n     * @param resources - abstract {@link Resource} from which the properties should be loaded\n     * @return loaded {@link Properties} object from provided {@link Resource}\n     */\n    protected abstract Properties loadInternally(RESOURCE resources);\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/utils/PathParser.java", "chunked_list": ["package io.polivakha.mojo.properties.utils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n", "import java.util.stream.Stream;\n\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.Assert;\n\n/**\n * This class parses the file system tree to find files matching specific ant pattern\n *\n * @author Mikhail Polivakha\n */\npublic class PathParser {\n\n    private final AntPathMatcher antPathMatcher = new AntPathMatcher(File.pathSeparator);\n\n    private final Pattern characterClassesRegexp = Pattern.compile(\".*:\\\\[.*]\");\n\n    /**\n     * Searches for all files available that match provided {@code antPathPattern}\n     *\n     * @param antPathPattern - ant path pattern, must not be null\n     * @return Stream of {@link Path}'s, that are files (not directories), that match provided ant path.\n     *         It is the responsibility of the caller method to close the stream\n     *\n     * @throws IOException in case of any file system errors\n     */\n    public Stream<Path> streamFilesMatchingAntPath(String antPathPattern) throws IOException {\n\n        Assert.notNull(antPathPattern, \"Provided ant path is null\");\n\n        String s = extractExactDirectory(Path.of(antPathPattern));\n\n        return Files\n          .walk(Path.of(s), FileVisitOption.FOLLOW_LINKS)\n          .filter(currentFile -> {\n", " * @author Mikhail Polivakha\n */\npublic class PathParser {\n\n    private final AntPathMatcher antPathMatcher = new AntPathMatcher(File.pathSeparator);\n\n    private final Pattern characterClassesRegexp = Pattern.compile(\".*:\\\\[.*]\");\n\n    /**\n     * Searches for all files available that match provided {@code antPathPattern}\n     *\n     * @param antPathPattern - ant path pattern, must not be null\n     * @return Stream of {@link Path}'s, that are files (not directories), that match provided ant path.\n     *         It is the responsibility of the caller method to close the stream\n     *\n     * @throws IOException in case of any file system errors\n     */\n    public Stream<Path> streamFilesMatchingAntPath(String antPathPattern) throws IOException {\n\n        Assert.notNull(antPathPattern, \"Provided ant path is null\");\n\n        String s = extractExactDirectory(Path.of(antPathPattern));\n\n        return Files\n          .walk(Path.of(s), FileVisitOption.FOLLOW_LINKS)\n          .filter(currentFile -> {\n", "              if (currentFile.toFile().isDirectory()) {\n                  return false;\n              }\n\n              return antPathMatcher.match(antPathPattern, currentFile.toString());\n          });\n    }\n\n    public String extractExactDirectory(Path path) {\n     \n        Assert.notNull(path, \"Passed path must not be null\");\n", "    public String extractExactDirectory(Path path) {\n     \n        Assert.notNull(path, \"Passed path must not be null\");\n\n        if (path.toString().isEmpty()) {\n            return \"/\";\n        }\n\n        String stringPath = path.normalize().toString();\n\n        return extractMostExactDirectoryFromNormalizedPath(stringPath);\n    }\n\n    private String extractMostExactDirectoryFromNormalizedPath(String stringPath) {\n        StringBuilder result = new StringBuilder(\"/\");\n\n        int leftPointer = 1;\n\n        int nextForwardSlashIndex = 1;\n", "        while ((nextForwardSlashIndex = stringPath.indexOf(\"/\", nextForwardSlashIndex)) != -1) {\n            String pathComponent = stringPath.substring(leftPointer, nextForwardSlashIndex);\n            if (containsAntTokens(pathComponent)) {\n                return removeTrailingSlashIfPresent(result);\n            }\n            result.append(pathComponent).append(\"/\");\n            nextForwardSlashIndex++;\n            leftPointer = nextForwardSlashIndex;\n        }\n\n        String tail = stringPath.substring(leftPointer);\n", "        if (!containsAntTokens(tail)) {\n            result.append(tail);\n        }\n\n        return removeTrailingSlashIfPresent(result);\n    }\n\n    private String removeTrailingSlashIfPresent(StringBuilder result) {\n        if (result.toString().endsWith(\"/\") && result.length() > 1) {\n            return result.substring(0, result.length() - 1);\n        }\n        return result.toString();\n    }\n", "        if (result.toString().endsWith(\"/\") && result.length() > 1) {\n            return result.substring(0, result.length() - 1);\n        }\n        return result.toString();\n    }\n\n    public boolean containsAntTokens(String pathComponent) {\n        if (pathComponent == null || pathComponent.isEmpty()) {\n            return false;\n        }\n", "        if (pathComponent.contains(\"**\") || pathComponent.contains(\"*\") || pathComponent.contains(\"?\")) {\n            return true;\n        }\n\n        return characterClassesRegexp.matcher(pathComponent).find();\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/models/Resource.java", "chunked_list": ["package io.polivakha.mojo.properties.models;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic abstract class Resource {\n\n    private InputStream stream;\n\n    public abstract boolean canBeOpened();\n\n    protected abstract InputStream openStream() throws IOException;\n", "    public abstract boolean canBeOpened();\n\n    protected abstract InputStream openStream() throws IOException;\n\n    public InputStream getInputStream() throws IOException {\n        if ( stream == null ) {\n            stream = openStream();\n        }\n        return stream;\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/models/UrlResource.java", "chunked_list": ["package io.polivakha.mojo.properties.models;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\npublic class UrlResource extends Resource {\n\n    private static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    private static final String SLASH_PREFIX = \"/\";\n\n    private final URL url;\n\n    private boolean isMissingClasspathResouce = false;\n\n    private String classpathUrl;\n\n    public UrlResource( String url ) throws MojoExecutionException {", "import org.apache.maven.plugin.MojoExecutionException;\n\npublic class UrlResource extends Resource {\n\n    private static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    private static final String SLASH_PREFIX = \"/\";\n\n    private final URL url;\n\n    private boolean isMissingClasspathResouce = false;\n\n    private String classpathUrl;\n\n    public UrlResource( String url ) throws MojoExecutionException {", "        if ( url.startsWith( CLASSPATH_PREFIX ) ) {\n            String resource = url.substring( CLASSPATH_PREFIX.length() );\n            if ( resource.startsWith( SLASH_PREFIX ) ) {\n                resource = resource.substring( 1 );\n            }\n            this.url = getClass().getClassLoader().getResource( resource );\n            if ( this.url == null ) {\n                isMissingClasspathResouce = true;\n                classpathUrl = url;\n            }\n        } else {", "            try {\n                this.url = new URL( url );\n            } catch ( MalformedURLException e ) {\n                throw new MojoExecutionException( \"Badly formed URL \" + url + \" - \" + e.getMessage() );\n            }\n        }\n    }\n\n    public boolean canBeOpened() {\n        if ( isMissingClasspathResouce ) {\n            return false;\n        }", "    public boolean canBeOpened() {\n        if ( isMissingClasspathResouce ) {\n            return false;\n        }\n        try {\n            openStream();\n        }\n        catch ( IOException e ) {\n            return false;\n        }\n        return true;\n    }\n\n    protected InputStream openStream() throws IOException {\n        return new BufferedInputStream( url.openStream() );\n    }\n", "    public String toString() {\n        if ( !isMissingClasspathResouce ) {\n            return \"URL \" + url.toString();\n        }\n        return classpathUrl;\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/models/FileResource.java", "chunked_list": ["package io.polivakha.mojo.properties.models;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class FileResource extends Resource {\n    private final File file;\n\n    public FileResource( File file )\n    {\n        this.file = file;\n    }\n", "public class FileResource extends Resource {\n    private final File file;\n\n    public FileResource( File file )\n    {\n        this.file = file;\n    }\n\n    public boolean canBeOpened() {\n        return file.exists();\n    }\n\n    protected InputStream openStream() throws IOException {\n        return new BufferedInputStream( new FileInputStream( file ) );\n    }\n", "    public boolean canBeOpened() {\n        return file.exists();\n    }\n\n    protected InputStream openStream() throws IOException {\n        return new BufferedInputStream( new FileInputStream( file ) );\n    }\n\n    public String toString()\n    {\n        return \"File: \" + file;\n    }\n}\n", "    public String toString()\n    {\n        return \"File: \" + file;\n    }\n}\n"]}
{"filename": "src/main/java/io/polivakha/mojo/properties/exception/PropertyCircularDefinitionException.java", "chunked_list": ["package io.polivakha.mojo.properties.exception;\n\npublic class PropertyCircularDefinitionException extends RuntimeException {\n\n    public PropertyCircularDefinitionException(String message) {\n        super(message);\n    }\n}\n"]}
