{"filename": "src/test/java/in/limebrew/xpenseservice/XpenseServiceApplicationTests.java", "chunked_list": ["package in.limebrew.xpenseservice;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass XpenseServiceApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {", "\t@Test\n\tvoid contextLoads() {\n\t}\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/XpenseServiceApplication.java", "chunked_list": ["package in.limebrew.xpenseservice;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class XpenseServiceApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(XpenseServiceApplication.class, args);\n\t}\n\n}\n", "\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(XpenseServiceApplication.class, args);\n\t}\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/query/TransactionQueryBuilder.java", "chunked_list": ["package in.limebrew.xpenseservice.query;\n\nimport com.google.cloud.firestore.Query;\nimport in.limebrew.xpenseservice.utils.DateUtil;\nimport in.limebrew.xpenseservice.utils.TransactionUtil;\n\nimport java.text.ParseException;\nimport java.util.Arrays;\n\n\npublic class TransactionQueryBuilder {", "\n\npublic class TransactionQueryBuilder {\n    public static Query buildQueryByTime(Query query, String date, String month, String year) {\n        System.out.println(\"Inside build query by time\");\n        //? Check if Date was passed\n        if(DateUtil.isValidDate(date)){\n            System.out.println(\"Inside date\");\n            query = query.whereEqualTo(\"creationDate\",date);\n        }\n\n        //? Check if month was passed -> year", "        else if(TransactionUtil.isValidMonth(month) && TransactionUtil.isValidYear(year)) {\n            System.out.println(\"Inside month and year\");\n            query = query\n                    .whereEqualTo(\"creationMonth\",month)\n                    .whereEqualTo(\"creationYear\",Integer.parseInt(year));\n        }\n\n        //? Check if year passed\n        else if(TransactionUtil.isValidYear(year)){\n            System.out.println(\"Inside year\");\n            query = query.whereEqualTo(\"creationYear\",Integer.parseInt(year));\n        }\n        else {\n            throw new NullPointerException(\"A valid date/month/year must be passed\");\n        }\n        return query;\n    }\n", "        else if(TransactionUtil.isValidYear(year)){\n            System.out.println(\"Inside year\");\n            query = query.whereEqualTo(\"creationYear\",Integer.parseInt(year));\n        }\n        else {\n            throw new NullPointerException(\"A valid date/month/year must be passed\");\n        }\n        return query;\n    }\n\n    public static Query buildQueryByTimeRange(Query query,\n                                              String startDate,\n                                              String endDate,\n                                              String creationDate,\n                                              String creationMonth,\n                                              String creationYear) throws ParseException, NullPointerException {\n        System.out.println(\"Inside build query by time range\");\n        //? Check if startDate and endDate is passed and valid", "    public static Query buildQueryByTimeRange(Query query,\n                                              String startDate,\n                                              String endDate,\n                                              String creationDate,\n                                              String creationMonth,\n                                              String creationYear) throws ParseException, NullPointerException {\n        System.out.println(\"Inside build query by time range\");\n        //? Check if startDate and endDate is passed and valid\n        if(DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)) {\n            query = query.whereGreaterThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(startDate))\n                    .whereLessThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(endDate));\n        }\n        else {\n\n            query = TransactionQueryBuilder.buildQueryByTime(query, creationDate, creationMonth, creationYear);\n        }\n        System.out.println(\"End of build query by time range\");\n        return query;\n    }\n", "        if(DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)) {\n            query = query.whereGreaterThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(startDate))\n                    .whereLessThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(endDate));\n        }\n        else {\n\n            query = TransactionQueryBuilder.buildQueryByTime(query, creationDate, creationMonth, creationYear);\n        }\n        System.out.println(\"End of build query by time range\");\n        return query;\n    }\n", "    public static Query buildQueryByTransaction(Query timeQuery, String amount, String type, String tag, String remarks) {\n        System.out.println(\"Inside build transaction query\");\n        //? Check if amount is passed and valid\n        if(TransactionUtil.idValidAmount(amount)) {\n            System.out.println(\"Inside amount\");\n            timeQuery = timeQuery.whereEqualTo(\"transactionAmount\",Double.parseDouble(amount));\n        }\n\n        if(type != null && type.length()>0) {\n            System.out.println(\"Inside type\");\n            timeQuery = timeQuery.whereEqualTo(\"transactionType\", type);\n        }\n", "        if(type != null && type.length()>0) {\n            System.out.println(\"Inside type\");\n            timeQuery = timeQuery.whereEqualTo(\"transactionType\", type);\n        }\n\n        if(tag != null && tag.length()>0) {\n            System.out.println(\"Inside tag\");\n            timeQuery = timeQuery.whereEqualTo(\"transactionTag\", tag);\n        }\n\n        if(remarks != null && remarks.length()>0) {\n            System.out.println(\"Inside remarks\");\n            //? Check if the substring is part of the transaction remark\n            timeQuery = timeQuery.whereIn(\"transactionRemarks\", Arrays.asList(remarks));\n        }\n\n        System.out.println(\"end of transaction query\");\n        return timeQuery;\n    }\n", "        if(remarks != null && remarks.length()>0) {\n            System.out.println(\"Inside remarks\");\n            //? Check if the substring is part of the transaction remark\n            timeQuery = timeQuery.whereIn(\"transactionRemarks\", Arrays.asList(remarks));\n        }\n\n        System.out.println(\"end of transaction query\");\n        return timeQuery;\n    }\n\n    public static Query buildTransactionQueryByAmountRange(Query query,\n                                                     String startAmount,\n                                                     String endAmount,\n                                                     String transactionAmount\n                                                     ) {\n        System.out.println(\"Inside build query by amount range\");\n        //? Check if startAmount and endAmount is passed and valid", "    public static Query buildTransactionQueryByAmountRange(Query query,\n                                                     String startAmount,\n                                                     String endAmount,\n                                                     String transactionAmount\n                                                     ) {\n        System.out.println(\"Inside build query by amount range\");\n        //? Check if startAmount and endAmount is passed and valid\n        if(TransactionUtil.idValidAmount(startAmount) && TransactionUtil.idValidAmount(endAmount)) {\n            query = query.whereGreaterThan(\"transactionAmount\", Double.parseDouble(startAmount))\n                         .whereLessThan(\"transactionAmount\", Double.parseDouble(endAmount));\n        }\n", "        else if (TransactionUtil.idValidAmount(transactionAmount)) {\n            query = query.whereEqualTo(\"transactionAmount\", Double.parseDouble(transactionAmount));\n        }\n\n        return query;\n    }\n\n    public static Query buildQueryByTransactionRange(Query query,\n                                                     String startAmount,\n                                                     String endAmount,\n                                                     String transactionAmount,\n                                                     String transactionType,\n                                                     String transactionTag,\n                                                     String transactionRemarks) {\n        System.out.println(\"Inside build query by transaction range\");\n        //? Build query by amount range\n        query = TransactionQueryBuilder.buildTransactionQueryByAmountRange(query, startAmount, endAmount, transactionAmount);\n", "        if(transactionType != null && transactionType.length()>0) {\n            System.out.println(\"Inside type\");\n            query = query.whereEqualTo(\"transactionType\", transactionType);\n        }\n\n        if(transactionTag != null && transactionTag.length()>0) {\n            System.out.println(\"Inside tag\");\n            query = query.whereEqualTo(\"transactionTag\", transactionTag);\n        }\n\n        if(transactionRemarks != null && transactionRemarks.length()>0) {\n            System.out.println(\"Inside remarks\");\n            //? Check if the substring is part of the transaction remark\n            query = query.whereIn(\"transactionRemarks\", Arrays.asList(transactionRemarks));\n        }\n        return query;\n    }\n\n\n}\n", "        if(transactionRemarks != null && transactionRemarks.length()>0) {\n            System.out.println(\"Inside remarks\");\n            //? Check if the substring is part of the transaction remark\n            query = query.whereIn(\"transactionRemarks\", Arrays.asList(transactionRemarks));\n        }\n        return query;\n    }\n\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/entity/Transaction.java", "chunked_list": ["package in.limebrew.xpenseservice.entity;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.google.cloud.firestore.annotation.DocumentId;\nimport lombok.*;\nimport java.util.Date;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor", "@AllArgsConstructor\n@NoArgsConstructor\n@Getter\n@Setter\npublic class Transaction {\n\n    @DocumentId\n    public String id;\n\n    public String profileId;\n\n    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"dd-MM-yyyy\")", "    public String profileId;\n\n    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"dd-MM-yyyy\")\n    public String creationDate;\n\n    public String creationTimeStamp;\n\n    public String creationMonth;\n\n    public int creationYear;\n", "    public int creationYear;\n\n    public double transactionAmount;\n\n    public String transactionType;\n\n    public String transactionTag;\n\n    public String transactionRemarks;\n}\n", "    public String transactionRemarks;\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/repository/TransactionRepository.java", "chunked_list": ["package in.limebrew.xpenseservice.repository;\n\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface TransactionRepository {\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/utils/TransactionUtil.java", "chunked_list": ["package in.limebrew.xpenseservice.utils;\n\nimport com.google.cloud.firestore.QueryDocumentSnapshot;\nimport java.text.ParseException;\nimport java.util.*;\n\npublic class TransactionUtil {\n    public static final List<String> monthList = Arrays.asList(\"jan\",\"feb\",\"mar\",\"apr\",\"may\",\"jun\",\"jul\",\"aug\",\"sep\",\"oct\",\"nov\",\"dec\");\n\n    public static int getYearFromDate(String date) throws ParseException, IndexOutOfBoundsException {\n        //? dd-mm-yyyy\n        return Integer.parseInt(date.substring(6));\n    }\n", "    public static int getYearFromDate(String date) throws ParseException, IndexOutOfBoundsException {\n        //? dd-mm-yyyy\n        return Integer.parseInt(date.substring(6));\n    }\n\n    public static String getMonthFromDate(String date) throws ParseException, IndexOutOfBoundsException {\n        //? dd-mm-yyyy\n        int monthIndex = Integer.parseInt(date.substring(3,5));\n        return TransactionUtil.monthList.get(monthIndex-1);\n    }\n", "    public static boolean isValidMonth(String month){\n        return !Objects.equals(month, \"\") && TransactionUtil.monthList.contains(month);\n    }\n\n    public static boolean isValidYear(String year){\n        try {\n            int parsedCreationYear = Integer.parseInt(year);\n            return parsedCreationYear >= 2020;\n        }\n        catch (Exception e){\n            return false;\n        }\n    }\n", "    public static boolean idValidAmount(String amount) {\n        try {\n            double parsedAmount = Double.parseDouble(amount);\n            return parsedAmount > 0.0;\n        }\n        catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static Map<String,Object> computeDashboard(List<QueryDocumentSnapshot> transactionDocuments){\n        Map<String,Object> dashboardMap = new HashMap<>();\n        double netEarnings,netExpenses,netInvestments,netFundTransfers, netSavings;\n\n        //? Compute Dashboard Fields\n        netEarnings = TransactionUtil.computeEarning(transactionDocuments);\n        netExpenses = TransactionUtil.computeExpense(transactionDocuments);\n        netInvestments = TransactionUtil.computeInvestment(transactionDocuments);\n        netFundTransfers = TransactionUtil.computeFundTransfer(transactionDocuments);\n        netSavings = TransactionUtil.computeEndSavings(netEarnings, netExpenses, netInvestments);\n\n        //? Store in the hashmap\n        dashboardMap.put(\"netEarnings\",String.format(\"%.2f\",netEarnings));\n        dashboardMap.put(\"netExpenses\",String.format(\"%.2f\",netExpenses));\n        dashboardMap.put(\"netInvestments\",String.format(\"%.2f\",netInvestments));\n        dashboardMap.put(\"netFundTransfers\",String.format(\"%.2f\",netFundTransfers));\n        dashboardMap.put(\"netSavings\", String.format(\"%.2f\",netSavings) );\n        return dashboardMap;\n    }\n", "    public static Map<String,Object> computeDashboard(List<QueryDocumentSnapshot> transactionDocuments){\n        Map<String,Object> dashboardMap = new HashMap<>();\n        double netEarnings,netExpenses,netInvestments,netFundTransfers, netSavings;\n\n        //? Compute Dashboard Fields\n        netEarnings = TransactionUtil.computeEarning(transactionDocuments);\n        netExpenses = TransactionUtil.computeExpense(transactionDocuments);\n        netInvestments = TransactionUtil.computeInvestment(transactionDocuments);\n        netFundTransfers = TransactionUtil.computeFundTransfer(transactionDocuments);\n        netSavings = TransactionUtil.computeEndSavings(netEarnings, netExpenses, netInvestments);\n\n        //? Store in the hashmap\n        dashboardMap.put(\"netEarnings\",String.format(\"%.2f\",netEarnings));\n        dashboardMap.put(\"netExpenses\",String.format(\"%.2f\",netExpenses));\n        dashboardMap.put(\"netInvestments\",String.format(\"%.2f\",netInvestments));\n        dashboardMap.put(\"netFundTransfers\",String.format(\"%.2f\",netFundTransfers));\n        dashboardMap.put(\"netSavings\", String.format(\"%.2f\",netSavings) );\n        return dashboardMap;\n    }\n", "    public static double computeEarning(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument ->\n                        Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"earning\") &&\n                        Objects.equals(transactionDocument.getData().get(\"transactionType\").toString(),\"credit\")\n                )\n                .mapToDouble(transactionDocument -> (double) transactionDocument.getData().get(\"transactionAmount\"))\n                .sum();\n    }\n", "    public static double computeExpense(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument ->\n                        Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"expense\")\n                )\n                .mapToDouble(transactionDocument -> {\n                        String transactionType = transactionDocument.getData().get(\"transactionType\").toString();\n                        double transactionAmount = (double) transactionDocument.getData().get(\"transactionAmount\");\n\n                        if(Objects.equals(transactionType,\"debit\"))\n                            return transactionAmount;", "                        if(Objects.equals(transactionType,\"debit\"))\n                            return transactionAmount;\n                        if(Objects.equals(transactionType,\"credit\"))\n                            return -transactionAmount;\n                        return 0;\n                })\n                .sum();\n    }\n\n    public static double computeInvestment(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument ->\n                        Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"investment\")\n                )\n                .mapToDouble(transactionDocument -> {\n                    String transactionType = transactionDocument\n                            .getData()\n                            .get(\"transactionType\")\n                            .toString();\n\n                    double transactionAmount = (double) transactionDocument.getData().get(\"transactionAmount\");\n", "    public static double computeInvestment(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument ->\n                        Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"investment\")\n                )\n                .mapToDouble(transactionDocument -> {\n                    String transactionType = transactionDocument\n                            .getData()\n                            .get(\"transactionType\")\n                            .toString();\n\n                    double transactionAmount = (double) transactionDocument.getData().get(\"transactionAmount\");\n", "                    if(Objects.equals(transactionType,\"debit\"))\n                        return transactionAmount;\n                    if(Objects.equals(transactionType,\"credit\"))\n                        return -transactionAmount;\n                    return 0;\n                })\n                .sum();\n    }\n\n    public static double computeFundTransfer(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument -> Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"fund_transfer\"))\n                .mapToDouble(transactionDocument -> (double) transactionDocument.getData().get(\"transactionAmount\"))\n                .sum();\n    }\n", "    public static double computeFundTransfer(List<QueryDocumentSnapshot> transactionDocuments){\n        return transactionDocuments\n                .stream()\n                .filter( transactionDocument -> Objects.equals(transactionDocument.getData().get(\"transactionTag\").toString(),\"fund_transfer\"))\n                .mapToDouble(transactionDocument -> (double) transactionDocument.getData().get(\"transactionAmount\"))\n                .sum();\n    }\n\n    public static double computeEndSavings(\n            double netEarnings,\n            double netExpenses,\n            double netInvestment\n    ) {\n        return (netEarnings - netExpenses - netInvestment);\n    }\n\n}", "    public static double computeEndSavings(\n            double netEarnings,\n            double netExpenses,\n            double netInvestment\n    ) {\n        return (netEarnings - netExpenses - netInvestment);\n    }\n\n}"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/utils/DateUtil.java", "chunked_list": ["package in.limebrew.xpenseservice.utils;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class DateUtil {\n    public static boolean isValidDate(String dateString) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"dd-MM-yyyy\");\n        sdf.setLenient(false);\n        try {\n            sdf.parse(dateString);\n            return true;\n        } catch (ParseException e) {\n            return false;\n        }\n    }\n", "        try {\n            sdf.parse(dateString);\n            return true;\n        } catch (ParseException e) {\n            return false;\n        }\n    }\n\n    public static String getUnixTimeFromDate(String dateString) throws ParseException {\n        SimpleDateFormat format = new SimpleDateFormat(\"dd-MM-yyyy\");\n        if(!isValidDate(dateString)) {\n            return \"\";\n        }\n\n        Date date = format.parse(dateString);\n        long unixTime = date.getTime()/1000L;\n        return \"\" + unixTime;\n\n    }\n\n}\n", "    public static String getUnixTimeFromDate(String dateString) throws ParseException {\n        SimpleDateFormat format = new SimpleDateFormat(\"dd-MM-yyyy\");\n        if(!isValidDate(dateString)) {\n            return \"\";\n        }\n\n        Date date = format.parse(dateString);\n        long unixTime = date.getTime()/1000L;\n        return \"\" + unixTime;\n\n    }\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/utils/ResponseUtil.java", "chunked_list": ["package in.limebrew.xpenseservice.utils;\n\nimport in.limebrew.xpenseservice.entity.Transaction;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ResponseUtil {", "import java.util.Map;\n\npublic class ResponseUtil {\n    public static final int HTTP_STATUS_OK = 200;\n    public static final int HTTP_STATUS_CREATED = 201;\n    public static final int HTTP_STATUS_UPDATED = 201;\n    public static final int HTTP_STATUS_DELETED = 201;\n    public static final int HTTP_STATUS_BAD_REQUEST = 400;\n    public static final int HTTP_STATUS_UNAUTHORIZED = 403;\n    public static final int HTTP_STATUS_NOT_FOUND = 404;\n    public static final int HTTP_STATUS_LIMIT_EXCEEDED = 429;", "    public static final int HTTP_STATUS_UNAUTHORIZED = 403;\n    public static final int HTTP_STATUS_NOT_FOUND = 404;\n    public static final int HTTP_STATUS_LIMIT_EXCEEDED = 429;\n    public static final int HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;\n    public static final int HTTP_STATUS_PARSING_ERROR = 500;\n\n    //? Success GetDashboard\n    public static ResponseEntity<Map<String,Object>> handleDashboardInfo(Map<String,Object> dashboardInfo){\n        Map<String,Object> response = new HashMap<>();\n\n        if(dashboardInfo.isEmpty()){\n            dashboardInfo.put(\"netEarnings\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netExpenses\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netInvestments\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netFundTransfer\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netSavings\", String.format(\"%.2f\",0.0f));\n        }\n\n        response.put(\"status\",HTTP_STATUS_OK);\n        response.put(\"message\",\"Dashboard info\");\n        response.put(\"data\",dashboardInfo);\n        return new ResponseEntity<>(response,HttpStatus.OK);\n    }\n\n    //? Success GetOne", "        if(dashboardInfo.isEmpty()){\n            dashboardInfo.put(\"netEarnings\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netExpenses\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netInvestments\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netFundTransfer\",String.format(\"%.2f\",0.0f));\n            dashboardInfo.put(\"netSavings\", String.format(\"%.2f\",0.0f));\n        }\n\n        response.put(\"status\",HTTP_STATUS_OK);\n        response.put(\"message\",\"Dashboard info\");\n        response.put(\"data\",dashboardInfo);\n        return new ResponseEntity<>(response,HttpStatus.OK);\n    }\n\n    //? Success GetOne", "    public static ResponseEntity<Map<String,Object>> successGetOne(Transaction transaction){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_OK);\n        response.put(\"message\",\"Item found\");\n        response.put(\"data\",transaction);\n        return new ResponseEntity<>(response, HttpStatus.OK);\n    }\n\n    //? Success GetMany\n    public static ResponseEntity<Map<String,Object>> successGetMany(List<Transaction> transactionList){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_OK);\n        response.put(\"message\",String.format(\"%s item(s) found\",transactionList.size()));\n        response.put(\"data\",transactionList);\n        return new ResponseEntity<>(response, HttpStatus.OK);\n    }\n\n    //? Success AddOne", "    public static ResponseEntity<Map<String,Object>> successGetMany(List<Transaction> transactionList){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_OK);\n        response.put(\"message\",String.format(\"%s item(s) found\",transactionList.size()));\n        response.put(\"data\",transactionList);\n        return new ResponseEntity<>(response, HttpStatus.OK);\n    }\n\n    //? Success AddOne\n    public static ResponseEntity<Map<String,Object>> successAddOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_CREATED);\n        response.put(\"message\",\"Item added successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Success UpdateOne", "    public static ResponseEntity<Map<String,Object>> successAddOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_CREATED);\n        response.put(\"message\",\"Item added successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Success UpdateOne\n    public static ResponseEntity<Map<String,Object>> successUpdateOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_UPDATED);\n        response.put(\"message\",\"Item updated successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Success DeleteOne", "    public static ResponseEntity<Map<String,Object>> successUpdateOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_UPDATED);\n        response.put(\"message\",\"Item updated successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Success DeleteOne\n    public static ResponseEntity<Map<String,Object>> successDeleteOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_DELETED);\n        response.put(\"message\",\"Item deleted successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Error Bad Request", "    public static ResponseEntity<Map<String,Object>> successDeleteOne(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_DELETED);\n        response.put(\"message\",\"Item deleted successfully\");\n        return new ResponseEntity<>(response,HttpStatus.CREATED);\n    }\n\n    //? Error Bad Request\n    public static ResponseEntity<Map<String,Object>> errorBadRequest(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_BAD_REQUEST);\n        response.put(\"error\",\"Bad Request!\");\n        return new ResponseEntity<>(response,HttpStatus.BAD_REQUEST);\n    }\n\n    //? Error Unauthorized", "    public static ResponseEntity<Map<String,Object>> errorBadRequest(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_BAD_REQUEST);\n        response.put(\"error\",\"Bad Request!\");\n        return new ResponseEntity<>(response,HttpStatus.BAD_REQUEST);\n    }\n\n    //? Error Unauthorized\n    public static ResponseEntity<Map<String,Object>> errorUnauthorized(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_UNAUTHORIZED);\n        response.put(\"error\",\"Unauthorized! Invalid token\");\n        return new ResponseEntity<>(response,HttpStatus.UNAUTHORIZED);\n    }\n\n    //? Error Not Found", "    public static ResponseEntity<Map<String,Object>> errorUnauthorized(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_UNAUTHORIZED);\n        response.put(\"error\",\"Unauthorized! Invalid token\");\n        return new ResponseEntity<>(response,HttpStatus.UNAUTHORIZED);\n    }\n\n    //? Error Not Found\n    public static ResponseEntity<Map<String,Object>> errorNotFound(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_NOT_FOUND);\n        response.put(\"error\",\"Error not found!\");\n        return new ResponseEntity<>(response,HttpStatus.NOT_FOUND);\n    }\n\n    //? Error Internal Server", "    public static ResponseEntity<Map<String,Object>> errorNotFound(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_NOT_FOUND);\n        response.put(\"error\",\"Error not found!\");\n        return new ResponseEntity<>(response,HttpStatus.NOT_FOUND);\n    }\n\n    //? Error Internal Server\n    public static ResponseEntity<Map<String,Object>> errorInternalServer(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_INTERNAL_SERVER_ERROR);\n        response.put(\"error\",\"Internal Server Error!\");\n        return new ResponseEntity<>(response,HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n\n    //? Error Internal Server", "    public static ResponseEntity<Map<String,Object>> errorInternalServer(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_INTERNAL_SERVER_ERROR);\n        response.put(\"error\",\"Internal Server Error!\");\n        return new ResponseEntity<>(response,HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n\n    //? Error Internal Server\n    public static ResponseEntity<Map<String,Object>> errorLimitExceeded(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_LIMIT_EXCEEDED);\n        response.put(\"error\",\"Query Limit Exceeded!\");\n        return new ResponseEntity<>(response,HttpStatus.TOO_MANY_REQUESTS);\n    }\n\n    //? Error Parsing entity", "    public static ResponseEntity<Map<String,Object>> errorLimitExceeded(){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_LIMIT_EXCEEDED);\n        response.put(\"error\",\"Query Limit Exceeded!\");\n        return new ResponseEntity<>(response,HttpStatus.TOO_MANY_REQUESTS);\n    }\n\n    //? Error Parsing entity\n    public static ResponseEntity<Map<String,Object>> errorParsingEntity(String errorMsg){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_PARSING_ERROR);\n        response.put(\"error\",errorMsg);\n        return new ResponseEntity<>(response,HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n", "    public static ResponseEntity<Map<String,Object>> errorParsingEntity(String errorMsg){\n        Map<String,Object> response = new HashMap<>();\n        response.put(\"status\",HTTP_STATUS_PARSING_ERROR);\n        response.put(\"error\",errorMsg);\n        return new ResponseEntity<>(response,HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/utils/RequestUtil.java", "chunked_list": ["package in.limebrew.xpenseservice.utils;\n\npublic class RequestUtil {\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/config/FirebaseConfig.java", "chunked_list": ["package in.limebrew.xpenseservice.config;\n\nimport com.google.auth.oauth2.GoogleCredentials;\nimport com.google.cloud.firestore.Firestore;\nimport com.google.firebase.FirebaseApp;\nimport com.google.firebase.FirebaseOptions;\nimport com.google.firebase.cloud.FirestoreClient;\nimport jakarta.annotation.PostConstruct;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;", "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.ResourceLoader;\nimport java.io.IOException;\nimport java.util.Set;\n\n@Configuration\npublic class FirebaseConfig {\n    private static final String GOOGLE_API_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\n\n    @Autowired\n    ResourceLoader resourceLoader;\n\n    @Value( \"${firebase.project-id}\" )\n    private String projectId;\n\n    @Value(\"${firebase.firestore.db.url}\")\n    private String firestoreDBUrl;\n\n    @PostConstruct", "@Configuration\npublic class FirebaseConfig {\n    private static final String GOOGLE_API_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\n\n    @Autowired\n    ResourceLoader resourceLoader;\n\n    @Value( \"${firebase.project-id}\" )\n    private String projectId;\n\n    @Value(\"${firebase.firestore.db.url}\")\n    private String firestoreDBUrl;\n\n    @PostConstruct", "    public FirebaseApp initializeFirebaseApp() throws IOException {\n        FirebaseOptions options = new FirebaseOptions.Builder()\n                .setProjectId(projectId)\n                .setCredentials(GoogleCredentials.getApplicationDefault().createScoped( Set.of( GOOGLE_API_SCOPE ) ))\n                .setDatabaseUrl(firestoreDBUrl)\n                .build();\n        return FirebaseApp.initializeApp(options);\n    }\n\n    @Bean\n    public Firestore getFirestore() {\n        return FirestoreClient.getFirestore();\n    }\n}\n", "    public Firestore getFirestore() {\n        return FirestoreClient.getFirestore();\n    }\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/constants/ResponseRecord.java", "chunked_list": ["package in.limebrew.xpenseservice.constants;\n\npublic record ResponseRecord(int status,String message, Object data) {\n}\n\nrecord ResponseErrorRecord(int status, String error){}"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/constants/TransactionEnum.java", "chunked_list": ["package in.limebrew.xpenseservice.constants;\n\npublic enum TransactionEnum {\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/constants/DashboardRecord.java", "chunked_list": ["package in.limebrew.xpenseservice.constants;\n\npublic record DashboardRecord (\n        double netEarnings,\n        double netExpenses,\n        double netInvestments,\n        double netFundTransfer,\n        double netSavings ) {\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/controller/DashboardController.java", "chunked_list": ["package in.limebrew.xpenseservice.controller;\n\nimport com.google.firebase.auth.FirebaseAuthException;\nimport com.google.firebase.auth.FirebaseToken;\nimport in.limebrew.xpenseservice.service.DashboardService;\nimport in.limebrew.xpenseservice.service.FirebaseAuthService;\nimport in.limebrew.xpenseservice.utils.DateUtil;\nimport in.limebrew.xpenseservice.utils.ResponseUtil;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;", "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport java.text.ParseException;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\n@RestController\n@RequestMapping(value=\"/api/dashboard\")", "@RestController\n@RequestMapping(value=\"/api/dashboard\")\n@CrossOrigin\npublic class DashboardController {\n\n    @Autowired\n    FirebaseAuthService firebaseAuthService;\n\n    @Autowired\n    DashboardService dashboardService;\n\n    @GetMapping(value=\"/query\")\n    public ResponseEntity<?> getDashBoardByQuery(@RequestHeader(\"Authorization\") String authHeader,\n                                                 @RequestParam(defaultValue = \"\", required = false) String creationDate,\n                                                 @RequestParam(defaultValue = \"\",required = false) String creationMonth,\n                                                 @RequestParam(defaultValue = \"\",required = false) String creationYear) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get Dashboard By Query for a profile\n            Map<String,Object> dashboardInfo = dashboardService.getDashboardByQuery(\n                    decodedToken.getUid(),\n                    creationDate,\n                    creationMonth,\n                    creationYear\n            );\n\n            //? Return response\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"Error: \"+e);\n            return new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED);\n        }\n    }\n\n    @GetMapping(value = \"/range\")\n    public ResponseEntity<?> getDashBoardByDateRange(@RequestHeader(\"Authorization\") String authHeader,\n                                                 @RequestParam(defaultValue = \"\", required = true) String startDate,\n                                                 @RequestParam(defaultValue = \"\", required = true) String endDate) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            System.out.println(\"profileId: \"+ decodedToken.getUid());\n\n            //? Check if required dates are valid or not\n            if(!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)){\n                return ResponseUtil.errorParsingEntity(\"Required Date must be passed in query and should be in dd-MM-yyyy format\");\n            }\n\n            //? Return the dashboard based on date range\n            Map<String, Object> dashboardInfo = dashboardService.getDashboardByDateRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate\n            );\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"error: \" + e);\n            return new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED);\n        }\n\n    }\n\n}\n", "            if(!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)){\n                return ResponseUtil.errorParsingEntity(\"Required Date must be passed in query and should be in dd-MM-yyyy format\");\n            }\n\n            //? Return the dashboard based on date range\n            Map<String, Object> dashboardInfo = dashboardService.getDashboardByDateRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate\n            );\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"error: \" + e);\n            return new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED);\n        }\n\n    }\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/controller/TransactionController.java", "chunked_list": ["package in.limebrew.xpenseservice.controller;\n\nimport com.google.firebase.auth.FirebaseAuthException;\nimport com.google.firebase.auth.FirebaseToken;\nimport in.limebrew.xpenseservice.entity.Transaction;\nimport in.limebrew.xpenseservice.service.FirebaseAuthService;\nimport in.limebrew.xpenseservice.service.TransactionService;\nimport in.limebrew.xpenseservice.utils.DateUtil;\nimport in.limebrew.xpenseservice.utils.ResponseUtil;\nimport in.limebrew.xpenseservice.utils.TransactionUtil;", "import in.limebrew.xpenseservice.utils.ResponseUtil;\nimport in.limebrew.xpenseservice.utils.TransactionUtil;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\n@RestController\n@RequestMapping(value=\"/api/transactions\")\n@CrossOrigin\npublic class TransactionController {\n\n    @Autowired\n    FirebaseAuthService firebaseAuthService;\n\n    @Autowired\n    TransactionService transactionService;\n\n    private static final String limitDefault = \"10\";\n    private static final String exceedLimit = \"100\";\n", "    public boolean isLimitExceeds(int queryLimit){\n        return queryLimit > Integer.parseInt(exceedLimit);\n    }\n\n    @GetMapping(value = \"/all\")\n    public ResponseEntity<Map<String,Object>> getAllTransactions(@RequestHeader(\"Authorization\") String authHeader,\n                                                                 @RequestParam(defaultValue = limitDefault ) int limit) {\n\n        //? Check if Query limit request exceeds\n        if(isLimitExceeds(limit))\n            return ResponseUtil.errorLimitExceeded();\n", "        if(isLimitExceeds(limit))\n            return ResponseUtil.errorLimitExceeded();\n\n        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get all transactions by profile id\n            List<Transaction> allTransactionsByProfileId = transactionService.getAllTransactions(decodedToken.getUid(),limit);\n\n            //? Return response\n            return ResponseUtil.successGetMany(allTransactionsByProfileId);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException e) {\n            return ResponseUtil.errorNotFound();\n        }\n\n    }\n\n    @GetMapping(value = \"/query\")\n    public ResponseEntity<?> getTransactionByQuery(@RequestHeader(\"Authorization\") String authHeader,\n                                                   @RequestParam(defaultValue = \"\", required = false) String creationDate,\n                                                   @RequestParam(defaultValue = \"\", required = false) String creationMonth,\n                                                   @RequestParam(defaultValue = \"\", required = false) String creationYear,\n                                                   @RequestParam(defaultValue = \"\", required = false) String transactionAmount,\n                                                   @RequestParam(defaultValue = \"\", required = false) String transactionType,\n                                                   @RequestParam(defaultValue = \"\", required = false) String transactionTag,\n                                                   @RequestParam(defaultValue = \"\", required = false) String transactionRemarks,\n                                                   @RequestParam(defaultValue = limitDefault, required = false) int limit) {\n\n        //? Check if Query limit request exceeds", "        if(isLimitExceeds(limit))\n            return ResponseUtil.errorLimitExceeded();\n\n        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get all transactions by profile id\n             List<Transaction> transactionByQuery =  transactionService.getTransactionsByQuery(\n                    decodedToken.getUid(),\n                    creationDate,\n                    creationMonth,\n                    creationYear,\n                    transactionAmount,\n                    transactionType,\n                    transactionTag,\n                    transactionRemarks,\n                    limit);\n\n            //? Return response\n            return ResponseUtil.successGetMany(transactionByQuery);\n\n        } catch (FirebaseAuthException | InterruptedException | NullPointerException | ExecutionException e) {\n            return ResponseUtil.errorNotFound();\n        }\n\n    }\n\n    @GetMapping(value = \"/query/range\")\n    public ResponseEntity<?> getTransactionByQueryRange(@RequestHeader(\"Authorization\") String authHeader,\n                                                        @RequestParam(defaultValue = \"\", required = false) String startDate,\n                                                        @RequestParam(defaultValue = \"\", required = false) String endDate,\n                                                        @RequestParam(defaultValue = \"\", required = false) String creationDate,\n                                                        @RequestParam(defaultValue = \"\", required = false) String creationMonth,\n                                                        @RequestParam(defaultValue = \"\", required = false) String creationYear,\n                                                        @RequestParam(defaultValue = \"\", required = false) String startAmount,\n                                                        @RequestParam(defaultValue = \"\", required = false) String endAmount,\n                                                        @RequestParam(defaultValue = \"\", required = false) String transactionAmount,\n                                                        @RequestParam(defaultValue = \"\", required = false) String transactionType,\n                                                        @RequestParam(defaultValue = \"\", required = false) String transactionTag,\n                                                        @RequestParam(defaultValue = \"\", required = false) String transactionRemarks,\n                                                        @RequestParam(defaultValue = limitDefault, required = false) int limit) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get all transactions by profile id\n            List<Transaction> transactionByRange =  transactionService.getTransactionsByRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate,\n                    creationDate,\n                    creationMonth,\n                    creationYear,\n                    startAmount,\n                    endAmount,\n                    transactionAmount,\n                    transactionType,\n                    transactionTag,\n                    transactionRemarks,\n                    limit);\n\n            //? Return response\n            return ResponseUtil.successGetMany(transactionByRange);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | RuntimeException | ParseException e) {\n            System.out.println(e);\n            return ResponseUtil.errorNotFound();\n        }\n    }\n\n\n    @GetMapping(value = \"/query/{id}\")\n    public ResponseEntity<?> getTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                @PathVariable(\"id\") String id) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get all transactions by profile id\n            Transaction transactionById = transactionService.getTransactionById(decodedToken.getUid(), id);\n\n            //? Check if transaction was found", "            if(transactionById == null) {\n                return ResponseUtil.errorNotFound();\n            }\n\n            //? Return response\n            return ResponseUtil.successGetOne(transactionById);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException e) {\n            return ResponseUtil.errorNotFound();\n        }\n    }\n\n    @PostMapping(value = \"/create\")\n    public ResponseEntity<Map<String,Object>> createTransaction(@RequestHeader(\"Authorization\") String authHeader,\n                                               @RequestBody Transaction transaction) {", "        try {\n            //? Extract the token  Bearer_\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Check if valid date format\n            if (!DateUtil.isValidDate(transaction.getCreationDate())) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Set the profile id from the JWT\n            transaction.setProfileId(decodedToken.getUid());\n\n            //? Set the Month and Year and Timestamp in the entity\n            transaction.setCreationMonth(TransactionUtil.getMonthFromDate(transaction.getCreationDate()));\n            transaction.setCreationYear(TransactionUtil.getYearFromDate(transaction.getCreationDate()));\n            transaction.setCreationTimeStamp(DateUtil.getUnixTimeFromDate(transaction.getCreationDate()));\n\n\n            //? Save in the database\n            transactionService.createTransaction(transaction);\n\n            //? Return response\n            return ResponseUtil.successAddOne();\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorUnauthorized();\n        }\n    }\n\n    @PutMapping(value = \"/update/{id}\")\n    public ResponseEntity<Map<String,Object>> updateTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                   @PathVariable(\"id\") String id,\n                                                   @RequestBody Transaction transaction) {", "            if (!DateUtil.isValidDate(transaction.getCreationDate())) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Set the profile id from the JWT\n            transaction.setProfileId(decodedToken.getUid());\n\n            //? Set the Month and Year and Timestamp in the entity\n            transaction.setCreationMonth(TransactionUtil.getMonthFromDate(transaction.getCreationDate()));\n            transaction.setCreationYear(TransactionUtil.getYearFromDate(transaction.getCreationDate()));\n            transaction.setCreationTimeStamp(DateUtil.getUnixTimeFromDate(transaction.getCreationDate()));\n\n\n            //? Save in the database\n            transactionService.createTransaction(transaction);\n\n            //? Return response\n            return ResponseUtil.successAddOne();\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorUnauthorized();\n        }\n    }\n\n    @PutMapping(value = \"/update/{id}\")\n    public ResponseEntity<Map<String,Object>> updateTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                   @PathVariable(\"id\") String id,\n                                                   @RequestBody Transaction transaction) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Check if valid date format\n            if (!DateUtil.isValidDate(transaction.getCreationDate())) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Set the profile id , month and year from the JWT\n            transaction.setProfileId(decodedToken.getUid());\n            transaction.setCreationTimeStamp(DateUtil.getUnixTimeFromDate(transaction.getCreationDate()));\n            transaction.setCreationMonth(TransactionUtil.getMonthFromDate(transaction.getCreationDate()));\n            transaction.setCreationYear(TransactionUtil.getYearFromDate(transaction.getCreationDate()));\n\n            //? update in the database\n            transactionService.updateTransactionById(id, transaction);\n\n            //? Return response\n            return ResponseUtil.successUpdateOne();\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorUnauthorized();\n        }\n    }\n\n    @DeleteMapping(value = \"/delete/{id}\")\n    public ResponseEntity<Map<String,Object>> deleteTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                   @PathVariable(\"id\") String id) {", "            if (!DateUtil.isValidDate(transaction.getCreationDate())) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Set the profile id , month and year from the JWT\n            transaction.setProfileId(decodedToken.getUid());\n            transaction.setCreationTimeStamp(DateUtil.getUnixTimeFromDate(transaction.getCreationDate()));\n            transaction.setCreationMonth(TransactionUtil.getMonthFromDate(transaction.getCreationDate()));\n            transaction.setCreationYear(TransactionUtil.getYearFromDate(transaction.getCreationDate()));\n\n            //? update in the database\n            transactionService.updateTransactionById(id, transaction);\n\n            //? Return response\n            return ResponseUtil.successUpdateOne();\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorUnauthorized();\n        }\n    }\n\n    @DeleteMapping(value = \"/delete/{id}\")\n    public ResponseEntity<Map<String,Object>> deleteTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                   @PathVariable(\"id\") String id) {", "        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Delete transaction by id\n            transactionService.deleteTransactionById(id);\n\n            //? Return response\n            return ResponseUtil.successDeleteOne();\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException e) {\n            return ResponseUtil.errorUnauthorized();\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/TransactionService.java", "chunked_list": ["package in.limebrew.xpenseservice.service;\n\nimport com.google.cloud.firestore.DocumentSnapshot;\nimport in.limebrew.xpenseservice.entity.Transaction;\nimport org.springframework.stereotype.Service;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;", "import java.util.List;\nimport java.util.concurrent.ExecutionException;\n\n@Service\npublic interface TransactionService {\n    List<Transaction> getAllTransactions(String profileId, int limit) throws ExecutionException, InterruptedException;\n    List<Transaction> getTransactionsByQuery(String profileId,\n                                String creationDate,\n                                String creationMonth,\n                                String creationYear,\n                                String transactionAmount,\n                                String transactionType,\n                                String transactionTag,\n                                String transactionRemarks,\n                                int limit) throws ExecutionException, InterruptedException, NullPointerException;\n    List<Transaction> getTransactionsByRange(String profileId,\n                                String startDate,\n                                String endDate,\n                                String creationDate,\n                                String creationMonth,\n                                String creationYear,\n                                String startAmount,\n                                String endAmount,\n                                String transactionAmount,\n                                String transactionType,\n                                String transactionTag,\n                                String transactionRemarks,\n                                int limit) throws ExecutionException, InterruptedException, NullPointerException, ParseException;\n\n    Transaction getTransactionById(String profileId ,String id) throws ExecutionException, InterruptedException;\n\n    String createTransaction(Transaction transaction) throws ExecutionException, InterruptedException;\n\n    String updateTransactionById(String id, Transaction transaction) throws ExecutionException, InterruptedException;\n\n    String deleteTransactionById(String id) throws ExecutionException, InterruptedException;\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/DashboardService.java", "chunked_list": ["package in.limebrew.xpenseservice.service;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\npublic interface DashboardService {\n    Map<String,Object> getDashboardByQuery(String profileId, String creationDate, String creationMonth, String creationYear) throws ExecutionException, InterruptedException, ParseException;\n    Map<String, Object> getDashboardByDateRange(String profileId, String startDate, String endDate) throws ExecutionException, InterruptedException, ParseException;\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/FirebaseAuthService.java", "chunked_list": ["package in.limebrew.xpenseservice.service;\n\nimport com.google.firebase.auth.FirebaseAuthException;\nimport com.google.firebase.auth.FirebaseToken;\n\npublic interface FirebaseAuthService {\n\n    //? Verify JWT\n    FirebaseToken verifyToken(String accessToken) throws FirebaseAuthException;\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/impl/TransactionServiceImpl.java", "chunked_list": ["package in.limebrew.xpenseservice.service.impl;\n\nimport com.google.api.core.ApiFuture;\nimport com.google.cloud.firestore.*;\nimport in.limebrew.xpenseservice.entity.Transaction;\nimport in.limebrew.xpenseservice.query.TransactionQueryBuilder;\nimport in.limebrew.xpenseservice.service.TransactionService;\nimport in.limebrew.xpenseservice.utils.DateUtil;\nimport in.limebrew.xpenseservice.utils.TransactionUtil;\nimport org.springframework.beans.factory.annotation.Autowired;", "import in.limebrew.xpenseservice.utils.TransactionUtil;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.text.ParseException;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;", "import java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\n\n@Service\npublic class TransactionServiceImpl implements TransactionService {\n    @Autowired\n    private final Firestore firestore;\n\n    private final String transactionCollection = \"transactions\";\n\n    public TransactionServiceImpl(Firestore firestore) {\n        this.firestore = firestore;\n    }\n\n    @Override\n    public List<Transaction> getAllTransactions(String profileId, int limit) throws ExecutionException, InterruptedException {\n        CollectionReference transactions = firestore.collection(transactionCollection);\n\n        //? Filter By ProfileId and sort by CreationDate (requires composite index)\n        Query query = transactions\n                .whereEqualTo(\"profileId\", profileId)\n                .orderBy(\"creationDate\", Query.Direction.DESCENDING)\n                .limit(limit);\n\n        QuerySnapshot querySnapshot = query.get().get();\n        List<QueryDocumentSnapshot> transactionDocuments = querySnapshot.getDocuments();\n\n        //? Handle if empty", "        if (transactionDocuments.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        //? Parse documents\n        return transactionDocuments.stream()\n                .map(queryDocumentSnapshot -> queryDocumentSnapshot.toObject(Transaction.class))\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public List<Transaction> getTransactionsByQuery(String profileId,\n                                                    String creationDate,\n                                                    String creationMonth,\n                                                    String creationYear,\n                                                    String transactionAmount,\n                                                    String transactionType,\n                                                    String transactionTag,\n                                                    String transactionRemarks,\n                                                    int limit) throws ExecutionException, InterruptedException, NullPointerException {\n\n        CollectionReference transactionCollectionRef = firestore.collection(transactionCollection);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId);\n\n        //? Build time query\n        query = TransactionQueryBuilder.buildQueryByTime(query, creationDate, creationMonth, creationYear);\n\n        //? Build transaction query\n        query = TransactionQueryBuilder.buildQueryByTransaction(query, transactionAmount,transactionType,transactionTag,transactionRemarks);\n\n        //? Query in the db\n        QuerySnapshot querySnapshot = query.get().get();\n        List<QueryDocumentSnapshot> transactionDocuments = querySnapshot.getDocuments();\n\n        return transactionDocuments.stream().map(queryDocumentSnapshot -> queryDocumentSnapshot.toObject(Transaction.class)).collect(Collectors.toList());\n\n    }\n\n    @Override\n    public List<Transaction> getTransactionsByRange(String profileId,\n                                       String startDate,\n                                       String endDate,\n                                       String creationDate,\n                                       String creationMonth,\n                                       String creationYear,\n                                       String startAmount,\n                                       String endAmount,\n                                       String transactionAmount,\n                                       String transactionType,\n                                       String transactionTag,\n                                       String transactionRemarks,\n                                       int limit) throws InterruptedException, ExecutionException, NullPointerException, ParseException {\n        CollectionReference transactionCollectionRef = firestore.collection(transactionCollection);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId);\n\n        //? Build time query by range\n        query = TransactionQueryBuilder.buildQueryByTimeRange(query,startDate,endDate,creationDate,creationMonth,creationYear);\n\n        //? Build transaction query by range\n        query = TransactionQueryBuilder.buildQueryByTransactionRange(query,startAmount,endAmount,transactionAmount,transactionType,transactionTag,transactionRemarks);\n\n        //? Query in the db\n        QuerySnapshot querySnapshot = query.get().get();\n        List<QueryDocumentSnapshot> transactionDocuments = querySnapshot.getDocuments();\n\n        return transactionDocuments.stream().map(queryDocumentSnapshot -> queryDocumentSnapshot.toObject(Transaction.class)).collect(Collectors.toList());\n    }\n\n    @Override", "    public Transaction getTransactionById(String profileId, String id) throws ExecutionException, InterruptedException {\n        CollectionReference transactions = firestore.collection(transactionCollection);\n        DocumentReference transactionDocument = transactions.document(id);\n        DocumentSnapshot transactionSnapshot = transactionDocument.get().get();\n\n        //? Check if the id belongs to the profile id\n        if(transactionSnapshot.exists() && transactionSnapshot.getString(\"profileId\").equals(profileId))\n            return transactionSnapshot.toObject(Transaction.class);\n\n        return null;\n    }\n\n    @Override", "    public String createTransaction(Transaction transaction) throws ExecutionException, InterruptedException {\n        ApiFuture<WriteResult> collectionApiFuture = firestore.collection(transactionCollection).document().set(transaction);\n        return collectionApiFuture.get().getUpdateTime().toString();\n    }\n\n    @Override\n    public String updateTransactionById(String id, Transaction transaction) throws ExecutionException, InterruptedException{\n        ApiFuture<WriteResult> collectionApiFuture = firestore.collection(transactionCollection).document(id).set(transaction);\n        return collectionApiFuture.get().getUpdateTime().toString();\n    }\n\n    @Override", "    public String deleteTransactionById(String id)  throws ExecutionException, InterruptedException {\n        ApiFuture<WriteResult> collectionApiFuture = firestore.collection(transactionCollection).document(id).delete();\n        return collectionApiFuture.get().getUpdateTime().toString();\n    }\n\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/impl/DashboardServiceImpl.java", "chunked_list": ["package in.limebrew.xpenseservice.service.impl;\n\nimport com.google.cloud.firestore.*;\n\nimport com.google.common.util.concurrent.AtomicDouble;\nimport in.limebrew.xpenseservice.entity.Transaction;\nimport in.limebrew.xpenseservice.service.DashboardService;\nimport in.limebrew.xpenseservice.utils.DateUtil;\nimport in.limebrew.xpenseservice.utils.TransactionUtil;\nimport org.springframework.beans.factory.annotation.Autowired;", "import in.limebrew.xpenseservice.utils.TransactionUtil;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.text.ParseException;\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\n\n@Service\npublic class DashboardServiceImpl implements DashboardService {\n    @Autowired\n    private final Firestore firestore;\n\n    private final String transactionCollection = \"transactions\";\n\n    public DashboardServiceImpl(Firestore firestore) {\n        this.firestore = firestore;\n    }\n\n    @Override\n    public Map<String,Object> getDashboardByQuery(String profileId, String creationDate, String creationMonth, String creationYear)  throws ExecutionException, InterruptedException, ParseException {\n        CollectionReference transactionCollectionRef = firestore.collection(transactionCollection);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId);\n\n        //? Check if Date was passed", "\n@Service\npublic class DashboardServiceImpl implements DashboardService {\n    @Autowired\n    private final Firestore firestore;\n\n    private final String transactionCollection = \"transactions\";\n\n    public DashboardServiceImpl(Firestore firestore) {\n        this.firestore = firestore;\n    }\n\n    @Override\n    public Map<String,Object> getDashboardByQuery(String profileId, String creationDate, String creationMonth, String creationYear)  throws ExecutionException, InterruptedException, ParseException {\n        CollectionReference transactionCollectionRef = firestore.collection(transactionCollection);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId);\n\n        //? Check if Date was passed", "        if(DateUtil.isValidDate(creationDate)){\n            query = query.whereEqualTo(\"creationDate\",creationDate);\n        }\n        //? Check if month was passed -> year\n        else if(TransactionUtil.isValidMonth(creationMonth) && TransactionUtil.isValidYear(creationYear)) {\n            query = query\n                    .whereEqualTo(\"creationMonth\",creationMonth)\n                    .whereEqualTo(\"creationYear\",Integer.parseInt(creationYear));\n\n            //? Order by Creation date\n\n        }\n        //? Check if year passed", "        else if(TransactionUtil.isValidYear(creationYear)){\n            query = query.whereEqualTo(\"creationYear\",Integer.parseInt(creationYear));\n\n        }\n        else {\n            return new HashMap<>();\n        }\n\n        //? Query in the db\n        QuerySnapshot querySnapshot = query.get().get();\n        List<QueryDocumentSnapshot> transactionDocuments = querySnapshot.getDocuments();\n\n        //? Handle if empty", "        if (transactionDocuments.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        //? Compute and return dashboard info\n        return TransactionUtil.computeDashboard(transactionDocuments);\n    }\n\n    @Override\n    public Map<String, Object> getDashboardByDateRange(String profileId, String startDate, String endDate) throws ExecutionException, InterruptedException, ParseException {\n        CollectionReference transactionCollectionRef = firestore.collection(transactionCollection);\n\n        //? Convert start and end date into unix timestamp\n        String startUnixTimeStamp = DateUtil.getUnixTimeFromDate(startDate);\n        String endUnixTimeStamp = DateUtil.getUnixTimeFromDate(endDate);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId)\n                                              .whereGreaterThan(\"creationTimeStamp\", startUnixTimeStamp)\n                                              .whereLessThan(\"creationTimeStamp\", endUnixTimeStamp);\n\n        //? Query in the db\n        QuerySnapshot querySnapshot = query.get().get();\n        List<QueryDocumentSnapshot> transactionDocuments = querySnapshot.getDocuments();\n\n        //? Handle if empty", "        if (transactionDocuments.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        //? Compute and return dashboard info\n        return TransactionUtil.computeDashboard(transactionDocuments);\n    }\n}\n"]}
{"filename": "src/main/java/in/limebrew/xpenseservice/service/impl/FirebaseAuthServiceImpl.java", "chunked_list": ["package in.limebrew.xpenseservice.service.impl;\n\nimport com.google.firebase.auth.FirebaseAuth;\nimport com.google.firebase.auth.FirebaseAuthException;\nimport com.google.firebase.auth.FirebaseToken;\nimport in.limebrew.xpenseservice.service.FirebaseAuthService;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class FirebaseAuthServiceImpl implements FirebaseAuthService {\n\n    @Override", "@Service\npublic class FirebaseAuthServiceImpl implements FirebaseAuthService {\n\n    @Override\n    public FirebaseToken verifyToken(String accessToken) throws FirebaseAuthException {\n        FirebaseAuth auth = FirebaseAuth.getInstance();\n        FirebaseToken decodedToken = auth.verifyIdToken(accessToken);\n        return decodedToken;\n    }\n}\n"]}
