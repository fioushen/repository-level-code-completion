{"filename": "BlockShuffle/src/Main.java", "chunked_list": ["package com.learnspigot.blockshuffle;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.*;\n\npublic class Main extends JavaPlugin {\n\n    private final List<Material> validBlocks = new ArrayList<>();\n    // a list of valid blocks that players can stand on\n\n    private final HashMap<UUID, Material> playerBlocks = new HashMap<>();\n    // a list of players who have a pending block to be found\n\n    private boolean running = false;\n    // a boolean which dictates if the minigames is running or not\n\n    @Override", "import java.util.*;\n\npublic class Main extends JavaPlugin {\n\n    private final List<Material> validBlocks = new ArrayList<>();\n    // a list of valid blocks that players can stand on\n\n    private final HashMap<UUID, Material> playerBlocks = new HashMap<>();\n    // a list of players who have a pending block to be found\n\n    private boolean running = false;\n    // a boolean which dictates if the minigames is running or not\n\n    @Override", "    public void onEnable() {\n\n        for (Material material : Material.values()) {\n            if (material.isBlock()) validBlocks.add(material);\n        }\n        // add all valid blocks to the list\n\n        getCommand(\"shuffle\").setExecutor(new ShuffleCommand(this));\n        // register the command class\n\n        Bukkit.getScheduler().runTaskTimer(this, new Runnable() {\n\n            private int secondsUntilNextRound = 5 * 60;\n            // store the time until next round\n\n            @Override", "            public void run() {\n\n                if (!isRunning()) { // if the minigame is not running, reset any data\n                    if (!playerBlocks.isEmpty()) playerBlocks.clear();\n                    secondsUntilNextRound = 5 * 60;\n                    return;\n                }\n\n                if (secondsUntilNextRound == 5 * 60) { // if the round has just started\n                    for (Player player : Bukkit.getOnlinePlayers()) {\n                        Material random = validBlocks.get(new Random().nextInt(validBlocks.size()));\n                        playerBlocks.put(player.getUniqueId(), random);\n                        player.sendMessage(ChatColor.AQUA + \"You must find and stand on a \" + random.name());\n                        // assign the player a random block\n                    }", "                if (secondsUntilNextRound == 5 * 60) { // if the round has just started\n                    for (Player player : Bukkit.getOnlinePlayers()) {\n                        Material random = validBlocks.get(new Random().nextInt(validBlocks.size()));\n                        playerBlocks.put(player.getUniqueId(), random);\n                        player.sendMessage(ChatColor.AQUA + \"You must find and stand on a \" + random.name());\n                        // assign the player a random block\n                    }\n                } else if (playerBlocks.isEmpty()) { // if everyone has found their block\n                    secondsUntilNextRound = 5 * 60;\n                    broadcast(ChatColor.GOLD + \"Everyone has found their block!\");\n                    // end the game\n                    return;\n                }\n", "                if (secondsUntilNextRound == 0) { // if the round is over\n                    for (UUID uuid : playerBlocks.keySet()) {\n                        if (Bukkit.getPlayer(uuid) == null) continue;\n                        broadcast(ChatColor.RED + Bukkit.getPlayer(uuid).getName() + \" has failed to find their block!\");\n                    }\n                    setRunning(false);\n                    // display the losers, and stop the game\n\n                } else {\n                    for (Player player : Bukkit.getOnlinePlayers()) {\n                        if (playerBlocks.containsKey(player.getUniqueId())) { // if the player has a pending block", "                    for (Player player : Bukkit.getOnlinePlayers()) {\n                        if (playerBlocks.containsKey(player.getUniqueId())) { // if the player has a pending block\n                            if (player.getLocation().getBlock().getRelative(0, -1, 0).getType() == playerBlocks.get(player.getUniqueId())) {\n                                // if the player is standing on the block\n                                broadcast(ChatColor.GREEN + player.getName() + \" has found their block!\");\n                                playerBlocks.remove(player.getUniqueId());\n                                // remove the pending block\n                            }\n                        }\n\n                        if (secondsUntilNextRound <= 30 && !(secondsUntilNextRound % 5 != 0 && secondsUntilNextRound > 5)) {\n                            broadcast(ChatColor.YELLOW + \"You have \" + secondsUntilNextRound + \" seconds remaining!\");\n                            // display when there are 30, 25, 20, 15, 10, 5, 4, 3, 2 and 1 seconds left\n                        }\n                    }\n                }\n\n                secondsUntilNextRound--;\n                // update the time\n            }\n        }, 20, 20);\n\n    }\n", "                        if (secondsUntilNextRound <= 30 && !(secondsUntilNextRound % 5 != 0 && secondsUntilNextRound > 5)) {\n                            broadcast(ChatColor.YELLOW + \"You have \" + secondsUntilNextRound + \" seconds remaining!\");\n                            // display when there are 30, 25, 20, 15, 10, 5, 4, 3, 2 and 1 seconds left\n                        }\n                    }\n                }\n\n                secondsUntilNextRound--;\n                // update the time\n            }\n        }, 20, 20);\n\n    }\n", "    public boolean isRunning() { return running; }\n    public void setRunning(boolean running) { this.running = running; }\n\n    private void broadcast(String msg) {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            player.sendMessage(msg);\n        }\n    }\n}\n"]}
{"filename": "BlockShuffle/src/ShuffleCommand.java", "chunked_list": ["package com.learnspigot.blockshuffle;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\npublic class ShuffleCommand implements CommandExecutor {\n\n    private final Main main;\n\n    public ShuffleCommand(Main main) {\n        this.main = main;\n    }\n\n    @Override", "\npublic class ShuffleCommand implements CommandExecutor {\n\n    private final Main main;\n\n    public ShuffleCommand(Main main) {\n        this.main = main;\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\n        main.setRunning(!main.isRunning());", "    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\n        main.setRunning(!main.isRunning());\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            if (main.isRunning()) {\n                player.sendMessage(ChatColor.GREEN + \"The block shuffle has started!\");\n            } else {\n                player.sendMessage(ChatColor.RED + \"The block shuffle has stopped!\");\n            }\n        }\n\n        return false;\n    }\n\n}\n"]}
{"filename": "InvSee/src/main/java/com/panav/Invsee/InvSee.java", "chunked_list": ["package com.panav.Invsee;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;", "import org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.*;\n\n\npublic class InvSee implements CommandExecutor {\n    @Override\n    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n", "public class InvSee implements CommandExecutor {\n    @Override\n    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n\n        if (!(sender instanceof Player player)) return true;\n        if (args.length == 0) return true;\n\n        if (!player.hasPermission(\"invsee.command\")) {\n            player.sendMessage(ChatColor.RED + \"You don't have the permission invsee.command!\");\n            return true;\n        }\n", "        if (Bukkit.getPlayer(args[0]) == null){\n            player.sendMessage(ChatColor.AQUA + \"Target not found\");\n            return true;\n        }\n\n        Player target = Bukkit.getPlayer(args[0]);\n\n        player.openInventory(getInventory(target));\n        return true;\n    }\n\n", "    public Inventory getInventory(Player target){\n        Inventory inv = Bukkit.createInventory(null, 54, ChatColor.RED + target.getName() + \"'s Inventory\");\n\n        ItemStack[] armour = target.getInventory().getArmorContents();\n        ItemStack[] invContent = target.getInventory().getStorageContents();\n\n        List<ItemStack> contents = new ArrayList<>(Arrays.asList(invContent));\n\n        for (int i = 0; i < 9; i++){\n            contents.add(new ItemStack(Material.BLACK_STAINED_GLASS_PANE));\n        }\n\n        Collections.addAll(contents, armour);\n\n        ItemStack[] cont = contents.toArray(new ItemStack[0]);\n\n        inv.setContents(cont);\n        return inv;\n    }\n}\n", "        for (int i = 0; i < 9; i++){\n            contents.add(new ItemStack(Material.BLACK_STAINED_GLASS_PANE));\n        }\n\n        Collections.addAll(contents, armour);\n\n        ItemStack[] cont = contents.toArray(new ItemStack[0]);\n\n        inv.setContents(cont);\n        return inv;\n    }\n}\n"]}
{"filename": "InvSee/src/main/java/com/panav/Invsee/Main.java", "chunked_list": ["package com.panav.Invsee;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic final class Main extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        getCommand(\"inv\").setExecutor(new InvSee());\n        Bukkit.getPluginManager().registerEvents(new testListener(), this);\n\n    }\n\n\n}\n", "    public void onEnable() {\n        getCommand(\"inv\").setExecutor(new InvSee());\n        Bukkit.getPluginManager().registerEvents(new testListener(), this);\n\n    }\n\n\n}\n"]}
{"filename": "InvSee/src/main/java/com/panav/Invsee/testListener.java", "chunked_list": ["package com.panav.Invsee;\n\nimport com.destroystokyo.paper.event.player.PlayerJumpEvent;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\n\npublic class testListener implements Listener {\n\n    @EventHandler\n    public void onJump(PlayerJumpEvent e){\n\n    }\n}\n", "    public void onJump(PlayerJumpEvent e){\n\n    }\n}\n"]}
{"filename": "FreezeWand/src/FreezeWand.java", "chunked_list": ["package com.learnspigot.freezewand;\n\nimport com.learnspigot.freezewand.profile.Profile;\nimport com.learnspigot.freezewand.profile.ProfileHandler;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerInteractAtEntityEvent;\nimport org.bukkit.event.player.PlayerJoinEvent;", "import org.bukkit.event.player.PlayerInteractAtEntityEvent;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.event.player.PlayerMoveEvent;\nimport org.bukkit.inventory.EquipmentSlot;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Optional;\n\npublic final class FreezeWand extends JavaPlugin implements Listener {\n\n    // Declare profile handler\n    private ProfileHandler profileHandler;\n\n    @Override", "\npublic final class FreezeWand extends JavaPlugin implements Listener {\n\n    // Declare profile handler\n    private ProfileHandler profileHandler;\n\n    @Override\n    public void onEnable() {\n        // Instantiate profile handler\n        profileHandler = new ProfileHandler();\n\n        // Register the event listeners in this class\n        getServer().getPluginManager().registerEvents(this, this);\n    }\n\n    @EventHandler", "    public void onPlayerInteractAtEntity(@NotNull final PlayerInteractAtEntityEvent e) {\n        // If the entity interacted with wasn't a player,\n        // the player wasn't holding a stick,\n        // or if the hand wasn't the main hand,\n        // return\n        if (!(e.getRightClicked() instanceof Player) ||\n                e.getPlayer().getInventory().getItemInMainHand().getType() != Material.STICK ||\n                e.getHand() != EquipmentSlot.HAND) {\n            return;\n        }\n\n        // Attempt to get both players' profiles\n        final Optional<Profile> optionalProfile = profileHandler.findByUniqueId(e.getPlayer().getUniqueId());\n        final Optional<Profile> optionalTarget = profileHandler.findByUniqueId(e.getRightClicked().getUniqueId());\n\n        // If either profile isn't present, return", "        if (!optionalProfile.isPresent() || !optionalTarget.isPresent()) {\n            return;\n        }\n\n        // Get the profile from the optional\n        final Profile profile = optionalProfile.get();\n        final Profile target = optionalTarget.get();\n\n        // Set the target's frozen state to the opposite\n        target.setFrozen(!target.isFrozen());\n\n        // Send the target and profile a message to update them on the target's frozen status\n        target.sendMessage(\"&eYou have been \" + (target.isFrozen() ? \"\" : \"un\") + \"frozen!\");\n        profile.sendMessage(\"&eYou have \" + (target.isFrozen() ? \"\" : \"un\") + \"frozen \" + target.getName() + \"!\");\n    }\n\n    @EventHandler", "    public void onPlayerMove(@NotNull final PlayerMoveEvent e) {\n        // Null check for the to location\n        if (e.getTo() == null) {\n            return;\n        }\n\n        // If the x, y and z coordinates are the same, return\n        if (e.getFrom().getX() == e.getTo().getX() && e.getFrom().getY() == e.getTo().getY() && e.getFrom().getZ() == e.getTo().getZ()) {\n            return;\n        }\n\n        // Attempt to get profile\n        final Optional<Profile> optionalProfile = profileHandler.findByUniqueId(e.getPlayer().getUniqueId());\n\n        // If profile isn't present, return", "        if (!optionalProfile.isPresent()) {\n            return;\n        }\n\n        // Get the profile from the optional\n        final Profile profile = optionalProfile.get();\n\n        // If the profile is frozen, cancel the player's movement\n        if (profile.isFrozen()) {\n            e.setCancelled(true);\n        }\n    }\n\n    @EventHandler", "        if (profile.isFrozen()) {\n            e.setCancelled(true);\n        }\n    }\n\n    @EventHandler\n    public void onPlayerJoin(@NotNull final PlayerJoinEvent e) {\n        // Check if profile exists for player\n        if (profileHandler.exists(e.getPlayer().getUniqueId())) {\n            // If it does, and the profile isn't null, update their name\n            profileHandler.findByUniqueId(e.getPlayer().getUniqueId()).ifPresent(\n                    profile -> profile.setName(e.getPlayer().getName())\n            );\n        } else {\n            // If they don't exist already, register a profile for them\n            profileHandler.register(e.getPlayer().getUniqueId(), e.getPlayer().getName());\n        }\n    }\n\n}\n", "        if (profileHandler.exists(e.getPlayer().getUniqueId())) {\n            // If it does, and the profile isn't null, update their name\n            profileHandler.findByUniqueId(e.getPlayer().getUniqueId()).ifPresent(\n                    profile -> profile.setName(e.getPlayer().getName())\n            );\n        } else {\n            // If they don't exist already, register a profile for them\n            profileHandler.register(e.getPlayer().getUniqueId(), e.getPlayer().getName());\n        }\n    }\n\n}\n"]}
{"filename": "FreezeWand/src/profile/Profile.java", "chunked_list": ["package com.learnspigot.freezewand.profile;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic final class Profile {\n\n    // The player's unique id & username\n    private final UUID uniqueId;\n    private String name;\n\n    // If they themselves are frozen\n    private boolean frozen = false;\n\n    // Constructor takes the player's unique id & username\n    public Profile(@NotNull final UUID uniqueId, @NotNull final String name) {\n        this.uniqueId = uniqueId;\n        this.name = name;\n    }\n\n    // Get the player's unique id\n    @NotNull", "\npublic final class Profile {\n\n    // The player's unique id & username\n    private final UUID uniqueId;\n    private String name;\n\n    // If they themselves are frozen\n    private boolean frozen = false;\n\n    // Constructor takes the player's unique id & username\n    public Profile(@NotNull final UUID uniqueId, @NotNull final String name) {\n        this.uniqueId = uniqueId;\n        this.name = name;\n    }\n\n    // Get the player's unique id\n    @NotNull", "    public UUID getUniqueId() {\n        return uniqueId;\n    }\n\n    // Get the player's name\n    @NotNull\n    public String getName() {\n        return name;\n    }\n\n    // Set player's name", "    public void setName(@NotNull final String name) {\n        this.name = name;\n    }\n\n    // Check if the player themselves is frozen\n    public boolean isFrozen() {\n        return frozen;\n    }\n\n    // Set whether the player themselves is frozen\n    public void setFrozen(final boolean frozen) {\n        this.frozen = frozen;\n    }\n\n    // Send a chat message to the player", "    public void setFrozen(final boolean frozen) {\n        this.frozen = frozen;\n    }\n\n    // Send a chat message to the player\n    public void sendMessage(@NotNull final String message) {\n        Objects.requireNonNull(Bukkit.getPlayer(uniqueId))\n                .sendMessage(ChatColor.translateAlternateColorCodes('&', message));\n    }\n\n}\n"]}
{"filename": "FreezeWand/src/profile/ProfileHandler.java", "chunked_list": ["package com.learnspigot.freezewand.profile;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\nimport java.util.HashMap;\n\npublic final class ProfileHandler {\n\n    // Declare a map for storing profiles, player's unique id as key\n    private final Map<UUID, Profile> profileMap = new HashMap<>();\n\n    // Public constructor, allow for instantiation\n    public ProfileHandler() {\n\n    }\n\n    // Register a new profile into the handler", "\npublic final class ProfileHandler {\n\n    // Declare a map for storing profiles, player's unique id as key\n    private final Map<UUID, Profile> profileMap = new HashMap<>();\n\n    // Public constructor, allow for instantiation\n    public ProfileHandler() {\n\n    }\n\n    // Register a new profile into the handler", "    public void register(@NotNull final UUID uniqueId, @NotNull final String name) {\n        profileMap.put(uniqueId, new Profile(uniqueId, name));\n    }\n\n    // Find a potential profile based off of player unique id\n    @NotNull\n    public Optional<Profile> findByUniqueId(@NotNull final UUID uniqueId) {\n        return Optional.of(profileMap.get(uniqueId));\n    }\n\n    // Check if a UUID exists in the map", "    public boolean exists(@NotNull final UUID uniqueId) {\n        return profileMap.containsKey(uniqueId);\n    }\n\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/ProximityChat.java", "chunked_list": ["package cc.stormlabs.proximitychat;\n\nimport cc.stormlabs.proximitychat.commands.GiveMegaphoneCommand;\nimport cc.stormlabs.proximitychat.commands.GlobalChatCommand;\nimport cc.stormlabs.proximitychat.events.AsyncPlayerChat;\nimport cc.stormlabs.proximitychat.manager.ConfigManager;\nimport cc.stormlabs.proximitychat.utils.CustomColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.inventory.ItemStack;", "import org.bukkit.Material;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.Collections;\nimport java.util.Objects;\n\npublic final class ProximityChat extends JavaPlugin {\n\n    private ConfigManager configManager;\n\n    @Override", "public final class ProximityChat extends JavaPlugin {\n\n    private ConfigManager configManager;\n\n    @Override\n    public void onEnable() {\n        configManager = new ConfigManager(this);\n        Bukkit.getPluginManager().registerEvents(new AsyncPlayerChat(this), this);\n        Objects.requireNonNull(getCommand(\"gmp\")).setExecutor(new GiveMegaphoneCommand(getMegaphone()));\n        Objects.requireNonNull(getCommand(\"gc\")).setExecutor(new GlobalChatCommand(getConfigManager()));\n    }\n\n    @Override", "    public void onDisable() {\n\n    }\n\n    public ConfigManager getConfigManager() {\n        return configManager;\n    }\n\n    public ItemStack getMegaphone() {\n        ItemStack megaphone = new ItemStack(Material.STICK);\n        ItemMeta megaphoneMeta = megaphone.getItemMeta();\n", "    public ItemStack getMegaphone() {\n        ItemStack megaphone = new ItemStack(Material.STICK);\n        ItemMeta megaphoneMeta = megaphone.getItemMeta();\n\n        if(megaphoneMeta != null) {\n            megaphoneMeta.setDisplayName(CustomColor.translate(\"&a&lMegaphone\"));\n            megaphoneMeta.setLore(Collections.singletonList(CustomColor.translate(\"&7Increases your talk rang to &e\"\n                            + getConfigManager().getMegaphoneRange()\n                            + \" &7blocks!\")));\n            megaphone.setItemMeta(megaphoneMeta);\n        }\n\n        return megaphone;\n    }\n\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/commands/GiveMegaphoneCommand.java", "chunked_list": ["package cc.stormlabs.proximitychat.commands;\n\nimport cc.stormlabs.proximitychat.utils.CustomColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\n\npublic class GiveMegaphoneCommand implements CommandExecutor {\n\n    private final ItemStack megaphone;\n\n    public GiveMegaphoneCommand(ItemStack megaphone) {\n        this.megaphone = megaphone;\n    }\n\n    @Override", "import org.bukkit.inventory.ItemStack;\n\npublic class GiveMegaphoneCommand implements CommandExecutor {\n\n    private final ItemStack megaphone;\n\n    public GiveMegaphoneCommand(ItemStack megaphone) {\n        this.megaphone = megaphone;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        if(!sender.hasPermission(\"proximitychat.megaphone\")) {\n            sender.sendMessage(CustomColor.translate(\"&cYou aren't allowed to do that!\"));\n            return false;\n        }\n\n        if(args.length == 0) {\n\n            if(!(sender instanceof Player)) {\n                sender.sendMessage(CustomColor.translate(\"&eThis command is only for players!\"));\n                return false;\n            }\n\n            Player player = (Player) sender;\n\n            player.getInventory().addItem(megaphone);\n            player.sendMessage(CustomColor.translate(\"&7Congrats! &aYou &7now have a megaphone.\"));\n            return true;\n", "            if(!(sender instanceof Player)) {\n                sender.sendMessage(CustomColor.translate(\"&eThis command is only for players!\"));\n                return false;\n            }\n\n            Player player = (Player) sender;\n\n            player.getInventory().addItem(megaphone);\n            player.sendMessage(CustomColor.translate(\"&7Congrats! &aYou &7now have a megaphone.\"));\n            return true;\n", "        } else if(args.length == 1) {\n\n            Player target = Bukkit.getPlayer(args[0]);\n            if(target == null) {\n                sender.sendMessage(CustomColor.translate(\"&a\" + args[0] + \" &7is &cnot &7online.\"));\n                return false;\n            }\n\n            if(((Player) sender).getUniqueId().equals(target.getUniqueId())) {\n                ((Player) sender).performCommand(\"gmp\");\n                return true;\n            }\n\n            target.getInventory().addItem(megaphone);\n            target.sendMessage(CustomColor.translate(\"&7Congrats! &aYou &7now have a megaphone.\"));\n            sender.sendMessage(CustomColor.translate(\"&7Congrats! &a\" + target.getName() + \" &7now has a megaphone.\"));\n            return true;\n\n        } else {\n            sender.sendMessage(CustomColor.translate(\"&7Invalid usage.. Try &e/gmp (player)&7.\"));\n        }\n\n        return false;\n    }\n}\n", "            if(((Player) sender).getUniqueId().equals(target.getUniqueId())) {\n                ((Player) sender).performCommand(\"gmp\");\n                return true;\n            }\n\n            target.getInventory().addItem(megaphone);\n            target.sendMessage(CustomColor.translate(\"&7Congrats! &aYou &7now have a megaphone.\"));\n            sender.sendMessage(CustomColor.translate(\"&7Congrats! &a\" + target.getName() + \" &7now has a megaphone.\"));\n            return true;\n\n        } else {\n            sender.sendMessage(CustomColor.translate(\"&7Invalid usage.. Try &e/gmp (player)&7.\"));\n        }\n\n        return false;\n    }\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/commands/GlobalChatCommand.java", "chunked_list": ["package cc.stormlabs.proximitychat.commands;\n\nimport cc.stormlabs.proximitychat.manager.ConfigManager;\nimport cc.stormlabs.proximitychat.utils.CustomColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\npublic class GlobalChatCommand implements CommandExecutor {\n\n    private final ConfigManager configManager;\n\n    public GlobalChatCommand(ConfigManager configManager) {\n        this.configManager = configManager;\n    }\n\n    @Override", "import org.bukkit.entity.Player;\n\npublic class GlobalChatCommand implements CommandExecutor {\n\n    private final ConfigManager configManager;\n\n    public GlobalChatCommand(ConfigManager configManager) {\n        this.configManager = configManager;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        if(!configManager.allowGlobalChat()) return false;\n\n        if(!(sender instanceof Player)) {\n            sender.sendMessage(CustomColor.translate(\"&eThis command is only for players!\"));\n            return false;\n        }\n\n        Player player = (Player) sender;\n", "        if(args.length < 1) {\n            sender.sendMessage(CustomColor.translate(\"&7Invalid usage.. Try &e/gc <message>&7.\"));\n            return false;\n        }\n\n        StringBuilder builder = new StringBuilder();\n        for (String word : args) {\n            builder.append(word).append(\" \");\n        }\n\n        Bukkit.broadcastMessage(CustomColor.translate(\"&8[&5GC&8] &a\" + player.getName() + \" &8\u2192 &7\" + builder.toString().trim()));\n        return true;\n    }\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/utils/CustomColor.java", "chunked_list": ["package cc.stormlabs.proximitychat.utils;\n\nimport org.bukkit.ChatColor;\n\npublic class CustomColor {\n\n    public static String translate(String message) {\n        return ChatColor.translateAlternateColorCodes('&', message);\n    }\n\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/events/AsyncPlayerChat.java", "chunked_list": ["package cc.stormlabs.proximitychat.events;\n\nimport cc.stormlabs.proximitychat.ProximityChat;\nimport cc.stormlabs.proximitychat.manager.ConfigManager;\nimport cc.stormlabs.proximitychat.utils.CustomColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;", "import org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\nimport org.bukkit.inventory.ItemStack;\n\npublic class AsyncPlayerChat implements Listener {\n\n    private final ConfigManager configManager;\n    private final ItemStack megaphone;\n\n    public AsyncPlayerChat(ProximityChat plugin) {\n        this.configManager = plugin.getConfigManager();\n        this.megaphone = plugin.getMegaphone();\n    }\n\n    @EventHandler", "    public void onAsyncPlayerChat(AsyncPlayerChatEvent event) {\n        Player player = event.getPlayer();\n        event.setCancelled(true);\n\n        Bukkit.getOnlinePlayers().forEach(target -> {\n            if(target.getUniqueId().equals(player.getUniqueId())) return;\n            int distance = (int) player.getLocation().distance(target.getLocation());\n            if(player.getInventory().getItemInMainHand().equals(megaphone)) {\n                if(distance <= configManager.getMegaphoneRange()) {\n                    if(configManager.showPlayerDistance()) {\n                        target.sendMessage(CustomColor.translate(\"&8[&e\" + distance + \"m&8] &a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                        return;\n                    }\n                    target.sendMessage(CustomColor.translate(\"&a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                }\n            } else {", "                if(distance <= configManager.getMegaphoneRange()) {\n                    if(configManager.showPlayerDistance()) {\n                        target.sendMessage(CustomColor.translate(\"&8[&e\" + distance + \"m&8] &a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                        return;\n                    }\n                    target.sendMessage(CustomColor.translate(\"&a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                }\n            } else {\n                if(distance <= configManager.getTalkRange()) {\n                    if(configManager.showPlayerDistance()) {\n                        target.sendMessage(CustomColor.translate(\"&8[&e\" + distance + \"m&8] &a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                        return;\n                    }\n                    target.sendMessage(CustomColor.translate(\"&a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                }\n            }\n        });\n\n        player.sendMessage(CustomColor.translate(\"&a&lYOU\" + \" &8\u2192 &7\" + event.getMessage()));\n    }\n\n}\n", "                if(distance <= configManager.getTalkRange()) {\n                    if(configManager.showPlayerDistance()) {\n                        target.sendMessage(CustomColor.translate(\"&8[&e\" + distance + \"m&8] &a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                        return;\n                    }\n                    target.sendMessage(CustomColor.translate(\"&a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                }\n            }\n        });\n\n        player.sendMessage(CustomColor.translate(\"&a&lYOU\" + \" &8\u2192 &7\" + event.getMessage()));\n    }\n\n}\n"]}
{"filename": "ProximityChat/src/main/java/cc/stormlabs/proximitychat/manager/ConfigManager.java", "chunked_list": ["package cc.stormlabs.proximitychat.manager;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class ConfigManager {\n\n    private final FileConfiguration configuration;\n\n    public ConfigManager(JavaPlugin plugin) {\n        this.configuration = plugin.getConfig();\n        this.configuration.options().copyDefaults(true);\n        plugin.saveDefaultConfig();\n    }\n", "    public int getTalkRange() {\n        return this.configuration.getInt(\"talk-range\");\n    }\n\n    // value gets added to the default talk range\n    public int getMegaphoneRange() {\n        return getTalkRange() + this.configuration.getInt(\"megaphone-range\");\n    }\n\n    public boolean showPlayerDistance() {\n        return this.configuration.getBoolean(\"show-distance\");\n    }\n", "    public boolean showPlayerDistance() {\n        return this.configuration.getBoolean(\"show-distance\");\n    }\n\n    public boolean allowGlobalChat() {\n        return this.configuration.getBoolean(\"allow-global-chat\");\n    }\n\n}\n"]}
{"filename": "GrapplingHooks/src/main/java/me/superpenguin/grapplinghooks/GrapplingHook.java", "chunked_list": ["package me.superpenguin.grapplinghooks;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.enchantments.Enchantment;", "import org.bukkit.command.CommandSender;\nimport org.bukkit.enchantments.Enchantment;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerFishEvent;\nimport org.bukkit.inventory.ItemFlag;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.util.Vector;", "import org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.util.Vector;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrapplingHook implements Listener, CommandExecutor {\n\n    GrapplingHooksMain plugin;\n\n    public GrapplingHook(GrapplingHooksMain plugin){\n        this.plugin = plugin;\n        Bukkit.getPluginManager().registerEvents(this, plugin);\n        plugin.getCommand(\"grapplinghook\").setExecutor(this);\n    }\n\n    // Arbritrary value determining how much power the grappling hook has\n    private final int POWER = 3;\n\n    private final ArrayList<UUID> grappling = new ArrayList<>();\n\n    // If you don't want a cooldown, you can just remove the 3 cooldown parts :) (1)\n    private final int COOLDOWN_SECONDS = 3;\n    private final Cache<UUID, Long> onCooldown = CacheBuilder.newBuilder().expireAfterWrite(COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n\n\n    @EventHandler", "public class GrapplingHook implements Listener, CommandExecutor {\n\n    GrapplingHooksMain plugin;\n\n    public GrapplingHook(GrapplingHooksMain plugin){\n        this.plugin = plugin;\n        Bukkit.getPluginManager().registerEvents(this, plugin);\n        plugin.getCommand(\"grapplinghook\").setExecutor(this);\n    }\n\n    // Arbritrary value determining how much power the grappling hook has\n    private final int POWER = 3;\n\n    private final ArrayList<UUID> grappling = new ArrayList<>();\n\n    // If you don't want a cooldown, you can just remove the 3 cooldown parts :) (1)\n    private final int COOLDOWN_SECONDS = 3;\n    private final Cache<UUID, Long> onCooldown = CacheBuilder.newBuilder().expireAfterWrite(COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n\n\n    @EventHandler", "    public void onFishingRodUse(PlayerFishEvent event) {\n        UUID uuid = event.getPlayer().getUniqueId();\n        // Called when they cast the fishing rod\n        if (event.getState() == PlayerFishEvent.State.FISHING) {\n            // Ensure they are using the grappling hook\n            if (event.getHand() == null) return;\n            ItemStack inHand = event.getPlayer().getInventory().getItem(event.getHand());\n            if (inHand == null || !inHand.hasItemMeta() || !inHand.getItemMeta().hasLocalizedName() || !inHand.getItemMeta().getLocalizedName().equals(\"GrapplingHook\")) return;\n\n            // Check if they are on cooldown and return if they are. (2)\n            long timeUntilUse = onCooldown.getIfPresent(uuid) == null ? 0 : onCooldown.getIfPresent(uuid) - System.currentTimeMillis();", "            if (timeUntilUse > 0) {\n                event.setCancelled(true);\n                event.getPlayer().sendMessage(\"You cannot use this for another \" + Math.round(timeUntilUse / 1000.0) + \" seconds\");\n                return;\n            }\n\n            // Add them to the list so we know they're grappling\n            grappling.add(uuid);\n\n        // When they reel in a fishing rod, check that they are grappling.\n        } else if (event.getState() == PlayerFishEvent.State.REEL_IN && grappling.contains(uuid)) {\n            // Get a vector pointing from the player to the fishing hook and add it to the players existing velocity.\n            Vector additionalVelocity = event.getHook().getLocation().subtract(event.getPlayer().getLocation()).toVector().normalize().multiply(POWER);\n            event.getPlayer().setVelocity(event.getPlayer().getVelocity().add(additionalVelocity));\n            grappling.remove(uuid);\n\n            // Put the player on a cooldown (3)\n            onCooldown.put(uuid, System.currentTimeMillis() + (COOLDOWN_SECONDS * 1000));\n", "        } else if (event.getState() == PlayerFishEvent.State.REEL_IN && grappling.contains(uuid)) {\n            // Get a vector pointing from the player to the fishing hook and add it to the players existing velocity.\n            Vector additionalVelocity = event.getHook().getLocation().subtract(event.getPlayer().getLocation()).toVector().normalize().multiply(POWER);\n            event.getPlayer().setVelocity(event.getPlayer().getVelocity().add(additionalVelocity));\n            grappling.remove(uuid);\n\n            // Put the player on a cooldown (3)\n            onCooldown.put(uuid, System.currentTimeMillis() + (COOLDOWN_SECONDS * 1000));\n\n        } else if (grappling.contains(uuid)) {\n            // they probably caught a fish, let's remove them from the list :)\n            grappling.remove(uuid);\n        }\n    }\n", "        } else if (grappling.contains(uuid)) {\n            // they probably caught a fish, let's remove them from the list :)\n            grappling.remove(uuid);\n        }\n    }\n\n    public static ItemStack getItem() {\n        ItemStack item = new ItemStack(Material.FISHING_ROD);\n        ItemMeta meta = item.getItemMeta();\n\n        // Customise your item here\n        meta.setDisplayName(\"Grappling Hook\");\n        meta.setLocalizedName(\"GrapplingHook\"); // <-- Identifier for the item\n        meta.addEnchant(Enchantment.DURABILITY, 1, false);\n        meta.addItemFlags(ItemFlag.HIDE_ENCHANTS);\n        meta.setLore(Arrays.asList(\"This is a grappling hook\"));\n\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        // When your function doesn't specify a return type you can use \"return sender.sendMessage...\"\n        if (!sender.hasPermission(\"grapplinghook.give\")) {\n            sender.sendMessage(\"You do not have permission for this\");\n            return true;\n        }\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(\"You must be a player\");\n            return true;\n        }\n        // You can specify more conditions here if you wish to extend the command to support giving it to other players.\n\n        ((Player) sender).getInventory().addItem(getItem());\n        sender.sendMessage(\"Recived a Grappling Hook!\");\n        return true;\n    }\n\n}\n"]}
{"filename": "GrapplingHooks/src/main/java/me/superpenguin/grapplinghooks/GrapplingHooksMain.java", "chunked_list": ["package me.superpenguin.grapplinghooks;\n\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class GrapplingHooksMain extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        new GrapplingHook(this);\n    }\n\n}\n"]}
{"filename": "Warps/src/main/java/me/snat/warps/Main.java", "chunked_list": ["package me.snat.warps;\n\nimport me.snat.warps.commands.DeleteWarpCommand;\nimport me.snat.warps.commands.SetWarpCommand;\nimport me.snat.warps.commands.WarpCommand;\nimport me.snat.warps.managers.WarpManager;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic final class Main extends JavaPlugin {\n\n    private WarpManager warpManager;\n\n    @Override", "public final class Main extends JavaPlugin {\n\n    private WarpManager warpManager;\n\n    @Override\n    public void onEnable() {\n        getCommand(\"warp\").setExecutor(new WarpCommand(this));\n        getCommand(\"setwarp\").setExecutor(new SetWarpCommand(this));\n        getCommand(\"delwarp\").setExecutor(new DeleteWarpCommand(this));\n        \n        warpManager = new WarpManager(this);\n    }\n", "    public WarpManager getWarpManager() { return warpManager; }\n\n}\n"]}
{"filename": "Warps/src/main/java/me/snat/warps/commands/DeleteWarpCommand.java", "chunked_list": ["package me.snat.warps.commands;\n\nimport me.snat.warps.Main;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\n\npublic class DeleteWarpCommand implements CommandExecutor {\n\n    private Main main;\n\n    public DeleteWarpCommand(Main main) {\n        this.main = main;\n    }\n\n\n    @Override", "import org.bukkit.entity.Player;\n\npublic class DeleteWarpCommand implements CommandExecutor {\n\n    private Main main;\n\n    public DeleteWarpCommand(Main main) {\n        this.main = main;\n    }\n\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        YamlConfiguration warps = main.getWarpManager().getWarps();\n\n        Player player = (Player) sender;\n        if (!(sender instanceof Player)) return false;\n\n        if (args.length == 0) {\n            player.sendMessage(ChatColor.RED + \"Please specify a warp name.\");\n            return true;\n        }\n", "        if (!warps.contains(args[0])) {\n            player.sendMessage(ChatColor.RED + \"That warp does not exist.\");\n            return true;\n        }\n\n        warps.set(args[0], null);\n        main.getWarpManager().saveWarps();\n        player.sendMessage(ChatColor.GOLD + \"Warp \" + args[0] + \" has been deleted!\");\n        return true;\n    }\n}\n"]}
{"filename": "Warps/src/main/java/me/snat/warps/commands/SetWarpCommand.java", "chunked_list": ["package me.snat.warps.commands;\n\nimport me.snat.warps.Main;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;", "import org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\n\npublic class SetWarpCommand implements CommandExecutor {\n\n    private Main main;\n\n    public SetWarpCommand(Main main) {\n        this.main = main;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        YamlConfiguration warps = main.getWarpManager().getWarps();\n\n        Player player = (Player) sender;\n        if (!(sender instanceof Player)) return false;\n\n        if (args.length == 0) {\n            player.sendMessage(ChatColor.RED + \"Please specify a name for the warp.\");\n            return true;\n        }\n", "        if (warps.contains(args[0])) {\n            player.sendMessage(ChatColor.RED + \"A warp with that name already exists.\");\n            return true;\n        }\n\n        Location loc = player.getLocation();\n\n        main.getWarpManager().setWarp(args[0], loc);\n        main.getWarpManager().saveWarps();\n\n        player.sendMessage(ChatColor.GOLD + \"Warp \" + args[0] + \" has been created!\" );\n\n        return true;\n    }\n}\n"]}
{"filename": "Warps/src/main/java/me/snat/warps/commands/WarpCommand.java", "chunked_list": ["package me.snat.warps.commands;\n\nimport me.snat.warps.Main;\nimport net.md_5.bungee.api.ChatColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.YamlConfiguration;", "import org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\n\npublic class WarpCommand implements CommandExecutor {\n\n    private Main main;\n\n    public WarpCommand (Main main) {\n        this.main = main;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        YamlConfiguration warps = main.getWarpManager().getWarps();\n\n        Player player = (Player) sender;\n        if (!(sender instanceof Player)) return false;\n\n        if (args.length == 0) {\n            player.sendMessage(ChatColor.RED + \"Please specify a Warp!\");\n            player.sendMessage(ChatColor.GOLD + \"Here are the available warps:\");\n            for(String warp : warps.getKeys(false)) {\n                player.sendMessage(warp);\n            }\n            return true;\n        }\n", "            for(String warp : warps.getKeys(false)) {\n                player.sendMessage(warp);\n            }\n            return true;\n        }\n\n        if (!warps.contains(args[0])) {\n            player.sendMessage(ChatColor.RED + \"That warp does not exist!\");\n            return true;\n        }\n\n        player.teleport(main.getWarpManager().getWarp(args[0]));\n        player.sendMessage(ChatColor.GOLD + \"You have been teleported to \" + args[0] + \".\");\n        return true;\n    }\n}\n"]}
{"filename": "Warps/src/main/java/me/snat/warps/managers/WarpManager.java", "chunked_list": ["package me.snat.warps.managers;\n\nimport me.snat.warps.Main;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.YamlConfiguration;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class WarpManager {\n\n    private Main main;\n    private File file;\n    private YamlConfiguration warps;\n\n\n    public WarpManager(Main main) {\n        this.main = main;\n        this.file = new File(main.getDataFolder(), \"warps.yml\");\n", "\npublic class WarpManager {\n\n    private Main main;\n    private File file;\n    private YamlConfiguration warps;\n\n\n    public WarpManager(Main main) {\n        this.main = main;\n        this.file = new File(main.getDataFolder(), \"warps.yml\");\n", "        if (!file.exists()) {\n            try {\n                file.createNewFile();\n            } catch (IOException e) {\n                System.out.println(\"Could not load warps.yml\");\n            }\n        }\n\n        warps = YamlConfiguration.loadConfiguration(file);\n    }\n\n", "    public void saveWarps() {\n        try {\n            warps.save(file);\n        } catch (IOException e) {\n            System.out.println(\"Could not save warps.yml\");\n        }\n    }\n\n    public void setWarp(String name, Location location) {\n        warps.set(name + \".location\", location);\n    }\n", "    public void setWarp(String name, Location location) {\n        warps.set(name + \".location\", location);\n    }\n\n    public Location getWarp(String name) {\n        return warps.getLocation(name + \".location\");\n    }\n\n    public YamlConfiguration getWarps() { return warps; }\n}\n", "    public YamlConfiguration getWarps() { return warps; }\n}\n"]}
{"filename": "DiscordVerification/src/main/java/xyz/alonefield/discordverifier/MinecraftVerifyCommand.java", "chunked_list": ["package xyz.alonefield.discordverifier;\n\nimport net.md_5.bungee.api.chat.ClickEvent;\nimport net.md_5.bungee.api.chat.ComponentBuilder;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport xyz.alonefield.discordverifier.api.DiscordVerifierAPI;", "import org.bukkit.entity.Player;\nimport xyz.alonefield.discordverifier.api.DiscordVerifierAPI;\n\nimport java.util.concurrent.CompletableFuture;\n\nfinal class MinecraftVerifyCommand implements CommandExecutor {\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(\"This command can only be run by a player\");\n            return false;\n        }\n        final Player player = (Player) sender;", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(\"This command can only be run by a player\");\n            return false;\n        }\n        final Player player = (Player) sender;\n        if (hasCode(player)) {\n            player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.has-code\")));\n            return false;\n        }\n        final CompletableFuture<String> codeTask = DiscordVerifierAPI.generateCode(DiscordVerifier.getInstance().getConfig().getInt(\"code-length\"));\n        codeTask.thenRun(() -> {\n           String code = DiscordVerifierAPI.get(codeTask);\n            DiscordVerifier.getDiscordCodes().put(player.getUniqueId(), Pair.of(code, DiscordVerifier.getInstance().getConfig().getInt(\"code-timeout\")));\n            sendCodeMessage(player);\n        });\n        return true;\n    }\n\n\n    private boolean hasCode(Player player) {\n        return DiscordVerifier.getDiscordCodes().get(player.getUniqueId()) != null;\n    }\n\n    private void sendCodeMessage(Player player) {\n        int time = DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getRight();\n        String code = DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getLeft();\n        String rawMsg = DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-generated\"))\n                .replace(\"{code}\", code)\n                .replace(\"{time}\", String.valueOf(time));\n        ComponentBuilder builder = new ComponentBuilder(rawMsg);", "        if (DiscordVerifier.getInstance().getConfig().getBoolean(\"should-minecraft-chat-copyable\")) {\n            builder.event(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, code));\n        }\n        player.spigot().sendMessage(builder.create());\n    }\n\n}\n"]}
{"filename": "DiscordVerification/src/main/java/xyz/alonefield/discordverifier/DiscordVerifier.java", "chunked_list": ["package xyz.alonefield.discordverifier;\n\nimport net.dv8tion.jda.api.JDA;\nimport net.dv8tion.jda.api.JDABuilder;\nimport net.dv8tion.jda.api.interactions.commands.OptionType;\nimport net.dv8tion.jda.api.interactions.commands.build.Commands;\nimport net.dv8tion.jda.api.requests.GatewayIntent;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;", "import org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport xyz.alonefield.discordverifier.api.DiscordVerifierAPI;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;", "import java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic final class DiscordVerifier extends JavaPlugin {\n\n    private static DiscordVerifier instance;\n    private static Connection dbConnection;\n    private static final Map<UUID, Pair<String, Integer>> discordCodes = new ConcurrentHashMap<>();\n    private static JDA discordClient;\n\n    @Override", "    public void onEnable() {\n        this.saveDefaultConfig();\n        if (instance == null) instance = this;\n        if (discordClient == null) discordClient = JDABuilder.create(getConfig().getString(\"discord.token\"), GatewayIntent.getIntents(GatewayIntent.ALL_INTENTS)).addEventListeners(new DiscordEvents()).build();\n\n        discordClient.upsertCommand(\n                Commands.slash(\n                        \"verify\",\n                                \"Verify your Minecraft account with your Discord account\"\n                        ).addOption(OptionType.STRING, \"code\", \"The code you received in-game\", true)\n                ).queue();\n        setupLoop();\n        setupDatabase();\n        getCommand(\"verify\").setExecutor(new MinecraftVerifyCommand());\n    }\n\n\n    private void setupLoop() {\n        getLogger().info(\"Starting data loop\");\n        Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {\n            discordCodes.forEach((uuid, data) -> {", "                if (data.getRight() <= 0) {\n                    discordCodes.remove(uuid);\n                    final Player player = Bukkit.getPlayer(uuid);\n                    if (player != null && player.isOnline() && player.isValid()) {\n                        player.sendMessage(DiscordVerifierAPI.cc(getConfig().getString(\"messages.code-expired\")));\n                    }\n                }\n                else {\n                    discordCodes.put(uuid, Pair.of(data.getLeft(), data.getRight() - 1));\n                }\n            });\n        }, 0, 20);\n        getLogger().info(\"Data loop started\");\n    }\n\n    private void setupDatabase() {", "        try {\n            getDatabaseConnection().prepareStatement(\"\"\"\n                CREATE TABLE IF NOT EXISTS DATA(\n                ID INT(36) NOT NULL,\n                SOMETHING VARCHAR(32) NOT NULL,\n                PRIMARY KEY(ID)\n            )\n            \"\"\");\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n", "    public static DiscordVerifier getInstance() {\n        return instance;\n    }\n\n    public static Map<UUID, Pair<String, Integer>> getDiscordCodes() {\n        return discordCodes;\n    }\n\n    public static JDA getDiscordClient() {\n        return discordClient;\n    }\n", "    public static JDA getDiscordClient() {\n        return discordClient;\n    }\n\n    public static Connection getDatabaseConnection() {\n        if (dbConnection == null) {\n            try {\n                Class.forName(\"org.sqlite.JDBC\");\n                dbConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + instance.getDataFolder().getAbsolutePath() + \"/database.db\");\n            }\n            catch (Exception e) {\n                instance.getLogger().severe(\"Failed to connect to database\");\n                e.printStackTrace();\n            }\n        }\n        return dbConnection;\n    }\n    }\n"]}
{"filename": "DiscordVerification/src/main/java/xyz/alonefield/discordverifier/DiscordEvents.java", "chunked_list": ["package xyz.alonefield.discordverifier;\n\nimport net.dv8tion.jda.api.entities.Role;\nimport net.dv8tion.jda.api.events.interaction.command.SlashCommandInteractionEvent;\nimport net.dv8tion.jda.api.hooks.ListenerAdapter;\nimport net.dv8tion.jda.api.interactions.commands.OptionMapping;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;\nimport xyz.alonefield.discordverifier.api.AsyncPlayerVerifyEvent;", "import org.jetbrains.annotations.NotNull;\nimport xyz.alonefield.discordverifier.api.AsyncPlayerVerifyEvent;\nimport xyz.alonefield.discordverifier.api.DiscordVerifierAPI;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nfinal class DiscordEvents extends ListenerAdapter {", "\nfinal class DiscordEvents extends ListenerAdapter {\n\n    @Override\n    public void onSlashCommandInteraction(@NotNull SlashCommandInteractionEvent event) {\n        if (!event.getName().equals(\"verify\")) return;\n        if (!event.isFromGuild()) return;\n        String channelId = DiscordVerifier.getInstance().getConfig().getString(\"discord.command-channel\");\n        if (channelId.isEmpty()) {\n            attemptVerify(event);\n            return;\n        }", "        if (channelId.isEmpty()) {\n            attemptVerify(event);\n            return;\n        }\n        if (event.getChannel().getId().equals(channelId)) {\n            attemptVerify(event);\n            return;\n        }\n        event.reply(\"Invalid channel to verify in.\").queue();\n    }\n\n    private void attemptVerify(SlashCommandInteractionEvent e) {", "        if (!e.isFromGuild()) {\n            e.reply(\"This command can only be used in a guild\").queue();\n            return;\n        }\n        e.deferReply(true).queue();\n        // Check the code argument\n        OptionMapping codeOption = e.getOption(\"code\");\n        if (codeOption == null) {\n            e.getHook().editOriginal(\"You must provide a code!\").queue(); // Impossible to reach\n            return;\n        }\n        String code = codeOption.getAsString();\n        AtomicBoolean failed = new AtomicBoolean(true);\n        // Check the code\n        DiscordVerifier.getDiscordCodes().forEach((uuid, data) -> {\n            boolean caseSensitive = DiscordVerifier.getInstance().getConfig().getBoolean(\"should-code-be-case-sensitive\");", "            if (!caseSensitive) {\n                if (data.getLeft().equalsIgnoreCase(code)) {\n                    setSuccessful(e, code, failed, uuid);\n                }\n                return;\n            }\n            if (data.getLeft().equals(code)) {\n                setSuccessful(e, code, failed, uuid);\n            }\n        });\n        if (failed.get()) {\n            e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-invalid\")).queue();\n            return;\n        }\n    }\n\n    private void setSuccessful(SlashCommandInteractionEvent e, String code, AtomicBoolean failed, UUID uuid) {\n        e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-discord\")).queue();\n        DiscordVerifier.getDiscordCodes().remove(uuid);\n        final Player player = Bukkit.getPlayer(uuid);\n        failed.set(false);\n        attemptSendMCMessage(uuid);\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {Bukkit.getPluginManager().callEvent(new AsyncPlayerVerifyEvent(uuid, e.getId(), code));});\n\n\n        Role given = Objects.requireNonNull(e.getGuild()).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-given\"));\n        Role removed = e.getGuild().getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-removed\"));\n        String name = player.getName();\n", "        if (failed.get()) {\n            e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-invalid\")).queue();\n            return;\n        }\n    }\n\n    private void setSuccessful(SlashCommandInteractionEvent e, String code, AtomicBoolean failed, UUID uuid) {\n        e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-discord\")).queue();\n        DiscordVerifier.getDiscordCodes().remove(uuid);\n        final Player player = Bukkit.getPlayer(uuid);\n        failed.set(false);\n        attemptSendMCMessage(uuid);\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {Bukkit.getPluginManager().callEvent(new AsyncPlayerVerifyEvent(uuid, e.getId(), code));});\n\n\n        Role given = Objects.requireNonNull(e.getGuild()).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-given\"));\n        Role removed = e.getGuild().getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-removed\"));\n        String name = player.getName();\n", "        if (given != null) {\n            e.getGuild().addRoleToMember(Objects.requireNonNull(e.getMember()), given).queue();\n        }\n        if (removed != null) {\n            e.getGuild().removeRoleFromMember(Objects.requireNonNull(e.getMember()), removed).queue();\n        }\n        if (DiscordVerifier.getInstance().getConfig().getBoolean(\"discord.sync-name\")){\n            Objects.requireNonNull(Objects.requireNonNull(e.getMember()).modifyNickname(name)).queue();\n        }\n\n        List<String> commands = DiscordVerifier.getInstance().getConfig().getStringList(\"Minecraft.Command\");\n\n        Bukkit.getScheduler().runTask(DiscordVerifier.getInstance(), () -> {", "            for (String cmd : commands) {\n                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), cmd.replace(\"{player}\", name));\n            }\n        });\n        //Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command.replace(\"{player}\", name));\n    }\n\n    private void attemptSendMCMessage(@NotNull UUID uuid) {\n        final Player player = DiscordVerifier.getInstance().getServer().getPlayer(uuid);\n        if (player == null || !player.isOnline() || !player.isValid()) return;\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-mc\")));\n    }\n\n}\n", "        if (player == null || !player.isOnline() || !player.isValid()) return;\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-mc\")));\n    }\n\n}\n"]}
{"filename": "DiscordVerification/src/main/java/xyz/alonefield/discordverifier/api/DiscordVerifierAPI.java", "chunked_list": ["package xyz.alonefield.discordverifier.api;\n\nimport org.bukkit.Bukkit;\nimport org.jetbrains.annotations.NotNull;\nimport org.bukkit.ChatColor;\nimport xyz.alonefield.discordverifier.DiscordVerifier;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;", "import java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\n\n/**\n * The API for DiscordVerifier\n */\npublic final class DiscordVerifierAPI {\n\n    private DiscordVerifierAPI() {} // Prevents instantiation\n    private static final String characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    private static final CompletableFuture<Void> VOID_FUTURE = CompletableFuture.completedFuture(null);\n\n    /**\n     * Colorizes a string using the {@link ChatColor#translateAlternateColorCodes(char, String)} method\n     * @param message The message to colorize\n     * @return The colorized message\n     */\n    public static @NotNull String cc(@NotNull String message) {\n        return ChatColor.translateAlternateColorCodes('&', message);\n    }\n\n    private static @NotNull CompletableFuture<String> generateString(int length) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        CompletableFuture.runAsync(() -> {\n            StringBuilder sb = new StringBuilder();", "public final class DiscordVerifierAPI {\n\n    private DiscordVerifierAPI() {} // Prevents instantiation\n    private static final String characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    private static final CompletableFuture<Void> VOID_FUTURE = CompletableFuture.completedFuture(null);\n\n    /**\n     * Colorizes a string using the {@link ChatColor#translateAlternateColorCodes(char, String)} method\n     * @param message The message to colorize\n     * @return The colorized message\n     */\n    public static @NotNull String cc(@NotNull String message) {\n        return ChatColor.translateAlternateColorCodes('&', message);\n    }\n\n    private static @NotNull CompletableFuture<String> generateString(int length) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        CompletableFuture.runAsync(() -> {\n            StringBuilder sb = new StringBuilder();", "            for (int i = 0; i < length; i++) {\n                sb.append(characters.charAt((int) (Math.random() * characters.length())));\n            }\n            if (DiscordVerifier.getDiscordCodes().containsValue(sb.toString())) {\n                generateNumber(length).thenAccept(future::complete);\n                return;\n            }\n            future.complete(sb.toString());\n        });\n        return future;\n    }\n\n    private static @NotNull CompletableFuture<String> generateNumber(int length) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        CompletableFuture.runAsync(() -> {\n            StringBuilder sb = new StringBuilder();", "            for (int i = 0; i < length; i++) {\n                sb.append(characters.charAt((int) (Math.random() * characters.length())));\n            }\n            if (DiscordVerifier.getDiscordCodes().containsValue(sb.toString())) {\n                generateNumber(length).thenAccept(future::complete);\n                return;\n            }\n            future.complete(sb.toString());\n        });\n        return future;\n    }\n\n    /**\n     * Generates a future that will complete with a random string of the specified length\n     * @param length The length of the code\n     * @return The generated code as a future\n     */\n    public static @NotNull CompletableFuture<String> generateCode(int length) {", "        if (DiscordVerifier.getInstance().getConfig().getBoolean(\"code-numbers-only\")) {\n            return generateNumber(length);\n        }\n        return generateString(length);\n    }\n\n    /**\n     * Saves a UUID and a discord ID to the database. This method is asynchronous\n     * @param uuid The UUID of the player\n     * @param discordId The discord ID of the player\n     * @return A {@link CompletableFuture} that completes when the operation is done\n     */", "    public static CompletableFuture<Void> savePlayer(final @NotNull UUID uuid, @NotNull String discordId) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {\n            try {\n                Connection connection = DiscordVerifier.getDatabaseConnection();\n                PreparedStatement statement = connection.prepareStatement(\"INSERT INTO discord_verifier (uuid, discord_id) VALUES (?, ?) ON DUPLICATE KEY UPDATE discord_id = ?\");\n                statement.setString(1, uuid.toString());\n                statement.setString(2, discordId);\n                statement.setString(3, discordId);\n                statement.execute();\n                future.complete(null);\n            }\n            catch (SQLException e) {\n                e.printStackTrace();\n                future.completeExceptionally(e);\n                DiscordVerifier.getInstance().getLogger().severe(\"Failed to save player \" + uuid + \" to database\");\n            }\n        });\n        return future;\n    }\n\n    /**\n     * Checks if a player is verified. This method is asynchronous\n     * @param uuid The UUID of the player\n     * @return A {@link CompletableFuture} that completes when the operation is done. The result is true if the player is verified, false otherwise\n     */", "    public static CompletableFuture<Boolean> isPlayerVerified(final @NotNull UUID uuid) {\n        CompletableFuture<Boolean> future = new CompletableFuture<>();\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {\n            try {\n                Connection connection = DiscordVerifier.getDatabaseConnection();\n                PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM discord_verifier WHERE uuid = ?\");\n                statement.setString(1, uuid.toString());\n                future.complete(statement.executeQuery().next());\n            }\n            catch (SQLException e) {\n                e.printStackTrace();\n                future.completeExceptionally(e);\n                DiscordVerifier.getInstance().getLogger().severe(\"Failed to check if player \" + uuid + \" is verified\");\n            }\n        });\n        return future;\n    }\n\n    /**\n     * Removes a player from the database. This method is asynchronous\n     * @param uuid The UUID of the player\n     * @return A {@link CompletableFuture} that completes when the operation is done\n     */", "    public static CompletableFuture<Void> removePlayer(final @NotNull UUID uuid) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {\n            try {\n                Connection connection = DiscordVerifier.getDatabaseConnection();\n                PreparedStatement statement = connection.prepareStatement(\"DELETE FROM discord_verifier WHERE uuid = ?\");\n                statement.setString(1, uuid.toString());\n                statement.execute();\n                future.complete(null);\n            }\n            catch (SQLException e) {\n                e.printStackTrace();\n                future.completeExceptionally(e);\n                DiscordVerifier.getInstance().getLogger().severe(\"Failed to remove player \" + uuid + \" from database\");\n            }\n        });\n        return future;\n    }\n\n\n    /**\n     * Gets the discord ID of a player. This method is asynchronous\n     * @param uuid The UUID of the player\n     * @return A {@link CompletableFuture} that completes when the operation is done. The result is the discord ID of the player, or null if the player is not verified\n     */", "    public static CompletableFuture<String> getDiscordId(final @NotNull UUID uuid) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {\n            try {\n                Connection connection = DiscordVerifier.getDatabaseConnection();\n                PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM discord_verifier WHERE uuid = ?\");\n                statement.setString(1, uuid.toString());\n                if (statement.executeQuery().next()) {\n                    future.complete(statement.getResultSet().getString(\"discord_id\"));\n                } else {\n                    future.complete(null);\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n                future.completeExceptionally(e);\n                DiscordVerifier.getInstance().getLogger().severe(\"Failed to get discord ID of player \" + uuid);\n            }\n        });\n        return future;\n    }\n\n    public static <T> T get(@NotNull CompletableFuture<T> future) {", "        try {\n            return future.get();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n"]}
{"filename": "DiscordVerification/src/main/java/xyz/alonefield/discordverifier/api/AsyncPlayerVerifyEvent.java", "chunked_list": ["package xyz.alonefield.discordverifier.api;\n\nimport org.bukkit.event.Event;\nimport org.bukkit.event.HandlerList;\n\nimport java.util.UUID;\n\npublic class AsyncPlayerVerifyEvent extends Event {\n\n    private static final HandlerList handlers = new HandlerList();\n\n    private final UUID player;\n    private final String codeUsed;\n    private final String discordId;\n\n    public AsyncPlayerVerifyEvent(UUID player, String discordId, String codeUsed) {\n        super(true); // Async!!!!\n        this.player = player;\n        this.codeUsed = codeUsed;\n        this.discordId = discordId;\n    }\n", "    public UUID getPlayer() {\n        return player;\n    }\n\n    public String getCodeUsed() {\n        return codeUsed;\n    }\n\n    public String getDiscordId() {\n        return discordId;\n    }\n\n    @Override", "    public String getDiscordId() {\n        return discordId;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n}\n"]}
{"filename": "WelcomeManager/src/main/java/ls/project/welcome/Main.java", "chunked_list": ["package ls.project.welcome;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic final class Main extends JavaPlugin {\n    public static Main instance;\n    @Override\n    public void onEnable() {\n        saveDefaultConfig();\n        instance = this;\n        Bukkit.getPluginManager().registerEvents(new JoinEvent(), this);\n    }\n\n\n}\n", "    public void onEnable() {\n        saveDefaultConfig();\n        instance = this;\n        Bukkit.getPluginManager().registerEvents(new JoinEvent(), this);\n    }\n\n\n}\n"]}
{"filename": "WelcomeManager/src/main/java/ls/project/welcome/JoinEvent.java", "chunked_list": ["package ls.project.welcome;\n\nimport net.md_5.bungee.api.ChatColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Color;\nimport org.bukkit.FireworkEffect;\nimport org.bukkit.entity.Firework;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;", "import org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.inventory.meta.FireworkMeta;\n\npublic class JoinEvent implements Listener {\n\n    //Main listener class\n\n    /*Comprises off\n      - Message sent on first join\n      - Message sent on join\n      - Title message\n      - Customisable firework\n      - broadcast\n     */\n    private final Main main = Main.instance;\n\n    @EventHandler", "    public void onJoin(PlayerJoinEvent e){\n        Player player = e.getPlayer();\n        firstJoin(player);\n        welcomeMessage(player);\n        titleWelcome(player);\n        Firework(player);\n        broadcast(player);\n    }\n\n\n    //special message for first join", "    public void firstJoin(Player player){\n        if (!main.getConfig().getBoolean(\"FirstJoin.Toggle\")) return;  //checking for the toggle\n        if (player.hasPlayedBefore()) return;\n        String message = main.getConfig().getString(\"FirstJoin.Message\");  //getting the message\n\n        if (message == null) return; //message null check\n        String HexColour = message.substring(0, 7); //getting hex colour code from message, hex colours always take 7 characters including the #\n        String message1 = message.substring(7);\n\n        player.sendMessage(ChatColor.of(HexColour) + message1);\n    }\n\n\n    //regular join messages", "    public void welcomeMessage(Player player){\n\n        if (!main.getConfig().getBoolean(\"Join.Toggle\")) return;  //checking for the toggle\n        String message = main.getConfig().getString(\"Join.Message\");  //getting the message\n\n        if (message == null) return; //message null check\n        String HexColour = message.substring(0, 7); //getting hex colour code from message, hex colours always take 7 characters including the #\n        String message1 = message.substring(7);\n\n        player.sendMessage(ChatColor.of(HexColour) + message1);\n    }\n\n\n    //Title message", "    public void titleWelcome(Player player){\n        if (!main.getConfig().getBoolean(\"Title.Toggle\")) return;  //checking for the toggle\n        String title = main.getConfig().getString(\"Title.Message\");\n        String subtitle = main.getConfig().getString(\"Title.Subtitle\");\n\n        if (title == null) return;\n        String HexColour1 = title.substring(0, 7); //getting hex colour code from message, hex colours always take 7 characters including the #\n        String message1 = title.substring(7);\n\n        String HexColour2 = subtitle.substring(0, 7); //getting hex colour code from message, hex colours always take 7 characters including the #\n        String message2 = subtitle.substring(7);\n\n        player.sendTitle(ChatColor.of(HexColour1) + message1, ChatColor.of(HexColour2) + message2);\n    }\n\n\n    //Firework", "    public void Firework(Player player){\n        if (!main.getConfig().getBoolean(\"Firework.toggle\")) return;\n\n        Firework firework = player.getWorld().spawn(player.getLocation(), Firework.class);\n        FireworkMeta meta = firework.getFireworkMeta();\n\n        meta.addEffect(FireworkEffect.builder().withColor(Color.RED).withColor(Color.AQUA).with(FireworkEffect.Type.BURST).withFlicker().build());\n        meta.setPower(2);\n        firework.setFireworkMeta(meta);\n    }\n\n\n    //Auto broadcast", "    public void broadcast(Player player){\n        if (!main.getConfig().getBoolean(\"Broadcast.toggle\")) return;\n\n        String message = main.getConfig().getString(\"Broadcast.message\");\n        if (message == null) return; //message null check\n        String HexColour = message.substring(0, 7); //getting hex colour code from message, hex colours always take 7 characters including the #\n        String message1 = message.substring(7);\n\n        String broadcast = message1.replace(\"{player}\", player.getName());\n        Bukkit.broadcastMessage(ChatColor.of(HexColour) + broadcast);\n    }\n}\n"]}
{"filename": "CustomItems/src/main/java/com/pzyc0/customitems/GetItemCommand.java", "chunked_list": ["package com.pzyc0.customitems;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.bukkit.util.StringUtil;\n", "import org.bukkit.util.StringUtil;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class GetItemCommand implements CommandExecutor, TabCompleter {\n    private final ConfigManager manager;\n\n    public GetItemCommand(ConfigManager manager) {\n        this.manager = manager;\n    }\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if(!(sender instanceof Player)) return false;\n        Player player = (Player) sender;\n        if(args.length != 1) {\n            player.sendMessage(ChatColor.RED+\"You need to specify the name of the item! The name can't have any spaces!\");\n            return false;\n        }\n        if(manager.getItem(args[0]) == null){\n            player.sendMessage(ChatColor.RED+\"The specified item couldn't be found!\");\n            return false;\n        }else {\n            player.getInventory().addItem(manager.getItem(args[0]));\n            player.sendMessage(ChatColor.GREEN+\"Gave you the item!\");\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {", "        if(args.length == 1){\n            return StringUtil.copyPartialMatches(args[0], Arrays.asList(manager.getItemsAsArray()), new ArrayList<>());\n        }\n        return null;\n    }\n}\n"]}
{"filename": "CustomItems/src/main/java/com/pzyc0/customitems/ConfigManager.java", "chunked_list": ["package com.pzyc0.customitems;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.io.IOException;\nimport java.util.ArrayList;", "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class ConfigManager {\n    private final CustomItems mainInstance;\n\n    private final HashMap<String, ItemStack> customItems;\n\n    public ConfigManager(CustomItems mainInstance){\n        this.mainInstance = mainInstance;\n        customItems = new HashMap<>();\n        loadItemStacks();\n    }", "    public void saveItem(ItemStack itemStack, String itemName){\n        //Save the Item via the command\n        mainInstance.getYmlDataFile().set(itemName, itemStack);\n        customItems.put(itemName, itemStack);\n    }\n    public ItemStack getItem(String name){\n        //Get the ItemStack with the name, if it doesn't find anything, it returns null because of the HashMap\n        return customItems.get(name);\n    }\n\n    private void loadItemStacks(){\n        //Add all the ItemStacks in the Config and the custom file to the HashMap\n        //'final' means that the value of the Variable won't and can't change", "        for(String itemStackName : mainInstance.getYmlDataFile().getConfigurationSection(\"\").getKeys(false)){\n            customItems.put(itemStackName, mainInstance.getYmlDataFile().getItemStack(itemStackName));\n        }\n        for(String itemStackFromConfigName : mainInstance.getConfig().getConfigurationSection(\"items\").getKeys(false)){\n            final ItemStack itemStack = new ItemStack(Material.AIR);\n            final FileConfiguration config = mainInstance.getConfig();\n            final String itemPath = \"items.\"+itemStackFromConfigName;\n            if(config.getString(itemPath+\".material\") != null) {\n                itemStack.setType(Material.valueOf(config.getString(itemPath+ \".material\")));\n            }\n            if(config.getInt(itemPath+\".amount\") != 0 && config.getInt(itemPath+\".amount\") < 65){\n                itemStack.setAmount(mainInstance.getConfig().getInt(itemPath+\".amount\"));\n            }", "            if(config.getInt(itemPath+\".amount\") != 0 && config.getInt(itemPath+\".amount\") < 65){\n                itemStack.setAmount(mainInstance.getConfig().getInt(itemPath+\".amount\"));\n            }\n            if(config.getConfigurationSection(itemPath+\".meta\") != null) {\n                final ItemMeta itemMeta = itemStack.getItemMeta();\n                if(config.getString(itemPath+\".meta.displayname\") != null) {\n                    itemMeta.setDisplayName(ChatColor.translateAlternateColorCodes('&', config.getString(itemPath+\".meta.displayname\")));\n                }\n                final List<String> loreList = new ArrayList<>();\n                for(String lore : config.getStringList(itemPath+\".meta.lore\")){\n                    loreList.add(ChatColor.translateAlternateColorCodes('&', lore));\n                }\n                itemMeta.setLore(loreList);\n                itemMeta.setUnbreakable(config.getBoolean(itemPath+\".meta.unbreakable\"));\n                itemStack.setItemMeta(itemMeta);\n            }\n            customItems.put(itemStackFromConfigName, itemStack);\n        }\n    }", "                for(String lore : config.getStringList(itemPath+\".meta.lore\")){\n                    loreList.add(ChatColor.translateAlternateColorCodes('&', lore));\n                }\n                itemMeta.setLore(loreList);\n                itemMeta.setUnbreakable(config.getBoolean(itemPath+\".meta.unbreakable\"));\n                itemStack.setItemMeta(itemMeta);\n            }\n            customItems.put(itemStackFromConfigName, itemStack);\n        }\n    }\n    public void saveFile(){", "    public void saveFile(){\n        try {\n            mainInstance.getYmlDataFile().save(mainInstance.getDatafile());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public String[] getItemsAsArray(){\n        return customItems.keySet().toArray(new String[0]);\n    }\n}\n"]}
{"filename": "CustomItems/src/main/java/com/pzyc0/customitems/SaveItemCommand.java", "chunked_list": ["package com.pzyc0.customitems;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\npublic class SaveItemCommand implements CommandExecutor {\n    private final ConfigManager manager;\n\n    public SaveItemCommand(ConfigManager manager) {\n        this.manager = manager;\n    }\n\n    @Override", "\npublic class SaveItemCommand implements CommandExecutor {\n    private final ConfigManager manager;\n\n    public SaveItemCommand(ConfigManager manager) {\n        this.manager = manager;\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if(!(sender instanceof Player)) return false;\n        Player player = (Player) sender;", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if(!(sender instanceof Player)) return false;\n        Player player = (Player) sender;\n        if(args.length != 1) {\n            player.sendMessage(ChatColor.RED+\"You need to specify a name for the Item! The name can't have any spaces!\");\n            return false;\n        }\n        if(player.getInventory().getItemInMainHand().getType() == Material.AIR){\n            player.sendMessage(ChatColor.RED+\"You need to have the Item you want to save in you main hand!\");\n            return false;\n        }\n\n        manager.saveItem(player.getInventory().getItemInMainHand(), args[0]);\n        player.sendMessage(ChatColor.GREEN+\"Saved the Item!\");\n        manager.saveFile();\n\n        return false;\n    }\n}\n"]}
{"filename": "CustomItems/src/main/java/com/pzyc0/customitems/CustomItems.java", "chunked_list": ["package com.pzyc0.customitems;\n\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic final class CustomItems extends JavaPlugin {\n\n    //File for the custom items and the yml file of it\n    private File datafile;\n    private YamlConfiguration ymlDataFile;\n\n    @Override", "public final class CustomItems extends JavaPlugin {\n\n    //File for the custom items and the yml file of it\n    private File datafile;\n    private YamlConfiguration ymlDataFile;\n\n    @Override\n    public void onEnable() {\n        // Plugin startup logic\n\n        getConfig().options().copyDefaults();\n        saveDefaultConfig();\n\n        datafile = new File(getDataFolder(), \"customitems.yml\");", "        if(datafile.exists()){\n            try {\n                datafile.createNewFile();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        ymlDataFile = YamlConfiguration.loadConfiguration(datafile);\n        try {\n            ymlDataFile.save(datafile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //The manager that saves and loads ItemStacks\n        ConfigManager manager = new ConfigManager(this);\n        getCommand(\"getitem\").setExecutor(new GetItemCommand(manager));\n        getCommand(\"getitem\").setTabCompleter(new GetItemCommand(manager));\n        getCommand(\"saveitem\").setExecutor(new SaveItemCommand(manager));\n    }\n\n    @Override", "        try {\n            ymlDataFile.save(datafile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //The manager that saves and loads ItemStacks\n        ConfigManager manager = new ConfigManager(this);\n        getCommand(\"getitem\").setExecutor(new GetItemCommand(manager));\n        getCommand(\"getitem\").setTabCompleter(new GetItemCommand(manager));\n        getCommand(\"saveitem\").setExecutor(new SaveItemCommand(manager));\n    }\n\n    @Override", "    public void onDisable() {\n        // Plugin shutdown logic\n        try {\n            ymlDataFile.save(datafile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public YamlConfiguration getYmlDataFile() {\n        return ymlDataFile;\n    }", "    public YamlConfiguration getYmlDataFile() {\n        return ymlDataFile;\n    }\n    public File getDatafile() {\n        return datafile;\n    }\n}\n"]}
{"filename": "StaffChat/src/main/java/me/snat/staffchat/Main.java", "chunked_list": ["package me.snat.staffchat;\n\nimport org.bukkit.plugin.java.JavaPlugin;\npublic final class Main extends JavaPlugin {\n\n    private String messageLayout;\n\n    @Override\n    public void onEnable() {\n        getConfig().options().copyDefaults();\n        saveDefaultConfig();\n        messageLayout = getConfig().getString(\"message-layout\");\n        getCommand(\"staffchat\").setExecutor(new StaffChat(this));\n    }\n", "    public void onEnable() {\n        getConfig().options().copyDefaults();\n        saveDefaultConfig();\n        messageLayout = getConfig().getString(\"message-layout\");\n        getCommand(\"staffchat\").setExecutor(new StaffChat(this));\n    }\n\n    public String getMessageLayout() { return messageLayout; }\n}\n"]}
{"filename": "StaffChat/src/main/java/me/snat/staffchat/ChatUtils.java", "chunked_list": ["package me.snat.staffchat;\n\nimport net.md_5.bungee.api.ChatColor;\npublic class ChatUtils {\n\n    public static String color(String string) {\n        return ChatColor.translateAlternateColorCodes('&', string);\n    }\n}\n"]}
{"filename": "StaffChat/src/main/java/me/snat/staffchat/StaffChat.java", "chunked_list": ["package me.snat.staffchat;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\nimport static me.snat.staffchat.ChatUtils.color;\n\npublic class StaffChat implements CommandExecutor {\n\n    private Main main;\n\n    public StaffChat(Main main) {\n        this.main = main;\n    }\n\n\n    @Override", "import static me.snat.staffchat.ChatUtils.color;\n\npublic class StaffChat implements CommandExecutor {\n\n    private Main main;\n\n    public StaffChat(Main main) {\n        this.main = main;\n    }\n\n\n    @Override", "    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n\n        String name = sender instanceof Player ? ((Player)sender).getDisplayName() : \"Server\";\n        if (args.length < 1) {\n            sender.sendMessage(\"Please provide a message.\");\n            return true;\n        }\n\n        String message = String.join(\" \", args);\n        message = color(main.getMessageLayout()\n                .replace(\"{PLAYER}\", name)\n                .replace(\"{MESSAGE}\", message));\n\n        Bukkit.broadcast(message, \"staffchat.use\");\n\n        return true;\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/Particles.java", "chunked_list": ["package com.tqqn.particles;\n\nimport com.tqqn.particles.commands.OpenParticleMenuCommand;\nimport com.tqqn.particles.listeners.OnLeaveListener;\nimport com.tqqn.particles.listeners.PlayerInventoryClickListener;\nimport com.tqqn.particles.managers.ParticleManager;\nimport com.tqqn.particles.menus.ParticleMenu;\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.PluginManager;\nimport org.bukkit.plugin.java.JavaPlugin;", "import org.bukkit.plugin.PluginManager;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic final class Particles extends JavaPlugin {\n\n    private final ParticleManager particleManager;\n    private final ParticleMenu particleMenu;\n\n    public Particles() {\n        this.particleManager = new ParticleManager(this);\n        this.particleMenu = new ParticleMenu(this);\n    }\n\n    @Override", "    public void onEnable() {\n        registerCommands();\n        registerEvents();\n        particleManager.addParticleNamesToArray();\n\n        particleMenu.setUpParticleMenu();\n        Bukkit.getLogger().info(\"Plugin has been enabled.\");\n    }\n\n    @Override\n    public void onDisable() {\n        Bukkit.getLogger().info(\"Plugin has been disabled.\");\n    }\n\n    /**\n     * Returns the ParticleManager.\n     * @return ParticleManager\n     */", "    public void onDisable() {\n        Bukkit.getLogger().info(\"Plugin has been disabled.\");\n    }\n\n    /**\n     * Returns the ParticleManager.\n     * @return ParticleManager\n     */\n    public ParticleManager getParticleManager() {\n        return this.particleManager;\n    }\n\n    /**\n     * Returns the ParticleMenu.\n     * @return ParticleMenu Object.\n     */", "    public ParticleManager getParticleManager() {\n        return this.particleManager;\n    }\n\n    /**\n     * Returns the ParticleMenu.\n     * @return ParticleMenu Object.\n     */\n    public ParticleMenu getParticleMenu() {\n        return this.particleMenu;\n    }\n\n    /**\n     * Register the commands.\n     */", "    public ParticleMenu getParticleMenu() {\n        return this.particleMenu;\n    }\n\n    /**\n     * Register the commands.\n     */\n    public void registerCommands() {\n        this.getCommand(\"particle\").setExecutor(new OpenParticleMenuCommand(this));\n    }\n\n    /**\n     * Register the events.\n     */", "    public void registerEvents() {\n        PluginManager pluginManager = Bukkit.getServer().getPluginManager();\n        pluginManager.registerEvents(new PlayerInventoryClickListener(this), this);\n        pluginManager.registerEvents(new OnLeaveListener(this), this);\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/particles/LobbyParticles.java", "chunked_list": ["package com.tqqn.particles.particles;\n\nimport org.bukkit.Material;\nimport org.bukkit.Particle;\n\npublic enum LobbyParticles {\n\n    PARTICLE_LAVADRIP(Particle.DRIP_LAVA, 1, Material.LAVA_BUCKET, 0, \"&6&lDrip-Lava Particle\", \"lobbyplugin.lavadrip\"),\n    PARTICLE_HEART(Particle.HEART,1, Material.RED_DYE, 1,\"&c&lHeart Particle\", \"lobbyplugin.heart\"),\n    PARTICLE_ANGRY(Particle.VILLAGER_ANGRY,1,Material.DIAMOND_SWORD,2,\"&4&lAngry Particle\", \"lobbyplugin.angry\"),\n    PARTICLE_ASH(Particle.ASH,1,Material.BLACK_DYE,3,\"&8&lAsh Particle\", \"lobbyplugin.ash\"),\n    PARTICLE_CLOUD(Particle.CLOUD,1,Material.GRAY_DYE,4,\"&f&lCloud Particle\", \"lobbyplugin.cloud\"),\n    PARTICLE_CRIT(Particle.CRIT,1,Material.GOLDEN_SWORD,5,\"&7&lCrit Particle\", \"lobbyplugin.crit\"),\n    PARTICLE_CRIT_MAGIC(Particle.CRIT_MAGIC,1,Material.POTION,6,\"&5&lCrit-Magic Particle\", \"lobbyplugin.crit.magic\"),\n    PARTICLE_ENCHANTMENT(Particle.ENCHANTMENT_TABLE,1,Material.ENCHANTED_BOOK,7,\"&b&lEnchantment Particle\", \"lobbyplugin.enchantment\"),\n    PARTICLE_NOTE(Particle.NOTE,1,Material.NOTE_BLOCK,8,\"&2&lNote Particle\", \"lobbyplugin.note\");\n\n    private final Particle particle;\n    private final int count;\n    private final Material menuItem;\n    private final int slot;\n    private final String itemName;\n    private final String permission;\n\n    /**\n     * LobbyParticles Enum\n     * @param particle Particle\n     * @param count int\n     * @param menuItem Material\n     * @param slot int\n     * @param itemName String\n     * @param permission String\n     */\n    LobbyParticles(Particle particle, int count, Material menuItem, int slot, String itemName, String permission) {\n        this.particle = particle;\n        this.count = count;\n        this.menuItem = menuItem;\n        this.slot = slot;\n        this.itemName = itemName;\n        this.permission = permission;\n    }\n", "    public Particle getParticle() {\n        return particle;\n    }\n    public int getCount() {\n        return count;\n    }\n    public Material getMenuItem() {\n        return menuItem;\n    }\n    public int getSlot() {\n        return slot;\n    }", "    public int getSlot() {\n        return slot;\n    }\n    public String getItemName() {\n        return itemName;\n    }\n    public String getPermission() {\n        return permission;\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/commands/OpenParticleMenuCommand.java", "chunked_list": ["package com.tqqn.particles.commands;\n\nimport com.tqqn.particles.Particles;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\n\npublic class OpenParticleMenuCommand implements CommandExecutor {\n\n    private final Particles plugin;\n\n    public OpenParticleMenuCommand(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    @Override", "public class OpenParticleMenuCommand implements CommandExecutor {\n\n    private final Particles plugin;\n\n    public OpenParticleMenuCommand(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String particle, String[] args) {\n        if (!(sender instanceof Player)) return true;\n        Player player = (Player) sender;\n", "    public boolean onCommand(CommandSender sender, Command command, String particle, String[] args) {\n        if (!(sender instanceof Player)) return true;\n        Player player = (Player) sender;\n\n        if (!(player.hasPermission(\"lobbyplugin.particles\"))) return false;\n\n        plugin.getParticleMenu().openInventory(player);\n        return true;\n\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/listeners/OnLeaveListener.java", "chunked_list": ["package com.tqqn.particles.listeners;\n\n\nimport com.tqqn.particles.Particles;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerQuitEvent;\n\npublic class OnLeaveListener implements Listener {\n\n    private final Particles plugin;\n\n    public OnLeaveListener(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    @EventHandler", "\npublic class OnLeaveListener implements Listener {\n\n    private final Particles plugin;\n\n    public OnLeaveListener(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    @EventHandler\n    public void OnLeave(PlayerQuitEvent event) {\n        Player player = event.getPlayer();\n        plugin.getParticleManager().removeParticleFromPlayer(player);\n    }\n}\n", "    public void OnLeave(PlayerQuitEvent event) {\n        Player player = event.getPlayer();\n        plugin.getParticleManager().removeParticleFromPlayer(player);\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/listeners/PlayerInventoryClickListener.java", "chunked_list": ["package com.tqqn.particles.listeners;\n\nimport com.tqqn.particles.Particles;\nimport com.tqqn.particles.particles.LobbyParticles;\nimport com.tqqn.particles.utils.Color;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;", "import org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.inventory.InventoryClickEvent;\n\npublic class PlayerInventoryClickListener implements Listener {\n\n    private final Particles plugin;\n\n    public PlayerInventoryClickListener(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    @EventHandler", "    public void onClick(InventoryClickEvent event) {\n        //If the entity who clicked is not a player, return.\n        if (!(event.getWhoClicked() instanceof Player player)) return;\n\n        //If the inventory is not the Particle inventory/menu return if it is, cancel the event to prevent players from taking stuff out of the menu.;\n        if (!(event.getView().getTitle().equalsIgnoreCase(Color.translate(\"&6Particle Menu\")))) return;\n        event.setCancelled(true);\n\n        //If the clicked item is the Turn off Particle item, remove the particle from the player.\n        if (event.getCurrentItem().getType() == Material.BARRIER && event.getCurrentItem().getItemMeta().getDisplayName().equals(Color.translate(\"&cTurn off Particle\"))) {\n            if (plugin.getParticleManager().doesPlayerParticleExist(player)) {\n                plugin.getParticleManager().removeParticleFromPlayer(player);\n                player.sendMessage(Color.translate(\"&cYou disabled your particle.\"));\n                closePlayerInventory(player);\n            } else {\n                player.sendMessage(Color.translate(\"&cYou don't have a particle enabled.\"));\n            }\n            return;\n        }\n\n        //Check if the clicked item is in the loaded MaterialMap for the particles.", "        if (event.getCurrentItem().getType() == Material.BARRIER && event.getCurrentItem().getItemMeta().getDisplayName().equals(Color.translate(\"&cTurn off Particle\"))) {\n            if (plugin.getParticleManager().doesPlayerParticleExist(player)) {\n                plugin.getParticleManager().removeParticleFromPlayer(player);\n                player.sendMessage(Color.translate(\"&cYou disabled your particle.\"));\n                closePlayerInventory(player);\n            } else {\n                player.sendMessage(Color.translate(\"&cYou don't have a particle enabled.\"));\n            }\n            return;\n        }\n\n        //Check if the clicked item is in the loaded MaterialMap for the particles.", "        if (!plugin.getParticleMenu().doesMaterialExistInMap(event.getCurrentItem())) return;\n\n        //Remove the particle from a player if the player has one equipped.\n        plugin.getParticleManager().removeParticleFromPlayer(player);\n\n        LobbyParticles lobbyParticles = plugin.getParticleMenu().getLobbyParticlesFromMap(event.getCurrentItem());\n\n        //If player has permission for that specific particle, give the particle.\n        if (player.hasPermission(lobbyParticles.getPermission())) {\n\n            plugin.getParticleManager().addParticleToPlayer(player, lobbyParticles);\n\n            player.sendMessage(Color.translate(\"&6You enabled the &c\" + lobbyParticles.getItemName() + \" &6particle.\"));\n        } else {\n            player.sendMessage(Color.translate(\"&cYou don't have permission to use this command.\"));\n        }\n        closePlayerInventory(player);\n    }\n\n    /**\n     * Async Scheduler to close the inventory after one tick.\n     * @param player Player\n     */\n    private void closePlayerInventory(Player player) {\n        Bukkit.getScheduler().runTaskLaterAsynchronously(plugin, () -> {\n            player.closeInventory();\n        }, 1L);\n    }\n}\n", "        if (player.hasPermission(lobbyParticles.getPermission())) {\n\n            plugin.getParticleManager().addParticleToPlayer(player, lobbyParticles);\n\n            player.sendMessage(Color.translate(\"&6You enabled the &c\" + lobbyParticles.getItemName() + \" &6particle.\"));\n        } else {\n            player.sendMessage(Color.translate(\"&cYou don't have permission to use this command.\"));\n        }\n        closePlayerInventory(player);\n    }\n\n    /**\n     * Async Scheduler to close the inventory after one tick.\n     * @param player Player\n     */\n    private void closePlayerInventory(Player player) {\n        Bukkit.getScheduler().runTaskLaterAsynchronously(plugin, () -> {\n            player.closeInventory();\n        }, 1L);\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/utils/Color.java", "chunked_list": ["package com.tqqn.particles.utils;\n\nimport org.bukkit.ChatColor;\n\npublic class Color {\n\n    public static String translate(String string) {\n        return ChatColor.translateAlternateColorCodes('&', string);\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/managers/ParticleManager.java", "chunked_list": ["package com.tqqn.particles.managers;\n\nimport com.tqqn.particles.Particles;\nimport com.tqqn.particles.particles.LobbyParticles;\nimport com.tqqn.particles.tasks.PlayParticleRunnable;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.UUID;", "import java.util.HashMap;\nimport java.util.UUID;\n\npublic class ParticleManager {\n\n    private final Particles plugin;\n\n    private final HashMap<UUID, LobbyParticles> playerLobbyParticles = new HashMap<>();\n\n    private final ArrayList<String> customParticles = new ArrayList<>();\n\n    private final HashMap<UUID, PlayParticleRunnable> playParticleRunnableHashMap = new HashMap<>();\n\n    public ParticleManager(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Adding Particle names to Array\n     */", "    public void addParticleNamesToArray() {\n        for (LobbyParticles lobbyParticles : LobbyParticles.values()) {\n            customParticles.add(lobbyParticles.name());\n        }\n    }\n\n    /**\n     * Checks if the Player has a particle.\n     * @param player Player\n     * @return true or false\n     */", "    public boolean doesPlayerParticleExist(Player player) {\n        return playerLobbyParticles.containsKey(player.getUniqueId());\n    }\n\n    /**\n     * Add a particle to the player.\n     * @param player Player\n     * @param lobbyParticles Particle\n     */\n    public void addParticleToPlayer(Player player, LobbyParticles lobbyParticles) {\n\n        playerLobbyParticles.remove(player.getUniqueId());\n", "    public void addParticleToPlayer(Player player, LobbyParticles lobbyParticles) {\n\n        playerLobbyParticles.remove(player.getUniqueId());\n\n        if (playParticleRunnableHashMap.containsKey(player.getUniqueId())) {\n            playParticleRunnableHashMap.get(player.getUniqueId()).cancel();\n            playParticleRunnableHashMap.remove(player.getUniqueId());\n        }\n\n        PlayParticleRunnable playParticleRunnable = new PlayParticleRunnable(plugin.getParticleManager(), lobbyParticles, player);\n        playParticleRunnable.runTaskTimerAsynchronously(plugin, 0, 10L);\n\n        playParticleRunnableHashMap.put(player.getUniqueId(), playParticleRunnable);\n        playerLobbyParticles.put(player.getUniqueId(), lobbyParticles);\n    }\n\n    /**\n     * Remove the equipped particle from the player.\n     * @param player Player\n     */", "    public void removeParticleFromPlayer(Player player) {\n        playerLobbyParticles.remove(player.getUniqueId());\n\n        if (!playParticleRunnableHashMap.containsKey(player.getUniqueId())) return;\n\n        playParticleRunnableHashMap.get(player.getUniqueId()).cancel();\n        playParticleRunnableHashMap.remove(player.getUniqueId());\n    }\n\n    /**\n     * Returns the size of LoadedParticles\n     * @return int size\n     */", "    public int getParticlesMapSize() {\n        return customParticles.size();\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/menus/ParticleMenu.java", "chunked_list": ["package com.tqqn.particles.menus;\n\nimport com.tqqn.particles.Particles;\nimport com.tqqn.particles.utils.Color;\nimport com.tqqn.particles.particles.LobbyParticles;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;", "import org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.HashMap;\n\npublic class ParticleMenu {\n\n    private Inventory inventory;\n\n    private final HashMap<ItemStack, LobbyParticles> loadedParticlesMaterial = new HashMap<>();\n\n    private final Particles plugin;\n\n    /**\n     * Main Constructor for class\n     * @param plugin MainClass\n     */\n    public ParticleMenu(Particles plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Method to add items to the private inventory variable.\n     */\n    private void addItemsToInventory() {", "        for (LobbyParticles lobbyParticles : LobbyParticles.values()) {\n            inventory.setItem(lobbyParticles.getSlot(), createGuiItem(lobbyParticles.getMenuItem(), lobbyParticles.getItemName()));\n            loadedParticlesMaterial.put(createGuiItem(lobbyParticles.getMenuItem(),lobbyParticles.getItemName()), lobbyParticles);\n        }\n        inventory.setItem(inventory.getSize()-1, createGuiItem(Material.BARRIER,\"&cTurn off Particle\"));\n    }\n\n    /**\n     * setups the inventory with desired slots and sizes.\n     */\n    public void setUpParticleMenu() {\n        int size = plugin.getParticleManager().getParticlesMapSize()+1;\n\n        size = (int) (9 * Math.ceil(size/9.0));\n        this.inventory = Bukkit.createInventory(null, size, Color.translate(\"&6Particle Menu\"));\n\n        addItemsToInventory();\n    }\n\n    /**\n     * ItemBuilder for custom name.\n     * @param material Material\n     * @param name String name\n     * @return itemStack\n     */", "    public void setUpParticleMenu() {\n        int size = plugin.getParticleManager().getParticlesMapSize()+1;\n\n        size = (int) (9 * Math.ceil(size/9.0));\n        this.inventory = Bukkit.createInventory(null, size, Color.translate(\"&6Particle Menu\"));\n\n        addItemsToInventory();\n    }\n\n    /**\n     * ItemBuilder for custom name.\n     * @param material Material\n     * @param name String name\n     * @return itemStack\n     */", "    public ItemStack createGuiItem(Material material, String name) {\n        ItemStack itemStack = new ItemStack(material);\n        ItemMeta itemMeta = itemStack.getItemMeta();\n\n        itemMeta.setDisplayName(Color.translate(name));\n        itemStack.setItemMeta(itemMeta);\n        return itemStack;\n    }\n\n    /**\n     * Opens the private inventory variable for player.\n     * @param player Player\n     */", "    public void openInventory(Player player) {\n        player.openInventory(inventory);\n    }\n\n    /**\n     * Checks if the itemstack is in the map.\n     * @param itemStack ItemStack\n     * @return true of false\n     */\n    public boolean doesMaterialExistInMap(ItemStack itemStack) {\n        return loadedParticlesMaterial.containsKey(itemStack);\n    }\n\n    /**\n     * Returns LobbyParticles that is with the itemstack key.\n     * @param itemStack ItemStack\n     * @return LobbyParticles\n     */", "    public boolean doesMaterialExistInMap(ItemStack itemStack) {\n        return loadedParticlesMaterial.containsKey(itemStack);\n    }\n\n    /**\n     * Returns LobbyParticles that is with the itemstack key.\n     * @param itemStack ItemStack\n     * @return LobbyParticles\n     */\n    public LobbyParticles getLobbyParticlesFromMap(ItemStack itemStack) {\n        return loadedParticlesMaterial.get(itemStack);\n    }\n}\n", "    public LobbyParticles getLobbyParticlesFromMap(ItemStack itemStack) {\n        return loadedParticlesMaterial.get(itemStack);\n    }\n}\n"]}
{"filename": "Particles/src/main/java/com/tqqn/particles/tasks/PlayParticleRunnable.java", "chunked_list": ["package com.tqqn.particles.tasks;\n\nimport com.tqqn.particles.managers.ParticleManager;\nimport com.tqqn.particles.particles.LobbyParticles;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\nimport org.bukkit.scheduler.BukkitRunnable;\n\npublic class PlayParticleRunnable extends BukkitRunnable {\n\n    private final LobbyParticles lobbyParticles;\n    private final Player player;\n    private final ParticleManager particleManager;\n\n    public PlayParticleRunnable(ParticleManager particleManager, LobbyParticles lobbyParticles, Player player) {\n        this.particleManager = particleManager;\n        this.lobbyParticles = lobbyParticles;\n        this.player = player;\n    }\n\n    /**\n     * Runnable that will check/give the particle if the player still has the particle equipped. If not remove/cancel it.\n     */\n    @Override", "public class PlayParticleRunnable extends BukkitRunnable {\n\n    private final LobbyParticles lobbyParticles;\n    private final Player player;\n    private final ParticleManager particleManager;\n\n    public PlayParticleRunnable(ParticleManager particleManager, LobbyParticles lobbyParticles, Player player) {\n        this.particleManager = particleManager;\n        this.lobbyParticles = lobbyParticles;\n        this.player = player;\n    }\n\n    /**\n     * Runnable that will check/give the particle if the player still has the particle equipped. If not remove/cancel it.\n     */\n    @Override", "    public void run() {\n\n        if (!(particleManager.doesPlayerParticleExist(player))) {\n            cancel();\n        }\n\n        Location playerLocation = new Location(player.getWorld(), player.getLocation().getX(), player.getLocation().getY()+1.5, player.getLocation().getZ());\n        player.spawnParticle(lobbyParticles.getParticle(), playerLocation, lobbyParticles.getCount());\n    }\n}\n"]}
{"filename": "ChatGames/src/main/java/ls/project/chatgames/Main.java", "chunked_list": ["package ls.project.chatgames;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic final class Main extends JavaPlugin {\n\n    private final List<ConfigurationSection> keys = new ArrayList<>();\n", "\npublic final class Main extends JavaPlugin {\n\n    private final List<ConfigurationSection> keys = new ArrayList<>();\n\n    public ChatGames games;\n\n    @Override\n    public void onEnable() {\n        saveDefaultConfig();\n        games = new ChatGames(this);\n\n        getCommand(\"games\").setExecutor(games);\n        Bukkit.getPluginManager().registerEvents(new ChatListener(this), this);\n\n        //Retrieving the number of questions, will use it in future to get the path of new questions and answers\n        ConfigurationSection questionSection = getConfig().getConfigurationSection(\"Questions\");\n", "    public void onEnable() {\n        saveDefaultConfig();\n        games = new ChatGames(this);\n\n        getCommand(\"games\").setExecutor(games);\n        Bukkit.getPluginManager().registerEvents(new ChatListener(this), this);\n\n        //Retrieving the number of questions, will use it in future to get the path of new questions and answers\n        ConfigurationSection questionSection = getConfig().getConfigurationSection(\"Questions\");\n\n        for (String questionNumber : questionSection.getKeys(false)) {\n\n            ConfigurationSection question = questionSection.getConfigurationSection(questionNumber);\n\n            keys.add(question);\n        }\n\n    }\n", "        for (String questionNumber : questionSection.getKeys(false)) {\n\n            ConfigurationSection question = questionSection.getConfigurationSection(questionNumber);\n\n            keys.add(question);\n        }\n\n    }\n\n    public ChatGames getGames(){ return games; }\n\n    public List<ConfigurationSection> getKeys(){ return keys;}\n}\n", "    public ChatGames getGames(){ return games; }\n\n    public List<ConfigurationSection> getKeys(){ return keys;}\n}\n"]}
{"filename": "ChatGames/src/main/java/ls/project/chatgames/ChatGames.java", "chunked_list": ["package ls.project.chatgames;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;", "import org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ChatGames implements CommandExecutor {\n\n    private Main main;\n\n    public ChatGames(Main main){\n        this.main = main;\n    }\n", "    public String answer;\n\n    @Override\n    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, String[] args) {\n        if (!(sender instanceof Player player)) return false;\n\n        player.sendMessage(ChatColor.YELLOW + \"Chat Games started!\");\n        List<ConfigurationSection> keys = main.getKeys();\n\n        Bukkit.getScheduler().scheduleSyncRepeatingTask(main, () -> {\n\n            //getting a random field\n            int rand = ThreadLocalRandom.current().nextInt(keys.size());\n            ConfigurationSection sec = keys.get(rand);\n\n            //broadcasting question and setting answer to a variable\n            Bukkit.broadcastMessage(sec.getString(\"question\"));\n            answer = sec.getString(\"answer\");\n\n        }, 0L, 6000L);\n\n\n\n        //getting the task id to use it for cancelling in future\n        Bukkit.getScheduler().scheduleSyncRepeatingTask(main, () -> {\n\n            answer = null;   //ending the task by nullifying the current answer\n            Bukkit.broadcastMessage(\"Current task set to null\");\n\n        }, 1200L, 1200L);\n\n\n        return false;\n    }\n", "    public String getAnswer(){return answer;}\n\n}\n"]}
{"filename": "ChatGames/src/main/java/ls/project/chatgames/ChatListener.java", "chunked_list": ["package ls.project.chatgames;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\nimport org.bukkit.inventory.ItemStack;\n", "import org.bukkit.inventory.ItemStack;\n\n\npublic class ChatListener implements Listener {\n\n    private final Main main;\n\n    public ChatListener(Main main){\n        this.main = main;\n    }\n\n    @EventHandler", "    public void onChat(AsyncPlayerChatEvent e) {\n\n        String message = e.getMessage();\n\n        ItemStack reward = new ItemStack(Material.DIAMOND);\n\n        if (message.equalsIgnoreCase(main.getGames().getAnswer())){   //checking if the message sent by player is the same as the answer\n            e.getPlayer().getInventory().addItem(reward);\n            Bukkit.broadcastMessage(ChatColor.AQUA + e.getPlayer().getName() + \" Has answered the question!\");\n\n            main.getGames().answer = null; //setting the answer to null\n        }\n\n    }\n}\n"]}
