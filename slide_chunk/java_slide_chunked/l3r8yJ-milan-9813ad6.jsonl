{"filename": "milan-interpreter/src/test/java/ru/milan/interpreter/AnnotativeMemoryTest.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport ru.milan.interpreter.exception.AtomNotDefinedException;\n\nfinal class AnnotativeMemoryTest {", "\nfinal class AnnotativeMemoryTest {\n\n    private Memory<Atom> mem;\n\n    @BeforeEach\n    void setUp() {\n        this.mem = new AnnotativeMemory();\n    }\n", "    }\n\n    @Test\n    void assignsAndGetsValuesCorrectly() {\n        this.mem.assign(\"myAtom\", new Value(0));\n        MatcherAssert.assertThat(\n            \"Contains placed atom\",\n            this.mem.get(\"myAtom\").asInteger(),\n            Matchers.is(0)\n        );", "            Matchers.is(0)\n        );\n        Assertions.assertThrows(\n            AtomNotDefinedException.class,\n            () -> this.mem.get(\"notMyAtom\")\n        );\n    }\n\n    @Test\n    void freesMemory() {", "    @Test\n    void freesMemory() {\n        this.mem.assign(\"1-2-3\", new Value(123));\n        MatcherAssert.assertThat(\n            \"Before clear\",\n            this.mem.get(\"1-2-3\").asInteger(),\n            Matchers.equalTo(123)\n        );\n        this.mem.free();\n        Assertions.assertThrows(", "        this.mem.free();\n        Assertions.assertThrows(\n            AtomNotDefinedException.class,\n            () -> this.mem.get(\"1-2-3\")\n        );\n    }\n}\n"]}
{"filename": "milan-interpreter/src/test/java/ru/milan/interpreter/MilanVisitorTest.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport lombok.SneakyThrows;\nimport org.antlr.v4.runtime.CharStreams;\nimport org.antlr.v4.runtime.CommonTokenStream;\nimport org.antlr.v4.runtime.RuleContext;\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.Matchers;", "import org.hamcrest.MatcherAssert;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport ru.l3r8y.UnixizedOf;\nimport ru.milan.interpreter.exception.AtomNotDefinedException;\nimport ru.milan.interpreter.fake.FakeLexer;\n", "import ru.milan.interpreter.fake.FakeLexer;\n\n/**\n * Test case for {@link MilanVisitor}.\n */\nfinal class MilanVisitorTest {\n\n    private ProgramVisitor<Atom> visitor;\n    private final Memory<Atom> memory = new AnnotativeMemory();\n    private ByteArrayOutputStream baos;", "    private final Memory<Atom> memory = new AnnotativeMemory();\n    private ByteArrayOutputStream baos;\n\n    @BeforeEach\n    void setUp() {\n        this.baos = new ByteArrayOutputStream();\n        this.visitor = new MilanVisitor(\n            System.in,\n            System.out,\n            System.err,", "            System.out,\n            System.err,\n            new AnnotativeMemory()\n        );\n    }\n\n    @AfterEach\n    void tearDown() {\n        this.memory.free();\n    }", "        this.memory.free();\n    }\n\n    @Test\n    void visitsAssign() {\n        final Integer atom = this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"assign.mil\").assignStmt()\n        ).asInteger();\n        MatcherAssert.assertThat(\n            \"Read right assign from file\",", "        MatcherAssert.assertThat(\n            \"Read right assign from file\",\n            321,\n            Matchers.equalTo(atom)\n        );\n    }\n\n    @Test\n    void visitsOutput() throws Exception {\n        System.setOut(new PrintStream(this.baos));", "    void visitsOutput() throws Exception {\n        System.setOut(new PrintStream(this.baos));\n        this.visitor = new MilanVisitor();\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"output.mil\").outputStmt()\n        );\n        MatcherAssert.assertThat(\n            \"Write right output\",\n            new UnixizedOf(this.baos.toString())\n                .asText()", "            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),\n            Matchers.equalTo(\"101\")\n        );\n        Assertions.assertThrows(\n            AtomNotDefinedException.class,\n            () ->\n                this.visitor.visit(\n                    MilanVisitorTest.parserFromSource(\"output_a.mil\").outputStmt()", "                this.visitor.visit(\n                    MilanVisitorTest.parserFromSource(\"output_a.mil\").outputStmt()\n                ),\n            \"Atom {A} is not defined\"\n        );\n    }\n\n    @Test\n    void visitsOutputMemorized() throws Exception {\n        this.injectAtomAndBaos(42);", "    void visitsOutputMemorized() throws Exception {\n        this.injectAtomAndBaos(42);\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"output_a.mil\").outputStmt()\n        );\n        MatcherAssert.assertThat(\n            \"Write right output\",\n            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),", "                .asText()\n                .asString(),\n            Matchers.equalTo(\"42\")\n        );\n    }\n\n    @Test\n    void visitsSimpleIfStatement() throws Exception {\n        this.injectAtomAndBaos(5);\n        this.visitor.visit(", "        this.injectAtomAndBaos(5);\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"if_simple.mil\").ifStmt()\n        );\n        MatcherAssert.assertThat(\n            \"Output from IF body is 555\",\n            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),\n            Matchers.equalTo(\"555\")", "                .asString(),\n            Matchers.equalTo(\"555\")\n        );\n    }\n\n    @Test\n    void visitsSimpleIfElseStatement() throws Exception {\n        this.injectAtomAndBaos(5);\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"if_else.mil\").ifStmt()", "        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"if_else.mil\").ifStmt()\n        );\n        MatcherAssert.assertThat(\n            \"Output from ELSE body\",\n            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),\n            Matchers.equalTo(\"101\")\n        );", "            Matchers.equalTo(\"101\")\n        );\n    }\n\n    @Test\n    void visitsSimpleWhileStatement() throws Exception {\n        this.injectAtomAndBaos(0);\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"simple_while.mil\").whileStmt()\n        );", "            MilanVisitorTest.parserFromSource(\"simple_while.mil\").whileStmt()\n        );\n        MatcherAssert.assertThat(\n            \"Outputs 5 times\",\n            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),\n            Matchers.equalTo(\"0\\n1\\n2\\n3\\n4\")\n        );\n    }", "        );\n    }\n\n    @Test\n    void visitsNotSimpleWhileStatement() throws Exception {\n        this.injectAtomAndBaos(0);\n        this.visitor.visit(\n            MilanVisitorTest.parserFromSource(\"not_simple_while.mil\").whileStmt()\n        );\n        MatcherAssert.assertThat(", "        );\n        MatcherAssert.assertThat(\n            \"Outputs 15 times\",\n            new UnixizedOf(this.baos.toString())\n                .asText()\n                .asString(),\n            Matchers.equalTo(\n                \"1\\n2\\n2\\n3\\n3\\n3\\n4\\n4\\n4\\n4\\n5\\n5\\n5\\n5\\n5\"\n            )\n        );", "            )\n        );\n    }\n\n    @Test\n    void visitsMultiplication() {\n        this.injectAtomAndBaos(33);\n        final RuleContext mul = MilanVisitorTest.contextFromString(\"A * 10;\");\n        MatcherAssert.assertThat(\n            \"10 * 33 = 330\",", "        MatcherAssert.assertThat(\n            \"10 * 33 = 330\",\n            this.visitor.visit(mul).asInteger(),\n            Matchers.equalTo(330)\n        );\n    }\n\n    @Test\n    void visitsDivision() {\n        this.injectAtomAndBaos(10);", "    void visitsDivision() {\n        this.injectAtomAndBaos(10);\n        final RuleContext div = MilanVisitorTest.contextFromString(\"A / 2;\");\n        MatcherAssert.assertThat(\n            \"10 / 2 = 5\",\n            this.visitor.visit(div).asInteger(),\n            Matchers.equalTo(5)\n        );\n    }\n", "    }\n\n    @Test\n    void visitsAddition() {\n        this.injectAtomAndBaos(3);\n        final RuleContext add = MilanVisitorTest.contextFromString(\"10 + A;\");\n        MatcherAssert.assertThat(\n            \"10 + 3 = 13\",\n            this.visitor.visit(add).asInteger(),\n            Matchers.equalTo(13)", "            this.visitor.visit(add).asInteger(),\n            Matchers.equalTo(13)\n        );\n    }\n\n    @Test\n    void visitsSubs() {\n        this.injectAtomAndBaos(3);\n        final RuleContext sub = MilanVisitorTest.contextFromString(\"10 - A;\");\n        MatcherAssert.assertThat(", "        final RuleContext sub = MilanVisitorTest.contextFromString(\"10 - A;\");\n        MatcherAssert.assertThat(\n            \"10 - 3 = 7\",\n            this.visitor.visit(sub).asInteger(),\n            Matchers.equalTo(7)\n        );\n    }\n\n    @Test\n    void visitsEquals() {", "    @Test\n    void visitsEquals() {\n        this.injectAtomAndBaos(3);\n        final RuleContext equals =\n            MilanVisitorTest.contextFromString(\"3 == A;\");\n        MatcherAssert.assertThat(\n            \"3 == 3 is true\",\n            this.visitor.visit(equals),\n            Matchers.is(Value.TRUE)\n        );", "            Matchers.is(Value.TRUE)\n        );\n    }\n\n    @Test\n    void visitsEqualsWithFalse() {\n        this.injectAtomAndBaos(3);\n        final RuleContext equals =\n            MilanVisitorTest.contextFromString(\"2 == A;\");\n        MatcherAssert.assertThat(", "            MilanVisitorTest.contextFromString(\"2 == A;\");\n        MatcherAssert.assertThat(\n            \"2 == 3 is false\",\n            this.visitor.visit(equals),\n            Matchers.is(Value.FALSE)\n        );\n    }\n\n    @Test\n    void visitsGreaterThan() {", "    @Test\n    void visitsGreaterThan() {\n        this.injectAtomAndBaos(12);\n        final RuleContext greaterContext =\n            MilanVisitorTest.contextFromString(\"2 > A;\");\n        MatcherAssert.assertThat(\n            \"2 > 12 is false\",\n            this.visitor.visit(greaterContext),\n            Matchers.is(Value.FALSE)\n        );", "            Matchers.is(Value.FALSE)\n        );\n        final RuleContext greaterEqualsContext =\n            MilanVisitorTest.contextFromString(\"12 >= A\");\n        MatcherAssert.assertThat(\n            \"12 >= 12 is true\",\n            this.visitor.visit(greaterEqualsContext),\n            Matchers.is(Value.TRUE)\n        );\n    }", "        );\n    }\n\n    @Test\n    void visitsLessThan() {\n        this.injectAtomAndBaos(10);\n        final RuleContext lessContext =\n            MilanVisitorTest.contextFromString(\"5 < A\");\n        MatcherAssert.assertThat(\n            \"5 < 10 is true\",", "        MatcherAssert.assertThat(\n            \"5 < 10 is true\",\n            this.visitor.visit(lessContext),\n            Matchers.equalTo(Value.TRUE)\n        );\n        final RuleContext lessEqualsContext =\n            MilanVisitorTest.contextFromString(\"5 <= A\");\n        MatcherAssert.assertThat(\n            \"5 <= 10 is true\",\n            this.visitor.visit(lessEqualsContext),", "            \"5 <= 10 is true\",\n            this.visitor.visit(lessEqualsContext),\n            Matchers.equalTo(Value.TRUE)\n        );\n    }\n\n    @Test\n    void visitsNotEquals() {\n        this.injectAtomAndBaos(2);\n        final RuleContext notEqualsContext =", "        this.injectAtomAndBaos(2);\n        final RuleContext notEqualsContext =\n            MilanVisitorTest.contextFromString(\"1 <> A\");\n        MatcherAssert.assertThat(\n            \"1 != 2 is true\",\n            this.visitor.visit(notEqualsContext),\n            Matchers.equalTo(Value.TRUE)\n        );\n        final RuleContext twoNotEqualsTwo =\n            MilanVisitorTest.contextFromString(\"2 <> A\");", "        final RuleContext twoNotEqualsTwo =\n            MilanVisitorTest.contextFromString(\"2 <> A\");\n        MatcherAssert.assertThat(\n            \"2 != 2 is false\",\n            this.visitor.visit(twoNotEqualsTwo),\n            Matchers.equalTo(Value.FALSE)\n        );\n    }\n\n    @Test", "\n    @Test\n    void visitsBrackets() {\n        this.injectAtomAndBaos(10);\n        final Integer result = this.visitor.visit(\n            MilanVisitorTest.contextFromString(\"(A + 5) * (A - 8) / (1 + 1)\")\n        ).asInteger();\n        MatcherAssert.assertThat(\n            \"15 * 2 = 30\",\n            result,", "            \"15 * 2 = 30\",\n            result,\n            Matchers.equalTo(15)\n        );\n    }\n\n    /**\n     * Injects the ByteArrayOutputStream and the value into the visitor.\n     *\n     * @param value The value to be assigned to the variable A.", "     *\n     * @param value The value to be assigned to the variable A.\n     */\n    private void injectAtomAndBaos(final int value) {\n        this.injectBaosIntoSystemOut();\n        this.fillAndInjectMemoryToVisitor(value, new MilanVisitor(System.out, this.memory));\n    }\n\n    /**\n     * This function fills the memory with a value and injects the visitor into the", "    /**\n     * This function fills the memory with a value and injects the visitor into the\n     * memory.\n     *\n     * @param value The value to be assigned to the memory cell A.\n     * @param vis The visitor that will be injected with the memory.\n     */\n    private void fillAndInjectMemoryToVisitor(final int value, final ProgramVisitor<Atom> vis) {\n        this.memory.assign(\"A\", new Value(value));\n        this.visitor = vis;", "        this.memory.assign(\"A\", new Value(value));\n        this.visitor = vis;\n    }\n\n    /**\n     * Injects the ByteArrayOutputStream into the System.out stream.\n     */\n    private void injectBaosIntoSystemOut() {\n        System.setOut(new PrintStream(this.baos));\n    }", "        System.setOut(new PrintStream(this.baos));\n    }\n\n    /**\n     * It creates a parser for a given resource\n     *\n     * @param resource the name of the resource file to parse\n     * @return A ProgramParser object.\n     */\n    @SneakyThrows", "     */\n    @SneakyThrows\n    private static ProgramParser parserFromSource(final String resource) {\n        return new ProgramParser(new CommonTokenStream(new FakeLexer(resource)));\n    }\n\n    /**\n     * It takes a string of code, and returns a parser that can parse that code\n     *\n     * @param code The code to parse", "     *\n     * @param code The code to parse\n     * @return A ProgramParser object.\n     */\n    @SneakyThrows\n    private static RuleContext contextFromString(final String code) {\n        return new ProgramParser(\n            new CommonTokenStream(\n                new MilanLexer(CharStreams.fromString(code))\n            )", "                new MilanLexer(CharStreams.fromString(code))\n            )\n        ).expressions().getRuleContext();\n    }\n}\n"]}
{"filename": "milan-interpreter/src/test/java/ru/milan/interpreter/ValueTest.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link Value}.", "/**\n * Test case for {@link Value}.\n */\nfinal class ValueTest {\n\n    private Atom alpha;\n\n    private Atom omega;\n\n    @BeforeEach", "\n    @BeforeEach\n    void setUp() {\n        this.alpha = new Value(1);\n        this.omega = new Value(4);\n    }\n\n    @Test\n    void writesCorrectAddition() {\n        MatcherAssert.assertThat(", "    void writesCorrectAddition() {\n        MatcherAssert.assertThat(\n            \"1 + 4 equal to 5\",\n            this.alpha.add(this.omega).asInteger(),\n            Matchers.equalTo(5)\n        );\n    }\n\n    @Test\n    void writesCorrectSubtraction() {", "    @Test\n    void writesCorrectSubtraction() {\n        MatcherAssert.assertThat(\n            \"4 - 1 equal to 3\",\n            this.omega.sub(this.alpha).asInteger(),\n            Matchers.equalTo(3)\n        );\n    }\n\n    @Test", "\n    @Test\n    void writesCorrectMultiplication() {\n        MatcherAssert.assertThat(\n            \"4 * 2 equal to 8\",\n            this.alpha.mul(new Value(2)).mul(this.omega).asInteger(),\n            Matchers.equalTo(8)\n        );\n    }\n", "    }\n\n    @Test\n    void writesCorrectDivision() {\n        MatcherAssert.assertThat(\n            \"4 / 2 equal to 2\",\n            new Value(4).div(new Value(2)).asInteger(),\n            Matchers.equalTo(2)\n        );\n        MatcherAssert.assertThat(", "        );\n        MatcherAssert.assertThat(\n            \"5 / 2 equal to 2\",\n            new Value(5).div(new Value(2)).asInteger(),\n            Matchers.equalTo(2)\n        );\n    }\n\n    @Test\n    void comparesCorrectly() {", "    @Test\n    void comparesCorrectly() {\n        MatcherAssert.assertThat(\n            \"2 is equal to 2\",\n            new Value(2).eq(new Value(2)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"3 is greater than to 2\",\n            new Value(3).gt(new Value(2)),", "            \"3 is greater than to 2\",\n            new Value(3).gt(new Value(2)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"2 is lesser than to 3\",\n            new Value(2).lt(new Value(3)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(", "        );\n        MatcherAssert.assertThat(\n            \"6 is greater than or equal to 3\",\n            new Value(6).gte(new Value(2)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"3 is greater than or equal to 3\",\n            new Value(3).gte(new Value(2)),\n            Matchers.equalTo(Value.TRUE)", "            new Value(3).gte(new Value(2)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"3 is less than or equal to 3\",\n            new Value(3).lte(new Value(3)),\n            Matchers.equalTo(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"89 is less than or equal to 1253\",", "        MatcherAssert.assertThat(\n            \"89 is less than or equal to 1253\",\n            new Value(89).lte(new Value(1253)),\n            Matchers.equalTo(Value.TRUE)\n        );\n    }\n\n    @Test\n    void writesCorrectOr() {\n        MatcherAssert.assertThat(", "    void writesCorrectOr() {\n        MatcherAssert.assertThat(\n            \"false || true == true\",\n            Value.FALSE.or(Value.TRUE),\n            Matchers.is(Value.TRUE)\n        );\n        MatcherAssert.assertThat(\n            \"false || false == false\",\n            Value.FALSE.or(Value.FALSE),\n            Matchers.is(Value.FALSE)", "            Value.FALSE.or(Value.FALSE),\n            Matchers.is(Value.FALSE)\n        );\n    }\n\n    @Test\n    void writesCorrectAnd() {\n        MatcherAssert.assertThat(\n            \"false && true == false\",\n            Value.FALSE.and(Value.TRUE),", "            \"false && true == false\",\n            Value.FALSE.and(Value.TRUE),\n            Matchers.is(Value.FALSE)\n        );\n        MatcherAssert.assertThat(\n            \"true && true == true\",\n            Value.TRUE.and(Value.TRUE),\n            Matchers.is(Value.TRUE)\n        );\n    }", "        );\n    }\n\n    @Test\n    void checksOnNumber() {\n        MatcherAssert.assertThat(\n            \"0 \u2013 is number\",\n            new Value(0).isNaN(),\n            Matchers.is(false)\n        );", "            Matchers.is(false)\n        );\n    }\n\n    @Test\n    void assertsNumberRight() {\n        Assertions.assertDoesNotThrow(\n            () -> this.alpha.assertNumber()\n        );\n    }", "        );\n    }\n}\n"]}
{"filename": "milan-interpreter/src/test/java/ru/milan/interpreter/fake/FakeLexer.java", "chunked_list": ["package ru.milan.interpreter.fake;\n\nimport org.antlr.v4.runtime.CharStreams;\nimport org.cactoos.io.ResourceOf;\nimport ru.l3r8y.UnixizedOf;\nimport ru.milan.interpreter.MilanLexer;\n\npublic class FakeLexer extends MilanLexer {\n\n    public FakeLexer(final String resource) throws Exception {\n        super(CharStreams.fromString(\n            new UnixizedOf(new ResourceOf(resource))\n                .asText()\n                .asString()\n            )\n        );\n    }\n}\n"]}
{"filename": "milan-interpreter/src/it/it-interpreter/src/test/java/EntrySpec.java", "chunked_list": ["import java.io.IOException;\nimport org.cactoos.io.ResourceOf;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport ru.milan.interpreter.AnnotativeMemory;\nimport ru.milan.interpreter.MilanInterpreter;\n\nclass EntrySpec {\n", "class EntrySpec {\n\n    private MilanInterpreter interpreter;\n\n    @BeforeEach\n    void setUp() {\n        this.interpreter = new MilanInterpreter(\n            new AnnotativeMemory(),\n            new ResourceOf(\"program.mil\"),\n            System.in,", "            new ResourceOf(\"program.mil\"),\n            System.in,\n            System.out,\n            System.err\n        );\n    }\n\n    @Test\n    void executesRealProgram() {\n        assertDoesNotThrow(() -> this.interpreter.run());", "    void executesRealProgram() {\n        assertDoesNotThrow(() -> this.interpreter.run());\n    }\n}"]}
{"filename": "milan-interpreter/src/it/it-interpreter/src/main/java/Entry.java", "chunked_list": ["import java.io.IOException;\nimport org.cactoos.io.ResourceOf;\nimport ru.milan.interpreter.AnnotativeMemory;\nimport ru.milan.interpreter.MilanInterpreter;\n\n/**\n * The entry point of integration test.\n */\npublic class Entry { }\n", "public class Entry { }\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/Memory.java", "chunked_list": ["package ru.milan.interpreter;\n\n/**\n * The runtime memory.\n *\n * @param <T> The type.\n */\npublic interface Memory<T> {\n\n    /**\n     * Get from memory.\n     *\n     * @param name The name of the variable to get.\n     * @return The value of the variable.\n     */\n    T get(String name);\n\n    /**\n     * Assign in memory.\n     *\n     * @param name The name of the variable to assign.\n     * @param value The value to assign to the variable.\n     */\n    void assign(String name, T value);\n\n    /**\n     * Clear the memory.\n     */\n    void free();\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/Atom.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport ru.milan.interpreter.exception.WrongTypeException;\n\n/**\n * Atom of Milan. Smallest unit.\n */\npublic interface Atom {\n\n    /**\n     * Returns true if the string is a number, false otherwise.\n     *\n     * @return A boolean value.\n     */\n    boolean isNumber();\n\n    /**\n     * Returns true if the value is NaN, otherwise returns false.\n     *\n     * @return A boolean value.\n     */\n    boolean isNaN();\n\n    /**\n     * Returns the value of this OptionalInt as an Integer if it is present,\n     * otherwise returns null.\n     *\n     * @return The return value is the integer value of the object.\n     */\n    Integer asInteger();\n\n    /**\n     * Returns true if the value is true, false otherwise.\n     *\n     * @return A boolean value.\n     */\n    boolean isTrue();\n\n    /**\n     * Returns true if the value is false.\n     *\n     * @return A boolean value.\n     */\n    boolean isFalse();\n\n    /**\n     * Not() returns the negation of the current atom.\n     *\n     * @return The result of the boolean operation.\n     */\n    Atom not();\n\n    /**\n     * \"Returns a new atom that is true if and only if both this atom and the other\n     * atom are true.\"\n     *\n     * @param other The other atom to be ANDed with this one.\n     * @return A new atom that is the conjunction of the two atoms.\n     */\n    Atom and(Atom other);\n\n    /**\n     * \"Returns a new atom that is true if either this atom or the other atom is\n     * true.\"\n     *\n     * @param other The other atom to be ORed with this atom.\n     * @return A new Atom object with the value of the two atoms ORed together.\n     */\n    Atom or(Atom other);\n\n    /**\n     * \"Multiply this atom by another atom.\"\n     *\n     * @param other The other atom to multiply with.\n     * @return The product of the two atoms.\n     */\n    Atom mul(Atom other);\n\n    /**\n     * \"Divide this atom by another atom.\"\n     *\n     * @param other The other atom to divide by.\n     * @return The result of the division of the two numbers.\n     */\n    Atom div(Atom other);\n\n    /**\n     * Adds the value of the other atom to this atom and returns the result\n     *\n     * @param other The other atom to add to this one.\n     * @return The sum of the two atoms.\n     */\n    Atom add(Atom other);\n\n    /**\n     * Subtracts the value of the other atom from this atom and returns the result.\n     *\n     * @param other The other atom to subtract from this one.\n     * @return The difference of the two atoms.\n     */\n    Atom sub(Atom other);\n\n    /**\n     * Returns true if this Atom is greater than the other Atom.\n     *\n     * @param other The other atom to compare to.\n     * @return A boolean value.\n     */\n    Atom gt(Atom other);\n\n    /**\n     * Returns true if this Atom is greater than or equal to the other Atom.\n     *\n     * @param other The other atom to compare to.\n     * @return A boolean value.\n     */\n    Atom gte(Atom other);\n\n    /**\n     * Returns true if this Atom is less than the other Atom.\n     *\n     * @param other The other atom to compare to.\n     * @return A boolean value.\n     */\n    Atom lt(Atom other);\n\n    /**\n     * Returns true if this Atom is less than or equal to the other Atom.\n     *\n     * @param other The other atom to compare to.\n     * @return A boolean value.\n     */\n    Atom lte(Atom other);\n\n    /**\n     * Returns true if this atom is equal to the other atom.\n     *\n     * @param other The other atom to compare to.\n     * @return The result of the comparison.\n     */\n    Atom eq(Atom other);\n\n    /**\n     * Returns true if this atom is not equal to the other atom.\n     *\n     * @param other The other atom to compare to.\n     * @return A new Atom object with the value of the comparison.\n     */\n    Atom neq(Atom other);\n\n    /**\n     * > Asserts that the given value is a number\n     * @throws WrongTypeException When assertion failed\n     */\n    void assertNumber() throws WrongTypeException;\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/AnnotativeMemory.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.cactoos.text.FormattedText;\nimport ru.milan.interpreter.exception.AtomNotDefinedException;\n\n/**\n * The memory, annotation way.\n */\npublic final class AnnotativeMemory implements Memory<Atom> {\n\n    private final Map<String, Atom> memory = new HashMap<>(0);\n\n    @Override", " * The memory, annotation way.\n */\npublic final class AnnotativeMemory implements Memory<Atom> {\n\n    private final Map<String, Atom> memory = new HashMap<>(0);\n\n    @Override\n    public Atom get(final String name) {\n        final Atom atom = this.memory.get(name);\n        if (null == atom) {\n            throw new AtomNotDefinedException(\n                \"Atom {%s} is not defined!\".formatted(name)\n            );\n        }\n        return atom;\n    }\n\n    @Override", "        if (null == atom) {\n            throw new AtomNotDefinedException(\n                \"Atom {%s} is not defined!\".formatted(name)\n            );\n        }\n        return atom;\n    }\n\n    @Override\n    public void assign(final String name, final Atom value) {\n        this.memory.put(name, value);\n    }\n\n    @Override", "    public void assign(final String name, final Atom value) {\n        this.memory.put(name, value);\n    }\n\n    @Override\n    public void free() {\n        this.memory.clear();\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/MilanErrorListener.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.util.BitSet;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport lombok.RequiredArgsConstructor;\nimport org.antlr.v4.runtime.BaseErrorListener;\nimport org.antlr.v4.runtime.Parser;\nimport org.antlr.v4.runtime.RecognitionException;\nimport org.antlr.v4.runtime.Recognizer;", "import org.antlr.v4.runtime.RecognitionException;\nimport org.antlr.v4.runtime.Recognizer;\nimport org.antlr.v4.runtime.atn.ATNConfigSet;\nimport org.antlr.v4.runtime.dfa.DFA;\nimport org.cactoos.Text;\n\n@RequiredArgsConstructor\npublic final class MilanErrorListener extends BaseErrorListener {\n\n    private final List<Text> lines;\n\n    @Override", "    public void syntaxError(\n        final Recognizer<?, ?> recognizer,\n        final Object symbol,\n        final int line,\n        final int position,\n        final String msg,\n        final RecognitionException error\n    ) {\n        throw new InputMismatchException(\n            \"[%d:%d] %s: \\\"%s\\\"\"\n                .formatted(\n                    line, position, msg,\n                    this.lines.size() < line ? \"EOF\" : this.lines.get(line - 1)\n                )\n        );\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/MilanVisitor.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport ru.milan.interpreter.exception.InterpretationException;\nimport ru.milan.interpreter.message.FormattedErrorMessage;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Scanner;", "import java.io.PrintStream;\nimport java.util.Scanner;\n\n/**\n * It's a visitor that visits the parse tree and executes the program.\n */\npublic final class MilanVisitor extends ProgramBaseVisitor<Atom> {\n\n    /**\n     * The input.\n     */\n    private final InputStream stdin;\n\n    /**\n     * The output.\n     */\n    private final PrintStream stdout;\n\n    /**\n     * Error output.\n     */\n    private final PrintStream stderr;\n\n    /**\n     * Runtime memory.\n     */\n    private final Memory<Atom> memory;\n\n    /**\n     * Wrapper wor printing.\n     */\n    private PrintStream print;\n\n    /**\n     * Wrapper wor input.\n     */\n    private BufferedReader input;\n\n    /**\n     * Ctor.\n     */\n    public MilanVisitor() {\n        this(System.in, System.out, System.err, new AnnotativeMemory());\n    }\n\n    /**\n     * Ctor.\n     */\n    public MilanVisitor(final Memory<Atom> memory) {\n        this(System.in, System.out, System.err, memory);\n    }\n\n    /**\n     * Ctor.\n     *\n     * @param stdin Standard input\n     */\n    public MilanVisitor(final InputStream stdin) {\n        this(stdin, System.out, System.err, new AnnotativeMemory());\n    }\n\n    /**\n     * @param out Standard output\n     * @param memory Runtime memory\n     */\n    public MilanVisitor(final PrintStream out, final Memory<Atom> memory) {\n        this(System.in, out, System.err, memory);\n    }\n\n    /**\n     * Ctor.\n     *\n     * @param stdin Standard input\n     * @param stdout Standard output\n     */\n    public MilanVisitor(final InputStream stdin, final PrintStream stdout) {\n        this(stdin, stdout, System.err, new AnnotativeMemory());\n    }\n\n    /**\n     * Ctor.\n     *\n     * @param stdin Standard input\n     * @param stdout Standard output\n     * @param stderr Standard errors\n     */\n    public MilanVisitor(\n        final InputStream stdin,\n        final PrintStream stdout,\n        final PrintStream stderr\n    ) {\n        this(stdin, stdout, stderr, new AnnotativeMemory());\n    }\n\n    /**\n     * Ctor.\n     *\n     * @param stdin Standard input\n     * @param stdout Standard output\n     * @param stderr Standard errors\n     * @param memory Interpretation memory\n     */\n    public MilanVisitor(\n        final InputStream stdin,\n        final PrintStream stdout,\n        final PrintStream stderr,\n        final Memory<Atom> memory\n    ) {\n        this.stdin = stdin;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.memory = memory;\n        this.init();\n    }\n\n    @Override", "    public Atom visitProg(final ProgramParser.ProgContext ctx) {\n        this.init();\n        try {\n            ctx.children.forEach(tkn -> {\n                if (tkn instanceof final ProgramParser.AssignStmtContext ass) {\n                    this.visitAssignStmt(ass);\n                }\n            });\n            return super.visitProg(ctx);\n        } catch (final RuntimeException ex) {\n            throw new IllegalStateException(\n                new FormattedErrorMessage(\n                    ctx.getStart().getLine(),\n                    ctx.getStart().getCharPositionInLine(),\n                    \"Interpretation error: %s\\n\".formatted(ex.getMessage())\n                ).asString(),\n                ex\n            );\n        } finally {\n            this.shutdown();\n        }\n    }\n\n    @Override", "    public Atom visitInt(final ProgramParser.IntContext ctx) {\n        return new Value(Integer.parseInt(ctx.INT().getText()));\n    }\n\n    @Override\n    public Atom visitId(final ProgramParser.IdContext ctx) {\n        return this.memory.get(ctx.getText());\n    }\n\n    @Override\n    public Atom visitAssignStmt(final ProgramParser.AssignStmtContext ctx) {\n        final Atom value = this.visit(ctx.expressions());\n        this.memory.assign(ctx.ID().getText(), value);\n        return value;\n    }\n\n    @Override", "    public Atom visitAssignStmt(final ProgramParser.AssignStmtContext ctx) {\n        final Atom value = this.visit(ctx.expressions());\n        this.memory.assign(ctx.ID().getText(), value);\n        return value;\n    }\n\n    @Override\n    public Atom visitRead(final ProgramParser.ReadContext ctx) {\n        try (final Scanner scan = new Scanner(System.in)) {\n            return new Value(scan.nextInt());\n        }\n    }\n\n    @Override", "    public Atom visitBrackets(final ProgramParser.BracketsContext ctx) {\n        final Atom result;\n        if (ctx.expr() instanceof ProgramParser.AdditionContext addition) {\n            result = this.visitAddition(addition);\n        } else if (ctx.expr() instanceof ProgramParser.MultiplicationContext mult) {\n            result = this.visitMultiplication(mult);\n        } else if (ctx.expr() instanceof ProgramParser.SubtractingContext sub) {\n            result = this.visitSubtracting(sub);\n        } else if (ctx.expr() instanceof ProgramParser.DivisionContext div) {\n            result = this.visitDivision(div);\n        } else {\n            result = super.visitBrackets(ctx);\n        }\n        return result;\n    }\n\n    @Override", "        } else if (ctx.expr() instanceof ProgramParser.DivisionContext div) {\n            result = this.visitDivision(div);\n        } else {\n            result = super.visitBrackets(ctx);\n        }\n        return result;\n    }\n\n    @Override\n    public Atom visitMultiplication(final ProgramParser.MultiplicationContext ctx) {\n        return this.visit(ctx.expr(0)).mul(this.visit(ctx.expr(1)));\n    }\n\n    @Override", "    public Atom visitMultiplication(final ProgramParser.MultiplicationContext ctx) {\n        return this.visit(ctx.expr(0)).mul(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitDivision(final ProgramParser.DivisionContext ctx) {\n        return this.visit(ctx.expr(0)).div(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitAddition(final ProgramParser.AdditionContext ctx) {\n        return this.visit(ctx.expr(0)).add(this.visit(ctx.expr(1)));\n    }\n\n    @Override", "    public Atom visitAddition(final ProgramParser.AdditionContext ctx) {\n        return this.visit(ctx.expr(0)).add(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitSubtracting(final ProgramParser.SubtractingContext ctx) {\n        return this.visit(ctx.expr(0)).sub(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitGreaterThan(final ProgramParser.GreaterThanContext ctx) {\n        return this.visit(ctx.expr(0)).gt(this.visit(ctx.expr(1)));\n    }\n\n    @Override", "    public Atom visitGreaterThan(final ProgramParser.GreaterThanContext ctx) {\n        return this.visit(ctx.expr(0)).gt(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitGreaterEqualsThan(final ProgramParser.GreaterEqualsThanContext ctx) {\n        return this.visit(ctx.expr(0)).gte(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitLessThan(final ProgramParser.LessThanContext ctx) {\n        return this.visit(ctx.expr(0)).lt(this.visit(ctx.expr(1)));\n    }\n\n    @Override", "    public Atom visitLessThan(final ProgramParser.LessThanContext ctx) {\n        return this.visit(ctx.expr(0)).lt(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitLessEqualsThan(final ProgramParser.LessEqualsThanContext ctx) {\n        return this.visit(ctx.expr(0)).lte(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitNotEquals(final ProgramParser.NotEqualsContext ctx) {\n        return this.visit(ctx.expr(0)).neq(this.visit(ctx.expr(1)));\n    }\n\n    @Override", "    public Atom visitNotEquals(final ProgramParser.NotEqualsContext ctx) {\n        return this.visit(ctx.expr(0)).neq(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitEquals(final ProgramParser.EqualsContext ctx) {\n        return this.visit(ctx.expr(0)).eq(this.visit(ctx.expr(1)));\n    }\n\n    @Override\n    public Atom visitStmt(final ProgramParser.StmtContext ctx) {", "    public Atom visitStmt(final ProgramParser.StmtContext ctx) {\n        try {\n            return super.visitStmt(ctx);\n        } catch (final RuntimeException ex) {\n            throw new InterpretationException(\n                ctx.getStart().getLine(),\n                ctx.getStart().getCharPositionInLine(),\n                \"Error while interpretation: '%s'\\n\".formatted(ex.getMessage()),\n                ex\n            );\n        }\n    }\n\n    @Override", "    public Atom visitIfStmt(final ProgramParser.IfStmtContext ctx) {\n        final Atom condition = this.visit(ctx.expressions());\n        if (condition.isTrue()) {\n            return this.visit(ctx.block());\n        }\n        if (null != ctx.elseStmt()) {\n            return this.visit(ctx.elseStmt());\n        }\n        return condition;\n    }\n\n    @Override", "    public Atom visitOutputStmt(final ProgramParser.OutputStmtContext ctx) {\n        final Atom value = this.visit(ctx.expressions());\n        this.print.println(value.asInteger());\n        return value;\n    }\n\n    @Override\n    public Atom visitWhileStmt(final ProgramParser.WhileStmtContext ctx) {\n        Atom condition = this.visit(ctx.expressions());\n        while (condition.isTrue()) {\n            this.visit(ctx.block());\n            condition = this.visit(ctx.expressions());\n        }\n        return new Value(0);\n    }\n\n    /**\n     * Initialize the print and input variables to be used for the rest of the\n     * program.\n     */\n    private void init() {\n        this.print = new PrintStream(this.stdout);\n        this.input = new BufferedReader(new InputStreamReader(this.stdin));\n    }\n\n    /**\n     * This function closes the print stream\n     */\n    private void shutdown() {\n        this.print.close();\n    }\n}\n", "        while (condition.isTrue()) {\n            this.visit(ctx.block());\n            condition = this.visit(ctx.expressions());\n        }\n        return new Value(0);\n    }\n\n    /**\n     * Initialize the print and input variables to be used for the rest of the\n     * program.\n     */\n    private void init() {\n        this.print = new PrintStream(this.stdout);\n        this.input = new BufferedReader(new InputStreamReader(this.stdin));\n    }\n\n    /**\n     * This function closes the print stream\n     */\n    private void shutdown() {\n        this.print.close();\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/MilanLexer.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.io.IOException;\nimport org.antlr.v4.runtime.CharStream;\nimport org.antlr.v4.runtime.CharStreams;\nimport org.cactoos.Text;\nimport org.cactoos.io.InputStreamOf;\n\n/**\n * It's a lexer for the Milan language that uses the `ProgramLexer` class to do the", "/**\n * It's a lexer for the Milan language that uses the `ProgramLexer` class to do the\n * heavy lifting.\n */\npublic class MilanLexer extends ProgramLexer {\n\n    public MilanLexer(final Text text) throws IOException {\n        this(CharStreams.fromStream(new InputStreamOf(text)));\n    }\n\n    public MilanLexer(final CharStream input) {\n        super(input);\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/ParsingException.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.io.Serial;\n\n/**\n * It's a runtime exception that wraps a checked exception and adds a line number.\n */\npublic final class ParsingException extends RuntimeException {\n\n    @Serial\n    private static final long serialVersionUID = 4683507305190194015L;\n    private final int line;\n\n    public ParsingException(final String msg, final Exception cause, final int line) {\n        super(msg, cause);\n        this.line = line;\n    }\n", "    public int line() {\n        return this.line;\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/Value.java", "chunked_list": ["package ru.milan.interpreter;\n\n/**\n * It's a wrapper around an object that can be either a number or a string\n */\npublic final class Value extends AtomEnvelope {\n\n    public static final Value FALSE = new Value(0);\n\n    public static final Value TRUE = new Value(1);\n\n    /**\n     * Integer ctor.\n     *\n     * @param value Integer value\n     */\n    public Value(final Integer value) {\n        super(value, false);\n    }\n}\n", "    public static final Value TRUE = new Value(1);\n\n    /**\n     * Integer ctor.\n     *\n     * @param value Integer value\n     */\n    public Value(final Integer value) {\n        super(value, false);\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/MilanInterpreter.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\n\nimport org.antlr.v4.runtime.*;\nimport org.antlr.v4.runtime.misc.ParseCancellationException;\nimport org.antlr.v4.runtime.tree.ParseTreeVisitor;", "import org.antlr.v4.runtime.misc.ParseCancellationException;\nimport org.antlr.v4.runtime.tree.ParseTreeVisitor;\nimport org.cactoos.Input;\nimport org.cactoos.Text;\nimport org.cactoos.list.ListOf;\nimport org.cactoos.text.Joined;\nimport org.cactoos.text.Split;\nimport org.cactoos.text.TextOf;\nimport ru.l3r8y.UnixizedOf;\nimport ru.milan.interpreter.exception.InterpretationException;", "import ru.l3r8y.UnixizedOf;\nimport ru.milan.interpreter.exception.InterpretationException;\nimport ru.milan.interpreter.message.FormattedErrorMessage;\n\n/**\n * It reads the input file, creates a lexer and a interpreter, and executes the interpreter\n */\npublic final class MilanInterpreter {\n\n    private final Memory<Atom> memory;\n    private final Input input;\n    private final InputStream stdin;\n    private final PrintStream stdout;\n    private final PrintStream stderr;\n\n    public MilanInterpreter(\n        final Memory<Atom> memory,\n        final Input input,\n        final InputStream in,\n        final PrintStream out,\n        final PrintStream err\n    ) {\n        this.memory = memory;\n        this.input = input;\n        this.stdin = in;\n        this.stdout = new PrintStream(out, true);\n        this.stderr = new PrintStream(err, true);\n    }\n\n    /**\n     * It reads the input file,\n     * creates a lexer and a interpreter, and executes the interpreter\n     */", "    public void run() throws Exception {\n        final List<Text> lines = this.lines();\n        final ANTLRErrorListener errors = new MilanErrorListener(lines);\n        final ProgramLexer lexer = new MilanLexer(new UnixizedOf(this.input).asText());\n        lexer.removeErrorListeners();\n        lexer.addErrorListener(errors);\n        final ProgramParser parser = new ProgramParser(\n            new CommonTokenStream(lexer)\n        );\n        parser.setErrorHandler(new BailErrorStrategy());\n        parser.removeErrorListeners();\n        parser.addErrorListener(errors);\n        this.execute(parser, this.stderr);\n    }\n\n    /**\n     * It walks the parse tree and executes the program\n     *\n     * @param parser The interpreter that was created by the ANTLR4 runtime.\n     * @param stderr The stream to which error messages are written.\n     */\n    private void execute(final ProgramParser parser, final PrintStream stderr) {", "        try {\n            this.walkParseTree(parser);\n        } catch (final InterpretationException ex) {\n            stderr.println(ex.getMessage());\n        } catch (final ParseCancellationException ex) {\n            this.formatIfParseCancelled(ex);\n        }\n    }\n\n    /**\n     * It creates a visitor that will visit the parse tree of the program, and then\n     * it visits the parse tree\n     *\n     * @param parser The interpreter object that was created by the ANTLR interpreter\n     * generator.\n     */\n    private void walkParseTree(final ProgramParser parser) {\n        final ParseTreeVisitor<Atom> visitor = new MilanVisitor(\n            this.stdin,\n            this.stdout,\n            this.stderr,\n            this.memory\n        );\n        visitor.visit(parser.prog());\n    }\n\n    /**\n     * If the exception is caused by an input mismatch, print the line number and\n     * column number of the offending token\n     *\n     * @param ex The exception that was thrown.\n     */\n    private void formatIfParseCancelled(\n        final ParseCancellationException ex\n    ) {", "        if (ex.getCause() instanceof InputMismatchException cause) {\n            final Token off = cause.getOffendingToken();\n            this.stderr.println(\n                new FormattedErrorMessage(\n                    off.getLine(),\n                    off.getCharPositionInLine(),\n                    \"Syntax error: %s not expected\"\n                        .formatted(off.getText())\n                ).asString()\n            );\n        }\n    }\n\n    /**\n     * \"Split the input text into lines, and return the lines as a list of text.\"\n     *\n     * @return A list of lines.\n     */\n    private List<Text> lines() {\n        return new ListOf<>(new Split(new TextOf(this.input), \"\\r?\\n\"));\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/AtomEnvelope.java", "chunked_list": ["package ru.milan.interpreter;\n\nimport java.util.Objects;\nimport java.util.function.BiFunction;\nimport org.cactoos.text.FormattedText;\nimport ru.milan.interpreter.exception.WrongTypeException;\n\npublic abstract class AtomEnvelope implements Atom {\n\n    private final Object value;\n\n    private final boolean nan;\n\n    /**\n     * Primary ctor,\n     *\n     * @param value The value.\n     * @param nan Is not number.\n     */\n    protected AtomEnvelope(final Object value, final boolean nan) {\n        this.value = value;\n        this.nan = nan;\n    }\n\n    @Override", "    public final boolean isNumber() {\n        return this.value instanceof Integer;\n    }\n\n    @Override\n    public final boolean isNaN() {\n        return this.nan;\n    }\n\n    @Override\n    public final Integer asInteger() {\n        return Integer.class.cast(this.value);\n    }\n\n    @Override", "    public final Integer asInteger() {\n        return Integer.class.cast(this.value);\n    }\n\n    @Override\n    public final boolean isTrue() {\n        this.assertNumber();\n        return 0 != this.asInteger();\n    }\n\n    @Override", "    public final boolean isFalse() {\n        this.assertNumber();\n        return 0 == this.asInteger();\n    }\n\n    @Override\n    public final Atom not() {\n        Atom result = Value.FALSE;\n        this.assertNumber();\n        if (0 == this.asInteger()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override", "        if (0 == this.asInteger()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override\n    public final Atom and(final Atom other) {\n        Atom result = Value.FALSE;\n        if (this.isTrue() && other.isTrue()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override", "        if (this.isTrue() && other.isTrue()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override\n    public final Atom or(final Atom other) {\n        Atom result = Value.FALSE;\n        if (this.isTrue() || other.isTrue()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override", "        if (this.isTrue() || other.isTrue()) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n\n    @Override\n    public final Atom mul(final Atom other) {\n        return this.arithmetic(other, (x, y) -> x * y);\n    }\n\n    @Override", "    public final Atom div(final Atom other) {\n        return this.arithmetic(other, (x, y) -> x / y);\n    }\n\n    @Override\n    public final Atom add(final Atom other) {\n        return this.arithmetic(other, Integer::sum);\n    }\n\n    @Override\n    public final Atom sub(final Atom other) {\n        return this.arithmetic(other, (x, y) -> x - y);\n    }\n\n    @Override", "    public final Atom sub(final Atom other) {\n        return this.arithmetic(other, (x, y) -> x - y);\n    }\n\n    @Override\n    public final Atom gt(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x > y);\n    }\n\n    @Override\n    public final Atom gte(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x >= y);\n    }\n\n    @Override", "    public final Atom gte(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x >= y);\n    }\n\n    @Override\n    public final Atom lt(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x < y);\n    }\n\n    @Override\n    public final Atom lte(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x <= y);\n    }\n\n    @Override", "    public final Atom lte(final Atom other) {\n        return this.boolOperation(other, (x, y) -> x <= y);\n    }\n\n    @Override\n    public final Atom eq(final Atom other) {\n        Atom result = Value.FALSE;\n        if (this.isNumber() && other.isNumber()) {\n            result = this.boolOperation(other, Integer::equals);\n        }\n        return result;\n    }\n\n    @Override", "    public final Atom neq(final Atom other) {\n        Atom result = Value.TRUE;\n        if (this.eq(other).equals(Value.TRUE)) {\n            result = Value.FALSE;\n        }\n        return result;\n    }\n\n    @Override\n    public final boolean equals(final Object obj) {\n        boolean result = false;", "    public final boolean equals(final Object obj) {\n        boolean result = false;\n        if (obj instanceof Atom) {\n            result = super.equals(obj);\n        }\n        return result;\n    }\n\n    @Override\n    public final int hashCode() {\n        final int result;", "    public final int hashCode() {\n        final int result;\n        if (null != this.value) {\n            result = this.value.hashCode();\n        } else {\n            result = 0;\n        }\n        return Objects.hash(result, this.nan);\n    }\n\n    @Override", "    public final void assertNumber() {\n        if (!this.isNumber()) {\n            throw new WrongTypeException(\n                \"Couldn't evaluate numeric expression '%s' \u2013 not a number\"\n                    .formatted(this.value)\n            );\n        }\n    }\n\n    /**\n     * This function takes a function that takes two integers and returns an\n     * integer, and returns a function that takes a Value and returns a Value.\n     *\n     * @param other The other value to perform the operation on.\n     * @param action a function that takes two integers and returns an integer.\n     * @return A new Value object.\n     */\n    private Atom arithmetic(\n        final Atom other,\n        final BiFunction<Integer, Integer, Integer> action\n    ) {\n        this.assertNumber();\n        other.assertNumber();\n        return new Value(action.apply(this.asInteger(), other.asInteger()));\n    }\n\n    /**\n     * \"If the two values are numbers, and the action returns true, return true,\n     * otherwise return false.\"\n     *\n     * @param other The other value to compare to.\n     * @param action a function that takes two integers and returns a boolean\n     * @return A Value object.\n     */\n    private Atom boolOperation(\n        final Atom other,\n        final BiFunction<Integer, Integer, Boolean> action\n    ) {\n        Atom result = Value.FALSE;\n        this.assertNumber();\n        other.assertNumber();", "        if (action.apply(this.asInteger(), other.asInteger())) {\n            result = Value.TRUE;\n        }\n        return result;\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/message/FormattedErrorMessage.java", "chunked_list": ["package ru.milan.interpreter.message;\n\nimport lombok.RequiredArgsConstructor;\nimport org.cactoos.Text;\nimport org.cactoos.text.FormattedText;\n\n/**\n * It's a `Text` that formats an error message.\n */\n@RequiredArgsConstructor\npublic final class FormattedErrorMessage implements Text {\n\n    private final int line;\n    private final int pos;\n    private final String message;\n\n    @Override", " */\n@RequiredArgsConstructor\npublic final class FormattedErrorMessage implements Text {\n\n    private final int line;\n    private final int pos;\n    private final String message;\n\n    @Override\n    public String asString() {\n        return \"Error at [%d, %d]:\\n\\t%s\".formatted(\n            this.line, this.pos, this.message\n        );\n    }\n}\n", "    public String asString() {\n        return \"Error at [%d, %d]:\\n\\t%s\".formatted(\n            this.line, this.pos, this.message\n        );\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/exception/BreakLoop.java", "chunked_list": ["package ru.milan.interpreter.exception;\n\nimport java.io.Serial;\n\npublic class BreakLoop extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = -1996736307460267582L;\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/exception/WrongTypeException.java", "chunked_list": ["package ru.milan.interpreter.exception;\n\nimport java.io.Serial;\n\npublic final class WrongTypeException extends RuntimeException {\n\n    @Serial\n    private static final long serialVersionUID = 8611745140496379648L;\n\n    public WrongTypeException(final String message) {\n        super(message);\n    }\n\n    public WrongTypeException(final String message, final Throwable cause) {\n        super(message, cause);\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/exception/ContinueLoop.java", "chunked_list": ["package ru.milan.interpreter.exception;\n\nimport java.io.Serial;\n\npublic class ContinueLoop extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = 6180650911272721570L;\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/exception/InterpretationException.java", "chunked_list": ["package ru.milan.interpreter.exception;\n\nimport ru.milan.interpreter.message.FormattedErrorMessage;\n\npublic class InterpretationException extends RuntimeException {\n\n    private final int line;\n    private final int pos;\n\n    public InterpretationException(\n        final int line,\n        final int pos,\n        final String msg,\n        final Throwable cause\n    ) {\n        super(msg, cause);\n        this.line = line;\n        this.pos = pos;\n    }\n\n    @Override", "    public final String getMessage() {\n        return new FormattedErrorMessage(\n            this.line,\n            this.pos,\n            super.getMessage()\n        ).asString();\n    }\n}\n"]}
{"filename": "milan-interpreter/src/main/java/ru/milan/interpreter/exception/AtomNotDefinedException.java", "chunked_list": ["package ru.milan.interpreter.exception;\n\nimport java.io.Serial;\n\npublic class AtomNotDefinedException extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = -8835732774840137937L;\n\n    public AtomNotDefinedException(final String text) {\n        super(text.toString());\n    }\n}\n"]}
{"filename": "milan-cli/src/main/java/ru/milan/cli/ProgramSource.java", "chunked_list": ["package ru.milan.cli;\n\nimport java.io.File;\nimport java.util.concurrent.Callable;\nimport org.cactoos.io.InputOf;\nimport org.cactoos.text.FormattedText;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Parameters;\nimport ru.milan.interpreter.AnnotativeMemory;\nimport ru.milan.interpreter.MilanInterpreter;", "import ru.milan.interpreter.AnnotativeMemory;\nimport ru.milan.interpreter.MilanInterpreter;\n\n@Command(\n    name = \"source\",\n    mixinStandardHelpOptions = true,\n    version = \"1.0.0\",\n    description = \"The source of Milan program, file with extension .mil\"\n)\npublic class ProgramSource implements Callable<Integer> {\n\n    @Parameters(\n        index = \"0\",\n        description = \"Path to source file\"\n    )\n    private File source;\n\n    @Override", ")\npublic class ProgramSource implements Callable<Integer> {\n\n    @Parameters(\n        index = \"0\",\n        description = \"Path to source file\"\n    )\n    private File source;\n\n    @Override\n    public Integer call() throws Exception {", "    public Integer call() throws Exception {\n        try {\n            final MilanInterpreter interpreter = new MilanInterpreter(\n                new AnnotativeMemory(),\n                new InputOf(this.source),\n                System.in,\n                System.out,\n                System.err\n            );\n            interpreter.run();\n        } catch (final RuntimeException ex) {\n            System.out.printf(\"Error executing the program: %s%n\", ex.getMessage());\n            System.exit(-1);\n        }\n        return 0;\n    }\n}\n"]}
{"filename": "milan-cli/src/main/java/ru/milan/cli/Cli.java", "chunked_list": ["package ru.milan.cli;\n\nimport picocli.CommandLine;\n\n/**\n * @todo #20:30min/DEV Write unit tests.\n * Unit test for cli interface.\n */\n/**\n * @todo #20:30min/DEV Add CLI to some package manager.", "/**\n * @todo #20:30min/DEV Add CLI to some package manager.\n * Add the CLI to some package manager, such as npm and etc\n */\npublic class Cli {\n    public static void main(final String[] args) {\n        System.exit(\n            new CommandLine(new ProgramSource()).execute(args)\n        );\n    }\n}\n"]}
