{"filename": "src/main/java/com/froobworld/seemore/SeeMore.java", "chunked_list": ["package com.froobworld.seemore;\n\nimport com.froobworld.seemore.command.SeeMoreCommand;\nimport com.froobworld.seemore.config.SeeMoreConfig;\nimport com.froobworld.seemore.controller.ViewDistanceController;\nimport com.froobworld.seemore.metrics.SeeMoreMetrics;\nimport com.froobworld.seemore.scheduler.BukkitSchedulerHook;\nimport com.froobworld.seemore.scheduler.RegionisedSchedulerHook;\nimport com.froobworld.seemore.scheduler.SchedulerHook;\nimport org.bukkit.Bukkit;", "import com.froobworld.seemore.scheduler.SchedulerHook;\nimport org.bukkit.Bukkit;\nimport org.bukkit.command.PluginCommand;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class SeeMore extends JavaPlugin {\n    private SeeMoreConfig config;\n    private SchedulerHook schedulerHook;\n    private ViewDistanceController viewDistanceController;\n\n    @Override", "    public void onEnable() {\n        config = new SeeMoreConfig(this);\n        try {\n            config.load();\n        } catch (Exception e) {\n            getLogger().severe(\"Error loading config\");\n            e.printStackTrace();\n            Bukkit.getPluginManager().disablePlugin(this);\n            return;\n        }\n        if (RegionisedSchedulerHook.isCompatible()) {\n            schedulerHook = new RegionisedSchedulerHook(this);\n        } else {\n            schedulerHook = new BukkitSchedulerHook(this);\n        }\n\n        viewDistanceController = new ViewDistanceController(this);\n\n        registerCommand();\n\n        new SeeMoreMetrics(this);\n    }\n\n    @Override", "        if (RegionisedSchedulerHook.isCompatible()) {\n            schedulerHook = new RegionisedSchedulerHook(this);\n        } else {\n            schedulerHook = new BukkitSchedulerHook(this);\n        }\n\n        viewDistanceController = new ViewDistanceController(this);\n\n        registerCommand();\n\n        new SeeMoreMetrics(this);\n    }\n\n    @Override", "    public void onDisable() {\n\n    }\n\n    private void registerCommand() {\n        PluginCommand pluginCommand = getCommand(\"seemore\");\n        if (pluginCommand != null) {\n            SeeMoreCommand seeMoreCommand = new SeeMoreCommand(this);\n            pluginCommand.setExecutor(seeMoreCommand);\n            pluginCommand.setTabCompleter(seeMoreCommand);\n            pluginCommand.setPermission(\"seemore.command.seemore\");\n        }\n    }\n", "    public void reload() throws Exception {\n        config.load();\n        if (viewDistanceController != null) {\n\n            // Update the target view distance of all players in case the configured maximum has changed\n            viewDistanceController.updateAllPlayers();\n        }\n    }\n\n    public SeeMoreConfig getSeeMoreConfig() {\n        return config;\n    }\n", "    public SeeMoreConfig getSeeMoreConfig() {\n        return config;\n    }\n\n    public SchedulerHook getSchedulerHook() {\n        return schedulerHook;\n    }\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/config/SeeMoreConfig.java", "chunked_list": ["package com.froobworld.seemore.config;\n\nimport com.froobworld.nabconfiguration.*;\nimport com.froobworld.nabconfiguration.annotations.Entry;\nimport com.froobworld.nabconfiguration.annotations.SectionMap;\nimport com.froobworld.seemore.SeeMore;\nimport org.bukkit.World;\n\nimport java.io.File;\n\npublic class SeeMoreConfig extends NabConfiguration {\n    private static final int VERSION = 1;\n\n    public SeeMoreConfig(SeeMore seeMore) {\n        super(\n                new File(seeMore.getDataFolder(), \"config.yml\"),\n                () -> seeMore.getResource(\"config.yml\"),\n                i -> seeMore.getResource(\"config-patches/\" + i + \".patch\"),\n                VERSION\n        );\n    }\n\n    @Entry(key = \"update-delay\")", "import java.io.File;\n\npublic class SeeMoreConfig extends NabConfiguration {\n    private static final int VERSION = 1;\n\n    public SeeMoreConfig(SeeMore seeMore) {\n        super(\n                new File(seeMore.getDataFolder(), \"config.yml\"),\n                () -> seeMore.getResource(\"config.yml\"),\n                i -> seeMore.getResource(\"config-patches/\" + i + \".patch\"),\n                VERSION\n        );\n    }\n\n    @Entry(key = \"update-delay\")", "    public final ConfigEntry<Integer> updateDelay = ConfigEntries.integerEntry();\n\n    @SectionMap(key = \"world-settings\", defaultKey = \"default\")\n    public final ConfigSectionMap<World, WorldSettings> worldSettings = new ConfigSectionMap<>(World::getName, WorldSettings.class, true);\n\n    public static class WorldSettings extends ConfigSection {\n\n        @Entry(key = \"maximum-view-distance\")\n        public final ConfigEntry<Integer> maximumViewDistance = ConfigEntries.integerEntry();\n\n    }\n\n}\n", "        public final ConfigEntry<Integer> maximumViewDistance = ConfigEntries.integerEntry();\n\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/metrics/SeeMoreMetrics.java", "chunked_list": ["package com.froobworld.seemore.metrics;\n\nimport com.froobworld.seemore.SeeMore;\nimport com.froobworld.seemore.metrics.charts.NumberOfWorldsChart;\nimport org.bstats.bukkit.Metrics;\n\npublic class SeeMoreMetrics {\n    private final Metrics metrics;\n\n    public SeeMoreMetrics(SeeMore seeMore) {\n        this.metrics = new Metrics(seeMore, 18658);\n        addCharts();\n    }\n\n    private void addCharts() {\n        metrics.addCustomChart(new NumberOfWorldsChart());\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/metrics/charts/NumberOfWorldsChart.java", "chunked_list": ["package com.froobworld.seemore.metrics.charts;\n\nimport org.bstats.charts.SimplePie;\nimport org.bukkit.Bukkit;\n\npublic class NumberOfWorldsChart extends SimplePie {\n\n    public NumberOfWorldsChart() {\n        super(\"number_of_worlds\", () -> Bukkit.getWorlds().size() + \"\");\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/command/SeeMoreCommand.java", "chunked_list": ["package com.froobworld.seemore.command;\n\nimport com.froobworld.seemore.SeeMore;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.util.StringUtil;", "import org.bukkit.command.TabCompleter;\nimport org.bukkit.util.StringUtil;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static net.kyori.adventure.text.Component.*;\n\npublic class SeeMoreCommand implements CommandExecutor, TabCompleter {\n    private static final Component NO_PERMISSION = text(\"You don't have permission to use this command.\", NamedTextColor.RED);\n    private final SeeMore seeMore;\n    private final AverageCommand averageCommand;\n    private final ReloadCommand reloadCommand;\n\n    public SeeMoreCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n        this.averageCommand = new AverageCommand(seeMore);\n        this.reloadCommand = new ReloadCommand(seeMore);\n    }\n\n    @Override", "import static net.kyori.adventure.text.Component.*;\n\npublic class SeeMoreCommand implements CommandExecutor, TabCompleter {\n    private static final Component NO_PERMISSION = text(\"You don't have permission to use this command.\", NamedTextColor.RED);\n    private final SeeMore seeMore;\n    private final AverageCommand averageCommand;\n    private final ReloadCommand reloadCommand;\n\n    public SeeMoreCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n        this.averageCommand = new AverageCommand(seeMore);\n        this.reloadCommand = new ReloadCommand(seeMore);\n    }\n\n    @Override", "    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        if (!sender.hasPermission(\"seemore.command.seemore\")) {\n            sender.sendMessage(NO_PERMISSION);\n            return false;\n        }\n\n        if (args.length > 0) {\n            if (args[0].equalsIgnoreCase(\"average\")) {\n                if (sender.hasPermission(\"seemore.command.average\")) {\n                    return averageCommand.onCommand(sender, command, label, args);\n                } else {\n                    sender.sendMessage(NO_PERMISSION);\n                    return false;\n                }\n            }", "                if (sender.hasPermission(\"seemore.command.average\")) {\n                    return averageCommand.onCommand(sender, command, label, args);\n                } else {\n                    sender.sendMessage(NO_PERMISSION);\n                    return false;\n                }\n            }\n            if (args[0].equalsIgnoreCase(\"reload\")) {\n                if (sender.hasPermission(\"seemore.command.reload\")) {\n                    return reloadCommand.onCommand(sender, command, label, args);\n                } else {\n                    sender.sendMessage(NO_PERMISSION);\n                    return false;\n                }\n            }\n        }\n        sender.sendMessage(text(\"SeeMore v\" + seeMore.getDescription().getVersion(), NamedTextColor.GRAY));\n        sender.sendMessage(empty());", "                if (sender.hasPermission(\"seemore.command.reload\")) {\n                    return reloadCommand.onCommand(sender, command, label, args);\n                } else {\n                    sender.sendMessage(NO_PERMISSION);\n                    return false;\n                }\n            }\n        }\n        sender.sendMessage(text(\"SeeMore v\" + seeMore.getDescription().getVersion(), NamedTextColor.GRAY));\n        sender.sendMessage(empty());\n        if (sender.hasPermission(\"seemore.command.reload\")) {\n            sender.sendMessage(text(\"/seemore reload\"));\n        }", "        if (sender.hasPermission(\"seemore.command.reload\")) {\n            sender.sendMessage(text(\"/seemore reload\"));\n        }\n        if (sender.hasPermission(\"seemore.command.average\")) {\n            sender.sendMessage(text(\"/seemore average\"));\n        }\n        return true;\n    }\n\n    @Override\n    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        List<String> suggestions = new ArrayList<>();", "        if (args.length == 1) {\n            if (sender.hasPermission(\"seemore.command.reload\")) {\n                suggestions.add(\"reload\");\n            }\n            if (sender.hasPermission(\"seemore.command.average\")) {\n                suggestions.add(\"average\");\n            }\n        }\n\n        return StringUtil.copyPartialMatches(args[args.length - 1], suggestions, new ArrayList<>());\n    }\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/command/AverageCommand.java", "chunked_list": ["package com.froobworld.seemore.command;\n\nimport com.froobworld.seemore.SeeMore;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.bukkit.Bukkit;\nimport org.bukkit.World;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;", "import org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.text.DecimalFormat;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;", "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static net.kyori.adventure.text.Component.*;\n\npublic class AverageCommand implements CommandExecutor, TabCompleter {\n    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"#.0\");\n    private final SeeMore seeMore;\n\n    public AverageCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override", "\npublic class AverageCommand implements CommandExecutor, TabCompleter {\n    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"#.0\");\n    private final SeeMore seeMore;\n\n    public AverageCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override\n    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        CompletableFuture<Void> future = CompletableFuture.completedFuture(null);\n        Map<World, AtomicInteger> chunkCountMap = new ConcurrentHashMap<>();\n        Map<World, AtomicInteger> playerCountMap = new ConcurrentHashMap<>();\n", "    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        CompletableFuture<Void> future = CompletableFuture.completedFuture(null);\n        Map<World, AtomicInteger> chunkCountMap = new ConcurrentHashMap<>();\n        Map<World, AtomicInteger> playerCountMap = new ConcurrentHashMap<>();\n\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            CompletableFuture<Void> playerFuture = new CompletableFuture<>();\n            future = future.thenCompose(v -> playerFuture);\n            seeMore.getSchedulerHook().runEntityTaskAsap(() -> {\n                chunkCountMap.compute(player.getWorld(), (world, chunkCount) -> {\n                    if (chunkCount == null) {\n                        chunkCount = new AtomicInteger();\n                    }", "                    if (chunkCount == null) {\n                        chunkCount = new AtomicInteger();\n                    }\n                    try {\n                        int viewDistance = player.getViewDistance();\n                        chunkCount.addAndGet((2 * viewDistance + 1) * (2 * viewDistance + 1));\n                        playerCountMap.computeIfAbsent(world, w -> new AtomicInteger()).getAndIncrement();\n                    } catch (Throwable ignored) {}\n                    return chunkCount;\n                });\n                playerFuture.complete(null);\n            }, () -> playerFuture.complete(null), player);\n        }\n\n        future.thenRun(() -> {\n            Map<World, Double> effectiveViewDistanceMap = new HashMap<>();\n            int totalChunkCount = 0;\n            int totalPlayerCount = 0;", "            for (World world : chunkCountMap.keySet()) {\n                int chunkCount = chunkCountMap.get(world).get();\n                int playerCount = playerCountMap.get(world).get();\n                if (playerCount == 0) {\n                    continue;\n                }\n\n                double effectiveViewDistance = (Math.sqrt((double) chunkCount / (double) playerCount) - 1.0) / 2.0;\n                effectiveViewDistanceMap.put(world, effectiveViewDistance);\n\n                totalChunkCount += chunkCount;\n                totalPlayerCount += playerCount;\n            }\n            double totalEffectiveViewDistance = totalPlayerCount == 0 ? 0 : (Math.sqrt((double) totalChunkCount / (double) totalPlayerCount) - 1.0) / 2.0;\n\n            sender.sendMessage(text(\"Effective average view distance:\", NamedTextColor.GRAY));\n            sender.sendMessage(\n                    text(\"All worlds: \", NamedTextColor.GOLD)\n                            .append(text(formatViewDistance(totalEffectiveViewDistance), NamedTextColor.RED))\n            );\n            sender.sendMessage(empty());\n            sender.sendMessage(text(\"--------------------------\"));", "            for (World world : Bukkit.getWorlds()) {\n                double effectiveViewDistance = effectiveViewDistanceMap.getOrDefault(world, 0.0);\n                sender.sendMessage(\n                        text(world.getName() + \": \", NamedTextColor.GOLD)\n                                .append(text(formatViewDistance(effectiveViewDistance), NamedTextColor.RED))\n                );\n            }\n            sender.sendMessage(text(\"--------------------------\"));\n        });\n        return true;\n    }\n\n    @Override\n    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        return Collections.emptyList();\n    }\n\n    private static String formatViewDistance(double viewDistance) {", "        if (viewDistance == 0) {\n            return \"-\";\n        }\n        return DECIMAL_FORMAT.format(viewDistance);\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/command/ReloadCommand.java", "chunked_list": ["package com.froobworld.seemore.command;\n\nimport com.froobworld.seemore.SeeMore;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;", "import org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static net.kyori.adventure.text.Component.*;\n\npublic class ReloadCommand implements CommandExecutor, TabCompleter {\n    private final SeeMore seeMore;\n\n    public ReloadCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override", "public class ReloadCommand implements CommandExecutor, TabCompleter {\n    private final SeeMore seeMore;\n\n    public ReloadCommand(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override\n    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        try {\n            seeMore.reload();\n            sender.sendMessage(text(\"Plugin reloaded.\", NamedTextColor.GRAY));\n        } catch (Exception e) {\n            sender.sendMessage(text(\"There was an error while reloading the plugin. See console for details.\", NamedTextColor.RED));\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        return Collections.emptyList();\n    }\n}\n", "    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        try {\n            seeMore.reload();\n            sender.sendMessage(text(\"Plugin reloaded.\", NamedTextColor.GRAY));\n        } catch (Exception e) {\n            sender.sendMessage(text(\"There was an error while reloading the plugin. See console for details.\", NamedTextColor.RED));\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n        return Collections.emptyList();\n    }\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/controller/ViewDistanceController.java", "chunked_list": ["package com.froobworld.seemore.controller;\n\nimport com.froobworld.seemore.SeeMore;\nimport com.froobworld.seemore.scheduler.ScheduledTask;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\n\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;", "import java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\n\npublic class ViewDistanceController {\n    private static final int MAX_UPDATE_ATTEMPTS = 10;\n    private final SeeMore seeMore;\n    private final Map<UUID, Integer> targetViewDistanceMap = new ConcurrentHashMap<>();\n    private final Map<UUID, Integer> targetSendDistanceMap = new ConcurrentHashMap<>();\n    private final Map<UUID, ScheduledTask> viewDistanceUpdateTasks = new ConcurrentHashMap<>();\n    private final Map<UUID, ScheduledTask> sendDistanceUpdateTasks = new ConcurrentHashMap<>();\n\n    public ViewDistanceController(SeeMore seeMore) {\n        this.seeMore = seeMore;\n        seeMore.getSchedulerHook().runRepeatingTask(this::cleanMaps, 1200, 1200);\n        Bukkit.getPluginManager().registerEvents(new ViewDistanceUpdater(this), seeMore);\n    }\n", "    public void updateAllPlayers() {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            seeMore.getSchedulerHook().runEntityTaskAsap(() -> {\n                setTargetViewDistance(player, player.getClientViewDistance(), false);\n            }, null, player);\n        }\n    }\n\n    public void setTargetViewDistance(Player player, int clientViewDistance, boolean testDelay) {\n        int floor = player.getWorld().getSimulationDistance();\n        int ceiling = Math.min(seeMore.getSeeMoreConfig().worldSettings.of(player.getWorld()).maximumViewDistance.get(), 32);\n\n        // Default to the world's view distance if the configured ceiling is negative\n        ceiling = ceiling < 0 ? player.getWorld().getViewDistance() : ceiling;\n\n        targetViewDistanceMap.put(player.getUniqueId(), Math.max(floor, Math.min(ceiling, clientViewDistance)));\n        targetSendDistanceMap.put(player.getUniqueId(), Math.max(2, Math.min(ceiling, clientViewDistance)) + 1);\n\n        // Update the view distance with a delay if it is being lowered\n        long delay = 0;", "    public void setTargetViewDistance(Player player, int clientViewDistance, boolean testDelay) {\n        int floor = player.getWorld().getSimulationDistance();\n        int ceiling = Math.min(seeMore.getSeeMoreConfig().worldSettings.of(player.getWorld()).maximumViewDistance.get(), 32);\n\n        // Default to the world's view distance if the configured ceiling is negative\n        ceiling = ceiling < 0 ? player.getWorld().getViewDistance() : ceiling;\n\n        targetViewDistanceMap.put(player.getUniqueId(), Math.max(floor, Math.min(ceiling, clientViewDistance)));\n        targetSendDistanceMap.put(player.getUniqueId(), Math.max(2, Math.min(ceiling, clientViewDistance)) + 1);\n\n        // Update the view distance with a delay if it is being lowered\n        long delay = 0;", "        try {\n            if (testDelay && player.getViewDistance() > targetViewDistanceMap.get(player.getUniqueId())) {\n                delay = seeMore.getSeeMoreConfig().updateDelay.get();\n            }\n        } catch (Exception ignored) {}\n\n        updateSendDistance(player);\n        updateViewDistance(player, delay);\n    }\n\n    private void updateSendDistance(Player player) {\n        updateDistance(player, 0, 0, targetSendDistanceMap, sendDistanceUpdateTasks, Player::setSendViewDistance);\n    }\n\n    private void updateViewDistance(Player player, long delay) {\n        updateDistance(player, delay, 0, targetViewDistanceMap, viewDistanceUpdateTasks, Player::setViewDistance);\n    }\n\n    private void updateDistance(Player player, long delay, int attempts, Map<UUID, Integer> distanceMap, Map<UUID, ScheduledTask> taskMap, BiConsumer<Player, Integer> distanceConsumer) {", "        if (attempts >= MAX_UPDATE_ATTEMPTS) {\n            return; // give up if attempted too many times\n        }\n        Integer distance = distanceMap.get(player.getUniqueId());\n        if (distance == null) {\n            return; // might be null if the player has left\n        }\n        taskMap.compute(player.getUniqueId(), (uuid, task) -> {\n            if (task != null) {\n                task.cancel(); // cancel the previous task in case it is still running\n            }", "            if (task != null) {\n                task.cancel(); // cancel the previous task in case it is still running\n            }\n            if (delay > 0) {\n                return seeMore.getSchedulerHook().runTaskDelayed(() -> updateDistance(player, 0, attempts, distanceMap, taskMap, distanceConsumer), delay);\n            }\n            CompletableFuture<ScheduledTask> retryTask = new CompletableFuture<>();\n            ScheduledTask updateTask = seeMore.getSchedulerHook().runEntityTaskAsap(() -> {\n                try {\n                    distanceConsumer.accept(player, distance);\n                } catch (Throwable ex) {\n\n                    // will sometimes fail if the player is not attached to a world yet, so retry after 20 ticks\n                    retryTask.complete(seeMore.getSchedulerHook().runTask(() -> updateDistance(player, 20, attempts + 1, distanceMap, taskMap, distanceConsumer)));\n                }\n            }, null, player);\n            return retryTask.getNow(updateTask);\n        });\n    }\n\n    private void cleanMaps() {\n        sendDistanceUpdateTasks.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        viewDistanceUpdateTasks.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        targetSendDistanceMap.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        targetViewDistanceMap.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n    }\n\n}\n", "                try {\n                    distanceConsumer.accept(player, distance);\n                } catch (Throwable ex) {\n\n                    // will sometimes fail if the player is not attached to a world yet, so retry after 20 ticks\n                    retryTask.complete(seeMore.getSchedulerHook().runTask(() -> updateDistance(player, 20, attempts + 1, distanceMap, taskMap, distanceConsumer)));\n                }\n            }, null, player);\n            return retryTask.getNow(updateTask);\n        });\n    }\n\n    private void cleanMaps() {\n        sendDistanceUpdateTasks.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        viewDistanceUpdateTasks.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        targetSendDistanceMap.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n        targetViewDistanceMap.entrySet().removeIf(entry -> Bukkit.getPlayer(entry.getKey()) == null);\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/controller/ViewDistanceUpdater.java", "chunked_list": ["package com.froobworld.seemore.controller;\n\nimport com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent;\nimport com.google.common.collect.Sets;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerChangedWorldEvent;\nimport org.bukkit.event.player.PlayerQuitEvent;\n\nimport java.util.Set;", "\nimport java.util.Set;\nimport java.util.UUID;\n\npublic class ViewDistanceUpdater implements Listener {\n    private final ViewDistanceController controller;\n    private final Set<UUID> seenBefore = Sets.newConcurrentHashSet();\n\n    public ViewDistanceUpdater(ViewDistanceController viewDistanceController) {\n        this.controller = viewDistanceController;\n    }\n\n    @EventHandler\n    private void onOptionsChange(PlayerClientOptionsChangeEvent event) {\n\n        // the change check may fail if the player has just joined the server, so also check if we have seen them before\n        boolean seen = seenBefore.contains(event.getPlayer().getUniqueId());\n", "        if (event.hasViewDistanceChanged() || !seen) {\n            seenBefore.add(event.getPlayer().getUniqueId());\n            controller.setTargetViewDistance(event.getPlayer(), event.getViewDistance(), seen);\n        }\n    }\n\n    @EventHandler\n    private void onQuit(PlayerQuitEvent event) {\n        seenBefore.remove(event.getPlayer().getUniqueId());\n    }\n\n    @EventHandler\n    private void onWorldChange(PlayerChangedWorldEvent event) {\n        controller.setTargetViewDistance(event.getPlayer(), event.getPlayer().getClientViewDistance(), false);\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/scheduler/SchedulerHook.java", "chunked_list": ["package com.froobworld.seemore.scheduler;\n\nimport org.bukkit.entity.Entity;\n\npublic interface SchedulerHook {\n\n    ScheduledTask runTask(Runnable runnable);\n\n    ScheduledTask runTaskDelayed(Runnable runnable, long delay);\n\n    ScheduledTask runRepeatingTask(Runnable runnable, long initDelay, long period);\n\n    ScheduledTask runEntityTask(Runnable runnable, Runnable retired, Entity entity);\n\n    ScheduledTask runEntityTaskAsap(Runnable runnable, Runnable retired, Entity entity);\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/scheduler/BukkitSchedulerHook.java", "chunked_list": ["package com.froobworld.seemore.scheduler;\n\nimport com.froobworld.seemore.SeeMore;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Entity;\n\npublic class BukkitSchedulerHook implements SchedulerHook {\n    private final SeeMore seeMore;\n\n    public BukkitSchedulerHook(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override", "    public ScheduledTask runTask(Runnable runnable) {\n        return new BukkitScheduledTask(Bukkit.getScheduler().runTask(seeMore, runnable).getTaskId());\n    }\n\n    @Override\n    public ScheduledTask runTaskDelayed(Runnable runnable, long delay) {\n        return new BukkitScheduledTask(Bukkit.getScheduler().runTaskLater(seeMore, runnable, delay).getTaskId());\n    }\n\n    @Override\n    public ScheduledTask runRepeatingTask(Runnable runnable, long initDelay, long period) {\n        return new BukkitScheduledTask(Bukkit.getScheduler().scheduleSyncRepeatingTask(seeMore, runnable, initDelay, period));\n    }\n\n    @Override", "    public ScheduledTask runRepeatingTask(Runnable runnable, long initDelay, long period) {\n        return new BukkitScheduledTask(Bukkit.getScheduler().scheduleSyncRepeatingTask(seeMore, runnable, initDelay, period));\n    }\n\n    @Override\n    public ScheduledTask runEntityTask(Runnable runnable, Runnable retired, Entity entity) {\n        return runTask(runnable);\n    }\n\n    @Override\n    public ScheduledTask runEntityTaskAsap(Runnable runnable, Runnable retired, Entity entity) {", "    public ScheduledTask runEntityTaskAsap(Runnable runnable, Runnable retired, Entity entity) {\n        if (Bukkit.isPrimaryThread()) {\n            runnable.run();\n            return new ScheduledTask() {\n                @Override\n                public void cancel() {}\n\n                @Override\n                public boolean isCancelled() {\n                    return false;\n                }\n            };\n        }\n        return runTask(runnable);\n    }\n\n    private static class BukkitScheduledTask implements ScheduledTask {\n        private final int taskId;\n\n        private BukkitScheduledTask(int taskId) {\n            this.taskId = taskId;\n        }\n\n        @Override", "                public boolean isCancelled() {\n                    return false;\n                }\n            };\n        }\n        return runTask(runnable);\n    }\n\n    private static class BukkitScheduledTask implements ScheduledTask {\n        private final int taskId;\n\n        private BukkitScheduledTask(int taskId) {\n            this.taskId = taskId;\n        }\n\n        @Override", "        public void cancel() {\n            Bukkit.getScheduler().cancelTask(taskId);\n        }\n\n        @Override\n        public boolean isCancelled() {\n            return !Bukkit.getScheduler().isQueued(taskId) && !Bukkit.getScheduler().isCurrentlyRunning(taskId);\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/scheduler/RegionisedSchedulerHook.java", "chunked_list": ["package com.froobworld.seemore.scheduler;\n\nimport com.froobworld.seemore.SeeMore;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Entity;\n\npublic class RegionisedSchedulerHook implements SchedulerHook {\n    private final SeeMore seeMore;\n\n    public RegionisedSchedulerHook(SeeMore seeMore) {\n        this.seeMore = seeMore;\n    }\n\n    @Override", "    public ScheduledTask runTask(Runnable runnable) {\n        return new RegionisedScheduledTask(Bukkit.getGlobalRegionScheduler().run(seeMore, task -> runnable.run()));\n    }\n\n    @Override\n    public ScheduledTask runTaskDelayed(Runnable runnable, long delay) {\n        return new RegionisedScheduledTask(Bukkit.getGlobalRegionScheduler().runDelayed(seeMore, task -> runnable.run(), delay));\n    }\n\n    @Override\n    public ScheduledTask runRepeatingTask(Runnable runnable, long initDelay, long period) {\n        return new RegionisedScheduledTask(Bukkit.getGlobalRegionScheduler().runAtFixedRate(seeMore, task -> runnable.run(), initDelay, period));\n    }\n\n    @Override", "    public ScheduledTask runRepeatingTask(Runnable runnable, long initDelay, long period) {\n        return new RegionisedScheduledTask(Bukkit.getGlobalRegionScheduler().runAtFixedRate(seeMore, task -> runnable.run(), initDelay, period));\n    }\n\n    @Override\n    public ScheduledTask runEntityTask(Runnable runnable, Runnable retired, Entity entity) {\n        io.papermc.paper.threadedregions.scheduler.ScheduledTask scheduledTask = entity.getScheduler().run(seeMore, task -> runnable.run(), retired);\n        return scheduledTask == null ? null : new RegionisedScheduledTask(scheduledTask);\n    }\n\n    @Override", "    public ScheduledTask runEntityTaskAsap(Runnable runnable, Runnable retired, Entity entity) {\n        if (Bukkit.isOwnedByCurrentRegion(entity)) {\n            runnable.run();\n            return new ScheduledTask() {\n                @Override\n                public void cancel() {}\n\n                @Override\n                public boolean isCancelled() {\n                    return false;\n                }\n            };\n        }\n        return runEntityTask(runnable, retired, entity);\n    }\n", "                public boolean isCancelled() {\n                    return false;\n                }\n            };\n        }\n        return runEntityTask(runnable, retired, entity);\n    }\n\n    public static boolean isCompatible() {\n        try {\n            Class.forName(\"io.papermc.paper.threadedregions.scheduler.AsyncScheduler\");\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    private static class RegionisedScheduledTask implements ScheduledTask {\n        private final io.papermc.paper.threadedregions.scheduler.ScheduledTask scheduledTask;\n\n        private RegionisedScheduledTask(io.papermc.paper.threadedregions.scheduler.ScheduledTask scheduledTask) {\n            this.scheduledTask = scheduledTask;\n        }\n\n        @Override", "    public static boolean isCompatible() {\n        try {\n            Class.forName(\"io.papermc.paper.threadedregions.scheduler.AsyncScheduler\");\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    private static class RegionisedScheduledTask implements ScheduledTask {\n        private final io.papermc.paper.threadedregions.scheduler.ScheduledTask scheduledTask;\n\n        private RegionisedScheduledTask(io.papermc.paper.threadedregions.scheduler.ScheduledTask scheduledTask) {\n            this.scheduledTask = scheduledTask;\n        }\n\n        @Override", "        public void cancel() {\n            scheduledTask.cancel();\n        }\n\n        @Override\n        public boolean isCancelled() {\n            return scheduledTask.isCancelled();\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/com/froobworld/seemore/scheduler/ScheduledTask.java", "chunked_list": ["package com.froobworld.seemore.scheduler;\n\npublic interface ScheduledTask {\n\n    void cancel();\n\n    boolean isCancelled();\n\n}\n"]}
