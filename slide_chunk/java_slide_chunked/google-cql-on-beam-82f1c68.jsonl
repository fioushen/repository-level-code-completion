{"filename": "src/test/java/com/google/fhir/cql/beam/FileLoaderTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.base.Predicates.alwaysFalse;", "\nimport static com.google.common.base.Predicates.alwaysFalse;\nimport static com.google.common.base.Predicates.alwaysTrue;\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;", "import java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n", "import org.junit.runners.JUnit4;\n\n/** Tests for {@link FileLoader}. */\n@RunWith(JUnit4.class)\npublic class FileLoaderTest {\n  @Rule public final TemporaryFolder tempFolder = new TemporaryFolder();\n\n  private Path tempFolderPath() {\n    return tempFolder.getRoot().toPath();\n  }\n\n  private void writeToNewTempFile(String content) throws IOException {\n    Files.writeString(tempFolder.newFile().toPath(), content, StandardCharsets.UTF_8);\n  }\n\n  @Test", "  public void loadFilesInDirectory_nonExistentDirectory() throws IOException {\n    Path nonExistentDirectory = tempFolder.getRoot().toPath().resolve(\"foo\");\n\n    assertThrows(NoSuchFileException.class,\n        () -> FileLoader.loadFilesInDirectory(nonExistentDirectory, alwaysTrue()));\n  }\n\n  @Test\n  public void loadFilesInDirectory_emptyDirectory() throws IOException {\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).isEmpty();\n  }\n\n  @Test", "  public void loadFilesInDirectory_emptyDirectory() throws IOException {\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).isEmpty();\n  }\n\n  @Test\n  public void loadFilesInDirectory_readsOneFile() throws IOException {\n    writeToNewTempFile(\"foo\");\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).containsExactly(\"foo\");\n  }\n\n  @Test", "  public void loadFilesInDirectory_ignoresFilteredFiles() throws IOException {\n    writeToNewTempFile(\"foo\");\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysFalse());\n    assertThat(result).isEmpty();\n  }\n\n  @Test\n  public void loadFilesInDirectory_readsMultipleFiles() throws IOException {\n    writeToNewTempFile(\"foo\");\n    writeToNewTempFile(\"bar\");\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).containsExactly(\"foo\", \"bar\");\n  }\n\n  @Test", "  public void loadFilesInDirectory_readsMultipleFiles() throws IOException {\n    writeToNewTempFile(\"foo\");\n    writeToNewTempFile(\"bar\");\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).containsExactly(\"foo\", \"bar\");\n  }\n\n  @Test\n  public void loadFilesInDirectory_ignoresSubdirectories() throws IOException {\n    Files.writeString(\n        tempFolder.newFolder(\"subdirectory\").toPath().resolve(\"file\"),\n        \"content\",\n        StandardCharsets.UTF_8);\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).isEmpty();\n  }\n}\n", "  public void loadFilesInDirectory_ignoresSubdirectories() throws IOException {\n    Files.writeString(\n        tempFolder.newFolder(\"subdirectory\").toPath().resolve(\"file\"),\n        \"content\",\n        StandardCharsets.UTF_8);\n\n    Collection<String> result = FileLoader.loadFilesInDirectory(tempFolderPath(), alwaysTrue());\n    assertThat(result).isEmpty();\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/EvaluateCqlTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.assertThrows;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.fhir.cql.beam.EvaluateCql.EvaluateCqlOptions;\nimport com.google.fhir.cql.beam.types.CqlEvaluationResult;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport java.io.File;\nimport java.io.IOException;", "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.time.ZoneOffset;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.apache.avro.file.DataFileReader;\nimport org.apache.avro.reflect.ReflectDatumReader;", "import org.apache.avro.file.DataFileReader;\nimport org.apache.avro.reflect.ReflectDatumReader;\nimport org.apache.beam.sdk.Pipeline;\nimport org.apache.beam.sdk.testing.TestPipeline;\nimport org.cqframework.cql.cql2elm.CqlTranslatorIncludeException;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;", "import org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {@link EvaluateCql}. */\n@RunWith(JUnit4.class)\npublic class EvaluateCqlTest {\n  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n  @Rule public TestPipeline testPipeline = TestPipeline.create();\n\n  private static final ResourceTypeAndId PATIENT_1_ID = new ResourceTypeAndId(\"Patient\", \"1\");\n  private static final ResourceTypeAndId PATIENT_2_ID = new ResourceTypeAndId(\"Patient\", \"2\");\n  private static final String PATIENT_1_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\"}\";\n  private static final String PATIENT_2_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"2\\\"}\";\n  private static final String PATIENT_1_CONDITION_RESOURCE_JSON = \"{\"\n      + \"  \\\"resourceType\\\": \\\"Condition\\\",\"\n      + \"  \\\"id\\\": \\\"c1\\\", \"\n      + \"  \\\"subject\\\": {\\\"reference\\\": \\\"Patient/1\\\"}, \"\n      + \"  \\\"code\\\": {\\\"coding\\\": [\"\n      + \"    {\\\"system\\\": \\\"http://example.com/foosystem\\\", \\\"code\\\": \\\"3\\\"}\"\n      + \"  ]}\"\n      + \"}\";\n\n  private static final ZonedDateTime EVALUATION_TIME =\n      ZonedDateTime.of(2022, 1, 7, 13, 14, 15, 0, ZoneOffset.UTC);\n\n  private Path ndjsonFolder;\n  private Path valueSetFolder;\n  private Path cqlFolder;\n  private Path resultsFolder;\n\n  @Before", "  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n  @Rule public TestPipeline testPipeline = TestPipeline.create();\n\n  private static final ResourceTypeAndId PATIENT_1_ID = new ResourceTypeAndId(\"Patient\", \"1\");\n  private static final ResourceTypeAndId PATIENT_2_ID = new ResourceTypeAndId(\"Patient\", \"2\");\n  private static final String PATIENT_1_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\"}\";\n  private static final String PATIENT_2_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"2\\\"}\";\n  private static final String PATIENT_1_CONDITION_RESOURCE_JSON = \"{\"\n      + \"  \\\"resourceType\\\": \\\"Condition\\\",\"\n      + \"  \\\"id\\\": \\\"c1\\\", \"\n      + \"  \\\"subject\\\": {\\\"reference\\\": \\\"Patient/1\\\"}, \"\n      + \"  \\\"code\\\": {\\\"coding\\\": [\"\n      + \"    {\\\"system\\\": \\\"http://example.com/foosystem\\\", \\\"code\\\": \\\"3\\\"}\"\n      + \"  ]}\"\n      + \"}\";\n\n  private static final ZonedDateTime EVALUATION_TIME =\n      ZonedDateTime.of(2022, 1, 7, 13, 14, 15, 0, ZoneOffset.UTC);\n\n  private Path ndjsonFolder;\n  private Path valueSetFolder;\n  private Path cqlFolder;\n  private Path resultsFolder;\n\n  @Before", "  public void setUp() throws IOException {\n    ndjsonFolder = tempFolder.newFolder(\"ndjson\").toPath();\n    valueSetFolder = tempFolder.newFolder(\"valuesets\").toPath();\n    cqlFolder = tempFolder.newFolder(\"cql\").toPath();\n    resultsFolder = tempFolder.newFolder().toPath();\n  }\n\n  private static VersionedIdentifier versionedIdentifier(String id, String version) {\n    VersionedIdentifier versionedIdentifier = new VersionedIdentifier();\n    versionedIdentifier.setId(id);\n    versionedIdentifier.setVersion(version);\n    return versionedIdentifier;\n  }\n\n  private static Collection<CqlEvaluationResult> readResults(File folder) throws IOException {\n    ReflectDatumReader<CqlEvaluationResult> reader =\n        new ReflectDatumReader<>(CqlEvaluationResult.ResultCoder.SCHEMA);\n\n    ArrayList<CqlEvaluationResult> results = new ArrayList<>();\n", "    for (File file : folder.listFiles()) {\n      try (DataFileReader<CqlEvaluationResult> fileReader =\n          new DataFileReader<CqlEvaluationResult>(file, reader)) {\n        fileReader.forEach(results::add);\n      }\n    }\n\n    return results;\n  }\n\n  private void writeLinesToFile(Path path, String... content) throws IOException {\n    Files.writeString(\n        path,\n        String.join(\"\\n\", content));\n  }\n\n  private Pipeline getTestPipeline(EvaluateCqlOptions options) {\n    return testPipeline;\n  }\n\n  @Test", "  public void assemblePipeline() throws IOException {\n    writeLinesToFile(ndjsonFolder.resolve(\"resources1.ndjson\"),\n        PATIENT_1_RESOURCE_JSON, PATIENT_2_RESOURCE_JSON);\n    writeLinesToFile(ndjsonFolder.resolve(\"resources2.ndjson\"), PATIENT_1_CONDITION_RESOURCE_JSON);\n    writeLinesToFile(valueSetFolder.resolve(\"valueset.json\"),\n        \"{\",\n        \"\\\"resourceType\\\": \\\"ValueSet\\\",\",\n        \"\\\"url\\\": \\\"http://example.com/foovalueset\\\",\",\n        \"\\\"expansion\\\": {\",\n        \"  \\\"contains\\\": [\",\n        \"    {\",\n        \"      \\\"system\\\": \\\"http://example.com/foosystem\\\",\",\n        \"      \\\"code\\\": \\\"3\\\"\",\n        \"    }\",\n        \"  ]\",\n        \"  }\",\n        \"}\");\n    writeLinesToFile(cqlFolder.resolve(\"foo.cql\"),\n        \"library FooLibrary version '0.1'\",\n        \"valueset \\\"FooSet\\\": 'http://example.com/foovalueset'\",\n        \"codesystem \\\"FooSystem\\\": 'http://example.com/foosystem'\",\n        \"code \\\"Code3\\\": '3' from \\\"FooSystem\\\"\",\n        \"using FHIR version '4.0.1'\",\n        \"context Patient\",\n        \"define \\\"Exp1\\\": Count([Condition: \\\"FooSet\\\"]) > 0\");\n\n    String[] args = new String[]{\n        \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n        \"--valueSetFolder=\" + valueSetFolder,\n        \"--cqlFolder=\" + cqlFolder,\n        \"--cqlLibraries=[{\\\"name\\\": \\\"FooLibrary\\\"}]\",\n        \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")};\n\n    EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME);\n\n    assertThat(readResults(resultsFolder.toFile()))\n        .containsExactly(\n            new CqlEvaluationResult(\n                versionedIdentifier(\"FooLibrary\", \"0.1\"),\n                PATIENT_1_ID,\n                EVALUATION_TIME,\n                ImmutableMap.of(\"Exp1\", true)),\n            new CqlEvaluationResult(\n                versionedIdentifier(\"FooLibrary\", \"0.1\"),\n                PATIENT_2_ID,\n                EVALUATION_TIME,\n                ImmutableMap.of(\"Exp1\", false)));\n  }\n\n  @Test", "  public void libraryNotFound() throws IOException {\n    String[] args = new String[]{\n        \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n        \"--valueSetFolder=\" + valueSetFolder,\n        \"--cqlFolder=\" + cqlFolder,\n        \"--cqlLibraries=[{\\\"name\\\": \\\"BarLibrary\\\"}]\",\n        \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")};\n\n    Exception e = assertThrows(CqlTranslatorIncludeException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"Could not load source\");\n\n    testPipeline.enableAbandonedNodeEnforcement(false);\n  }\n\n  @Test", "  public void libraryCompilationError() throws IOException {\n    writeLinesToFile(cqlFolder.resolve(\"foo.cql\"),\n        \"library FooLibrary version '0.1'\",\n        \"BAD CQL\");\n\n    String[] args = new String[]{\n        \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n        \"--valueSetFolder=\" + valueSetFolder,\n        \"--cqlFolder=\" + cqlFolder,\n        \"--cqlLibraries=[{\\\"name\\\": \\\"FooLibrary\\\"}]\",\n        \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(RuntimeException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"Syntax error\");\n\n    testPipeline.enableAbandonedNodeEnforcement(false);\n  }\n\n  @Test", "  public void cqlLibrariesFlagWithEmptyList() {\n    String[] args = new String[]{\n        \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n        \"--valueSetFolder=\" + valueSetFolder,\n        \"--cqlFolder=\" + cqlFolder,\n        \"--cqlLibraries=[]\",\n        \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"At least one CQL library must be specified.\");\n  }\n\n  @Test", "  public void cqlLibrariesFlagNotSpecified() {\n    String[] args = new String[]{\n      \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n      \"--valueSetFolder=\" + valueSetFolder,\n      \"--cqlFolder=\" + cqlFolder,\n      \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"--cqlLibraries\");\n  }\n\n  @Test", "  public void ndjsonFhirFilePatternFlagNotSpecified() {\n    String[] args = new String[]{\n      \"--valueSetFolder=\" + valueSetFolder,\n      \"--cqlFolder=\" + cqlFolder,\n      \"--cqlLibraries=[]\",\n      \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"--ndjsonFhirFilePattern\");\n  }\n\n  @Test", "  public void valueSetFolderFlagNotSpecified() {\n    String[] args = new String[]{\n      \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n      \"--cqlFolder=\" + cqlFolder,\n      \"--cqlLibraries=[]\",\n      \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"--valueSetFolder\");\n  }\n\n  @Test", "  public void cqlFolderFlagNotSpecified() {\n    String[] args = new String[]{\n      \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n      \"--valueSetFolder=\" + valueSetFolder,\n      \"--cqlLibraries=[]\",\n      \"--outputFilenamePrefix=\" + resultsFolder.resolve(\"output\")\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"--cqlFolder\");\n  }\n\n  @Test", "  public void outputFilenamePrefixFlagNotSpecified() {\n    String[] args = new String[]{\n      \"--ndjsonFhirFilePattern=\" + ndjsonFolder + \"/*\",\n      \"--valueSetFolder=\" + valueSetFolder,\n      \"--cqlFolder=\" + cqlFolder,\n      \"--cqlLibraries=[]\"\n    };\n\n    Exception e = assertThrows(IllegalArgumentException.class,\n        () -> EvaluateCql.runPipeline(this::getTestPipeline, args, EVALUATION_TIME));\n    assertThat(e).hasMessageThat().contains(\"--outputFilenamePrefix\");\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/KeyForContextFnTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\nimport static java.util.Collections.emptyMap;\nimport static org.junit.Assert.assertThrows;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport org.apache.beam.sdk.Pipeline.PipelineExecutionException;\nimport org.apache.beam.sdk.testing.PAssert;", "import org.apache.beam.sdk.Pipeline.PipelineExecutionException;\nimport org.apache.beam.sdk.testing.PAssert;\nimport org.apache.beam.sdk.testing.TestPipeline;\nimport org.apache.beam.sdk.transforms.Create;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.values.KV;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.hl7.elm_modelinfo.r1.ClassInfo;\nimport org.hl7.elm_modelinfo.r1.ModelInfo;\nimport org.hl7.elm_modelinfo.r1.RelationshipInfo;", "import org.hl7.elm_modelinfo.r1.ModelInfo;\nimport org.hl7.elm_modelinfo.r1.RelationshipInfo;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {@link KeyForContextFn}. */\n@RunWith(JUnit4.class)\npublic class KeyForContextFnTest {\n  @Rule public TestPipeline testPipeline = TestPipeline.create();\n\n  private PCollection<String> testPipelineWith(String... input) {\n    return testPipeline.apply(Create.of(ImmutableList.copyOf(input)));\n  }\n\n  @Test", "@RunWith(JUnit4.class)\npublic class KeyForContextFnTest {\n  @Rule public TestPipeline testPipeline = TestPipeline.create();\n\n  private PCollection<String> testPipelineWith(String... input) {\n    return testPipeline.apply(Create.of(ImmutableList.copyOf(input)));\n  }\n\n  @Test\n  public void keysResourceInContextWithOwnId() {\n    String resourceJson = \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\"}\";\n\n    PCollection<KV<ResourceTypeAndId, String>> output = testPipelineWith(resourceJson)\n        .apply(ParDo.of(new KeyForContextFn(\"Patient\", new ModelInfo())));\n\n    PAssert.thatSingleton(output)\n        .isEqualTo(KV.of(new ResourceTypeAndId(\"Patient\", \"1\"), resourceJson));\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n\n  @Test", "  public void keysResourceInContextWithOwnId() {\n    String resourceJson = \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\"}\";\n\n    PCollection<KV<ResourceTypeAndId, String>> output = testPipelineWith(resourceJson)\n        .apply(ParDo.of(new KeyForContextFn(\"Patient\", new ModelInfo())));\n\n    PAssert.thatSingleton(output)\n        .isEqualTo(KV.of(new ResourceTypeAndId(\"Patient\", \"1\"), resourceJson));\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n\n  @Test", "  public void doesNotKeyResourceOutOfContextWithOwnId() {\n    PCollection<KV<ResourceTypeAndId, String>> output =\n        testPipelineWith(\"{\\\"resourceType\\\": \\\"Encounter\\\", \\\"id\\\": \\\"1\\\"}\")\n            .apply(ParDo.of(new KeyForContextFn(\"Patient\", new ModelInfo())));\n\n    PAssert.thatMap(output).isEqualTo(emptyMap());\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void keysOnRelatedField() {\n    String resourceJson = \"{\"\n        + \"\\\"resourceType\\\":\\\"Encounter\\\",\"\n        + \"\\\"id\\\":\\\"1\\\",\"\n        + \"\\\"subject\\\":{\\\"reference\\\":\\\"Patient/2\\\"}\"\n        + \"}\";\n\n    PCollection<KV<ResourceTypeAndId, String>> output = testPipelineWith(resourceJson)\n        .apply(ParDo.of(new KeyForContextFn(\"Patient\", new ModelInfo())));\n\n    PAssert.thatSingleton(output)\n        .isEqualTo(KV.of(new ResourceTypeAndId(\"Patient\", \"2\"), resourceJson));\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void keysOnMultipleRelatedFields() {\n    String resourceJson = \"{\"\n        + \"\\\"resourceType\\\":\\\"AllergyIntolerance\\\",\"\n        + \"\\\"id\\\":\\\"1\\\",\"\n        + \"\\\"patient\\\":{\\\"reference\\\":\\\"Patient/2\\\"},\"\n        + \"\\\"asserter\\\":{\\\"reference\\\":\\\"Patient/3\\\"}\"\n        + \"}\";\n\n    PCollection<KV<ResourceTypeAndId, String>> output = testPipelineWith(resourceJson)\n        .apply(ParDo.of(new KeyForContextFn(\"Patient\",\n            new ModelInfo()\n                .withTypeInfo(new ClassInfo()\n                    .withName(\"AllergyIntolerance\")\n                    .withContextRelationship(new RelationshipInfo()\n                        .withContext(\"Patient\")\n                        .withRelatedKeyElement(\"asserter\"))))));\n\n    PAssert.thatMap(output).isEqualTo(ImmutableMap.of(\n        new ResourceTypeAndId(\"Patient\", \"2\"), resourceJson,\n        new ResourceTypeAndId(\"Patient\", \"3\"), resourceJson));\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void failsOnNonRelativeReferences() {\n    String resourceJson = \"{\"\n        + \"\\\"resourceType\\\":\\\"Encounter\\\",\"\n        + \"\\\"id\\\":\\\"1\\\",\"\n        + \"\\\"subject\\\":{\\\"reference\\\":\\\"http://example.com/fhir/Patient/2\\\"}\"\n        + \"}\";\n\n    PCollection<KV<ResourceTypeAndId, String>> output = testPipelineWith(resourceJson)\n        .apply(ParDo.of(new KeyForContextFn(\"Patient\", new ModelInfo())));\n\n    PAssert.thatSingleton(output)\n        .isEqualTo(KV.of(new ResourceTypeAndId(\"Patient\", \"2\"), resourceJson));\n\n    Exception thrown = assertThrows(\n        PipelineExecutionException.class,\n        () -> testPipeline.run().waitUntilFinish());\n    assertThat(thrown).hasCauseThat().isInstanceOf(IllegalArgumentException.class);\n    assertThat(thrown).hasMessageThat().contains(\"Unable to handle reference\");\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/EvaluateCqlForContextFnTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\n\nimport ca.uhn.fhir.context.FhirVersionEnum;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.fhir.cql.beam.types.CqlEvaluationResult;\nimport com.google.fhir.cql.beam.types.CqlLibraryId;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;", "import com.google.fhir.cql.beam.types.CqlLibraryId;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport java.io.IOException;\nimport java.time.ZoneOffset;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.apache.beam.sdk.testing.PAssert;\nimport org.apache.beam.sdk.testing.TestPipeline;\nimport org.apache.beam.sdk.transforms.Create;", "import org.apache.beam.sdk.testing.TestPipeline;\nimport org.apache.beam.sdk.transforms.Create;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.cqframework.cql.cql2elm.CqlCompiler;\nimport org.cqframework.cql.cql2elm.CqlTranslatorOptions.Options;\nimport org.cqframework.cql.cql2elm.LibraryManager;\nimport org.cqframework.cql.cql2elm.ModelManager;\nimport org.cqframework.cql.elm.execution.Library;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;", "import org.cqframework.cql.elm.execution.Library;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.opencds.cqf.cql.evaluator.engine.elm.LibraryMapper;\n\n/** Tests for {@link EvaluateCqlForContextFn}. */\n@RunWith(JUnit4.class)\npublic class EvaluateCqlForContextFnTest {", "/** Tests for {@link EvaluateCqlForContextFn}. */\n@RunWith(JUnit4.class)\npublic class EvaluateCqlForContextFnTest {\n  @Rule public TestPipeline testPipeline = TestPipeline.create();\n\n  private static final ResourceTypeAndId PATIENT_1_ID = new ResourceTypeAndId(\"Patient\", \"1\");\n  private static final ResourceTypeAndId PATIENT_2_ID = new ResourceTypeAndId(\"Patient\", \"2\");\n  private static final String PATIENT_1_AGE_21_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\", \\\"birthDate\\\": \\\"2000-01-01\\\"}\";\n  private static final String PATIENT_2_AGE_1_RESOURCE_JSON =\n      \"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"2\\\", \\\"birthDate\\\": \\\"2020-01-01\\\"}\";\n  private static final ZonedDateTime EVALUATION_TIME =\n      ZonedDateTime.of(2022, 1, 7, 13, 14, 15, 0, ZoneOffset.UTC);\n\n  private static CqlLibraryId cqlLibraryId(String name, String version) {\n    return new CqlLibraryId(name, version);\n  }\n\n  private static VersionedIdentifier versionedIdentifier(String id, String version) {\n    VersionedIdentifier versionedIdentifier = new VersionedIdentifier();\n    versionedIdentifier.setId(id);\n    versionedIdentifier.setVersion(version);\n    return versionedIdentifier;\n  }\n\n  private static Collection<Library> cqlToLibraries(String... cqlStrings) {\n    ModelManager modelManager = new ModelManager();\n    CqlCompiler compiler = new CqlCompiler(modelManager, new LibraryManager(modelManager));\n\n    Collection<Library> libraries = new ArrayList<>();", "    try {\n      for (String cql : cqlStrings) {\n        libraries.add(LibraryMapper.INSTANCE.map(compiler.run(\n            cql, Options.EnableResultTypes, Options.EnableLocators)));\n        assertThat(compiler.getExceptions()).isEmpty();\n      }\n      return libraries;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Test", "  public void libraryIdPopulated() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"Exp1\\\": true\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getLibraryId()).isEqualTo(new CqlLibraryId(\"FooLibrary\", \"0.1\"));\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void libraryVersionPopulatedWhenNotSpecified() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"Exp1\\\": true\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", null)),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getLibraryId().getVersion()).isEqualTo(\"0.1\");\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void contextPopulated() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"Exp1\\\": true\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getContexId()).isEqualTo(PATIENT_1_ID);\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void resultsPopulated() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"Exp1\\\": true\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).containsExactly(\"Exp1\", true);\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void nullResultsArePopulated() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(\"{\\\"resourceType\\\": \\\"Patient\\\", \\\"id\\\": \\\"1\\\"}\"));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"Exp1\\\": AgeInYears() < 15\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).containsExactly(\"Exp1\", null);\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void valueSetsAreLoaded() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"valueset \\\"FooSet\\\": 'http://example.com/foovalueset'\\n\"\n                    + \"codesystem \\\"FooSystem\\\": 'http://example.com/foosystem'\\n\"\n                    + \"code \\\"Code3\\\": '3' from \\\"FooSystem\\\"\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"Exp1\\\": \\\"Code3\\\" in \\\"FooSet\\\"\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(\"{\"\n                + \"\\\"resourceType\\\": \\\"ValueSet\\\",\"\n                + \"\\\"url\\\": \\\"http://example.com/foovalueset\\\",\"\n                + \"\\\"expansion\\\": {\"\n                + \"  \\\"contains\\\": [\"\n                + \"    {\"\n                + \"      \\\"system\\\": \\\"http://example.com/foosystem\\\",\"\n                + \"      \\\"code\\\": \\\"3\\\"\"\n                + \"    }\"\n                + \"  ]\"\n                + \"  }\"\n                + \"}\"),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).containsExactly(\"Exp1\", true);\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void missingValueSet() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"valueset \\\"FooSet\\\": 'http://example.com/foovalueset'\\n\"\n                    + \"codesystem \\\"FooSystem\\\": 'http://example.com/foosystem'\\n\"\n                    + \"code \\\"Code3\\\": '3' from \\\"FooSystem\\\"\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"Exp1\\\": \\\"Code3\\\" in \\\"FooSet\\\"\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getError()).contains(\"http://example.com/foovalueset\");\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void expressionsThatDontMatchContextAreSkipped() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Unfiltered\\n\"\n                    + \"define \\\"Exp1\\\": true\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).isEmpty();\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void expressionsThatDontReturnBooleansAreSkipped() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Unfiltered\\n\"\n                    + \"define \\\"Exp1\\\": 'foo'\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).isEmpty();\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void thrownExceptionsCapturedInResults() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"Exp1\\\": (Interval[3, 1].high > 5)\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getResults()).isNull();\n      assertThat(result.getError()).contains(\"Invalid Interval\");\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void contextSwitchingForbidden() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Unfiltered\\n\"\n                    + \"define \\\"Exp1\\\": true\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"Exp2\\\": \\\"Exp1\\\"\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.thatSingleton(output).satisfies(result -> {\n      assertThat(result.getError()).contains(\"Context switching is not supported.\");\n      return null;\n    });\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void multipleLibraries() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"Exp1\\\": true\",\n                \"library BarLibrary version '0.5'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"define \\\"ExpA\\\": false\"),\n            ImmutableSet.of(\n                cqlLibraryId(\"FooLibrary\", \"0.1\"),\n                cqlLibraryId(\"BarLibrary\", \"0.5\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.that(output).containsInAnyOrder(\n      new CqlEvaluationResult(\n          versionedIdentifier(\"FooLibrary\", \"0.1\"),\n          PATIENT_1_ID,\n          EVALUATION_TIME,\n          ImmutableMap.of(\"Exp1\", true)),\n      new CqlEvaluationResult(\n          versionedIdentifier(\"BarLibrary\", \"0.5\"),\n          PATIENT_1_ID,\n          EVALUATION_TIME,\n          ImmutableMap.of(\"ExpA\", false)));\n\n    testPipeline.run().waitUntilFinish();\n  }\n\n  @Test", "  public void multiplePatients() {\n    ImmutableMap<ResourceTypeAndId, Iterable<String>> input = ImmutableMap.of(\n        PATIENT_1_ID, ImmutableList.of(PATIENT_1_AGE_21_RESOURCE_JSON),\n        PATIENT_2_ID, ImmutableList.of(PATIENT_2_AGE_1_RESOURCE_JSON));\n\n    PCollection<CqlEvaluationResult> output = testPipeline.apply(Create.of(input))\n        .apply(ParDo.of(new EvaluateCqlForContextFn(\n            cqlToLibraries(\n                \"library FooLibrary version '0.1'\\n\"\n                    + \"using FHIR version '4.0.1'\\n\"\n                    + \"context Patient\\n\"\n                    + \"define \\\"YoungerThan18\\\": AgeInYears() < 18\"),\n            ImmutableSet.of(cqlLibraryId(\"FooLibrary\", \"0.1\")),\n            ImmutableList.of(),\n            EVALUATION_TIME,\n            FhirVersionEnum.R4)));\n\n    PAssert.that(output).containsInAnyOrder(\n      new CqlEvaluationResult(\n          versionedIdentifier(\"FooLibrary\", \"0.1\"),\n          PATIENT_1_ID,\n          EVALUATION_TIME,\n          ImmutableMap.of(\"YoungerThan18\", false)),\n      new CqlEvaluationResult(\n          versionedIdentifier(\"FooLibrary\", \"0.1\"),\n          PATIENT_2_ID,\n          EVALUATION_TIME,\n          ImmutableMap.of(\"YoungerThan18\", true)));\n\n    testPipeline.run().waitUntilFinish();\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/types/CqlEvaluationResultTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\nimport static java.util.Collections.emptyMap;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.testing.EqualsTester;\nimport java.time.ZoneOffset;\nimport java.time.ZonedDateTime;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Map;", "import java.time.temporal.ChronoUnit;\nimport java.util.Map;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Unit tests for {@link CqlEvaluationResult}. */\n@RunWith(JUnit4.class)\npublic class CqlEvaluationResultTest {\n  private static final ZonedDateTime EVALUATION_TIME_1 =\n      ZonedDateTime.of(2022, 1, 1, 1, 1, 1, 1, ZoneOffset.UTC);\n  private static final ZonedDateTime EVALUATION_TIME_2 =\n      ZonedDateTime.of(2022, 2, 2, 2, 2, 2, 2, ZoneOffset.UTC);\n\n  private static final ResourceTypeAndId PATIENT_1 = new ResourceTypeAndId(\"Patient\", \"1\");\n\n  private static final VersionedIdentifier libraryBar1 =\n      new VersionedIdentifier().withId(\"Bar\").withVersion(\"1\");\n  private static final VersionedIdentifier libraryBar2 =\n      new VersionedIdentifier().withId(\"Bar\").withVersion(\"2\");\n\n  @Test", "@RunWith(JUnit4.class)\npublic class CqlEvaluationResultTest {\n  private static final ZonedDateTime EVALUATION_TIME_1 =\n      ZonedDateTime.of(2022, 1, 1, 1, 1, 1, 1, ZoneOffset.UTC);\n  private static final ZonedDateTime EVALUATION_TIME_2 =\n      ZonedDateTime.of(2022, 2, 2, 2, 2, 2, 2, ZoneOffset.UTC);\n\n  private static final ResourceTypeAndId PATIENT_1 = new ResourceTypeAndId(\"Patient\", \"1\");\n\n  private static final VersionedIdentifier libraryBar1 =\n      new VersionedIdentifier().withId(\"Bar\").withVersion(\"1\");\n  private static final VersionedIdentifier libraryBar2 =\n      new VersionedIdentifier().withId(\"Bar\").withVersion(\"2\");\n\n  @Test", "  public void getLibraryId() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getLibraryId()).isEqualTo(new CqlLibraryId(libraryBar1));\n  }\n\n  @Test\n  public void getContextId() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getContexId()).isEqualTo(PATIENT_1);\n  }\n\n  @Test", "  public void getContextId() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getContexId()).isEqualTo(PATIENT_1);\n  }\n\n  @Test\n  public void getEvaluationTime_truncatesToMilliseconds() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getEvaluationTime())\n        .isEqualTo(EVALUATION_TIME_1.truncatedTo(ChronoUnit.MILLIS).toInstant());\n  }\n\n  @Test", "  public void getEvaluationTime_truncatesToMilliseconds() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getEvaluationTime())\n        .isEqualTo(EVALUATION_TIME_1.truncatedTo(ChronoUnit.MILLIS).toInstant());\n  }\n\n  @Test\n  public void getError() {\n    CqlEvaluationResult result = new CqlEvaluationResult(\n        libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"An exception\"));\n\n    assertThat(result.getError()).isEqualTo(\"An exception\");\n  }\n\n  @Test", "  public void getError() {\n    CqlEvaluationResult result = new CqlEvaluationResult(\n        libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"An exception\"));\n\n    assertThat(result.getError()).isEqualTo(\"An exception\");\n  }\n\n  @Test\n  public void getError_returnsNullWhenNoErrorExists() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getError()).isNull();\n  }\n\n\n  @Test", "  public void getError_returnsNullWhenNoErrorExists() {\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, emptyMap());\n\n    assertThat(result.getError()).isNull();\n  }\n\n\n  @Test\n  public void getResults_returnsNullWhenErrorExists() {\n    CqlEvaluationResult result = new CqlEvaluationResult(\n        libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"An exception\"));\n\n    assertThat(result.getResults()).isNull();\n  }\n\n  @Test", "  public void getResults_returnsNullWhenErrorExists() {\n    CqlEvaluationResult result = new CqlEvaluationResult(\n        libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"An exception\"));\n\n    assertThat(result.getResults()).isNull();\n  }\n\n  @Test\n  public void getResults() {\n    Map<String, Boolean> results = ImmutableMap.of(\"Foo\", true, \"Bar\", false);\n\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, results);\n\n    assertThat(result.getResults()).isEqualTo(results);\n  }\n\n  @Test", "  public void getResults() {\n    Map<String, Boolean> results = ImmutableMap.of(\"Foo\", true, \"Bar\", false);\n\n    CqlEvaluationResult result =\n        new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, results);\n\n    assertThat(result.getResults()).isEqualTo(results);\n  }\n\n  @Test\n  public void equals() {\n    new EqualsTester()\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of(\"Numerator\", false)),\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of(\"Numerator\", false)))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar2, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar2, PATIENT_1, EVALUATION_TIME_2, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Exception\")),\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Exception\")))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Other exception\")))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_2, new RuntimeException(\"Exception\")))\n      .testEquals();\n  }\n}\n", "  public void equals() {\n    new EqualsTester()\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of(\"Numerator\", false)),\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of(\"Numerator\", false)))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar1, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar2, PATIENT_1, EVALUATION_TIME_1, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(libraryBar2, PATIENT_1, EVALUATION_TIME_2, ImmutableMap.of()))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Exception\")),\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Exception\")))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_1, new RuntimeException(\"Other exception\")))\n      .addEqualityGroup(\n          new CqlEvaluationResult(\n              libraryBar1, PATIENT_1, EVALUATION_TIME_2, new RuntimeException(\"Exception\")))\n      .testEquals();\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/types/ResourceTypeAndIdTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.testing.EqualsTester;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Unit tests for {@link ResourceTypeAndId}. */\n@RunWith(JUnit4.class)\npublic class ResourceTypeAndIdTest {\n  @Test", "/** Unit tests for {@link ResourceTypeAndId}. */\n@RunWith(JUnit4.class)\npublic class ResourceTypeAndIdTest {\n  @Test\n  public void getType() {\n    assertThat(new ResourceTypeAndId(\"Patient\", \"1\").getType())\n        .isEqualTo(\"Patient\");\n  }\n\n  @Test\n  public void getId() {\n    assertThat(new ResourceTypeAndId(\"Patient\", \"1\").getId())\n        .isEqualTo(\"1\");\n  }\n\n  @Test", "  public void getId() {\n    assertThat(new ResourceTypeAndId(\"Patient\", \"1\").getId())\n        .isEqualTo(\"1\");\n  }\n\n  @Test\n  public void equals() {\n    new EqualsTester()\n      .addEqualityGroup(\n          new ResourceTypeAndId(\"Patient\", \"1\"),\n          new ResourceTypeAndId(\"Patient\", \"1\"))\n      .addEqualityGroup(new ResourceTypeAndId(\"Patient\", \"2\"))\n      .addEqualityGroup(new ResourceTypeAndId(\"Encounter\", \"1\"))\n      .testEquals();\n  }\n}\n"]}
{"filename": "src/test/java/com/google/fhir/cql/beam/types/CqlLibraryIdTest.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.truth.Truth.assertThat;", "\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.testing.EqualsTester;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Unit tests for {@link CqlLibraryId}. */", "\n/** Unit tests for {@link CqlLibraryId}. */\n@RunWith(JUnit4.class)\npublic class CqlLibraryIdTest {\n  @Test\n  public void getName() {\n    assertThat(new CqlLibraryId(\"Foo\", \"1\").getName())\n        .isEqualTo(\"Foo\");\n  }\n\n  @Test", "  public void getVersion() {\n    assertThat(new CqlLibraryId(\"Foo\", \"1\").getVersion())\n        .isEqualTo(\"1\");\n  }\n\n  @Test\n  public void equals() {\n    new EqualsTester()\n      .addEqualityGroup(\n          new CqlLibraryId(\"Foo\", \"1.0\"),\n          new CqlLibraryId(\"Foo\", \"1.0\"),\n          new CqlLibraryId(new VersionedIdentifier().withId(\"Foo\").withVersion(\"1.0\")))\n      .addEqualityGroup(\n          new CqlLibraryId(\"Bar\", null),\n          new CqlLibraryId(new VersionedIdentifier().withId(\"Bar\")))\n      .addEqualityGroup(new CqlLibraryId(\"Foo\", \"2.0\"))\n      .addEqualityGroup(new CqlLibraryId(\"Bar\", \"1.0\"))\n      .testEquals();\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/EvaluateCqlForContextFn.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.base.Preconditions.checkNotNull;", "\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.ImmutableList.toImmutableList;\nimport static com.google.common.collect.ImmutableSet.toImmutableSet;\n\nimport ca.uhn.fhir.context.FhirContext;\nimport ca.uhn.fhir.context.FhirVersionEnum;\nimport ca.uhn.fhir.parser.IParser;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.SerializationFeature;", "import com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.json.JsonMapper;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.fhir.cql.beam.types.CqlEvaluationResult;\nimport com.google.fhir.cql.beam.types.CqlLibraryId;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport java.io.IOException;\nimport java.io.InputStream;", "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.time.ZonedDateTime;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;", "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.values.KV;\nimport org.cqframework.cql.elm.execution.ExpressionDef;\nimport org.cqframework.cql.elm.execution.Library;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.hl7.fhir.r4.model.Bundle;", "import org.cqframework.cql.elm.execution.VersionedIdentifier;\nimport org.hl7.fhir.r4.model.Bundle;\nimport org.hl7.fhir.r4.model.Bundle.BundleType;\nimport org.hl7.fhir.r4.model.Resource;\nimport org.opencds.cqf.cql.engine.data.CompositeDataProvider;\nimport org.opencds.cqf.cql.engine.execution.Context;\nimport org.opencds.cqf.cql.engine.execution.InMemoryLibraryLoader;\nimport org.opencds.cqf.cql.engine.execution.LibraryLoader;\nimport org.opencds.cqf.cql.engine.fhir.model.R4FhirModelResolver;\nimport org.opencds.cqf.cql.engine.model.ModelResolver;", "import org.opencds.cqf.cql.engine.fhir.model.R4FhirModelResolver;\nimport org.opencds.cqf.cql.engine.model.ModelResolver;\nimport org.opencds.cqf.cql.engine.retrieve.RetrieveProvider;\nimport org.opencds.cqf.cql.engine.serializing.jackson.JsonCqlMapper;\nimport org.opencds.cqf.cql.engine.terminology.TerminologyProvider;\nimport org.opencds.cqf.cql.evaluator.engine.retrieve.BundleRetrieveProvider;\nimport org.opencds.cqf.cql.evaluator.engine.terminology.BundleTerminologyProvider;\n\n/**\n * A function that evaluates a set of CQL libraries over the collection of resources, represented as", "/**\n * A function that evaluates a set of CQL libraries over the collection of resources, represented as\n * JSON strings, for a given context. The collection of resources should include every resource\n * necessary for evaluation of the CQL within the context (e.g., the entire Patient bundle).\n *\n * <p>The follow constraints currently exist:\n *\n * <ul>\n *   <li>there is no support for accessing resources outside of the context (i.e., no support for\n *       cross-context and related context retrieves).", " *   <li>there is no support for accessing resources outside of the context (i.e., no support for\n *       cross-context and related context retrieves).\n *   <li>all resources for the context must fit within the memory of a worker.\n *   <li>only boolean expressions are written to the resulting {@link CqlEvaluationResult} objects.\n *   <li>there is no support for passing parameters to the CQL libraries.\n * </ul>\n */\npublic final class EvaluateCqlForContextFn\n    extends DoFn<KV<ResourceTypeAndId, Iterable<String>>, CqlEvaluationResult> {\n  /** A context that disallows evaluation of cross-context CQL expressions. */\n  private static class FixedContext extends Context {\n    public FixedContext(\n        Library library, ZonedDateTime evaluationZonedDateTime, ResourceTypeAndId contextValue) {\n      super(library, evaluationZonedDateTime);\n      super.setContextValue(contextValue.getType(), contextValue.getId());\n      super.enterContext(contextValue.getType());\n    }\n\n    @Override", "    public void enterContext(String context) {\n      if (!context.equals(getCurrentContext())) {\n        throw new IllegalStateException(\"Context switching is not supported.\");\n      }\n      super.enterContext(context);\n    }\n  }\n\n  /** A wrapper around {@link Library} that supports Java serialization. */\n  private static class SerializableLibraryWrapper implements Serializable {\n    private static JsonMapper jsonMapper =\n        JsonCqlMapper.getMapper()\n            .rebuild()\n            .disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET)\n            .disable(SerializationFeature.INDENT_OUTPUT)\n            .build();\n    private Library library;\n\n    public SerializableLibraryWrapper(Library library) {\n      this.library = library;\n    }\n", "    public Library getLibrary() {\n      return library;\n    }\n\n    private void readObject(ObjectInputStream inputStream) throws IOException {\n      library = jsonMapper.readValue((InputStream) inputStream, Library.class);\n    }\n\n    private void writeObject(ObjectOutputStream outputStream) throws IOException {\n      jsonMapper.writeValue((OutputStream) outputStream, library);\n    }\n  }\n\n  private final ImmutableList<SerializableLibraryWrapper> cqlSources;\n  private final ImmutableSet<CqlLibraryId> cqlLibraryIds;\n  private final ImmutableList<String> valueSetJsonResources;\n  private final ZonedDateTime evaluationDateTime;\n  private final FhirVersionEnum fhirVersion;\n\n  private transient ImmutableSet<VersionedIdentifier> cqlLibraryVersionedIdentifiers;\n  private transient FhirContext fhirContext;\n  private transient ModelResolver modelResolver;\n  private transient TerminologyProvider terminologyProvider;\n  private transient LibraryLoader libraryLoader;\n\n  public EvaluateCqlForContextFn(\n      Collection<Library> cqlSources,\n      Set<CqlLibraryId> cqlLibraryIds,\n      Collection<String> valueSetJsonResources,\n      ZonedDateTime evaluationDateTime,\n      FhirVersionEnum fhirVersion) {\n    this.cqlSources =\n        cqlSources.stream().map(SerializableLibraryWrapper::new).collect(toImmutableList());\n    this.cqlLibraryIds = ImmutableSet.copyOf(cqlLibraryIds);\n    this.valueSetJsonResources = ImmutableList.copyOf(valueSetJsonResources);\n    this.evaluationDateTime = checkNotNull(evaluationDateTime);\n    this.fhirVersion = checkNotNull(fhirVersion);\n  }\n\n  @DoFn.Setup", "  public void setup() {\n    cqlLibraryVersionedIdentifiers =\n        cqlLibraryIds.stream()\n            .map(id -> new VersionedIdentifier().withId(id.getName()).withVersion(id.getVersion()))\n            .collect(toImmutableSet());\n    fhirContext = new FhirContext(fhirVersion);\n    modelResolver = new CachingModelResolver(new R4FhirModelResolver());\n    terminologyProvider = createTerminologyProvider(fhirContext, valueSetJsonResources);\n    libraryLoader = new InMemoryLibraryLoader(\n        cqlSources.stream()\n            .map(SerializableLibraryWrapper::getLibrary)\n            .collect(Collectors.toList()));\n  }\n\n  @ProcessElement", "  public void processElement(\n      @Element KV<ResourceTypeAndId, Iterable<String>> contextResources,\n      OutputReceiver<CqlEvaluationResult> out) {\n    RetrieveProvider retrieveProvider = createRetrieveProvider(contextResources.getValue());\n    for (VersionedIdentifier cqlLibraryId : cqlLibraryVersionedIdentifiers) {\n      Library library = libraryLoader.load(cqlLibraryId);\n      Context context = createContext(library, retrieveProvider, contextResources.getKey());\n      try {\n        out.output(\n            new CqlEvaluationResult(\n                library.getIdentifier(),\n                contextResources.getKey(),\n                evaluationDateTime,\n                evaluate(library, context, contextResources.getKey())));\n      } catch (Exception e) {\n        out.output(\n            new CqlEvaluationResult(\n                library.getIdentifier(), contextResources.getKey(), evaluationDateTime, e));\n      }\n    }\n  }\n\n  private Map<String, Boolean> evaluate(\n      Library library, Context context, ResourceTypeAndId contextValue) {\n    HashMap<String, Boolean> results = new HashMap<>();", "    for (ExpressionDef expression : library.getStatements().getDef()) {\n      if (!expression.getContext().equals(contextValue.getType())\n          || !isBooleanExpression(expression)) {\n        continue;\n      }\n      if (results.putIfAbsent(expression.getName(), (Boolean) expression.evaluate(context))\n          != null) {\n        throw new InternalError(\"Duplicate expression name: \" + expression.getName());\n      }\n    }\n    return results;\n  }\n\n  private static boolean isBooleanExpression(ExpressionDef expression) {\n    return expression.getResultTypeName() != null\n        && expression.getResultTypeName().getNamespaceURI().equals(\"urn:hl7-org:elm-types:r1\")\n        && expression.getResultTypeName().getLocalPart().equals(\"Boolean\");\n  }\n\n  private Context createContext(\n      Library library, RetrieveProvider retrieveProvider, ResourceTypeAndId contextValue) {\n    Context context = new FixedContext(library, evaluationDateTime, contextValue);\n    context.setExpressionCaching(true);\n    context.registerLibraryLoader(libraryLoader);\n    context.registerTerminologyProvider(terminologyProvider);\n    context.registerDataProvider(\n        \"http://hl7.org/fhir\", new CompositeDataProvider(modelResolver, retrieveProvider));\n    // TODO(nasha): Set user defined parameters via `context.setParameter`.\n    return context;\n  }\n\n  private static TerminologyProvider createTerminologyProvider(\n      FhirContext fhirContext, ImmutableList<String> valueSetJsonStrings) {\n    IParser parser = fhirContext.newJsonParser();\n    Bundle bundle = new Bundle();\n    bundle.setType(BundleType.COLLECTION);\n    valueSetJsonStrings.stream()\n        .map(parser::parseResource)\n        .forEach((resource) -> bundle.addEntry().setResource((Resource) resource));\n    return new BundleTerminologyProvider(fhirContext, bundle);\n  }\n\n  private RetrieveProvider createRetrieveProvider(Iterable<String> jsonResource) {\n    Bundle bundle = new Bundle();\n    bundle.setType(BundleType.COLLECTION);\n    IParser parser = fhirContext.newJsonParser();\n    jsonResource.forEach(\n        element -> {\n          bundle.addEntry().setResource((Resource) parser.parseResource(element));\n        });\n    BundleRetrieveProvider provider = new BundleRetrieveProvider(fhirContext, bundle);\n    provider.setTerminologyProvider(terminologyProvider);\n    provider.setExpandValueSets(true);\n    return provider;\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/ForwardingModelResolver.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport org.opencds.cqf.cql.engine.model.ModelResolver;", "\nimport org.opencds.cqf.cql.engine.model.ModelResolver;\n\n/** A {@link ModelResolver} that forwards calls to the provided {@code ModelResolver}. */\npublic abstract class ForwardingModelResolver implements ModelResolver {\n  private final ModelResolver resolver;\n\n  public ForwardingModelResolver(ModelResolver resolver) {\n    this.resolver = resolver;\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Override", "  public String getPackageName() {\n    return resolver.getPackageName();\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Override\n  public void setPackageName(String packageName) {\n    resolver.setPackageName(packageName);\n  }\n\n  @Override", "  public Object resolvePath(Object target, String path) {\n    return resolver.resolvePath(target, path);\n  }\n\n  @Override\n  public Object getContextPath(String contextType, String targetType) {\n    return resolver.getContextPath(contextType, targetType);\n  }\n\n  @Override\n  public Class<?> resolveType(String typeName) {\n    return resolver.resolveType(typeName);\n  }\n\n  @Override\n  public Class<?> resolveType(Object value) {\n    return resolver.resolveType(value);\n  }\n\n  @Override", "  public Boolean is(Object value, Class<?> type) {\n    return resolver.is(value, type);\n  }\n\n  @Override\n  public Object as(Object value, Class<?> type, boolean isStrict) {\n    return resolver.as(value, type, isStrict);\n  }\n\n  @Override\n  public Object createInstance(String typeName) {\n    return resolver.createInstance(typeName);\n  }\n\n  @Override", "  public Object createInstance(String typeName) {\n    return resolver.createInstance(typeName);\n  }\n\n  @Override\n  public void setValue(Object target, String path, Object value) {\n    resolver.setValue(target, path, value);\n  }\n\n  @Override\n  public Boolean objectEqual(Object left, Object right) {\n    return resolver.objectEqual(left, right);\n  }\n\n  @Override", "  public Boolean objectEqual(Object left, Object right) {\n    return resolver.objectEqual(left, right);\n  }\n\n  @Override\n  public Boolean objectEquivalent(Object left, Object right) {\n    return resolver.objectEquivalent(left, right);\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/FileLoader.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport com.google.common.collect.ImmutableList;", "\nimport com.google.common.collect.ImmutableList;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/** Static utilities for loading file contents into a {@code List<String>}. */", "\n/** Static utilities for loading file contents into a {@code List<String>}. */\nfinal class FileLoader {\n  private FileLoader() {}\n\n  /**\n   * Returns a list with an entry, containing the file's content, for each file in the specified\n   * directory. Content is read as a UTF-8 string. Files in subdirectories are not considered.\n   *\n   * @param directory a path to a directory that contains the files to load", "   *\n   * @param directory a path to a directory that contains the files to load\n   * @param pathFilter a filter that controls which files are read into the returned list\n   * @throws IOException when an error is encountered listing or reading files in the directory\n   */\n  public static ImmutableList<String> loadFilesInDirectory(\n      Path directory, Predicate<Path> pathFilter) throws IOException {\n    ImmutableList.Builder<String> result = ImmutableList.builder();\n    try (Stream<Path> paths =\n        Files.list(directory).filter(Files::isRegularFile).filter(pathFilter)) {\n      for (Path path : (Iterable<Path>) paths::iterator) {\n        result.add(Files.readString(path, StandardCharsets.UTF_8));\n      }\n    }\n    return result.build();\n  }\n}\n", "      for (Path path : (Iterable<Path>) paths::iterator) {\n        result.add(Files.readString(path, StandardCharsets.UTF_8));\n      }\n    }\n    return result.build();\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/CachingModelResolver.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport java.util.concurrent.ConcurrentHashMap;", "\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.opencds.cqf.cql.engine.model.ModelResolver;\n\n/**\n * A {@link ModelResolver} that caches the results of calls to {@link ModelResolver#resolveType}.\n */\npublic class CachingModelResolver extends ForwardingModelResolver {\n  private final ConcurrentHashMap<String, Class<?>> typeCache = new ConcurrentHashMap<>();\n  private final ConcurrentHashMap<Class<?>, Class<?>> objectTypeCache = new ConcurrentHashMap<>();\n\n  public CachingModelResolver(ModelResolver resolver) {\n    super(resolver);\n  }\n\n  @Override\n  public Class<?> resolveType(String typeName) {\n    return typeCache.computeIfAbsent(typeName, super::resolveType);\n  }\n\n  @Override\n  public Class<?> resolveType(Object value) {\n    return objectTypeCache.computeIfAbsent(\n        value.getClass(),\n        (key) -> {\n          return super.resolveType(value);\n        });\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/EvaluateCql.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.base.Preconditions.checkArgument;", "\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.collect.ImmutableList.toImmutableList;\n\nimport ca.uhn.fhir.context.FhirVersionEnum;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;", "import com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.fhir.cql.beam.types.CqlEvaluationResult;\nimport com.google.fhir.cql.beam.types.CqlLibraryId;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.file.Path;", "import java.net.URISyntaxException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport org.apache.beam.sdk.Pipeline;", "import java.util.function.Predicate;\nimport org.apache.beam.sdk.Pipeline;\nimport org.apache.beam.sdk.extensions.avro.io.AvroIO;\nimport org.apache.beam.sdk.io.TextIO;\nimport org.apache.beam.sdk.options.Description;\nimport org.apache.beam.sdk.options.PipelineOptions;\nimport org.apache.beam.sdk.options.PipelineOptionsFactory;\nimport org.apache.beam.sdk.options.Validation.Required;\nimport org.apache.beam.sdk.transforms.GroupByKey;\nimport org.apache.beam.sdk.transforms.ParDo;", "import org.apache.beam.sdk.transforms.GroupByKey;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.cqframework.cql.cql2elm.CqlCompilerException;\nimport org.cqframework.cql.cql2elm.CqlCompilerException.ErrorSeverity;\nimport org.cqframework.cql.cql2elm.CqlTranslatorOptions;\nimport org.cqframework.cql.cql2elm.CqlTranslatorOptions.Options;\nimport org.cqframework.cql.cql2elm.LibraryManager;\nimport org.cqframework.cql.cql2elm.ModelManager;\nimport org.cqframework.cql.cql2elm.model.CompiledLibrary;\nimport org.cqframework.cql.elm.execution.Library;", "import org.cqframework.cql.cql2elm.model.CompiledLibrary;\nimport org.cqframework.cql.elm.execution.Library;\nimport org.opencds.cqf.cql.evaluator.cql2elm.content.InMemoryLibrarySourceProvider;\nimport org.opencds.cqf.cql.evaluator.engine.elm.LibraryMapper;\n\n/**\n * Main entry point for evaluating CQL libraries over a set of FHIR records with Apache Beam.\n *\n * <p>See README.md for additional information.\n */\npublic final class EvaluateCql {\n  /**\n   * Options supported by {@link EvaluateCql}.\n   */", " * <p>See README.md for additional information.\n */\npublic final class EvaluateCql {\n  /**\n   * Options supported by {@link EvaluateCql}.\n   */\n  public interface EvaluateCqlOptions extends PipelineOptions {\n    @Description(\n        \"The file pattern of the NDJSON FHIR files to read. Follows the conventions of \"\n            + \"https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob.\")\n    @Required\n    String getNdjsonFhirFilePattern();\n\n    void setNdjsonFhirFilePattern(String value);\n\n    @Description(\n        \"Path to a folder that contains ValueSet FHIR records. Each file must contain exactly one \"\n            + \"ValueSet FHIR record. Subfolders and their content are ignored.\")\n    @Required\n    String getValueSetFolder();\n\n    void setValueSetFolder(String value);\n\n    @Description(\n        \"Path to a folder that contains CQL libraries. Subfolders and their content are ignored.\")\n    @Required\n    String getCqlFolder();\n\n    void setCqlFolder(String value);\n\n    @Description(\n        \"A list of CQL library IDs and, optionally, versions that will be evaluated \"\n            + \"against the provided FHIR. Format: \"\n            + \"[{\\\"name\\\": \\\"ColorectalCancerScreeningsFHIR\\\"}, \"\n            + \"{\\\"name\\\": \\\"ControllingHighBloodPressureFHIR\\\" \\\"version\\\": \\\"0.0.002\\\"}]\")\n    @Required\n    @JsonSerialize\n    @JsonDeserialize\n    List<CqlLibraryId> getCqlLibraries();\n\n    void setCqlLibraries(List<CqlLibraryId> value);\n\n    @Description(\"Path and name prefix of the file shards that will contain the pipeline output.\")\n    @Required\n    String getOutputFilenamePrefix();\n\n    void setOutputFilenamePrefix(String value);\n  }\n\n  private static ImmutableList<String> loadFilesInDirectory(\n      Path directory, Predicate<Path> pathFilter) {", "    try {\n      return FileLoader.loadFilesInDirectory(directory, pathFilter);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Failed to read files in \" + directory, e);\n    }\n  }\n\n  private static Path toPath(String directory) {\n    try {\n      URI directoryUri = new URI(directory);\n      if (new URI(directory).getScheme() != null) {\n        return Paths.get(directoryUri);\n      }\n    } catch (URISyntaxException e) {\n      // Fall through and treat as a file:// directory.\n    }\n\n    return new File(directory).toPath();\n  }\n\n  private static final Options[] TRANSLATOR_OPTIONS = {\n    Options.DisableListPromotion,\n    Options.DisableListDemotion,\n    Options.EnableResultTypes,\n    Options.EnableLocators\n  };\n\n  private static ImmutableList<Library> loadLibraries(\n      Path cqlFolder, Collection<CqlLibraryId> cqlLibraryIds) {\n    LibraryManager libraryManager = new LibraryManager(new ModelManager());\n    libraryManager\n        .getLibrarySourceLoader()\n        .registerProvider(\n            new InMemoryLibrarySourceProvider(\n                loadFilesInDirectory(cqlFolder, (path) -> path.toString().endsWith(\".cql\"))));\n    libraryManager.enableCache();\n", "    try {\n      URI directoryUri = new URI(directory);\n      if (new URI(directory).getScheme() != null) {\n        return Paths.get(directoryUri);\n      }\n    } catch (URISyntaxException e) {\n      // Fall through and treat as a file:// directory.\n    }\n\n    return new File(directory).toPath();\n  }\n\n  private static final Options[] TRANSLATOR_OPTIONS = {\n    Options.DisableListPromotion,\n    Options.DisableListDemotion,\n    Options.EnableResultTypes,\n    Options.EnableLocators\n  };\n\n  private static ImmutableList<Library> loadLibraries(\n      Path cqlFolder, Collection<CqlLibraryId> cqlLibraryIds) {\n    LibraryManager libraryManager = new LibraryManager(new ModelManager());\n    libraryManager\n        .getLibrarySourceLoader()\n        .registerProvider(\n            new InMemoryLibrarySourceProvider(\n                loadFilesInDirectory(cqlFolder, (path) -> path.toString().endsWith(\".cql\"))));\n    libraryManager.enableCache();\n", "    for (CqlLibraryId libraryIds : cqlLibraryIds) {\n      List<CqlCompilerException> errors = new ArrayList<>();\n      libraryManager.resolveLibrary(\n          new org.hl7.elm.r1.VersionedIdentifier()\n              .withId(libraryIds.getName())\n              .withVersion(libraryIds.getVersion()),\n          new CqlTranslatorOptions(TRANSLATOR_OPTIONS),\n          errors);\n      if (errors.stream().filter(error -> error.getSeverity().equals(ErrorSeverity.Error)).count()\n          > 0) {\n        throw new RuntimeException(\n            \"Errors encountered while compiling CQL. \" + errors.toString());\n      }\n    }\n\n    return libraryManager.getCompiledLibraries().values().stream()\n        .map(CompiledLibrary::getLibrary)\n        .map(LibraryMapper.INSTANCE::map)\n        .collect(toImmutableList());\n  }\n\n  private static void assemblePipeline(\n      Pipeline pipeline, EvaluateCqlOptions options, ZonedDateTime evaluationDateTime) {\n    checkArgument(\n        !options.getCqlLibraries().isEmpty(), \"At least one CQL library must be specified.\");\n\n    pipeline\n        .apply(\"ReadNDJSON\", TextIO.read().from(options.getNdjsonFhirFilePattern()))\n        .apply(\"KeyForContext\", ParDo.of(new KeyForContextFn(\n            \"Patient\", new ModelManager().resolveModel(\"FHIR\", \"4.0.1\").getModelInfo())))\n        .apply(\"GroupByContext\", GroupByKey.<ResourceTypeAndId, String>create())\n        .apply(\n            \"EvaluateCql\",\n            ParDo.of(\n                new EvaluateCqlForContextFn(\n                    loadLibraries(toPath(options.getCqlFolder()), options.getCqlLibraries()),\n                    ImmutableSet.copyOf(options.getCqlLibraries()),\n                    loadFilesInDirectory(\n                        toPath(options.getValueSetFolder()),\n                        (path) -> path.toString().endsWith(\".json\")),\n                    evaluationDateTime,\n                    FhirVersionEnum.R4)))\n        .apply(\n            \"WriteCqlOutput\",\n            AvroIO.write(CqlEvaluationResult.class)\n                .withSchema(CqlEvaluationResult.ResultCoder.SCHEMA)\n                .to(options.getOutputFilenamePrefix())\n                .withSuffix(\".avro\"));\n  }\n\n  @VisibleForTesting\n  static void runPipeline(\n      Function<EvaluateCqlOptions, Pipeline> pipelineCreator,\n      String[] args,\n      ZonedDateTime evaluationDateTime) {\n    EvaluateCqlOptions options =\n        PipelineOptionsFactory.fromArgs(args).withValidation().as(EvaluateCqlOptions.class);\n    Pipeline pipeline = pipelineCreator.apply(options);\n    assemblePipeline(pipeline, options, evaluationDateTime);\n    pipeline.run().waitUntilFinish();\n  }\n", "      if (errors.stream().filter(error -> error.getSeverity().equals(ErrorSeverity.Error)).count()\n          > 0) {\n        throw new RuntimeException(\n            \"Errors encountered while compiling CQL. \" + errors.toString());\n      }\n    }\n\n    return libraryManager.getCompiledLibraries().values().stream()\n        .map(CompiledLibrary::getLibrary)\n        .map(LibraryMapper.INSTANCE::map)\n        .collect(toImmutableList());\n  }\n\n  private static void assemblePipeline(\n      Pipeline pipeline, EvaluateCqlOptions options, ZonedDateTime evaluationDateTime) {\n    checkArgument(\n        !options.getCqlLibraries().isEmpty(), \"At least one CQL library must be specified.\");\n\n    pipeline\n        .apply(\"ReadNDJSON\", TextIO.read().from(options.getNdjsonFhirFilePattern()))\n        .apply(\"KeyForContext\", ParDo.of(new KeyForContextFn(\n            \"Patient\", new ModelManager().resolveModel(\"FHIR\", \"4.0.1\").getModelInfo())))\n        .apply(\"GroupByContext\", GroupByKey.<ResourceTypeAndId, String>create())\n        .apply(\n            \"EvaluateCql\",\n            ParDo.of(\n                new EvaluateCqlForContextFn(\n                    loadLibraries(toPath(options.getCqlFolder()), options.getCqlLibraries()),\n                    ImmutableSet.copyOf(options.getCqlLibraries()),\n                    loadFilesInDirectory(\n                        toPath(options.getValueSetFolder()),\n                        (path) -> path.toString().endsWith(\".json\")),\n                    evaluationDateTime,\n                    FhirVersionEnum.R4)))\n        .apply(\n            \"WriteCqlOutput\",\n            AvroIO.write(CqlEvaluationResult.class)\n                .withSchema(CqlEvaluationResult.ResultCoder.SCHEMA)\n                .to(options.getOutputFilenamePrefix())\n                .withSuffix(\".avro\"));\n  }\n\n  @VisibleForTesting\n  static void runPipeline(\n      Function<EvaluateCqlOptions, Pipeline> pipelineCreator,\n      String[] args,\n      ZonedDateTime evaluationDateTime) {\n    EvaluateCqlOptions options =\n        PipelineOptionsFactory.fromArgs(args).withValidation().as(EvaluateCqlOptions.class);\n    Pipeline pipeline = pipelineCreator.apply(options);\n    assemblePipeline(pipeline, options, evaluationDateTime);\n    pipeline.run().waitUntilFinish();\n  }\n", "  public static void main(String[] args) {\n    runPipeline(Pipeline::create, args, ZonedDateTime.now());\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/KeyForContextFn.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam;\n\nimport static com.google.common.base.Preconditions.checkNotNull;", "\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.ImmutableSetMultimap.flatteningToImmutableSetMultimap;\n\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.fhir.cql.beam.types.ResourceTypeAndId;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport java.util.HashSet;", "import com.google.gson.JsonParser;\nimport java.util.HashSet;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.values.KV;\nimport org.hl7.elm_modelinfo.r1.ClassInfo;\nimport org.hl7.elm_modelinfo.r1.ModelInfo;", "import org.hl7.elm_modelinfo.r1.ClassInfo;\nimport org.hl7.elm_modelinfo.r1.ModelInfo;\nimport org.hl7.elm_modelinfo.r1.RelationshipInfo;\n\n/**\n * Function that keys FHIR resources represented in JSON by their CQL context (e.g., \"Patient\").\n *\n * <p>All references within the resources being processed must be relative (i.e., \"Patient/123\").\n *\n * @see https://cql.hl7.org/02-authorsguide.html#context", " *\n * @see https://cql.hl7.org/02-authorsguide.html#context\n */\npublic final class KeyForContextFn extends DoFn<String, KV<ResourceTypeAndId, String>> {\n  private static final Pattern REFERENCE_PATTERN = Pattern.compile(\"([^/]+)/([^/]+)\");\n  private static final String REFERENCE_FIELD_NAME = \"reference\";\n  private static final String SUBJECT_FIELD_NAME = \"subject\";\n  private static final String PATIENT_FIELD_NAME = \"patient\";\n\n  private final String context;\n  private final ImmutableSetMultimap<String, String> relatedKeyElementByType;\n\n  public KeyForContextFn(String context, ModelInfo modelInfo) {\n    this.context = checkNotNull(context);\n    this.relatedKeyElementByType = createRelatedKeyElementByTypeMap(context, modelInfo);\n  }\n\n  /**\n   * Returns a map from resource type to related key fields for the provided context.\n   */\n  private static ImmutableSetMultimap<String, String> createRelatedKeyElementByTypeMap(\n      String context, ModelInfo modelInfo) {\n    return modelInfo.getTypeInfo().stream()\n        .filter(typeInfo -> typeInfo instanceof ClassInfo)\n        .map(typeInfo -> (ClassInfo) typeInfo)\n        .collect(\n            flatteningToImmutableSetMultimap(\n                ClassInfo::getName,\n                classInfo -> classInfo.getContextRelationship().stream()\n                    .filter(relationship -> relationship.getContext().equals(context))\n                    .map(RelationshipInfo::getRelatedKeyElement)));\n  }\n\n  @ProcessElement", "  public void processElement(\n      @Element String element, OutputReceiver<KV<ResourceTypeAndId, String>> out) {\n    JsonObject resourceObject = JsonParser.parseString(element).getAsJsonObject();\n    String resourceType = resourceObject.get(\"resourceType\").getAsString();\n\n    if (resourceType.equals(context)) {\n      out.output(\n          KV.of(\n              new ResourceTypeAndId(\n                  resourceObject.get(\"resourceType\").getAsString(),\n                  resourceObject.get(\"id\").getAsString()),\n              element));\n    }\n\n    relatedKeyElements(resourceType).stream()\n        .map(fieldName -> asResourceTypeAndId(resourceObject, fieldName))\n        .filter(Optional::isPresent)\n        .map(Optional::get)\n        .filter(typeAndId -> typeAndId.getType().equals(context))\n        .forEach(typeAndId -> out.output(KV.of(typeAndId, element)));\n  }\n\n  private Set<String> relatedKeyElements(String resourceType) {\n    Set<String> relatedKeyElements = new HashSet<>(relatedKeyElementByType.get(resourceType));\n\n    // TODO(nasha): Remove this when ModelInfo contains a complete list of related key elements.\n    // As is, it misses some resources so we make up for that by checking for the presence of\n    // \"subject\" and \"patient\", two well know context fields.\n    relatedKeyElements.add(SUBJECT_FIELD_NAME);\n    relatedKeyElements.add(PATIENT_FIELD_NAME);\n\n    return relatedKeyElements;\n  }\n\n  /**\n   * Returns the resource type and ID of the FHIR reference located at {@code referenceFieldName}.\n   */\n  private Optional<ResourceTypeAndId> asResourceTypeAndId(\n      JsonObject resourceObject, String referenceFieldName) {", "    if (!resourceObject.has(referenceFieldName)) {\n      return Optional.empty();\n    }\n    JsonElement referenceElement = resourceObject.get(referenceFieldName);\n    if (!referenceElement.isJsonObject()) {\n      // TODO(nasha): Support repeated fields (i.e. JsonArray).\n      return Optional.empty();\n    }\n    JsonObject referenceObject = referenceElement.getAsJsonObject();\n    if (!referenceObject.has(REFERENCE_FIELD_NAME)) {\n      return Optional.empty();\n    }\n    return Optional.of(extractReference(referenceObject.get(REFERENCE_FIELD_NAME).getAsString()));\n  }\n\n  /**\n   * @param referenceString a reference string in the format of \"Type/ID\" (e.g., \"Patient/123\")\n   */\n  private ResourceTypeAndId extractReference(String referenceString) {\n    Matcher matcher = REFERENCE_PATTERN.matcher(referenceString);", "    if (!referenceObject.has(REFERENCE_FIELD_NAME)) {\n      return Optional.empty();\n    }\n    return Optional.of(extractReference(referenceObject.get(REFERENCE_FIELD_NAME).getAsString()));\n  }\n\n  /**\n   * @param referenceString a reference string in the format of \"Type/ID\" (e.g., \"Patient/123\")\n   */\n  private ResourceTypeAndId extractReference(String referenceString) {\n    Matcher matcher = REFERENCE_PATTERN.matcher(referenceString);", "    if (!matcher.matches()) {\n      throw new IllegalArgumentException(\n          \"Unable to handle reference. Only relative references in the format of \\\"Type/ID\\\" are\"\n              + \" supported.\");\n    }\n    String referenceResourceType = matcher.group(1);\n    String referenceResourceId = matcher.group(2);\n    return new ResourceTypeAndId(referenceResourceType, referenceResourceId);\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/types/CqlEvaluationResult.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.base.Preconditions.checkNotNull;", "\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static org.apache.avro.LogicalTypes.timestampMillis;\nimport static org.apache.avro.SchemaBuilder.builder;\nimport static org.apache.avro.SchemaBuilder.unionOf;\n\nimport autovalue.shaded.org.jetbrains.annotations.Nullable;\nimport com.google.common.base.MoreObjects;\nimport java.time.Instant;\nimport java.time.ZonedDateTime;", "import java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport org.apache.avro.Schema;\nimport org.apache.beam.sdk.coders.CannotProvideCoderException;\nimport org.apache.beam.sdk.coders.Coder;", "import org.apache.beam.sdk.coders.CannotProvideCoderException;\nimport org.apache.beam.sdk.coders.Coder;\nimport org.apache.beam.sdk.coders.CoderProvider;\nimport org.apache.beam.sdk.coders.DefaultCoder;\nimport org.apache.beam.sdk.extensions.avro.coders.AvroCoder;\nimport org.apache.beam.sdk.values.TypeDescriptor;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\n\n/**\n * A container that holds the results of evaluating a specific CQL library in a specific context.", "/**\n * A container that holds the results of evaluating a specific CQL library in a specific context.\n */\n@DefaultCoder(CqlEvaluationResult.ResultCoder.class)\npublic final class CqlEvaluationResult {\n  /**\n   * A custom {@link AvroCoder} for {@link CqlEvaluationResult} objects.\n   *\n   * <p>This coder uses a custom Avro schema rather than the one generated via reflection due to the\n   * results map need to support nullable values, which is not possible when using Avro's reflection\n   * based schema generation.\n   */", "  public static class ResultCoder extends AvroCoder<CqlEvaluationResult> {\n    public ResultCoder() {\n      super(CqlEvaluationResult.class, SCHEMA, true);\n    }\n\n    /** The schema for {@link CqlEvaluationResult}. */\n    public static Schema SCHEMA = builder(CqlEvaluationResult.class.getPackageName())\n        .record(CqlEvaluationResult.class.getSimpleName()).fields()\n            .name(\"contextId\").type(schemaFor(ResourceTypeAndId.class)).noDefault()\n            .name(\"libraryId\").type(schemaFor(CqlLibraryId.class)).noDefault()\n            .name(\"evaluationTime\")\n                .type(timestampMillis().addToSchema(builder().longType()))\n                .noDefault()\n            .name(\"error\").type(unionOf().nullType().and().stringType().endUnion()).noDefault()\n            .name(\"results\")\n                .type(unionOf()\n                    .nullType().and()\n                    .map().values().unionOf().nullType().and().booleanType().endUnion()\n                    .endUnion())\n                .noDefault()\n        .endRecord();\n\n    private static Schema schemaFor(Class<?> clazz) {\n      return builder(clazz.getPackageName()).type(AvroCoder.of(clazz).getSchema());\n    }\n\n    @SuppressWarnings(\"unchecked\")", "    public static CoderProvider getCoderProvider() {\n      return new CoderProvider() {\n        @Override\n        public <T> Coder<T> coderFor(\n            TypeDescriptor<T> typeDescriptor, List<? extends Coder<?>> componentCoders)\n            throws CannotProvideCoderException {\n          if (typeDescriptor.getRawType() != CqlEvaluationResult.class) {\n            throw new CannotProvideCoderException(typeDescriptor + \" is not supported\");\n          }\n          return (Coder<T>) new ResultCoder();\n        }\n      };\n    }\n  }\n\n  private CqlLibraryId libraryId;\n  private ResourceTypeAndId contextId;\n  private long evaluationTime;\n  @Nullable private String error;\n  @Nullable private Map<String, Boolean> results;\n\n  // Required for AvroCoder.\n  public CqlEvaluationResult() {}\n\n  public CqlEvaluationResult(\n      VersionedIdentifier cqlLibraryIdentifier,\n      ResourceTypeAndId contextId,\n      ZonedDateTime evaluationDateTime,\n      Map<String, Boolean> results) {\n    this.libraryId = new CqlLibraryId(cqlLibraryIdentifier);\n    this.contextId = checkNotNull(contextId);\n    this.evaluationTime = evaluationDateTime.toInstant().toEpochMilli();\n    this.results = Collections.unmodifiableMap(new HashMap<>(results));\n  }\n\n  public CqlEvaluationResult(\n      VersionedIdentifier cqlLibraryIdentifier,\n      ResourceTypeAndId contextId,\n      ZonedDateTime evaluationDateTime,\n      Exception exception) {\n    this.libraryId = new CqlLibraryId(cqlLibraryIdentifier);\n    this.contextId = checkNotNull(contextId);\n    this.evaluationTime = evaluationDateTime.toInstant().toEpochMilli();\n    this.error = exception.getMessage();\n  }\n", "  public CqlLibraryId getLibraryId() {\n    return libraryId;\n  }\n\n  public ResourceTypeAndId getContexId() {\n    return contextId;\n  }\n\n  public Instant getEvaluationTime() {\n    return Instant.ofEpochMilli(evaluationTime);\n  }\n", "  public Instant getEvaluationTime() {\n    return Instant.ofEpochMilli(evaluationTime);\n  }\n\n  public String getError() {\n    return error;\n  }\n\n  public Map<String, Boolean> getResults() {\n    return results;\n  }\n\n  @Override", "  public String toString() {\n    return MoreObjects.toStringHelper(CqlEvaluationResult.class)\n        .add(\"libraryId\", libraryId)\n        .add(\"contextId\", contextId)\n        .add(\"evaluationTime\", evaluationTime)\n        .add(\"results\", results)\n        .add(\"error\", error)\n        .toString();\n  }\n\n  @Override", "  public int hashCode() {\n    return Objects.hash(libraryId, contextId, evaluationTime, results, error);\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof CqlEvaluationResult)) {\n      return false;\n    }\n    CqlEvaluationResult that = (CqlEvaluationResult) other;\n    return this.libraryId.equals(that.libraryId)\n        && this.contextId.equals(that.contextId)\n        && this.evaluationTime == that.evaluationTime\n        && Objects.equals(this.results, that.results)\n        && Objects.equals(this.error, that.error);\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/types/CqlLibraryId.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.base.Preconditions.checkNotNull;", "\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.MoreObjects;\nimport java.io.Serializable;\nimport java.util.Objects;\nimport javax.annotation.Nullable;\nimport org.apache.beam.sdk.coders.DefaultCoder;", "import javax.annotation.Nullable;\nimport org.apache.beam.sdk.coders.DefaultCoder;\nimport org.apache.beam.sdk.extensions.avro.coders.AvroCoder;\nimport org.cqframework.cql.elm.execution.VersionedIdentifier;\n\n/** A CQL library identifier that can be serialized by {@link AvroCoder}. */\n@DefaultCoder(AvroCoder.class)\npublic final class CqlLibraryId implements Serializable {\n  private String name;\n\n  @Nullable\n  private String version;\n\n  // Required for AvroCoder.\n  public CqlLibraryId() {}\n\n  public CqlLibraryId(VersionedIdentifier cqlLibraryIdentifier) {\n    this(cqlLibraryIdentifier.getId(), cqlLibraryIdentifier.getVersion());\n  }\n\n  @JsonCreator\n  public CqlLibraryId(\n      @JsonProperty(\"name\") String name,\n      @Nullable @JsonProperty(\"version\") String version) {\n    this.name = checkNotNull(name);\n    this.version = version;\n  }\n\n  /**\n   * Returns the library's name.\n   *\n   * @see https://cql.hl7.org/02-authorsguide.html#library\n   */\n  @JsonProperty(\"name\")", "  public String getName() {\n    return name;\n  }\n\n  /**\n   * Returns the library's version.\n   *\n   * @see https://cql.hl7.org/02-authorsguide.html#library\n   */\n  @Nullable\n  @JsonProperty(\"version\")", "  public String getVersion() {\n    return version;\n  }\n\n  @Override\n  public String toString() {\n    return MoreObjects.toStringHelper(CqlLibraryId.class)\n        .add(\"name\", name)\n        .add(\"version\", version)\n        .toString();\n  }\n\n  @Override", "  public int hashCode() {\n    return Objects.hash(name, version);\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof CqlLibraryId)) {\n      return false;\n    }\n\n    CqlLibraryId that = (CqlLibraryId) other;\n\n    return this.name.equals(that.name) && Objects.equals(this.version, that.version);\n  }\n}\n"]}
{"filename": "src/main/java/com/google/fhir/cql/beam/types/ResourceTypeAndId.java", "chunked_list": ["/*\n * Copyright (C) 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.fhir.cql.beam.types;\n\nimport static com.google.common.base.Preconditions.checkNotNull;", "\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.MoreObjects;\nimport java.io.Serializable;\nimport java.util.Objects;\nimport org.apache.beam.sdk.coders.DefaultCoder;\nimport org.apache.beam.sdk.extensions.avro.coders.AvroCoder;\n\n/**", "\n/**\n * A container that holds a FHIR record's resource type and logical ID.\n */\n@DefaultCoder(AvroCoder.class)\npublic final class ResourceTypeAndId implements Serializable {\n  private String type;\n  private String id;\n\n  // Required for AvroCoder.\n  public ResourceTypeAndId() {}\n\n  public ResourceTypeAndId(String type, String id) {\n    this.type = checkNotNull(type);\n    this.id = checkNotNull(id);\n  }\n\n  /**\n   * Returns the resource's type as a string (e.g. \"Patient\").\n   */", "  public String getType() {\n    return type;\n  }\n\n  /**\n   * Returns the resource's logical ID.\n   *\n   * @see https://www.hl7.org/fhir/resource.html#id\n   */\n  public String getId() {\n    return id;\n  }\n\n  @Override", "  public String getId() {\n    return id;\n  }\n\n  @Override\n  public String toString() {\n    return MoreObjects.toStringHelper(ResourceTypeAndId.class)\n        .add(\"type\", type)\n        .add(\"id\", id)\n        .toString();\n  }\n\n  @Override", "  public int hashCode() {\n    return Objects.hash(type, id);\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof ResourceTypeAndId)) {\n      return false;\n    }\n\n    ResourceTypeAndId that = (ResourceTypeAndId) other;\n\n    return this.type.equals(that.type)\n        && this.id.equals(that.id);\n  }\n}\n"]}
