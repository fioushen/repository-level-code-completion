{"filename": "canal-client-example/src/main/java/io/xzxj/canal/example/ExampleApplication.java", "chunked_list": ["package io.xzxj.canal.example;\n\nimport io.xzxj.canal.spring.annotation.EnableCanalListener;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * @author xzxj\n * @date 2023/3/11 12:19\n */", " * @date 2023/3/11 12:19\n */\n@EnableCanalListener\n@SpringBootApplication\npublic class ExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ExampleApplication.class, args);\n    }\n\n}\n"]}
{"filename": "canal-client-example/src/main/java/io/xzxj/canal/example/entity/TestEntity.java", "chunked_list": ["package io.xzxj.canal.example.entity;\n\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport lombok.Data;\n\n/**\n * @author xzxj\n * @date 2023/3/11 13:53\n */", " * @date 2023/3/11 13:53\n */\n@Data\n@TableName(\"t_test\")\npublic class TestEntity {\n\n    private Long id;\n\n    private String name;\n\n    @TableField(\"f_age\")\n    private Integer age;\n\n}\n"]}
{"filename": "canal-client-example/src/main/java/io/xzxj/canal/example/listener/TestListener.java", "chunked_list": ["package io.xzxj.canal.example.listener;\n\nimport io.xzxj.canal.core.annotation.CanalListener;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.example.entity.TestEntity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author xzxj", "/**\n * @author xzxj\n * @date 2023/3/11 13:53\n */\n@CanalListener\npublic class TestListener implements EntryListener<TestEntity> {\n\n    private static final Logger log = LoggerFactory.getLogger(TestListener.class);\n\n    @Override\n    public void insert(TestEntity testEntity) {\n        log.info(\"insert={}\", testEntity);\n    }\n\n    @Override", "    public void insert(TestEntity testEntity) {\n        log.info(\"insert={}\", testEntity);\n    }\n\n    @Override\n    public void update(TestEntity before, TestEntity after) {\n        log.info(\"update before={}\", before);\n        log.info(\"update after={}\", after);\n    }\n\n    @Override", "    public void delete(TestEntity testEntity) {\n        log.info(\"delete={}\", testEntity);\n    }\n}\n"]}
{"filename": "canal-client-core/src/test/java/io/xzxj/canal/core/SimpleCanalClientExample.java", "chunked_list": ["package io.xzxj.canal.core;\n\nimport com.alibaba.otter.canal.client.CanalConnector;\nimport com.alibaba.otter.canal.client.CanalConnectors;\nimport com.alibaba.otter.canal.common.utils.AddressUtils;\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport com.alibaba.otter.canal.protocol.Message;\n\nimport java.net.InetSocketAddress;\nimport java.util.List;", "import java.net.InetSocketAddress;\nimport java.util.List;\n\npublic class SimpleCanalClientExample {\n\n    public static void main(String[] args) {\n        // \u521b\u5efa\u94fe\u63a5\n        CanalConnector connector = CanalConnectors.newSingleConnector(\n                new InetSocketAddress(AddressUtils.getHostIp(), 11111),\n                \"example\", \"\", \"\");\n        int batchSize = 1000;\n        int emptyCount = 0;", "        try {\n            connector.connect();\n            connector.subscribe(\".*\\\\..*\");\n            connector.rollback();\n            int totalEmptyCount = 120;\n            while (emptyCount < totalEmptyCount) {\n                Message message = connector.getWithoutAck(batchSize); // \u83b7\u53d6\u6307\u5b9a\u6570\u91cf\u7684\u6570\u636e\n                long batchId = message.getId();\n                int size = message.getEntries().size();\n                if (batchId == -1 || size == 0) {\n                    emptyCount++;\n                    System.out.println(\"empty count : \" + emptyCount);", "                if (batchId == -1 || size == 0) {\n                    emptyCount++;\n                    System.out.println(\"empty count : \" + emptyCount);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                } else {\n                    emptyCount = 0;\n                    // System.out.printf(\"message[batchId=%s,size=%s] \\n\", batchId, size);\n                    printEntry(message.getEntries());\n                }\n\n                connector.ack(batchId); // \u63d0\u4ea4\u786e\u8ba4\n                // connector.rollback(batchId); // \u5904\u7406\u5931\u8d25, \u56de\u6eda\u6570\u636e\n            }\n\n            System.out.println(\"empty too many times, exit\");\n        } finally {\n            connector.disconnect();\n        }\n    }\n\n    private static void printEntry(List<CanalEntry.Entry> entrys) {", "        for (CanalEntry.Entry entry : entrys) {\n            if (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) {\n                continue;\n            }\n\n            CanalEntry.RowChange rowChage = null;\n            try {\n                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());\n            } catch (Exception e) {\n                throw new RuntimeException(\"ERROR ## parser of eromanga-event has an error , data:\" + entry.toString(),\n                        e);\n            }\n\n            CanalEntry.EventType eventType = rowChage.getEventType();\n            System.out.printf(\"================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s%n\",\n                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),\n                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),\n                    eventType);\n", "            for (CanalEntry.RowData rowData : rowChage.getRowDatasList()) {\n                if (eventType == CanalEntry.EventType.DELETE) {\n                    printColumn(rowData.getBeforeColumnsList());\n                } else if (eventType == CanalEntry.EventType.INSERT) {\n                    printColumn(rowData.getAfterColumnsList());\n                } else {\n                    System.out.println(\"-------&gt; before\");\n                    printColumn(rowData.getBeforeColumnsList());\n                    System.out.println(\"-------&gt; after\");\n                    printColumn(rowData.getAfterColumnsList());\n                }\n            }\n        }\n    }\n\n    private static void printColumn(List<CanalEntry.Column> columns) {", "        for (CanalEntry.Column column : columns) {\n            System.out.println(column.getName() + \" : \" + column.getValue() + \"    update=\" + column.getUpdated());\n        }\n    }\n\n}"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/IMessageHandler.java", "chunked_list": ["package io.xzxj.canal.core.handler;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:44\n */\npublic interface IMessageHandler<T> {\n\n    void handleMessage(T t) throws Exception;\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/RowDataHandler.java", "chunked_list": ["package io.xzxj.canal.core.handler;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport io.xzxj.canal.core.listener.EntryListener;\n\n/**\n * @author xzxj\n * @date 2023/3/11 14:57\n */\npublic interface RowDataHandler<T> {\n\n    <R> void handleRowData(T t, EntryListener<R> entryListener, CanalEntry.EventType eventType) throws Exception;\n\n}\n", " */\npublic interface RowDataHandler<T> {\n\n    <R> void handleRowData(T t, EntryListener<R> entryListener, CanalEntry.EventType eventType) throws Exception;\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/AbstractMessageHandler.java", "chunked_list": ["package io.xzxj.canal.core.handler;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport com.alibaba.otter.canal.protocol.Message;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.core.util.EntryListenerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\n\n/**\n * @author xzxj\n * @date 2023/3/11 11:25\n */\npublic abstract class AbstractMessageHandler implements IMessageHandler<Message> {\n\n    private static final Logger log = LoggerFactory.getLogger(AbstractMessageHandler.class);\n\n    private final List<EntryListener<?>> entryListenerList;\n    private final RowDataHandler<CanalEntry.RowData> rowDataHandler;\n\n    public AbstractMessageHandler(List<EntryListener<?>> entryListenerList, RowDataHandler<CanalEntry.RowData> rowDataHandler) {\n        this.entryListenerList = entryListenerList;\n        this.rowDataHandler = rowDataHandler;\n    }\n\n    @Override", "    public void handleMessage(Message message) {\n        List<CanalEntry.Entry> entries = message.getEntries();\n        for (CanalEntry.Entry entry : entries) {\n            if (!CanalEntry.EntryType.ROWDATA.equals(entry.getEntryType())) {\n                continue;\n            }\n            String schemaName = entry.getHeader().getSchemaName();\n            String tableName = entry.getHeader().getTableName();\n\n            EntryListener<?> entryListener = EntryListenerUtil.findEntryListener(entryListenerList, schemaName, tableName);\n\n            CanalEntry.RowChange rowChange;", "            try {\n                rowChange = CanalEntry.RowChange.parseFrom(entry.getStoreValue());\n            } catch (Exception e) {\n                throw new RuntimeException(\"parse event has an error , data:\" + entry, e);\n            }\n            List<CanalEntry.RowData> rowDataList = rowChange.getRowDatasList();\n            CanalEntry.EventType eventType = rowChange.getEventType();\n            try {\n                for (CanalEntry.RowData rowData : rowDataList) {\n                    if (entryListener != null) {\n                        rowDataHandler.handleRowData(rowData, entryListener, eventType);\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"handle row data error\", e);\n            }\n        }\n    }\n\n}\n", "                for (CanalEntry.RowData rowData : rowDataList) {\n                    if (entryListener != null) {\n                        rowDataHandler.handleRowData(rowData, entryListener, eventType);\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"handle row data error\", e);\n            }\n        }\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/AbstractFlatMessageHandler.java", "chunked_list": ["package io.xzxj.canal.core.handler;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.core.util.EntryListenerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * @author xzxj\n * @date 2023/3/15 13:42\n */\npublic abstract class AbstractFlatMessageHandler implements IMessageHandler<FlatMessage> {\n\n    private static final Logger log = LoggerFactory.getLogger(AbstractFlatMessageHandler.class);\n\n    private final List<EntryListener<?>> entryListenerList;\n    private final RowDataHandler<List<Map<String, String>>> rowDataHandler;\n\n    public AbstractFlatMessageHandler(List<EntryListener<?>> entryListenerList,\n                                      RowDataHandler<List<Map<String, String>>> rowDataHandler) {\n        this.entryListenerList = entryListenerList;\n        this.rowDataHandler = rowDataHandler;\n    }\n\n    @Override", " * @date 2023/3/15 13:42\n */\npublic abstract class AbstractFlatMessageHandler implements IMessageHandler<FlatMessage> {\n\n    private static final Logger log = LoggerFactory.getLogger(AbstractFlatMessageHandler.class);\n\n    private final List<EntryListener<?>> entryListenerList;\n    private final RowDataHandler<List<Map<String, String>>> rowDataHandler;\n\n    public AbstractFlatMessageHandler(List<EntryListener<?>> entryListenerList,\n                                      RowDataHandler<List<Map<String, String>>> rowDataHandler) {\n        this.entryListenerList = entryListenerList;\n        this.rowDataHandler = rowDataHandler;\n    }\n\n    @Override", "    public void handleMessage(FlatMessage flatMessage) {\n        List<Map<String, String>> messageData = flatMessage.getData();\n        if (messageData == null || messageData.isEmpty()) {\n            return;\n        }\n        for (int i = 0; i < messageData.size(); i++) {\n            CanalEntry.EventType eventType = CanalEntry.EventType.valueOf(flatMessage.getType());\n            List<Map<String, String>> maps;\n            if (eventType.equals(CanalEntry.EventType.UPDATE)) {\n                Map<String, String> map = messageData.get(i);\n                Map<String, String> oldMap = flatMessage.getOld().get(i);\n                maps = Stream.of(map, oldMap).collect(Collectors.toList());\n            } else {\n                maps = Stream.of(messageData.get(i)).collect(Collectors.toList());\n            }\n\n            String schemaName = flatMessage.getDatabase();\n            String tableName = flatMessage.getTable();\n\n            EntryListener<?> entryListener = EntryListenerUtil.findEntryListener(entryListenerList, schemaName, tableName);\n", "            if (eventType.equals(CanalEntry.EventType.UPDATE)) {\n                Map<String, String> map = messageData.get(i);\n                Map<String, String> oldMap = flatMessage.getOld().get(i);\n                maps = Stream.of(map, oldMap).collect(Collectors.toList());\n            } else {\n                maps = Stream.of(messageData.get(i)).collect(Collectors.toList());\n            }\n\n            String schemaName = flatMessage.getDatabase();\n            String tableName = flatMessage.getTable();\n\n            EntryListener<?> entryListener = EntryListenerUtil.findEntryListener(entryListenerList, schemaName, tableName);\n", "            try {\n                if (entryListener != null) {\n                    rowDataHandler.handleRowData(maps, entryListener, eventType);\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(\"parse event has an error , data:\" + messageData, e);\n            }\n        }\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/AsyncFlatMessageHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.handler.AbstractFlatMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;", "import java.util.Map;\nimport java.util.concurrent.ExecutorService;\n\n/**\n * @author xzxj\n * @date 2023/3/15 13:49\n */\npublic class AsyncFlatMessageHandlerImpl extends AbstractFlatMessageHandler {\n\n\n    private final ExecutorService executor;\n\n    public AsyncFlatMessageHandlerImpl(List<EntryListener<?>> entryListenerList,\n                                       RowDataHandler<List<Map<String, String>>> rowDataHandler,\n                                       ExecutorService executor) {\n        super(entryListenerList, rowDataHandler);\n        this.executor = executor;\n    }\n\n    @Override", "    public void handleMessage(FlatMessage flatMessage) {\n        executor.execute(() -> super.handleMessage(flatMessage));\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/SyncMessageHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport io.xzxj.canal.core.handler.AbstractMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\n\nimport java.util.List;\n\n/**", "\n/**\n * @author xzxj\n * @date 2023/3/15 10:36\n */\npublic class SyncMessageHandlerImpl extends AbstractMessageHandler {\n\n    public SyncMessageHandlerImpl(List<EntryListener<?>> entryListenerList, RowDataHandler<CanalEntry.RowData> rowDataHandler) {\n        super(entryListenerList, rowDataHandler);\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/MapRowDataHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport io.xzxj.canal.core.factory.IConvertFactory;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author xzxj\n * @date 2023/3/15 14:06\n */\npublic class MapRowDataHandlerImpl implements RowDataHandler<List<Map<String, String>>> {\n\n    private static final Logger log = LoggerFactory.getLogger(MapRowDataHandlerImpl.class);\n\n    private final IConvertFactory<Map<String, String>> convertFactory;\n\n    public MapRowDataHandlerImpl(IConvertFactory<Map<String, String>> convertFactory) {\n        this.convertFactory = convertFactory;\n    }\n\n    @Override\n    public <R> void handleRowData(List<Map<String, String>> mapList,\n                                  EntryListener<R> entryListener,\n                                  CanalEntry.EventType eventType) throws Exception {", "public class MapRowDataHandlerImpl implements RowDataHandler<List<Map<String, String>>> {\n\n    private static final Logger log = LoggerFactory.getLogger(MapRowDataHandlerImpl.class);\n\n    private final IConvertFactory<Map<String, String>> convertFactory;\n\n    public MapRowDataHandlerImpl(IConvertFactory<Map<String, String>> convertFactory) {\n        this.convertFactory = convertFactory;\n    }\n\n    @Override\n    public <R> void handleRowData(List<Map<String, String>> mapList,\n                                  EntryListener<R> entryListener,\n                                  CanalEntry.EventType eventType) throws Exception {", "        if (entryListener == null) {\n            return;\n        }\n        switch (eventType) {\n            case INSERT:\n                R entry = convertFactory.newInstance(entryListener, mapList.get(0));\n                entryListener.insert(entry);\n                break;\n            case UPDATE:\n                R before = convertFactory.newInstance(entryListener, mapList.get(1));\n                R after = convertFactory.newInstance(entryListener, mapList.get(0));\n                entryListener.update(before, after);\n                break;\n            case DELETE:\n                R o = convertFactory.newInstance(entryListener, mapList.get(0));\n                entryListener.delete(o);\n                break;\n            default:\n                log.info(\"\u672a\u77e5\u6d88\u606f\u7c7b\u578b {} \u4e0d\u5904\u7406 {}\", eventType, mapList);\n                break;\n        }\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/RowDataHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport io.xzxj.canal.core.factory.IConvertFactory;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author xzxj\n * @date 2023/3/12 11:55\n */\npublic class RowDataHandlerImpl implements RowDataHandler<CanalEntry.RowData> {\n\n    private static final Logger log = LoggerFactory.getLogger(RowDataHandlerImpl.class);\n\n    private final IConvertFactory<List<CanalEntry.Column>> convertFactory;\n\n    public RowDataHandlerImpl(IConvertFactory<List<CanalEntry.Column>> convertFactory) {\n        this.convertFactory = convertFactory;\n    }\n\n    @Override\n    public <R> void handleRowData(CanalEntry.RowData rowData, EntryListener<R> entryListener, CanalEntry.EventType eventType) throws Exception {", " */\npublic class RowDataHandlerImpl implements RowDataHandler<CanalEntry.RowData> {\n\n    private static final Logger log = LoggerFactory.getLogger(RowDataHandlerImpl.class);\n\n    private final IConvertFactory<List<CanalEntry.Column>> convertFactory;\n\n    public RowDataHandlerImpl(IConvertFactory<List<CanalEntry.Column>> convertFactory) {\n        this.convertFactory = convertFactory;\n    }\n\n    @Override\n    public <R> void handleRowData(CanalEntry.RowData rowData, EntryListener<R> entryListener, CanalEntry.EventType eventType) throws Exception {", "        if (entryListener == null) {\n            log.warn(\"entryListener not found\");\n            return;\n        }\n        switch (eventType) {\n            case INSERT:\n                R object = convertFactory.newInstance(entryListener, rowData.getAfterColumnsList());\n                entryListener.insert(object);\n                break;\n            case UPDATE:\n                Set<String> updateColumnSet = rowData.getAfterColumnsList().stream().filter(CanalEntry.Column::getUpdated)\n                        .map(CanalEntry.Column::getName).collect(Collectors.toSet());\n                R before = convertFactory.newInstance(entryListener, rowData.getBeforeColumnsList(), updateColumnSet);\n                R after = convertFactory.newInstance(entryListener, rowData.getAfterColumnsList());\n                entryListener.update(before, after);\n                break;\n            case DELETE:\n                R o = convertFactory.newInstance(entryListener, rowData.getBeforeColumnsList());\n                entryListener.delete(o);\n                break;\n            default:\n                break;\n        }\n    }\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/AsyncMessageHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport com.alibaba.otter.canal.protocol.Message;\nimport io.xzxj.canal.core.handler.AbstractMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\n\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;", "import java.util.List;\nimport java.util.concurrent.ExecutorService;\n\n/**\n * @author xzxj\n * @date 2023/3/15 10:37\n */\npublic class AsyncMessageHandlerImpl extends AbstractMessageHandler {\n\n\n    private final ExecutorService executor;\n\n    public AsyncMessageHandlerImpl(List<EntryListener<?>> entryListenerList, RowDataHandler<CanalEntry.RowData> rowDataHandler, ExecutorService executor) {\n        super(entryListenerList, rowDataHandler);\n        this.executor = executor;\n    }\n\n    @Override", "    public void handleMessage(Message message) {\n        executor.execute(() -> super.handleMessage(message));\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/handler/impl/SyncFlatMessageHandlerImpl.java", "chunked_list": ["package io.xzxj.canal.core.handler.impl;\n\nimport io.xzxj.canal.core.handler.AbstractFlatMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.listener.EntryListener;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**", "\n/**\n * @author xzxj\n * @date 2023/3/15 13:48\n */\npublic class SyncFlatMessageHandlerImpl extends AbstractFlatMessageHandler {\n\n    public SyncFlatMessageHandlerImpl(List<EntryListener<?>> entryListenerList, RowDataHandler<List<Map<String, String>>> rowDataHandler) {\n        super(entryListenerList, rowDataHandler);\n    }\n\n}\n\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/util/TableInfoUtil.java", "chunked_list": ["package io.xzxj.canal.core.util;\n\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.google.common.base.CaseFormat;\nimport io.xzxj.canal.core.annotation.CanalListener;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport org.apache.commons.lang3.StringUtils;\n\nimport javax.annotation.Nullable;\nimport javax.persistence.Table;", "import javax.annotation.Nullable;\nimport javax.persistence.Table;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author xzxj\n * @date 2023/3/11 16:19", " * @author xzxj\n * @date 2023/3/11 16:19\n */\npublic class TableInfoUtil {\n\n    private static Map<Class<? extends EntryListener>, Class>\n            CLASS_LISTENER_CACHE_MAP = new ConcurrentHashMap<>();\n\n    @Deprecated\n    @Nullable\n    public static String getTableName(EntryListener<?> entryListener) {\n        CanalListener annotation = entryListener.getClass().getAnnotation(CanalListener.class);", "    public static String getTableName(EntryListener<?> entryListener) {\n        CanalListener annotation = entryListener.getClass().getAnnotation(CanalListener.class);\n        if (annotation == null) {\n            return null;\n        }\n        StringBuilder fullName = new StringBuilder();\n        String schemaName = annotation.schemaName().length != 0 ? annotation.schemaName()[0] : null;\n        if (StringUtils.isNotBlank(schemaName)) {\n            fullName.append(schemaName).append(\".\");\n        }\n        if (StringUtils.isNotBlank(annotation.tableName())) {\n            fullName.append(annotation.tableName());\n        } else {\n            String tableName = findTableName(entryListener);\n            fullName.append(tableName);\n        }\n        return fullName.toString();\n    }\n\n    @Nullable", "        if (StringUtils.isNotBlank(annotation.tableName())) {\n            fullName.append(annotation.tableName());\n        } else {\n            String tableName = findTableName(entryListener);\n            fullName.append(tableName);\n        }\n        return fullName.toString();\n    }\n\n    @Nullable\n    public static String findTableName(EntryListener<?> entryListener) {\n        Class<Object> tableClass = getTableClass(entryListener);", "    public static String findTableName(EntryListener<?> entryListener) {\n        Class<Object> tableClass = getTableClass(entryListener);\n        if (tableClass == null) {\n            return null;\n        }\n        TableName tableName = tableClass.getAnnotation(TableName.class);\n        if (tableName != null && StringUtils.isNotBlank(tableName.value())) {\n            return tableName.value();\n        }\n        Table table = tableClass.getAnnotation(Table.class);\n        if (table != null && StringUtils.isNotBlank(table.name())) {\n            return table.name();\n        }\n        return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, tableClass.getName());\n    }\n\n    /**\n     * \u627e\u5230EntryListener\u6cdb\u578b\u4e2d\u7684\u6570\u636e\u5e93\u5b9e\u4f53\u7c7b\n     *\n     * @param object\n     * @param <T>\n     * @return\n     */\n    @Nullable\n    public static <T> Class<T> getTableClass(EntryListener<?> object) {\n        Class<? extends EntryListener> listenerClass = object.getClass();\n        Class<T> tableClass = CLASS_LISTENER_CACHE_MAP.get(listenerClass);", "        if (table != null && StringUtils.isNotBlank(table.name())) {\n            return table.name();\n        }\n        return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, tableClass.getName());\n    }\n\n    /**\n     * \u627e\u5230EntryListener\u6cdb\u578b\u4e2d\u7684\u6570\u636e\u5e93\u5b9e\u4f53\u7c7b\n     *\n     * @param object\n     * @param <T>\n     * @return\n     */\n    @Nullable\n    public static <T> Class<T> getTableClass(EntryListener<?> object) {\n        Class<? extends EntryListener> listenerClass = object.getClass();\n        Class<T> tableClass = CLASS_LISTENER_CACHE_MAP.get(listenerClass);", "        if (tableClass != null) {\n            return tableClass;\n        }\n        Type[] interfacesTypes = listenerClass.getGenericInterfaces();\n        for (Type type : interfacesTypes) {\n            Class<?> c = (Class<?>) ((ParameterizedType) type).getRawType();\n            if (c.equals(EntryListener.class)) {\n                tableClass = (Class<T>) ((ParameterizedType) type).getActualTypeArguments()[0];\n                CLASS_LISTENER_CACHE_MAP.putIfAbsent(listenerClass, tableClass);\n                return tableClass;\n            }\n        }\n        return null;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/util/EntryListenerUtil.java", "chunked_list": ["package io.xzxj.canal.core.util;\n\nimport io.xzxj.canal.core.annotation.CanalListener;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport org.apache.commons.lang3.StringUtils;\n\nimport javax.annotation.Nullable;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\n\n/**\n * @author xzxj\n * @date 2023/8/16 11:54\n */\npublic class EntryListenerUtil {\n\n    public static final String DEFAULT_KEY = \"DEFAULT\";\n\n    private static Map<String, Map<String, EntryListener<?>>> entryListenerMap;\n\n    @Nullable", "    public static final String DEFAULT_KEY = \"DEFAULT\";\n\n    private static Map<String, Map<String, EntryListener<?>>> entryListenerMap;\n\n    @Nullable\n    public static EntryListener<?> findEntryListener(List<EntryListener<?>> entryListenerList, String schemaName, String tableName) {\n        if (entryListenerMap == null) {\n            initEntryListenerMap(entryListenerList);\n        }\n        // \u5148\u6839\u636e\u6570\u636e\u5e93\u540d\u627e\u5bf9\u5e94\u7684 Map<String, EntryListener>\n        Map<String, EntryListener<?>> listenerMap = MapValueUtil.getValueByRegex(entryListenerMap, schemaName);", "        if (listenerMap == null) {\n            listenerMap = MapValueUtil.getValueByRegex(entryListenerMap, EntryListenerUtil.DEFAULT_KEY);\n        }\n\n        // \u518d\u6839\u636e\u8868\u540d\u627e\u5bf9\u5e94\u7684 EntryListener\n        return listenerMap != null ? MapValueUtil.getValueByRegex(listenerMap, tableName) : null;\n    }\n\n    private static void initEntryListenerMap(List<EntryListener<?>> entryListenerList) {\n        entryListenerMap = new HashMap<>();\n        Map<String, EntryListener<?>> defaultMap = new HashMap<>();", "        for (EntryListener<?> entryListener : entryListenerList) {\n            CanalListener annotation = entryListener.getClass().getAnnotation(CanalListener.class);\n            if (annotation == null) {\n                continue;\n            }\n            String[] schemaNames = annotation.schemaName();\n            String tableName = annotation.tableName();\n            if (StringUtils.isBlank(tableName)) {\n                tableName = TableInfoUtil.findTableName(entryListener);\n            }\n            if (schemaNames.length == 0) {\n                defaultMap.put(tableName, entryListener);\n                continue;\n            }", "            if (schemaNames.length == 0) {\n                defaultMap.put(tableName, entryListener);\n                continue;\n            }\n            for (String schemaName : schemaNames) {\n                Map<String, EntryListener<?>> map = new HashMap<>();\n                map.put(tableName, entryListener);\n                entryListenerMap.put(schemaName, map);\n            }\n        }\n        entryListenerMap.put(DEFAULT_KEY, defaultMap);\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/util/TableFieldUtil.java", "chunked_list": ["package io.xzxj.canal.core.util;\n\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.google.common.base.CaseFormat;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\n\nimport javax.persistence.Column;\nimport java.beans.Transient;", "import javax.persistence.Column;\nimport java.beans.Transient;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**", "\n/**\n * @author xzxj\n * @date 2023/3/12 12:16\n */\npublic class TableFieldUtil {\n\n    private static final Map<Class<?>, Map<String, String>> TABLE_FILED_CACHE_MAP = new ConcurrentHashMap<>();\n\n    /**\n     * \u83b7\u53d6\u5b57\u6bb5\u540d\u79f0\u548c\u5b9e\u4f53\u5c5e\u6027\u7684\u5bf9\u5e94\u5173\u7cfb\n     *\n     * @param clazz\n     * @return\n     */", "    public static Map<String, String> getFieldMap(Class<?> clazz) {\n        Map<String, String> map = TABLE_FILED_CACHE_MAP.get(clazz);\n        if (map == null) {\n            List<Field> fields = FieldUtils.getAllFieldsList(clazz);\n            //\u5982\u679c\u5b9e\u4f53\u7c7b\u4e2d\u5b58\u5728column \u6ce8\u89e3\uff0c\u5219\u4f7f\u7528\u6ce8\u89e3\u7684\u540d\u79f0\u4e3a\u5b57\u6bb5\u540d\n            map = fields.stream().filter(TableFieldUtil::tableColumnFiled)\n                    .filter(field -> !Modifier.isStatic(field.getModifiers()))\n                    .collect(Collectors.toMap(TableFieldUtil::getColumnName, Field::getName));\n            TABLE_FILED_CACHE_MAP.putIfAbsent(clazz, map);\n        }\n        return map;\n    }\n\n    private static String getColumnName(Field field) {\n        TableId tableId = field.getAnnotation(TableId.class);", "        if (tableId != null && StringUtils.isNotBlank(tableId.value())) {\n            return tableId.value();\n        }\n        TableField tableField = field.getAnnotation(TableField.class);\n        if (tableField != null && StringUtils.isNotBlank(tableField.value())) {\n            return tableField.value();\n        }\n        Column column = field.getAnnotation(Column.class);\n        if (column != null && StringUtils.isNotBlank(column.name())) {\n            return column.name();\n        }\n        return defaultColumnName(field);\n    }\n\n    private static String defaultColumnName(Field field) {\n        return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, field.getName());\n    }\n\n    private static boolean tableColumnFiled(Field field) {\n        TableField tableField = field.getAnnotation(TableField.class);\n        Transient annotation = field.getAnnotation(Transient.class);\n        return tableField == null || tableField.exist() || annotation == null;\n    }\n\n    public static <R> void setFieldValue(R object, String fieldName, String value) throws NoSuchFieldException, IllegalAccessException {\n        Field field;", "        if (column != null && StringUtils.isNotBlank(column.name())) {\n            return column.name();\n        }\n        return defaultColumnName(field);\n    }\n\n    private static String defaultColumnName(Field field) {\n        return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, field.getName());\n    }\n\n    private static boolean tableColumnFiled(Field field) {\n        TableField tableField = field.getAnnotation(TableField.class);\n        Transient annotation = field.getAnnotation(Transient.class);\n        return tableField == null || tableField.exist() || annotation == null;\n    }\n\n    public static <R> void setFieldValue(R object, String fieldName, String value) throws NoSuchFieldException, IllegalAccessException {\n        Field field;", "        try {\n            field = object.getClass().getDeclaredField(fieldName);\n        } catch (NoSuchFieldException e) {\n            field = object.getClass().getSuperclass().getDeclaredField(fieldName);\n        }\n        field.setAccessible(true);\n        Class<?> type = field.getType();\n        Object result = StringConvertUtil.convertType(type, value);\n        field.set(object, result);\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/util/MapValueUtil.java", "chunked_list": ["package io.xzxj.canal.core.util;\n\nimport java.util.Map;\n\n/**\n * @author xzxj\n * @date 2023/5/4 10:13\n */\npublic class MapValueUtil {\n\n    public static <V> V getValueByRegex(Map<String, V> map, String key) {", "public class MapValueUtil {\n\n    public static <V> V getValueByRegex(Map<String, V> map, String key) {\n        for (Map.Entry<String, V> entry : map.entrySet()) {\n            String entryKey = entry.getKey();\n            if (entryKey == null) {\n                continue;\n            }\n            if (key.matches(entryKey)) {\n                return entry.getValue();\n            }\n        }\n        return null;\n    }\n\n}\n", "            if (key.matches(entryKey)) {\n                return entry.getValue();\n            }\n        }\n        return null;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/util/StringConvertUtil.java", "chunked_list": ["package io.xzxj.canal.core.util;\n\nimport org.apache.commons.lang.time.DateUtils;\n\nimport java.math.BigDecimal;\nimport java.text.ParseException;\nimport java.util.Date;\n\n/**\n * @author xzxj", "/**\n * @author xzxj\n * @date 2023/3/12 12:21\n */\npublic class StringConvertUtil {\n\n    private static final String[] PARSE_PATTERNS = new String[]{\"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\",\n            \"yyyy-MM-dd HH:mm\", \"yyyy-MM\", \"yyyy/MM/dd\", \"yyyy/MM/dd HH:mm:ss\",\n            \"yyyy/MM/dd HH:mm\", \"yyyy/MM\", \"yyyy.MM.dd\", \"yyyy.MM.dd HH:mm:ss\",\n            \"yyyy.MM.dd HH:mm\", \"yyyy.MM\"};\n\n    public StringConvertUtil() {\n    }\n\n    static Object convertType(Class<?> type, String columnValue) {", "        if (columnValue == null || columnValue.equals(\"\")) {\n            return null;\n        } else if (type.equals(Integer.class)) {\n            return Integer.parseInt(columnValue);\n        } else if (type.equals(Long.class)) {\n            return Long.parseLong(columnValue);\n        } else if (type.equals(Boolean.class)) {\n            return convertToBoolean(columnValue);\n        } else if (type.equals(BigDecimal.class)) {\n            return new BigDecimal(columnValue);\n        } else if (type.equals(Double.class)) {\n            return Double.parseDouble(columnValue);", "        } else if (type.equals(BigDecimal.class)) {\n            return new BigDecimal(columnValue);\n        } else if (type.equals(Double.class)) {\n            return Double.parseDouble(columnValue);\n        } else if (type.equals(Float.class)) {\n            return Float.parseFloat(columnValue);\n        } else if (type.equals(Date.class)) {\n            return parseDate(columnValue);\n        } else {\n            return type.equals(java.sql.Date.class) ? parseSqlDate(columnValue) : columnValue;\n        }\n    }\n\n    private static Date parseDate(String str) {", "        if (str == null) {\n            return null;\n        } else {\n            try {\n                return DateUtils.parseDate(str, PARSE_PATTERNS);\n            } catch (ParseException var2) {\n                return null;\n            }\n        }\n    }\n\n    private static Date parseSqlDate(String str) {", "        if (str == null) {\n            return null;\n        } else {\n            try {\n                Date date = DateUtils.parseDate(str, PARSE_PATTERNS);\n                return new java.sql.Date(date.getTime());\n            } catch (ParseException var2) {\n                return null;\n            }\n        }\n    }\n\n    private static boolean convertToBoolean(String value) {\n        return \"1\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value);\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/listener/EntryListener.java", "chunked_list": ["package io.xzxj.canal.core.listener;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:44\n */\npublic interface EntryListener<T> {\n\n    /**\n     * \u76d1\u542c\u5230\u65b0\u589e\u6570\u636e\u65f6\u4f1a\u89e6\u53d1\u7684\u65b9\u6cd5\n     *\n     * @param t \u6570\u636e\u5e93\u65b0\u589e\u7684\u6570\u636e\n     */\n    default void insert(T t) {\n\n    }\n\n    /**\n     * \u76d1\u542c\u5230\u4fee\u6539\u6570\u636e\u65f6\u4f1a\u89e6\u53d1\u7684\u65b9\u6cd5\n     *\n     * @param before \u4fee\u6539\u4e4b\u524d\u7684\u6570\u636e\n     * @param after  \u4fee\u6539\u4e4b\u540e\u7684\u6570\u636e\n     */\n    default void update(T before, T after) {\n\n    }\n\n    /**\n     * \u76d1\u542c\u5230\u5220\u9664\u6570\u636e\u65f6\u4f1a\u89e6\u53d1\u7684\u65b9\u6cd5\n     *\n     * @param t \u6570\u636e\u5e93\u5220\u9664\u7684\u6570\u636e\n     */\n    default void delete(T t) {\n\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/client/RabbitMqCanalClient.java", "chunked_list": ["package io.xzxj.canal.core.client;\n\nimport com.alibaba.otter.canal.client.rabbitmq.RabbitMQCanalConnector;\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj\n * @date 2023/3/24 9:23\n */\npublic class RabbitMqCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(RabbitMqCanalClient.class);\n\n    @Override", "public class RabbitMqCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(RabbitMqCanalClient.class);\n\n    @Override\n    public void handleListening() {\n        RabbitMQCanalConnector mqCanalConnector = (RabbitMQCanalConnector) connector;\n        while (runStatus) {\n            try {\n                List<FlatMessage> messageList = mqCanalConnector.getFlatListWithoutAck(timeout, unit);\n                log.debug(\"receive message={}\", messageList);", "            try {\n                List<FlatMessage> messageList = mqCanalConnector.getFlatListWithoutAck(timeout, unit);\n                log.debug(\"receive message={}\", messageList);\n                for (FlatMessage message : messageList) {\n                    messageHandler.handleMessage(message);\n                }\n                mqCanalConnector.ack();\n            } catch (Exception e) {\n                log.error(\"canal \u6d88\u8d39\u5f02\u5e38 \u56de\u6eda\u6d88\u606f\", e);\n                mqCanalConnector.rollback();\n            }\n        }\n        connector.unsubscribe();\n        connector.disconnect();\n    }\n", "    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n\n        // \u94fe\u63a5\u5730\u5740\n        private String servers;\n\n        // \u4e3b\u673a\u540d\n        private String virtualHost;\n\n        private String queueName;\n\n        // \u4e00\u4e9b\u9274\u6743\u4fe1\u606f\n        private String accessKey;\n        private String secretKey;\n        private Long resourceOwnerId;\n        private String username;\n        private String password;\n\n        private String filter = StringUtils.EMPTY;\n\n        private Long timeout = 1L;\n\n        private TimeUnit unit = TimeUnit.SECONDS;\n\n        private Integer batchSize = 1;\n\n        private IMessageHandler<?> messageHandler;\n\n        private Builder() {\n        }\n", "        public Builder servers(String servers) {\n            this.servers = servers;\n            return this;\n        }\n\n        public Builder virtualHost(String vhost) {\n            this.virtualHost = vhost;\n            return this;\n        }\n\n        public Builder queueName(String queueName) {\n            this.queueName = queueName;\n            return this;\n        }\n", "        public Builder queueName(String queueName) {\n            this.queueName = queueName;\n            return this;\n        }\n\n        public Builder accessKey(String accessKey) {\n            this.accessKey = accessKey;\n            return this;\n        }\n\n        public Builder secretKey(String secretKey) {\n            this.secretKey = secretKey;\n            return this;\n        }\n", "        public Builder secretKey(String secretKey) {\n            this.secretKey = secretKey;\n            return this;\n        }\n\n        public Builder resourceOwnerId(Long resourceOwnerId) {\n            this.resourceOwnerId = resourceOwnerId;\n            return this;\n        }\n\n        public Builder username(String username) {\n            this.username = username;\n            return this;\n        }\n", "        public Builder username(String username) {\n            this.username = username;\n            return this;\n        }\n\n        public Builder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n        public Builder filter(String filter) {\n            this.filter = filter;\n            return this;\n        }\n", "        public Builder filter(String filter) {\n            this.filter = filter;\n            return this;\n        }\n\n        public Builder timeout(Long timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public Builder unit(TimeUnit unit) {\n            this.unit = unit;\n            return this;\n        }\n", "        public Builder unit(TimeUnit unit) {\n            this.unit = unit;\n            return this;\n        }\n\n        public Builder batchSize(Integer batchSize) {\n            this.batchSize = batchSize;\n            return this;\n        }\n\n        public Builder messageHandler(IMessageHandler<?> messageHandler) {\n            this.messageHandler = messageHandler;\n            return this;\n        }\n", "        public Builder messageHandler(IMessageHandler<?> messageHandler) {\n            this.messageHandler = messageHandler;\n            return this;\n        }\n\n        public RabbitMqCanalClient build() {\n            RabbitMQCanalConnector connector = new RabbitMQCanalConnector(servers, virtualHost, queueName,\n                    accessKey, secretKey, username, password,\n                    resourceOwnerId, true);\n            RabbitMqCanalClient rabbitMqCanalClient = new RabbitMqCanalClient();\n            rabbitMqCanalClient.messageHandler = messageHandler;\n            rabbitMqCanalClient.connector = connector;\n            rabbitMqCanalClient.filter = this.filter;\n            rabbitMqCanalClient.unit = this.unit;\n            rabbitMqCanalClient.batchSize = this.batchSize;\n            rabbitMqCanalClient.timeout = this.timeout;\n            return rabbitMqCanalClient;\n        }\n\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/client/TcpCanalClient.java", "chunked_list": ["package io.xzxj.canal.core.client;\n\nimport com.alibaba.otter.canal.client.CanalConnector;\nimport com.alibaba.otter.canal.client.CanalConnectors;\nimport com.alibaba.otter.canal.protocol.Message;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:51\n */\npublic class TcpCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(TcpCanalClient.class);\n\n    @Override", " */\npublic class TcpCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(TcpCanalClient.class);\n\n    @Override\n    public void handleListening() {\n        while (runStatus) {\n            long batchId = 0L;\n            try {\n                Message message = connector.getWithoutAck(batchSize, timeout, unit);\n                log.debug(\"receive message={}\", message);\n                batchId = message.getId();", "            try {\n                Message message = connector.getWithoutAck(batchSize, timeout, unit);\n                log.debug(\"receive message={}\", message);\n                batchId = message.getId();\n                if (message.getId() != -1 && message.getEntries().size() != 0) {\n                    messageHandler.handleMessage(message);\n                }\n                connector.ack(batchId);\n            } catch (Exception e) {\n                log.error(\"canal \u6d88\u8d39\u5f02\u5e38 \u56de\u6eda\u6d88\u606f\", e);\n                connector.rollback(batchId);\n            }\n        }\n        connector.unsubscribe();\n        connector.disconnect();\n    }\n", "    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        private String filter = StringUtils.EMPTY;\n        private Integer batchSize = 1;\n        private Long timeout = 1L;\n        private TimeUnit unit = TimeUnit.SECONDS;\n        private String hostname;\n        private Integer port;\n        private String destination;\n        private String username;\n        private String password;\n        private IMessageHandler<?> messageHandler;\n\n        private Builder() {\n        }\n", "        public Builder hostname(String hostname) {\n            this.hostname = hostname;\n            return this;\n        }\n\n        public Builder port(Integer port) {\n            this.port = port;\n            return this;\n        }\n\n        public Builder destination(String destination) {\n            this.destination = destination;\n            return this;\n        }\n", "        public Builder destination(String destination) {\n            this.destination = destination;\n            return this;\n        }\n\n        public Builder username(String username) {\n            this.username = username;\n            return this;\n        }\n\n        public Builder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n", "        public Builder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n\n        public Builder filter(String filter) {\n            this.filter = filter;\n            return this;\n        }\n", "        public Builder batchSize(Integer batchSize) {\n            this.batchSize = batchSize;\n            return this;\n        }\n\n        public Builder timeout(Long timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public Builder unit(TimeUnit unit) {\n            this.unit = unit;\n            return this;\n        }\n", "        public Builder unit(TimeUnit unit) {\n            this.unit = unit;\n            return this;\n        }\n\n        public Builder messageHandler(IMessageHandler<?> messageHandler) {\n            this.messageHandler = messageHandler;\n            return this;\n        }\n\n        public TcpCanalClient build() {\n            CanalConnector canalConnector = CanalConnectors.newSingleConnector(new InetSocketAddress(hostname, port), destination, username, password);\n            TcpCanalClient tcpCanalClient = new TcpCanalClient();\n            tcpCanalClient.connector = canalConnector;\n            tcpCanalClient.messageHandler = messageHandler;\n            tcpCanalClient.filter = this.filter;\n            tcpCanalClient.unit = this.unit;\n            tcpCanalClient.batchSize = this.batchSize;\n            tcpCanalClient.timeout = this.timeout;\n            return tcpCanalClient;\n        }\n    }\n\n}\n", "        public TcpCanalClient build() {\n            CanalConnector canalConnector = CanalConnectors.newSingleConnector(new InetSocketAddress(hostname, port), destination, username, password);\n            TcpCanalClient tcpCanalClient = new TcpCanalClient();\n            tcpCanalClient.connector = canalConnector;\n            tcpCanalClient.messageHandler = messageHandler;\n            tcpCanalClient.filter = this.filter;\n            tcpCanalClient.unit = this.unit;\n            tcpCanalClient.batchSize = this.batchSize;\n            tcpCanalClient.timeout = this.timeout;\n            return tcpCanalClient;\n        }\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/client/KafkaCanalClient.java", "chunked_list": ["package io.xzxj.canal.core.client;\n\nimport com.alibaba.otter.canal.client.kafka.KafkaCanalConnector;\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;", "\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj\n * @date 2023/3/15 13:36\n */\npublic class KafkaCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(KafkaCanalClient.class);\n\n    @Override", "public class KafkaCanalClient extends AbstractCanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(KafkaCanalClient.class);\n\n    @Override\n    public void subscribe() {\n        connector.subscribe();\n    }\n\n    @Override\n    public void handleListening() {\n        KafkaCanalConnector kafkaCanalConnector = (KafkaCanalConnector) connector;", "    public void handleListening() {\n        KafkaCanalConnector kafkaCanalConnector = (KafkaCanalConnector) connector;\n        while (runStatus) {\n            try {\n                List<FlatMessage> messageList = kafkaCanalConnector.getFlatListWithoutAck(timeout, unit);\n                log.debug(\"receive message={}\", messageList);\n                for (FlatMessage message : messageList) {\n                    messageHandler.handleMessage(message);\n                }\n                kafkaCanalConnector.ack();\n            } catch (Exception e) {\n                log.error(\"canal \u6d88\u8d39\u5f02\u5e38 \u56de\u6eda\u6d88\u606f\", e);\n                kafkaCanalConnector.rollback();\n            }\n        }\n        connector.unsubscribe();\n        connector.disconnect();\n    }\n\n", "    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static final class Builder {\n        private String filter = StringUtils.EMPTY;\n        private Integer batchSize = 1;\n        private Long timeout = 1L;\n        private TimeUnit unit = TimeUnit.SECONDS;\n        private String servers;\n        private String topic;\n        private Integer partition;\n        private String groupId;\n        private IMessageHandler<?> messageHandler;\n\n        private Builder() {\n        }\n", "        public Builder servers(String servers) {\n            this.servers = servers;\n            return this;\n        }\n\n        public Builder topic(String topic) {\n            this.topic = topic;\n            return this;\n        }\n\n        public Builder partition(Integer partition) {\n            this.partition = partition;\n            return this;\n        }\n", "        public Builder partition(Integer partition) {\n            this.partition = partition;\n            return this;\n        }\n\n        public Builder groupId(String groupId) {\n            this.groupId = groupId;\n            return this;\n        }\n\n        public Builder filter(String filter) {\n            this.filter = filter;\n            return this;\n        }\n", "        public Builder filter(String filter) {\n            this.filter = filter;\n            return this;\n        }\n\n        public Builder batchSize(Integer batchSize) {\n            this.batchSize = batchSize;\n            return this;\n        }\n\n        public Builder timeout(Long timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n", "        public Builder timeout(Long timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public Builder unit(TimeUnit unit) {\n            this.unit = unit;\n            return this;\n        }\n\n        public Builder messageHandler(IMessageHandler<?> messageHandler) {\n            this.messageHandler = messageHandler;\n            return this;\n        }\n", "        public Builder messageHandler(IMessageHandler<?> messageHandler) {\n            this.messageHandler = messageHandler;\n            return this;\n        }\n\n        public KafkaCanalClient build() {\n            KafkaCanalConnector connector = new KafkaCanalConnector(servers, topic, partition, groupId, batchSize, true);\n            KafkaCanalClient kafkaCanalClient = new KafkaCanalClient();\n            kafkaCanalClient.messageHandler = messageHandler;\n            kafkaCanalClient.connector = connector;\n            kafkaCanalClient.filter = this.filter;\n            kafkaCanalClient.unit = this.unit;\n            kafkaCanalClient.batchSize = this.batchSize;\n            kafkaCanalClient.timeout = this.timeout;\n            return kafkaCanalClient;\n        }\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/client/AbstractCanalClient.java", "chunked_list": ["package io.xzxj.canal.core.client;\n\nimport com.alibaba.otter.canal.client.CanalConnector;\nimport com.alibaba.otter.canal.protocol.exception.CanalClientException;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:33\n */\npublic abstract class AbstractCanalClient implements ICanalClient {\n\n    private static final Logger log = LoggerFactory.getLogger(AbstractCanalClient.class);\n\n    protected volatile boolean runStatus;\n\n    private Thread thread;\n\n    protected CanalConnector connector;\n\n    protected IMessageHandler messageHandler;\n\n    protected String filter = \"\";\n\n    protected Integer batchSize = 1;\n\n    protected Long timeout = 1L;\n\n    protected TimeUnit unit = TimeUnit.SECONDS;\n\n    @Override", "    public void init() {\n        log.info(\"canal client init\");\n        this.connectCanal();\n        thread = new Thread(this::handleListening);\n        thread.setName(\"canal-client-thread\");\n        runStatus = true;\n        thread.start();\n    }\n\n    private void connectCanal() {\n        try {\n            log.info(\"canal client connecting\");\n            connector.connect();\n            this.subscribe();\n            log.info(\"canal client connect success\");\n        } catch (CanalClientException e) {\n            log.error(\"canal client connect error: {}\", e.getMessage(), e);\n            this.destroy();\n        }\n    }\n", "        try {\n            log.info(\"canal client connecting\");\n            connector.connect();\n            this.subscribe();\n            log.info(\"canal client connect success\");\n        } catch (CanalClientException e) {\n            log.error(\"canal client connect error: {}\", e.getMessage(), e);\n            this.destroy();\n        }\n    }\n", "    public void subscribe() {\n        connector.subscribe(filter);\n    }\n\n    @Override\n    public void destroy() {\n        connector.unsubscribe();\n        log.info(\"canal client destroy\");\n        if (thread != null) {\n            thread.interrupt();\n        }\n        runStatus = false;\n    }\n\n}\n", "        if (thread != null) {\n            thread.interrupt();\n        }\n        runStatus = false;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/client/ICanalClient.java", "chunked_list": ["package io.xzxj.canal.core.client;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:33\n */\npublic interface ICanalClient {\n\n    /**\n     * \u521d\u59cb\u5316\u5ba2\u6237\u7aef\n     */\n    void init();\n\n\n    /**\n     * \u9500\u6bc1\u5ba2\u6237\u7aef\n     */\n    void destroy();\n\n\n    /**\n     * \u6267\u884c\u76d1\u542c\n     */\n    void handleListening();\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/factory/IConvertFactory.java", "chunked_list": ["package io.xzxj.canal.core.factory;\n\nimport io.xzxj.canal.core.listener.EntryListener;\n\nimport java.util.Set;\n\n/**\n * \u6570\u636e\u5e93\u5b57\u6bb5\u8f6c\u6362\u5b9e\u4f53\u7c7b\u5de5\u5382\n *\n * @author xzxj", " *\n * @author xzxj\n * @date 2023/3/11 15:08\n */\npublic interface IConvertFactory<T> {\n\n    <R> R newInstance(EntryListener<?> entryHandler, T t) throws Exception;\n\n    default <R> R newInstance(EntryListener<?> entryHandler, T t, Set<String> updateColumn) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        return null;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/factory/AbstractConvertFactory.java", "chunked_list": ["package io.xzxj.canal.core.factory;\n\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.core.util.TableInfoUtil;\n\n/**\n * @author xzxj\n * @date 2023/3/11 16:16\n */\npublic abstract class AbstractConvertFactory<T> implements IConvertFactory<T> {\n\n    @Override\n    public <R> R newInstance(EntryListener<?> entryListener, T t) throws Exception {\n        Class<R> tableClass = TableInfoUtil.getTableClass(entryListener);", " */\npublic abstract class AbstractConvertFactory<T> implements IConvertFactory<T> {\n\n    @Override\n    public <R> R newInstance(EntryListener<?> entryListener, T t) throws Exception {\n        Class<R> tableClass = TableInfoUtil.getTableClass(entryListener);\n        if (tableClass != null) {\n            return newInstance(tableClass, t);\n        }\n        return null;\n    }\n\n    abstract <R> R newInstance(Class<R> clazz, T t) throws InstantiationException, IllegalAccessException, NoSuchFieldException;\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/factory/MapConvertFactory.java", "chunked_list": ["package io.xzxj.canal.core.factory;\n\nimport io.xzxj.canal.core.util.TableFieldUtil;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Map;\n\n/**\n * @author xzxj\n * @date 2023/3/15 14:10", " * @author xzxj\n * @date 2023/3/15 14:10\n */\npublic class MapConvertFactory extends AbstractConvertFactory<Map<String, String>> {\n\n    @Override\n    <R> R newInstance(Class<R> clazz, Map<String, String> valueMap) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        R object = clazz.newInstance();\n        Map<String, String> fieldMap = TableFieldUtil.getFieldMap(object.getClass());\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n            String fieldName = fieldMap.get(entry.getKey());", "        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n            String fieldName = fieldMap.get(entry.getKey());\n            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(object, fieldName, entry.getValue());\n            }\n        }\n        return object;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/factory/EntryColumnConvertFactory.java", "chunked_list": ["package io.xzxj.canal.core.factory;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.core.util.TableFieldUtil;\nimport io.xzxj.canal.core.util.TableInfoUtil;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author xzxj\n * @date 2023/3/12 12:10\n */\npublic class EntryColumnConvertFactory extends AbstractConvertFactory<List<CanalEntry.Column>> {\n\n    @Override\n    <R> R newInstance(Class<R> clazz, List<CanalEntry.Column> columnList) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        R object = clazz.newInstance();\n        Map<String, String> fieldMap = TableFieldUtil.getFieldMap(object.getClass());", "public class EntryColumnConvertFactory extends AbstractConvertFactory<List<CanalEntry.Column>> {\n\n    @Override\n    <R> R newInstance(Class<R> clazz, List<CanalEntry.Column> columnList) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        R object = clazz.newInstance();\n        Map<String, String> fieldMap = TableFieldUtil.getFieldMap(object.getClass());\n        for (CanalEntry.Column column : columnList) {\n            String fieldName = fieldMap.get(column.getName());\n            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(object, fieldName, column.getValue());\n            }\n        }\n        return object;\n    }\n\n    @Override\n    public <R> R newInstance(EntryListener<?> entryHandler, List<CanalEntry.Column> columnList, Set<String> updateColumn) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        Class<R> tableClass = TableInfoUtil.getTableClass(entryHandler);", "            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(object, fieldName, column.getValue());\n            }\n        }\n        return object;\n    }\n\n    @Override\n    public <R> R newInstance(EntryListener<?> entryHandler, List<CanalEntry.Column> columnList, Set<String> updateColumn) throws InstantiationException, IllegalAccessException, NoSuchFieldException {\n        Class<R> tableClass = TableInfoUtil.getTableClass(entryHandler);\n        if (tableClass == null) {\n            return null;\n        }\n        R r = tableClass.newInstance();\n        Map<String, String> columnNames = TableFieldUtil.getFieldMap(r.getClass());", "        if (tableClass == null) {\n            return null;\n        }\n        R r = tableClass.newInstance();\n        Map<String, String> columnNames = TableFieldUtil.getFieldMap(r.getClass());\n        for (CanalEntry.Column column : columnList) {\n            if (!updateColumn.contains(column.getName())) {\n                continue;\n            }\n            String fieldName = columnNames.get(column.getName());\n            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(r, fieldName, column.getValue());\n            }\n        }\n        return r;\n    }\n\n}\n", "            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(r, fieldName, column.getValue());\n            }\n        }\n        return r;\n    }\n\n}\n"]}
{"filename": "canal-client-core/src/main/java/io/xzxj/canal/core/annotation/CanalListener.java", "chunked_list": ["package io.xzxj.canal.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author xzxj\n * @date 2023/3/11 10:27", " * @author xzxj\n * @date 2023/3/11 10:27\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CanalListener {\n\n    /**\n     * \u8ba2\u9605\u6570\u636e\u5e93\u540d\n     */", "     * \u8ba2\u9605\u6570\u636e\u5e93\u540d\n     */\n    String[] schemaName() default {};\n\n    /**\n     * \u8ba2\u9605\u8868\u540d \u9ed8\u8ba4\u53d6\u6ce8\u89e3\u5b9e\u4f53\u7c7b\u6ce8\u89e3\u7684 TableName\n     */\n    String tableName() default \"\";\n\n", "\n\n    /**\n     * spring bean name\n     */\n    String name() default \"\";\n\n}\n", ""]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/autoconfigure/ThreadPoolAutoConfiguration.java", "chunked_list": ["package io.xzxj.canal.spring.autoconfigure;\n\nimport org.apache.commons.lang3.concurrent.BasicThreadFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.concurrent.ExecutorService;", "\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj\n * @date 2023/3/15 10:42\n */", " * @date 2023/3/15 10:42\n */\n@Configuration\n@ConditionalOnProperty(value = \"canal.async\", havingValue = \"true\", matchIfMissing = true)\npublic class ThreadPoolAutoConfiguration {\n\n    private static final Logger log = LoggerFactory.getLogger(ThreadPoolAutoConfiguration.class);\n\n    @Bean(destroyMethod = \"shutdown\")\n    public ExecutorService executorService() {\n        BasicThreadFactory factory = new BasicThreadFactory.Builder()\n                .namingPattern(\"canal-execute-thread-%d\")\n                .uncaughtExceptionHandler((t, e) -> log.error(\"thread \" + t.getName() + \" have a exception\", e))\n                .build();\n\n        return new ThreadPoolExecutor(20, 100,0L, TimeUnit.MILLISECONDS,\n                new LinkedBlockingQueue<>(1024), factory, new ThreadPoolExecutor.AbortPolicy());\n    }\n\n}\n", "    public ExecutorService executorService() {\n        BasicThreadFactory factory = new BasicThreadFactory.Builder()\n                .namingPattern(\"canal-execute-thread-%d\")\n                .uncaughtExceptionHandler((t, e) -> log.error(\"thread \" + t.getName() + \" have a exception\", e))\n                .build();\n\n        return new ThreadPoolExecutor(20, 100,0L, TimeUnit.MILLISECONDS,\n                new LinkedBlockingQueue<>(1024), factory, new ThreadPoolExecutor.AbortPolicy());\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/autoconfigure/KafkaClientAutoConfiguration.java", "chunked_list": ["package io.xzxj.canal.spring.autoconfigure;\n\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.client.AbstractCanalClient;\nimport io.xzxj.canal.core.client.KafkaCanalClient;\nimport io.xzxj.canal.core.factory.MapConvertFactory;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.handler.impl.AsyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.MapRowDataHandlerImpl;", "import io.xzxj.canal.core.handler.impl.AsyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.MapRowDataHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.SyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.spring.properties.CanalProperties;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;", "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\n\n/**\n * @author xzxj", "/**\n * @author xzxj\n * @date 2023/3/15 13:51\n */\n@EnableConfigurationProperties(CanalProperties.class)\n@ConditionalOnProperty(value = \"canal.server-mode\", havingValue = \"kafka\")\n@Import(ThreadPoolAutoConfiguration.class)\npublic class KafkaClientAutoConfiguration {\n\n    private final CanalProperties canalProperties;\n\n    public KafkaClientAutoConfiguration(CanalProperties canalProperties) {\n        this.canalProperties = canalProperties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(RowDataHandler.class)\n    public RowDataHandler<List<Map<String, String>>> rowDataHandler() {\n        return new MapRowDataHandlerImpl(new MapConvertFactory());\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"true\", matchIfMissing = true)\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<FlatMessage> asyncFlatMessageHandler(RowDataHandler<List<Map<String, String>>> rowDataHandler,\n                                                                List<EntryListener<?>> entryHandlers,\n                                                                ExecutorService executorService) {\n        return new AsyncFlatMessageHandlerImpl(entryHandlers, rowDataHandler, executorService);\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"false\")\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<FlatMessage> syncFlatMessageHandler(RowDataHandler<List<Map<String, String>>> rowDataHandler,\n                                                               List<EntryListener<?>> entryHandlers) {\n        return new SyncFlatMessageHandlerImpl(entryHandlers, rowDataHandler);\n    }\n\n    @Bean(initMethod = \"init\", destroyMethod = \"destroy\")\n    @ConditionalOnMissingBean(AbstractCanalClient.class)", "    public KafkaCanalClient kafkaCanalClient(IMessageHandler<FlatMessage> messageHandler) {\n        return KafkaCanalClient.builder().servers(canalProperties.getServer())\n                .groupId(canalProperties.getKafka().getGroupId())\n                .topic(canalProperties.getDestination())\n                .partition(canalProperties.getKafka().getPartition())\n                .messageHandler(messageHandler)\n                .batchSize(canalProperties.getBatchSize())\n                .filter(canalProperties.getFilter())\n                .timeout(canalProperties.getTimeout())\n                .unit(canalProperties.getUnit())\n                .build();\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/autoconfigure/RabbitMqClientAutoConfiguration.java", "chunked_list": ["package io.xzxj.canal.spring.autoconfigure;\n\nimport com.alibaba.otter.canal.protocol.FlatMessage;\nimport io.xzxj.canal.core.client.AbstractCanalClient;\nimport io.xzxj.canal.core.client.RabbitMqCanalClient;\nimport io.xzxj.canal.core.factory.MapConvertFactory;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.handler.impl.AsyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.MapRowDataHandlerImpl;", "import io.xzxj.canal.core.handler.impl.AsyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.MapRowDataHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.SyncFlatMessageHandlerImpl;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.spring.properties.CanalProperties;\nimport io.xzxj.canal.spring.properties.CanalRabbitMqProperties;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;", "import org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Import;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\n\n/**\n * @author xzxj", "/**\n * @author xzxj\n * @date 2023/3/24 9:49\n */\n@EnableConfigurationProperties(CanalProperties.class)\n@ConditionalOnProperty(value = \"canal.server-mode\", havingValue = \"rabbit_mq\")\n@Import(ThreadPoolAutoConfiguration.class)\npublic class RabbitMqClientAutoConfiguration {\n\n    private final CanalProperties canalProperties;\n\n    public RabbitMqClientAutoConfiguration(CanalProperties canalProperties) {\n        this.canalProperties = canalProperties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(RowDataHandler.class)\n    public RowDataHandler<List<Map<String, String>>> rowDataHandler() {\n        return new MapRowDataHandlerImpl(new MapConvertFactory());\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"true\", matchIfMissing = true)\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<FlatMessage> asyncFlatMessageHandler(RowDataHandler<List<Map<String, String>>> rowDataHandler,\n                                                                List<EntryListener<?>> entryListenerList,\n                                                                ExecutorService executorService) {\n        return new AsyncFlatMessageHandlerImpl(entryListenerList, rowDataHandler, executorService);\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"false\")\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<FlatMessage> syncFlatMessageHandler(RowDataHandler<List<Map<String, String>>> rowDataHandler,\n                                                               List<EntryListener<?>> entryListenerList) {\n        return new SyncFlatMessageHandlerImpl(entryListenerList, rowDataHandler);\n    }\n\n    @Bean(initMethod = \"init\", destroyMethod = \"destroy\")\n    @ConditionalOnMissingBean(AbstractCanalClient.class)", "    public RabbitMqCanalClient rabbitMqCanalClient(IMessageHandler<FlatMessage> messageHandler) {\n        CanalRabbitMqProperties mqProperties = canalProperties.getRabbitMq();\n        return RabbitMqCanalClient.builder().servers(canalProperties.getServer())\n                .virtualHost(mqProperties.getVirtualHost())\n                .queueName(canalProperties.getDestination())\n                .accessKey(mqProperties.getAccessKey())\n                .secretKey(mqProperties.getSecretKey())\n                .resourceOwnerId(mqProperties.getResourceOwnerId())\n                .username(mqProperties.getUsername())\n                .password(mqProperties.getPassword())\n                .messageHandler(messageHandler)\n                .batchSize(canalProperties.getBatchSize())\n                .filter(canalProperties.getFilter())\n                .timeout(canalProperties.getTimeout())\n                .unit(canalProperties.getUnit())\n                .build();\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/autoconfigure/TcpClientAutoConfiguration.java", "chunked_list": ["package io.xzxj.canal.spring.autoconfigure;\n\nimport com.alibaba.otter.canal.protocol.CanalEntry;\nimport com.alibaba.otter.canal.protocol.Message;\nimport io.xzxj.canal.core.client.AbstractCanalClient;\nimport io.xzxj.canal.core.client.TcpCanalClient;\nimport io.xzxj.canal.core.factory.EntryColumnConvertFactory;\nimport io.xzxj.canal.core.handler.IMessageHandler;\nimport io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.handler.impl.AsyncMessageHandlerImpl;", "import io.xzxj.canal.core.handler.RowDataHandler;\nimport io.xzxj.canal.core.handler.impl.AsyncMessageHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.RowDataHandlerImpl;\nimport io.xzxj.canal.core.handler.impl.SyncMessageHandlerImpl;\nimport io.xzxj.canal.core.listener.EntryListener;\nimport io.xzxj.canal.spring.properties.CanalProperties;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;", "import org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Import;\n\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\n\n/**\n * @author xzxj\n * @date 2023/3/11 11:37", " * @author xzxj\n * @date 2023/3/11 11:37\n */\n@EnableConfigurationProperties(CanalProperties.class)\n@ConditionalOnProperty(value = \"canal.server-mode\", havingValue = \"tcp\")\n@Import(ThreadPoolAutoConfiguration.class)\npublic class TcpClientAutoConfiguration {\n\n    private final CanalProperties canalProperties;\n\n    public TcpClientAutoConfiguration(CanalProperties canalProperties) {\n        this.canalProperties = canalProperties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(RowDataHandler.class)\n    public RowDataHandler<CanalEntry.RowData> rowDataHandler() {\n        return new RowDataHandlerImpl(new EntryColumnConvertFactory());\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"true\", matchIfMissing = true)\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<Message> asyncMessageHandler(List<EntryListener<?>> entryListenerList,\n                                                        RowDataHandler<CanalEntry.RowData> rowDataHandler,\n                                                        ExecutorService executorService) {\n        return new AsyncMessageHandlerImpl(entryListenerList, rowDataHandler, executorService);\n    }\n\n    @Bean\n    @ConditionalOnProperty(value = \"canal.async\", havingValue = \"false\")\n    @ConditionalOnMissingBean(IMessageHandler.class)\n    public IMessageHandler<Message> syncMessageHandler(List<EntryListener<?>> entryListenerList,\n                                                       RowDataHandler<CanalEntry.RowData> rowDataHandler) {\n        return new SyncMessageHandlerImpl(entryListenerList, rowDataHandler);\n    }\n\n    @Bean(initMethod = \"init\", destroyMethod = \"destroy\")\n    @ConditionalOnMissingBean(AbstractCanalClient.class)", "    public TcpCanalClient tcpCanalClient(IMessageHandler<Message> messageHandler) {\n        String server = canalProperties.getServer();\n        String[] array = server.split(\":\");\n        return TcpCanalClient.builder()\n                .hostname(array[0])\n                .port(Integer.parseInt(array[1]))\n                .destination(canalProperties.getDestination())\n                .username(canalProperties.getUsername())\n                .password(canalProperties.getPassword())\n                .messageHandler(messageHandler)\n                .batchSize(canalProperties.getBatchSize())\n                .filter(canalProperties.getFilter())\n                .timeout(canalProperties.getTimeout())\n                .unit(canalProperties.getUnit())\n                .build();\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/properties/CanalProperties.java", "chunked_list": ["package io.xzxj.canal.spring.properties;\n\nimport io.xzxj.canal.spring.enums.CanalServerMode;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.context.properties.NestedConfigurationProperty;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author xzxj", "/**\n * @author xzxj\n * @date 2023/3/11 11:36\n */\n@ConfigurationProperties(\"canal\")\npublic class CanalProperties {\n\n    private CanalServerMode serverMode = CanalServerMode.TCP;\n\n    private Boolean async = true;\n\n    private String destination = \"example\";\n\n    private String server = \"127.0.0.1:11111\";\n\n    private String filter = \"\";\n\n    private String username;\n\n    private String password;\n\n    private Integer batchSize = 1;\n\n    private Long timeout = 1L;\n\n    private TimeUnit unit = TimeUnit.SECONDS;\n\n    @NestedConfigurationProperty\n    private CanalKafkaProperties kafka;\n\n    @NestedConfigurationProperty\n    private CanalRabbitMqProperties rabbitMq;\n", "    public CanalServerMode getServerMode() {\n        return serverMode;\n    }\n\n    public void setServerMode(CanalServerMode serverMode) {\n        this.serverMode = serverMode;\n    }\n\n    public Boolean getAsync() {\n        return async;\n    }\n", "    public Boolean getAsync() {\n        return async;\n    }\n\n    public void setAsync(Boolean async) {\n        this.async = async;\n    }\n\n    public String getDestination() {\n        return destination;\n    }\n", "    public String getDestination() {\n        return destination;\n    }\n\n    public void setDestination(String destination) {\n        this.destination = destination;\n    }\n\n    public String getServer() {\n        return server;\n    }\n", "    public String getServer() {\n        return server;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getFilter() {\n        return filter;\n    }\n", "    public String getFilter() {\n        return filter;\n    }\n\n    public void setFilter(String filter) {\n        this.filter = filter;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n", "    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n", "    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public Integer getBatchSize() {\n        return batchSize;\n    }\n", "    public Integer getBatchSize() {\n        return batchSize;\n    }\n\n    public void setBatchSize(Integer batchSize) {\n        this.batchSize = batchSize;\n    }\n\n    public Long getTimeout() {\n        return timeout;\n    }\n", "    public Long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(Long timeout) {\n        this.timeout = timeout;\n    }\n\n    public TimeUnit getUnit() {\n        return unit;\n    }\n", "    public TimeUnit getUnit() {\n        return unit;\n    }\n\n    public void setUnit(TimeUnit unit) {\n        this.unit = unit;\n    }\n\n    public CanalKafkaProperties getKafka() {\n        return kafka;\n    }\n", "    public CanalKafkaProperties getKafka() {\n        return kafka;\n    }\n\n    public void setKafka(CanalKafkaProperties kafka) {\n        this.kafka = kafka;\n    }\n\n    public CanalRabbitMqProperties getRabbitMq() {\n        return rabbitMq;\n    }\n", "    public CanalRabbitMqProperties getRabbitMq() {\n        return rabbitMq;\n    }\n\n    public void setRabbitMq(CanalRabbitMqProperties rabbitMq) {\n        this.rabbitMq = rabbitMq;\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/properties/CanalKafkaProperties.java", "chunked_list": ["package io.xzxj.canal.spring.properties;\n\n/**\n * @author xzxj\n * @date 2023/3/15 13:56\n */\npublic class CanalKafkaProperties {\n\n\n    private Integer partition;\n\n    private String groupId;\n", "    public Integer getPartition() {\n        return partition;\n    }\n\n    public void setPartition(Integer partition) {\n        this.partition = partition;\n    }\n\n    public String getGroupId() {\n        return groupId;\n    }\n", "    public String getGroupId() {\n        return groupId;\n    }\n\n    public void setGroupId(String groupId) {\n        this.groupId = groupId;\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/properties/CanalRabbitMqProperties.java", "chunked_list": ["package io.xzxj.canal.spring.properties;\n\n/**\n * @author xzxj\n * @date 2023/3/24 9:36\n */\npublic class CanalRabbitMqProperties {\n\n    // \u4e3b\u673a\u540d\n    private String virtualHost = \"/\";\n\n    // \u4e00\u4e9b\u9274\u6743\u4fe1\u606f\n    private String accessKey = \"\";\n    private String secretKey = \"\";\n    private Long resourceOwnerId;\n    private String username = \"guest\";\n    private String password = \"guest\";\n", "    public String getVirtualHost() {\n        return virtualHost;\n    }\n\n    public void setVirtualHost(String virtualHost) {\n        this.virtualHost = virtualHost;\n    }\n\n    public String getAccessKey() {\n        return accessKey;\n    }\n", "    public String getAccessKey() {\n        return accessKey;\n    }\n\n    public void setAccessKey(String accessKey) {\n        this.accessKey = accessKey;\n    }\n\n    public String getSecretKey() {\n        return secretKey;\n    }\n", "    public String getSecretKey() {\n        return secretKey;\n    }\n\n    public void setSecretKey(String secretKey) {\n        this.secretKey = secretKey;\n    }\n\n    public Long getResourceOwnerId() {\n        return resourceOwnerId;\n    }\n", "    public Long getResourceOwnerId() {\n        return resourceOwnerId;\n    }\n\n    public void setResourceOwnerId(Long resourceOwnerId) {\n        this.resourceOwnerId = resourceOwnerId;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n", "    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n", "    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/registrar/CanalListenerScanner.java", "chunked_list": ["package io.xzxj.canal.spring.registrar;\n\nimport io.xzxj.canal.core.annotation.CanalListener;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathBeanDefinitionScanner;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\nimport org.springframework.lang.NonNull;\n\nimport java.util.Set;", "\nimport java.util.Set;\n\n/**\n * @author xzxj\n * @date 2023/3/16 14:13\n */\npublic class CanalListenerScanner extends ClassPathBeanDefinitionScanner {\n\n    public CanalListenerScanner(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n\n    @NonNull\n    @Override\n    protected Set<BeanDefinitionHolder> doScan(@NonNull String... basePackages) {\n        // \u6dfb\u52a0\u8fc7\u6ee4\u6761\u4ef6\uff0c\u8fd9\u91cc\u662f\u53ea\u6dfb\u52a0\u4e86@CanalListener\u7684\u6ce8\u89e3\u624d\u4f1a\u88ab\u626b\u63cf\u5230\n        addIncludeFilter(new AnnotationTypeFilter(CanalListener.class));\n        // \u8c03\u7528spring\u7684\u626b\u63cf\n        return super.doScan(basePackages);\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/registrar/CanalListenerRegistrar.java", "chunked_list": ["package io.xzxj.canal.spring.registrar;\n\nimport io.xzxj.canal.core.annotation.CanalListener;\nimport io.xzxj.canal.spring.annotation.EnableCanalListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.ResourceLoaderAware;\nimport org.springframework.context.annotation.AnnotationBeanNameGenerator;", "import org.springframework.context.ResourceLoaderAware;\nimport org.springframework.context.annotation.AnnotationBeanNameGenerator;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.StandardAnnotationMetadata;\nimport org.springframework.lang.NonNull;\n\n/**", "\n/**\n * @author xzxj\n * @date 2023/3/14 19:47\n */\npublic class CanalListenerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {\n\n    private static final Logger log = LoggerFactory.getLogger(CanalListenerRegistrar.class);\n\n    private ResourceLoader resourceLoader;\n\n    @Override", "    public void setResourceLoader(@NonNull ResourceLoader resourceLoader) {\n        this.resourceLoader = resourceLoader;\n    }\n\n    @Override\n    public void registerBeanDefinitions(@NonNull AnnotationMetadata metadata,\n                                        @NonNull BeanDefinitionRegistry registry) {\n\n\n        AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(EnableCanalListener.class.getName()));\n        // \u83b7\u53d6\u5230basePackage\u7684\u503c\n        assert annoAttrs != null;\n        String[] basePackages = annoAttrs.getStringArray(\"basePackages\");\n        // \u5982\u679c\u6ca1\u6709\u8bbe\u7f6ebasePackage \u626b\u63cf\u8def\u5f84,\u5c31\u626b\u63cf\u5bf9\u5e94\u5305\u4e0b\u9762\u7684\u503c", "        if (basePackages.length == 0) {\n            basePackages = new String[]{((StandardAnnotationMetadata) metadata).getIntrospectedClass().getPackage().getName()};\n        }\n\n        CanalListenerScanner scanHandle = new CanalListenerScanner(registry);\n\n        if (resourceLoader != null) {\n            scanHandle.setResourceLoader(resourceLoader);\n        }\n        // \u8fd9\u91cc\u5b9e\u73b0\u7684\u662f\u6839\u636e\u540d\u79f0\u6765\u6ce8\u5165\n        scanHandle.setBeanNameGenerator(new BeanNameGenerator());\n        // \u626b\u63cf\u6307\u5b9a\u8def\u5f84\u4e0b\u7684\u63a5\u53e3\n        scanHandle.doScan(basePackages);\n    }\n\n    static class BeanNameGenerator extends AnnotationBeanNameGenerator {\n        @NonNull\n        @Override", "        public String generateBeanName(@NonNull BeanDefinition definition, @NonNull BeanDefinitionRegistry registry) {\n            String name = getBeanNameByAnnotation(definition);\n            if (name != null && !\"\".equals(name)) {\n                return name;\n            }\n            return super.generateBeanName(definition, registry);\n        }\n\n        private String getBeanNameByAnnotation(BeanDefinition definition) {\n            String beanClassName = definition.getBeanClassName();\n            try {\n                Class<?> clazz = Class.forName(beanClassName);\n                CanalListener annotation = clazz.getAnnotation(CanalListener.class);", "            try {\n                Class<?> clazz = Class.forName(beanClassName);\n                CanalListener annotation = clazz.getAnnotation(CanalListener.class);\n                if (annotation == null) {\n                    return null;\n                }\n                return annotation.name();\n            } catch (ClassNotFoundException e) {\n                log.error(e.getMessage(), e);\n            }\n            return null;\n        }\n    }\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/enums/CanalServerMode.java", "chunked_list": ["package io.xzxj.canal.spring.enums;\n\n/**\n * @author xzxj\n * @date 2023/3/11 11:38\n */\npublic enum CanalServerMode {\n\n    TCP,\n    KAFKA,\n    ROCKET_MQ,\n    RABBIT_MQ,\n    PULSAR_MQ,\n\n}\n"]}
{"filename": "canal-spring-boot-starter/src/main/java/io/xzxj/canal/spring/annotation/EnableCanalListener.java", "chunked_list": ["package io.xzxj.canal.spring.annotation;\n\nimport io.xzxj.canal.spring.registrar.CanalListenerRegistrar;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.annotation.AliasFor;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;", "import java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author xzxj\n * @date 2023/3/11 16:40\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)", "@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Import(CanalListenerRegistrar.class)\npublic @interface EnableCanalListener {\n\n    @AliasFor(\"basePackages\")\n    String[] value() default {};\n\n    @AliasFor(\"value\")", "\n    @AliasFor(\"value\")\n    String[] basePackages() default {};\n\n}\n\n"]}
