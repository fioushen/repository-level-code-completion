{"filename": "proxy/src/test/java/com/github/wandererex/wormhole/proxy/ProxyTest.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\npublic class ProxyTest {\n}\n"]}
{"filename": "proxy/src/test/java/com/github/wandererex/wormhole/proxy/ProxyServer.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;", "import io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class ProxyServer {\n    private int port;\n\n    private ChannelFuture channelFuture;\n    public ProxyServer(int port) {\n        this.port = port;\n    }\n", "    public void open() {\n        EventLoopGroup boss = new NioEventLoopGroup();\n        EventLoopGroup worker = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        bootstrap.group(boss, worker)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new FrameDecoder());\n                        pipeline.addLast(new FrameEncoder());\n                        pipeline.addLast(new PackageDecoder());\n                        pipeline.addLast(new PackageEncoder());\n                        pipeline.addLast(new SimpleChannelInboundHandler<Frame>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, Frame msg) throws Exception {\n                                System.out.println(\"read: \" + msg);", "                                if (msg.getOpCode() == 0x1) {\n                                    msg.setOpCode(0x11);\n                                    ctx.writeAndFlush(msg);\n                                    System.out.println(\"write: \" + msg);\n                                }\n                                if (msg.getOpCode() == 0x5) {\n                                    Frame frame = new Frame(0x6, null, null);\n                                    ctx.writeAndFlush(frame);\n                                    System.out.println(\"write: \" + frame);\n                                }\n                            }\n                        });\n                        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));\n                    }\n                });\n", "        try {\n            channelFuture = bootstrap.bind(port).sync();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        channelFuture.addListener((future) -> {\n            if (!future.isSuccess()) {\n                future.cause().printStackTrace();\n            }\n\n        });\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            boss.shutdownGracefully().syncUninterruptibly();\n            worker.shutdownGracefully().syncUninterruptibly();\n        }));\n    }\n", "    public void close() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new ProxyServer(8090).open();\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/FrameDecoder.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n\npublic class FrameDecoder extends LengthFieldBasedFrameDecoder {\n    public FrameDecoder() {\n        super(10240, 0, 2, 0, 2);\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/Proxy.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.ProxyServiceConfig;\nimport io.netty.channel.Channel;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.nio.charset.StandardCharsets;", "\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\n\npublic class Proxy {\n    public static CountDownLatch latch = new CountDownLatch(1);\n    private String serverHost;\n\n    private Integer serverPort;\n\n    private ProxyServiceConfig config;\n\n    private Channel channel;\n\n    private ProxyClient client;\n\n    public Proxy() throws Exception {\n        String configPath = \"/config.json\";\n        this.config = ConfigLoader.load(configPath);\n        this.serverHost = config.getServerHost();\n        this.serverPort = config.getServerPort();\n        client = new ProxyClient(config);\n    }\n", "    public void start() throws Exception {\n        channel = client.connect(serverHost, serverPort);\n        online(channel);\n        client.syncAuth();\n        client.checkIdle();\n        latch.await();\n    }\n\n    private void online(Channel channel) {\n        JSONObject jsonObject = new JSONObject();\n        for (Map.Entry<String, ProxyServiceConfig.ServiceConfig> entry : config.getServiceConfigMap().entrySet()){\n            jsonObject.put(entry.getKey(), JSON.toJSONString(entry.getValue()));\n        }\n        String string = jsonObject.toJSONString();\n        Frame frame = new Frame(0x1, null, string.getBytes(StandardCharsets.UTF_8));\n        channel.writeAndFlush(frame);\n    }\n", "        for (Map.Entry<String, ProxyServiceConfig.ServiceConfig> entry : config.getServiceConfigMap().entrySet()){\n            jsonObject.put(entry.getKey(), JSON.toJSONString(entry.getValue()));\n        }\n        String string = jsonObject.toJSONString();\n        Frame frame = new Frame(0x1, null, string.getBytes(StandardCharsets.UTF_8));\n        channel.writeAndFlush(frame);\n    }\n\n    public static void main(String[] args) throws Exception {\n        Proxy proxy = new Proxy();\n        proxy.start();\n    }\n}\n", "    public static void main(String[] args) throws Exception {\n        Proxy proxy = new Proxy();\n        proxy.start();\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/PackageEncoder.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.FrameSerialization;\nimport com.github.wandererex.wormhole.serialize.Serialization;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.MessageToMessageEncoder;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class PackageEncoder extends MessageToMessageEncoder<Frame> {\n    private Serialization<Frame> serialization = new FrameSerialization();\n\n    public PackageEncoder() {\n    }\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Frame pkg, List<Object> out) throws Exception {\n        ByteBuf buffer = ctx.alloc().buffer();\n        ByteBuf buf = serialization.serialize(pkg, buffer);\n        out.add(buf);\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/PackageDecoder.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.FrameSerialization;\nimport com.github.wandererex.wormhole.serialize.Serialization;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.MessageToMessageDecoder;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class PackageDecoder extends MessageToMessageDecoder<ByteBuf> {\n    private Serialization<Frame> serialization = new FrameSerialization();\n\n    public PackageDecoder() {\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {\n        Frame pkg = serialization.deserialize(byteBuf);\n        out.add(pkg);\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/ProxyClient.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.github.wandererex.wormhole.serialize.*;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;", "import io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\npublic class ProxyClient {\n    private Bootstrap clientBootstrap;\n\n    private NioEventLoopGroup clientGroup;\n\n    private Channel channel;\n\n    private Channel channel1;\n\n    private String serviceKey;\n\n    private volatile boolean connectSuccess = false;\n\n    private volatile boolean authSuccess = false;\n\n    private long lastHeatbeatTime;\n\n    private ChannelPromise channelPromise;\n\n    public ProxyClient(ProxyServiceConfig config) {\n        this.clientBootstrap = new Bootstrap();\n        this.clientGroup = new NioEventLoopGroup();", "        if (config == null) {\n            clientBootstrap.group(clientGroup).channel(NioSocketChannel.class)\n                    .option(ChannelOption.TCP_NODELAY, true)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        //\u521d\u59cb\u5316\u65f6\u5c06handler\u8bbe\u7f6e\u5230ChannelPipeline\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            //ch.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(10 * 3, 15 * 3, 20 * 3));\n                            //ch.pipeline().addLast(new FixedLengthFrameDecoder(20));\n                            ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {\n                                @Override", "                                public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                                    Frame frame = new Frame(0xB, serviceKey, null);\n                                    channel1.writeAndFlush(frame);\n                                    ctx.fireChannelInactive();\n                                }\n                                @Override\n                                protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {\n                                    if (channel1 != null) {\n                                        byte[] bytes = new byte[msg.readableBytes()];\n                                        msg.readBytes(bytes, 0, bytes.length);\n                                        List<Frame> frames = NetworkUtil.byteArraytoFrameList(bytes, serviceKey);\n                                        log.info(\"proxy read from service data {}\", bytes);", "                                        for (Frame frame : frames) {\n                                            TaskExecutor.get().addTask(new Task(channel1, frame));\n                                        }\n                                    }\n                                }\n                            });\n                            ch.pipeline().addLast(\"logs\", new LoggingHandler(LogLevel.DEBUG));\n                        }\n                    });\n        }\n        else {\n            clientBootstrap.group(clientGroup).channel(NioSocketChannel.class)\n                    .option(ChannelOption.TCP_NODELAY, true)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        //\u521d\u59cb\u5316\u65f6\u5c06handler\u8bbe\u7f6e\u5230ChannelPipeline\n                        @Override", "                        public void initChannel(SocketChannel ch) {\n                            //ch.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(10 * 3, 15 * 3, 20 * 3));\n                            ch.pipeline().addLast(new FrameDecoder());\n                            ch.pipeline().addLast(new FrameEncoder());\n                            ch.pipeline().addLast(new PackageDecoder());\n                            ch.pipeline().addLast(new PackageEncoder());\n                            ch.pipeline().addLast(new ProxyHandler(ProxyClient.this, config));\n                            ch.pipeline().addLast(\"logs\", new LoggingHandler(LogLevel.DEBUG));\n                        }\n                    });\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            Proxy.latch.countDown();\n            clientGroup.shutdownGracefully().syncUninterruptibly();\n        }));\n    }\n", "    public void setChannel1(Channel channel1) {\n        this.channel1 = channel1;\n    }\n\n    public void setServiceKey(String serviceKey) {\n        this.serviceKey = serviceKey;\n    }\n\n    public Channel connect(String ip, int port) throws Exception {\n        /**\n         * \u6700\u591a\u5c1d\u8bd55\u6b21\u548c\u670d\u52a1\u7aef\u8fde\u63a5\n         */\n        this.channel = doConnect(ip, port, 5);\n        this.channelPromise = new DefaultChannelPromise(this.channel);\n        this.connectSuccess = true;\n        return this.channel;\n    }\n\n    private Channel doConnect(String ip, int port, int retry) throws InterruptedException {\n        ChannelFuture future = null;", "    public Channel connect(String ip, int port) throws Exception {\n        /**\n         * \u6700\u591a\u5c1d\u8bd55\u6b21\u548c\u670d\u52a1\u7aef\u8fde\u63a5\n         */\n        this.channel = doConnect(ip, port, 5);\n        this.channelPromise = new DefaultChannelPromise(this.channel);\n        this.connectSuccess = true;\n        return this.channel;\n    }\n\n    private Channel doConnect(String ip, int port, int retry) throws InterruptedException {\n        ChannelFuture future = null;", "        for (int i = retry; i > 0; i--) {\n            try {\n                future = clientBootstrap.connect(ip, port).sync();\n            } catch (InterruptedException e) {\n                log.debug(\"debug:connect business server fail, client \" + NetworkUtil.getLocalHost() + \", server \" + ip + \":\" + port);\n            }\n            if (future.isSuccess()) {\n                return future.channel();\n            }\n            Thread.sleep(5000);\n        }\n        throw new RuntimeException(\"connect business server fail, client \" + NetworkUtil.getLocalHost() + \", server \" + ip + \":\" + port);\n    }\n", "    public void disconnect() throws Exception {\n        if (!connectSuccess) {\n            log.error(\"no connect!\");\n            return;\n        }\n        channel.close().sync();\n        connectSuccess = false;\n    }\n\n    public void send(Frame frame) throws Exception {\n        if (!connectSuccess) {\n            throw new RuntimeException(\"no connect!\");\n        }\n        channel.writeAndFlush(frame).sync();\n    }\n", "    public void send(Frame frame) throws Exception {\n        if (!connectSuccess) {\n            throw new RuntimeException(\"no connect!\");\n        }\n        channel.writeAndFlush(frame).sync();\n    }\n\n    public void authSuccess() {\n        this.authSuccess = true;\n        channelPromise.setSuccess();\n    }\n", "    public void shutdown() throws Exception {\n        disconnect();\n        clientGroup.shutdownGracefully().syncUninterruptibly();\n        Proxy.latch.countDown();\n    }\n\n    public void updateHeatbeatTime() {\n        lastHeatbeatTime = System.currentTimeMillis();\n    }\n\n    public void checkIdle() {\n        ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(2);\n        scheduledExecutorService.scheduleWithFixedDelay(() -> {", "    public void checkIdle() {\n        ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(2);\n        scheduledExecutorService.scheduleWithFixedDelay(() -> {\n            if (lastHeatbeatTime > 0) {\n                if (System.currentTimeMillis() - lastHeatbeatTime > 15000) {\n                    try {\n                        shutdown();\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        }, 5, 5, TimeUnit.SECONDS);\n        scheduledExecutorService.scheduleWithFixedDelay(() -> {\n            Frame frame = new Frame(0x5, null, null);\n            channel.writeAndFlush(frame);\n        }, 5, 5, TimeUnit.SECONDS);\n    }\n", "    public void syncAuth() throws InterruptedException {\n        channelPromise.sync();\n    }\n\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/FrameEncoder.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport io.netty.handler.codec.LengthFieldPrepender;\n\npublic class FrameEncoder extends LengthFieldPrepender {\n    public FrameEncoder() {\n        super(2);\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/ProxyHandler.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.ProxyServiceConfig;\nimport com.github.wandererex.wormhole.serialize.Task;\nimport com.github.wandererex.wormhole.serialize.TaskExecutor;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;", "import io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n@Slf4j\npublic class ProxyHandler extends SimpleChannelInboundHandler<Frame> {\n    private ProxyServiceConfig config;\n\n    private ConcurrentMap<String, Channel> map = new ConcurrentHashMap<>();\n\n    private ProxyClient proxyClient;\n\n    public ProxyHandler(ProxyClient proxyClient, ProxyServiceConfig config) {\n        this.config = config;\n        this.proxyClient = proxyClient;\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Frame msg) throws Exception {\n        int opCode = msg.getOpCode();\n        String serviceKey = msg.getServiceKey();\n        byte[] payload = msg.getPayload();", "\n@Slf4j\npublic class ProxyHandler extends SimpleChannelInboundHandler<Frame> {\n    private ProxyServiceConfig config;\n\n    private ConcurrentMap<String, Channel> map = new ConcurrentHashMap<>();\n\n    private ProxyClient proxyClient;\n\n    public ProxyHandler(ProxyClient proxyClient, ProxyServiceConfig config) {\n        this.config = config;\n        this.proxyClient = proxyClient;\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Frame msg) throws Exception {\n        int opCode = msg.getOpCode();\n        String serviceKey = msg.getServiceKey();\n        byte[] payload = msg.getPayload();", "        if (opCode == 0x9) {\n            ProxyServiceConfig.ServiceConfig serviceConfig = config.getServiceConfig(serviceKey);\n            ProxyClient proxyClient = new ProxyClient(null);\n            proxyClient.setChannel1(ctx.channel());\n            proxyClient.setServiceKey(serviceKey);\n            try {\n                Channel channel = proxyClient.connect(serviceConfig.getIp(), serviceConfig.getPort());\n                map.put(serviceKey, channel);\n                Frame frame = new Frame(0x91, serviceKey, null);\n                ctx.writeAndFlush(frame);\n            } catch (Exception e) {\n                Frame frame = new Frame(0x90, serviceKey, null);\n                ctx.writeAndFlush(frame);\n            }", "        } else if (opCode == 0x3) {\n            Channel channel = map.get(serviceKey);\n            if (channel == null) {\n                Frame frame = new Frame(0x40, serviceKey, null);\n                ctx.writeAndFlush(frame);\n            } else {\n                log.info(\"proxy send to service data {}\", payload);\n                TaskExecutor.get().addTask(new Task(channel, Unpooled.copiedBuffer(payload)));\n                Frame frame = new Frame(0x41, serviceKey, null);\n                ctx.writeAndFlush(frame);\n            }", "        } else if (opCode == 0x10) {\n            log.error(\"proxy connect server error\");\n            close();\n        } else if (opCode == 0x11) {\n            log.info(\"proxy connect server success\");\n            proxyClient.authSuccess();\n        } else if (opCode == 0x6) {\n            log.info(\"proxy update heatbeat time\");\n            proxyClient.updateHeatbeatTime();\n        } else if (opCode == 0x81) {\n            log.info(\"proxy offline success\");\n            close();", "        } else if (opCode == 0x81) {\n            log.info(\"proxy offline success\");\n            close();\n        } else if (opCode == 0x80) {\n            log.error(\"proxy offline error\");\n        } else if (opCode == 0x7) {\n            log.info(\"server offline\");\n            Frame frame = new Frame(0x81, null, null);\n            proxyClient.send(frame);\n            close();\n        } else if (opCode == 0xA) {\n            log.info(\"server offline\");\n            Channel channel = map.get(serviceKey);", "        } else if (opCode == 0xA) {\n            log.info(\"server offline\");\n            Channel channel = map.get(serviceKey);\n            if (channel != null) {\n                channel.close();\n            }\n        }\n    }\n\n    private void close() throws Exception {\n        proxyClient.shutdown();", "        for (Channel channel : map.values()) {\n            channel.close();\n        }\n    }\n}\n"]}
{"filename": "proxy/src/main/java/com/github/wandererex/wormhole/proxy/ConfigLoader.java", "chunked_list": ["package com.github.wandererex.wormhole.proxy;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.github.wandererex.wormhole.serialize.ProxyServiceConfig;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;", "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class ConfigLoader {\n    public static ProxyServiceConfig load(String path) throws IOException {\n        InputStream inputStream = ConfigLoader.class.getResourceAsStream(path);\n        byte[] bytes = IOUtils.toByteArray(inputStream);\n        String s = new String(bytes, StandardCharsets.UTF_8);\n        JSONObject jsonObject = JSON.parseObject(s);\n        ProxyServiceConfig proxyServiceConfig = new ProxyServiceConfig();", "        for (Map.Entry<String, Object> entry : jsonObject.entrySet()) {\n            if (entry.getValue() instanceof  JSONObject) {\n                proxyServiceConfig.addConfig(entry.getKey(), ((JSONObject) entry.getValue()).toJavaObject(ProxyServiceConfig.ServiceConfig.class));\n            }\n        }\n        proxyServiceConfig.setServerHost(jsonObject.getString(\"serverHost\"));\n        proxyServiceConfig.setServerPort(jsonObject.getInteger(\"serverPort\"));\n        return proxyServiceConfig;\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/FrameDecoder.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n\npublic class FrameDecoder extends LengthFieldBasedFrameDecoder {\n    public FrameDecoder() {\n        super(10240, 0, 2, 0, 2);\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/ForwardHandler.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.NetworkUtil;\nimport com.github.wandererex.wormhole.serialize.Task;\nimport com.github.wandererex.wormhole.serialize.TaskExecutor;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;", "import io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.util.Attribute;\nimport io.netty.util.AttributeKey;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;", "import java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n@ChannelHandler.Sharable\n@Slf4j\npublic class ForwardHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    private String serviceKey;\n    private Channel proxyChannel;\n\n    private Channel channel;\n\n    public ForwardHandler(String serviceKey, Channel proxyChannel) {\n        this.serviceKey = serviceKey;\n        this.proxyChannel = proxyChannel;\n    }\n", "    public void setChannel(Channel channel) {\n        this.channel = channel;\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {\n        if (channel == null || !channel.isActive()) {\n            ctx.fireChannelRead(msg);\n        }\n        AttributeKey<CountDownLatch> attributeKey = AttributeKey.valueOf(serviceKey);\n        Attribute<CountDownLatch> attr = proxyChannel.attr(attributeKey);", "        if (attr.get() != null) {\n            CountDownLatch latch = attr.get();\n            if (latch != null) {\n                latch.await();\n            }\n            attr.set(null);\n        }\n        byte[] bytes = new byte[msg.readableBytes()];\n        msg.readBytes(bytes, 0, bytes.length);\n        List<Frame> frames = NetworkUtil.byteArraytoFrameList(bytes, serviceKey);\n        for (Frame frame : frames) {\n            log.info(\"server mapping port read {}\", frame);\n            TaskExecutor.get().addTask(new Task(proxyChannel, frame));\n        }\n    }\n", "        for (Frame frame : frames) {\n            log.info(\"server mapping port read {}\", frame);\n            TaskExecutor.get().addTask(new Task(proxyChannel, frame));\n        }\n    }\n\n    public void send(byte[] buf) {\n        log.info(\"server send to client data {}, {}\", buf, channel);\n        channel.writeAndFlush(buf);\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/PackageEncoder.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.FrameSerialization;\nimport com.github.wandererex.wormhole.serialize.Serialization;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.MessageToMessageEncoder;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class PackageEncoder extends MessageToMessageEncoder<Frame> {\n    private Serialization<Frame> serialization = new FrameSerialization();\n\n    public PackageEncoder() {\n    }\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Frame pkg, List<Object> out) throws Exception {\n        ByteBuf buffer = ctx.alloc().buffer();\n        ByteBuf buf = serialization.serialize(pkg, buffer);\n        out.add(buf);\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/PackageDecoder.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.FrameSerialization;\nimport com.github.wandererex.wormhole.serialize.Serialization;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.MessageToMessageDecoder;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class PackageDecoder extends MessageToMessageDecoder<ByteBuf> {\n    private Serialization<Frame> serialization = new FrameSerialization();\n\n    public PackageDecoder() {\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {\n        Frame pkg = serialization.deserialize(byteBuf);\n        out.add(pkg);\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/ProxyServerHandler.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.ProxyServiceConfig;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;", "import io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.util.Attribute;\nimport io.netty.util.AttributeKey;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;", "import java.util.Map;\nimport java.util.concurrent.CountDownLatch;\n\n@Slf4j\npublic class ProxyServerHandler extends SimpleChannelInboundHandler<Frame> {\n    private Map<String, ProxyServer> proxyServerMap = new HashMap<>();\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Frame msg) throws Exception {\n        System.out.println(\"read: \" + msg);\n        if (msg.getOpCode() == 0x1) {\n            byte[] payload = msg.getPayload();\n            String s = new String(payload, StandardCharsets.UTF_8);\n            JSONObject jsonObject = JSON.parseObject(s);\n            ProxyServiceConfig proxyServiceConfig = new ProxyServiceConfig();", "        if (msg.getOpCode() == 0x1) {\n            byte[] payload = msg.getPayload();\n            String s = new String(payload, StandardCharsets.UTF_8);\n            JSONObject jsonObject = JSON.parseObject(s);\n            ProxyServiceConfig proxyServiceConfig = new ProxyServiceConfig();\n            for (Map.Entry<String, Object> entry : jsonObject.entrySet()) {\n                proxyServiceConfig.addConfig(entry.getKey(), JSON.parseObject((String) entry.getValue()).toJavaObject(ProxyServiceConfig.ServiceConfig.class));\n            }\n            buildForwardServer(proxyServiceConfig, ctx.channel());\n            msg.setOpCode(0x11);\n            ctx.writeAndFlush(msg);\n            System.out.println(\"write: \" + msg);\n        }", "        if (msg.getOpCode() == 0x5) {\n            Frame frame = new Frame(0x6, null, null);\n            ctx.writeAndFlush(frame);\n            System.out.println(\"write: \" + frame);\n        }\n        if (msg.getOpCode() == 0x91) {\n            AttributeKey<CountDownLatch> attributeKey = AttributeKey.valueOf(msg.getServiceKey());\n            Attribute<CountDownLatch> attr = ctx.attr(attributeKey);\n            CountDownLatch latch = attr.get();\n            if (latch != null) {\n                latch.countDown();\n            }\n        }", "            if (latch != null) {\n                latch.countDown();\n            }\n        }\n        if (msg.getOpCode() == 0x3) {\n            log.info(\"server read from proxy data {}\", msg);\n            ProxyServer proxyServer = proxyServerMap.get(msg.getServiceKey());\n            if (proxyServer != null) {\n                proxyServer.send(msg.getPayload());\n            }\n            Frame frame = new Frame(0x41, null, null);\n            ctx.writeAndFlush(frame);\n            System.out.println(\"write: \" + frame);\n        }", "        if (msg.getOpCode() == 0x40) {\n            System.out.println(\"write data error\");\n        }\n        if (msg.getOpCode() == 0x41) {\n            System.out.println(\"write data success\");\n        }\n        if (msg.getOpCode() == 0xB) {\n            log.info(\"server offline\");\n            ProxyServer proxyServer = proxyServerMap.get(msg.getServiceKey());\n            if (proxyServer != null) {\n                proxyServer.close();\n            }\n        }\n    }\n\n    private void buildForwardServer(ProxyServiceConfig config, Channel channel) {\n        Map<String, ProxyServiceConfig.ServiceConfig> serviceConfigMap = config.getServiceConfigMap();", "            if (proxyServer != null) {\n                proxyServer.close();\n            }\n        }\n    }\n\n    private void buildForwardServer(ProxyServiceConfig config, Channel channel) {\n        Map<String, ProxyServiceConfig.ServiceConfig> serviceConfigMap = config.getServiceConfigMap();\n        for (Map.Entry<String, ProxyServiceConfig.ServiceConfig> config1 : serviceConfigMap.entrySet()) {\n            ProxyServer proxyServer = new ProxyServer(config1.getKey(), config1.getValue().getMappingPort(), channel);\n            proxyServerMap.put(config1.getKey(), proxyServer);\n            proxyServer.open();\n            log.info(\"port mapping open {} {} {}\", config1.getKey(), config1.getValue().getPort(), config1.getValue().getMappingPort());\n        }\n    }\n}\n", "        for (Map.Entry<String, ProxyServiceConfig.ServiceConfig> config1 : serviceConfigMap.entrySet()) {\n            ProxyServer proxyServer = new ProxyServer(config1.getKey(), config1.getValue().getMappingPort(), channel);\n            proxyServerMap.put(config1.getKey(), proxyServer);\n            proxyServer.open();\n            log.info(\"port mapping open {} {} {}\", config1.getKey(), config1.getValue().getPort(), config1.getValue().getMappingPort());\n        }\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/FrameEncoder.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport io.netty.handler.codec.LengthFieldPrepender;\n\npublic class FrameEncoder extends LengthFieldPrepender {\n    public FrameEncoder() {\n        super(2);\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/Server.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;", "import io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class Server {\n    private int port;\n\n    private ChannelFuture channelFuture;\n    public Server(int port) {\n        this.port = port;\n    }\n", "    public void open() {\n        EventLoopGroup boss = new NioEventLoopGroup();\n        EventLoopGroup worker = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        bootstrap.group(boss, worker)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new FrameDecoder());\n                        pipeline.addLast(new FrameEncoder());\n                        pipeline.addLast(new PackageDecoder());\n                        pipeline.addLast(new PackageEncoder());\n                        pipeline.addLast(new ProxyServerHandler() {\n                        });\n                        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));\n                    }\n                });\n", "        try {\n            channelFuture = bootstrap.bind(port).sync();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        channelFuture.addListener((future) -> {\n            if (!future.isSuccess()) {\n                future.cause().printStackTrace();\n            }\n\n        });\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            boss.shutdownGracefully().syncUninterruptibly();\n            worker.shutdownGracefully().syncUninterruptibly();\n        }));\n    }\n", "    public void close() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n    }\n\n    public static void main(String[] args) {\n        String port = null;\n        if (args != null && args.length > 0) {\n            for (int i = 0; i < args.length; i++) {\n                if (StringUtils.isNotEmpty(args[i]) && args[i].equals(\"--port\")) {", "        if (args != null && args.length > 0) {\n            for (int i = 0; i < args.length; i++) {\n                if (StringUtils.isNotEmpty(args[i]) && args[i].equals(\"--port\")) {\n                    if (i + 1 < args.length) {\n                        String arg = args[i + 1];\n                        if (StringUtils.isNotEmpty(arg)) {\n                            port = arg;\n                        }\n                    }\n                }\n            }", "            if (port != null) {\n                new Server(Integer.parseInt(port)).open();\n            }\n        }\n    }\n}\n"]}
{"filename": "server/src/main/java/com/github/wandererex/wormhole/server/ProxyServer.java", "chunked_list": ["package com.github.wandererex.wormhole.server;\n\nimport com.github.wandererex.wormhole.serialize.Frame;\nimport com.github.wandererex.wormhole.serialize.Task;\nimport com.github.wandererex.wormhole.serialize.TaskExecutor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.buffer.UnpooledHeapByteBuf;", "import io.netty.buffer.Unpooled;\nimport io.netty.buffer.UnpooledHeapByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.FixedLengthFrameDecoder;\nimport io.netty.handler.codec.MessageToByteEncoder;\nimport io.netty.handler.codec.MessageToMessageEncoder;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;", "import io.netty.handler.codec.MessageToMessageEncoder;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.Attribute;\nimport io.netty.util.AttributeKey;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ProxyServer {\n    private String serviceKey;\n\n    private Integer mappingPort;\n\n    private ChannelFuture channelFuture;\n\n    private Channel proxyChannel;\n\n    private Channel channel;\n\n    private ForwardHandler forwardHandler;\n\n    public ProxyServer(String serviceKey, Integer mappingPort, Channel proxyChannel) {\n        this.serviceKey = serviceKey;\n        this.mappingPort = mappingPort;\n        this.proxyChannel = proxyChannel;\n        this.forwardHandler = new ForwardHandler(serviceKey, proxyChannel);\n    }\n", "\npublic class ProxyServer {\n    private String serviceKey;\n\n    private Integer mappingPort;\n\n    private ChannelFuture channelFuture;\n\n    private Channel proxyChannel;\n\n    private Channel channel;\n\n    private ForwardHandler forwardHandler;\n\n    public ProxyServer(String serviceKey, Integer mappingPort, Channel proxyChannel) {\n        this.serviceKey = serviceKey;\n        this.mappingPort = mappingPort;\n        this.proxyChannel = proxyChannel;\n        this.forwardHandler = new ForwardHandler(serviceKey, proxyChannel);\n    }\n", "    public void send(byte[] buf) {\n        if (channel == null) {\n            return;\n        }\n        TaskExecutor.get().addTask(new Task(channel, Unpooled.copiedBuffer(buf)));\n    }\n\n    public void open() {\n        EventLoopGroup boss = new NioEventLoopGroup();\n        EventLoopGroup worker = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        bootstrap.group(boss, worker)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                            @Override", "                            public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n                                Frame frame = new Frame(0x9, serviceKey, null);\n                                CountDownLatch latch = new CountDownLatch(1);\n                                channel = ctx.channel();\n                                forwardHandler.setChannel(channel);\n                                AttributeKey<CountDownLatch> attributeKey = AttributeKey.valueOf(serviceKey);\n                                Attribute<CountDownLatch> attr = proxyChannel.attr(attributeKey);\n                                attr.set(latch);\n                                proxyChannel.writeAndFlush(frame);\n                            }\n\n                            @Override", "                            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                                Frame frame = new Frame(0xA, serviceKey, null);\n                                proxyChannel.writeAndFlush(frame);\n                                ctx.fireChannelInactive();\n                            }\n                        });\n                        //pipeline.addLast(new FixedLengthFrameDecoder(20));\n                        pipeline.addLast(forwardHandler);\n                        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));\n                    }\n                });\n", "        try {\n            channelFuture = bootstrap.bind(mappingPort).sync();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        channelFuture.addListener((future) -> {\n            if (!future.isSuccess()) {\n                future.cause().printStackTrace();\n            }\n\n        });\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            boss.shutdownGracefully().syncUninterruptibly();\n            worker.shutdownGracefully().syncUninterruptibly();\n        }));\n    }\n", "    public void close() {\n        if (channel == null) {\n            return;\n        }\n        channel.close();\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/TaskExecutor.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport java.util.concurrent.*;\n\npublic class TaskExecutor {\n    private static TaskExecutor taskExecutor =  new TaskExecutor();\n    private ExecutorService executorService;\n\n    private BlockingQueue<Task> queue;\n\n    public TaskExecutor() {\n        this.executorService = Executors.newSingleThreadExecutor();\n        this.executorService.submit(() -> {", "            try {\n                for (;;) {\n                    Task task = this.queue.poll(100, TimeUnit.MICROSECONDS);\n                    if (task != null) {\n                        try {\n                            task.run();\n                        } catch (Exception e) {\n\n                        }\n                    }\n                }\n            } catch (Exception e) {\n\n            }\n        });\n        this.queue = new LinkedBlockingQueue<>();\n    }\n", "    public void addTask(Task task) {\n        this.queue.add(task);\n    }\n\n    public static TaskExecutor get() {\n        return taskExecutor;\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/FrameSerialization.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.commons.lang3.StringUtils;\n\n\nimport java.nio.charset.StandardCharsets;\n\npublic class FrameSerialization implements Serialization<Frame> {\n\n    @Override", "\npublic class FrameSerialization implements Serialization<Frame> {\n\n    @Override\n    public ByteBuf serialize(Frame msg, ByteBuf byteBuf) {\n        int opCode = msg.getOpCode();\n        byteBuf.writeInt(opCode);\n        String serviceKey = msg.getServiceKey();\n        if (StringUtils.isNotEmpty(serviceKey)) {\n            byte[] bytes = msg.getServiceKey().getBytes(StandardCharsets.UTF_8);\n            byteBuf.writeInt(bytes.length);\n            byteBuf.writeBytes(bytes);\n        } else {\n            byteBuf.writeInt(0);\n        }", "        if (StringUtils.isNotEmpty(serviceKey)) {\n            byte[] bytes = msg.getServiceKey().getBytes(StandardCharsets.UTF_8);\n            byteBuf.writeInt(bytes.length);\n            byteBuf.writeBytes(bytes);\n        } else {\n            byteBuf.writeInt(0);\n        }\n        if (msg.getPayload() != null) {\n            byteBuf.writeInt(msg.getPayload().length);\n            byteBuf.writeBytes(msg.getPayload());\n        } else {\n            byteBuf.writeInt(0);\n        }\n        return byteBuf;\n    }\n\n    @Override", "    public Frame deserialize(ByteBuf byteBuf) {\n        Frame frame = new Frame();\n        frame.setOpCode(byteBuf.readInt());\n        int n = byteBuf.readInt();\n        byte[] bytes = null;\n        if (n > 0) {\n            bytes = new byte[n];\n            byteBuf.readBytes(bytes, 0, n);\n            String serviceKey = new String(bytes, StandardCharsets.UTF_8);\n            frame.setServiceKey(serviceKey);\n        }\n        n = byteBuf.readInt();", "        if (n > 0) {\n            bytes = new byte[n];\n            byteBuf.readBytes(bytes, 0, n);\n            frame.setPayload(bytes);\n        }\n        return frame;\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/Frame.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Frame {\n    //0x1:\u5185\u7f51proxy\u8fde\u63a5\u516c\u7f51\u670d\u52a1\u5668\u8bf7\u6c42\uff0c0x2x:0x1\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\uff0c0x3:\u6570\u636e\u4f20\u8f93\uff0c0x4:\u6570\u636e\u4f20\u8f93\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f), 0x5:\u5fc3\u8df3, 0x6:\u5fc3\u8df3\u54cd\u5e94, 0x7:\u5185\u7f51proxy\u8fde\u63a5\u516c\u7f51\u670d\u52a1\u5668\u4e0b\u7ebf\uff0c0x8:0x7\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0x9:\u5185\u7f51proxy\u4e0e\u5185\u7f51\u670d\u52a1\u5efa\u7acb\u8fde\u63a5, 0xA:0x9\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0xA:\u5185\u7f51proxy\u4e0e\u5185\u7f51\u670d\u52a1\u65ad\u5f00\u8fde\u63a5, 0xA:0xA\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0xB:\u516c\u7f51\u670d\u52a1\u5668\u65ad\u5f00\u8fde\u63a5, 0xA:0xB\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    private int opCode;\n\n    private String serviceKey;\n\n    private byte[] payload;\n}\n", "@AllArgsConstructor\npublic class Frame {\n    //0x1:\u5185\u7f51proxy\u8fde\u63a5\u516c\u7f51\u670d\u52a1\u5668\u8bf7\u6c42\uff0c0x2x:0x1\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\uff0c0x3:\u6570\u636e\u4f20\u8f93\uff0c0x4:\u6570\u636e\u4f20\u8f93\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f), 0x5:\u5fc3\u8df3, 0x6:\u5fc3\u8df3\u54cd\u5e94, 0x7:\u5185\u7f51proxy\u8fde\u63a5\u516c\u7f51\u670d\u52a1\u5668\u4e0b\u7ebf\uff0c0x8:0x7\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0x9:\u5185\u7f51proxy\u4e0e\u5185\u7f51\u670d\u52a1\u5efa\u7acb\u8fde\u63a5, 0xA:0x9\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0xA:\u5185\u7f51proxy\u4e0e\u5185\u7f51\u670d\u52a1\u65ad\u5f00\u8fde\u63a5, 0xA:0xA\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    //0xB:\u516c\u7f51\u670d\u52a1\u5668\u65ad\u5f00\u8fde\u63a5, 0xA:0xB\u54cd\u5e94(0\u5931\u8d25\uff0c1\u6210\u529f)\n    private int opCode;\n\n    private String serviceKey;\n\n    private byte[] payload;\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/ProxyServiceConfig.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport lombok.Data;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Data\npublic class ProxyServiceConfig {\n    @Data\n    public static class ServiceConfig {\n        private String ip;\n        private Integer port;\n        private Integer mappingPort;\n    }\n\n    private Map<String, ServiceConfig> map = new HashMap<>();\n\n    private String serverHost;\n\n    private Integer serverPort;\n", "public class ProxyServiceConfig {\n    @Data\n    public static class ServiceConfig {\n        private String ip;\n        private Integer port;\n        private Integer mappingPort;\n    }\n\n    private Map<String, ServiceConfig> map = new HashMap<>();\n\n    private String serverHost;\n\n    private Integer serverPort;\n", "    public  ServiceConfig getServiceConfig(String serviceKey) {\n        return map.get(serviceKey);\n    }\n\n    public Map<String, ServiceConfig> getServiceConfigMap() {\n        return new HashMap<>(map);\n    }\n\n    public void addConfig(String key, ServiceConfig config) {\n        map.put(key, config);\n    }\n}\n", "    public void addConfig(String key, ServiceConfig config) {\n        map.put(key, config);\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/NetworkUtil.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.*;\nimport java.util.regex.Pattern;", "import java.util.*;\nimport java.util.regex.Pattern;\n\nimport static java.util.Collections.emptyList;\n\n@Slf4j\npublic class NetworkUtil {\n    private static volatile String HOST_ADDRESS;\n    private static final String LOCALHOST_VALUE = \"127.0.0.1\";\n    private static volatile InetAddress LOCAL_ADDRESS = null;\n    private static final Pattern IP_PATTERN = Pattern.compile(\"\\\\d{1,3}(\\\\.\\\\d{1,3}){3,5}$\");\n    private static final String ANYHOST_VALUE = \"0.0.0.0\";\n\n    private static final String PREFERRED_NETWORK_INTERFACE = \"network.interface.preferred\";\n\n    private static final String IGNORED_NETWORK_INTERFACE_REGEX = \"network.interface.ignored\";\n\n    /**\n     * \u83b7\u53d6\u672c\u673a IP \u5730\u5740\n     * @return \u672c\u673a IP \u5730\u5740\n     */", "    public static String getLocalHost() {\n        if (HOST_ADDRESS != null) {\n            return HOST_ADDRESS;\n        }\n\n        InetAddress address = getLocalAddress();\n        if (address != null) {\n            return HOST_ADDRESS = address.getHostAddress();\n        }\n        return LOCALHOST_VALUE;\n    }\n\n    /**\n     * Find first valid IP from local network card\n     *\n     * @return first valid local IP\n     */", "    public static InetAddress getLocalAddress() {\n        if (LOCAL_ADDRESS != null) {\n            return LOCAL_ADDRESS;\n        }\n        InetAddress localAddress = getLocalAddress0();\n        LOCAL_ADDRESS = localAddress;\n        return localAddress;\n    }\n    private static InetAddress getLocalAddress0() {\n        InetAddress localAddress = null;\n\n        // @since 2.7.6, choose the {@link NetworkInterface} first", "        try {\n            NetworkInterface networkInterface = findNetworkInterface();\n            Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();\n            while (addresses.hasMoreElements()) {\n                Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());\n                if (addressOp.isPresent()) {\n                    try {\n                        if (addressOp.get().isReachable(100)) {\n                            return addressOp.get();\n                        }\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            log.warn(\"[Net] getLocalAddress0 failed.\", e);\n        }\n", "        try {\n            localAddress = InetAddress.getLocalHost();\n            Optional<InetAddress> addressOp = toValidAddress(localAddress);\n            if (addressOp.isPresent()) {\n                return addressOp.get();\n            }\n        } catch (Throwable e) {\n            log.warn(\"[Net] getLocalAddress0 failed.\", e);\n        }\n\n\n        return localAddress;\n    }\n\n    /**\n     * Get the suitable {@link NetworkInterface}\n     *\n     * @return If no {@link NetworkInterface} is available , return <code>null</code>\n     * @since 2.7.6\n     */", "    public static NetworkInterface findNetworkInterface() {\n\n        List<NetworkInterface> validNetworkInterfaces = emptyList();\n        try {\n            validNetworkInterfaces = getValidNetworkInterfaces();\n        } catch (Throwable e) {\n            log.warn(\"[Net] findNetworkInterface failed\", e);\n        }\n\n        NetworkInterface result = null;\n\n        // Try to find the preferred one", "        for (NetworkInterface networkInterface : validNetworkInterfaces) {\n            if (isPreferredNetworkInterface(networkInterface)) {\n                result = networkInterface;\n                log.info(\"[Net] use preferred network interface: {}\", networkInterface.getDisplayName());\n                break;\n            }\n        }\n\n        if (result == null) { // If not found, try to get the first one\n            for (NetworkInterface networkInterface : validNetworkInterfaces) {\n                Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();", "        if (result == null) { // If not found, try to get the first one\n            for (NetworkInterface networkInterface : validNetworkInterfaces) {\n                Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());\n                    if (addressOp.isPresent()) {\n                        try {\n                            if (addressOp.get().isReachable(100)) {\n                                result = networkInterface;\n                                break;\n                            }\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                    }\n                }\n            }\n        }\n", "        if (result == null) {\n            result = first(validNetworkInterfaces);\n        }\n\n        return result;\n    }\n\n    private static Optional<InetAddress> toValidAddress(InetAddress address) {\n        if (address instanceof Inet6Address) {\n            Inet6Address v6Address = (Inet6Address) address;\n            if (isPreferIPV6Address()) {\n                return Optional.ofNullable(normalizeV6Address(v6Address));\n            }\n        }", "        if (address instanceof Inet6Address) {\n            Inet6Address v6Address = (Inet6Address) address;\n            if (isPreferIPV6Address()) {\n                return Optional.ofNullable(normalizeV6Address(v6Address));\n            }\n        }\n        if (isValidV4Address(address)) {\n            return Optional.of(address);\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Check if an ipv6 address\n     *\n     * @return true if it is reachable\n     */\n    static boolean isPreferIPV6Address() {\n        return Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n    }\n\n    static boolean isValidV4Address(InetAddress address) {", "        if (address == null || address.isLoopbackAddress()) {\n            return false;\n        }\n\n        String name = address.getHostAddress();\n        return (name != null\n                && IP_PATTERN.matcher(name).matches()\n                && !ANYHOST_VALUE.equals(name)\n                && !LOCALHOST_VALUE.equals(name));\n    }\n\n    /**\n     * normalize the ipv6 Address, convert scope name to scope id.\n     * e.g.\n     * convert\n     * fe80:0:0:0:894:aeec:f37d:23e1%en0\n     * to\n     * fe80:0:0:0:894:aeec:f37d:23e1%5\n     * <p>\n     * The %5 after ipv6 address is called scope id.\n     * see java doc of {@link Inet6Address} for more details.\n     *\n     * @param address the input address\n     * @return the normalized address, with scope id converted to int\n     */\n    static InetAddress normalizeV6Address(Inet6Address address) {\n        String addr = address.getHostAddress();\n        int i = addr.lastIndexOf('%');", "        if (i > 0) {\n            try {\n                return InetAddress.getByName(addr.substring(0, i) + '%' + address.getScopeId());\n            } catch (UnknownHostException e) {\n                // ignore\n                log.debug(\"Unknown IPV6 address: \", e);\n            }\n        }\n        return address;\n    }\n\n    /**\n     * Get the valid {@link NetworkInterface network interfaces}\n     *\n     * @return non-null\n     * @throws SocketException SocketException if an I/O error occurs.\n     * @since 2.7.6\n     */\n    private static List<NetworkInterface> getValidNetworkInterfaces() throws SocketException {\n        List<NetworkInterface> validNetworkInterfaces = new LinkedList<>();\n        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();", "        while (interfaces.hasMoreElements()) {\n            NetworkInterface networkInterface = interfaces.nextElement();\n            if (ignoreNetworkInterface(networkInterface)) { // ignore\n                continue;\n            }\n            // \u6839\u636e\u7528\u6237 -D \u53c2\u6570\u5ffd\u7565\u7f51\u5361\n            if (ignoreInterfaceByConfig(networkInterface.getDisplayName())) {\n                continue;\n            }\n            validNetworkInterfaces.add(networkInterface);\n        }\n        return validNetworkInterfaces;\n    }\n\n    /**\n     * @param networkInterface {@link NetworkInterface}\n     * @return if the specified {@link NetworkInterface} should be ignored, return <code>true</code>\n     * @throws SocketException SocketException if an I/O error occurs.\n     * @since 2.7.6\n     */\n    private static boolean ignoreNetworkInterface(NetworkInterface networkInterface) throws SocketException {\n        return networkInterface == null\n                || networkInterface.isLoopback()\n                || networkInterface.isVirtual()\n                || !networkInterface.isUp();\n    }\n\n    /**\n     * Take the first element from the specified collection\n     *\n     * @param values the collection object\n     * @param <T>    the type of element of collection\n     * @return if found, return the first one, or <code>null</code>\n     * @since 2.7.6\n     */\n    public static <T> T first(Collection<T> values) {", "        if (values == null || values.isEmpty()) {\n            return null;\n        }\n        if (values instanceof List) {\n            List<T> list = (List<T>) values;\n            return list.get(0);\n        } else {\n            return values.iterator().next();\n        }\n    }\n\n", "    public static boolean isPreferredNetworkInterface(NetworkInterface networkInterface) {\n        String preferredNetworkInterface = System.getProperty(PREFERRED_NETWORK_INTERFACE);\n        return Objects.equals(networkInterface.getDisplayName(), preferredNetworkInterface);\n    }\n\n    static boolean ignoreInterfaceByConfig(String interfaceName) {\n        String regex = System.getProperty(IGNORED_NETWORK_INTERFACE_REGEX);\n        if (StringUtils.isBlank(regex)) {\n            return false;\n        }\n        if (interfaceName.matches(regex)) {\n            log.info(\"[Net] ignore network interface: {} by regex({})\", interfaceName, regex);\n            return true;\n        }\n        return false;\n    }\n", "        if (interfaceName.matches(regex)) {\n            log.info(\"[Net] ignore network interface: {} by regex({})\", interfaceName, regex);\n            return true;\n        }\n        return false;\n    }\n\n    public static List<Frame> byteArraytoFrameList(byte[] array, String serviceKey) {\n        int n = 0;\n        byte[] bytes = new byte[1024];\n        List<Frame> frames = new ArrayList<>();", "        for (int i = 0; i < array.length; i += n) {\n            if (i + 1024 < array.length) {\n                System.arraycopy(array, i, bytes, 0, 1024);\n                n = 1024;\n                Frame frame = new Frame(0x3, serviceKey, bytes);\n                frames.add(frame);\n            } else {\n                byte[] bytes1 = new byte[array.length - i];\n                System.arraycopy(array, i, bytes1, 0, bytes1.length);\n                n = bytes1.length;\n                Frame frame = new Frame(0x3, serviceKey, bytes1);\n                frames.add(frame);\n            }\n        }\n        return frames;\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/Serialization.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport io.netty.buffer.ByteBuf;\n\npublic interface Serialization<T> {\n    ByteBuf serialize(T msg, ByteBuf byteBuf);\n\n    T deserialize(ByteBuf byteBuf);\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/Task.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\n\npublic class Task implements Runnable{\n    private Channel channel;\n\n    private Object msg;\n\n    public Task(Channel channel, Object msg) {\n        this.channel = channel;\n        this.msg = msg;\n    }\n\n    @Override", "    public void run() {\n        channel.writeAndFlush(msg);\n    }\n}\n"]}
{"filename": "serialize/src/main/java/com/github/wandererex/wormhole/serialize/Constant.java", "chunked_list": ["package com.github.wandererex.wormhole.serialize;\n\npublic interface Constant {\n    String CLIENT_PUBLIC_KEY = \"client_public_key\";\n\n    byte[] BUSINESS_MAGIC = {(byte) 0xc3, (byte) 0x11, (byte) 0xa3, (byte) 0x65};\n\n    byte[] PING_MAGIC = {(byte) 0xc3, (byte) 0x15, (byte) 0xa7, (byte) 0x65};\n\n    byte[] PONG_MAGIC = {(byte) 0xc3, (byte) 0x17, (byte) 0xab, (byte) 0x65};\n\n    int opContinuation = 0;\n\n    int opText = 1;\n\n    int opBinary = 2;\n\n    int opClose = 8;\n\n    int opPing = 9;\n\n    int opPong = 10;\n\n    String SEND_SUCCESS = \"SEND_SUCCESS\";\n\n    String SEND_FAILED = \"send_failed\";\n\n}\n"]}
