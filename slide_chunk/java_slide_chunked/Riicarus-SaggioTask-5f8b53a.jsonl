{"filename": "src/test/java/TaskDSLParserTest.java", "chunked_list": ["import io.github.riicarus.SaggioTask;\nimport io.github.riicarus.TaskContext;\nimport io.github.riicarus.TaskResult;\nimport io.github.riicarus.TransferableTask;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author Riicarus\n * @create 2023-7-28 8:02\n * @since 1.1.0\n */\npublic class TaskDSLParserTest {\n\n    public static void main(String[] args) {\n        SaggioTask saggioTask = new SaggioTask();\n\n        TransferableTask<String> task = saggioTask.build(\"task\",\n                (ctx) -> new TaskResult<>(\"success\", \"0\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> task0 = saggioTask.build(\"task0\",\n                (ctx) -> new TaskResult<>(\"success\", \"aa\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskA = saggioTask.build(\"taskA\",\n                (ctx) -> new TaskResult<>(\"success\", \"A-D1\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskB = saggioTask.build(\"taskB\",\n                (ctx) -> {\n                    Thread.sleep(5000);\n                    return new TaskResult<>(\"success\", \"B-D1\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskC = saggioTask.build(\"taskC\",\n                (ctx) -> {\n                    Thread.sleep(4000);\n                    return new TaskResult<>(\"success\", \"C-DE1\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskD = saggioTask.build(\"taskD\",\n                (ctx) -> new TaskResult<>(\"success\", \"D-E1\"),\n                (res, ctx) -> System.out.println(res));\n\n        saggioTask.arrange(\"task#0, task0#aa & taskA, taskB, taskC @1000\");\n\n        ThreadPoolExecutor taskExecutor = new ThreadPoolExecutor(20, 50, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(10));\n        TaskContext context = new TaskContext();\n        context.getConfig().setRecursivelyStop(true);\n\n        List<TransferableTask<?>> startTasks = new ArrayList<>();\n        startTasks.add(task0);\n        startTasks.add(task);\n        saggioTask.run(startTasks, taskExecutor, context);\n    }\n\n}\n", "public class TaskDSLParserTest {\n\n    public static void main(String[] args) {\n        SaggioTask saggioTask = new SaggioTask();\n\n        TransferableTask<String> task = saggioTask.build(\"task\",\n                (ctx) -> new TaskResult<>(\"success\", \"0\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> task0 = saggioTask.build(\"task0\",\n                (ctx) -> new TaskResult<>(\"success\", \"aa\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskA = saggioTask.build(\"taskA\",\n                (ctx) -> new TaskResult<>(\"success\", \"A-D1\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskB = saggioTask.build(\"taskB\",\n                (ctx) -> {\n                    Thread.sleep(5000);\n                    return new TaskResult<>(\"success\", \"B-D1\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskC = saggioTask.build(\"taskC\",\n                (ctx) -> {\n                    Thread.sleep(4000);\n                    return new TaskResult<>(\"success\", \"C-DE1\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskD = saggioTask.build(\"taskD\",\n                (ctx) -> new TaskResult<>(\"success\", \"D-E1\"),\n                (res, ctx) -> System.out.println(res));\n\n        saggioTask.arrange(\"task#0, task0#aa & taskA, taskB, taskC @1000\");\n\n        ThreadPoolExecutor taskExecutor = new ThreadPoolExecutor(20, 50, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(10));\n        TaskContext context = new TaskContext();\n        context.getConfig().setRecursivelyStop(true);\n\n        List<TransferableTask<?>> startTasks = new ArrayList<>();\n        startTasks.add(task0);\n        startTasks.add(task);\n        saggioTask.run(startTasks, taskExecutor, context);\n    }\n\n}\n"]}
{"filename": "src/test/java/TaskTest.java", "chunked_list": ["import io.github.riicarus.SaggioTask;\nimport io.github.riicarus.TaskContext;\nimport io.github.riicarus.TaskResult;\nimport io.github.riicarus.TransferableTask;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * [FEATURE INFO]<br/>\n *\n * @author Riicarus\n * @create 2023-5-26 3:41\n * @since 1.0.0\n */\npublic class TaskTest {\n", " * @since 1.0.0\n */\npublic class TaskTest {\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor taskExecutor = new ThreadPoolExecutor(20, 50, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(10));\n\n        SaggioTask saggioTask = new SaggioTask();\n\n        TransferableTask<String> task0 = saggioTask.build(\"0\",\n                (ctx) -> new TaskResult<>(\"success\", \"0\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskA = saggioTask.build(\"A\",\n                (ctx) -> new TaskResult<>(\"success\", \"A-DE\"),\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskB = saggioTask.build(\"B\",\n                (ctx) -> {\n                    Thread.sleep(5000);\n                    return new TaskResult<>(\"success\", \"B-DE\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskC = saggioTask.build(\"C\",\n                (ctx) -> {\n                    Thread.sleep(4000);\n                    return new TaskResult<>(\"success\", \"C-DE\");\n                },\n                (res, ctx) -> System.out.println(res));\n        TransferableTask<String> taskD = saggioTask.build(\"D\",\n                (ctx) -> new TaskResult<>(\"success\", \"D-F\"),\n                (res, ctx) -> System.out.println(res));\n        taskA.and(task0, \"0\");\n        taskB.and(task0, \"0\");\n        taskC.and(task0, \"0\");\n        taskD.any(taskA, \"A-DE\")\n                .any(taskB, \"B-DE\")\n                .any(taskC, \"C-DE\")\n                .setTimeout(5000, TimeUnit.MILLISECONDS);\n\n//        TransferableTask<String> taskE = saggioTask.build(\"E\", (ctx) -> new TaskResult<>(\"success\", \"E-F1\"), (res, ctx) -> System.out.println(res));\n//        taskE.and(taskC, \"C-DE\")\n//                .and(taskD, \"D-E1\")\n//                .setTimeout(4, TimeUnit.SECONDS);\n        TransferableTask<String> taskE = saggioTask.build(\"E\", (ctx) -> new TaskResult<>(\"success\", \"E-F\"), (res, ctx) -> System.out.println(res));\n        taskE.any(taskA, \"A-DE\")\n                .any(taskB, \"B-DE\")\n                .any(taskC, \"C-DE\")\n                .setTimeout(5000, TimeUnit.MILLISECONDS);\n\n        TransferableTask<String> taskF = saggioTask.build(\"F\", (ctx) -> new TaskResult<>(\"success\", \"F-G\"), (res, ctx) -> System.out.println(res));\n        taskF.and(taskD, \"D-F\")\n                .and(taskE, \"E-F\")\n                .setTimeout(5000, TimeUnit.MILLISECONDS);\n\n        TaskContext context = new TaskContext();\n        context.getConfig().setTimeout(1000, TimeUnit.MILLISECONDS);\n        context.getConfig().setRecursivelyStop(true);\n\n        List<TransferableTask<?>> startTasks = new ArrayList<>();\n        startTasks.add(task0);\n        saggioTask.run(startTasks, taskExecutor, context);\n    }\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskContext.java", "chunked_list": ["package io.github.riicarus;\n\nimport java.util.HashMap;\n\n/**\n * [FEATURE INFO]<br/>\n * Context for a saggio task. <br/>\n * The context does not provide any concurrent ensure, so this may need some user's work.\n *\n * @author Riicarus", " *\n * @author Riicarus\n * @create 2023-6-8 19:17\n * @since 1.0.0\n */\npublic class TaskContext {\n\n    private final TaskConfig config = new TaskConfig();\n\n    private final HashMap<String, Object> data = new HashMap<>();\n\n    public TaskContext() {\n    }\n", "    public TaskConfig getConfig() {\n        return config;\n    }\n\n    public Object get(String key) {\n        return data.get(key);\n    }\n\n    public void set(String key, Object value) {\n        data.put(key, value);\n    }\n}\n", "    public void set(String key, Object value) {\n        data.put(key, value);\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskType.java", "chunked_list": ["package io.github.riicarus;\n\n/**\n * [FEATURE INFO]<br/>\n * type of a condition\n *\n * @author Riicarus\n * @create 2023-6-1 2:36\n * @since 1.0.0\n */\npublic enum TaskType {\n\n    ANY(0),\n    AND(1);\n\n    private final int value;\n\n    TaskType(int value) {\n        this.value = value;\n    }\n", " * @since 1.0.0\n */\npublic enum TaskType {\n\n    ANY(0),\n    AND(1);\n\n    private final int value;\n\n    TaskType(int value) {\n        this.value = value;\n    }\n", "    public int getValue() {\n        return value;\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskConfig.java", "chunked_list": ["package io.github.riicarus;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * [FEATURE INFO]<br/>\n * config for a task\n *\n * @author Riicarus\n * @create 2023-6-8 19:17", " * @author Riicarus\n * @create 2023-6-8 19:17\n * @since 1.0.0\n */\npublic class TaskConfig {\n\n    private int timeout = 3000;\n    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;\n\n    /**\n     * Indicating that whether the task should be recursively stopped when one task fails or meets a timeout.\n     */\n    private boolean recursivelyStop = true;\n", "    public int getTimeout() {\n        return timeout;\n    }\n\n    public TaskConfig setTimeout(int timeout, TimeUnit timeUnit) {\n        this.timeout = timeout;\n        this.timeUnit = timeUnit;\n        return this;\n    }\n\n    public TimeUnit getTimeUnit() {\n        return timeUnit;\n    }\n\n    @SuppressWarnings(\"all\")", "    public TimeUnit getTimeUnit() {\n        return timeUnit;\n    }\n\n    @SuppressWarnings(\"all\")\n    public boolean isRecursivelyStop() {\n        return recursivelyStop;\n    }\n\n    public TaskConfig setRecursivelyStop(boolean recursivelyStop) {\n        this.recursivelyStop = recursivelyStop;\n        return this;\n    }\n}\n", "    public TaskConfig setRecursivelyStop(boolean recursivelyStop) {\n        this.recursivelyStop = recursivelyStop;\n        return this;\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/Transferable.java", "chunked_list": ["package io.github.riicarus;\n\n/**\n * [FEATURE INFO]<br/>\n *\n * @author Riicarus\n * @create 2023-6-12 23:04\n * @since 1.0.0\n */\npublic interface Transferable<T> {\n\n    T and(T prev, String state);\n\n    T any(T prev, String state);\n\n}\n", " */\npublic interface Transferable<T> {\n\n    T and(T prev, String state);\n\n    T any(T prev, String state);\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskResult.java", "chunked_list": ["package io.github.riicarus;\n\n/**\n * [FEATURE INFO]<br/>\n *\n * @author Riicarus\n * @create 2023-5-25 21:27\n * @since 1.0.0\n */\npublic class TaskResult<T> {\n\n    private T t;\n\n    private String state;\n\n    public TaskResult(T t, String state) {\n        this.t = t;\n        this.state = state;\n    }\n", " */\npublic class TaskResult<T> {\n\n    private T t;\n\n    private String state;\n\n    public TaskResult(T t, String state) {\n        this.t = t;\n        this.state = state;\n    }\n", "    public T getT() {\n        return t;\n    }\n\n    public void setT(T t) {\n        this.t = t;\n    }\n\n    public String getState() {\n        return state;\n    }\n", "    public String getState() {\n        return state;\n    }\n\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskResult{\" +\n                \"t=\" + t +\n                \", state='\" + state + '\\'' +\n                '}';\n    }\n}\n", "    public String toString() {\n        return \"TaskResult{\" +\n                \"t=\" + t +\n                \", state='\" + state + '\\'' +\n                '}';\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskSync.java", "chunked_list": ["package io.github.riicarus;\n\nimport java.util.concurrent.ThreadPoolExecutor;\n\n/**\n * [FEATURE INFO]<br/>\n * task synchronizer interface\n *\n * @author Riicarus\n * @create 2023-6-27 8:28", " * @author Riicarus\n * @create 2023-6-27 8:28\n * @since 1.0.1\n */\npublic interface TaskSync {\n\n    /**\n     * wait till all/any prev taskFunc tasks arriving according to the task type,\n     * or end to meet the timeout or being interrupted\n     *\n     * @param context TaskContext\n     * @return if task can work\n     */\n    boolean waitToWork(TaskContext context);\n\n    /**\n     * task's executed method, the task will wait\n     * till all/any prev tasks arriving according to the task type,\n     * or end to meet the timeout or being interrupted.\n     *\n     * @param executor thread pool\n     * @param context TaskContext\n     * @param isBegin is begin() execute, that is, the task will be immediately executed without any waiting\n     */\n    void execute(ThreadPoolExecutor executor, TaskContext context, boolean isBegin);\n\n    /**\n     * join() is the way to execute the current task or update current task's status, according to current task's working state. <br/>\n     * Executed by previous task.\n     *\n     * @param executor thread pool\n     * @param context TaskContext\n     */\n    void join(ThreadPoolExecutor executor, TaskContext context);\n\n    /**\n     * jump to and execute next task(s)\n     *\n     * @param state  transfer state from this to next\n     * @param executor thread pool\n     * @param context TaskContext\n     */\n    void next(String state, ThreadPoolExecutor executor, TaskContext context);\n\n    /**\n     * handle task's waiting/executing interrupted\n     *\n     * @param context TaskContext\n     */\n    void handleInterrupted(TaskContext context);\n\n    /**\n     * get if the task is executing\n     *\n     * @return if the task is executing\n     */\n    boolean isExecuting();\n\n    /**\n     * get if the task is executed\n     *\n     * @return if the task is executed\n     */\n    boolean isExecuted();\n\n    /**\n     * get if the task is canceled\n     *\n     * @return if the task is canceled\n     */\n    boolean isCanceled();\n\n    /**\n     * get the thread witch is executing the task if the task is in executing status\n     *\n     * @return thread witch is executing the task\n     */\n    Thread getCurrentThread();\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TaskPushDownTable.java", "chunked_list": ["package io.github.riicarus;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * [FEATURE INFO]<br/>\n * push down table of tasks.\n *\n * @author Riicarus", " *\n * @author Riicarus\n * @create 2023-6-1 2:45\n * @since 1.0.0\n */\npublic class TaskPushDownTable {\n\n    private final HashMap<TransferableTask<?>, HashMap<String, HashSet<TransferableTask<?>>>> pushDownTable = new HashMap<>();\n\n    public HashSet<TransferableTask<?>> getNextTasks(TransferableTask<?> task, String state) {\n        HashMap<String, HashSet<TransferableTask<?>>> nextTasks;\n", "        if ((nextTasks = pushDownTable.get(task)) != null) {\n            return nextTasks.get(state);\n        }\n\n        return null;\n    }\n\n    public HashMap<String, HashSet<TransferableTask<?>>> getNextTasks(TransferableTask<?> task) {\n        return pushDownTable.get(task);\n    }\n", "    public void add(TransferableTask<?> now, String state, TransferableTask<?> then) {\n        HashMap<String, HashSet<TransferableTask<?>>> nextTasks;\n        HashSet<TransferableTask<?>> tasksOfState;\n\n        if ((nextTasks = pushDownTable.get(now)) == null) {\n            nextTasks = new HashMap<>();\n            tasksOfState = new HashSet<>();\n            tasksOfState.add(then);\n            nextTasks.put(state, tasksOfState);\n            pushDownTable.put(now, nextTasks);\n            return;\n        }\n", "        if ((tasksOfState = nextTasks.get(state)) == null) {\n            tasksOfState = new HashSet<>();\n            nextTasks.put(state, tasksOfState);\n            return;\n        }\n\n        tasksOfState.add(then);\n    }\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/Task.java", "chunked_list": ["package io.github.riicarus;\n\nimport io.github.riicarus.function.PrevTaskFunction;\nimport io.github.riicarus.function.TaskCallback;\nimport io.github.riicarus.function.TaskFunction;\n\nimport java.util.HashSet;\n\n/**\n * [FEATURE INFO]<br/>", "/**\n * [FEATURE INFO]<br/>\n * task interface\n *\n * @author Riicarus\n * @create 2023-6-26 17:53\n * @since 1.0.1\n */\npublic interface Task<T> {\n\n    // core attributes\n    String getName();\n    TaskType getType();\n    HashSet<TransferableTask<?>> getPrevTasks();\n\n    // executable functions\n    PrevTaskFunction getPrevFunc();\n    TaskFunction<T> getTaskFunc();\n    TaskCallback<T> getCallback();\n\n    // execute method\n    TaskResult<T> doExecute(TaskContext context);\n\n}\n", "public interface Task<T> {\n\n    // core attributes\n    String getName();\n    TaskType getType();\n    HashSet<TransferableTask<?>> getPrevTasks();\n\n    // executable functions\n    PrevTaskFunction getPrevFunc();\n    TaskFunction<T> getTaskFunc();\n    TaskCallback<T> getCallback();\n\n    // execute method\n    TaskResult<T> doExecute(TaskContext context);\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/TransferableTask.java", "chunked_list": ["package io.github.riicarus;\n\nimport io.github.riicarus.exception.TaskArrangeException;\nimport io.github.riicarus.function.PrevTaskFunction;\nimport io.github.riicarus.function.TaskCallback;\nimport io.github.riicarus.function.TaskFunction;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;", "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n", "import java.util.concurrent.locks.ReentrantLock;\n\n/**\n * [FEATURE INFO]<br/>\n * task interface\n *\n * @author Riicarus\n * @create 2023-6-12 22:45\n * @since 1.0.0\n */\npublic class TransferableTask<T> implements Transferable<TransferableTask<?>>, Task<T> {\n\n    protected final TaskSynchronizer<T> sync;\n\n    // push-down table maintainer\n    private final SaggioTask saggioTask;\n\n    // core attributes\n    protected final String name;\n    protected TaskType type;\n    protected final HashSet<TransferableTask<?>> prevTasks = new HashSet<>();\n\n    // task's executable function interfaces\n    private PrevTaskFunction prevFunc;\n    private final TaskFunction<T> taskFunc;\n    private TaskCallback<T> callback;\n\n    protected boolean useCustomizedTimeout = false;\n    protected int timeout = 3000;\n    protected TimeUnit timeUnit = TimeUnit.MILLISECONDS;\n", " * @since 1.0.0\n */\npublic class TransferableTask<T> implements Transferable<TransferableTask<?>>, Task<T> {\n\n    protected final TaskSynchronizer<T> sync;\n\n    // push-down table maintainer\n    private final SaggioTask saggioTask;\n\n    // core attributes\n    protected final String name;\n    protected TaskType type;\n    protected final HashSet<TransferableTask<?>> prevTasks = new HashSet<>();\n\n    // task's executable function interfaces\n    private PrevTaskFunction prevFunc;\n    private final TaskFunction<T> taskFunc;\n    private TaskCallback<T> callback;\n\n    protected boolean useCustomizedTimeout = false;\n    protected int timeout = 3000;\n    protected TimeUnit timeUnit = TimeUnit.MILLISECONDS;\n", "    public static int DEFAULT_TIMEOUT = 3000;\n\n    public TransferableTask(String name, TaskFunction<T> taskFunc, SaggioTask saggioTask) {\n        this.sync = new TaskSynchronizer<>(this);\n        this.name = name;\n        this.taskFunc = taskFunc;\n        this.saggioTask = saggioTask;\n    }\n\n    public TransferableTask(String name, TaskFunction<T> taskFunc, TaskCallback<T> callback, SaggioTask saggioTask) {\n        this.sync = new TaskSynchronizer<>(this);\n        this.name = name;\n        this.taskFunc = taskFunc;\n        this.callback = callback;\n        this.saggioTask = saggioTask;\n    }\n\n    public TransferableTask(String name, PrevTaskFunction prevFunc, TaskFunction<T> taskFunc, TaskCallback<T> callback, SaggioTask saggioTask) {\n        this.sync = new TaskSynchronizer<>(this);\n        this.name = name;\n        this.prevFunc = prevFunc;\n        this.taskFunc = taskFunc;\n        this.callback = callback;\n        this.saggioTask = saggioTask;\n    }\n\n    /**\n     * link previous task to current one, meaning that if all previous tasks executed successfully and returned the given state, current task will be executed.\n     *\n     * @param prev previous task\n     * @param fromState transfer state\n     * @return current task\n     */\n    @Override\n    public TransferableTask<?> and(TransferableTask<?> prev, String fromState) {", "        if (type == null) {\n            type = TaskType.AND;\n        } else if (type.equals(TaskType.ANY)) {\n            throw new TaskArrangeException(\"Type is already set to 'ANY', can not add task of type 'AND', task: \" + this);\n        }\n\n        saggioTask.getPushDownTable().add(prev, fromState, this);\n        this.addPrevTask(prev);\n\n        return this;\n    }\n\n    /**\n     * link previous task to current one, meaning that if any previous tasks executed successfully and returned the given state, current task will be executed.\n     *\n     * @param prev previous task\n     * @param fromState transfer state\n     * @return current task\n     */\n    @Override\n    public TransferableTask<?> any(TransferableTask<?> prev, String fromState) {", "        if (type == null) {\n            type = TaskType.ANY;\n        } else if (type.equals(TaskType.AND)) {\n            throw new TaskArrangeException(\"Type is already set to 'AND', can not add task of type 'ANY', task: \" + this);\n        }\n\n        saggioTask.getPushDownTable().add(prev, fromState, this);\n        this.addPrevTask(prev);\n\n        return this;\n    }\n\n    protected void addPrevTask(TransferableTask<?>... tasks) {\n        prevTasks.addAll(Arrays.asList(tasks));\n    }\n\n    protected void begin(ThreadPoolExecutor executor, TaskContext context) {\n        sync.begin(executor, context);\n    }\n\n    /**\n     * task's executed method, the task will wait\n     * till all/any prev tasks arriving according to the task type,\n     * or end to meet the timeout or being interrupted.\n     *\n     * @param executor thread pool\n     * @param context TaskContext\n     * @param isBegin is begin() execute, that is, the task will be immediately executed without any waiting\n     */\n    protected void execute(ThreadPoolExecutor executor, TaskContext context, boolean isBegin) {\n        sync.execute(executor, context, isBegin);\n    }\n\n    /**\n     * execute prevFunc, taskFunc and callback\n     *\n     * @param context TaskContext\n     * @return TaskResult\n     */\n    @Override\n    public TaskResult<T> doExecute(TaskContext context) {", "        if (prevFunc != null) {\n            prevFunc.execute(context);\n        }\n\n        TaskResult<T> result;\n        try {\n            result = taskFunc.execute(context);\n\n            if (callback != null) {\n                callback.execute(result, context);\n            }\n\n            sync.updateSuccessStatus();\n\n            return result;\n        } catch (InterruptedException e) {\n            System.out.println(\"Executing task[\" + this + \"] has been interrupted, caused by: \" + e.getCause());\n\n            sync.handleInterrupted(context);\n\n            return new TaskResult<>(null, null);\n        }\n    }\n\n    @Override\n    public HashSet<TransferableTask<?>> getPrevTasks() {\n        return prevTasks;\n    }\n\n    @Override", "            if (callback != null) {\n                callback.execute(result, context);\n            }\n\n            sync.updateSuccessStatus();\n\n            return result;\n        } catch (InterruptedException e) {\n            System.out.println(\"Executing task[\" + this + \"] has been interrupted, caused by: \" + e.getCause());\n\n            sync.handleInterrupted(context);\n\n            return new TaskResult<>(null, null);\n        }\n    }\n\n    @Override\n    public HashSet<TransferableTask<?>> getPrevTasks() {\n        return prevTasks;\n    }\n\n    @Override", "    public String getName() {\n        return name;\n    }\n\n    @Override\n    public TaskType getType() {\n        return type;\n    }\n\n    @Override\n    public PrevTaskFunction getPrevFunc() {\n        return prevFunc;\n    }\n\n    @Override\n    public TaskFunction<T> getTaskFunc() {\n        return taskFunc;\n    }\n\n    @Override\n    public TaskCallback<T> getCallback() {\n        return callback;\n    }\n\n    public TransferableTask<?> setTimeout(int timeout, TimeUnit timeUnit) {\n        this.timeout = timeout;\n        this.timeUnit = timeUnit;\n        this.useCustomizedTimeout = true;\n        return this;\n    }\n", "    public PrevTaskFunction getPrevFunc() {\n        return prevFunc;\n    }\n\n    @Override\n    public TaskFunction<T> getTaskFunc() {\n        return taskFunc;\n    }\n\n    @Override\n    public TaskCallback<T> getCallback() {\n        return callback;\n    }\n\n    public TransferableTask<?> setTimeout(int timeout, TimeUnit timeUnit) {\n        this.timeout = timeout;\n        this.timeUnit = timeUnit;\n        this.useCustomizedTimeout = true;\n        return this;\n    }\n", "    public boolean isUseCustomizedTimeout() {\n        return useCustomizedTimeout;\n    }\n\n    public int getTimeout() {\n        return timeout;\n    }\n\n    public TimeUnit getTimeUnit() {\n        return timeUnit;\n    }\n", "    public TimeUnit getTimeUnit() {\n        return timeUnit;\n    }\n\n    public void setPrevFunc(PrevTaskFunction prevFunc) {\n        this.prevFunc = prevFunc;\n    }\n\n    public void setCallback(TaskCallback<T> callback) {\n        this.callback = callback;\n    }\n\n    protected void setType(TaskType type) {\n        this.type = type;\n    }\n", "    public void setCallback(TaskCallback<T> callback) {\n        this.callback = callback;\n    }\n\n    protected void setType(TaskType type) {\n        this.type = type;\n    }\n\n    public SaggioTask getSaggioTask() {\n        return saggioTask;\n    }\n\n    public TaskSynchronizer<T> getSync() {\n        return sync;\n    }\n\n    @Override", "    public SaggioTask getSaggioTask() {\n        return saggioTask;\n    }\n\n    public TaskSynchronizer<T> getSync() {\n        return sync;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        TransferableTask<?> that = (TransferableTask<?>) o;\n        return Objects.equals(name, that.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name);\n    }\n\n    @Override", "    public int hashCode() {\n        return Objects.hash(name);\n    }\n\n    @Override\n    public String toString() {\n        return \"TransferableTask{\" +\n                \"name='\" + name + '\\'' +\n                \", type=\" + type +\n                '}';\n    }\n\n    protected static class TaskSynchronizer<T> implements TaskSync {\n        // locks and concurrent-working arrangement attributes\n        final Semaphore canWork = new Semaphore(0);\n        final Lock joinLock = new ReentrantLock();\n        final AtomicInteger notArrivedCount = new AtomicInteger();\n        volatile boolean executed = false;\n        volatile boolean canceled = false;\n        /**\n         * The thread which is executing execute() method, may be block by canWork.acquire() and will be set to null when executed.\n         */\n        volatile Thread currentThread;\n\n        final TransferableTask<T> task;\n\n        public TaskSynchronizer(TransferableTask<T> task) {", "            if (task == null) {\n                throw new RuntimeException(\"TaskSynchronizer's task can not be null\");\n            }\n\n            this.task = task;\n        }\n\n        /**\n         * wait till all/any prev taskFunc tasks arriving according to the task type,\n         * or end to meet the timeout or being interrupted\n         *\n         * @param context TaskContext\n         * @return if task can work\n         */\n        @Override", "        public boolean waitToWork(TaskContext context) {\n//            System.out.println(\"enter wait, thread: \" + Thread.currentThread());\n\n            int _timeout = task.isUseCustomizedTimeout() ? task.getTimeout() : context.getConfig().getTimeout();\n            TimeUnit _timeUnit = task.isUseCustomizedTimeout() ? task.getTimeUnit() : context.getConfig().getTimeUnit();\n\n            try {\n                if (!canWork.tryAcquire(_timeout, _timeUnit)) {\n                    // if acquire timeout\n                    System.out.println(\"TransferableTask[\" + task + \"] acquiring semaphore has been stopped, caused by: timeout--\" + _timeout + \" \" + _timeUnit);\n\n                    handleWaitTimeout(context);\n                    return false;\n                }\n\n                return true;\n            } catch (InterruptedException e) {\n                System.out.println(\"TransferableTask[\" + task + \"] acquiring semaphore has been interrupted\");\n\n                handleInterrupted(context);\n                return false;\n            }\n        }\n\n        /**\n         * task executes as the serial-tasks' beginning node\n         *\n         * @param executor thread pool\n         * @param context TaskContext\n         */", "        public void begin(ThreadPoolExecutor executor, TaskContext context) {\n            canWork.release();\n\n            task.execute(executor, context, true);\n        }\n\n        /**\n         * task's executed method, the task will wait\n         * till all/any prev tasks arriving according to the task type,\n         * or end to meet the timeout or being interrupted.\n         *\n         * @param executor thread pool\n         * @param context TaskContext\n         * @param isBegin is begin() execute, that is, the task will be immediately executed without any waiting\n         */\n        @Override", "        public void execute(ThreadPoolExecutor executor, TaskContext context, boolean isBegin) {\n            currentThread = Thread.currentThread();\n            currentThread.setName(\"task-\" + task.name);\n\n            if (!isBegin) {\n                joinLock.unlock();\n            }\n\n            if (!waitToWork(context)) {\n                return;\n            }\n\n            stopPrevAny(context);\n\n            TaskResult<T> result = task.doExecute(context);\n\n            next(result.getState(), executor, context);\n        }\n\n        /**\n         * join() is the way to execute the current task or update current task's status, according to current task's working state. <br/>\n         * Executed by previous task.\n         *\n         * @param executor thread pool\n         * @param context TaskContext\n         */\n        @Override", "            if (!waitToWork(context)) {\n                return;\n            }\n\n            stopPrevAny(context);\n\n            TaskResult<T> result = task.doExecute(context);\n\n            next(result.getState(), executor, context);\n        }\n\n        /**\n         * join() is the way to execute the current task or update current task's status, according to current task's working state. <br/>\n         * Executed by previous task.\n         *\n         * @param executor thread pool\n         * @param context TaskContext\n         */\n        @Override", "        public void join(ThreadPoolExecutor executor, TaskContext context) {\n            boolean isBoot = false;\n\n            // optimize\n            if (isExecuted() || isCanceled() || (isExecuting() && TaskType.ANY.equals(task.getType()))) {\n                return;\n            }\n\n            try {\n                joinLock.lock();\n", "            try {\n                joinLock.lock();\n\n                if (isExecuted() || isCanceled()) {\n                    return;\n                }\n\n                // if the task is not executed\n                if (!isExecuting()) {\n                    isBoot = true;\n                    notArrivedCount.set(task.getPrevTasks().size());\n", "                if (!isExecuting()) {\n                    isBoot = true;\n                    notArrivedCount.set(task.getPrevTasks().size());\n\n                    if (TaskType.ANY.equals(task.getType())) {\n                        canWork.release();\n                    } else if (TaskType.AND.equals(task.getType())) {\n                        if (notArrivedCount.decrementAndGet() == 0) {\n                            canWork.release();\n                        }\n                    }\n                    task.execute(executor, context, false);\n                } else {", "                    if (TaskType.AND.equals(task.getType())) {\n                        if (notArrivedCount.decrementAndGet() == 0) {\n                            canWork.release();\n                        }\n                    }\n                }\n            } finally {\n                if (!isBoot) {\n                    joinLock.unlock();\n                }\n            }\n        }\n\n        /**\n         * jump to and execute all next tasks\n         *\n         * @param state  transfer state from this to next\n         * @param executor thread pool\n         * @param context TaskContext\n         */\n        @Override", "        public void next(String state, ThreadPoolExecutor executor, TaskContext context) {\n            HashSet<TransferableTask<?>> nextTasks = task.getSaggioTask().getPushDownTable().getNextTasks(this.task, state);\n            if (nextTasks == null || nextTasks.isEmpty()) {\n                return;\n            }\n\n            executedAllNext(nextTasks, executor, context);\n        }\n\n        /**\n         * execute all next tasks\n         *\n         * @param nextTasks tasks need to be executed\n         * @param executor thread pool\n         * @param context TaskContext\n         */\n        private void executedAllNext(HashSet<TransferableTask<?>> nextTasks, ThreadPoolExecutor executor, TaskContext context) {", "            for (TransferableTask<?> nextTask : nextTasks) {\n                executor.execute(() -> nextTask.getSync().join(executor, context));\n            }\n        }\n\n        public void updateSuccessStatus() {\n            executed = true;\n            currentThread = null;\n        }\n\n        /**\n         * handle task's waiting/executing interrupted\n         *\n         * @param context TaskContext\n         */\n        @Override", "        public void handleInterrupted(TaskContext context) {\n            // if the destination task is executing/waiting interrupted, the prev tasks are not needed to be executed.\n            stopPrevAnd(context);\n            stopPrevAny(context);\n            stopAfterPrev(context);\n\n            currentThread = null;\n            canceled = true;\n        }\n\n        /**\n         * handle task waiting timeout\n         *\n         * @param context TaskContext\n         */", "        public void handleWaitTimeout(TaskContext context) {\n            // if the destination task is waiting timeout, the prev tasks are not needed to be executed.\n            stopPrevAnd(context);\n            stopPrevAny(context);\n            stopAfterPrev(context);\n\n            currentThread = null;\n            canceled = true;\n        }\n\n        /**\n         * handle task arrived to current task whose type is ANY\n         *\n         * @param context TaskContext\n         */", "        public void handleAnyArrived(TaskContext context) {\n            stopPrevAny(context);\n        }\n\n        /**\n         * stop the task's all previous executing tasks if current task's type is ANY and need to stop according to the setting stopIfNextStopped\n         *\n         * @param context TaskContext\n         */\n        private void stopPrevAny(TaskContext context) {\n            if (!context.getConfig().isRecursivelyStop()) {\n                return;\n            }\n", "            if (!context.getConfig().isRecursivelyStop()) {\n                return;\n            }\n\n            if (TaskType.ANY.equals(task.getType())) {\n                for (TransferableTask<?> prevTask : task.getPrevTasks()) {\n                    if (prevTask.getSync().isExecuting()) {\n                        try {\n                            System.out.println(\"Executing task[\" + prevTask + \"] will be interrupted, caused by: stopPrevAny(), by task: \" + task);\n                            prevTask.getSync().getCurrentThread().interrupt();\n                        } catch (NullPointerException ignored) {\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * stop the task's all previous executing tasks if current task's type is AND and need to stop according to the setting stopIfNextStopped\n         *\n         * @param context TaskContext\n         */\n        private void stopPrevAnd(TaskContext context) {", "            if (!context.getConfig().isRecursivelyStop()) {\n                return;\n            }\n\n            if (TaskType.AND.equals(task.getType())) {\n                for (TransferableTask<?> prevTask : task.getPrevTasks()) {\n                    if (prevTask.getSync().isExecuting()) {\n                        try {\n                            System.out.println(\"Executing task[\" + task + \"] will be interrupted, caused by: stopPrevAnd(), by task: \" + task);\n                            prevTask.getSync().getCurrentThread().interrupt();\n                        } catch (NullPointerException ignored) {\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * stop the task's all next executing tasks' prev tasks if needed to stop according to the setting stopIfNextStopped\n         *\n         * @param context TaskContext\n         */\n        private void stopAfterPrev(TaskContext context) {", "            if (!context.getConfig().isRecursivelyStop()) {\n                return;\n            }\n\n            final HashMap<String, HashSet<TransferableTask<?>>> nextTasks = task.getSaggioTask().getPushDownTable().getNextTasks(this.task);\n            if (nextTasks == null) {\n                return;\n            }\n\n            for (HashSet<TransferableTask<?>> tasks : nextTasks.values()) {\n                for (TransferableTask<?> task : tasks) {", "            for (HashSet<TransferableTask<?>> tasks : nextTasks.values()) {\n                for (TransferableTask<?> task : tasks) {\n                    if (TaskType.AND.equals(task.getType())) {\n                        if (task.getSync().isExecuting()) {\n                            try {\n                                System.out.println(\"Executing task[\" + task + \"] will be interrupted, caused by: tryStopAfterPrev(), by task: \" + this.task);\n                                task.getSync().getCurrentThread().interrupt();\n                            } catch (NullPointerException ignored) {\n                            }\n                        }\n                    }\n", "                    if (TaskType.ANY.equals(task.getType())) {\n                        if (task.getSync().isExecuting() && task.getSync().getNotArrivedCount() == 1) {\n                            // if only current task has not arrived, stop its next task\n                            try {\n                                System.out.println(\"Executing task[\" + task + \"] will be interrupted, caused by: tryStopAfterPrev(), by task: \" + this.task);\n                                task.getSync().getCurrentThread().interrupt();\n                            } catch (NullPointerException ignored) {\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        @Override", "        public boolean isExecuting() {\n            return currentThread != null && !canceled;\n        }\n\n        @Override\n        public boolean isExecuted() {\n            return executed && !canceled;\n        }\n\n        @Override\n        public boolean isCanceled() {\n            return canceled;\n        }\n\n        @Override", "        public boolean isCanceled() {\n            return canceled;\n        }\n\n        @Override\n        public Thread getCurrentThread() {\n            return currentThread;\n        }\n\n        public int getNotArrivedCount() {\n            return notArrivedCount.get();\n        }\n    }\n}\n", "        public int getNotArrivedCount() {\n            return notArrivedCount.get();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/SaggioTask.java", "chunked_list": ["package io.github.riicarus;\n\nimport io.github.riicarus.dsl.TaskArrangeDSLParser;\nimport io.github.riicarus.function.PrevTaskFunction;\nimport io.github.riicarus.function.TaskCallback;\nimport io.github.riicarus.function.TaskFunction;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ThreadPoolExecutor;", "import java.util.List;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * [FEATURE INFO]<br/>\n * task api\n *\n * @author Riicarus\n * @create 2023-6-1 14:48", " * @author Riicarus\n * @create 2023-6-1 14:48\n * @since 1.0.0\n */\npublic class SaggioTask {\n\n    /**\n     * count of tasks, used for task name generation\n     */\n    private final AtomicInteger taskCount = new AtomicInteger(0);\n\n    private final TaskPushDownTable PUSH_DOWN_TABLE = new TaskPushDownTable();\n\n    private final HashMap<String, TransferableTask<?>> TASKS = new HashMap<>();\n\n    private final TaskArrangeDSLParser dslParser = new TaskArrangeDSLParser(this);\n\n    public SaggioTask() {\n    }\n\n    /**\n     * build an initial task with needed attributes\n     *\n     * @param name task name\n     * @param taskFunc main task function\n     * @param <T> type of taskFunc result's data\n     * @return initial task\n     */\n    public <T> TransferableTask<T> build(String name, TaskFunction<T> taskFunc) {\n        TransferableTask<T> task = new TransferableTask<>(name, taskFunc, this);\n        TASKS.put(task.getName(), task);\n\n        return task;\n    }\n\n    /**\n     * build an initial task with needed attributes\n     *\n     * @param name task name\n     * @param taskFunc main task function\n     * @param callback callback function after task function's execution\n     * @param <T> type of taskFunc result's data\n     * @return initial task\n     */\n    public <T> TransferableTask<T> build(String name, TaskFunction<T> taskFunc, TaskCallback<T> callback) {\n        TransferableTask<T> task = new TransferableTask<>(name, taskFunc, callback, this);\n        TASKS.put(task.getName(), task);\n\n        return task;\n    }\n\n    /**\n     * build an initial task with needed attributes\n     *\n     * @param name task name\n     * @param prevFunc function executed before task function's execution\n     * @param taskFunc main task function\n     * @param callback callback function after task function's execution\n     * @param <T> type of taskFunc result's data\n     * @return initial task\n     */\n    public <T> TransferableTask<T> build(String name, PrevTaskFunction prevFunc, TaskFunction<T> taskFunc, TaskCallback<T> callback) {\n        TransferableTask<T> task = new TransferableTask<>(name, taskFunc, callback, this);\n        task.setPrevFunc(prevFunc);\n\n        TASKS.put(task.getName(), task);\n\n        return task;\n    }\n\n    /**\n     * generate an initial copy of the given task\n     *\n     * @param name task name\n     * @param srcTask the source task to be copied\n     * @param <T> type of task result's data\n     * @return initial task\n     */\n    public <T> TransferableTask<T> buildFrom(String name, TransferableTask<T> srcTask) {\n        return build(name, srcTask.getPrevFunc(), srcTask.getTaskFunc(), srcTask.getCallback());\n    }\n", "    public void arrange(String arrangement) {\n        dslParser.parse(arrangement);\n    }\n\n    /**\n     * run a serial-tasks from the given tasks\n     *\n     * @param tasks start tasks\n     * @param executor thread pool\n     * @param context TaskContext\n     */", "    public void run(List<TransferableTask<?>> tasks, ThreadPoolExecutor executor, TaskContext context) {\n        for (TransferableTask<?> task : tasks) {\n            executor.execute(() -> task.begin(executor, context));\n        }\n    }\n\n    protected int generateId() {\n        return taskCount.getAndIncrement();\n    }\n\n    protected TaskPushDownTable getPushDownTable() {\n        return PUSH_DOWN_TABLE;\n    }\n\n    public TransferableTask<?> getTask(String name) {\n        return TASKS.get(name);\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/function/PrevTaskFunction.java", "chunked_list": ["package io.github.riicarus.function;\n\nimport io.github.riicarus.TaskContext;\n\n/**\n * [FEATURE INFO]<br/>\n * function execute before task execution\n *\n * @author Riicarus\n * @create 2023-6-8 23:34", " * @author Riicarus\n * @create 2023-6-8 23:34\n * @since 1.0.0\n */\n@FunctionalInterface\npublic interface PrevTaskFunction {\n\n    void execute(TaskContext context);\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/function/TaskCallback.java", "chunked_list": ["package io.github.riicarus.function;\n\nimport io.github.riicarus.TaskContext;\nimport io.github.riicarus.TaskResult;\n\n/**\n * [FEATURE INFO]<br/>\n *\n * @author Riicarus\n * @create 2023-5-25 20:24", " * @author Riicarus\n * @create 2023-5-25 20:24\n * @since 1.0.0\n */\n@FunctionalInterface\npublic interface TaskCallback<T> {\n\n    void execute(TaskResult<T> result, TaskContext context);\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/function/TaskFunction.java", "chunked_list": ["package io.github.riicarus.function;\n\nimport io.github.riicarus.TaskContext;\nimport io.github.riicarus.TaskResult;\n\n/**\n * [FEATURE INFO]<br/>\n *\n * @author Riicarus\n * @create 2023-5-25 20:01", " * @author Riicarus\n * @create 2023-5-25 20:01\n * @since 1.0.0\n */\n@FunctionalInterface\npublic interface TaskFunction<T> {\n\n    TaskResult<T> execute(TaskContext context) throws InterruptedException;\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/exception/TaskArrangeDSLGrammarException.java", "chunked_list": ["package io.github.riicarus.exception;\n\n/**\n * Exception for task arrange dsl grammar\n *\n * @author Riicarus\n * @create 2023-7-28 20:42\n * @since 1.1.0\n */\npublic class TaskArrangeDSLGrammarException extends RuntimeException {\n\n    public TaskArrangeDSLGrammarException(String message) {\n        super(message);\n    }\n\n}\n", " */\npublic class TaskArrangeDSLGrammarException extends RuntimeException {\n\n    public TaskArrangeDSLGrammarException(String message) {\n        super(message);\n    }\n\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/exception/TaskArrangeException.java", "chunked_list": ["package io.github.riicarus.exception;\n\n/**\n * Runtime exception when task arrangement failed\n *\n * @author Riicarus\n * @create 2023-7-27 8:10\n * @since 1.0.2\n */\npublic class TaskArrangeException extends RuntimeException {\n\n    public TaskArrangeException(String message) {\n        super(message);\n    }\n\n    public TaskArrangeException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n", " */\npublic class TaskArrangeException extends RuntimeException {\n\n    public TaskArrangeException(String message) {\n        super(message);\n    }\n\n    public TaskArrangeException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n"]}
{"filename": "src/main/java/io/github/riicarus/dsl/TaskArrangeDSLParser.java", "chunked_list": ["package io.github.riicarus.dsl;\n\nimport io.github.riicarus.SaggioTask;\nimport io.github.riicarus.TaskType;\nimport io.github.riicarus.TransferableTask;\nimport io.github.riicarus.exception.TaskArrangeDSLGrammarException;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;", "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Parser for task arrangement dsl. <br/>\n * <p>\n * Parse dsl like: <br/>\n * - task#0 & taskA, taskB, taskC <br/>", " * Parse dsl like: <br/>\n * - task#0 & taskA, taskB, taskC <br/>\n * - taskA#A-D, taskB#B-D, taskC#C-D | taskD <br/>\n *\n * @author Riicarus\n * @create 2023-7-28 7:14\n * @since 1.1.0\n */\npublic class TaskArrangeDSLParser {\n\n    // reserved words", "public class TaskArrangeDSLParser {\n\n    // reserved words\n    public static final String AND_LINKER = \" & \";\n    public static final String ANY_LINKER = \" \\\\| \";\n    public static final String TASK_LINKER = \", \";\n    public static final String STATE_LINKER = \"#\";\n    public static final String TIMEOUT_LINKER = \"@\";\n\n    private SaggioTask saggioTask;\n\n    public TaskArrangeDSLParser(SaggioTask saggioTask) {", "        if (saggioTask == null) {\n            throw new RuntimeException(\"SaggioTask of DSLParser can not be null.\");\n        }\n        this.saggioTask = saggioTask;\n    }\n\n    public void parse(String str) {\n        if (str == null) {\n            return;\n        }\n\n        HashMap<String, String> items = splitParts(str);\n        TaskType type = getTaskType(str);\n\n        List<String> fromTaskNamesWithState = Arrays.asList(items.get(\"from\").split(TASK_LINKER));\n        List<String> toTaskNames = Arrays.asList(items.get(\"to\").split(TASK_LINKER));\n        int timeout = Integer.parseInt(items.get(\"timeout\"));\n\n        List<FromTaskEntry> fromTaskEntries = splitFromTask(fromTaskNamesWithState);\n        List<TransferableTask<?>> toTasks = splitToTask(toTaskNames);\n\n        arrangeTasks(fromTaskEntries, toTasks, type, timeout);\n    }\n\n    private HashMap<String, String> splitParts(String str) {\n        // example: task#0 & taskA, taskB, taskC @1000\n\n        // split by ANY_LINKER or AND_LINKER\n        // res: [\"task#0\", \"taskA, taskB, taskC\"]\n        HashMap<String, String> items = new HashMap<>();\n\n        int timeoutLinkerIdx = str.lastIndexOf(TIMEOUT_LINKER);\n        String timeoutStr = timeoutLinkerIdx == -1 ? \"0\" : str.substring(timeoutLinkerIdx + 1).trim();\n        items.put(\"timeout\", timeoutStr);\n\n        String subStr = timeoutLinkerIdx == -1 ? str : str.substring(0, timeoutLinkerIdx).trim();\n        String[] subItems;\n", "        if (subStr.contains(ANY_LINKER)) {\n            subItems = subStr.split(ANY_LINKER);\n        } else if (subStr.contains(AND_LINKER)) {\n            subItems = subStr.split(AND_LINKER);\n        } else {\n            throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Can not find task relation linker.\");\n        }\n\n        if (subItems.length != 2) {\n            throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Some needed part(s) of dsl missed.\");\n        }\n\n        items.put(\"from\", subItems[0]);\n        items.put(\"to\", subItems[1]);\n\n        return items;\n    }\n\n    private List<FromTaskEntry> splitFromTask(List<String> fromTaskNamesWithState) {\n        List<FromTaskEntry> fromTaskEntries = new ArrayList<>();\n", "        if (subItems.length != 2) {\n            throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Some needed part(s) of dsl missed.\");\n        }\n\n        items.put(\"from\", subItems[0]);\n        items.put(\"to\", subItems[1]);\n\n        return items;\n    }\n\n    private List<FromTaskEntry> splitFromTask(List<String> fromTaskNamesWithState) {\n        List<FromTaskEntry> fromTaskEntries = new ArrayList<>();\n", "        for (String taskNameWithStatus : fromTaskNamesWithState) {\n            String[] parts = taskNameWithStatus.split(STATE_LINKER);\n            if (parts.length != 2) {\n                throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Some needed part(s) of from task symbol missed.\");\n            }\n\n            TransferableTask<?> task = saggioTask.getTask(parts[0]);\n            if (task == null) {\n                throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Can not find task of name: \" + parts[0] + \".\");\n            }\n            fromTaskEntries.add(new FromTaskEntry(task, parts[1]));\n        }\n\n        return fromTaskEntries;\n    }\n\n    private List<TransferableTask<?>> splitToTask(List<String> toTaskNames) {\n        List<TransferableTask<?>> toTasks = new ArrayList<>();\n", "        for (String toTaskName : toTaskNames) {\n            TransferableTask<?> task = saggioTask.getTask(toTaskName);\n            if (task == null) {\n                throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Can not find task of name: \" + toTaskName + \".\");\n            }\n            toTasks.add(task);\n        }\n\n        return toTasks;\n    }\n\n    private void arrangeTasks(List<FromTaskEntry> fromTaskEntries, List<TransferableTask<?>> toTasks, TaskType type, int timeout) {", "        if (timeout <= 0) {\n            timeout = TransferableTask.DEFAULT_TIMEOUT;\n        }\n\n        if (TaskType.ANY.equals(type)) {\n            for (TransferableTask<?> toTask : toTasks) {\n                for (FromTaskEntry fromTaskEntry : fromTaskEntries) {\n                    toTask.any(fromTaskEntry.task, fromTaskEntry.state)\n                            .setTimeout(timeout, TimeUnit.MILLISECONDS);\n                }\n            }", "        } else if (TaskType.AND.equals(type)) {\n            for (TransferableTask<?> toTask : toTasks) {\n                for (FromTaskEntry fromTaskEntry : fromTaskEntries) {\n                    toTask.and(fromTaskEntry.task, fromTaskEntry.state)\n                            .setTimeout(timeout, TimeUnit.MILLISECONDS);\n                }\n            }\n        }\n    }\n\n    private TaskType getTaskType(String str) {", "        if (str.contains(AND_LINKER)) {\n            return TaskType.AND;\n        } else if (str.contains(ANY_LINKER)) {\n            return TaskType.ANY;\n        } else {\n            throw new TaskArrangeDSLGrammarException(\"You've got a grammar syntax in the task arrangement dsl: Can not find task relation linker.\");\n        }\n    }\n\n    public TaskArrangeDSLParser setSaggioTask(SaggioTask saggioTask) {\n        this.saggioTask = saggioTask;\n        return this;\n    }\n\n    private record FromTaskEntry(TransferableTask<?> task, String state) {\n    }\n}\n", "    public TaskArrangeDSLParser setSaggioTask(SaggioTask saggioTask) {\n        this.saggioTask = saggioTask;\n        return this;\n    }\n\n    private record FromTaskEntry(TransferableTask<?> task, String state) {\n    }\n}\n"]}
