{"filename": "forge/src/main/java/com/xtracr/realcamera/EventHandler.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.CrosshairUtils;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.render.Camera;\nimport net.minecraftforge.client.event.InputEvent.Key;\nimport net.minecraftforge.client.event.RenderLevelStageEvent;\nimport net.minecraftforge.client.event.ViewportEvent.ComputeCameraAngles;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;", "import net.minecraftforge.client.event.ViewportEvent.ComputeCameraAngles;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\n\npublic class EventHandler {\n    @SubscribeEvent\n    public static void onKeyInput(Key event) {\n        KeyBindings.handle(MinecraftClient.getInstance());\n    }\n\n    @SubscribeEvent\n    public static void onCameraUpdate(ComputeCameraAngles event) {", "    public static void onCameraUpdate(ComputeCameraAngles event) {\n        if (RealCameraCore.isActive()) {\n            Camera camera = event.getCamera();\n            RealCameraCore.updateCamera(camera, event.getRenderer().getClient(), (float) event.getPartialTick());\n            event.setPitch(camera.getPitch());\n            event.setYaw(camera.getYaw());\n            event.setRoll(RealCameraCore.getRoll());\n        }\n    }\n\n    @SubscribeEvent", "    public static void onRenderWorldStage(RenderLevelStageEvent event) {\n        if (RenderLevelStageEvent.Stage.AFTER_SKY.equals(event.getStage())) {\n            RealCameraCore.isRenderingWorld = true;\n            if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n                CrosshairUtils.update(MinecraftClient.getInstance(), event.getCamera(),\n                        event.getPoseStack().peek().getPositionMatrix(), event.getProjectionMatrix());\n            }\n        } else if (RenderLevelStageEvent.Stage.AFTER_WEATHER.equals(event.getStage())) {\n            RealCameraCore.isRenderingWorld = false;\n        }\n    }\n}\n"]}
{"filename": "forge/src/main/java/com/xtracr/realcamera/RealCameraForge.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.config.ConfigScreen;\nimport net.minecraftforge.client.ConfigScreenHandler.ConfigScreenFactory;\nimport net.minecraftforge.client.event.RegisterKeyMappingsEvent;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\nimport net.minecraftforge.fml.ModList;\nimport net.minecraftforge.fml.ModLoadingContext;", "import net.minecraftforge.fml.ModList;\nimport net.minecraftforge.fml.ModLoadingContext;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\n\n@Mod(RealCamera.MODID)\npublic class RealCameraForge {\n    public RealCameraForge() {\n        IEventBus eventBus = FMLJavaModLoadingContext.get().getModEventBus();\n        eventBus.addListener(this::clientSetup);\n        eventBus.addListener(this::onKeyRegister);\n    }\n\n    @SubscribeEvent", "    public void clientSetup(FMLClientSetupEvent event) {\n        RealCamera.setup();\n\n        MinecraftForge.EVENT_BUS.addListener(EventHandler::onKeyInput);\n        MinecraftForge.EVENT_BUS.addListener(EventHandler::onCameraUpdate);\n        MinecraftForge.EVENT_BUS.addListener(EventHandler::onRenderWorldStage);\n\n        if (ModList.get().isLoaded(\"cloth_config\")) {\n            ModLoadingContext.get().registerExtensionPoint(ConfigScreenFactory.class,\n                    () -> new ConfigScreenFactory((client, parent) -> ConfigScreen.create(parent)));\n        }\n    }\n\n    @SubscribeEvent", "    public void onKeyRegister(RegisterKeyMappingsEvent event) {\n        event.register(KeyBindings.TOGGLE_PERSPECTIVE);\n        event.register(KeyBindings.TOGGLE_ADJUST_MODE);\n        event.register(KeyBindings.TOGGLE_CAMERA_MODE);\n        event.register(KeyBindings.ADJUST_UP);\n        event.register(KeyBindings.ADJUST_DOWN);\n        event.register(KeyBindings.ADJUST_BACK);\n        event.register(KeyBindings.ADJUST_FRONT);\n        event.register(KeyBindings.ADJUST_LEFT);\n        event.register(KeyBindings.ADJUST_RIGHT);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/RealCamera.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.api.CompatExample;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RealCamera {\n    public static final String MODID = \"realcamera\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MODID);\n", "    public static final String MODID = \"realcamera\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MODID);\n\n    public static void setup() {\n        ConfigFile.load();\n        CompatExample.register();\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/KeyBindings.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.config.ModConfig;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.option.KeyBinding;\nimport net.minecraft.client.util.InputUtil;\nimport org.lwjgl.glfw.GLFW;\n\npublic final class KeyBindings {\n    private static final ModConfig config = ConfigFile.modConfig;\n    private static final String KEY_CATEGORY = \"key.category.xtracr_\" + RealCamera.MODID;\n    private static final String KEY_ID = \"key.xtracr_\" + RealCamera.MODID + \"_\";\n", "\npublic final class KeyBindings {\n    private static final ModConfig config = ConfigFile.modConfig;\n    private static final String KEY_CATEGORY = \"key.category.xtracr_\" + RealCamera.MODID;\n    private static final String KEY_ID = \"key.xtracr_\" + RealCamera.MODID + \"_\";\n\n    public static final KeyBinding TOGGLE_PERSPECTIVE = new KeyBinding(\n            KEY_ID + \"togglePerspective\", InputUtil.Type.KEYSYM, GLFW.GLFW_KEY_F6, KEY_CATEGORY);\n    public static final KeyBinding TOGGLE_ADJUST_MODE = new KeyBinding(\n            KEY_ID + \"toggleAdjustMode\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding TOGGLE_CAMERA_MODE = new KeyBinding(\n            KEY_ID + \"toggleCameraMode\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);", "    public static final KeyBinding TOGGLE_ADJUST_MODE = new KeyBinding(\n            KEY_ID + \"toggleAdjustMode\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding TOGGLE_CAMERA_MODE = new KeyBinding(\n            KEY_ID + \"toggleCameraMode\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_UP = new KeyBinding(\n            KEY_ID + \"adjustUP\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_DOWN = new KeyBinding(\n            KEY_ID + \"adjustDOWN\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_FRONT = new KeyBinding(\n            KEY_ID + \"adjustFRONT\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_BACK = new KeyBinding(\n            KEY_ID + \"adjustBACK\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);", "    public static final KeyBinding ADJUST_FRONT = new KeyBinding(\n            KEY_ID + \"adjustFRONT\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_BACK = new KeyBinding(\n            KEY_ID + \"adjustBACK\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_LEFT = new KeyBinding(\n            KEY_ID + \"adjustLEFT\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n    public static final KeyBinding ADJUST_RIGHT = new KeyBinding(\n            KEY_ID + \"adjustRIGHT\", InputUtil.Type.KEYSYM, InputUtil.UNKNOWN_KEY.getCode(), KEY_CATEGORY);\n\n    public static void handle(MinecraftClient client) {\n        if (client.player == null || client.currentScreen != null) return;\n", "    public static void handle(MinecraftClient client) {\n        if (client.player == null || client.currentScreen != null) return;\n\n        while (TOGGLE_PERSPECTIVE.wasPressed()) {\n            boolean enabled = config.isEnabled();\n            ConfigFile.load();\n            config.setEnabled(!enabled);\n            ConfigFile.save();\n        }\n        while (TOGGLE_ADJUST_MODE.wasPressed()) {\n            if (config.isClassic()) config.cycleClassicAdjustMode();\n            else config.setAdjustOffset(!config.isAdjustingOffset());\n            ConfigFile.save();\n        }", "        while (TOGGLE_ADJUST_MODE.wasPressed()) {\n            if (config.isClassic()) config.cycleClassicAdjustMode();\n            else config.setAdjustOffset(!config.isAdjustingOffset());\n            ConfigFile.save();\n        }\n        while (TOGGLE_CAMERA_MODE.wasPressed()) {\n            config.setClassic(!config.isClassic());\n            ConfigFile.save();\n        }\n        while (ADJUST_LEFT.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicZ(true);\n            else config.adjustBindingZ(true);\n            ConfigFile.save();\n        }", "        while (ADJUST_LEFT.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicZ(true);\n            else config.adjustBindingZ(true);\n            ConfigFile.save();\n        }\n        while (ADJUST_RIGHT.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicZ(false);\n            else config.adjustBindingZ(false);\n            ConfigFile.save();\n        }\n        while (ADJUST_UP.wasPressed()) {", "        while (ADJUST_UP.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicY(true);\n            else config.adjustBindingY(true);\n            ConfigFile.save();\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicY(false);\n            else config.adjustBindingY(false);\n            ConfigFile.save();\n        }\n        while (ADJUST_FRONT.wasPressed()) {", "        while (ADJUST_FRONT.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicX(true);\n            else config.adjustBindingX(true);\n            ConfigFile.save();\n        }\n        while (ADJUST_BACK.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicX(false);\n            else config.adjustBindingX(false);\n            ConfigFile.save();\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/RealCameraCore.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.api.VirtualRenderer;\nimport com.xtracr.realcamera.compat.PehkuiCompat;\nimport com.xtracr.realcamera.compat.PhysicsModCompat;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.config.ModConfig;\nimport com.xtracr.realcamera.mixins.CameraAccessor;\nimport com.xtracr.realcamera.mixins.PlayerEntityRendererAccessor;\nimport com.xtracr.realcamera.utils.MathUtils;", "import com.xtracr.realcamera.mixins.PlayerEntityRendererAccessor;\nimport com.xtracr.realcamera.utils.MathUtils;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.client.render.entity.PlayerEntityRenderer;\nimport net.minecraft.client.render.entity.model.PlayerEntityModel;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.EntityPose;", "import net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.EntityPose;\nimport net.minecraft.entity.LivingEntity;\nimport net.minecraft.util.hit.HitResult;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.util.math.MathHelper;\nimport net.minecraft.util.math.RotationAxis;\nimport net.minecraft.util.math.Vec3d;\nimport net.minecraft.world.RaycastContext;\nimport org.joml.Matrix3f;", "import net.minecraft.world.RaycastContext;\nimport org.joml.Matrix3f;\nimport org.joml.Vector4f;\n\npublic class RealCameraCore {\n    private static final ModConfig config = ConfigFile.modConfig;\n\n    public static boolean isRenderingWorld = false;\n    private static String status = \"Successful\";\n    private static float cameraRoll = 0.0F;\n", "    public static String getStatus() {\n        return status;\n    }\n\n    public static float getRoll() {\n        return cameraRoll;\n    }\n\n    public static boolean isActive() {\n        MinecraftClient client = MinecraftClient.getInstance();\n        return config.isEnabled() && client.options.getPerspective().isFirstPerson() && client.gameRenderer.getCamera() != null\n                && client.player != null && !config.disableModWhen(client);\n    }\n", "    public static boolean isActive() {\n        MinecraftClient client = MinecraftClient.getInstance();\n        return config.isEnabled() && client.options.getPerspective().isFirstPerson() && client.gameRenderer.getCamera() != null\n                && client.player != null && !config.disableModWhen(client);\n    }\n\n    public static void updateCamera(Camera camera, MinecraftClient client, float tickDelta) {\n        cameraRoll = 0.0F;\n\n        if (config.isRendering() && !config.disableRenderingWhen(client)) {\n            ((CameraAccessor) camera).setThirdPerson(true);\n        }\n", "        if (config.isRendering() && !config.disableRenderingWhen(client)) {\n            ((CameraAccessor) camera).setThirdPerson(true);\n        }\n\n        if (config.isClassic()) {\n            classicModeUpdate(camera, client, tickDelta);\n        } else {\n            // GameRenderer.render\n            bindingModeUpdate(camera, client, tickDelta, new MatrixStack());\n        }\n    }\n\n    private static void classicModeUpdate(Camera camera, MinecraftClient client, float tickDelta) {\n        ClientPlayerEntity player = client.player;\n\n        float centerYaw = camera.getYaw();\n        float pitch = camera.getPitch() + config.getClassicPitch();\n        float yaw = centerYaw - config.getClassicYaw();\n        cameraRoll = config.getClassicRoll();\n        Vec3d refer = new Vec3d(config.getClassicRX(), config.getClassicRY(), config.getClassicRZ()).multiply(config.getScale());\n        Vec3d offset = new Vec3d(config.getClassicX(), config.getClassicY(), config.getClassicZ()).multiply(config.getScale());\n        Vec3d center = new Vec3d(config.getCenterX(), config.getCenterY(), config.getCenterZ()).multiply(config.getScale());\n", "        if (player.isSneaking()) {\n            center = center.add(0.0D, -0.021875D, 0.0D);\n        }\n        if (config.compatPehkui()) {\n            refer = PehkuiCompat.scaleVec3d(refer, player, tickDelta);\n            offset = PehkuiCompat.scaleVec3d(offset, player, tickDelta);\n            center = PehkuiCompat.scaleVec3d(center, player, tickDelta);\n        }\n\n        ((CameraAccessor) camera).invokeSetRotation(centerYaw, 0.0F);\n        ((CameraAccessor) camera).invokeMoveBy(center.getX(), center.getY(), center.getZ());\n        ((CameraAccessor) camera).invokeSetRotation(yaw, pitch);\n        offset = offset.subtract(refer);\n        ((CameraAccessor) camera).invokeMoveBy(refer.getX(), refer.getY(), refer.getZ());\n        Vec3d referVec = camera.getPos();\n        ((CameraAccessor) camera).invokeMoveBy(offset.getX(), offset.getY(), offset.getZ());\n        clipCameraToSpace(camera, referVec);\n    }\n\n    private static void bindingModeUpdate(Camera camera, MinecraftClient client, float tickDelta, MatrixStack matrixStack) {\n\n        // GameRenderer.renderWorld\n        matrixStack.multiply(RotationAxis.POSITIVE_X.rotationDegrees(camera.getPitch()));\n        matrixStack.multiply(RotationAxis.POSITIVE_Y.rotationDegrees(camera.getYaw() + 180.0F));\n        matrixStack.peek().getNormalMatrix().identity();\n        // WorldRenderer.render\n        ClientPlayerEntity player = client.player;", "        if (player.age == 0) {\n            player.lastRenderX = player.getX();\n            player.lastRenderY = player.getY();\n            player.lastRenderZ = player.getZ();\n        }\n        // WorldRenderer.renderEntity\n        Vec3d renderOffset = new Vec3d(MathHelper.lerp(tickDelta, player.lastRenderX, player.getX()),\n                MathHelper.lerp(tickDelta, player.lastRenderY, player.getY()),\n                MathHelper.lerp(tickDelta, player.lastRenderZ, player.getZ()))\n                .subtract(camera.getPos());\n        // EntityRenderDispatcher.render", "        if (config.compatPhysicsMod())\n            PhysicsModCompat.renderStart(client.getEntityRenderDispatcher(), player, renderOffset.getX(),\n                    renderOffset.getY(), renderOffset.getZ(), MathHelper.lerp(tickDelta, player.prevYaw, player.getYaw()), tickDelta, matrixStack);\n\n        PlayerEntityRenderer playerRenderer = (PlayerEntityRenderer) client.getEntityRenderDispatcher().getRenderer(player);\n        renderOffset = renderOffset.add(playerRenderer.getPositionOffset(player, tickDelta));\n        matrixStack.translate(renderOffset.getX(), renderOffset.getY(), renderOffset.getZ());\n\n        if (config.compatPehkui()) PehkuiCompat.scaleMatrices(matrixStack, player, tickDelta);\n\n        virtualRender(player, playerRenderer, tickDelta, matrixStack);\n\n        // ModelPart$Cuboid.renderCuboid\n        Vector4f refer = matrixStack.peek().getPositionMatrix().transform(new Vector4f((float) (config.getBindingRZ() * config.getScale()),\n                -(float) (config.getBindingRY() * config.getScale()),\n                -(float) (config.getBindingRX() * config.getScale()), 1.0F));\n        Vector4f offset = matrixStack.peek().getPositionMatrix().transform(new Vector4f((float) (config.getBindingZ() * config.getScale()),\n                -(float) (config.getBindingY() * config.getScale()),\n                -(float) (config.getBindingX() * config.getScale()), 1.0F));\n\n        offset.sub(refer);\n        ((CameraAccessor) camera).invokeMoveBy(-refer.z(), refer.y(), -refer.x());\n        Vec3d referVec = camera.getPos();\n        ((CameraAccessor) camera).invokeMoveBy(-offset.z(), offset.y(), -offset.x());\n        clipCameraToSpace(camera, referVec);\n\n        Matrix3f normal = matrixStack.peek().getNormalMatrix().scale(1.0F, -1.0F, -1.0F);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingYaw()), normal.m10, normal.m11, normal.m12);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingPitch()), normal.m00, normal.m01, normal.m02);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingRoll()), normal.m20, normal.m21, normal.m22);\n        Vec3d eulerAngle = MathUtils.getEulerAngleYXZ(normal).multiply(180.0D / Math.PI);\n\n        float pitch = config.isPitchingBound() ? (float) eulerAngle.getX() : camera.getPitch() + config.getBindingPitch();\n        float yaw = config.isYawingBound() ? (float) eulerAngle.getY() : -camera.getYaw() + config.getBindingYaw();\n        cameraRoll = config.isRollingBound() ? (float) eulerAngle.getZ() : config.getBindingRoll();\n        ((CameraAccessor) camera).invokeSetRotation(-yaw, pitch);\n    }\n\n    private static void clipCameraToSpace(Camera camera, Vec3d referVec) {", "        if (config.compatPehkui()) PehkuiCompat.scaleMatrices(matrixStack, player, tickDelta);\n\n        virtualRender(player, playerRenderer, tickDelta, matrixStack);\n\n        // ModelPart$Cuboid.renderCuboid\n        Vector4f refer = matrixStack.peek().getPositionMatrix().transform(new Vector4f((float) (config.getBindingRZ() * config.getScale()),\n                -(float) (config.getBindingRY() * config.getScale()),\n                -(float) (config.getBindingRX() * config.getScale()), 1.0F));\n        Vector4f offset = matrixStack.peek().getPositionMatrix().transform(new Vector4f((float) (config.getBindingZ() * config.getScale()),\n                -(float) (config.getBindingY() * config.getScale()),\n                -(float) (config.getBindingX() * config.getScale()), 1.0F));\n\n        offset.sub(refer);\n        ((CameraAccessor) camera).invokeMoveBy(-refer.z(), refer.y(), -refer.x());\n        Vec3d referVec = camera.getPos();\n        ((CameraAccessor) camera).invokeMoveBy(-offset.z(), offset.y(), -offset.x());\n        clipCameraToSpace(camera, referVec);\n\n        Matrix3f normal = matrixStack.peek().getNormalMatrix().scale(1.0F, -1.0F, -1.0F);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingYaw()), normal.m10, normal.m11, normal.m12);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingPitch()), normal.m00, normal.m01, normal.m02);\n        normal.rotateLocal((float) Math.toRadians(config.getBindingRoll()), normal.m20, normal.m21, normal.m22);\n        Vec3d eulerAngle = MathUtils.getEulerAngleYXZ(normal).multiply(180.0D / Math.PI);\n\n        float pitch = config.isPitchingBound() ? (float) eulerAngle.getX() : camera.getPitch() + config.getBindingPitch();\n        float yaw = config.isYawingBound() ? (float) eulerAngle.getY() : -camera.getYaw() + config.getBindingYaw();\n        cameraRoll = config.isRollingBound() ? (float) eulerAngle.getZ() : config.getBindingRoll();\n        ((CameraAccessor) camera).invokeSetRotation(-yaw, pitch);\n    }\n\n    private static void clipCameraToSpace(Camera camera, Vec3d referVec) {", "        if (!config.doClipToSpace()) return;\n        Vec3d offset = camera.getPos().subtract(referVec);\n        final float depth = 0.065F;\n        for (int i = 0; i < 8; ++i) {\n            float f = depth * ((i & 1) * 2 - 1);\n            float g = depth * ((i >> 1 & 1) * 2 - 1);\n            float h = depth * ((i >> 2 & 1) * 2 - 1);\n            Vec3d start = referVec.add(f, g, h);\n            Vec3d end = referVec.add(offset).add(f, g, h);\n            HitResult hitResult = ((CameraAccessor) camera).getArea().raycast(new RaycastContext(start, end,\n                    RaycastContext.ShapeType.VISUAL, RaycastContext.FluidHandling.NONE, camera.getFocusedEntity()));\n            double l = hitResult.getPos().distanceTo(start);", "            if (hitResult.getType() == HitResult.Type.MISS || l >= offset.length()) continue;\n            offset = offset.multiply(l / offset.length());\n        }\n        ((CameraAccessor) camera).invokeSetPos(referVec.add(offset));\n    }\n\n    private static void virtualRender(AbstractClientPlayerEntity player, PlayerEntityRenderer playerRenderer,\n            float tickDelta, MatrixStack matrixStack) {\n\n        if (config.isUsingModModel()) {\n            status = \"Successful\";", "        if (config.isUsingModModel()) {\n            status = \"Successful\";\n            try {\n                matrixStack.push();\n                if (!VirtualRenderer.virtualRender(tickDelta, matrixStack)) {\n                    return;\n                }\n            } catch (Throwable throwable) {\n                status = throwable.getMessage() != null ? throwable.getMessage() : throwable.getClass().getName();\n                matrixStack.pop();\n            }\n        }\n\n        // PlayerEntityRenderer.render\n        ((PlayerEntityRendererAccessor) playerRenderer).invokeSetModelPose(player);\n        // LivingEntityRenderer.render\n        PlayerEntityModel<AbstractClientPlayerEntity> playerModel = playerRenderer.getModel();\n        float n;\n        Direction direction;\n        playerModel.handSwingProgress = player.getHandSwingProgress(tickDelta);\n        playerModel.riding = player.hasVehicle();\n        playerModel.child = player.isBaby();\n        float h = MathHelper.lerpAngleDegrees(tickDelta, player.prevBodyYaw, player.bodyYaw);\n        float j = MathHelper.lerpAngleDegrees(tickDelta, player.prevHeadYaw, player.headYaw);\n        float k = j - h;", "        if (player.hasVehicle() && player.getVehicle() instanceof LivingEntity vehicle) {\n            h = MathHelper.lerpAngleDegrees(tickDelta, vehicle.prevBodyYaw, vehicle.bodyYaw);\n            k = j - h;\n            float l = MathHelper.wrapDegrees(k);\n            if (l < -85.0f) l = -85.0f;\n            else if (l >= 85.0f) l = 85.0f;\n            h = j - l;\n            if (l * l > 2500.0f) h += l * 0.2f;\n            k = j - h;\n        }\n        float m = MathHelper.lerp(tickDelta, player.prevPitch, player.getPitch());", "        if (PlayerEntityRenderer.shouldFlipUpsideDown(player)) {\n            m *= -1.0f;\n            k *= -1.0f;\n        }\n        if (player.isInPose(EntityPose.SLEEPING) && (direction = player.getSleepingDirection()) != null) {\n            n = player.getEyeHeight(EntityPose.STANDING) - 0.1f;\n            matrixStack.translate((float) (-direction.getOffsetX()) * n, 0.0f, (float) (-direction.getOffsetZ()) * n);\n        }\n        float l = player.age + tickDelta;\n        ((PlayerEntityRendererAccessor) playerRenderer).invokeSetupTransforms(player, matrixStack, l, h, tickDelta);\n        matrixStack.scale(-1.0f, -1.0f, 1.0f);\n        ((PlayerEntityRendererAccessor) playerRenderer).invokeScale(player, matrixStack, tickDelta);\n        matrixStack.translate(0.0f, -1.501f, 0.0f);\n        n = 0.0f;\n        float o = 0.0f;", "        if (!player.hasVehicle() && player.isAlive()) {\n            n = player.limbAnimator.getSpeed(tickDelta);\n            o = player.limbAnimator.getPos(tickDelta);\n            if (player.isBaby()) o *= 3.0f;\n            if (n > 1.0f) n = 1.0f;\n        }\n        playerModel.animateModel(player, o, n, tickDelta);\n        playerModel.setAngles(player, o, n, l, k, m);\n        // AnimalModel.render\n        // ModelPart.render\n        config.getVanillaModelPart().get(playerRenderer.getModel()).rotate(matrixStack);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinItem.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.RaycastUtils;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.item.Item;\nimport net.minecraft.util.hit.BlockHitResult;\nimport net.minecraft.world.RaycastContext;\nimport net.minecraft.world.World;", "import net.minecraft.world.RaycastContext;\nimport net.minecraft.world.World;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(Item.class)\npublic abstract class MixinItem {\n    @Inject(method = \"raycast\", at = @At(\"HEAD\"), cancellable = true)\n    private static void coverRaycast(World world, PlayerEntity player, RaycastContext.FluidHandling fluidHandling,\n            CallbackInfoReturnable<BlockHitResult> cInfo) {", "public abstract class MixinItem {\n    @Inject(method = \"raycast\", at = @At(\"HEAD\"), cancellable = true)\n    private static void coverRaycast(World world, PlayerEntity player, RaycastContext.FluidHandling fluidHandling,\n            CallbackInfoReturnable<BlockHitResult> cInfo) {\n        if (!ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            RaycastUtils.update(player, 25.0D, 1.0F);\n            cInfo.setReturnValue(world.raycast(RaycastUtils.getRaycastContext(RaycastContext.ShapeType.OUTLINE, fluidHandling, player)));\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinPlayerEntityRenderer.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.api.VirtualRenderer;\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.entity.EntityRendererFactory.Context;\nimport net.minecraft.client.render.entity.LivingEntityRenderer;\nimport net.minecraft.client.render.entity.PlayerEntityRenderer;\nimport net.minecraft.client.render.entity.model.PlayerEntityModel;\nimport org.spongepowered.asm.mixin.Mixin;", "import net.minecraft.client.render.entity.model.PlayerEntityModel;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(PlayerEntityRenderer.class)\npublic abstract class MixinPlayerEntityRenderer\n        extends LivingEntityRenderer<AbstractClientPlayerEntity, PlayerEntityModel<AbstractClientPlayerEntity>> {\n    public MixinPlayerEntityRenderer(Context ctx, PlayerEntityModel<AbstractClientPlayerEntity> model,\n            float shadowRadius) {\n        super(ctx, model, shadowRadius);\n    }\n\n    @Inject(method = \"setModelPose\", at = @At(\"RETURN\"))\n    private void onSetModelPoseRETURN(AbstractClientPlayerEntity player, CallbackInfo cInfo) {", "        if (!(player instanceof ClientPlayerEntity)) return;\n        if (VirtualRenderer.shouldDisableRender(\"head\")) model.head.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"hat\")) model.hat.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"body\")) model.body.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightArm\")) model.rightArm.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftArm\")) model.leftArm.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightLeg\")) model.rightLeg.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftLeg\")) model.leftLeg.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftSleeve\")) model.leftSleeve.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightSleeve\")) model.rightSleeve.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftPants\")) model.leftPants.visible = false;", "        if (VirtualRenderer.shouldDisableRender(\"leftSleeve\")) model.leftSleeve.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightSleeve\")) model.rightSleeve.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftPants\")) model.leftPants.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightPants\")) model.rightPants.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"jacket\")) model.jacket.visible = false;\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinArmorFeatureRenderer.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.api.VirtualRenderer;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.VertexConsumerProvider;\nimport net.minecraft.client.render.entity.feature.ArmorFeatureRenderer;\nimport net.minecraft.client.render.entity.model.BipedEntityModel;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.EquipmentSlot;\nimport net.minecraft.entity.LivingEntity;", "import net.minecraft.entity.EquipmentSlot;\nimport net.minecraft.entity.LivingEntity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(ArmorFeatureRenderer.class)\npublic abstract class MixinArmorFeatureRenderer {\n    @Inject(method = \"renderArmor\", at = @At(\"HEAD\"), cancellable = true)\n    private <T extends LivingEntity, A extends BipedEntityModel<T>> void onRenderArmorHEAD(MatrixStack matrices,\n            VertexConsumerProvider vertexConsumers, T entity, EquipmentSlot armorSlot, int light, A model, CallbackInfo cInfo) {", "public abstract class MixinArmorFeatureRenderer {\n    @Inject(method = \"renderArmor\", at = @At(\"HEAD\"), cancellable = true)\n    private <T extends LivingEntity, A extends BipedEntityModel<T>> void onRenderArmorHEAD(MatrixStack matrices,\n            VertexConsumerProvider vertexConsumers, T entity, EquipmentSlot armorSlot, int light, A model, CallbackInfo cInfo) {\n        if (!(entity instanceof ClientPlayerEntity)) return;\n        if ((VirtualRenderer.shouldDisableRender(\"helmet\") && armorSlot == EquipmentSlot.HEAD) ||\n                (VirtualRenderer.shouldDisableRender(\"chestplate\") && armorSlot == EquipmentSlot.CHEST) ||\n                (VirtualRenderer.shouldDisableRender(\"leggings\") && armorSlot == EquipmentSlot.LEGS) ||\n                (VirtualRenderer.shouldDisableRender(\"boots\") && armorSlot == EquipmentSlot.FEET)) {\n            cInfo.cancel();\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/PlayerEntityRendererAccessor.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.render.entity.PlayerEntityRenderer;\nimport net.minecraft.client.util.math.MatrixStack;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Invoker;\n\n@Mixin(PlayerEntityRenderer.class)\npublic interface PlayerEntityRendererAccessor {\n    @Invoker\n    void invokeSetModelPose(AbstractClientPlayerEntity player);\n\n    @Invoker\n    void invokeScale(AbstractClientPlayerEntity abstractClientPlayerEntity, MatrixStack matrixStack, float tickDelta);\n\n    @Invoker\n    void invokeSetupTransforms(AbstractClientPlayerEntity abstractClientPlayerEntity, MatrixStack matrixStack,\n            float f, float bodyYaw, float tickDelta);\n}\n", "@Mixin(PlayerEntityRenderer.class)\npublic interface PlayerEntityRendererAccessor {\n    @Invoker\n    void invokeSetModelPose(AbstractClientPlayerEntity player);\n\n    @Invoker\n    void invokeScale(AbstractClientPlayerEntity abstractClientPlayerEntity, MatrixStack matrixStack, float tickDelta);\n\n    @Invoker\n    void invokeSetupTransforms(AbstractClientPlayerEntity abstractClientPlayerEntity, MatrixStack matrixStack,\n            float f, float bodyYaw, float tickDelta);\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinClientPlayerEntity.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.mojang.authlib.GameProfile;\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.RaycastUtils;\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.option.Perspective;\nimport net.minecraft.client.world.ClientWorld;", "import net.minecraft.client.option.Perspective;\nimport net.minecraft.client.world.ClientWorld;\nimport net.minecraft.util.hit.HitResult;\nimport net.minecraft.world.RaycastContext;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Redirect;\n\n@Mixin(ClientPlayerEntity.class)\npublic abstract class MixinClientPlayerEntity extends AbstractClientPlayerEntity {\n    public MixinClientPlayerEntity(ClientWorld world, GameProfile profile) {\n        super(world, profile);\n    }\n\n    @Redirect(method = \"getLeashPos\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/option/Perspective;isFirstPerson()Z\"))\n    private boolean returnFalse(Perspective perspective) {", "@Mixin(ClientPlayerEntity.class)\npublic abstract class MixinClientPlayerEntity extends AbstractClientPlayerEntity {\n    public MixinClientPlayerEntity(ClientWorld world, GameProfile profile) {\n        super(world, profile);\n    }\n\n    @Redirect(method = \"getLeashPos\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/option/Perspective;isFirstPerson()Z\"))\n    private boolean returnFalse(Perspective perspective) {\n        if (ConfigFile.modConfig.isRendering() && RealCameraCore.isActive()) return false;\n        return perspective.isFirstPerson();\n    }\n\n    @Override", "        if (ConfigFile.modConfig.isRendering() && RealCameraCore.isActive()) return false;\n        return perspective.isFirstPerson();\n    }\n\n    @Override\n    public HitResult raycast(double maxDistance, float tickDelta, boolean includeFluids) {\n        if (!ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            RaycastUtils.update(this, maxDistance * maxDistance, tickDelta);\n            return getWorld().raycast(RaycastUtils.getRaycastContext(RaycastContext.ShapeType.OUTLINE,\n                    includeFluids ? RaycastContext.FluidHandling.ANY : RaycastContext.FluidHandling.NONE, this));\n        }\n        return super.raycast(maxDistance, tickDelta, includeFluids);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinPlayerHeldItemFeatureRenderer.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.api.VirtualRenderer;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.VertexConsumerProvider;\nimport net.minecraft.client.render.entity.feature.PlayerHeldItemFeatureRenderer;\nimport net.minecraft.client.render.model.json.ModelTransformationMode;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.LivingEntity;\nimport net.minecraft.item.ItemStack;", "import net.minecraft.entity.LivingEntity;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.Arm;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(PlayerHeldItemFeatureRenderer.class)\npublic abstract class MixinPlayerHeldItemFeatureRenderer {\n    @Inject(method = \"renderItem\", at = @At(\"HEAD\"), cancellable = true)\n    private void onRenderItemHEAD(LivingEntity entity, ItemStack stack, ModelTransformationMode transformationMode,\n            Arm arm, MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light, CallbackInfo cInfo) {", "@Mixin(PlayerHeldItemFeatureRenderer.class)\npublic abstract class MixinPlayerHeldItemFeatureRenderer {\n    @Inject(method = \"renderItem\", at = @At(\"HEAD\"), cancellable = true)\n    private void onRenderItemHEAD(LivingEntity entity, ItemStack stack, ModelTransformationMode transformationMode,\n            Arm arm, MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light, CallbackInfo cInfo) {\n        if (!(entity instanceof ClientPlayerEntity)) return;\n        if (VirtualRenderer.shouldDisableRender(\"heldItem\")) cInfo.cancel();\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinGameRenderer.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.compat.DoABarrelRollCompat;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.CrosshairUtils;\nimport com.xtracr.realcamera.utils.RaycastUtils;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.option.Perspective;\nimport net.minecraft.client.render.Camera;", "import net.minecraft.client.option.Perspective;\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.client.render.GameRenderer;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.projectile.ProjectileUtil;\nimport net.minecraft.util.hit.EntityHitResult;\nimport net.minecraft.util.math.Box;\nimport net.minecraft.util.math.Vec3d;\nimport org.spongepowered.asm.mixin.Final;", "import net.minecraft.util.math.Vec3d;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.Unique;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.ModifyVariable;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(GameRenderer.class)\npublic abstract class MixinGameRenderer {\n    @Unique\n    private static boolean toggled = false;\n\n    @Shadow\n    @Final MinecraftClient client;\n\n    @ModifyVariable(method = \"updateTargetedEntity\", at = @At(\"STORE\"), ordinal = 0)\n    private EntityHitResult modifyEntityHitResult(EntityHitResult entityHitResult) {\n        CrosshairUtils.capturedEntityHitResult = entityHitResult;", "        if (!ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            Vec3d startVec = RaycastUtils.getStartVec();\n            Vec3d endVec = RaycastUtils.getEndVec();\n            double sqDistance = (client.crosshairTarget != null ?\n                    client.crosshairTarget.getPos().squaredDistanceTo(startVec) : endVec.squaredDistanceTo(startVec));\n            Entity cameraEntity = client.getCameraEntity();\n            Box box = cameraEntity.getBoundingBox().stretch(cameraEntity.getRotationVec(client.getTickDelta())\n                    .multiply(client.interactionManager.getReachDistance())).expand(1.0, 1.0, 1.0);\n            CrosshairUtils.capturedEntityHitResult = ProjectileUtil.raycast(cameraEntity, startVec, endVec, box, entity -> !entity.isSpectator() && entity.canHit(), sqDistance);\n        }\n        return CrosshairUtils.capturedEntityHitResult;\n    }\n\n    @Inject(method = \"renderHand\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/util/math/MatrixStack;push()V\"))\n    private void setThirdPerson(MatrixStack matrices, Camera camera, float tickDelta, CallbackInfo cInfo) {", "        if (ConfigFile.modConfig.isRendering() && camera.isThirdPerson() && RealCameraCore.isActive() &&\n                !ConfigFile.modConfig.allowRenderingHandWhen(client)) {\n            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);\n            toggled = true;\n        }\n    }\n\n    @Inject(method = \"renderHand\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/util/math/MatrixStack;pop()V\"))\n    private void setFirstPerson(CallbackInfo cInfo) {\n        if (toggled) {\n            client.options.setPerspective(Perspective.FIRST_PERSON);\n            toggled = false;\n        }\n    }\n\n    @Inject(method = \"renderWorld\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/render/Camera;update(Lnet/minecraft/world/BlockView;Lnet/minecraft/entity/Entity;ZZF)V\",\n            shift = At.Shift.BY, by = -2))\n    private void onBeforeCameraUpdate(float tickDelta, long limitTime, MatrixStack matrixStack, CallbackInfo cInfo) {", "        if (toggled) {\n            client.options.setPerspective(Perspective.FIRST_PERSON);\n            toggled = false;\n        }\n    }\n\n    @Inject(method = \"renderWorld\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/render/Camera;update(Lnet/minecraft/world/BlockView;Lnet/minecraft/entity/Entity;ZZF)V\",\n            shift = At.Shift.BY, by = -2))\n    private void onBeforeCameraUpdate(float tickDelta, long limitTime, MatrixStack matrixStack, CallbackInfo cInfo) {\n        if (ConfigFile.modConfig.compatDoABarrelRoll() && DoABarrelRollCompat.modEnabled() && RealCameraCore.isActive()) {\n            matrixStack.loadIdentity();\n        }\n    }\n}\n", "        if (ConfigFile.modConfig.compatDoABarrelRoll() && DoABarrelRollCompat.modEnabled() && RealCameraCore.isActive()) {\n            matrixStack.loadIdentity();\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/CameraAccessor.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.util.math.Vec3d;\nimport net.minecraft.world.BlockView;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\nimport org.spongepowered.asm.mixin.gen.Invoker;\n\n@Mixin(Camera.class)\npublic interface CameraAccessor {\n    @Accessor\n    BlockView getArea();\n\n    @Accessor\n    void setThirdPerson(boolean thirdPerson);\n\n    @Invoker\n    void invokeMoveBy(double x, double y, double z);\n\n    @Invoker\n    void invokeSetRotation(float yaw, float pitch);\n\n    @Invoker\n    void invokeSetPos(Vec3d pos);\n\n}\n", "\n@Mixin(Camera.class)\npublic interface CameraAccessor {\n    @Accessor\n    BlockView getArea();\n\n    @Accessor\n    void setThirdPerson(boolean thirdPerson);\n\n    @Invoker\n    void invokeMoveBy(double x, double y, double z);\n\n    @Invoker\n    void invokeSetRotation(float yaw, float pitch);\n\n    @Invoker\n    void invokeSetPos(Vec3d pos);\n\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinInGameHud.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.CrosshairUtils;\nimport net.minecraft.client.gui.DrawContext;\nimport net.minecraft.client.gui.hud.InGameHud;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;", "import org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(InGameHud.class)\npublic abstract class MixinInGameHud {\n    @Inject(method = \"renderCrosshair(Lnet/minecraft/client/gui/DrawContext;)V\", at = @At(\"HEAD\"))\n    private void onRenderCrosshairHEAD(DrawContext context, CallbackInfo cInfo) {\n        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            context.getMatrices().push();\n            CrosshairUtils.translateMatrices(context.getMatrices());\n        }\n    }\n\n    @Inject(method = \"renderCrosshair(Lnet/minecraft/client/gui/DrawContext;)V\", at = @At(\"RETURN\"))\n    private void onRenderCrosshairRETURN(DrawContext context, CallbackInfo cInfo) {", "        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            context.getMatrices().push();\n            CrosshairUtils.translateMatrices(context.getMatrices());\n        }\n    }\n\n    @Inject(method = \"renderCrosshair(Lnet/minecraft/client/gui/DrawContext;)V\", at = @At(\"RETURN\"))\n    private void onRenderCrosshairRETURN(DrawContext context, CallbackInfo cInfo) {\n        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            context.getMatrices().pop();\n        }\n    }\n}\n", "        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            context.getMatrices().pop();\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/mixins/MixinEntityRenderer.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.Frustum;\nimport net.minecraft.client.render.entity.EntityRenderer;\nimport net.minecraft.entity.Entity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;", "import org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(EntityRenderer.class)\npublic abstract class MixinEntityRenderer {\n    @Inject(method = \"shouldRender\", at = @At(\"HEAD\"), cancellable = true)\n    private <T extends Entity> void onShouldRenderHEAD(T entity, Frustum frustum, double x, double y, double z,\n            CallbackInfoReturnable<Boolean> cInfo) {\n        if (ConfigFile.modConfig.isRendering() && RealCameraCore.isActive() && entity instanceof ClientPlayerEntity) {\n            cInfo.setReturnValue(true);\n        }\n    }\n}\n", "        if (ConfigFile.modConfig.isRendering() && RealCameraCore.isActive() && entity instanceof ClientPlayerEntity) {\n            cInfo.setReturnValue(true);\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/utils/ReflectUtils.java", "chunked_list": ["package com.xtracr.realcamera.utils;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\npublic class ReflectUtils {\n    public static boolean isLoaded(final String className) {", "\npublic class ReflectUtils {\n    public static boolean isLoaded(final String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException exception) {\n            return false;\n        }\n    }\n", "    public static boolean isLoaded(final String className, final String... classNames) {\n        boolean ret = isLoaded(className);\n        for (final String name : classNames) ret = ret || isLoaded(name);\n        return ret;\n    }\n\n    public static Optional<Class<?>> getClass(final String className) {\n        try {\n            return Optional.of(Class.forName(className));\n        } catch (ClassNotFoundException exception) {\n            return Optional.empty();\n        }\n    }\n", "    public static Optional<Class<?>> getClass(final String className, final String... classNames) {\n        Optional<Class<?>> ret = getClass(className);\n        for (final String name : classNames) {\n            if (ret.isPresent()) return ret;\n            ret = getClass(name);\n        }\n        return ret;\n    }\n\n    public static Optional<Field> getField(final Optional<Class<?>> classObj, final String fieldName) {\n        return classObj.map(cls -> {", "    public static Optional<Field> getField(final Optional<Class<?>> classObj, final String fieldName) {\n        return classObj.map(cls -> {\n            try {\n                final Field fld = cls.getField(fieldName);\n                fld.setAccessible(true);\n                return fld;\n            } catch (NoSuchFieldException | SecurityException ignored) {\n                return null;\n            }\n        });\n    }\n", "    public static Optional<Field> getDeclaredField(final Optional<Class<?>> classObj, final String fieldName) {\n        return classObj.map(cls -> {\n            try {\n                final Field fld = cls.getDeclaredField(fieldName);\n                fld.setAccessible(true);\n                return fld;\n            } catch (NoSuchFieldException | SecurityException ignored) {\n                return null;\n            }\n        });\n    }\n", "    public static Optional<Object> getFieldValue(final Optional<Field> field, @Nullable final Object object) {\n        return field.map(fld -> {\n            try {\n                return fld.get(object);\n            } catch (IllegalArgumentException | IllegalAccessException ignored) {\n                return null;\n            }\n        });\n    }\n\n    public static void setField(final Optional<Field> field, @Nullable final Object object, Object value) {\n        field.ifPresent(fld -> {", "    public static void setField(final Optional<Field> field, @Nullable final Object object, Object value) {\n        field.ifPresent(fld -> {\n            try {\n                fld.set(object, value);\n            } catch (IllegalArgumentException | IllegalAccessException ignored) {\n            }\n        });\n    }\n\n    public static Optional<Method> getMethod(final Optional<Class<?>> classObj, final String methodName, Class<?>... args) {\n        return classObj.map(cls -> {", "    public static Optional<Method> getMethod(final Optional<Class<?>> classObj, final String methodName, Class<?>... args) {\n        return classObj.map(cls -> {\n            try {\n                final Method mtd = cls.getMethod(methodName, args);\n                mtd.setAccessible(true);\n                return mtd;\n            } catch (NoSuchMethodException | SecurityException ignored) {\n                return null;\n            }\n        });\n    }\n", "    public static Optional<Method> getDeclaredMethod(final Optional<Class<?>> classObj, final String methodName, Class<?>... args) {\n        return classObj.map(cls -> {\n            try {\n                final Method mtd = cls.getDeclaredMethod(methodName, args);\n                mtd.setAccessible(true);\n                return mtd;\n            } catch (NoSuchMethodException | SecurityException ignored) {\n                return null;\n            }\n        });\n    }\n", "    public static Optional<Object> invokeMethod(final Optional<Method> method, @Nullable Object object, Object... args) {\n        return method.map(mtd -> {\n            try {\n                return mtd.invoke(object, args);\n            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ignored) {\n                return null;\n            }\n        });\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/utils/RaycastUtils.java", "chunked_list": ["package com.xtracr.realcamera.utils;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.util.math.Vec3d;\nimport net.minecraft.world.RaycastContext;\nimport net.minecraft.world.RaycastContext.FluidHandling;\nimport net.minecraft.world.RaycastContext.ShapeType;\n\npublic class RaycastUtils {\n    private static Vec3d startVec = Vec3d.ZERO;\n    private static Vec3d direction = Vec3d.ZERO;\n    private static Vec3d endVec = Vec3d.ZERO;\n", "import net.minecraft.world.RaycastContext.ShapeType;\n\npublic class RaycastUtils {\n    private static Vec3d startVec = Vec3d.ZERO;\n    private static Vec3d direction = Vec3d.ZERO;\n    private static Vec3d endVec = Vec3d.ZERO;\n\n    public static Vec3d getStartVec() {\n        return startVec;\n    }\n", "    public static Vec3d getDirection() {\n        return direction;\n    }\n\n    public static Vec3d getEndVec() {\n        return endVec;\n    }\n\n    public static RaycastContext getRaycastContext(ShapeType shapeType, FluidHandling fluidHandling, Entity entity) {\n        return new RaycastContext(startVec, endVec, shapeType, fluidHandling, entity);\n    }\n", "    public static RaycastContext getRaycastContext(ShapeType shapeType, FluidHandling fluidHandling, Entity entity) {\n        return new RaycastContext(startVec, endVec, shapeType, fluidHandling, entity);\n    }\n\n    public static void update(Entity entity, double sqDistance, float tickDelta) {\n        final Camera camera = MinecraftClient.getInstance().gameRenderer.getCamera();\n        final Vec3d eyePos = entity.getCameraPosVec(tickDelta);\n        startVec = camera.getPos();\n        direction = Vec3d.fromPolar(camera.getPitch(), camera.getYaw());\n\n        final Vec3d offset = startVec.subtract(eyePos);\n        final Vec3d footPoint = MathUtils.getIntersectionPoint(Vec3d.ZERO, direction, offset, direction);", "        if (footPoint.lengthSquared() > sqDistance) {\n            startVec = eyePos;\n            direction = entity.getRotationVec(tickDelta);\n            endVec = startVec.add(direction.multiply(Math.sqrt(sqDistance)));\n            return;\n        } else if (offset.lengthSquared() > sqDistance) {\n            startVec = startVec.add(direction.multiply(offset.distanceTo(footPoint) - Math.sqrt(sqDistance - footPoint.lengthSquared())));\n        }\n        endVec = eyePos.add(footPoint.add(direction.multiply(Math.sqrt(sqDistance - footPoint.lengthSquared()))));\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/utils/MathUtils.java", "chunked_list": ["package com.xtracr.realcamera.utils;\n\nimport net.minecraft.util.math.Vec3d;\nimport org.joml.Matrix3f;\nimport org.joml.Matrix4f;\nimport org.joml.Vector4f;\n\npublic class MathUtils {\n    public static Vec3d getEulerAngleYXZ(Matrix3f normal) {\n        if (normal.m21 <= -1.0D) {\n            return new Vec3d(Math.PI / 2, Math.atan2(normal.m10, normal.m00), 0.0D);", "    public static Vec3d getEulerAngleYXZ(Matrix3f normal) {\n        if (normal.m21 <= -1.0D) {\n            return new Vec3d(Math.PI / 2, Math.atan2(normal.m10, normal.m00), 0.0D);\n        } else if (normal.m21 >= 1.0D) {\n            return new Vec3d(-Math.PI / 2, -Math.atan2(normal.m10, normal.m00), 0.0D);\n        }\n        double xRot = Math.asin(-normal.m21);\n        double yRot = Math.atan2(normal.m20, normal.m22);\n        double zRot = Math.atan2(normal.m01, normal.m11);\n        return new Vec3d(xRot, yRot, zRot);\n    }\n", "    public static Vec3d getIntersectionPoint(Vec3d planePoint, Vec3d planeNormal, Vec3d linePoint, Vec3d lineNormal) {\n        double distance = planeNormal.dotProduct(planePoint.subtract(linePoint)) / planeNormal.dotProduct(lineNormal);\n        return linePoint.add(lineNormal.multiply(distance));\n    }\n\n    public static Vec3d projectToVec2d(Vec3d vec3d, Matrix4f... projectionMatrices) {\n        Vector4f vector4f = new Vector4f((float) vec3d.getX(), (float) vec3d.getY(), (float) vec3d.getZ(), 1.0F);\n        for (Matrix4f matrix4f : projectionMatrices) vector4f.mul(matrix4f);\n        if (vector4f.w() == 0.0D) return Vec3d.ZERO;\n        return new Vec3d(vector4f.x(), vector4f.y(), 0).multiply(1 / (double) vector4f.w());\n    }\n}\n", "        if (vector4f.w() == 0.0D) return Vec3d.ZERO;\n        return new Vec3d(vector4f.x(), vector4f.y(), 0).multiply(1 / (double) vector4f.w());\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/utils/CrosshairUtils.java", "chunked_list": ["package com.xtracr.realcamera.utils;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.client.util.Window;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.util.hit.EntityHitResult;\nimport net.minecraft.util.hit.HitResult;\nimport net.minecraft.util.math.Vec3d;\nimport org.joml.Matrix4f;", "import net.minecraft.util.math.Vec3d;\nimport org.joml.Matrix4f;\n\npublic class CrosshairUtils {\n    public static EntityHitResult capturedEntityHitResult;\n    private static Vec3d offset = Vec3d.ZERO;\n\n    public static void translateMatrices(MatrixStack matrixStack) {\n        matrixStack.translate(offset.getX(), -offset.getY(), 0.0D);\n    }\n", "    public static void update(MinecraftClient client, Camera camera, Matrix4f... projectionMatrices) {\n        HitResult hitResult = client.crosshairTarget;\n        if (client.targetedEntity != null) {\n            hitResult = capturedEntityHitResult;\n        }\n        if (hitResult == null) {\n            offset = Vec3d.ZERO;\n            return;\n        }\n        Window window = client.getWindow();\n        offset = MathUtils.projectToVec2d(hitResult.getPos().subtract(camera.getPos()), projectionMatrices)\n                .multiply(0.5 * window.getScaledWidth(), 0.5 * window.getScaledHeight(), 0.0D);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/utils/Triple.java", "chunked_list": ["package com.xtracr.realcamera.utils;\n\npublic class Triple<L, M, R> {\n    private L left;\n    private M middle;\n    private R right;\n\n    public Triple(L left, M middle, R right) {\n        this.left = left;\n        this.middle = middle;\n        this.right = right;\n    }\n", "    public L getLeft() {\n        return left;\n    }\n\n    public void setLeft(L left) {\n        this.left = left;\n    }\n\n    public M getMiddle() {\n        return middle;\n    }\n", "    public M getMiddle() {\n        return middle;\n    }\n\n    public void setMiddle(M middle) {\n        this.middle = middle;\n    }\n\n    public R getRight() {\n        return right;\n    }\n", "    public R getRight() {\n        return right;\n    }\n\n    public void setRight(R right) {\n        this.right = right;\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/config/VanillaModelPart.java", "chunked_list": ["package com.xtracr.realcamera.config;\n\nimport net.minecraft.client.model.ModelPart;\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.render.entity.model.PlayerEntityModel;\n\nimport java.util.function.Function;\n\npublic enum VanillaModelPart {\n    head(model -> model.head),\n    body(model -> model.body),\n    leftArm(model -> model.leftArm),\n    rightArm(model -> model.rightArm),\n    leftLeg(model -> model.leftLeg),\n    rightLeg(model -> model.rightLeg);\n\n    private final Function<PlayerEntityModel<AbstractClientPlayerEntity>, ModelPart> function;\n\n    VanillaModelPart(Function<PlayerEntityModel<AbstractClientPlayerEntity>, ModelPart> function) {\n        this.function = function;\n    }\n", "public enum VanillaModelPart {\n    head(model -> model.head),\n    body(model -> model.body),\n    leftArm(model -> model.leftArm),\n    rightArm(model -> model.rightArm),\n    leftLeg(model -> model.leftLeg),\n    rightLeg(model -> model.rightLeg);\n\n    private final Function<PlayerEntityModel<AbstractClientPlayerEntity>, ModelPart> function;\n\n    VanillaModelPart(Function<PlayerEntityModel<AbstractClientPlayerEntity>, ModelPart> function) {\n        this.function = function;\n    }\n", "    public ModelPart get(PlayerEntityModel<AbstractClientPlayerEntity> playerModel) {\n        return function.apply(playerModel);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/config/ConfigFile.java", "chunked_list": ["package com.xtracr.realcamera.config;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.xtracr.realcamera.RealCamera;\nimport net.minecraft.client.MinecraftClient;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;", "import java.io.BufferedWriter;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class ConfigFile {\n    public static final ModConfig modConfig = new ModConfig();\n\n    private static final String FILE_NAME = RealCamera.MODID + \".json\";\n    private static final Path PATH;\n    private static final Gson GSON = new GsonBuilder()\n            .setPrettyPrinting()\n            .create();\n\n    static {\n        final File configDir = new File(MinecraftClient.getInstance().runDirectory, \"config\");", "        if (!configDir.exists()) configDir.mkdirs();\n        PATH = configDir.toPath().resolve(FILE_NAME);\n    }\n\n    public static void load() {\n        try (BufferedReader reader = Files.newBufferedReader(PATH)) {\n            modConfig.set(GSON.fromJson(reader, ModConfig.class));\n            modConfig.clamp();\n        } catch (Exception exception) {\n            RealCamera.LOGGER.warn(\"Failed to load \" + FILE_NAME);\n            save();\n        }\n    }\n", "    public static void save() {\n        try (BufferedWriter writer = Files.newBufferedWriter(PATH)) {\n            GSON.toJson(modConfig, writer);\n        } catch (Exception exception) {\n            RealCamera.LOGGER.warn(\"Failed to save \" + FILE_NAME, exception);\n            reset();\n        }\n    }\n\n    public static void reset() {\n        try (BufferedWriter writer = Files.newBufferedWriter(PATH)) {\n            modConfig.set(new ModConfig());\n            GSON.toJson(modConfig, writer);\n        } catch (Exception exception) {\n            RealCamera.LOGGER.warn(\"Failed to reset \" + FILE_NAME, exception);\n        }\n    }\n}\n", "    public static void reset() {\n        try (BufferedWriter writer = Files.newBufferedWriter(PATH)) {\n            modConfig.set(new ModConfig());\n            GSON.toJson(modConfig, writer);\n        } catch (Exception exception) {\n            RealCamera.LOGGER.warn(\"Failed to reset \" + FILE_NAME, exception);\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/config/ConfigScreen.java", "chunked_list": ["package com.xtracr.realcamera.config;\n\nimport com.xtracr.realcamera.RealCamera;\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.api.VirtualRenderer;\nimport com.xtracr.realcamera.compat.DoABarrelRollCompat;\nimport com.xtracr.realcamera.compat.PehkuiCompat;\nimport com.xtracr.realcamera.compat.PhysicsModCompat;\nimport com.xtracr.realcamera.utils.Triple;\nimport me.shedaniel.clothconfig2.api.ConfigBuilder;", "import com.xtracr.realcamera.utils.Triple;\nimport me.shedaniel.clothconfig2.api.ConfigBuilder;\nimport me.shedaniel.clothconfig2.api.ConfigCategory;\nimport me.shedaniel.clothconfig2.api.ConfigEntryBuilder;\nimport me.shedaniel.clothconfig2.gui.entries.MultiElementListEntry;\nimport me.shedaniel.clothconfig2.gui.entries.NestedListListEntry;\nimport me.shedaniel.clothconfig2.impl.builders.SubCategoryBuilder;\nimport net.minecraft.client.gui.screen.Screen;\nimport net.minecraft.text.ClickEvent;\nimport net.minecraft.text.HoverEvent;", "import net.minecraft.text.ClickEvent;\nimport net.minecraft.text.HoverEvent;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class ConfigScreen {\n    private static final String CATEGORY = \"config.category.xtracr_\" + RealCamera.MODID + \"_\";\n    private static final String OPTION = \"config.option.xtracr_\" + RealCamera.MODID + \"_\";\n    private static final String TOOLTIP = \"config.tooltip.xtracr_\" + RealCamera.MODID + \"_\";\n", "\npublic class ConfigScreen {\n    private static final String CATEGORY = \"config.category.xtracr_\" + RealCamera.MODID + \"_\";\n    private static final String OPTION = \"config.option.xtracr_\" + RealCamera.MODID + \"_\";\n    private static final String TOOLTIP = \"config.tooltip.xtracr_\" + RealCamera.MODID + \"_\";\n\n    public static Screen create(Screen parent) {\n\n        ConfigFile.load();\n        final ModConfig config = ConfigFile.modConfig;\n\n        final ConfigBuilder builder = ConfigBuilder.create()\n                .setParentScreen(parent)\n                .transparentBackground()\n                .setSavingRunnable(ConfigFile::save)\n                .setTitle(Text.translatable(\"config.title.xtracr_\" + RealCamera.MODID));\n        ConfigEntryBuilder entryBuilder = builder.entryBuilder();\n        ConfigCategory general = builder.getOrCreateCategory(Text.translatable(CATEGORY + \"general\"));\n        ConfigCategory binding = builder.getOrCreateCategory(Text.translatable(CATEGORY + \"binding\"));\n        ConfigCategory classic = builder.getOrCreateCategory(Text.translatable(CATEGORY + \"classic\"));\n        ConfigCategory compats = builder.getOrCreateCategory(Text.translatable(CATEGORY + \"compats\"));\n        ConfigCategory disable = builder.getOrCreateCategory(Text.translatable(CATEGORY + \"disable\"));\n\n        general.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"enabled\"), config.general.enabled)\n                .setSaveConsumer(b -> config.general.enabled = b)\n                .build());\n        general.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"classic\"), config.general.classic)\n                .setDefaultValue(false)\n                .setTooltip(Text.translatable(TOOLTIP + \"classic\"))\n                .setSaveConsumer(b -> config.general.classic = b)\n                .build());\n        general.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"clipToSpace\"), config.general.clipToSpace)\n                .setDefaultValue(true)\n                .setTooltip(Text.translatable(TOOLTIP + \"clipToSpace\"))\n                .setSaveConsumer(b -> config.general.clipToSpace = b)\n                .build());\n        general.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"dynamicCrosshair\"), config.general.dynamicCrosshair)\n                .setDefaultValue(false)\n                .setTooltip(Text.translatable(TOOLTIP + \"dynamicCrosshair\"))\n                .setSaveConsumer(b -> config.general.dynamicCrosshair = b)\n                .build());\n        general.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"renderModel\"), config.general.renderModel)\n                .setDefaultValue(true)\n                .setTooltip(Text.translatable(TOOLTIP + \"renderModel\"))\n                .setSaveConsumer(b -> config.general.renderModel = b)\n                .build());\n        general.addEntry(entryBuilder.startDoubleField(Text.translatable(OPTION + \"adjustStep\"), config.general.adjustStep)\n                .setDefaultValue(0.25D)\n                .setMin(0.0D)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setTooltip(Text.translatable(TOOLTIP + \"adjustStep\"))\n                .setSaveConsumer(d -> config.general.adjustStep = d)\n                .build());\n        general.addEntry(entryBuilder.startDoubleField(Text.translatable(OPTION + \"scale\"), config.general.scale)\n                .setDefaultValue(1.0D)\n                .setMin(0.0D)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setTooltip(Text.translatable(TOOLTIP + \"scale\"))\n                .setSaveConsumer(d -> config.general.scale = d)\n                .build());\n\n        binding.addEntry(entryBuilder.startEnumSelector(Text.translatable(OPTION + \"vanillaModelPart\"), VanillaModelPart.class, config.binding.vanillaModelPart)\n                .setDefaultValue(VanillaModelPart.head)\n                .setTooltip(Text.translatable(TOOLTIP + \"vanillaModelPart\"))\n                .setSaveConsumer(e -> config.binding.vanillaModelPart = e)\n                .build());\n        binding.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"adjustOffset\"), config.binding.adjustOffset)\n                .setDefaultValue(true)\n                .setTooltip(Text.translatable(TOOLTIP + \"adjustOffset\"))\n                .setSaveConsumer(b -> config.binding.adjustOffset = b)\n                .build());\n        SubCategoryBuilder bindingCameraOffset = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"cameraOffset\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"bindingOffset\"), Text.translatable(TOOLTIP + \"referOffset\"), Text.translatable(TOOLTIP + \"bindingOffset_n\"));\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"X\"), config.binding.cameraX)\n                .setDefaultValue(3.25D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.cameraX = d)\n                .build());\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"Y\"), config.binding.cameraY)\n                .setDefaultValue(2.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.cameraY = d)\n                .build());\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"Z\"), config.binding.cameraZ)\n                .setDefaultValue(0.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.cameraZ = d)\n                .build());\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"X\"), config.binding.referX)\n                .setDefaultValue(3.25D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.referX = d)\n                .build());\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"Y\"), config.binding.referY)\n                .setDefaultValue(2.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.referY = d)\n                .build());\n        bindingCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"Z\"), config.binding.referZ)\n                .setDefaultValue(0.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.binding.referZ = d)\n                .build());\n        binding.addEntry(bindingCameraOffset.build());\n        SubCategoryBuilder bindingCameraRotation = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"cameraRotation\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"cameraRotation\"), Text.translatable(TOOLTIP + \"cameraRotation_n\"));\n        bindingCameraRotation.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"bindPitching\"), config.binding.bindPitching)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.binding.bindPitching = b)\n                .build());\n        bindingCameraRotation.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"bindYawing\"), config.binding.bindYawing)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.binding.bindYawing = b)\n                .build());\n        bindingCameraRotation.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"bindRolling\"), config.binding.bindRolling)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.binding.bindRolling = b)\n                .build());\n        bindingCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"pitch\"), config.binding.pitch)\n                .setDefaultValue(0.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.binding.pitch = f)\n                .build());\n        bindingCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"yaw\"), config.binding.yaw)\n                .setDefaultValue(0.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.binding.yaw = f)\n                .build());\n        bindingCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"roll\"), config.binding.roll)\n                .setDefaultValue(0.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.binding.roll = f)\n                .build());\n        binding.addEntry(bindingCameraRotation.build());\n\n        classic.addEntry(entryBuilder.startEnumSelector(Text.translatable(OPTION + \"classicAdjustMode\"), ModConfig.Classic.AdjustMode.class, config.classic.adjustMode)\n                .setDefaultValue(ModConfig.Classic.AdjustMode.CAMERA)\n                .setTooltip(Text.translatable(TOOLTIP + \"classicAdjustMode\"))\n                .setSaveConsumer(e -> config.classic.adjustMode = e)\n                .build());\n        SubCategoryBuilder classicCameraOffset = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"cameraOffset\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"classicOffset\"), Text.translatable(TOOLTIP + \"referOffset\"), Text.translatable(TOOLTIP + \"classicOffset_n\"));\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"X\"), config.classic.cameraX)\n                .setDefaultValue(-60.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.cameraX = d)\n                .build());\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"Y\"), config.classic.cameraY)\n                .setDefaultValue(2.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.cameraY = d)\n                .build());\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"cameraOffset\", \"Z\"), config.classic.cameraZ)\n                .setDefaultValue(-16.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.cameraZ = d)\n                .build());\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"X\"), config.classic.referX)\n                .setDefaultValue(3.25D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.referX = d)\n                .build());\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"Y\"), config.classic.referY)\n                .setDefaultValue(2.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.referY = d)\n                .build());\n        classicCameraOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"referOffset\", \"Z\"), config.classic.referZ)\n                .setDefaultValue(0.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.referZ = d)\n                .build());\n        classic.addEntry(classicCameraOffset.build());\n        SubCategoryBuilder classicCenterOffset = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"centerOffset\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"centerOffset\"));\n        classicCenterOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"centerOffset\", \"X\"), config.classic.centerX)\n                .setDefaultValue(0.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.centerX = d)\n                .build());\n        classicCenterOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"centerOffset\", \"Y\"), config.classic.centerY)\n                .setDefaultValue(-3.4D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.centerY = d)\n                .build());\n        classicCenterOffset.add(entryBuilder.startDoubleField(Text.translatable(OPTION + \"centerOffset\", \"Z\"), config.classic.centerZ)\n                .setDefaultValue(0.0D)\n                .setMin(ModConfig.MIN_DOUBLE)\n                .setMax(ModConfig.MAX_DOUBLE)\n                .setSaveConsumer(d -> config.classic.centerZ = d)\n                .build());\n        classic.addEntry(classicCenterOffset.build());\n        SubCategoryBuilder classicCameraRotation = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"cameraRotation\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"cameraRotation\"), Text.translatable(TOOLTIP + \"cameraRotation_n\"));\n        classicCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"pitch\"), config.classic.pitch)\n                .setDefaultValue(0.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.classic.pitch = f)\n                .build());\n        classicCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"yaw\"), config.classic.yaw)\n                .setDefaultValue(18.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.classic.yaw = f)\n                .build());\n        classicCameraRotation.add(entryBuilder.startFloatField(Text.translatable(OPTION + \"roll\"), config.classic.roll)\n                .setDefaultValue(0.0F)\n                .setMin(-180.0F)\n                .setMax(180.0F)\n                .setSaveConsumer(f -> config.classic.roll = f)\n                .build());\n        classic.addEntry(classicCameraRotation.build());\n\n        compats.addEntry(entryBuilder.startTextDescription(Text.translatable(OPTION + \"compatsText_1\",\n                        Text.translatable(OPTION + \"compatsText_2\").styled(s -> s.withColor(Formatting.BLUE)\n                                .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Text.literal(\"https://github.com/xTracr/RealCamera/wiki/Configuration\")))\n                                .withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, \"https://github.com/xTracr/RealCamera/wiki/Configuration#mod-model-compat\")))))\n                .build());\n        compats.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"useModModel\"), config.compats.useModModel)\n                .setDefaultValue(false)\n                .setTooltip(Text.translatable(TOOLTIP + \"useModModel\", Text.literal((config.compats.useModModel ? RealCameraCore.getStatus() : \"Disabled\")).styled(\n                        s -> s.withColor((config.compats.useModModel ? (RealCameraCore.getStatus().equals(\"Successful\") ? Formatting.GREEN : Formatting.RED) : Formatting.YELLOW)))))\n                .setSaveConsumer(b -> config.compats.useModModel = b)\n                .build());\n        compats.addEntry(entryBuilder.startSelector(Text.translatable(OPTION + \"modelModID\"), VirtualRenderer.getModidList(), config.compats.modelModID)\n                .setDefaultValue(\"minecraft\")\n                .setSaveConsumer(s -> config.compats.modelModID = s)\n                .build());\n        compats.addEntry(entryBuilder.startStrField(Text.translatable(OPTION + \"modModelPart\"), config.compats.modModelPart)\n                .setDefaultValue(\"head\")\n                .setTooltip(Text.translatable(TOOLTIP + \"modModelPart\"))\n                .setSaveConsumer(s -> config.compats.modModelPart = s)\n                .build());\n        SubCategoryBuilder compatSwitches = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"compatSwitches\"))\n                .setTooltip(Text.translatable(TOOLTIP + \"compatSwitches\"));", "        if (DoABarrelRollCompat.loaded)\n            compatSwitches.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"doABarrelRoll\"), config.compats.doABarrelRoll)\n                    .setDefaultValue(true)\n                    .setSaveConsumer(b -> config.compats.doABarrelRoll = b)\n                    .build());\n        if (PehkuiCompat.loaded)\n            compatSwitches.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"pehkui\"), config.compats.pehkui)\n                    .setDefaultValue(true)\n                    .setSaveConsumer(b -> config.compats.pehkui = b)\n                    .build());\n        if (PhysicsModCompat.loaded)\n            compatSwitches.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"physicsMod\"), config.compats.physicsMod)\n                    .setDefaultValue(true)\n                    .setSaveConsumer(b -> config.compats.physicsMod = b)\n                    .build());\n        compats.addEntry(compatSwitches.build());\n\n        disable.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"onlyInBinding\"), config.disable.onlyInBinding)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.disable.onlyInBinding = b)\n                .build());\n        disable.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"renderModelPart\"), config.disable.renderModelPart)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.renderModelPart = b)\n                .build());\n        disable.addEntry(entryBuilder.startStrList(Text.translatable(OPTION + \"disabledModelParts\"), config.disable.disabledModelParts)\n                .setDefaultValue(ModConfig.Disable.defaultParts)\n                .setTooltip(Text.translatable(TOOLTIP + \"disabledModelParts\", ModConfig.Disable.optionalParts))\n                .setSaveConsumer(l -> config.disable.disabledModelParts = l)\n                .build());\n        disable.addEntry(new NestedListListEntry<Triple<String, List<String>, List<String>>, MultiElementListEntry<Triple<String, List<String>, List<String>>>>(\n                Text.translatable(OPTION + \"customConditions\"),\n                config.disable.customConditions,\n                false,\n                Optional::empty,\n                l -> config.disable.customConditions = l,\n                () -> ModConfig.Disable.defaultConditions,\n                entryBuilder.getResetButtonKey(),\n                true,\n                false,\n                (element, entry) -> {\n                    ModConfig.resetTripleIfNull(element, ModConfig.Disable.defaultTriple);\n                    return new MultiElementListEntry<>(Text.literal(element.getMiddle().get(0)), element, Arrays.asList(\n                            entryBuilder.startSelector(Text.translatable(OPTION + \"customConditions_behavior\"), ModConfig.Disable.behaviors, element.getLeft())\n                                    .setSaveConsumer(element::setLeft)\n                                    .build(),\n                            entryBuilder.startStrList(Text.translatable(OPTION + \"customConditions_id\"), element.getMiddle())\n                                    .setSaveConsumer(element::setMiddle)\n                                    .build(),\n                            entryBuilder.startStrList(Text.translatable(OPTION + \"customConditions_actions\"), element.getRight())\n                                    .setTooltip(Text.translatable(TOOLTIP + \"customConditions_actions\"))\n                                    .setSaveConsumer(element::setRight)\n                                    .build()),\n                            false);\n                }));\n        SubCategoryBuilder disableModWhen = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"disableModWhen\"));\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"fallFlying\"), config.disable.fallFlying)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.disable.fallFlying = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"swimming\"), config.disable.swimming)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.swimming = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"crawling\"), config.disable.crawling)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.crawling = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"sneaking\"), config.disable.sneaking)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.sneaking = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"sleeping\"), config.disable.sleeping)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.sleeping = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"screenOpened\"), config.disable.screenOpened)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.screenOpened = b)\n                .build());\n        disable.addEntry(disableModWhen.build());\n\n        return builder.build();\n    }\n}\n", "        if (PhysicsModCompat.loaded)\n            compatSwitches.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"physicsMod\"), config.compats.physicsMod)\n                    .setDefaultValue(true)\n                    .setSaveConsumer(b -> config.compats.physicsMod = b)\n                    .build());\n        compats.addEntry(compatSwitches.build());\n\n        disable.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"onlyInBinding\"), config.disable.onlyInBinding)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.disable.onlyInBinding = b)\n                .build());\n        disable.addEntry(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"renderModelPart\"), config.disable.renderModelPart)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.renderModelPart = b)\n                .build());\n        disable.addEntry(entryBuilder.startStrList(Text.translatable(OPTION + \"disabledModelParts\"), config.disable.disabledModelParts)\n                .setDefaultValue(ModConfig.Disable.defaultParts)\n                .setTooltip(Text.translatable(TOOLTIP + \"disabledModelParts\", ModConfig.Disable.optionalParts))\n                .setSaveConsumer(l -> config.disable.disabledModelParts = l)\n                .build());\n        disable.addEntry(new NestedListListEntry<Triple<String, List<String>, List<String>>, MultiElementListEntry<Triple<String, List<String>, List<String>>>>(\n                Text.translatable(OPTION + \"customConditions\"),\n                config.disable.customConditions,\n                false,\n                Optional::empty,\n                l -> config.disable.customConditions = l,\n                () -> ModConfig.Disable.defaultConditions,\n                entryBuilder.getResetButtonKey(),\n                true,\n                false,\n                (element, entry) -> {\n                    ModConfig.resetTripleIfNull(element, ModConfig.Disable.defaultTriple);\n                    return new MultiElementListEntry<>(Text.literal(element.getMiddle().get(0)), element, Arrays.asList(\n                            entryBuilder.startSelector(Text.translatable(OPTION + \"customConditions_behavior\"), ModConfig.Disable.behaviors, element.getLeft())\n                                    .setSaveConsumer(element::setLeft)\n                                    .build(),\n                            entryBuilder.startStrList(Text.translatable(OPTION + \"customConditions_id\"), element.getMiddle())\n                                    .setSaveConsumer(element::setMiddle)\n                                    .build(),\n                            entryBuilder.startStrList(Text.translatable(OPTION + \"customConditions_actions\"), element.getRight())\n                                    .setTooltip(Text.translatable(TOOLTIP + \"customConditions_actions\"))\n                                    .setSaveConsumer(element::setRight)\n                                    .build()),\n                            false);\n                }));\n        SubCategoryBuilder disableModWhen = entryBuilder.startSubCategory(Text.translatable(CATEGORY + \"disableModWhen\"));\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"fallFlying\"), config.disable.fallFlying)\n                .setDefaultValue(true)\n                .setSaveConsumer(b -> config.disable.fallFlying = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"swimming\"), config.disable.swimming)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.swimming = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"crawling\"), config.disable.crawling)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.crawling = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"sneaking\"), config.disable.sneaking)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.sneaking = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"sleeping\"), config.disable.sleeping)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.sleeping = b)\n                .build());\n        disableModWhen.add(entryBuilder.startBooleanToggle(Text.translatable(OPTION + \"screenOpened\"), config.disable.screenOpened)\n                .setDefaultValue(false)\n                .setSaveConsumer(b -> config.disable.screenOpened = b)\n                .build());\n        disable.addEntry(disableModWhen.build());\n\n        return builder.build();\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/config/ModConfig.java", "chunked_list": ["package com.xtracr.realcamera.config;\n\nimport com.xtracr.realcamera.utils.Triple;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.util.math.MathHelper;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;", "import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class ModConfig {\n    protected static final double MIN_DOUBLE = -64.0D;\n    protected static final double MAX_DOUBLE = 64.0D;\n\n    public General general = new General();\n    public Binding binding = new Binding();\n    public Classic classic = new Classic();", "    public General general = new General();\n    public Binding binding = new Binding();\n    public Classic classic = new Classic();\n    public Compats compats = new Compats();\n    public Disable disable = new Disable();\n\n    public static <L, M, R> void resetTripleIfNull(Triple<L, M, R> triple, Triple<L, M, R> source) {\n        if (triple == null) triple = source;\n        if (triple.getLeft() == null) triple.setLeft(source.getLeft());\n        if (triple.getMiddle() == null) triple.setMiddle(source.getMiddle());\n        if (triple.getRight() == null) triple.setRight(source.getRight());\n    }\n", "        if (triple.getLeft() == null) triple.setLeft(source.getLeft());\n        if (triple.getMiddle() == null) triple.setMiddle(source.getMiddle());\n        if (triple.getRight() == null) triple.setRight(source.getRight());\n    }\n\n    public void set(ModConfig modConfig) {\n        general = modConfig.general;\n        binding = modConfig.binding;\n        classic = modConfig.classic;\n        compats = modConfig.compats;\n        disable = modConfig.disable;\n    }\n", "    public void clamp() {\n        general.clamp();\n        binding.clamp();\n        classic.clamp();\n        disable.clamp();\n    }\n\n    public boolean isEnabled() {\n        return general.enabled;\n    }\n", "    public void setEnabled(boolean value) {\n        general.enabled = value;\n    }\n\n    public boolean isClassic() {\n        return general.classic;\n    }\n\n    public void setClassic(boolean value) {\n        general.classic = value;\n    }\n", "    public void setClassic(boolean value) {\n        general.classic = value;\n    }\n\n    public boolean doClipToSpace() {\n        return general.clipToSpace;\n    }\n\n    public boolean isCrosshairDynamic() {\n        return general.dynamicCrosshair;\n    }\n", "    public boolean isCrosshairDynamic() {\n        return general.dynamicCrosshair;\n    }\n\n    public boolean isRendering() {\n        return general.renderModel;\n    }\n\n    public double getAdjustStep() {\n        return general.adjustStep;\n    }\n", "    public double getAdjustStep() {\n        return general.adjustStep;\n    }\n\n    public double getScale() {\n        return general.scale * 0.0625D;\n    }\n\n    // binding\n    public VanillaModelPart getVanillaModelPart() {\n        return binding.vanillaModelPart;\n    }\n", "    public VanillaModelPart getVanillaModelPart() {\n        return binding.vanillaModelPart;\n    }\n\n    public boolean isAdjustingOffset() {\n        return binding.adjustOffset;\n    }\n\n    public double getBindingX() {\n        return binding.cameraX;\n    }\n", "    public double getBindingX() {\n        return binding.cameraX;\n    }\n\n    public double getBindingY() {\n        return binding.cameraY;\n    }\n\n    public double getBindingZ() {\n        return binding.cameraZ;\n    }\n", "    public double getBindingZ() {\n        return binding.cameraZ;\n    }\n\n    public double getBindingRX() {\n        return binding.referX;\n    }\n\n    public double getBindingRY() {\n        return binding.referY;\n    }\n", "    public double getBindingRY() {\n        return binding.referY;\n    }\n\n    public double getBindingRZ() {\n        return binding.referZ;\n    }\n\n    public boolean isPitchingBound() {\n        return binding.bindPitching;\n    }\n", "    public boolean isPitchingBound() {\n        return binding.bindPitching;\n    }\n\n    public boolean isYawingBound() {\n        return binding.bindYawing;\n    }\n\n    public boolean isRollingBound() {\n        return binding.bindRolling;\n    }\n", "    public boolean isRollingBound() {\n        return binding.bindRolling;\n    }\n\n    public float getBindingPitch() {\n        return binding.pitch;\n    }\n\n    public float getBindingYaw() {\n        return binding.yaw;\n    }\n", "    public float getBindingYaw() {\n        return binding.yaw;\n    }\n\n    public float getBindingRoll() {\n        return binding.roll;\n    }\n\n    public void setAdjustOffset(boolean value) {\n        binding.adjustOffset = value;\n    }\n", "    public void setAdjustOffset(boolean value) {\n        binding.adjustOffset = value;\n    }\n\n    public void adjustBindingX(boolean add) {\n        int s = add ? 1 : -1;\n        if (isAdjustingOffset()) binding.cameraX += s * getAdjustStep();\n        else binding.roll += s * 4 * (float) getAdjustStep();\n        binding.clamp();\n    }\n", "    public void adjustBindingY(boolean add) {\n        int s = add ? 1 : -1;\n        if (isAdjustingOffset()) binding.cameraY += s * getAdjustStep();\n        else binding.yaw += s * 4 * (float) getAdjustStep();\n        binding.clamp();\n    }\n\n    public void adjustBindingZ(boolean add) {\n        int s = add ? 1 : -1;\n        if (isAdjustingOffset()) binding.cameraZ += s * getAdjustStep();\n        else binding.pitch += s * 4 * (float) getAdjustStep();\n        binding.clamp();\n    }\n\n    // classic\n    public Classic.AdjustMode getClassicAdjustMode() {\n        return classic.adjustMode;\n    }\n", "        if (isAdjustingOffset()) binding.cameraZ += s * getAdjustStep();\n        else binding.pitch += s * 4 * (float) getAdjustStep();\n        binding.clamp();\n    }\n\n    // classic\n    public Classic.AdjustMode getClassicAdjustMode() {\n        return classic.adjustMode;\n    }\n\n    public double getClassicX() {\n        return classic.cameraX;\n    }\n", "    public double getClassicX() {\n        return classic.cameraX;\n    }\n\n    public double getClassicY() {\n        return classic.cameraY;\n    }\n\n    public double getClassicZ() {\n        return classic.cameraZ;\n    }\n", "    public double getClassicZ() {\n        return classic.cameraZ;\n    }\n\n    public double getClassicRX() {\n        return classic.referX;\n    }\n\n    public double getClassicRY() {\n        return classic.referY;\n    }\n", "    public double getClassicRY() {\n        return classic.referY;\n    }\n\n    public double getClassicRZ() {\n        return classic.referZ;\n    }\n\n    public double getCenterX() {\n        return classic.centerX;\n    }\n", "    public double getCenterX() {\n        return classic.centerX;\n    }\n\n    public double getCenterY() {\n        return classic.centerY;\n    }\n\n    public double getCenterZ() {\n        return classic.centerZ;\n    }\n", "    public double getCenterZ() {\n        return classic.centerZ;\n    }\n\n    public float getClassicPitch() {\n        return classic.pitch;\n    }\n\n    public float getClassicYaw() {\n        return classic.yaw;\n    }\n", "    public float getClassicYaw() {\n        return classic.yaw;\n    }\n\n    public float getClassicRoll() {\n        return classic.roll;\n    }\n\n    public void cycleClassicAdjustMode() {\n        classic.adjustMode = classic.adjustMode.cycle();\n    }\n", "    public void cycleClassicAdjustMode() {\n        classic.adjustMode = classic.adjustMode.cycle();\n    }\n\n    public void adjustClassicX(boolean add) {\n        int s = add ? 1 : -1;\n        switch (classic.adjustMode) {\n            case CENTER -> classic.centerX += s * getAdjustStep();\n            case ROTATION -> classic.roll += s * 4 * (float) getAdjustStep();\n            default -> classic.cameraX += s * getAdjustStep();\n        }\n        classic.clamp();\n    }\n", "    public void adjustClassicY(boolean add) {\n        int s = add ? 1 : -1;\n        switch (classic.adjustMode) {\n            case CENTER -> classic.centerY += s * getAdjustStep();\n            case ROTATION -> classic.yaw += s * 4 * (float) getAdjustStep();\n            default -> classic.cameraY += s * getAdjustStep();\n        }\n        classic.clamp();\n    }\n\n    public void adjustClassicZ(boolean add) {\n        int s = add ? 1 : -1;\n        switch (classic.adjustMode) {\n            case CENTER -> classic.centerZ += s * getAdjustStep();\n            case ROTATION -> classic.pitch += s * 4 * (float) getAdjustStep();\n            default -> classic.cameraZ += s * getAdjustStep();\n        }\n        classic.clamp();\n    }\n\n    // compats", "    public void adjustClassicZ(boolean add) {\n        int s = add ? 1 : -1;\n        switch (classic.adjustMode) {\n            case CENTER -> classic.centerZ += s * getAdjustStep();\n            case ROTATION -> classic.pitch += s * 4 * (float) getAdjustStep();\n            default -> classic.cameraZ += s * getAdjustStep();\n        }\n        classic.clamp();\n    }\n\n    // compats", "    public boolean isUsingModModel() {\n        return compats.useModModel;\n    }\n\n    public String getModelModID() {\n        return compats.modelModID;\n    }\n\n    public String getModModelPartName() {\n        return compats.modModelPart;\n    }\n", "    public String getModModelPartName() {\n        return compats.modModelPart;\n    }\n\n    public boolean compatDoABarrelRoll() {\n        return compats.doABarrelRoll;\n    }\n\n    public boolean compatPehkui() {\n        return compats.pehkui;\n    }\n", "    public boolean compatPehkui() {\n        return compats.pehkui;\n    }\n\n    public boolean compatPhysicsMod() {\n        return compats.physicsMod;\n    }\n\n    // disable\n    private boolean shouldDisable(MinecraftClient client, String action) {\n        boolean b = false;", "        for (Triple<String, List<String>, List<String>> triple : disable.customConditions) {\n            if (!triple.getRight().contains(action)) continue;\n            String behavior = triple.getLeft();\n            b = b || (client.player.isHolding(stack ->\n                            triple.getMiddle().contains(Registries.ITEM.getId(stack.getItem()).toString())) &&\n                    (behavior.equals(\"holding\") ||\n                            (behavior.equals(\"attacking\") && client.options.attackKey.isPressed()) ||\n                            (behavior.equals(\"using\") && client.options.useKey.isPressed())));\n        }\n        return b;\n    }\n", "    public boolean shouldDisableRender(String modelPartName) {\n        if (disable.onlyInBinding && general.classic) return false;\n        return (disable.renderModelPart && disable.disabledModelParts.contains(modelPartName)) ||\n                shouldDisable(MinecraftClient.getInstance(), modelPartName);\n    }\n\n    public boolean allowRenderingHandWhen(MinecraftClient client) {\n        if (disable.onlyInBinding && general.classic) return false;\n        return shouldDisable(client, \"allow_rendering_hand\");\n    }\n", "    public boolean disableModWhen(MinecraftClient client) {\n        if (disable.onlyInBinding && general.classic) return false;\n        return shouldDisable(client, \"disable_mod\") ||\n                (client.player.isFallFlying() && disable.fallFlying) ||\n                (client.player.isSwimming() && disable.swimming) ||\n                (client.player.isCrawling() && disable.crawling) ||\n                (client.player.isSneaking() && disable.sneaking) ||\n                (client.player.isSleeping() && disable.sleeping) ||\n                (client.currentScreen != null && disable.screenOpened);\n    }\n", "    public boolean disableRenderingWhen(MinecraftClient client) {\n        if (disable.onlyInBinding && general.classic) return false;\n        return shouldDisable(client, \"disable_rendering\");\n    }\n\n    public static class General {\n        public boolean enabled = false;\n        public boolean classic = false;\n        public boolean clipToSpace = true;\n        public boolean dynamicCrosshair = false;\n        public boolean renderModel = true;", "        public boolean clipToSpace = true;\n        public boolean dynamicCrosshair = false;\n        public boolean renderModel = true;\n        public double adjustStep = 0.25D;\n        public double scale = 1.0D;\n\n        private void clamp() {\n            adjustStep = MathHelper.clamp(adjustStep, 0.0D, MAX_DOUBLE);\n            scale = MathHelper.clamp(scale, 0.0D, MAX_DOUBLE);\n        }\n    }\n", "    public static class Binding {\n        public VanillaModelPart vanillaModelPart = VanillaModelPart.head;\n        public boolean adjustOffset = true;\n        public double cameraX = 3.25D;\n        public double cameraY = 2.0D;\n        public double cameraZ = 0.0D;\n        public double referX = 3.25D;\n        public double referY = 2.0D;\n        public double referZ = 0.0D;\n        public boolean bindPitching = true;\n        public boolean bindYawing = true;", "        public double referZ = 0.0D;\n        public boolean bindPitching = true;\n        public boolean bindYawing = true;\n        public boolean bindRolling = true;\n        public float pitch = 0.0F;\n        public float yaw = 0.0F;\n        public float roll = 0.0F;\n\n        private void clamp() {\n            if (vanillaModelPart == null) vanillaModelPart = VanillaModelPart.head;\n            cameraX = MathHelper.clamp(cameraX, MIN_DOUBLE, MAX_DOUBLE);\n            cameraY = MathHelper.clamp(cameraY, MIN_DOUBLE, MAX_DOUBLE);\n            cameraZ = MathHelper.clamp(cameraZ, MIN_DOUBLE, MAX_DOUBLE);\n            referX = MathHelper.clamp(referX, MIN_DOUBLE, MAX_DOUBLE);\n            referY = MathHelper.clamp(referY, MIN_DOUBLE, MAX_DOUBLE);\n            referZ = MathHelper.clamp(referZ, MIN_DOUBLE, MAX_DOUBLE);\n            pitch = MathHelper.wrapDegrees(pitch);\n            yaw = MathHelper.wrapDegrees(yaw);\n            roll = MathHelper.wrapDegrees(roll);\n        }\n    }\n", "            if (vanillaModelPart == null) vanillaModelPart = VanillaModelPart.head;\n            cameraX = MathHelper.clamp(cameraX, MIN_DOUBLE, MAX_DOUBLE);\n            cameraY = MathHelper.clamp(cameraY, MIN_DOUBLE, MAX_DOUBLE);\n            cameraZ = MathHelper.clamp(cameraZ, MIN_DOUBLE, MAX_DOUBLE);\n            referX = MathHelper.clamp(referX, MIN_DOUBLE, MAX_DOUBLE);\n            referY = MathHelper.clamp(referY, MIN_DOUBLE, MAX_DOUBLE);\n            referZ = MathHelper.clamp(referZ, MIN_DOUBLE, MAX_DOUBLE);\n            pitch = MathHelper.wrapDegrees(pitch);\n            yaw = MathHelper.wrapDegrees(yaw);\n            roll = MathHelper.wrapDegrees(roll);\n        }\n    }\n", "    public static class Classic {\n        public AdjustMode adjustMode = AdjustMode.CAMERA;\n        public double cameraX = -60.0D;\n        public double cameraY = 2.0D;\n        public double cameraZ = -16.0D;\n        public double referX = 3.25D;\n        public double referY = 2.0D;\n        public double referZ = 0.0D;\n        public double centerX = 0.0D;\n        public double centerY = -3.4D;\n        public double centerZ = 0.0D;", "        public double centerX = 0.0D;\n        public double centerY = -3.4D;\n        public double centerZ = 0.0D;\n        public float pitch = 0.0F;\n        public float yaw = 18.0F;\n        public float roll = 0.0F;\n\n        private void clamp() {\n            if (adjustMode == null) adjustMode = AdjustMode.CAMERA;\n            cameraX = MathHelper.clamp(cameraX, MIN_DOUBLE, MAX_DOUBLE);\n            cameraY = MathHelper.clamp(cameraY, MIN_DOUBLE, MAX_DOUBLE);\n            cameraZ = MathHelper.clamp(cameraZ, MIN_DOUBLE, MAX_DOUBLE);\n            referX = MathHelper.clamp(referX, MIN_DOUBLE, MAX_DOUBLE);\n            referY = MathHelper.clamp(referY, MIN_DOUBLE, MAX_DOUBLE);\n            referZ = MathHelper.clamp(referZ, MIN_DOUBLE, MAX_DOUBLE);\n            centerX = MathHelper.clamp(centerX, MIN_DOUBLE, MAX_DOUBLE);\n            centerY = MathHelper.clamp(centerY, MIN_DOUBLE, MAX_DOUBLE);\n            centerZ = MathHelper.clamp(centerZ, MIN_DOUBLE, MAX_DOUBLE);\n            pitch = MathHelper.wrapDegrees(pitch);\n            yaw = MathHelper.wrapDegrees(yaw);\n            roll = MathHelper.wrapDegrees(roll);\n        }\n", "            if (adjustMode == null) adjustMode = AdjustMode.CAMERA;\n            cameraX = MathHelper.clamp(cameraX, MIN_DOUBLE, MAX_DOUBLE);\n            cameraY = MathHelper.clamp(cameraY, MIN_DOUBLE, MAX_DOUBLE);\n            cameraZ = MathHelper.clamp(cameraZ, MIN_DOUBLE, MAX_DOUBLE);\n            referX = MathHelper.clamp(referX, MIN_DOUBLE, MAX_DOUBLE);\n            referY = MathHelper.clamp(referY, MIN_DOUBLE, MAX_DOUBLE);\n            referZ = MathHelper.clamp(referZ, MIN_DOUBLE, MAX_DOUBLE);\n            centerX = MathHelper.clamp(centerX, MIN_DOUBLE, MAX_DOUBLE);\n            centerY = MathHelper.clamp(centerY, MIN_DOUBLE, MAX_DOUBLE);\n            centerZ = MathHelper.clamp(centerZ, MIN_DOUBLE, MAX_DOUBLE);\n            pitch = MathHelper.wrapDegrees(pitch);\n            yaw = MathHelper.wrapDegrees(yaw);\n            roll = MathHelper.wrapDegrees(roll);\n        }\n", "        public enum AdjustMode {\n            CAMERA, CENTER, ROTATION;\n\n            private static final AdjustMode[] VALUES = values();\n\n            public AdjustMode cycle() {\n                return VALUES[(ordinal() + 1) % VALUES.length];\n            }\n        }\n    }\n", "    public static class Compats {\n        public boolean useModModel = false;\n        public String modelModID = \"minecraft\";\n        public String modModelPart = \"head\";\n        public boolean doABarrelRoll = true;\n        public boolean pehkui = true;\n        public boolean physicsMod = true;\n    }\n\n    public static class Disable {\n        public static final Set<String> optionalParts = new HashSet<>(Set.of(\"head\", \"hat\", \"helmet\"));\n        protected static final List<String> defaultParts = Arrays.asList(\"head\", \"hat\", \"helmet\");\n        protected static final Triple<String, List<String>, List<String>> defaultTriple = new Triple<>\n                (\"holding\", List.of(\"new item id\"), List.of(\"new action\"));\n        protected static final List<Triple<String, List<String>, List<String>>> defaultConditions = Arrays.asList(\n                new Triple<>(\"using\", List.of(\"minecraft:spyglass\"), List.of(\"disable_rendering\")),\n                new Triple<>(\"holding\", List.of(\"Example--minecraft:filled_map\"), Arrays.asList(\n                        \"allow_rendering_hand\", \"leftArm\", \"rightArm\", \"leftSleeve\", \"rightSleeve\", \"heldItem\")));\n        protected static final String[] behaviors = {\"holding\", \"attacking\", \"using\"};", "    public static class Disable {\n        public static final Set<String> optionalParts = new HashSet<>(Set.of(\"head\", \"hat\", \"helmet\"));\n        protected static final List<String> defaultParts = Arrays.asList(\"head\", \"hat\", \"helmet\");\n        protected static final Triple<String, List<String>, List<String>> defaultTriple = new Triple<>\n                (\"holding\", List.of(\"new item id\"), List.of(\"new action\"));\n        protected static final List<Triple<String, List<String>, List<String>>> defaultConditions = Arrays.asList(\n                new Triple<>(\"using\", List.of(\"minecraft:spyglass\"), List.of(\"disable_rendering\")),\n                new Triple<>(\"holding\", List.of(\"Example--minecraft:filled_map\"), Arrays.asList(\n                        \"allow_rendering_hand\", \"leftArm\", \"rightArm\", \"leftSleeve\", \"rightSleeve\", \"heldItem\")));\n        protected static final String[] behaviors = {\"holding\", \"attacking\", \"using\"};\n        public boolean onlyInBinding = true;", "        public boolean onlyInBinding = true;\n        public boolean renderModelPart = false;\n        public List<String> disabledModelParts = defaultParts;\n        public List<Triple<String, List<String>, List<String>>> customConditions = defaultConditions;\n        public boolean fallFlying = true;\n        public boolean swimming = false;\n        public boolean crawling = false;\n        public boolean sneaking = false;\n        public boolean sleeping = false;\n        public boolean screenOpened = false;\n\n        private void clamp() {", "        public boolean sleeping = false;\n        public boolean screenOpened = false;\n\n        private void clamp() {\n            if (disabledModelParts == null) disabledModelParts = defaultParts;\n            if (customConditions == null) customConditions = defaultConditions;\n            customConditions.forEach(triple -> resetTripleIfNull(triple, defaultTriple));\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/compat/PhysicsModCompat.java", "chunked_list": ["package com.xtracr.realcamera.compat;\n\nimport com.xtracr.realcamera.utils.ReflectUtils;\nimport net.minecraft.client.render.entity.EntityRenderDispatcher;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.client.world.ClientWorld;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.world.World;\nimport org.joml.Matrix3f;\nimport org.joml.Matrix4f;", "import org.joml.Matrix3f;\nimport org.joml.Matrix4f;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\npublic class PhysicsModCompat {\n    public static final boolean loaded = ReflectUtils.isLoaded(\"net.diebuddies.physics.PhysicsMod\");\n\n    private static final Optional<Field> EntityRenderDispatcher_worldField;\n    private static final Optional<Method> ConfigClient_areOceanPhysicsEnabled;\n    private static final Optional<Method> PhysicsMod_getInstance;\n    private static final Optional<Method> PhysicsMod_getPhysicsWorld;\n    private static final Optional<Method> PhysicsWorld_getOceanWorld;\n    private static final Optional<Method> OceanWorld_computeEntityOffset;\n\n    static {", "    public static final boolean loaded = ReflectUtils.isLoaded(\"net.diebuddies.physics.PhysicsMod\");\n\n    private static final Optional<Field> EntityRenderDispatcher_worldField;\n    private static final Optional<Method> ConfigClient_areOceanPhysicsEnabled;\n    private static final Optional<Method> PhysicsMod_getInstance;\n    private static final Optional<Method> PhysicsMod_getPhysicsWorld;\n    private static final Optional<Method> PhysicsWorld_getOceanWorld;\n    private static final Optional<Method> OceanWorld_computeEntityOffset;\n\n    static {\n        if (loaded) {\n            final String worldFieldName = ReflectUtils.isLoaded(\"net.fabricmc.loader.api.FabricLoader\") ? \"field_4684\" : \"f_114366_\";\n            final Optional<Class<?>> configClientClass = ReflectUtils.getClass(\"net.diebuddies.config.ConfigClient\");\n            final Optional<Class<?>> physicsModClass = ReflectUtils.getClass(\"net.diebuddies.physics.PhysicsMod\");\n            final Optional<Class<?>> physicsWorldClass = ReflectUtils.getClass(\"net.diebuddies.physics.PhysicsWorld\");\n            final Optional<Class<?>> oceanWorldClass = ReflectUtils.getClass(\"net.diebuddies.physics.ocean.OceanWorld\");\n            EntityRenderDispatcher_worldField = ReflectUtils.getDeclaredField(Optional.of(EntityRenderDispatcher.class), worldFieldName);\n            ConfigClient_areOceanPhysicsEnabled = ReflectUtils.getDeclaredMethod(configClientClass, \"areOceanPhysicsEnabled\");\n            PhysicsMod_getInstance = ReflectUtils.getDeclaredMethod(physicsModClass, \"getInstance\", World.class);\n            PhysicsMod_getPhysicsWorld = ReflectUtils.getDeclaredMethod(physicsModClass, \"getPhysicsWorld\");\n            PhysicsWorld_getOceanWorld = ReflectUtils.getDeclaredMethod(physicsWorldClass, \"getOceanWorld\");\n            OceanWorld_computeEntityOffset = ReflectUtils.getDeclaredMethod(oceanWorldClass, \"computeEntityOffset\",\n                    Matrix4f.class, Matrix3f.class, World.class, Entity.class, double.class, double.class, double.class, double.class, double.class, double.class, float.class, float.class);\n        } else {\n            EntityRenderDispatcher_worldField = Optional.empty();\n            ConfigClient_areOceanPhysicsEnabled = Optional.empty();\n            PhysicsMod_getInstance = Optional.empty();\n            PhysicsMod_getPhysicsWorld = Optional.empty();\n            PhysicsWorld_getOceanWorld = Optional.empty();\n            OceanWorld_computeEntityOffset = Optional.empty();\n        }\n    }\n\n    public static <E extends Entity> void renderStart(EntityRenderDispatcher dispatcher, E entity, double x, double y, double z, float yRot, float renderPercent, MatrixStack matrixStack) {", "        if (loaded) {\n            final String worldFieldName = ReflectUtils.isLoaded(\"net.fabricmc.loader.api.FabricLoader\") ? \"field_4684\" : \"f_114366_\";\n            final Optional<Class<?>> configClientClass = ReflectUtils.getClass(\"net.diebuddies.config.ConfigClient\");\n            final Optional<Class<?>> physicsModClass = ReflectUtils.getClass(\"net.diebuddies.physics.PhysicsMod\");\n            final Optional<Class<?>> physicsWorldClass = ReflectUtils.getClass(\"net.diebuddies.physics.PhysicsWorld\");\n            final Optional<Class<?>> oceanWorldClass = ReflectUtils.getClass(\"net.diebuddies.physics.ocean.OceanWorld\");\n            EntityRenderDispatcher_worldField = ReflectUtils.getDeclaredField(Optional.of(EntityRenderDispatcher.class), worldFieldName);\n            ConfigClient_areOceanPhysicsEnabled = ReflectUtils.getDeclaredMethod(configClientClass, \"areOceanPhysicsEnabled\");\n            PhysicsMod_getInstance = ReflectUtils.getDeclaredMethod(physicsModClass, \"getInstance\", World.class);\n            PhysicsMod_getPhysicsWorld = ReflectUtils.getDeclaredMethod(physicsModClass, \"getPhysicsWorld\");\n            PhysicsWorld_getOceanWorld = ReflectUtils.getDeclaredMethod(physicsWorldClass, \"getOceanWorld\");\n            OceanWorld_computeEntityOffset = ReflectUtils.getDeclaredMethod(oceanWorldClass, \"computeEntityOffset\",\n                    Matrix4f.class, Matrix3f.class, World.class, Entity.class, double.class, double.class, double.class, double.class, double.class, double.class, float.class, float.class);\n        } else {\n            EntityRenderDispatcher_worldField = Optional.empty();\n            ConfigClient_areOceanPhysicsEnabled = Optional.empty();\n            PhysicsMod_getInstance = Optional.empty();\n            PhysicsMod_getPhysicsWorld = Optional.empty();\n            PhysicsWorld_getOceanWorld = Optional.empty();\n            OceanWorld_computeEntityOffset = Optional.empty();\n        }\n    }\n\n    public static <E extends Entity> void renderStart(EntityRenderDispatcher dispatcher, E entity, double x, double y, double z, float yRot, float renderPercent, MatrixStack matrixStack) {", "        if (!loaded) return;\n        Object world = ReflectUtils.getFieldValue(EntityRenderDispatcher_worldField, dispatcher).get();\n        if ((boolean) ReflectUtils.invokeMethod(ConfigClient_areOceanPhysicsEnabled, null).orElse(false) && world instanceof ClientWorld clientWorld) {\n            Object oceanWorld = ReflectUtils.invokeMethod(PhysicsWorld_getOceanWorld, ReflectUtils.invokeMethod(PhysicsMod_getPhysicsWorld, ReflectUtils.invokeMethod(PhysicsMod_getInstance, null, clientWorld).get()).get()).get();\n            ReflectUtils.invokeMethod(OceanWorld_computeEntityOffset, oceanWorld, matrixStack.peek().getPositionMatrix(), matrixStack.peek().getNormalMatrix(), clientWorld, entity, x, y, z, 0.0D, 0.0D, 0.0D, yRot, renderPercent);\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/compat/PehkuiCompat.java", "chunked_list": ["package com.xtracr.realcamera.compat;\n\nimport com.xtracr.realcamera.utils.ReflectUtils;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.util.math.Vec3d;\n\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\npublic class PehkuiCompat {", "import java.util.Optional;\n\npublic class PehkuiCompat {\n    public static final boolean loaded = ReflectUtils.isLoaded(\"virtuoel.pehkui.Pehkui\");\n\n    private static final Optional<Method> getModelWidthScale;\n    private static final Optional<Method> getModelHeightScale;\n\n    static {\n        if (loaded) {\n            final Optional<Class<?>> scaleUtilsClass = ReflectUtils.getClass(\"virtuoel.pehkui.util.ScaleUtils\");\n            getModelWidthScale = ReflectUtils.getMethod(scaleUtilsClass, \"getModelWidthScale\", Entity.class, float.class);\n            getModelHeightScale = ReflectUtils.getMethod(scaleUtilsClass, \"getModelHeightScale\", Entity.class, float.class);\n        } else {\n            getModelWidthScale = Optional.empty();\n            getModelHeightScale = Optional.empty();\n        }\n    }\n", "        if (loaded) {\n            final Optional<Class<?>> scaleUtilsClass = ReflectUtils.getClass(\"virtuoel.pehkui.util.ScaleUtils\");\n            getModelWidthScale = ReflectUtils.getMethod(scaleUtilsClass, \"getModelWidthScale\", Entity.class, float.class);\n            getModelHeightScale = ReflectUtils.getMethod(scaleUtilsClass, \"getModelHeightScale\", Entity.class, float.class);\n        } else {\n            getModelWidthScale = Optional.empty();\n            getModelHeightScale = Optional.empty();\n        }\n    }\n\n    public static void scaleMatrices(MatrixStack matrixStack, Entity entity, float tickDelta) {", "    public static void scaleMatrices(MatrixStack matrixStack, Entity entity, float tickDelta) {\n        if (!loaded) return;\n        final float widthScale = (float) ReflectUtils.invokeMethod(getModelWidthScale, null, entity, tickDelta).orElse(1.0F);\n        final float heightScale = (float) ReflectUtils.invokeMethod(getModelHeightScale, null, entity, tickDelta).orElse(1.0F);\n        matrixStack.peek().getPositionMatrix().scale(widthScale, heightScale, widthScale);\n    }\n\n    public static Vec3d scaleVec3d(Vec3d vec3d, Entity entity, float tickDelta) {\n        if (!loaded) return vec3d;\n        final float widthScale = (float) ReflectUtils.invokeMethod(getModelWidthScale, null, entity, tickDelta).orElse(1.0F);\n        final float heightScale = (float) ReflectUtils.invokeMethod(getModelHeightScale, null, entity, tickDelta).orElse(1.0F);\n        return vec3d.multiply(widthScale, heightScale, widthScale);\n    }\n}\n", "        if (!loaded) return vec3d;\n        final float widthScale = (float) ReflectUtils.invokeMethod(getModelWidthScale, null, entity, tickDelta).orElse(1.0F);\n        final float heightScale = (float) ReflectUtils.invokeMethod(getModelHeightScale, null, entity, tickDelta).orElse(1.0F);\n        return vec3d.multiply(widthScale, heightScale, widthScale);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/compat/DoABarrelRollCompat.java", "chunked_list": ["package com.xtracr.realcamera.compat;\n\nimport com.xtracr.realcamera.utils.ReflectUtils;\n\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\npublic class DoABarrelRollCompat {\n    public static final boolean loaded = ReflectUtils.isLoaded(\"nl.enjarai.doabarrelroll.DoABarrelRollClient\");\n\n    private static final Optional<Object> modConfigInstance;\n    private static final Optional<Method> getModEnabled;\n\n    static {", "    public static final boolean loaded = ReflectUtils.isLoaded(\"nl.enjarai.doabarrelroll.DoABarrelRollClient\");\n\n    private static final Optional<Object> modConfigInstance;\n    private static final Optional<Method> getModEnabled;\n\n    static {\n        if (loaded) {\n            final Optional<Class<?>> modConfigClass = ReflectUtils.getClass(\"nl.enjarai.doabarrelroll.config.ModConfig\");\n            modConfigInstance = ReflectUtils.getFieldValue(ReflectUtils.getField(modConfigClass, \"INSTANCE\"), null);\n            getModEnabled = ReflectUtils.getMethod(modConfigClass, \"getModEnabled\");\n        } else {\n            modConfigInstance = Optional.empty();\n            getModEnabled = Optional.empty();\n        }\n    }\n", "    public static boolean modEnabled() {\n        return loaded && (boolean) ReflectUtils.invokeMethod(getModEnabled, modConfigInstance.get()).orElse(false);\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/api/CompatExample.java", "chunked_list": ["package com.xtracr.realcamera.api;\n\nimport com.xtracr.realcamera.mixins.PlayerEntityRendererAccessor;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.model.ModelPart;\nimport net.minecraft.client.network.AbstractClientPlayerEntity;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.render.entity.PlayerEntityRenderer;\nimport net.minecraft.client.render.entity.model.PlayerEntityModel;\nimport net.minecraft.client.util.math.MatrixStack;", "import net.minecraft.client.render.entity.model.PlayerEntityModel;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.entity.EntityPose;\nimport net.minecraft.entity.LivingEntity;\nimport net.minecraft.util.math.Direction;\nimport net.minecraft.util.math.MathHelper;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;", "import java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiPredicate;\n\n/**\n * This example uses {@code reflection} to {@code register} and {@code getModelPartName}.\n *\n * <p>If you don't want to use reflection, an (optional) dependency should be added to call the methods.\n * Don't know how to add a dependency? Go to <a href=\"https://jitpack.io\">jitpack.io</a>", " * <p>If you don't want to use reflection, an (optional) dependency should be added to call the methods.\n * Don't know how to add a dependency? Go to <a href=\"https://jitpack.io\">jitpack.io</a>\n * or <a href=\"https://jitpack.io/#xTracr/RealCamera/\">jitpack.io/#xTracr/RealCamera/</a>\n * for information about it.</p>\n */\npublic class CompatExample {\n    /**\n     * <b>mandatory</b>\n     */\n    public static final String modid = \"minecraft\";\n\n    private static final Map<String, String> nameMap = new HashMap<>();\n    /**\n     * {@code = VirtualRenderer.class.getDeclaredMethod(\"getModelPartName\")}\n     *\n     * <p>return the value of {@link com.xtracr.realcamera.config.ModConfig.Compats#modModelPart modModelPart}\n     * option in the config.</p>\n     *\n     * @see #register()\n     * @see VirtualRenderer#getModelPartName() getModelPartName()\n     */\n    private static Method getModelPartNameMethod;\n\n    static {\n        // These data were obtained from the mapping file.", "    public static final String modid = \"minecraft\";\n\n    private static final Map<String, String> nameMap = new HashMap<>();\n    /**\n     * {@code = VirtualRenderer.class.getDeclaredMethod(\"getModelPartName\")}\n     *\n     * <p>return the value of {@link com.xtracr.realcamera.config.ModConfig.Compats#modModelPart modModelPart}\n     * option in the config.</p>\n     *\n     * @see #register()\n     * @see VirtualRenderer#getModelPartName() getModelPartName()\n     */\n    private static Method getModelPartNameMethod;\n\n    static {\n        // These data were obtained from the mapping file.", "        try {\n            // Fabric\n            Class.forName(\"net.fabricmc.loader.api.FabricLoader\");\n            nameMap.put(\"head\", \"field_3398\");\n            nameMap.put(\"hat\", \"field_3394\");\n            nameMap.put(\"body\", \"field_3391\");\n            nameMap.put(\"rightArm\", \"field_3401\");\n            nameMap.put(\"leftArm\", \"field_27433\");\n            nameMap.put(\"rightLeg\", \"field_3392\");\n            nameMap.put(\"leftLeg\", \"field_3397\");\n            nameMap.put(\"leftSleeve\", \"field_3484\");\n            nameMap.put(\"rightSleeve\", \"field_3486\");\n            nameMap.put(\"leftPants\", \"field_3482\");\n            nameMap.put(\"rightPants\", \"field_3479\");\n            nameMap.put(\"jacket\", \"field_3483\");\n            nameMap.put(\"cloak\", \"field_3485\");\n            nameMap.put(\"ear\", \"field_3481\");\n        } catch (ClassNotFoundException exception) {\n            // Forge\n            nameMap.put(\"head\", \"f_102808_\");\n            nameMap.put(\"hat\", \"f_102809_\");\n            nameMap.put(\"body\", \"f_102810_\");\n            nameMap.put(\"rightArm\", \"f_102811_\");\n            nameMap.put(\"leftArm\", \"f_102812_\");\n            nameMap.put(\"rightLeg\", \"f_102813_\");\n            nameMap.put(\"leftLeg\", \"f_102814_\");\n            nameMap.put(\"leftSleeve\", \"f_103374_\");\n            nameMap.put(\"rightSleeve\", \"f_103375_\");\n            nameMap.put(\"leftPants\", \"f_103376_\");\n            nameMap.put(\"rightPants\", \"f_103377_\");\n            nameMap.put(\"jacket\", \"f_103378_\");\n            nameMap.put(\"cloak\", \"f_103373_\");\n            nameMap.put(\"ear\", \"f_103379_\");\n        }\n    }\n\n    /**\n     * Your should register before the first time camera setup.\n     *\n     * <p>This method is called in {@link com.xtracr.realcamera.RealCamera#setup()}.</p>\n     *\n     * @see VirtualRenderer#register(String, BiPredicate)\n     */", "    public static void register() {\n        //if ( Real Camera isn't loaded ) return;\n        try {\n            final Class<?> virtualRendererClass = Class.forName(\"com.xtracr.realcamera.api.VirtualRenderer\");\n            getModelPartNameMethod = virtualRendererClass.getDeclaredMethod(\"getModelPartName\");\n\n            final Method registerMethod = virtualRendererClass.getDeclaredMethod(\"register\", String.class, BiPredicate.class);\n            final BiPredicate<Float, MatrixStack> function = CompatExample::virtualRender;\n            registerMethod.invoke(null, modid, function);\n\n        } catch (Exception exception) {\n            // handle exception\n        }\n    }\n\n    /**\n     * <b>mandatory</b>\n     *\n     * <p>This method's code should include as much as possible all parts related to {@code matrixStack}\n     * in the code that renders the player model, to ensure that the result of {@code matrixStack}\n     * after processing is identical to the actual rendering.</p>\n     *\n     * <p>When you need to handle a {@code Throwable} that makes it impossible for the method to continue running,\n     * simply wrap it in a {@link RuntimeException} and throw it, just like in {@link #getModelPart} here.</p>\n     *\n     * @param tickDelta   or partialTick(s) (official mapping)\n     * @param matrixStack or poseStack (official mapping)\n     * @return {@code boolean} turn to vanilla rendering if true\n     * @see net.minecraft.client.render.entity.EntityRenderDispatcher#render\n     * @see net.minecraft.client.render.entity.PlayerEntityRenderer#render\n     * @see net.minecraft.client.render.entity.LivingEntityRenderer#render\n     * @see net.minecraft.client.render.entity.model.AnimalModel#render\n     * @see net.minecraft.client.model.ModelPart#render\n     */", "    public static boolean virtualRender(float tickDelta, MatrixStack matrixStack) {\n        MinecraftClient client = MinecraftClient.getInstance();\n        ClientPlayerEntity player = client.player;\n        PlayerEntityRenderer renderer = (PlayerEntityRenderer) client.getEntityRenderDispatcher().getRenderer(player);\n        // PlayerEntityRenderer.render\n        ((PlayerEntityRendererAccessor) renderer).invokeSetModelPose(player);\n        // LivingEntityRenderer.render\n        PlayerEntityModel<AbstractClientPlayerEntity> playerModel = renderer.getModel();\n        float n;\n        Direction direction;\n        playerModel.handSwingProgress = player.getHandSwingProgress(tickDelta);\n        playerModel.riding = player.hasVehicle();\n        playerModel.child = player.isBaby();\n        float h = MathHelper.lerpAngleDegrees(tickDelta, player.prevBodyYaw, player.bodyYaw);\n        float j = MathHelper.lerpAngleDegrees(tickDelta, player.prevHeadYaw, player.headYaw);\n        float k = j - h;", "        if (player.hasVehicle() && player.getVehicle() instanceof LivingEntity) {\n            LivingEntity vehicle = (LivingEntity) player.getVehicle();\n            h = MathHelper.lerpAngleDegrees(tickDelta, vehicle.prevBodyYaw, vehicle.bodyYaw);\n            k = j - h;\n            float l = MathHelper.wrapDegrees(k);\n            if (l < -85.0f) {\n                l = -85.0f;\n            }\n            if (l >= 85.0f) {\n                l = 85.0f;\n            }\n            h = j - l;", "            if (l >= 85.0f) {\n                l = 85.0f;\n            }\n            h = j - l;\n            if (l * l > 2500.0f) {\n                h += l * 0.2f;\n            }\n            k = j - h;\n        }\n        float m = MathHelper.lerp(tickDelta, player.prevPitch, player.getPitch());\n        if (PlayerEntityRenderer.shouldFlipUpsideDown(player)) {\n            m *= -1.0f;\n            k *= -1.0f;\n        }", "        if (PlayerEntityRenderer.shouldFlipUpsideDown(player)) {\n            m *= -1.0f;\n            k *= -1.0f;\n        }\n        if (player.isInPose(EntityPose.SLEEPING) && (direction = player.getSleepingDirection()) != null) {\n            n = player.getEyeHeight(EntityPose.STANDING) - 0.1f;\n            matrixStack.translate((float) (-direction.getOffsetX()) * n, 0.0f, (float) (-direction.getOffsetZ()) * n);\n        }\n        float l = player.age + tickDelta;\n        ((PlayerEntityRendererAccessor) renderer).invokeSetupTransforms(player, matrixStack, l, h, tickDelta);\n        matrixStack.scale(-1.0f, -1.0f, 1.0f);\n        ((PlayerEntityRendererAccessor) renderer).invokeScale(player, matrixStack, tickDelta);\n        matrixStack.translate(0.0f, -1.501f, 0.0f);\n        n = 0.0f;\n        float o = 0.0f;", "        if (!player.hasVehicle() && player.isAlive()) {\n            n = player.limbAnimator.getSpeed(tickDelta);\n            o = player.limbAnimator.getPos(tickDelta);\n            if (player.isBaby()) {\n                o *= 3.0f;\n            }\n            if (n > 1.0f) {\n                n = 1.0f;\n            }\n        }\n        playerModel.animateModel(player, o, n, tickDelta);\n        playerModel.setAngles(player, o, n, l, k, m);\n        ModelPart modelPart = getModelPart(playerModel);\n        // AnimalModel.render\n        /*", "        if (playerModel.child) {\n            float f;\n            if (...) {\n                if (playerModel.headScaled) {\n                    f = 1.5f / playerModel.invertedChildHeadScale;\n                    matrixStack.scale(f, f, f);\n                }\n                matrixStack.translate(0.0f, playerModel.childHeadYOffset / 16.0f, playerModel.childHeadZOffset / 16.0f);\n            } else {\n                f = 1.0f / playerModel.invertedChildBodyScale;\n                matrixStack.scale(f, f, f);\n                matrixStack.translate(0.0f, playerModel.childBodyYOffset / 16.0f, 0.0f);\n            }\n        }\n         */\n        // ModelPart.render\n        modelPart.rotate(matrixStack);\n        return false;\n    }\n\n    private static ModelPart getModelPart(PlayerEntityModel<AbstractClientPlayerEntity> playerModel) {", "        try {\n            final String fieldName = nameMap.get((String) getModelPartNameMethod.invoke(null));\n            final Field modelPartField = playerModel.getClass().getField(fieldName);\n            return (ModelPart) modelPartField.get(playerModel);\n        } catch (Exception exception) {\n            throw new RuntimeException(exception);\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/com/xtracr/realcamera/api/VirtualRenderer.java", "chunked_list": ["package com.xtracr.realcamera.api;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.config.ModConfig;\nimport net.minecraft.client.util.math.MatrixStack;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiPredicate;", "import java.util.Map;\nimport java.util.function.BiPredicate;\n\n/**\n * @see CompatExample\n */\npublic class VirtualRenderer {\n    public static final ModConfig config = ConfigFile.modConfig;\n\n    private static final Map<String, BiPredicate<Float, MatrixStack>> functionProvider = new HashMap<>();\n\n    /**\n     * @param modid    {@code mandatory}\n     * @param function {@code mandatory} turn to vanilla rendering if return true.\n     *                 {@link CompatExample#virtualRender See example here}\n     */", "    public static void register(String modid, BiPredicate<Float, MatrixStack> function) {\n        functionProvider.put(modid, function);\n    }\n\n    /**\n     * @return the value of {@link com.xtracr.realcamera.config.ModConfig.Compats#modModelPart modModelPart}\n     * option in the config\n     */\n    public static String getModelPartName() {\n        return config.getModModelPartName();\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinPlayerEntityRenderer#onSetModelPoseRETURN\n     * MixinPlayerEntityRenderer.onSetModelPoseRETURN\n     */", "    public static String getModelPartName() {\n        return config.getModModelPartName();\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinPlayerEntityRenderer#onSetModelPoseRETURN\n     * MixinPlayerEntityRenderer.onSetModelPoseRETURN\n     */\n    public static boolean shouldDisableRender(String modelPartName) {\n        ModConfig.Disable.optionalParts.add(modelPartName);\n        return RealCameraCore.isRenderingWorld && config.shouldDisableRender(modelPartName) && RealCameraCore.isActive();\n    }\n", "    public static boolean shouldDisableRender(String modelPartName) {\n        ModConfig.Disable.optionalParts.add(modelPartName);\n        return RealCameraCore.isRenderingWorld && config.shouldDisableRender(modelPartName) && RealCameraCore.isActive();\n    }\n\n    public static boolean virtualRender(float tickDelta, MatrixStack matrixStack) {\n        return functionProvider.get(config.getModelModID()).test(tickDelta, matrixStack);\n    }\n\n    public static String[] getModidList() {\n        return functionProvider.keySet().toArray(new String[functionProvider.size()]);\n    }\n}\n", "    public static String[] getModidList() {\n        return functionProvider.keySet().toArray(new String[functionProvider.size()]);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/com/xtracr/realcamera/RealCameraFabric.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;\nimport net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;\nimport net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;\n\n@Environment(EnvType.CLIENT)\npublic class RealCameraFabric implements ClientModInitializer {\n    @Override", "\n@Environment(EnvType.CLIENT)\npublic class RealCameraFabric implements ClientModInitializer {\n    @Override\n    public void onInitializeClient() {\n        RealCamera.setup();\n\n        ClientTickEvents.END_CLIENT_TICK.register(KeyBindings::handle);\n        WorldRenderEvents.START.register(EventHandler::onWorldRenderStart);\n        WorldRenderEvents.END.register(context -> RealCameraCore.isRenderingWorld = false);\n\n        KeyBindingHelper.registerKeyBinding(KeyBindings.TOGGLE_PERSPECTIVE);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.TOGGLE_ADJUST_MODE);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.TOGGLE_CAMERA_MODE);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_UP);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_DOWN);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_BACK);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_FRONT);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_LEFT);\n        KeyBindingHelper.registerKeyBinding(KeyBindings.ADJUST_RIGHT);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/com/xtracr/realcamera/EventHandler.java", "chunked_list": ["package com.xtracr.realcamera;\n\nimport com.xtracr.realcamera.config.ConfigFile;\nimport com.xtracr.realcamera.utils.CrosshairUtils;\nimport net.fabricmc.fabric.api.client.rendering.v1.WorldRenderContext;\nimport net.minecraft.client.MinecraftClient;\n\npublic class EventHandler {\n    public static void onWorldRenderStart(WorldRenderContext context) {\n        RealCameraCore.isRenderingWorld = true;\n        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            CrosshairUtils.update(MinecraftClient.getInstance(), context.camera(),\n                    context.matrixStack().peek().getPositionMatrix(), context.projectionMatrix());\n        }\n    }\n}\n", "    public static void onWorldRenderStart(WorldRenderContext context) {\n        RealCameraCore.isRenderingWorld = true;\n        if (ConfigFile.modConfig.isCrosshairDynamic() && RealCameraCore.isActive()) {\n            CrosshairUtils.update(MinecraftClient.getInstance(), context.camera(),\n                    context.matrixStack().peek().getPositionMatrix(), context.projectionMatrix());\n        }\n    }\n}\n"]}
{"filename": "fabric/src/main/java/com/xtracr/realcamera/mixins/GameRendererEvents.java", "chunked_list": ["package com.xtracr.realcamera.mixins;\n\nimport com.xtracr.realcamera.RealCameraCore;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.render.Camera;\nimport net.minecraft.client.render.GameRenderer;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.util.math.RotationAxis;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;", "import org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(GameRenderer.class)\npublic abstract class GameRendererEvents {\n    @Shadow\n    @Final MinecraftClient client;\n    @Shadow\n    @Final private Camera camera;\n\n    @Inject(method = \"renderWorld\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/render/Camera;update(Lnet/minecraft/world/BlockView;Lnet/minecraft/entity/Entity;ZZF)V\",\n            shift = At.Shift.AFTER))\n    private void onAfterCameraUpdate(float tickDelta, long limitTime, MatrixStack matrixStack, CallbackInfo cInfo) {", "public abstract class GameRendererEvents {\n    @Shadow\n    @Final MinecraftClient client;\n    @Shadow\n    @Final private Camera camera;\n\n    @Inject(method = \"renderWorld\", at = @At(value = \"INVOKE\",\n            target = \"Lnet/minecraft/client/render/Camera;update(Lnet/minecraft/world/BlockView;Lnet/minecraft/entity/Entity;ZZF)V\",\n            shift = At.Shift.AFTER))\n    private void onAfterCameraUpdate(float tickDelta, long limitTime, MatrixStack matrixStack, CallbackInfo cInfo) {\n        if (RealCameraCore.isActive()) {\n            RealCameraCore.updateCamera(camera, client, tickDelta);\n            matrixStack.multiply(RotationAxis.POSITIVE_Z.rotationDegrees(RealCameraCore.getRoll()));\n        }\n    }\n}\n", "        if (RealCameraCore.isActive()) {\n            RealCameraCore.updateCamera(camera, client, tickDelta);\n            matrixStack.multiply(RotationAxis.POSITIVE_Z.rotationDegrees(RealCameraCore.getRoll()));\n        }\n    }\n}\n"]}
{"filename": "fabric/src/main/java/com/xtracr/realcamera/config/RealCameraMenu.java", "chunked_list": ["package com.xtracr.realcamera.config;\n\nimport com.terraformersmc.modmenu.api.ConfigScreenFactory;\nimport com.terraformersmc.modmenu.api.ModMenuApi;\n\npublic class RealCameraMenu implements ModMenuApi {\n    @Override\n    public ConfigScreenFactory<?> getModConfigScreenFactory() {\n        return ConfigScreen::create;\n    }\n}\n"]}
