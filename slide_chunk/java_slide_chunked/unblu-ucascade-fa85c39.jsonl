{"filename": "src/test/java/ResetTestExampleFilesMain.java", "chunked_list": ["import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\nimport static com.github.tomakehurst.wiremock.client.WireMock.post;\nimport static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;", "import java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\n", "import java.util.Objects;\n\nimport org.gitlab4j.api.Constants.StateEvent;\nimport org.gitlab4j.api.GitLabApi;\nimport org.gitlab4j.api.GitLabApiException;\nimport org.gitlab4j.api.models.AcceptMergeRequestParams;\nimport org.gitlab4j.api.models.Branch;\nimport org.gitlab4j.api.models.MergeRequest;\nimport org.gitlab4j.api.models.MergeRequestParams;\nimport org.gitlab4j.api.models.Project;", "import org.gitlab4j.api.models.MergeRequestParams;\nimport org.gitlab4j.api.models.Project;\nimport org.gitlab4j.api.models.ProjectHook;\nimport org.gitlab4j.api.models.RepositoryFile;\nimport org.gitlab4j.api.models.User;\nimport org.gitlab4j.api.models.Visibility;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.github.tomakehurst.wiremock.WireMockServer;", "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.stubbing.ServeEvent;\nimport com.github.tomakehurst.wiremock.verification.LoggedRequest;\n\npublic class ResetTestExampleFilesMain {\n\n\t//\tprivate static final String URL = \"https://gitlab.com\";\n\tprivate static final String URL = \"http://localhost:9080\";\n\t//\tprivate static final String URL = \"http://localhost:8888\";\n\tprivate static final String TOKEN = \"glpat-********************\";\n\t//private static final String HOOK_URL = \"http://localhost:9999\";\n\tprivate static final String HOOK_URL = \"https://****-****-***-***-****-****-****-****-****.eu.ngrok.io\";\n\tprivate static final String HOOK_PATH = \"/webhook\";\n\tprivate static final String PROJECT_NAME = \"test_project\";\n\tprivate static final boolean RECREATE_PROJECT = true;\n", "\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.println(\"Prepare mock server\");\n\t\tWireMockServer wireMockServer = new WireMockServer(9999);\n\t\twireMockServer.start();\n\t\twireMockServer.stubFor(\n\t\t\t\tpost(urlPathEqualTo(HOOK_PATH))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(\"{ \\\"status\\\": \\\"ok\\\"}\")));\n\n\t\ttry (GitLabApi gitLabApi = new GitLabApi(URL, TOKEN)) {\n\t\t\tUser currentUser = gitLabApi.getUserApi().getCurrentUser();\n\n\t\t\t//Prepare project:\n\t\t\tSystem.out.println(\"Prepare project\");\n\t\t\tProject project;", "\t\t\ttry {\n\t\t\t\tString projectPath = currentUser.getUsername() + \"/\" + PROJECT_NAME;\n\t\t\t\tproject = gitLabApi.getProjectApi().getProject(projectPath);\n\t\t\t\tif (RECREATE_PROJECT && project != null) {\n\t\t\t\t\tgitLabApi.getProjectApi().deleteProject(project);\n\t\t\t\t\twaitForProjectToBeDeleted(gitLabApi, projectPath);\n\t\t\t\t\tproject = null;\n\t\t\t\t}\n\t\t\t} catch (GitLabApiException e) {\n\t\t\t\tproject = null;\n\t\t\t}", "\t\t\tif (project == null) {\n\t\t\t\tProject initProject = new Project()\n\t\t\t\t\t\t.withName(PROJECT_NAME)\n\t\t\t\t\t\t.withVisibility(Visibility.PUBLIC)\n\t\t\t\t\t\t.withInitializeWithReadme(true)\n\t\t\t\t\t\t.withDefaultBranch(\"main\");\n\t\t\t\tproject = gitLabApi.getProjectApi().createProject(initProject);\n\t\t\t}\n\n\t\t\t//Initialize the repository:\n\t\t\tSystem.out.println(\"Initialize the repository\");\n\t\t\tBranch branch;", "\t\t\ttry {\n\t\t\t\tbranch = gitLabApi.getRepositoryApi().getBranch(project, \"main\");\n\t\t\t} catch (GitLabApiException e) {\n\t\t\t\tbranch = null;\n\t\t\t}\n\t\t\tif (branch == null) {\n\t\t\t\tcreateFile(gitLabApi, project, \"main\", \"test.txt\", \"This is a test\", \"Initial commit\");\n\n\t\t\t\tbranch = gitLabApi.getRepositoryApi().getBranch(project, \"main\");\n\t\t\t}\n\t\t\tString commitSha = branch.getCommit().getId();\n\n\t\t\t//Delete branches from previous run (if they exists)\n\t\t\tSystem.out.println(\"Delete branches from previous run (if they exists)\");\n\t\t\tdeleteBranch(gitLabApi, project, \"feature_branch\");\n\t\t\tdeleteBranch(gitLabApi, project, \"mr40_release/6.x.x\");\n\t\t\tdeleteBranch(gitLabApi, project, \"mr100_release/6.x.x\");\n\n\t\t\t//[WRITE RESPONSE FILE] get branch:\n\t\t\tSystem.out.println(\"Get branch -> gitlab_template_json/api/getBranchResponse.json\");\n\t\t\tstoreGetRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/getBranchResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/repository/branches/main\");\n\n\t\t\t//[WRITE RESPONSE FILE] create branch\n\t\t\tSystem.out.println(\"Create branch -> gitlab_template_json/api/createBranchResponse.json\");\n\t\t\tstorePostEmptyBodyRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/createBranchResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/repository/branches?branch=mr90_release%2F6.x.x&ref=\" + commitSha);\n\t\t\tdeleteBranch(gitLabApi, project, \"mr90_release/6.x.x\");\n\n\t\t\t//ucascade file:\n\t\t\tSystem.out.println(\"Ucascade file\");\n\t\t\tString expectedContent = Files.readString(Paths.get(\"src/test/resources/ucascade.json\"));\n\t\t\tcommitSha = ensureFileContent(gitLabApi, project, commitSha, expectedContent, \"ucascade.json\");\n\n\t\t\t//[WRITE RESPONSE FILE] get file:\n\t\t\tSystem.out.println(\"Get file -> gitlab_template_json/api/getFileFromRepository.json\");\n\t\t\tstoreGetRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/getFileFromRepository.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/repository/files/ucascade%2Ejson?ref=\" + commitSha);\n\n\t\t\t//pipeline file:\n\t\t\t// XXX\n\t\t\t// System.out.println(\"Pipeline file\");\n\t\t\t// String pipelineContent = \"\"\"\n\t\t\t// \t\tstages:\n\t\t\t// \t\t  - build\n\t\t\t//\n\t\t\t// \t\tbuild-job:\n\t\t\t// \t\t  stage: build\n\t\t\t// \t\t  script:\n\t\t\t// \t\t    - echo \"Compiling the code...\"\n\t\t\t// \t\t    - echo \"Compile complete.\"\n\t\t\t// \t\t\"\"\";\n\t\t\t// createFile(gitLabApi, project, \"main\", \".gitlab-ci.yml\", pipelineContent, \"Add pipeline file\");\n\n\t\t\t//create release/6.x.x branch\n\t\t\tSystem.out.println(\"Create release/6.x.x branch\");\n\t\t\tcreateBranch(gitLabApi, project, \"release/6.x.x\", commitSha);\n\n\t\t\t//delete all previous MRs if any?\n\t\t\tSystem.out.println(\"Delete all previous MRs if any?\");\n\t\t\tList<MergeRequest> mergeRequests = gitLabApi.getMergeRequestApi().getMergeRequests(project);", "\t\t\tfor (MergeRequest mr : mergeRequests) {\n\t\t\t\tgitLabApi.getMergeRequestApi().deleteMergeRequest(project, mr.getIid());\n\t\t\t}\n\n\t\t\tBranch featureBranch = createBranch(gitLabApi, project, \"feature_branch\", commitSha);\n\t\t\tfor (int i = 1; i < 90; i++) {\n\t\t\t\tSystem.out.println(\"Create dummy MR \" + i);\n\t\t\t\tcreateAndCloseMergeRequest(gitLabApi, project, featureBranch.getName(), \"main\", \"MR \" + i);\n\t\t\t}\n\t\t\tSystem.out.println(\"Create ucascade MR 90\");\n\t\t\tBranch mr40Branch = createBranch(gitLabApi, project, \"mr40_release/6.x.x\", commitSha);\n\t\t\tcreateFile(gitLabApi, project, mr40Branch.getName(), \"change\" + System.currentTimeMillis() + \".txt\", \"This is a test\", \"My feature\");\n\t\t\tcreateMergeRequest(gitLabApi, project, mr40Branch.getName(), \"main\", \"[ucascade-TEST] Auto MR: release/6.x.x -> main (!40)\");", "\t\t\tfor (int i = 91; i < 100; i++) {\n\t\t\t\tSystem.out.println(\"Create dummy MR \" + i);\n\t\t\t\tcreateAndCloseMergeRequest(gitLabApi, project, featureBranch.getName(), \"main\", \"MR \" + i);\n\t\t\t}\n\t\t\t//create a real merge request\n\t\t\tSystem.out.println(\"Create real MR\");\n\t\t\tBranch someFeature = createBranch(gitLabApi, project, \"some-feature\", \"release/6.x.x\");\n\t\t\tcreateFile(gitLabApi, project, someFeature.getName(), \"file\" + System.currentTimeMillis() + \".txt\", \"This is a test\", \"My feature\");\n\t\t\tMergeRequest mr100 = createMergeRequest(gitLabApi, project, someFeature.getName(), \"release/6.x.x\", \"Some feature\");\n\n\t\t\t//create a webhook receiver to catch the event coming from Gitlab:\n\t\t\tSystem.out.println(\"Create webhook receiver\");\n\t\t\tProjectHook hook = gitLabApi.getProjectApi().addHook(project, HOOK_URL + HOOK_PATH, false, false, true);\n\t\t\tThread.sleep(1000L);\n\t\t\twaitForMr(gitLabApi, project, mr100.getIid());\n\t\t\tSystem.out.println(\"Accept real MR\");\n\t\t\tAcceptMergeRequestParams acceptMergeParam = new AcceptMergeRequestParams()\n\t\t\t\t\t.withMergeCommitMessage(\"Merge commit message\")\n\t\t\t\t\t// XXX .withMergeWhenPipelineSucceeds(true)\n\t\t\t\t\t.withShouldRemoveSourceBranch(true);\n\t\t\tgitLabApi.getMergeRequestApi().acceptMergeRequest(project, mr100.getIid(), acceptMergeParam);\n\t\t\tSystem.out.println(\"Store webhook event -> gitlab_template_json/webhook/mergedMREvent.json\");\n\t\t\tLoggedRequest request = waitForRequest(wireMockServer);\n\t\t\tstoreRequest(Paths.get(\"src/test/resources/gitlab_template_json/webhook/mergedMREvent.json\"), request);\n\t\t\tgitLabApi.getProjectApi().deleteHook(hook);\n\n\t\t\t//[WRITE RESPONSE FILE] create auto merge request:\n\t\t\tSystem.out.println(\"Create auto merge request -> gitlab_template_json/api/createMRResponse.json\");\n\t\t\tcreateBranch(gitLabApi, project, \"mr100_release/6.x.x\", \"release/6.x.x\");\n\t\t\tString createMr101Content = \"\"\"\n\t\t\t\t\t{\n\t\t\t\t\t    \"target_branch\": \"main\",\n\t\t\t\t\t    \"source_branch\": \"mr100_release/6.x.x\",\n\t\t\t\t\t    \"title\": \"Automatic cascade merge request: `something` !100 --> `release/6.x.x` --> `main`\",\n\t\t\t\t\t    \"description\": ,\n\t\t\t\t\t    \"remove_source_branch\": true\n\t\t\t\t\t}\n\t\t\t\t\t\"\"\";\n\t\t\tJsonNode mr101Response = storePostRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/createMRResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/merge_requests\", createMr101Content);\n\t\t\tLong mr101Nr = mr101Response.get(\"iid\").asLong();\n\t\t\twaitForMr(gitLabApi, project, mr101Nr);\n\n\t\t\t//[WRITE RESPONSE FILE] get MR\n\t\t\tSystem.out.println(\"Get merge request -> gitlab_template_json/api/getMRResponse.json\");\n\t\t\tstoreGetRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/getMRResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/merge_requests/\" + mr101Nr);\n\n\t\t\t//[WRITE RESPONSE FILE] get open MRs\n\t\t\tSystem.out.println(\"Get open MRs -> gitlab_template_json/api/getOpenMRsResponse.json\");\n\t\t\tstoreGetRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/getOpenMRsResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/merge_requests?state=opened&per_page=96&page=1\");\n\n\t\t\t//[WRITE RESPONSE FILE] accept auto merge request\n\t\t\tSystem.out.println(\"Accept auto merge request -> gitlab_template_json/api/acceptMRResponse.json\");\n\t\t\tString accpetMr101Content = \"\"\"\n\t\t\t\t\t{\n\t\t\t\t\t    \"merge_commit_message\": \"[ucascade-TEST] Automatic merge: 'release/6.x.x' -> 'main'\",\n\t\t\t\t\t    \"should_remove_source_branch\": true\n\t\t\t\t\t}\n\t\t\t\t\t\"\"\";\n\t\t\t// XXX \"merge_when_pipeline_succeeds\": true,\n\t\t\tstorePutRequestResponse(Paths.get(\"src/test/resources/gitlab_template_json/api/acceptMRResponse.json\"), URL + \"/api/v4/projects/\" + project.getId() + \"/merge_requests/\" + mr101Nr + \"/merge\", accpetMr101Content);\n\n\t\t\tSystem.out.println(\"DONE\");\n\t\t}\n\t}\n\n\tprivate static void waitForMr(GitLabApi gitLabApi, Project project, Long mrIid) throws InterruptedException, GitLabApiException {\n\t\tint countDown = 30;\n\t\tMergeRequest mergeRequest = null;\n\t\tdo {\n\t\t\tThread.sleep(1000L);\n\t\t\tmergeRequest = gitLabApi.getMergeRequestApi().getMergeRequest(project, mrIid);", "\t\t} while (mergeRequest.getDetailedMergeStatus().equals(\"checking\") && countDown-- > 0);\n\t\tif (!mergeRequest.getDetailedMergeStatus().equals(\"mergeable\")) {\n\t\t\tthrow new IllegalStateException(\"Wrong detailed_merge_status for MR: \" + mergeRequest);\n\t\t}\n\t}\n\n\tprivate static void waitForProjectToBeDeleted(GitLabApi gitLabApi, String projectPath) throws InterruptedException, GitLabApiException {\n\t\tint countDown = 30;\n\t\tProject project = null;\n\t\tdo {\n\t\t\tThread.sleep(1000L);\n\t\t\tproject = gitLabApi.getProjectApi().getProject(projectPath);", "\t\t} while (project != null && countDown-- > 0);\n\t\tif (project != null) {\n\t\t\tthrow new IllegalStateException(\"Project can not be deleted\");\n\t\t}\n\t}\n\n\tprivate static LoggedRequest waitForRequest(WireMockServer wireMockServer) throws InterruptedException {\n\t\tint countDown = 30;\n\t\tList<ServeEvent> allServeEvents = List.of();\n\t\tdo {\n\t\t\tThread.sleep(1000L);\n\t\t\tallServeEvents = wireMockServer.getAllServeEvents();", "\t\t} while (allServeEvents.isEmpty() && countDown-- > 0);\n\t\tif (allServeEvents.size() != 1) {\n\t\t\tthrow new IllegalStateException(\"Expecting 1 request, got: \" + allServeEvents.size());\n\t\t}\n\t\treturn allServeEvents.get(0).getRequest();\n\t}\n\n\tprivate static void createFile(GitLabApi gitLabApi, Project project, String branchName, String filePath, String content, String commitMessage) throws GitLabApiException {\n\t\tRepositoryFile file = new RepositoryFile();\n\t\tfile.setContent(content);\n\t\tfile.setFilePath(filePath);\n\t\tgitLabApi.getRepositoryFileApi().createFile(project, file, branchName, commitMessage);\n\t}\n\n\tprivate static void createAndCloseMergeRequest(GitLabApi gitLabApi, Project project, String sourceBranch, String targetBranch, String title) throws GitLabApiException {\n\t\tMergeRequest mr = createMergeRequest(gitLabApi, project, sourceBranch, targetBranch, title);\n\n\t\tMergeRequestParams closeParams = new MergeRequestParams()\n\t\t\t\t.withStateEvent(StateEvent.CLOSE);\n\t\tgitLabApi.getMergeRequestApi().updateMergeRequest(project, mr.getIid(), closeParams);\n\n\t}\n\n\tprivate static MergeRequest createMergeRequest(GitLabApi gitLabApi, Project project, String sourceBranch, String targetBranch, String title) throws GitLabApiException {\n\t\tMergeRequestParams mrParams = new MergeRequestParams()\n\t\t\t\t.withSourceBranch(sourceBranch)\n\t\t\t\t.withTargetBranch(targetBranch)\n\t\t\t\t.withTitle(title)\n\t\t\t\t.withDescription(\"A dummy pr\")\n\t\t\t\t.withRemoveSourceBranch(true);\n\t\treturn gitLabApi.getMergeRequestApi().createMergeRequest(project, mrParams);\n\t}\n\n\tprivate static Branch createBranch(GitLabApi gitLabApi, Project project, String branchName, String ref) throws GitLabApiException {\n\t\tBranch branch;", "\t\ttry {\n\t\t\tbranch = gitLabApi.getRepositoryApi().getBranch(project, branchName);\n\t\t} catch (GitLabApiException e) {\n\t\t\tbranch = gitLabApi.getRepositoryApi().createBranch(project, branchName, ref);\n\t\t}\n\t\treturn branch;\n\t}\n\n\tprivate static void deleteBranch(GitLabApi gitLabApi, Project project, String branchName) throws GitLabApiException {\n\t\ttry {\n\t\t\tgitLabApi.getRepositoryApi().deleteBranch(project, branchName);\n\t\t} catch (GitLabApiException e) {\n\t\t\t//Nothing to do\n\t\t}\n\t}\n\n\tprivate static String ensureFileContent(GitLabApi gitLabApi, Project project, String commitSha, String expectedContent, String filePath) throws GitLabApiException {\n\t\tString fileContent;", "\t\ttry {\n\t\t\tgitLabApi.getRepositoryApi().deleteBranch(project, branchName);\n\t\t} catch (GitLabApiException e) {\n\t\t\t//Nothing to do\n\t\t}\n\t}\n\n\tprivate static String ensureFileContent(GitLabApi gitLabApi, Project project, String commitSha, String expectedContent, String filePath) throws GitLabApiException {\n\t\tString fileContent;\n\t\ttry {\n\t\t\tRepositoryFile ucascadeFile = gitLabApi.getRepositoryFileApi().getFile(project, filePath, commitSha);\n\t\t\tfileContent = new String(Base64.getDecoder().decode(ucascadeFile.getContent()));\n\t\t} catch (GitLabApiException e) {\n\t\t\tfileContent = null;\n\t\t}", "\t\ttry {\n\t\t\tRepositoryFile ucascadeFile = gitLabApi.getRepositoryFileApi().getFile(project, filePath, commitSha);\n\t\t\tfileContent = new String(Base64.getDecoder().decode(ucascadeFile.getContent()));\n\t\t} catch (GitLabApiException e) {\n\t\t\tfileContent = null;\n\t\t}\n\t\tif (fileContent == null || !Objects.equals(fileContent, expectedContent)) {\n\t\t\tRepositoryFile file = new RepositoryFile();\n\t\t\tfile.setContent(expectedContent);\n\t\t\tfile.setFilePath(filePath);\n\t\t\tif (fileContent == null) {\n\t\t\t\tgitLabApi.getRepositoryFileApi().createFile(project, file, \"main\", \"Create '\" + filePath + \"' file\");\n\t\t\t\t//the response does not contains the commit ref, query the branch again\n\t\t\t\tBranch branch = gitLabApi.getRepositoryApi().getBranch(project, \"main\");\n\t\t\t\treturn branch.getCommit().getId();\n\t\t\t} else {\n\t\t\t\tRepositoryFile f = gitLabApi.getRepositoryFileApi().updateFile(project, file, \"main\", \"Update '\" + file + \"' file\");\n\t\t\t\treturn f.getRef();\n\t\t\t}\n\t\t}\n\t\treturn commitSha;\n\t}\n\n\tprivate static JsonNode storeGetRequestResponse(Path file, String url) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.GET()\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"get\", request);\n\t}\n\n\tprivate static JsonNode storePostEmptyBodyRequestResponse(Path file, String url) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.POST(BodyPublishers.noBody())\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storePostRequestResponse(Path file, String url, String body) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.POST(BodyPublishers.ofString(body))\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storePutRequestResponse(Path file, String url, String body) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.PUT(BodyPublishers.ofString(body))\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storeRequestResponse(Path file, String url, String method, HttpRequest request) throws Exception {\n\t\tHttpClient client = HttpClient.newHttpClient();\n\n\t\tHttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n\n\t\tString content = response.body();\n\t\treturn storeJsonFile(file, content);\n\t}\n\n\tprivate static void storeRequest(Path file, LoggedRequest request) throws IOException {\n\t\tstoreJsonFile(file, request.getBodyAsString());\n\t}\n\n\tprivate static JsonNode storeJsonFile(Path file, String content) throws IOException {\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tJsonNode jsonNode = mapper.readTree(content);\n\t\tString json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonNode);\n\t\tjson = json.replaceAll(\"\\\"project_id\\\" : \\\\d+,\", \"\\\"project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"source_project_id\\\" : \\\\d+,\", \"\\\"source_project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"target_project_id\\\" : \\\\d+,\", \"\\\"target_project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"id\\\" : \\\\d+,\", \"\\\"id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"merge_commit_sha\\\" : \\\"[^\\\"]+\\\",\", \"\\\"merge_commit_sha\\\" : \\\"e819d39ed37c6d4b8e700b9e7f34c74c099c163b\\\",\");\n\t\tFiles.writeString(file, json);\n\t\treturn jsonNode;\n\t}\n}\n", "\t\t\tif (fileContent == null) {\n\t\t\t\tgitLabApi.getRepositoryFileApi().createFile(project, file, \"main\", \"Create '\" + filePath + \"' file\");\n\t\t\t\t//the response does not contains the commit ref, query the branch again\n\t\t\t\tBranch branch = gitLabApi.getRepositoryApi().getBranch(project, \"main\");\n\t\t\t\treturn branch.getCommit().getId();\n\t\t\t} else {\n\t\t\t\tRepositoryFile f = gitLabApi.getRepositoryFileApi().updateFile(project, file, \"main\", \"Update '\" + file + \"' file\");\n\t\t\t\treturn f.getRef();\n\t\t\t}\n\t\t}\n\t\treturn commitSha;\n\t}\n\n\tprivate static JsonNode storeGetRequestResponse(Path file, String url) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.GET()\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"get\", request);\n\t}\n\n\tprivate static JsonNode storePostEmptyBodyRequestResponse(Path file, String url) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.POST(BodyPublishers.noBody())\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storePostRequestResponse(Path file, String url, String body) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.POST(BodyPublishers.ofString(body))\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storePutRequestResponse(Path file, String url, String body) throws Exception {\n\t\tHttpRequest request = HttpRequest.newBuilder()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"PRIVATE-TOKEN\", TOKEN)\n\t\t\t\t.uri(new URI(url))\n\t\t\t\t.PUT(BodyPublishers.ofString(body))\n\t\t\t\t.build();\n\n\t\treturn storeRequestResponse(file, url, \"post\", request);\n\t}\n\n\tprivate static JsonNode storeRequestResponse(Path file, String url, String method, HttpRequest request) throws Exception {\n\t\tHttpClient client = HttpClient.newHttpClient();\n\n\t\tHttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n\n\t\tString content = response.body();\n\t\treturn storeJsonFile(file, content);\n\t}\n\n\tprivate static void storeRequest(Path file, LoggedRequest request) throws IOException {\n\t\tstoreJsonFile(file, request.getBodyAsString());\n\t}\n\n\tprivate static JsonNode storeJsonFile(Path file, String content) throws IOException {\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tJsonNode jsonNode = mapper.readTree(content);\n\t\tString json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonNode);\n\t\tjson = json.replaceAll(\"\\\"project_id\\\" : \\\\d+,\", \"\\\"project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"source_project_id\\\" : \\\\d+,\", \"\\\"source_project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"target_project_id\\\" : \\\\d+,\", \"\\\"target_project_id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"id\\\" : \\\\d+,\", \"\\\"id\\\" : 1,\");\n\t\tjson = json.replaceAll(\"\\\"merge_commit_sha\\\" : \\\"[^\\\"]+\\\",\", \"\\\"merge_commit_sha\\\" : \\\"e819d39ed37c6d4b8e700b9e7f34c74c099c163b\\\",\");\n\t\tFiles.writeString(file, json);\n\t\treturn jsonNode;\n\t}\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/WireMockGitlabProxy.java", "chunked_list": ["package com.unblu.ucascade;\n\nimport static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;\n\nimport java.util.Collections;\nimport java.util.Map;\n\nimport com.github.tomakehurst.wiremock.WireMockServer;\n\nimport io.quarkus.test.common.QuarkusTestResourceLifecycleManager;", "\nimport io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n\npublic class WireMockGitlabProxy implements QuarkusTestResourceLifecycleManager {\n\n\tfinal static String API_PREFIX = \"/api/v4/\";\n\n\tWireMockServer wireMockServer;\n\n\t@Override\n\tpublic Map<String, String> start() {\n\t\twireMockServer = new WireMockServer(options().dynamicPort());\n\t\twireMockServer.start();\n\n\t\tSystem.out.println(\"WireMock server: \" + wireMockServer.baseUrl());\n\t\treturn Collections.singletonMap(\"gitlab.host\", wireMockServer.baseUrl());\n\t}\n\n\t@Override", "\tpublic synchronized void stop() {\n\t\tif (wireMockServer != null) {\n\t\t\twireMockServer.stop();\n\t\t\twireMockServer = null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void inject(TestInjector testInjector) {\n\t\ttestInjector.injectIntoFields(\n\t\t\t\twireMockServer,\n\t\t\t\tnew TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n\t}\n\n}\n", "\tpublic void inject(TestInjector testInjector) {\n\t\ttestInjector.injectIntoFields(\n\t\t\t\twireMockServer,\n\t\t\t\tnew TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n\t}\n\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/UcascadeTest.java", "chunked_list": ["package com.unblu.ucascade;\n\nimport static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\nimport static com.github.tomakehurst.wiremock.client.WireMock.containing;\nimport static com.github.tomakehurst.wiremock.client.WireMock.delete;\nimport static com.github.tomakehurst.wiremock.client.WireMock.get;\nimport static com.github.tomakehurst.wiremock.client.WireMock.post;\nimport static com.github.tomakehurst.wiremock.client.WireMock.put;\nimport static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\nimport static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;", "import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\nimport static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.Matchers.endsWith;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.hamcrest.Matchers.startsWith;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeUnit;\n\nimport javax.ws.rs.core.Response;\n\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\nimport org.gitlab4j.api.GitLabApiException;\nimport org.gitlab4j.api.models.MergeRequest;\nimport org.gitlab4j.api.utils.JacksonJson;\nimport org.gitlab4j.api.utils.UrlEncoder;\nimport org.junit.jupiter.api.Assertions;", "import org.gitlab4j.api.utils.UrlEncoder;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.client.WireMock;", "import com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.client.WireMock;\nimport com.github.tomakehurst.wiremock.stubbing.ServeEvent;\nimport com.github.tomakehurst.wiremock.stubbing.StubMapping;\nimport com.unblu.ucascade.util.GitlabMockUtil;\nimport com.unblu.ucascade.util.GitlabMockUtil.GitlabAction;\n\nimport controller.model.MergeRequestSimple;\nimport controller.model.MergeRequestUcascadeState;\nimport io.quarkus.test.common.QuarkusTestResource;", "import controller.model.MergeRequestUcascadeState;\nimport io.quarkus.test.common.QuarkusTestResource;\nimport io.quarkus.test.junit.QuarkusTest;\nimport service.GitLabService;\n\n@QuarkusTest\n@QuarkusTestResource(WireMockGitlabProxy.class)\nclass UcascadeTest {\n\n\tfinal static String API_PREFIX = \"/api/v4/\";", "\n\tfinal static String API_PREFIX = \"/api/v4/\";\n\tfinal static String API_AUTH_KEY_NAME = \"PRIVATE-TOKEN\";\n\n\t@InjectWireMock\n\tWireMockServer wireMockServer;\n\n\t@ConfigProperty(name = \"gitlab.api.token\")\n\tString apiToken;\n\t@ConfigProperty(name = \"gitlab.api.token.approver\")", "\tString apiToken;\n\t@ConfigProperty(name = \"gitlab.api.token.approver\")\n\tOptional<String> apiTokenApprover;\n\n\tString branchModelContent;\n\n\t@BeforeEach\n\tvoid init() throws IOException {\n\t\twireMockServer.resetAll();\n\t\tbranchModelContent = Files.readString(Path.of(\"src/test/resources/ucascade.json\"));", "\t\twireMockServer.resetAll();\n\t\tbranchModelContent = Files.readString(Path.of(\"src/test/resources/ucascade.json\"));\n\t\tsetupGetUserStub();\n\t}\n\n\t@Test\n\tvoid testEndpointRapidReturn() throws Exception {\n\t\tsetupDefaultStubs();\n\n\t\tgiven().when()", "\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"X-Gitlab-Event-UUID\", GitlabMockUtil.GITLAB_EVENT_UUID)\n\t\t\t\t.body(GitlabMockUtil.get(GitlabAction.EVENT_MR_MERGED, null))\n\t\t\t\t.post(\"/ucascade/merge-request\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.ACCEPTED.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))", "\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"build_commit\", equalTo(\"6af21ad\"))\n\t\t\t\t.body(\"build_timestamp\", equalTo(\"2022-01-01T07:21:58.378413Z\"));\n\n\t\tverifyRequests(13);\n\t}\n\n\t@Test", "\n\t@Test\n\tvoid testEndpointBlocking() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'\n\t\t// input is the GitLab event JSON\n\t\t// expect to create an auto-merge request: !101\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\t\tString expectedDescription = \"Automatic cascade merge request: \" + \"`something` !\" + (mrNumber - 1) + \" --> `release/6.x.x` --> `main`\";", "\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\t\tString expectedDescription = \"Automatic cascade merge request: \" + \"`something` !\" + (mrNumber - 1) + \" --> `release/6.x.x` --> `main`\";\n\n\t\tsetupDefaultStubs();\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"X-Gitlab-Event-UUID\", GitlabMockUtil.GITLAB_EVENT_UUID)\n\t\t\t\t.body(GitlabMockUtil.get(GitlabAction.EVENT_MR_MERGED, null))\n\t\t\t\t.post(\"/ucascade/merge-request-blocking\")", "\t\t\t\t.body(GitlabMockUtil.get(GitlabAction.EVENT_MR_MERGED, null))\n\t\t\t\t.post(\"/ucascade/merge-request-blocking\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"build_commit\", equalTo(\"6af21ad\"))\n\t\t\t\t.body(\"build_timestamp\", equalTo(\"2022-01-01T07:21:58.378413Z\"))\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))", "\t\t\t\t.body(\"build_timestamp\", equalTo(\"2022-01-01T07:21:58.378413Z\"))\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.description\", equalTo(expectedDescription))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))\n\t\t\t\t.body(\"created_auto_mr.source_branch\", equalTo(\"mr100_release/6.x.x\"))\n\t\t\t\t.body(\"created_auto_mr.target_branch\", equalTo(nextMainBranch))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(13);", "\n\t\tverifyRequests(13);\n\t}\n\n\t@Test\n\tvoid testSuccessCaseMergeEvent() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'\n\t\t// input is using the replay endpoint\n\t\t// expect to create an auto-merge request: !101\n\t\tLong mrNumber = 101L;", "\t\t// expect to create an auto-merge request: !101\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\t\tString expectedDescription = \"Automatic cascade merge request: \" + \"`something` !\" + (mrNumber - 1) + \" --> `release/6.x.x` --> `main`\";\n\n\t\tsetupDefaultStubs();\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()", "\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))", "\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.description\", equalTo(expectedDescription))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))\n\t\t\t\t.body(\"created_auto_mr.source_branch\", equalTo(\"mr100_release/6.x.x\"))\n\t\t\t\t.body(\"created_auto_mr.target_branch\", equalTo(nextMainBranch))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());", "\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(13);\n\t}\n\n\t@Test\n\tvoid testSuccessCaseCloseEvent() throws Exception {\n\t\t// corresponds to the close event of MR !100 automatically created branch targeting branch 'main'\n\t\t// input is using the replay endpoint", "\t\t// corresponds to the close event of MR !100 automatically created branch targeting branch 'main'\n\t\t// input is using the replay endpoint\n\t\t// expect to delete the source branch of MR !100 and to merge existing MRs between the same source/target branches\n\t\tLong mrNumber = 100L;\n\t\tString branchToDelete = \"mr99_release/6.x.x\";\n\n\t\t//\t\tsetupDefaultStubs();\n\t\tsetupDeleteBranchStubOk(GitlabMockUtil.PROJECT_ID, branchToDelete);\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, mrNumber, GitlabMockUtil.USER_ID, branchToDelete, GitlabMockUtil.DEFAULT_TARGET_BRANCH, \"closed\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_CLOSE_ACTION, GitlabMockUtil.GITLAB_EVENT_UUID);\n", "\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, mrNumber, GitlabMockUtil.USER_ID, branchToDelete, GitlabMockUtil.DEFAULT_TARGET_BRANCH, \"closed\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_CLOSE_ACTION, GitlabMockUtil.GITLAB_EVENT_UUID);\n\n\t\tLong existingOpenMrNr = 90L;\n\t\tsetupGetOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, existingOpenMrNr, true);\n\t\tsetupAcceptMergeRequestStub(GitlabMockUtil.PROJECT_ID, existingOpenMrNr, Map.of(\"iid\", \"\" + existingOpenMrNr), true, true);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, existingOpenMrNr, null);\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")", "\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged.mr_number\", equalTo(existingOpenMrNr.intValue()))", "\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged.mr_number\", equalTo(existingOpenMrNr.intValue()))\n\t\t\t\t.body(\"previous_auto_mr_merged.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", equalTo(branchToDelete));\n\n\t\tverifyRequests(5);\n\t}\n\n\tprivate void setupDefaultStubs() {", "\n\tprivate void setupDefaultStubs() {\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);", "\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tsetupAcceptMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null, true, true);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tcustomProperties = Map.of(\"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, (mrNumber - 1), customProperties);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, true);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);", "\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, true);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\t}\n\n\t@Test\n\tvoid testSuccessCaseNoPipelineConfigured() throws Exception {\n\t\t// when no pipelines are configured for this MR,\n\t\t// the merge_when_pipeline_succeeds flag must be set to false.\n\t\t// expect to create an auto-merge request: !101 and to merge it directly without waiting for pipelines", "\t\t// the merge_when_pipeline_succeeds flag must be set to false.\n\t\t// expect to create an auto-merge request: !101 and to merge it directly without waiting for pipelines\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");", "\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tsetupAcceptMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null, false, true);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tcustomProperties = Map.of(\"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, (mrNumber - 1), customProperties);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, false);", "\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, (mrNumber - 1), customProperties);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, false);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")", "\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))", "\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))\n\t\t\t\t.body(\"created_auto_mr.source_branch\", equalTo(\"mr100_release/6.x.x\"))\n\t\t\t\t.body(\"created_auto_mr.target_branch\", equalTo(nextMainBranch))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(13);\n\t}\n", "\t}\n\n\t@Test\n\tvoid testFollowUpCascade() throws Exception {\n\t\t// corresponds to the merge event of auto merge-request !100 from the 'mr99_release/5.x.x' branch targeting branch 'release/6.x.x'\n\t\t// expect to create an auto-merge request: !101\n\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";", "\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\n\t\tLong projectId = 2345L;\n\t\tsetupCreateBranchStub(projectId, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(projectId, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(projectId);\n\t\tsetupDeleteBranchStubNotFound(projectId, \"mr99_release/5.x.x\");\n\t\tMap<String, Object> projectIdProperties = Map.of(\"project_id\", \"\" + projectId);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\", \"project_id\", \"\" + projectId);", "\t\tMap<String, Object> projectIdProperties = Map.of(\"project_id\", \"\" + projectId);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\", \"project_id\", \"\" + projectId);\n\t\tsetupCreateMergeRequestStub(projectId, customProperties);\n\t\tsetupAcceptMergeRequestStub(projectId, mrNumber, projectIdProperties, true, true);\n\t\tsetupApproveMergeRequestStub(projectId, mrNumber, projectIdProperties);\n\t\tsetupGetMergeRequestApprovalsStub(projectId, mrNumber, null);\n\t\tsetupGetMergeRequestStub(projectId, mrNumber, projectIdProperties);\n\t\tcustomProperties = Map.of(\"project_id\", \"\" + projectId, \"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(projectId, (mrNumber - 1), customProperties);\n\t\tsetupGetMRPipelinesRequestStub(projectId, mrNumber, true);", "\t\tsetupGetMergeRequestStub(projectId, (mrNumber - 1), customProperties);\n\t\tsetupGetMRPipelinesRequestStub(projectId, mrNumber, true);\n\t\tsetupGetFileFromRepositoryRequestStub(projectId, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(projectId, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(projectId, 100L, GitlabMockUtil.USER_ID, \"mr99_release/5.x.x\", \"release/6.x.x\", \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, \"event-93484\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)", "\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(\"event-93484\"))\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.project_id\", equalTo(projectId.intValue()))", "\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.project_id\", equalTo(projectId.intValue()))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))\n\t\t\t\t.body(\"created_auto_mr.source_branch\", equalTo(\"mr100_release/6.x.x\"))\n\t\t\t\t.body(\"created_auto_mr.target_branch\", equalTo(nextMainBranch))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(14);\n\t}", "\t\tverifyRequests(14);\n\t}\n\n\t@Test\n\tvoid testAlreadyExistingMR() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'\n\t\t// there is already an auto merge-request between 'release/6.x.x' and 'main'\n\t\t// expect to create an auto-merge request: !101, do not merge it\n\n\t\tLong mrNumber = 101L;", "\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString expectedTitle = \"[ucascade-TEST] Auto MR: release/6.x.x -> \" + nextMainBranch + \" (!100)\";\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);", "\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tcustomProperties = Map.of(\"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber - 1, customProperties);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n", "\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))", "\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.title\", equalTo(expectedTitle))\n\t\t\t\t.body(\"created_auto_mr.mr_number\", equalTo(mrNumber.intValue()))\n\t\t\t\t.body(\"created_auto_mr.source_branch\", equalTo(\"mr100_release/6.x.x\"))\n\t\t\t\t.body(\"created_auto_mr.target_branch\", equalTo(nextMainBranch))\n\t\t\t\t.body(\"created_auto_mr.detailed_merge_status\", equalTo(\"checking\"))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_CONCURRENT_MRS.name()))", "\t\t\t\t.body(\"created_auto_mr.detailed_merge_status\", equalTo(\"checking\"))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_CONCURRENT_MRS.name()))\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(9);\n\t}\n\n\t@Test\n\tvoid testMRCannotBeMergedConflicts() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'", "\tvoid testMRCannotBeMergedConflicts() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'\n\t\t// expect to create an auto-merge request: !101, do not merge it because of the conflicts\n\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);", "\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tMap<String, Object> mrCustomProperties = Map.of(\n\t\t\t\t\"title\", \"\\\"[ucascade] Auto MR: release/6.x.x -> main (!100)\\\"\",\n\t\t\t\t\"detailed_merge_status\", \"\\\"broken_status\\\"\",\n\t\t\t\t\"has_conflicts\", true);", "\t\t\t\t\"detailed_merge_status\", \"\\\"broken_status\\\"\",\n\t\t\t\t\"has_conflicts\", true);\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, mrCustomProperties);\n\t\tmrCustomProperties = Map.of(\n\t\t\t\t\"iid\", \"100\",\n\t\t\t\t\"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, 100L, mrCustomProperties);\n\t\tsetupUpdateMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);", "\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()", "\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.detailed_merge_status\", equalTo(\"broken_status\"))\n\t\t\t\t.body(\"created_auto_mr.has_conflicts\", equalTo(true))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_CONFLICTS.name()))", "\t\t\t\t.body(\"created_auto_mr.has_conflicts\", equalTo(true))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_CONFLICTS.name()))\n\t\t\t\t.body(\"created_auto_mr.assignee_ids\", equalTo(List.of(987, 988))) // the merge_user + assignee of the previous MR\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(13);\n\t}\n\n\t@Test\n\tvoid testMRCannotBeMergedUnknownReason() throws Exception {", "\t@Test\n\tvoid testMRCannotBeMergedUnknownReason() throws Exception {\n\t\t// corresponds to the merge event of MR !100 feature branch targeting branch 'release/6.x.x'\n\t\t// expect to create an auto-merge request: !101, do not merge it because of unknown reason/unrecognized merge_status\n\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);", "\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, \"mr100_release/6.x.x\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tMap<String, Object> mrCustomProperties = Map.of(\n\t\t\t\t\"title\", \"\\\"[ucascade] Auto MR: release/6.x.x -> main (!100)\\\"\",\n\t\t\t\t\"detailed_merge_status\", \"\\\"policies_denied\\\"\");", "\t\t\t\t\"title\", \"\\\"[ucascade] Auto MR: release/6.x.x -> main (!100)\\\"\",\n\t\t\t\t\"detailed_merge_status\", \"\\\"policies_denied\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, mrCustomProperties);\n\t\tmrCustomProperties = Map.of(\n\t\t\t\t\"iid\", \"100\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, 100L, mrCustomProperties);\n\t\tmrCustomProperties = Map.of(\n\t\t\t\t\"detailed_merge_status\", \"\\\"policies_denied\\\"\",\n\t\t\t\t\"has_conflicts\", \"false\");\n\t\tsetupUpdateMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, mrCustomProperties);", "\t\t\t\t\"has_conflicts\", \"false\");\n\t\tsetupUpdateMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, mrCustomProperties);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)", "\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.detailed_merge_status\", equalTo(\"policies_denied\"))", "\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr.detailed_merge_status\", equalTo(\"policies_denied\"))\n\t\t\t\t.body(\"created_auto_mr.has_conflicts\", equalTo(false))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_UNKNOWN_REASON.name()))\n\t\t\t\t.body(\"created_auto_mr.assignee_ids\", equalTo(List.of(987, 988))) // the merge_user + assignee of the previous MR\n\t\t\t\t.body(\"existing_branch_deleted\", nullValue());\n\n\t\tverifyRequests(13);\n\t}\n", "\t}\n\n\t@Test\n\tvoid testDeleteBranch() throws Exception {\n\t\t// corresponds to the merge event of auto merge-request MR !102 (branch 'mr99_release/6.x.x' targeting 'main')\n\t\t// the branch 'mr99_release/6.x.x' is deleted.\n\n\t\tsetupDeleteBranchStubOk(GitlabMockUtil.PROJECT_ID, \"mr99_release/6.x.x\");\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);", "\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 102L, GitlabMockUtil.USER_ID, \"mr99_release/6.x.x\", \"main\", \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, GitlabMockUtil.GITLAB_EVENT_UUID);\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()", "\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", equalTo(\"mr99_release/6.x.x\"));\n", "\t\t\t\t.body(\"existing_branch_deleted.branch_name\", equalTo(\"mr99_release/6.x.x\"));\n\n\t\tverifyRequests(3);\n\t}\n\n\t@Test\n\tvoid testMergePreviousAutoMergeRequest() throws Exception {\n\t\t// corresponds to the merge event of auto merge-request MR !110 (branch 'mr107_release/6.x.x' targeting 'main')\n\t\t// there is already an auto merge-request between 'release/6.x.x' and 'main'\n\t\t// expect to merge the oldest from this list", "\t\t// there is already an auto merge-request between 'release/6.x.x' and 'main'\n\t\t// expect to merge the oldest from this list\n\n\t\tLong mrNr = 90L;\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupGetOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNr, true);\n\t\tsetupAcceptMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNr, Map.of(\"iid\", \"\" + mrNr), true, true);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNr, null);\n\t\tsetupDeleteBranchStubNotFound(GitlabMockUtil.PROJECT_ID, \"mr107_release/6.x.x\");", "\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNr, null);\n\t\tsetupDeleteBranchStubNotFound(GitlabMockUtil.PROJECT_ID, \"mr107_release/6.x.x\");\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 110L, GitlabMockUtil.USER_ID, \"mr107_release/6.x.x\", \"main\", \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, \"event7462\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()", "\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(\"event7462\"))\n\t\t\t\t.body(\"previous_auto_mr_merged.mr_number\", equalTo(mrNr.intValue()))\n\t\t\t\t.body(\"previous_auto_mr_merged.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());", "\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(6);\n\t}\n\n\t@Test\n\tvoid testMergeCorrectPreviousAutoMergeRequest() throws Exception {\n\t\t// corresponds to the merge event of auto merge-request MR !110 (branch 'mr107_release/6.x.x' targeting 'main')\n\t\t// there are already auto merge-requests between:", "\t\t// corresponds to the merge event of auto merge-request MR !110 (branch 'mr107_release/6.x.x' targeting 'main')\n\t\t// there are already auto merge-requests between:\n\t\t//  - 'release/6.x.x' and 'main' (!101)\n\t\t//  - 'prod' and 'main' (!90)\n\t\t// expect to merge !101: the oldest between 'release/6.x.x' and 'main'.\n\n\t\tLong mrNr = 101L;\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tMergeRequest mr90 = createMr(90L, \"mr56_prod\", \"main\", false);\n\t\tMergeRequest mr101 = createMr(mrNr, \"mr95_release/6.x.x\", \"main\", false);", "\t\tMergeRequest mr90 = createMr(90L, \"mr56_prod\", \"main\", false);\n\t\tMergeRequest mr101 = createMr(mrNr, \"mr95_release/6.x.x\", \"main\", false);\n\t\tList<MergeRequest> openMrs = List.of(mr90, mr101);\n\t\tString body = toJson(openMrs);\n\t\tsetupGetOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID, body);\n\t\tsetupGetMRPipelinesRequestStub(GitlabMockUtil.PROJECT_ID, mrNr, true);\n\t\tsetupAcceptMergeRequestStub(GitlabMockUtil.PROJECT_ID, 101L, null, true, true);\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, 101L, null);\n\t\tsetupDeleteBranchStubNotFound(GitlabMockUtil.PROJECT_ID, \"mr107_release/6.x.x\");\n", "\t\tsetupDeleteBranchStubNotFound(GitlabMockUtil.PROJECT_ID, \"mr107_release/6.x.x\");\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 110L, GitlabMockUtil.USER_ID, \"mr107_release/6.x.x\", \"main\", \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, \"event945837\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())", "\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(\"event945837\"))\n\t\t\t\t.body(\"previous_auto_mr_merged.mr_number\", equalTo(mrNr.intValue()))\n\t\t\t\t.body(\"previous_auto_mr_merged.ucascade_state\", equalTo(MergeRequestUcascadeState.MERGED.name()))\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n", "\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(6);\n\t}\n\n\t@Test\n\tvoid testDoNotMergePreviousAutoMergeRequest() throws Exception {\n\t\t// corresponds to the merge event of auto merge-request MR !110 (branch 'mr107_release/6.x.x' targeting 'main')\n\t\t// there are already auto merge-requests between 'release/6.x.x' and 'main': !101 and !90\n\t\t// MR !90 has already mergeWhenPipelineSucceeds == true", "\t\t// there are already auto merge-requests between 'release/6.x.x' and 'main': !101 and !90\n\t\t// MR !90 has already mergeWhenPipelineSucceeds == true\n\t\t// expect to not merge !90 or !101 (because the flag is already set for !90)\n\n\t\tLong mrNr = 101L;\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tMergeRequest mr90 = createMr(90L, \"mr56_release/6.x.x\", \"main\", true);\n\t\tMergeRequest mr101 = createMr(mrNr, \"mr95_release/6.x.x\", \"main\", false);\n\t\tList<MergeRequest> openMrs = List.of(mr90, mr101);\n\t\tString body = toJson(openMrs);", "\t\tList<MergeRequest> openMrs = List.of(mr90, mr101);\n\t\tString body = toJson(openMrs);\n\t\tsetupGetOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID, body);\n\t\tsetupDeleteBranchStubNotFound(GitlabMockUtil.PROJECT_ID, \"mr107_release/6.x.x\");\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 110L, GitlabMockUtil.USER_ID, \"mr107_release/6.x.x\", \"main\", \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, \"event94857\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)", "\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(\"event94857\"))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())", "\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(3);\n\t}\n\n\t@Test\n\tvoid testTargetBranchNonExistent() throws Exception {\n\t\t//error because the configured branch in 'ucascade.json' does not exist", "\tvoid testTargetBranchNonExistent() throws Exception {\n\t\t//error because the configured branch in 'ucascade.json' does not exist\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tsetupGetBranchStubNotFound(GitlabMockUtil.PROJECT_ID, nextMainBranch);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\n\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 90L, GitlabMockUtil.USER_ID, GitlabMockUtil.MR_EVENT_SOURCE_BRANCH, GitlabMockUtil.MR_EVENT_TARGET_BRANCH, \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, GitlabMockUtil.GITLAB_EVENT_UUID);\n", "\t\tMergeRequestSimple mrSimple = new MergeRequestSimple(GitlabMockUtil.PROJECT_ID, 90L, GitlabMockUtil.USER_ID, GitlabMockUtil.MR_EVENT_SOURCE_BRANCH, GitlabMockUtil.MR_EVENT_TARGET_BRANCH, \"merged\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, GitlabMockUtil.MR_EVENT_MERGE_ACTION, GitlabMockUtil.GITLAB_EVENT_UUID);\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))", "\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"created_auto_mr_error\", equalTo(\"GitlabEvent: '\" + GitlabMockUtil.GITLAB_EVENT_UUID + \"' | Branch named '\" + nextMainBranch +\n\t\t\t\t\t\t\"' does not exist in project '\" + GitlabMockUtil.PROJECT_ID +\n\t\t\t\t\t\t\"'. Please check the ucascade configuration file.\"));\n\n\t\tverifyRequests(3);\n\t}\n\n\t@Test", "\n\t@Test\n\tvoid testMergeWithoutApprovals() throws Exception {\n\t\t// MR does not have all the required approvals, thus cannot be merged.\n\t\tLong mrNumber = 101L;\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\t\tString sourceBranch = \"mr100_release/6.x.x\";\n\n\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, sourceBranch, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);", "\t\tsetupCreateBranchStub(GitlabMockUtil.PROJECT_ID, sourceBranch, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, null);\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tMap<String, Object> customProperties = Map.of(\"detailed_merge_status\", \"\\\"checking\\\"\");\n\t\tsetupCreateMergeRequestStub(GitlabMockUtil.PROJECT_ID, customProperties);\n\t\tMap<String, Object> approvalsCustomProperties = Map.of(\n\t\t\t\t\"approvals_required\", \"1\",\n\t\t\t\t\"approvals_left\", \"1\");\n\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, approvalsCustomProperties);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);", "\t\tsetupGetMergeRequestApprovalsStub(GitlabMockUtil.PROJECT_ID, mrNumber, approvalsCustomProperties);\n\t\tsetupApproveMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tcustomProperties = Map.of(\"source_branch\", \"\\\"something\\\"\");\n\t\tsetupGetMergeRequestStub(GitlabMockUtil.PROJECT_ID, (mrNumber - 1), customProperties);\n\t\tsetupUpdateMergeRequestStub(GitlabMockUtil.PROJECT_ID, mrNumber, null);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, true);\n\n\t\tgiven().when()", "\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_MISSING_APPROVALS.name()));", "\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"created_auto_mr.ucascade_state\", equalTo(MergeRequestUcascadeState.NOT_MERGED_MISSING_APPROVALS.name()));\n\n\t\tverifyRequests(12);\n\t}\n\n\t@Test\n\tvoid testNoDiffBetweenBranches() throws Exception {\n\t\t// expect no auto-merge request since there are no diff between source and target branches\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;", "\t\t// expect no auto-merge request since there are no diff between source and target branches\n\t\tString nextMainBranch = GitlabMockUtil.DEFAULT_TARGET_BRANCH;\n\n\t\tsetupGetBranchStub(GitlabMockUtil.PROJECT_ID, nextMainBranch, null);\n\t\tsetupGetEmptyOpenMergeRequestStub(GitlabMockUtil.PROJECT_ID);\n\t\tsetupGetFileFromRepositoryRequestStub(GitlabMockUtil.PROJECT_ID, \"ucascade.json\", GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA);\n\t\tsetupCompareBranchesRequestStub(GitlabMockUtil.PROJECT_ID, GitlabMockUtil.MR_EVENT_MERGE_COMMIT_SHA, nextMainBranch, false);\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\n\t\tgiven().when()", "\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())", "\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(4);\n\t}\n\n\t@Test\n\tvoid testGetPrevMRFromBranchName() {", "\t@Test\n\tvoid testGetPrevMRFromBranchName() {\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123_something\"),\n\t\t\t\t123L);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123_something/1.x.x\"),\n\t\t\t\t123L);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123_something/987\"),\n\t\t\t\t123L);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123_something/mr987_else\"),\n\t\t\t\t123L);", "\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123_something/mr987_else\"),\n\t\t\t\t123L);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr_unrelated\"),\n\t\t\t\tnull);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"mr123unrelated\"),\n\t\t\t\tnull);\n\t\tAssertions.assertEquals(GitLabService.getPrevMergeRequestNumber(\"something_mr123_unrelated\"),\n\t\t\t\tnull);\n\t}\n", "\t}\n\n\t@Test\n\tvoid testFormatCascadeElement() {\n\t\tAssertions.assertEquals(\"`release/6.x.x` !123 --> \",\n\t\t\t\tGitLabService.formatCascadeElement(\"-->\", 123L, \"mr123_release/6.x.x\"));\n\t\tAssertions.assertEquals(\"`release/6.x.x` !123 --> \",\n\t\t\t\tGitLabService.formatCascadeElement(\"-->\", 123L, \"release/6.x.x\"));\n\t\tAssertions.assertEquals(\"`release/6.x.x` !123 \",\n\t\t\t\tGitLabService.formatCascadeElement(null, 123L, \"release/6.x.x\"));", "\t\tAssertions.assertEquals(\"`release/6.x.x` !123 \",\n\t\t\t\tGitLabService.formatCascadeElement(null, 123L, \"release/6.x.x\"));\n\t\tAssertions.assertEquals(\"`release/6.x.x` --> \",\n\t\t\t\tGitLabService.formatCascadeElement(\"-->\", null, \"release/6.x.x\"));\n\t}\n\n\t@Test\n\tvoid testEventIgnoredIfActionNotEqualsToMerge() throws Exception {\n\t\t// expect merge-request event to be ignored if action is not 'merge'\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();", "\t\t// expect merge-request event to be ignored if action is not 'merge'\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\t\tmrSimple.setMrAction(\"update\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())", "\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(0);", "\n\t\tverifyRequests(0);\n\t}\n\n\t@Test\n\tvoid testEventIgnoredIfStateNotEqualsToMerged() throws Exception {\n\t\t// expect merge-request event to be ignored if MR state is not 'merged'\n\t\tMergeRequestSimple mrSimple = GitlabMockUtil.createDefaultMREvent();\n\t\tmrSimple.setMrState(\"opened\");\n", "\t\tmrSimple.setMrState(\"opened\");\n\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(mrSimple)\n\t\t\t\t.post(\"/ucascade/replay\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))", "\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(GitlabMockUtil.GITLAB_EVENT_UUID))\n\t\t\t\t.body(\"previous_auto_mr_merged\", nullValue())\n\t\t\t\t.body(\"created_auto_mr\", nullValue())\n\t\t\t\t.body(\"existing_branch_deleted.branch_name\", nullValue());\n\n\t\tverifyRequests(0);\n\t}\n", "\t}\n\n\t@Test\n\tvoid testEndpointRapidReturnMalformedRequest() throws Exception {\n\t\tString json = \"\"\"\n\t\t\t\t{\n\t\t\t\t    \"foo\" : \"bar\",\n\t\t\t\t    \"baz\" : 43\n\t\t\t\t}\n\t\t\t\t\"\"\";", "\t\t\t\t}\n\t\t\t\t\"\"\";\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(json)\n\t\t\t\t.post(\"/ucascade/merge-request\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.ACCEPTED.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))", "\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", nullValue())\n\t\t\t\t.body(\"build_commit\", equalTo(\"6af21ad\"))\n\t\t\t\t.body(\"build_timestamp\", equalTo(\"2022-01-01T07:21:58.378413Z\"))\n\t\t\t\t.body(\"error\", startsWith(\"Could not resolve subtype of\"));\n\n\t\tverifyRequests(0);\n\t}\n", "\t}\n\n\t@Test\n\tvoid testInvalidEndpoint() throws Exception {\n\t\tString json = \"\"\"\n\t\t\t\t{\n\t\t\t\t    \"foo\" : \"bar\",\n\t\t\t\t    \"baz\" : 43\n\t\t\t\t}\n\t\t\t\t\"\"\";", "\t\t\t\t}\n\t\t\t\t\"\"\";\n\t\tgiven().when()\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.header(\"X-Gitlab-Event-UUID\", \"test-1289369\")\n\t\t\t\t.body(json)\n\t\t\t\t.post(\"/foo\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.ACCEPTED.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))", "\t\t\t\t.statusCode(Response.Status.ACCEPTED.getStatusCode())\n\t\t\t\t.body(startsWith(\"{\\n\"))\n\t\t\t\t.body(endsWith(\"\\n}\"))\n\t\t\t\t.body(\"gitlab_event_uuid\", equalTo(\"test-1289369\"))\n\t\t\t\t.body(\"build_commit\", equalTo(\"6af21ad\"))\n\t\t\t\t.body(\"build_timestamp\", equalTo(\"2022-01-01T07:21:58.378413Z\"))\n\t\t\t\t.body(\"error\", equalTo(\"Invalid path: /foo\"));\n\n\t\tverifyRequests(0);\n\t}", "\t\tverifyRequests(0);\n\t}\n\n\t@Test\n\tvoid testHealthLive() throws Exception {\n\t\t//make sure we get an answer from the 'quarkus-smallrye-health' module\n\t\tgiven().when()\n\t\t\t\t.get(\"/q/health/live\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())", "\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(\"status\", notNullValue())\n\t\t\t\t.body(\"checks\", notNullValue())\n\t\t\t\t.body(\"gitlab_event_uuid\", nullValue())\n\t\t\t\t.body(\"build_commit\", nullValue())\n\t\t\t\t.body(\"build_timestamp\", nullValue())\n\t\t\t\t.body(\"error\", nullValue());\n\n\t\tverifyRequests(0);", "\n\t\tverifyRequests(0);\n\t}\n\n\t@Test\n\tvoid testHealthReady() throws Exception {\n\t\t//make sure we get an answer from the 'quarkus-smallrye-health' module\n\t\tgiven().when()\n\t\t\t\t.post(\"/q/health/ready\")\n\t\t\t\t.then()", "\t\t\t\t.post(\"/q/health/ready\")\n\t\t\t\t.then()\n\t\t\t\t.statusCode(Response.Status.OK.getStatusCode())\n\t\t\t\t.body(\"status\", notNullValue())\n\t\t\t\t.body(\"checks\", notNullValue())\n\t\t\t\t.body(\"gitlab_event_uuid\", nullValue())\n\t\t\t\t.body(\"build_commit\", nullValue())\n\t\t\t\t.body(\"build_timestamp\", nullValue())\n\t\t\t\t.body(\"error\", nullValue());\n", "\t\t\t\t.body(\"error\", nullValue());\n\n\t\tverifyRequests(0);\n\t}\n\n\tprivate void verifyRequests(int expectedRequestNumber) throws InterruptedException {\n\t\tList<ServeEvent> allServeEvents = waitForRequests(expectedRequestNumber);\n\n\t\t//If getUser() was called, expect one more call:\n\t\tint expected;\n\t\tif (allServeEvents.stream().anyMatch(e -> isGetUserStub(e.getStubMapping()))) {\n\t\t\texpected = expectedRequestNumber + 1;\n\t\t} else {\n\t\t\texpected = expectedRequestNumber;\n\t\t}\n\t\tAssertions.assertEquals(expected, allServeEvents.size(), \"Number of requests to GitLab\");\n\n\t\t//Verify that all stubs where called at least once. getUser() is defined as stub, but unused if the GitLabService was already initialized for a given test\n\t\tList<StubMapping> usedStubs = allServeEvents.stream().map(e -> e.getStubMapping()).toList();\n\t\tList<StubMapping> stubMappings = wireMockServer.getStubMappings();\n\t\tList<String> unused = stubMappings.stream()\n\t\t\t\t.filter(s -> !usedStubs.contains(s))\n\t\t\t\t.filter(s -> !isGetUserStub(s))\n\t\t\t\t.map(e -> e.getRequest().toString())\n\t\t\t\t.toList();", "\t\t//If getUser() was called, expect one more call:\n\t\tint expected;\n\t\tif (allServeEvents.stream().anyMatch(e -> isGetUserStub(e.getStubMapping()))) {\n\t\t\texpected = expectedRequestNumber + 1;\n\t\t} else {\n\t\t\texpected = expectedRequestNumber;\n\t\t}\n\t\tAssertions.assertEquals(expected, allServeEvents.size(), \"Number of requests to GitLab\");\n\n\t\t//Verify that all stubs where called at least once. getUser() is defined as stub, but unused if the GitLabService was already initialized for a given test\n\t\tList<StubMapping> usedStubs = allServeEvents.stream().map(e -> e.getStubMapping()).toList();\n\t\tList<StubMapping> stubMappings = wireMockServer.getStubMappings();\n\t\tList<String> unused = stubMappings.stream()\n\t\t\t\t.filter(s -> !usedStubs.contains(s))\n\t\t\t\t.filter(s -> !isGetUserStub(s))\n\t\t\t\t.map(e -> e.getRequest().toString())\n\t\t\t\t.toList();", "\t\tif (!unused.isEmpty()) {\n\t\t\tAssertions.fail(\"Some defined stubs were not called by the GitLab client:\\n\" + unused);\n\t\t}\n\t}\n\n\tprivate List<ServeEvent> waitForRequests(int minimalNumberOfRequestsToWaitFor) throws InterruptedException {\n\t\tint countDown = 30;\n\t\tList<ServeEvent> allServeEvents = wireMockServer.getAllServeEvents();\n\t\twhile (allServeEvents.size() < minimalNumberOfRequestsToWaitFor && countDown-- > 0) {\n\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\tallServeEvents = wireMockServer.getAllServeEvents();\n\t\t}\n\t\treturn allServeEvents;\n\t}\n\n\tprivate boolean isGetUserStub(StubMapping stub) {\n\t\treturn Objects.equals(\"/api/v4/user\", stub.getRequest().getUrlPath());\n\t}\n\n\tprivate void setupCreateBranchStub(Long projectId, String branch, String ref, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tpost(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.withQueryParam(\"branch\", WireMock.equalTo(branch))\n\t\t\t\t\t\t.withQueryParam(\"ref\", WireMock.equalTo(ref))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.CREATE_BRANCH, customProperties))));\n\t}\n\n\tprivate void setupGetBranchStub(Long projectId, String branchName, Map<String, Object> customProperties) {", "\t\twhile (allServeEvents.size() < minimalNumberOfRequestsToWaitFor && countDown-- > 0) {\n\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\tallServeEvents = wireMockServer.getAllServeEvents();\n\t\t}\n\t\treturn allServeEvents;\n\t}\n\n\tprivate boolean isGetUserStub(StubMapping stub) {\n\t\treturn Objects.equals(\"/api/v4/user\", stub.getRequest().getUrlPath());\n\t}\n\n\tprivate void setupCreateBranchStub(Long projectId, String branch, String ref, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tpost(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.withQueryParam(\"branch\", WireMock.equalTo(branch))\n\t\t\t\t\t\t.withQueryParam(\"ref\", WireMock.equalTo(ref))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.CREATE_BRANCH, customProperties))));\n\t}\n\n\tprivate void setupGetBranchStub(Long projectId, String branchName, Map<String, Object> customProperties) {", "\t\ttry {\n\t\t\twireMockServer.stubFor(\n\t\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches/\" + UrlEncoder.urlEncode(branchName)))\n\t\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.GET_BRANCH, customProperties))));\n\t\t} catch (GitLabApiException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void setupGetBranchStubNotFound(Long projectId, String branchName) {", "\t\ttry {\n\t\t\twireMockServer.stubFor(\n\t\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches/\" + UrlEncoder.urlEncode(branchName)))\n\t\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t\t.withStatus(404)\n\t\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t\t.withBody(\"{\\\"message\\\":\\\"404 Branch Not Found\\\"}\")));\n\t\t} catch (GitLabApiException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void setupDeleteBranchStubNotFound(Long projectId, String branchName) {", "\t\ttry {\n\t\t\twireMockServer.stubFor(\n\t\t\t\t\tdelete(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches/\" + UrlEncoder.urlEncode(branchName)))\n\t\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t\t.withStatus(404)\n\t\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t\t.withBody(\"{\\\"message\\\":\\\"404 Branch Not Found\\\"}\")));\n\t\t} catch (GitLabApiException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void setupDeleteBranchStubOk(Long projectId, String branchName) {", "\t\ttry {\n\t\t\twireMockServer.stubFor(\n\t\t\t\t\tdelete(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/branches/\" + UrlEncoder.urlEncode(branchName)))\n\t\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t\t.withStatus(204)));\n\t\t} catch (GitLabApiException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void setupCreateMergeRequestStub(Long projectId, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tpost(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.CREATE_MR, customProperties))));\n\t}\n\n\tprivate void setupAcceptMergeRequestStub(Long projectId, Long mrId, Map<String, Object> customProperties, boolean hasPipelines, boolean hasAllApprovals) {\n\t\twireMockServer.stubFor(\n\t\t\t\tput(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId + \"/merge\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.withRequestBody(containing(\"merge_when_pipeline_succeeds=\" + hasPipelines))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withStatus(hasAllApprovals ? 200 : 405)\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(hasAllApprovals ? GitlabMockUtil.get(GitlabAction.ACCEPT_MR, customProperties) : \"{\\\"message\\\":\\\"405 Method Not Allowed\\\"}\")));\n\t}\n\n\tprivate void setupGetMergeRequestStub(Long projectId, Long mrId, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.GET_MR, customProperties))));\n\t}\n\n\tprivate void setupUpdateMergeRequestStub(Long projectId, Long mrId, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tput(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.UPDATE_MR, customProperties))));\n\t}\n\n\tprivate void setupGetEmptyOpenMergeRequestStub(Long projectId) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlMatching(API_PREFIX + \"projects/\" + projectId + \"/merge_requests\\\\?state=opened.*\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(\"[]\")));\n\t}\n\n\tprivate void setupGetOpenMergeRequestStub(Long projectId) {\n\t\tsetupGetOpenMergeRequestStub(projectId, GitlabMockUtil.get(GitlabAction.GET_OPEN_MRS, null));\n\t}\n\n\tprivate void setupGetOpenMergeRequestStub(Long projectId, String body) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlMatching(API_PREFIX + \"projects/\" + projectId + \"/merge_requests\\\\?state=opened.*\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(body)));\n\t}\n\n\tprivate void setupGetFileFromRepositoryRequestStub(Long projectId, String filePath, String ref) {", "\t\ttry {\n\t\t\twireMockServer.stubFor(\n\t\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/files/\" + UrlEncoder.urlEncode(filePath)))\n\t\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t\t.withQueryParam(\"ref\", WireMock.equalTo(ref))\n\t\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.GET_FILE, null))));\n\t\t} catch (GitLabApiException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void setupGetMRPipelinesRequestStub(Long projectId, Long mrId, boolean hasPipelines) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId + \"/pipelines\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(hasPipelines ? GitlabMockUtil.get(GitlabAction.LIST_MR_PIPELINES, null) : \"[]\")));\n\t}\n\n\tprivate void setupApproveMergeRequestStub(Long projectId, Long mrId, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tpost(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId + \"/approve\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiTokenApprover.orElseThrow(() -> new IllegalStateException(\"When no approver api token is set, an ApproveMergeRequest call is not expected\"))))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.APPROVE_MR, customProperties))));\n\t}\n\n\tprivate void setupGetMergeRequestApprovalsStub(Long projectId, Long mrId, Map<String, Object> customProperties) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/merge_requests/\" + mrId + \"/approvals\"))\n\t\t\t\t\t\t.withHeader(API_AUTH_KEY_NAME, WireMock.equalTo(apiToken))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.GET_APPROVALS, customProperties))));\n\t}\n\n\tprivate void setupCompareBranchesRequestStub(Long projectId, String from, String to, boolean hasDiff) {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"projects/\" + projectId + \"/repository/compare\"))\n\t\t\t\t\t\t.withQueryParam(\"from\", WireMock.equalTo(from))\n\t\t\t\t\t\t.withQueryParam(\"to\", WireMock.equalTo(to))\n\t\t\t\t\t\t.withQueryParam(\"straight\", WireMock.equalTo(\"true\"))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(hasDiff ? GitlabMockUtil.get(GitlabAction.COMPARE_DIFF_BRANCHES, null) : GitlabMockUtil.get(GitlabAction.COMPARE_NO_DIFF_BRANCHES, null))));\n\t}\n\n\tprivate void setupGetUserStub() {\n\t\twireMockServer.stubFor(\n\t\t\t\tget(urlPathEqualTo(API_PREFIX + \"user\"))\n\t\t\t\t\t\t.willReturn(aResponse()\n\t\t\t\t\t\t\t\t.withHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t\t\t\t\t.withBody(GitlabMockUtil.get(GitlabAction.GET_USER, null))));\n\t}\n\n\tprivate MergeRequest createMr(Long iid, String sourceBranch, String targetBranch, Boolean mergeWhenPipelineSucceeds) {\n\t\tMergeRequest mr = new MergeRequest();\n\t\tmr.setProjectId(GitlabMockUtil.PROJECT_ID);\n\t\tmr.setIid(iid);\n\t\tmr.setSourceBranch(sourceBranch);\n\t\tmr.setTargetBranch(targetBranch);\n\t\tmr.setMergeWhenPipelineSucceeds(mergeWhenPipelineSucceeds);\n\t\tmr.setDetailedMergeStatus(\"mergeable\");\n\t\treturn mr;\n\t}\n\n\tprivate String toJson(Object value) throws JsonProcessingException {\n\t\tObjectMapper mapper = new JacksonJson().getObjectMapper();\n\t\tmapper.enable(SerializationFeature.INDENT_OUTPUT);\n\t\treturn mapper.writeValueAsString(value);\n\t}\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/InjectWireMock.java", "chunked_list": ["package com.unblu.ucascade;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface InjectWireMock {", "@Target(ElementType.FIELD)\npublic @interface InjectWireMock {\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/util/JsonUtilsTest.java", "chunked_list": ["package com.unblu.ucascade.util;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\nimport org.gitlab4j.api.Constants.MergeRequestState;\nimport org.gitlab4j.api.utils.JacksonJson;\nimport org.gitlab4j.api.webhook.MergeRequestEvent;", "import org.gitlab4j.api.utils.JacksonJson;\nimport org.gitlab4j.api.webhook.MergeRequestEvent;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonMappingException;", "import com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.unblu.ucascade.util.GitlabMockUtil.GitlabAction;\n\nimport controller.model.CascadeResult;\nimport controller.model.Config;\nimport controller.model.ConfigBranches;\nimport controller.model.DeleteBranchResult;", "import controller.model.ConfigBranches;\nimport controller.model.DeleteBranchResult;\nimport controller.model.MergeRequestResult;\nimport controller.model.MergeRequestSimple;\nimport controller.model.MergeRequestUcascadeState;\nimport util.JsonUtils;\n\nclass JsonUtilsTest {\n\n\t@Test", "\n\t@Test\n\tvoid testParseConfig() throws Exception {\n\t\tConfig expected = new Config()\n\t\t\t\t.addBranch(new ConfigBranches()\n\t\t\t\t\t\t.withSourceBranchPattern(\"main/1\\\\.2\\\\.x\")\n\t\t\t\t\t\t.withTargetBranch(\"main/1.3.x\"))\n\t\t\t\t.addBranch(new ConfigBranches()\n\t\t\t\t\t\t.withSourceBranchPattern(\"main/1\\\\.3\\\\.x/[0-9]{4}\\\\.[0-9]{2}\")\n\t\t\t\t\t\t.withTargetBranch(\"main/1.3.x\"))", "\t\t\t\t\t\t.withSourceBranchPattern(\"main/1\\\\.3\\\\.x/[0-9]{4}\\\\.[0-9]{2}\")\n\t\t\t\t\t\t.withTargetBranch(\"main/1.3.x\"))\n\t\t\t\t.addBranch(new ConfigBranches()\n\t\t\t\t\t\t.withSourceBranchPattern(\"main/1\\\\.3\\\\.x\")\n\t\t\t\t\t\t.withTargetBranch(\"main/2.0.x\"))\n\t\t\t\t.addBranch(new ConfigBranches()\n\t\t\t\t\t\t.withSourceBranchPattern(\"main/2\\\\.0\\\\.x/[0-9]{4}\\\\.[0-9]{2}\")\n\t\t\t\t\t\t.withTargetBranch(\"main/2.0.x\"));\n\n\t\t// Due to https://github.com/docToolchain/docToolchain/issues/898 we need a copy inside the _documentation project because it can't access the java project", "\n\t\t// Due to https://github.com/docToolchain/docToolchain/issues/898 we need a copy inside the _documentation project because it can't access the java project\n\t\tPath file = Path.of(\"_documentation/src/docs/tech-docs/ucascade.json\");\n\n\t\t// Read the current content to see if the parser works:\n\t\tString content = Files.readString(file);\n\t\tConfig config = JsonUtils.getConfigFromString(content);\n\n\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:\n\t\tObjectMapper mapper = new ObjectMapper();", "\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tmapper.enable(SerializationFeature.INDENT_OUTPUT);\n\t\tmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\n\t\tmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\n\t\tString expectedContent = mapper.writeValueAsString(expected);\n\t\tFiles.writeString(file, expectedContent);\n\n\t\tAssertions.assertEquals(expected, config);\n\t\tAssertions.assertEquals(expectedContent, content);", "\t\tAssertions.assertEquals(expected, config);\n\t\tAssertions.assertEquals(expectedContent, content);\n\t}\n\n\t@Test\n\tvoid testParseMergeRequest() throws Exception {\n\t\tLong projectId = 23L;\n\t\tLong mrNumber = 122L;\n\t\tLong userId = 9382L;\n\t\tString sourceBranch = \"feature/1.3.x/some-change\";", "\t\tLong userId = 9382L;\n\t\tString sourceBranch = \"feature/1.3.x/some-change\";\n\t\tString targetBranch = \"main/1.3.x\";\n\t\tString mrState = MergeRequestState.MERGED.toValue();\n\t\tString mergeCommitSha = \"0c6f9d312b924bff313f60db2f269b5f4901cd95\";\n\t\tString mrAction = \"merge\";\n\n\t\tMergeRequestSimple expected = new MergeRequestSimple(projectId, mrNumber, userId, sourceBranch, targetBranch, mrState, mergeCommitSha, mrAction, \"replay-394720\");\n\n\t\t// Due to https://github.com/docToolchain/docToolchain/issues/898 we need a copy inside the _documentation project because it can't access the java project", "\n\t\t// Due to https://github.com/docToolchain/docToolchain/issues/898 we need a copy inside the _documentation project because it can't access the java project\n\t\tPath file = Path.of(\"_documentation/src/docs/tech-docs/replay.json\");\n\n\t\t// Read the current content to see if the parser works:\n\t\tString content = Files.readString(file);\n\t\tMergeRequestSimple mr = JsonUtils.getMergeRequestFromString(content);\n\n\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:\n\t\tObjectMapper mapper = new ObjectMapper();", "\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tmapper.enable(SerializationFeature.INDENT_OUTPUT);\n\t\tmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\n\t\tmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\n\t\tString expectedContent = mapper.writeValueAsString(expected);\n\t\tFiles.writeString(file, expectedContent);\n\n\t\tAssertions.assertEquals(expected, mr);\n\t\tAssertions.assertEquals(expectedContent, content);", "\t\tAssertions.assertEquals(expected, mr);\n\t\tAssertions.assertEquals(expectedContent, content);\n\t}\n\n\t@Test\n\tvoid testUcascadeNonBlockingResponseFile() throws Exception {\n\t\tCascadeResult expected = createCascadeResult();\n\t\tcheckMergeRequestResultFile(expected, CascadeResult.class, \"_documentation/src/docs/tech-docs/ucascade-non-blocking-response.json\");\n\t}\n", "\t}\n\n\t@Test\n\tvoid testUcascadeBlockingResponseFile() throws Exception {\n\t\t// corresponds to the merge event of MR !25 targeting branch main/1.3.x\n\t\t// that was an auto-merge request for MR !21 between main/1.2.x and main/1.3.x\n\t\t// branch mr21_main/1.2.x was not deleted by GitLab\n\t\t// a new cascade mr to main is created -> MR !38\n\t\t// other auto-MR open (!34) between main/1.2.x and main/1.3.x was still open (and waiting for !25 to be merged first)\n", "\t\t// other auto-MR open (!34) between main/1.2.x and main/1.3.x was still open (and waiting for !25 to be merged first)\n\n\t\tMergeRequestResult previousAutoMrMerged = new MergeRequestResult();\n\t\tpreviousAutoMrMerged.setId(34L);\n\t\tpreviousAutoMrMerged.setIid(34L);\n\t\tpreviousAutoMrMerged.setProjectId(1L);\n\t\tpreviousAutoMrMerged.setTitle(\"[ucascade] Auto MR: 'main/1.2.x' -> 'main/1.3.x' (!29)\");\n\t\tpreviousAutoMrMerged.setDescription(\"Automatic cascade merge request: `test` !29 --> `main/1.2.x` --> `main/1.3.x`\");\n\t\tpreviousAutoMrMerged.setState(\"opened\");\n\t\tpreviousAutoMrMerged.setDetailedMergeStatus(\"mergeable\");", "\t\tpreviousAutoMrMerged.setState(\"opened\");\n\t\tpreviousAutoMrMerged.setDetailedMergeStatus(\"mergeable\");\n\t\tpreviousAutoMrMerged.setHasConflicts(false);\n\t\tpreviousAutoMrMerged.setSourceBranch(\"mr29_main/1.2.x\");\n\t\tpreviousAutoMrMerged.setTargetBranch(\"main/1.3.x\");\n\t\tpreviousAutoMrMerged.setWebUrl(\"https://gitlab.example.com/root/some-project/-/merge_requests/34\");\n\t\tpreviousAutoMrMerged.setUcascadeState(MergeRequestUcascadeState.MERGED);\n\n\t\tMergeRequestResult createdAutoMr = new MergeRequestResult();\n\t\tcreatedAutoMr.setAssigneeIds(List.of(40L));", "\t\tMergeRequestResult createdAutoMr = new MergeRequestResult();\n\t\tcreatedAutoMr.setAssigneeIds(List.of(40L));\n\t\tcreatedAutoMr.setId(38L);\n\t\tcreatedAutoMr.setIid(38L);\n\t\tcreatedAutoMr.setProjectId(1L);\n\t\tcreatedAutoMr.setTitle(\"[ucascade] Auto MR: 'main/1.3.x' -> 'develop' (!25)\");\n\t\tcreatedAutoMr.setDescription(\"Automatic cascade merge request: `test` !24 --> `main/1.2.x` !25 --> `main/1.3.x` --> develop\");\n\t\tcreatedAutoMr.setState(\"opened\");\n\t\tcreatedAutoMr.setDetailedMergeStatus(\"broken_status\");\n\t\tcreatedAutoMr.setHasConflicts(true);", "\t\tcreatedAutoMr.setDetailedMergeStatus(\"broken_status\");\n\t\tcreatedAutoMr.setHasConflicts(true);\n\t\tcreatedAutoMr.setSourceBranch(\"mr25_main/1.3.x\");\n\t\tcreatedAutoMr.setTargetBranch(\"main\");\n\t\tcreatedAutoMr.setWebUrl(\"https://gitlab.example.com/root/some-project/-/merge_requests/38\");\n\t\tcreatedAutoMr.setUcascadeState(MergeRequestUcascadeState.NOT_MERGED_CONFLICTS);\n\n\t\tCascadeResult expected = new CascadeResult();\n\t\texpected.setBuildCommit(\"6af21ad\");\n\t\texpected.setBuildTimestamp(\"2022-01-01T07:21:58.378413Z\");", "\t\texpected.setBuildCommit(\"6af21ad\");\n\t\texpected.setBuildTimestamp(\"2022-01-01T07:21:58.378413Z\");\n\t\texpected.setGitlabEventUUID(\"62940263-b495-4f7e-b0e8-578c7307f13d\");\n\t\texpected.setPreviousAutoMrMerged(previousAutoMrMerged);\n\t\texpected.setCreatedAutoMr(createdAutoMr);\n\t\texpected.setExistingBranchDelete(new DeleteBranchResult(\"mr21_main/1.2.x\"));\n\n\t\tcheckMergeRequestResultFile(expected, CascadeResult.class, \"_documentation/src/docs/tech-docs/ucascade-blocking-response.json\");\n\t}\n", "\t}\n\n\tprivate CascadeResult createCascadeResult() {\n\t\tCascadeResult result = new CascadeResult();\n\t\tresult.setBuildCommit(\"6af21ad\");\n\t\tresult.setBuildTimestamp(\"2022-01-01T07:21:58.378413Z\");\n\t\tresult.setGitlabEventUUID(\"62940263-b495-4f7e-b0e8-578c7307f13d\");\n\t\treturn result;\n\t}\n", "\t}\n\n\tprivate <T> void checkMergeRequestResultFile(T expected, Class<T> cls, String filePath) throws IOException, JsonProcessingException, JsonMappingException {\n\t\t// Due to https://github.com/docToolchain/docToolchain/issues/898 we need a copy inside the _documentation project because it can't access the java project\n\t\tPath file = Path.of(filePath);\n\n\t\t// Read the current content to see if the parser works:\n\t\tString content = Files.readString(file);\n\n\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:", "\n\t\t// Update the file derived from the Java model, so that we are sure it stays up-to-date in the docs:\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tmapper.enable(SerializationFeature.INDENT_OUTPUT);\n\t\tmapper.setSerializationInclusion(Include.NON_NULL);\n\t\tT actual;\n\t\ttry {\n\t\t\tactual = mapper.readValue(content, cls);\n\t\t} catch (Exception e) {\n\t\t\tactual = null;\n\t\t}\n\t\tString expectedContent = mapper.writeValueAsString(expected);\n\t\tFiles.writeString(file, expectedContent);\n\n\t\tAssertions.assertEquals(expected, actual);\n\t\tAssertions.assertEquals(expectedContent, content);\n\t}\n\n\t@Test\n\tvoid testToSimpleEvent() throws Exception {\n\t\tString content = GitlabMockUtil.get(GitlabAction.EVENT_MR_MERGED, null);\n\t\tMergeRequestEvent mrEvent = new JacksonJson().getObjectMapper().readValue(content, MergeRequestEvent.class);\n\t\tMergeRequestSimple result = JsonUtils.toSimpleEvent(mrEvent, GitlabMockUtil.GITLAB_EVENT_UUID);\n\n\t\tMergeRequestSimple expected = GitlabMockUtil.createDefaultMREvent();\n\t\tAssertions.assertEquals(expected, result);\n\t}\n\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/util/GitlabMockUtil.java", "chunked_list": ["package com.unblu.ucascade.util;\n\nimport java.util.EnumMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport controller.model.MergeRequestSimple;\n\npublic class GitlabMockUtil {\n\n\tpublic static final long PROJECT_ID = 1L;", "public class GitlabMockUtil {\n\n\tpublic static final long PROJECT_ID = 1L;\n\tpublic static final long USER_ID = 1L;\n\n\tpublic static final String MR_EVENT_SOURCE_BRANCH = \"some-feature\";\n\tpublic static final String MR_EVENT_TARGET_BRANCH = \"release/6.x.x\";\n\tpublic static final String MR_EVENT_MERGE_COMMIT_SHA = \"e819d39ed37c6d4b8e700b9e7f34c74c099c163b\";\n\tpublic static final String MR_EVENT_MERGE_ACTION = \"merge\";\n\tpublic static final String MR_EVENT_CLOSE_ACTION = \"close\";\n", "\tpublic static final String MR_EVENT_MERGE_ACTION = \"merge\";\n\tpublic static final String MR_EVENT_CLOSE_ACTION = \"close\";\n\n\tpublic static final String DEFAULT_TARGET_BRANCH = \"main\";\n\n\tpublic static final String GITLAB_EVENT_UUID = \"test-1234\";\n\n\tpublic static MergeRequestSimple createDefaultMREvent() {\n\t\treturn new MergeRequestSimple(PROJECT_ID, 100L, USER_ID, MR_EVENT_SOURCE_BRANCH, MR_EVENT_TARGET_BRANCH, \"merged\", MR_EVENT_MERGE_COMMIT_SHA, MR_EVENT_MERGE_ACTION, GITLAB_EVENT_UUID);\n\t}\n\n\t/**\n\t * Gitlab API actions\n\t */", "\tpublic static enum GitlabAction {\n\t\t// REST API\n\t\tCREATE_BRANCH, CREATE_MR, ACCEPT_MR, APPROVE_MR, GET_APPROVALS, UPDATE_MR, GET_OPEN_MRS, GET_MR, GET_BRANCH, GET_FILE, LIST_MR_PIPELINES, COMPARE_DIFF_BRANCHES, COMPARE_NO_DIFF_BRANCHES, GET_USER,\n\t\t// Webhook\n\t\tEVENT_MR_MERGED;\n\t}\n\n\tprivate static final EnumMap<GitlabAction, String> jsonTemplatesLocation = initJsonTemplatesLocationMap();\n\n\t/**\n\t * Loads the JSON file content for a given action, possibly customizing some properties.\n\t *\n\t * @param action The action for which the corresponding JSON response is required.\n\t * @param customProperties Map between the name and value of the properties to be modified using the new value.\n\t * @return String containing the contents of the JSON file for the given action, with its properties customized accordingly to the provided map.\n\t */", "\tpublic static String get(GitlabAction action, Map<String, Object> customProperties) {\n\t\tString origJson = ResourcesUtil.readFromResources(jsonTemplatesLocation.get(action));\n\t\tif (customProperties != null) {\n\t\t\tfor (Entry<String, Object> customProperty : customProperties.entrySet()) {\n\t\t\t\tString name = customProperty.getKey();\n\t\t\t\tObject value = customProperty.getValue();\n\t\t\t\torigJson = origJson.replaceAll(\"(\\\\s*\\\"\" + name + \"\\\"\\\\s*:\\\\s*).+,\", \"$1\" + value + \",\");\n\t\t\t}\n\t\t}\n\t\treturn origJson;\n\t}\n\n\tprivate static EnumMap<GitlabAction, String> initJsonTemplatesLocationMap() {\n\t\tEnumMap<GitlabAction, String> templates = new EnumMap<>(GitlabAction.class);\n\t\ttemplates.put(GitlabAction.CREATE_BRANCH, \"/gitlab_template_json/api/createBranchResponse.json\");\n\t\ttemplates.put(GitlabAction.CREATE_MR, \"/gitlab_template_json/api/createMRResponse.json\");\n\t\ttemplates.put(GitlabAction.ACCEPT_MR, \"/gitlab_template_json/api/acceptMRResponse.json\");\n\t\ttemplates.put(GitlabAction.APPROVE_MR, \"/gitlab_template_json/api/approveMRResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_APPROVALS, \"/gitlab_template_json/api/getMRApprovalsResponse.json\");\n\t\ttemplates.put(GitlabAction.UPDATE_MR, \"/gitlab_template_json/api/updateMRResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_OPEN_MRS, \"/gitlab_template_json/api/getOpenMRsResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_MR, \"/gitlab_template_json/api/getMRResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_BRANCH, \"/gitlab_template_json/api/getBranchResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_FILE, \"/gitlab_template_json/api/getFileFromRepository.json\");\n\t\ttemplates.put(GitlabAction.LIST_MR_PIPELINES, \"/gitlab_template_json/api/listMRPipelines.json\");\n\t\ttemplates.put(GitlabAction.COMPARE_DIFF_BRANCHES, \"/gitlab_template_json/api/compareDiffBranchesResponse.json\");\n\t\ttemplates.put(GitlabAction.COMPARE_NO_DIFF_BRANCHES, \"/gitlab_template_json/api/compareNoDiffBranchesResponse.json\");\n\t\ttemplates.put(GitlabAction.GET_USER, \"/gitlab_template_json/api/getUserResponse.json\");\n\t\ttemplates.put(GitlabAction.EVENT_MR_MERGED, \"/gitlab_template_json/webhook/mergedMREvent.json\");\n\n\t\treturn templates;\n\t}\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/util/GitlabMockUtilTest.java", "chunked_list": ["package com.unblu.ucascade.util;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Map;\n", "import java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.unblu.ucascade.util.GitlabMockUtil.GitlabAction;\n\nimport util.ConfigurationUtils;\n\nclass GitlabMockUtilTest {\n", "class GitlabMockUtilTest {\n\n\t@Test\n\tvoid gitLabMockUtilTest() {\n\t\tMap<String, Object> customProperties = Map.of(\n\t\t\t\t\"detailed_merge_status\", \"\\\"broken_status\\\"\",\n\t\t\t\t\"project_id\", 1234);\n\t\tString body = GitlabMockUtil.get(GitlabAction.CREATE_MR, customProperties);\n\n\t\tassertTrue(body.contains(\"\\\"detailed_merge_status\\\" : \\\"broken_status\\\",\"));", "\n\t\tassertTrue(body.contains(\"\\\"detailed_merge_status\\\" : \\\"broken_status\\\",\"));\n\t\tassertFalse(body.contains(\"\\\"detailed_merge_status\\\" : \\\"mergeable\\\",\"));\n\t\tassertTrue(body.contains(\"\\\"project_id\\\" : 1234,\"));\n\t\tassertFalse(body.contains(\"\\\"project_id\\\" : 1,\"));\n\t}\n\n\t@Test\n\tvoid testGetNextTargetBranch() throws Exception {\n\t\tString branchModelContent = Files.readString(Path.of(\"src/test/resources/ucascade.json\"));", "\tvoid testGetNextTargetBranch() throws Exception {\n\t\tString branchModelContent = Files.readString(Path.of(\"src/test/resources/ucascade.json\"));\n\t\tString actual = ConfigurationUtils.getNextTargetBranch(branchModelContent, GitlabMockUtil.MR_EVENT_TARGET_BRANCH);\n\t\tassertEquals(GitlabMockUtil.DEFAULT_TARGET_BRANCH, actual);\n\t}\n\n}\n"]}
{"filename": "src/test/java/com/unblu/ucascade/util/ResourcesUtil.java", "chunked_list": ["package com.unblu.ucascade.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.stream.Collectors;\n\nimport com.unblu.ucascade.WireMockGitlabProxy;\n\npublic class ResourcesUtil {\n", "import com.unblu.ucascade.WireMockGitlabProxy;\n\npublic class ResourcesUtil {\n\n\tpublic static String readFromResources(String name) {\n\t\ttry (InputStream is = WireMockGitlabProxy.class.getResourceAsStream(name)) {\n\t\t\treturn new BufferedReader(new InputStreamReader(is))\n\t\t\t\t\t.lines().collect(Collectors.joining(\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\"Could not read resource \" + name, e);\n\t\t}\n\t}\n\n}\n"]}
{"filename": "src/main/java/util/ConfigurationUtils.java", "chunked_list": ["package util;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport controller.model.Config;\nimport controller.model.ConfigBranches;\n\npublic class ConfigurationUtils {\n", "\npublic class ConfigurationUtils {\n\n\tpublic static String getNextTargetBranch(String branchModel, String sourceBranchName) {\n\t\tConfig config = JsonUtils.getConfigFromString(branchModel);\n\t\tList<ConfigBranches> branches = config.getBranches();\n\t\tif (branches != null) {\n\t\t\tfor (final ConfigBranches branch : branches) {\n\t\t\t\tString sourceBranchPatternString = branch.getSourceBranchPattern();\n\t\t\t\tPattern sourceBranchPattern = Pattern.compile(sourceBranchPatternString);\n\t\t\t\tMatcher matcher = sourceBranchPattern.matcher(sourceBranchName);", "\t\t\t\tif (matcher.find()) {\n\t\t\t\t\treturn branch.getTargetBranch();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"]}
{"filename": "src/main/java/util/JsonUtils.java", "chunked_list": ["package util;\n\nimport java.io.IOException;\n\nimport org.gitlab4j.api.webhook.MergeRequestEvent;\nimport org.gitlab4j.api.webhook.MergeRequestEvent.ObjectAttributes;\n\nimport com.fasterxml.jackson.core.json.JsonReadFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.json.JsonMapper;", "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.json.JsonMapper;\n\nimport controller.model.Config;\nimport controller.model.MergeRequestSimple;\n\npublic class JsonUtils {\n\n\tpublic static Config getConfigFromString(String content) {\n\t\ttry {\n\t\t\tObjectMapper mapper = JsonMapper.builder()\n\t\t\t\t\t.enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)\n\t\t\t\t\t.build();\n\t\t\treturn mapper.readValue(content, Config.class);\n\t\t} catch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"The String could not be parsed as Config: '%s'\", content), ex);\n\t\t}\n\t}\n", "\tpublic static Config getConfigFromString(String content) {\n\t\ttry {\n\t\t\tObjectMapper mapper = JsonMapper.builder()\n\t\t\t\t\t.enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)\n\t\t\t\t\t.build();\n\t\t\treturn mapper.readValue(content, Config.class);\n\t\t} catch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"The String could not be parsed as Config: '%s'\", content), ex);\n\t\t}\n\t}\n", "\tpublic static MergeRequestSimple getMergeRequestFromString(String content) {\n\t\ttry {\n\t\t\tObjectMapper mapper = JsonMapper.builder()\n\t\t\t\t\t.build();\n\t\t\treturn mapper.readValue(content, MergeRequestSimple.class);\n\t\t} catch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"The String could not be parsed as MergeRequestSimple: '%s'\", content), ex);\n\t\t}\n\t}\n\n\tpublic static MergeRequestSimple toSimpleEvent(MergeRequestEvent mrEvent, String gitlabEventUUID) {\n\t\tMergeRequestSimple result = new MergeRequestSimple();\n\n\t\tObjectAttributes objectAttributes = mrEvent.getObjectAttributes();", "\tpublic static MergeRequestSimple toSimpleEvent(MergeRequestEvent mrEvent, String gitlabEventUUID) {\n\t\tMergeRequestSimple result = new MergeRequestSimple();\n\n\t\tObjectAttributes objectAttributes = mrEvent.getObjectAttributes();\n\t\tif (objectAttributes == null) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | MergeRequestEvent.ObjectAttributes is null. Possible cause: error in the deserializing process\", gitlabEventUUID));\n\t\t}\n\n\t\tresult.setGitlabEventUUID(gitlabEventUUID);\n\t\tresult.setUserId(mrEvent.getUser().getId());\n\t\tresult.setProjectId(mrEvent.getProject().getId());\n\t\tresult.setSourceBranch(objectAttributes.getSourceBranch());\n\t\tresult.setTargetBranch(objectAttributes.getTargetBranch());\n\t\tresult.setMrNumber(objectAttributes.getIid());\n\t\tresult.setMergeCommitSha(objectAttributes.getMergeCommitSha());\n\t\tresult.setMrState(objectAttributes.getState());\n\t\tresult.setMrAction(objectAttributes.getAction());\n\n\t\treturn result;\n\t}\n\n\tprivate JsonUtils() {\n\t}\n}\n"]}
{"filename": "src/main/java/controller/MergeRequestController.java", "chunked_list": ["package controller;\n\nimport java.util.Random;\n\nimport javax.inject.Inject;\n\nimport org.gitlab4j.api.webhook.MergeRequestEvent;\n\nimport controller.model.CascadeResult;\nimport controller.model.MergeRequestSimple;", "import controller.model.CascadeResult;\nimport controller.model.MergeRequestSimple;\nimport io.quarkus.logging.Log;\nimport io.quarkus.vertx.web.Body;\nimport io.quarkus.vertx.web.Header;\nimport io.quarkus.vertx.web.Route;\nimport io.quarkus.vertx.web.Route.HandlerType;\nimport io.quarkus.vertx.web.Route.HttpMethod;\nimport io.quarkus.vertx.web.RouteBase;\nimport io.vertx.core.http.HttpServerResponse;", "import io.quarkus.vertx.web.RouteBase;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.core.json.Json;\nimport io.vertx.ext.web.RoutingContext;\nimport io.vertx.mutiny.core.eventbus.EventBus;\nimport service.GitLabService;\nimport util.JsonUtils;\n\n@RouteBase(produces = \"application/json\")\npublic class MergeRequestController {\n\n\t@Inject\n\tGitLabService gitLabService;\n\n\t@Inject\n\tEventBus eventsBus;\n\n\t@Route(path = \"/ucascade/merge-request\", order = 1, methods = HttpMethod.POST, type = HandlerType.NORMAL)", "@RouteBase(produces = \"application/json\")\npublic class MergeRequestController {\n\n\t@Inject\n\tGitLabService gitLabService;\n\n\t@Inject\n\tEventBus eventsBus;\n\n\t@Route(path = \"/ucascade/merge-request\", order = 1, methods = HttpMethod.POST, type = HandlerType.NORMAL)\n\tpublic CascadeResult mergeRequest(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, @Body MergeRequestEvent mrEvent, HttpServerResponse response) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Received\", gitlabEventUUID);\n\t\tMergeRequestSimple simpleEvent = JsonUtils.toSimpleEvent(mrEvent, gitlabEventUUID);\n\t\t// consumed by GitLabService class\n\t\teventsBus.send(GitLabService.MERGE_REQUEST_EVENT, simpleEvent);\n\t\tresponse.setStatusCode(202);\n\t\treturn gitLabService.createResult(gitlabEventUUID);\n\t}\n\n\t@Route(path = \"/ucascade/merge-request-blocking\", order = 1, methods = HttpMethod.POST, type = HandlerType.BLOCKING)", "\tpublic CascadeResult mergeRequest(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, @Body MergeRequestEvent mrEvent, HttpServerResponse response) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Received\", gitlabEventUUID);\n\t\tMergeRequestSimple simpleEvent = JsonUtils.toSimpleEvent(mrEvent, gitlabEventUUID);\n\t\t// consumed by GitLabService class\n\t\teventsBus.send(GitLabService.MERGE_REQUEST_EVENT, simpleEvent);\n\t\tresponse.setStatusCode(202);\n\t\treturn gitLabService.createResult(gitlabEventUUID);\n\t}\n\n\t@Route(path = \"/ucascade/merge-request-blocking\", order = 1, methods = HttpMethod.POST, type = HandlerType.BLOCKING)\n\tpublic CascadeResult mergeRequestBlocking(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, @Body MergeRequestEvent mrEvent) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Received (blocking)\", gitlabEventUUID);\n\t\tMergeRequestSimple simpleEvent = JsonUtils.toSimpleEvent(mrEvent, gitlabEventUUID);\n\t\treturn gitLabService.mergeRequest(simpleEvent);\n\t}\n\n\t@Route(path = \"/ucascade/replay\", order = 1, methods = HttpMethod.POST, type = HandlerType.BLOCKING)", "\tpublic CascadeResult mergeRequestBlocking(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, @Body MergeRequestEvent mrEvent) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Received (blocking)\", gitlabEventUUID);\n\t\tMergeRequestSimple simpleEvent = JsonUtils.toSimpleEvent(mrEvent, gitlabEventUUID);\n\t\treturn gitLabService.mergeRequest(simpleEvent);\n\t}\n\n\t@Route(path = \"/ucascade/replay\", order = 1, methods = HttpMethod.POST, type = HandlerType.BLOCKING)\n\tpublic CascadeResult replay(@Body MergeRequestSimple mrSimple) {\n\t\tString gitlabEventUUID = mrSimple.getGitlabEventUUID();\n\t\tif (gitlabEventUUID == null) {\n\t\t\tgitlabEventUUID = \"replay-\" + new Random().nextInt(1000, 10000);\n\t\t}\n\t\tLog.infof(\"GitlabEvent: '%s' | Replay\", gitlabEventUUID);\n\t\treturn gitLabService.mergeRequest(mrSimple);\n\t}\n\n\t@Route(path = \"/*\", order = 2)", "\t\tif (gitlabEventUUID == null) {\n\t\t\tgitlabEventUUID = \"replay-\" + new Random().nextInt(1000, 10000);\n\t\t}\n\t\tLog.infof(\"GitlabEvent: '%s' | Replay\", gitlabEventUUID);\n\t\treturn gitLabService.mergeRequest(mrSimple);\n\t}\n\n\t@Route(path = \"/*\", order = 2)\n\tpublic void other(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, RoutingContext rc) {\n\t\tString path = rc.request().path();\n\t\tif (path.startsWith(\"/q/health\")) {\n\t\t\t// the module 'quarkus-smallrye-health' will answer:\n\t\t\trc.next();\n\t\t} else {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Invalid path '%s' \", gitlabEventUUID, path);\n\n\t\t\tCascadeResult result = gitLabService.createResult(gitlabEventUUID);\n\t\t\tresult.setError(\"Invalid path: \" + path);\n\t\t\tString body = Json.encode(result);\n\t\t\trc.response()\n\t\t\t\t\t.setStatusCode(202)\n\t\t\t\t\t.end(body);\n\t\t}\n\t}\n\n\t@Route(path = \"/*\", order = 3, type = HandlerType.FAILURE)", "\tpublic void other(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, RoutingContext rc) {\n\t\tString path = rc.request().path();\n\t\tif (path.startsWith(\"/q/health\")) {\n\t\t\t// the module 'quarkus-smallrye-health' will answer:\n\t\t\trc.next();\n\t\t} else {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Invalid path '%s' \", gitlabEventUUID, path);\n\n\t\t\tCascadeResult result = gitLabService.createResult(gitlabEventUUID);\n\t\t\tresult.setError(\"Invalid path: \" + path);\n\t\t\tString body = Json.encode(result);\n\t\t\trc.response()\n\t\t\t\t\t.setStatusCode(202)\n\t\t\t\t\t.end(body);\n\t\t}\n\t}\n\n\t@Route(path = \"/*\", order = 3, type = HandlerType.FAILURE)", "\tpublic CascadeResult error(@Header(\"X-Gitlab-Event-UUID\") String gitlabEventUUID, RoutingContext rc) {\n\t\tThrowable t = rc.failure();\n\t\tLog.warnf(t, \"GitlabEvent: '%s' | Failed to handle request on path '%s' \", gitlabEventUUID, rc.request().path());\n\n\t\tCascadeResult result = gitLabService.createResult(gitlabEventUUID);\n\t\tif (t != null) {\n\t\t\tresult.setError(t.getMessage());\n\t\t} else {\n\t\t\tresult.setError(\"Unknown error\");\n\t\t}\n\t\trc.response().setStatusCode(202);\n\t\treturn result;\n\t}\n}\n"]}
{"filename": "src/main/java/controller/model/DeleteBranchResult.java", "chunked_list": ["/*\n *    Copyright 2008-2022 unblu inc., Sarnen, Switzerland\n *    All rights reserved.\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\npackage controller.model;\n", "package controller.model;\n\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class DeleteBranchResult {\n\n\t@JsonProperty(\"branch_name\")\n\tprivate String branchName;\n\n\tpublic DeleteBranchResult() {\n\t}\n\n\tpublic DeleteBranchResult(String branchName) {\n\t\tthis.branchName = branchName;\n\t}\n\n\t@Override", "\tpublic int hashCode() {\n\t\treturn Objects.hash(branchName);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tDeleteBranchResult other = (DeleteBranchResult) obj;\n\t\treturn Objects.equals(branchName, other.branchName);\n\t}\n\n\t@Override", "\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tDeleteBranchResult other = (DeleteBranchResult) obj;\n\t\treturn Objects.equals(branchName, other.branchName);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"DeleteBranchResult [branchName=\" + branchName + \"]\";\n\t}\n}\n", "\tpublic String toString() {\n\t\treturn \"DeleteBranchResult [branchName=\" + branchName + \"]\";\n\t}\n}\n"]}
{"filename": "src/main/java/controller/model/Config.java", "chunked_list": ["package controller.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class Config {\n\n\t@JsonProperty(\"branches\")\n\tprivate List<ConfigBranches> branches;\n\n\tpublic List<ConfigBranches> getBranches() {\n\t\treturn branches;\n\t}\n", "public class Config {\n\n\t@JsonProperty(\"branches\")\n\tprivate List<ConfigBranches> branches;\n\n\tpublic List<ConfigBranches> getBranches() {\n\t\treturn branches;\n\t}\n\n\tpublic void setBranches(List<ConfigBranches> branches) {\n\t\tthis.branches = branches;\n\t}\n", "\tpublic void setBranches(List<ConfigBranches> branches) {\n\t\tthis.branches = branches;\n\t}\n\n\tpublic Config addBranch(ConfigBranches value) {\n\t\tif (branches == null) {\n\t\t\tbranches = new ArrayList<>();\n\t\t}\n\t\tbranches.add(value);\n\t\treturn this;\n\t}\n\n\t@Override", "\tpublic int hashCode() {\n\t\treturn Objects.hash(branches);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tConfig other = (Config) obj;\n\t\treturn Objects.equals(branches, other.branches);\n\t}\n}\n", "\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tConfig other = (Config) obj;\n\t\treturn Objects.equals(branches, other.branches);\n\t}\n}\n"]}
{"filename": "src/main/java/controller/model/MergeRequestSimple.java", "chunked_list": ["package controller.model;\n\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class MergeRequestSimple {\n\n\t@JsonProperty(\"project_id\")\n\tprivate Long projectId;\n\t@JsonProperty(\"mr_number\")\n\tprivate Long mrNumber;\n\t@JsonProperty(\"user_id\")\n\tprivate Long userId;\n\t@JsonProperty(\"source_branch\")\n\tprivate String sourceBranch;\n\t@JsonProperty(\"target_branch\")\n\tprivate String targetBranch;\n\t@JsonProperty(\"mr_state\")\n\tprivate String mrState;\n\t@JsonProperty(\"merge_commit_sha\")\n\tprivate String mergeCommitSha;\n\t@JsonProperty(\"mr_action\")\n\tprivate String mrAction;\n\n\t@JsonProperty(\"gitlab_event_uuid\")\n\tprivate String gitlabEventUUID;\n\n\tpublic MergeRequestSimple() {\n\t\tsuper();\n\t}\n\n\tpublic MergeRequestSimple(Long projectId, Long mrNumber, Long userId, String sourceBranch, String targetBranch, String mrState, String mergeCommitSha, String mrAction, String gitlabEventUUID) {\n\t\tthis.projectId = projectId;\n\t\tthis.mrNumber = mrNumber;\n\t\tthis.userId = userId;\n\t\tthis.sourceBranch = sourceBranch;\n\t\tthis.targetBranch = targetBranch;\n\t\tthis.mrState = mrState;\n\t\tthis.mergeCommitSha = mergeCommitSha;\n\t\tthis.gitlabEventUUID = gitlabEventUUID;\n\t\tthis.mrAction = mrAction;\n\t}\n", "\tpublic Long getProjectId() {\n\t\treturn projectId;\n\t}\n\n\tpublic void setProjectId(Long projectId) {\n\t\tthis.projectId = projectId;\n\t}\n\n\tpublic Long getMrNumber() {\n\t\treturn mrNumber;\n\t}\n", "\tpublic Long getMrNumber() {\n\t\treturn mrNumber;\n\t}\n\n\tpublic void setMrNumber(Long mrNumber) {\n\t\tthis.mrNumber = mrNumber;\n\t}\n\n\tpublic Long getUserId() {\n\t\treturn userId;\n\t}\n", "\tpublic Long getUserId() {\n\t\treturn userId;\n\t}\n\n\tpublic void setUserId(Long userId) {\n\t\tthis.userId = userId;\n\t}\n\n\tpublic String getSourceBranch() {\n\t\treturn sourceBranch;\n\t}\n", "\tpublic String getSourceBranch() {\n\t\treturn sourceBranch;\n\t}\n\n\tpublic void setSourceBranch(String sourceBranch) {\n\t\tthis.sourceBranch = sourceBranch;\n\t}\n\n\tpublic String getTargetBranch() {\n\t\treturn targetBranch;\n\t}\n", "\tpublic String getTargetBranch() {\n\t\treturn targetBranch;\n\t}\n\n\tpublic void setTargetBranch(String targetBranch) {\n\t\tthis.targetBranch = targetBranch;\n\t}\n\n\tpublic String getMrState() {\n\t\treturn mrState;\n\t}\n", "\tpublic String getMrState() {\n\t\treturn mrState;\n\t}\n\n\tpublic void setMrState(String mrState) {\n\t\tthis.mrState = mrState;\n\t}\n\n\tpublic String getMergeCommitSha() {\n\t\treturn mergeCommitSha;\n\t}\n", "\tpublic String getMergeCommitSha() {\n\t\treturn mergeCommitSha;\n\t}\n\n\tpublic void setMergeCommitSha(String mergeCommitSha) {\n\t\tthis.mergeCommitSha = mergeCommitSha;\n\t}\n\n\tpublic String getMrAction() {\n\t\treturn mrAction;\n\t}\n", "\tpublic String getMrAction() {\n\t\treturn mrAction;\n\t}\n\n\tpublic void setMrAction(String mrAction) {\n\t\tthis.mrAction = mrAction;\n\t}\n\n\tpublic String getGitlabEventUUID() {\n\t\treturn gitlabEventUUID;\n\t}\n", "\tpublic String getGitlabEventUUID() {\n\t\treturn gitlabEventUUID;\n\t}\n\n\tpublic void setGitlabEventUUID(String gitlabEventUUID) {\n\t\tthis.gitlabEventUUID = gitlabEventUUID;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(gitlabEventUUID, mergeCommitSha, mrAction, mrNumber, mrState, projectId, sourceBranch, targetBranch, userId);\n\t}\n\n\t@Override", "\tpublic int hashCode() {\n\t\treturn Objects.hash(gitlabEventUUID, mergeCommitSha, mrAction, mrNumber, mrState, projectId, sourceBranch, targetBranch, userId);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tMergeRequestSimple other = (MergeRequestSimple) obj;\n\t\treturn Objects.equals(gitlabEventUUID, other.gitlabEventUUID) &&\n\t\t\t\tObjects.equals(mergeCommitSha, other.mergeCommitSha) &&\n\t\t\t\tObjects.equals(mrAction, other.mrAction) &&\n\t\t\t\tObjects.equals(mrNumber, other.mrNumber) &&\n\t\t\t\tObjects.equals(mrState, other.mrState) &&\n\t\t\t\tObjects.equals(projectId, other.projectId) &&\n\t\t\t\tObjects.equals(sourceBranch, other.sourceBranch) &&\n\t\t\t\tObjects.equals(targetBranch, other.targetBranch) &&\n\t\t\t\tObjects.equals(userId, other.userId);\n\t}\n\n\t@Override", "\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tMergeRequestSimple other = (MergeRequestSimple) obj;\n\t\treturn Objects.equals(gitlabEventUUID, other.gitlabEventUUID) &&\n\t\t\t\tObjects.equals(mergeCommitSha, other.mergeCommitSha) &&\n\t\t\t\tObjects.equals(mrAction, other.mrAction) &&\n\t\t\t\tObjects.equals(mrNumber, other.mrNumber) &&\n\t\t\t\tObjects.equals(mrState, other.mrState) &&\n\t\t\t\tObjects.equals(projectId, other.projectId) &&\n\t\t\t\tObjects.equals(sourceBranch, other.sourceBranch) &&\n\t\t\t\tObjects.equals(targetBranch, other.targetBranch) &&\n\t\t\t\tObjects.equals(userId, other.userId);\n\t}\n\n\t@Override", "\tpublic String toString() {\n\t\treturn \"MergeRequestSimple [projectId=\" + projectId + \", mrNumber=\" + mrNumber + \", userId=\" + userId + \", sourceBranch=\" + sourceBranch + \", targetBranch=\" + targetBranch + \", mrState=\" + mrState + \", mergeCommitSha=\" + mergeCommitSha + \", mrAction=\" + mrAction + \", gitlabEventUUID=\" + gitlabEventUUID + \"]\";\n\t}\n\n}\n"]}
{"filename": "src/main/java/controller/model/ConfigBranches.java", "chunked_list": ["package controller.model;\n\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class ConfigBranches {\n\n\t@JsonProperty(\"sourceBranchPattern\")\n\tprivate String sourceBranchPattern;\n\n\t@JsonProperty(\"targetBranch\")\n\tprivate String targetBranch;\n", "\tpublic String getSourceBranchPattern() {\n\t\treturn sourceBranchPattern;\n\t}\n\n\tpublic void setSourceBranchPattern(String sourceBranchPattern) {\n\t\tthis.sourceBranchPattern = sourceBranchPattern;\n\t}\n\n\tpublic ConfigBranches withSourceBranchPattern(String value) {\n\t\tsetSourceBranchPattern(value);\n\t\treturn this;\n\t}\n", "\tpublic ConfigBranches withSourceBranchPattern(String value) {\n\t\tsetSourceBranchPattern(value);\n\t\treturn this;\n\t}\n\n\tpublic String getTargetBranch() {\n\t\treturn targetBranch;\n\t}\n\n\tpublic void setTargetBranch(String targetBranch) {\n\t\tthis.targetBranch = targetBranch;\n\t}\n", "\tpublic void setTargetBranch(String targetBranch) {\n\t\tthis.targetBranch = targetBranch;\n\t}\n\n\tpublic ConfigBranches withTargetBranch(String value) {\n\t\tsetTargetBranch(value);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(sourceBranchPattern, targetBranch);\n\t}\n\n\t@Override", "\tpublic int hashCode() {\n\t\treturn Objects.hash(sourceBranchPattern, targetBranch);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tConfigBranches other = (ConfigBranches) obj;\n\t\treturn Objects.equals(sourceBranchPattern, other.sourceBranchPattern) &&\n\t\t\t\tObjects.equals(targetBranch, other.targetBranch);\n\t}\n}\n", "\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tConfigBranches other = (ConfigBranches) obj;\n\t\treturn Objects.equals(sourceBranchPattern, other.sourceBranchPattern) &&\n\t\t\t\tObjects.equals(targetBranch, other.targetBranch);\n\t}\n}\n"]}
{"filename": "src/main/java/controller/model/MergeRequestUcascadeState.java", "chunked_list": ["package controller.model;\n\npublic enum MergeRequestUcascadeState {\n\tMERGED, NOT_MERGED_CONFLICTS, NOT_MERGED_CONCURRENT_MRS, NOT_MERGED_UNKNOWN_REASON, NOT_MERGED_MISSING_APPROVALS\n}\n"]}
{"filename": "src/main/java/controller/model/CascadeResult.java", "chunked_list": ["package controller.model;\n\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class CascadeResult {\n\n\t@JsonProperty(\"build_commit\")\n\tprivate String buildCommit;\n\n\t@JsonProperty(\"build_timestamp\")\n\tprivate String buildTimestamp;\n\n\t@JsonProperty(\"gitlab_event_uuid\")\n\tprivate String gitlabEventUUID;\n\n\t@JsonProperty(\"error\")\n\tprivate String error;\n\n\t@JsonProperty(\"previous_auto_mr_merged\")\n\tprivate MergeRequestResult previousAutoMrMerged;\n\n\t@JsonProperty(\"previous_auto_mr_merged_error\")\n\tprivate String previousAutoMrMergedError;\n\n\t@JsonProperty(\"created_auto_mr\")\n\tprivate MergeRequestResult createdAutoMr;\n\n\t@JsonProperty(\"created_auto_mr_error\")\n\tprivate String createdAutoMrError;\n\n\t@JsonProperty(\"existing_branch_deleted\")\n\tprivate DeleteBranchResult existingBranchDelete;\n\n\t@JsonProperty(\"existing_branch_deleted_error\")\n\tprivate String existingBranchDeleteError;\n", "\tpublic String getBuildCommit() {\n\t\treturn buildCommit;\n\t}\n\n\tpublic void setBuildCommit(String buildCommit) {\n\t\tthis.buildCommit = buildCommit;\n\t}\n\n\tpublic String getBuildTimestamp() {\n\t\treturn buildTimestamp;\n\t}\n", "\tpublic String getBuildTimestamp() {\n\t\treturn buildTimestamp;\n\t}\n\n\tpublic void setBuildTimestamp(String buildTimestamp) {\n\t\tthis.buildTimestamp = buildTimestamp;\n\t}\n\n\tpublic String getGitlabEventUUID() {\n\t\treturn gitlabEventUUID;\n\t}\n", "\tpublic String getGitlabEventUUID() {\n\t\treturn gitlabEventUUID;\n\t}\n\n\tpublic void setGitlabEventUUID(String gitlabEventUUID) {\n\t\tthis.gitlabEventUUID = gitlabEventUUID;\n\t}\n\n\tpublic String getError() {\n\t\treturn error;\n\t}\n", "\tpublic String getError() {\n\t\treturn error;\n\t}\n\n\tpublic void setError(String error) {\n\t\tthis.error = error;\n\t}\n\n\tpublic MergeRequestResult getPreviousAutoMrMerged() {\n\t\treturn previousAutoMrMerged;\n\t}\n", "\tpublic MergeRequestResult getPreviousAutoMrMerged() {\n\t\treturn previousAutoMrMerged;\n\t}\n\n\tpublic void setPreviousAutoMrMerged(MergeRequestResult previousAutoMrMerged) {\n\t\tthis.previousAutoMrMerged = previousAutoMrMerged;\n\t}\n\n\tpublic String getPreviousAutoMrMergedError() {\n\t\treturn previousAutoMrMergedError;\n\t}\n", "\tpublic String getPreviousAutoMrMergedError() {\n\t\treturn previousAutoMrMergedError;\n\t}\n\n\tpublic void setPreviousAutoMrMergedError(String previousAutoMrMergedError) {\n\t\tthis.previousAutoMrMergedError = previousAutoMrMergedError;\n\t}\n\n\tpublic MergeRequestResult getCreatedAutoMr() {\n\t\treturn createdAutoMr;\n\t}\n", "\tpublic MergeRequestResult getCreatedAutoMr() {\n\t\treturn createdAutoMr;\n\t}\n\n\tpublic void setCreatedAutoMr(MergeRequestResult createdAutoMr) {\n\t\tthis.createdAutoMr = createdAutoMr;\n\t}\n\n\tpublic String getCreatedAutoMrError() {\n\t\treturn createdAutoMrError;\n\t}\n", "\tpublic String getCreatedAutoMrError() {\n\t\treturn createdAutoMrError;\n\t}\n\n\tpublic void setCreatedAutoMrError(String createdAutoMrError) {\n\t\tthis.createdAutoMrError = createdAutoMrError;\n\t}\n\n\tpublic DeleteBranchResult getExistingBranchDelete() {\n\t\treturn existingBranchDelete;\n\t}\n", "\tpublic DeleteBranchResult getExistingBranchDelete() {\n\t\treturn existingBranchDelete;\n\t}\n\n\tpublic void setExistingBranchDelete(DeleteBranchResult existingBranchDelete) {\n\t\tthis.existingBranchDelete = existingBranchDelete;\n\t}\n\n\tpublic String getExistingBranchDeleteError() {\n\t\treturn existingBranchDeleteError;\n\t}\n", "\tpublic String getExistingBranchDeleteError() {\n\t\treturn existingBranchDeleteError;\n\t}\n\n\tpublic void setExistingBranchDeleteError(String existingBranchDeleteError) {\n\t\tthis.existingBranchDeleteError = existingBranchDeleteError;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(buildCommit, buildTimestamp, createdAutoMr, createdAutoMrError, error, existingBranchDelete, existingBranchDeleteError, gitlabEventUUID, previousAutoMrMerged, previousAutoMrMergedError);\n\t}\n\n\t@Override", "\tpublic int hashCode() {\n\t\treturn Objects.hash(buildCommit, buildTimestamp, createdAutoMr, createdAutoMrError, error, existingBranchDelete, existingBranchDeleteError, gitlabEventUUID, previousAutoMrMerged, previousAutoMrMergedError);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tCascadeResult other = (CascadeResult) obj;\n\t\treturn Objects.equals(buildCommit, other.buildCommit) &&\n\t\t\t\tObjects.equals(buildTimestamp, other.buildTimestamp) &&\n\t\t\t\tObjects.equals(createdAutoMr, other.createdAutoMr) &&\n\t\t\t\tObjects.equals(createdAutoMrError, other.createdAutoMrError) &&\n\t\t\t\tObjects.equals(error, other.error) &&\n\t\t\t\tObjects.equals(existingBranchDelete, other.existingBranchDelete) &&\n\t\t\t\tObjects.equals(existingBranchDeleteError, other.existingBranchDeleteError) &&\n\t\t\t\tObjects.equals(gitlabEventUUID, other.gitlabEventUUID) &&\n\t\t\t\tObjects.equals(previousAutoMrMerged, other.previousAutoMrMerged) &&\n\t\t\t\tObjects.equals(previousAutoMrMergedError, other.previousAutoMrMergedError);\n\t}\n\n\t@Override", "\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tCascadeResult other = (CascadeResult) obj;\n\t\treturn Objects.equals(buildCommit, other.buildCommit) &&\n\t\t\t\tObjects.equals(buildTimestamp, other.buildTimestamp) &&\n\t\t\t\tObjects.equals(createdAutoMr, other.createdAutoMr) &&\n\t\t\t\tObjects.equals(createdAutoMrError, other.createdAutoMrError) &&\n\t\t\t\tObjects.equals(error, other.error) &&\n\t\t\t\tObjects.equals(existingBranchDelete, other.existingBranchDelete) &&\n\t\t\t\tObjects.equals(existingBranchDeleteError, other.existingBranchDeleteError) &&\n\t\t\t\tObjects.equals(gitlabEventUUID, other.gitlabEventUUID) &&\n\t\t\t\tObjects.equals(previousAutoMrMerged, other.previousAutoMrMerged) &&\n\t\t\t\tObjects.equals(previousAutoMrMergedError, other.previousAutoMrMergedError);\n\t}\n\n\t@Override", "\tpublic String toString() {\n\t\treturn \"CascadeResult [buildCommit=\" + buildCommit + \", buildTimestamp=\" + buildTimestamp + \", gitlabEventUUID=\" + gitlabEventUUID + \", error=\" + error + \", previousAutoMrMerged=\" + previousAutoMrMerged + \", previousAutoMrMergedError=\" + previousAutoMrMergedError + \", createdAutoMr=\" + createdAutoMr + \", createdAutoMrError=\" + createdAutoMrError + \", existingBranchDelete=\" + existingBranchDelete + \", existingBranchDeleteError=\" + existingBranchDeleteError + \"]\";\n\t}\n\n}\n"]}
{"filename": "src/main/java/controller/model/MergeRequestResult.java", "chunked_list": ["/*\n *    Copyright 2008-2022 unblu inc., Sarnen, Switzerland\n *    All rights reserved.\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\npackage controller.model;\n", "package controller.model;\n\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.gitlab4j.api.models.Assignee;\nimport org.gitlab4j.api.models.MergeRequest;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class MergeRequestResult {\n\n\t@JsonProperty(\"id\")\n\tprivate Long id;\n\n\t@JsonProperty(\"project_id\")\n\tprivate Long projectId;\n\n\t@JsonProperty(\"mr_number\")\n\tprivate Long iid;\n\n\t@JsonProperty(\"assignee_ids\")\n\tprivate List<Long> assigneeIds;\n\n\t@JsonProperty(\"title\")\n\tprivate String title;\n\n\t@JsonProperty(\"description\")\n\tprivate String description;\n\n\t@JsonProperty(\"state\")\n\tprivate String state;\n\n\t@JsonProperty(\"detailed_merge_status\")\n\tprivate String detailedMergeStatus;\n\n\t@JsonProperty(\"has_conflicts\")\n\tprivate Boolean hasConflicts;\n\n\t@JsonProperty(\"source_branch\")\n\tprivate String sourceBranch;\n\n\t@JsonProperty(\"target_branch\")\n\tprivate String targetBranch;\n\n\t@JsonProperty(\"web_url\")\n\tprivate String webUrl;\n\n\t@JsonProperty(\"ucascade_state\")\n\tprivate MergeRequestUcascadeState ucascadeState;\n\n\tpublic MergeRequestResult(MergeRequest mr) {\n\t\tid = mr.getIid();\n\t\tiid = mr.getIid();\n\t\tprojectId = mr.getProjectId();\n\t\ttitle = mr.getTitle();\n\t\tdescription = mr.getDescription();\n\t\tstate = mr.getState();\n\t\tdetailedMergeStatus = mr.getDetailedMergeStatus();\n\t\thasConflicts = mr.getHasConflicts();\n\t\tsourceBranch = mr.getSourceBranch();\n\t\ttargetBranch = mr.getTargetBranch();\n\t\twebUrl = mr.getWebUrl();\n\t\tassigneeIds = mr.getAssignees() == null ? null : mr.getAssignees().stream().map(Assignee::getId).toList();\n\t}\n\n\tpublic MergeRequestResult() {\n\t}\n", "import com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class MergeRequestResult {\n\n\t@JsonProperty(\"id\")\n\tprivate Long id;\n\n\t@JsonProperty(\"project_id\")\n\tprivate Long projectId;\n\n\t@JsonProperty(\"mr_number\")\n\tprivate Long iid;\n\n\t@JsonProperty(\"assignee_ids\")\n\tprivate List<Long> assigneeIds;\n\n\t@JsonProperty(\"title\")\n\tprivate String title;\n\n\t@JsonProperty(\"description\")\n\tprivate String description;\n\n\t@JsonProperty(\"state\")\n\tprivate String state;\n\n\t@JsonProperty(\"detailed_merge_status\")\n\tprivate String detailedMergeStatus;\n\n\t@JsonProperty(\"has_conflicts\")\n\tprivate Boolean hasConflicts;\n\n\t@JsonProperty(\"source_branch\")\n\tprivate String sourceBranch;\n\n\t@JsonProperty(\"target_branch\")\n\tprivate String targetBranch;\n\n\t@JsonProperty(\"web_url\")\n\tprivate String webUrl;\n\n\t@JsonProperty(\"ucascade_state\")\n\tprivate MergeRequestUcascadeState ucascadeState;\n\n\tpublic MergeRequestResult(MergeRequest mr) {\n\t\tid = mr.getIid();\n\t\tiid = mr.getIid();\n\t\tprojectId = mr.getProjectId();\n\t\ttitle = mr.getTitle();\n\t\tdescription = mr.getDescription();\n\t\tstate = mr.getState();\n\t\tdetailedMergeStatus = mr.getDetailedMergeStatus();\n\t\thasConflicts = mr.getHasConflicts();\n\t\tsourceBranch = mr.getSourceBranch();\n\t\ttargetBranch = mr.getTargetBranch();\n\t\twebUrl = mr.getWebUrl();\n\t\tassigneeIds = mr.getAssignees() == null ? null : mr.getAssignees().stream().map(Assignee::getId).toList();\n\t}\n\n\tpublic MergeRequestResult() {\n\t}\n", "\tpublic Long getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic Long getIid() {\n\t\treturn iid;\n\t}\n", "\tpublic Long getIid() {\n\t\treturn iid;\n\t}\n\n\tpublic void setIid(Long iid) {\n\t\tthis.iid = iid;\n\t}\n\n\tpublic Long getProjectId() {\n\t\treturn projectId;\n\t}\n", "\tpublic Long getProjectId() {\n\t\treturn projectId;\n\t}\n\n\tpublic void setProjectId(Long projectId) {\n\t\tthis.projectId = projectId;\n\t}\n\n\tpublic List<Long> getAssigneeIds() {\n\t\treturn assigneeIds;\n\t}\n", "\tpublic void setAssigneeIds(List<Long> assigneeIds) {\n\t\tthis.assigneeIds = assigneeIds;\n\t}\n\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n", "\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n", "\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic String getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(String state) {\n\t\tthis.state = state;\n\t}\n", "\tpublic void setState(String state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic String getDetailedMergeStatus() {\n\t\treturn detailedMergeStatus;\n\t}\n\n\tpublic void setDetailedMergeStatus(String detailedMergeStatus) {\n\t\tthis.detailedMergeStatus = detailedMergeStatus;\n\t}\n", "\tpublic void setDetailedMergeStatus(String detailedMergeStatus) {\n\t\tthis.detailedMergeStatus = detailedMergeStatus;\n\t}\n\n\tpublic Boolean getHasConflicts() {\n\t\treturn hasConflicts;\n\t}\n\n\tpublic void setHasConflicts(Boolean hasConflicts) {\n\t\tthis.hasConflicts = hasConflicts;\n\t}\n", "\tpublic void setHasConflicts(Boolean hasConflicts) {\n\t\tthis.hasConflicts = hasConflicts;\n\t}\n\n\tpublic String getSourceBranch() {\n\t\treturn sourceBranch;\n\t}\n\n\tpublic void setSourceBranch(String sourceBranch) {\n\t\tthis.sourceBranch = sourceBranch;\n\t}\n", "\tpublic void setSourceBranch(String sourceBranch) {\n\t\tthis.sourceBranch = sourceBranch;\n\t}\n\n\tpublic String getTargetBranch() {\n\t\treturn targetBranch;\n\t}\n\n\tpublic void setTargetBranch(String targetBranch) {\n\t\tthis.targetBranch = targetBranch;\n\t}\n", "\tpublic void setTargetBranch(String targetBranch) {\n\t\tthis.targetBranch = targetBranch;\n\t}\n\n\tpublic String getWebUrl() {\n\t\treturn webUrl;\n\t}\n\n\tpublic void setWebUrl(String webUrl) {\n\t\tthis.webUrl = webUrl;\n\t}\n", "\tpublic void setWebUrl(String webUrl) {\n\t\tthis.webUrl = webUrl;\n\t}\n\n\tpublic MergeRequestUcascadeState getUcascadeState() {\n\t\treturn ucascadeState;\n\t}\n\n\tpublic void setUcascadeState(MergeRequestUcascadeState ucascadeState) {\n\t\tthis.ucascadeState = ucascadeState;\n\t}\n\n\t@Override", "\tpublic void setUcascadeState(MergeRequestUcascadeState ucascadeState) {\n\t\tthis.ucascadeState = ucascadeState;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(assigneeIds, description, detailedMergeStatus, hasConflicts, id, iid, projectId, sourceBranch, state, targetBranch, title, ucascadeState, webUrl);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {", "\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tMergeRequestResult other = (MergeRequestResult) obj;\n\t\treturn Objects.equals(assigneeIds, other.assigneeIds) &&\n\t\t\t\tObjects.equals(description, other.description) &&\n\t\t\t\tObjects.equals(detailedMergeStatus, other.detailedMergeStatus) &&\n\t\t\t\tObjects.equals(hasConflicts, other.hasConflicts) &&\n\t\t\t\tObjects.equals(id, other.id) &&\n\t\t\t\tObjects.equals(iid, other.iid) &&\n\t\t\t\tObjects.equals(projectId, other.projectId) &&\n\t\t\t\tObjects.equals(sourceBranch, other.sourceBranch) &&\n\t\t\t\tObjects.equals(state, other.state) &&\n\t\t\t\tObjects.equals(targetBranch, other.targetBranch) &&\n\t\t\t\tObjects.equals(title, other.title) &&\n\t\t\t\tucascadeState == other.ucascadeState &&\n\t\t\t\tObjects.equals(webUrl, other.webUrl);\n\t}\n\n\t@Override", "\tpublic String toString() {\n\t\treturn \"MergeRequestResult [id=\" + id + \", projectId=\" + projectId + \", iid=\" + iid + \", assigneeIds=\" + assigneeIds + \", title=\" + title + \", description=\" + description + \", state=\" + state + \", detailedMergeStatus=\" + detailedMergeStatus + \", hasConflicts=\" + hasConflicts + \", sourceBranch=\" + sourceBranch + \", targetBranch=\" + targetBranch + \", webUrl=\" + webUrl + \", ucascadeState=\" + ucascadeState + \"]\";\n\t}\n\n}\n"]}
{"filename": "src/main/java/controller/model/MergeRequestEventBundle.java", "chunked_list": ["package controller.model;\n\nimport org.gitlab4j.api.webhook.MergeRequestEvent;\n\npublic class MergeRequestEventBundle {\n\n\tprivate MergeRequestEvent mrEvent;\n\tprivate String gitlabEventUUID;\n\n\tpublic MergeRequestEventBundle(MergeRequestEvent mrEvent, String gitlabEventUUID) {\n\t\tthis.mrEvent = mrEvent;\n\t\tthis.gitlabEventUUID = gitlabEventUUID;\n\t}\n", "\tpublic MergeRequestEvent getMrEvent() {\n\t\treturn mrEvent;\n\t}\n\n\tpublic String getGitlabEventUUID() {\n\t\treturn gitlabEventUUID;\n\t}\n\n}\n"]}
{"filename": "src/main/java/service/GitLabService.java", "chunked_list": ["package service;\n\nimport java.util.ArrayDeque;\nimport java.util.Base64;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;", "import java.util.Optional;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport javax.annotation.PostConstruct;\nimport javax.enterprise.context.ApplicationScoped;\nimport javax.inject.Inject;", "import javax.enterprise.context.ApplicationScoped;\nimport javax.inject.Inject;\n\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\nimport org.gitlab4j.api.Constants.MergeRequestState;\nimport org.gitlab4j.api.GitLabApi;\nimport org.gitlab4j.api.GitLabApiException;\nimport org.gitlab4j.api.MergeRequestApi;\nimport org.gitlab4j.api.models.AcceptMergeRequestParams;\nimport org.gitlab4j.api.models.Assignee;", "import org.gitlab4j.api.models.AcceptMergeRequestParams;\nimport org.gitlab4j.api.models.Assignee;\nimport org.gitlab4j.api.models.Branch;\nimport org.gitlab4j.api.models.MergeRequest;\nimport org.gitlab4j.api.models.MergeRequestParams;\n\nimport controller.model.CascadeResult;\nimport controller.model.DeleteBranchResult;\nimport controller.model.MergeRequestResult;\nimport controller.model.MergeRequestSimple;", "import controller.model.MergeRequestResult;\nimport controller.model.MergeRequestSimple;\nimport controller.model.MergeRequestUcascadeState;\nimport io.quarkus.logging.Log;\nimport io.quarkus.vertx.ConsumeEvent;\nimport io.smallrye.common.annotation.Blocking;\nimport io.vertx.mutiny.core.eventbus.EventBus;\nimport util.ConfigurationUtils;\n\n@ApplicationScoped\npublic class GitLabService {\n", "\n@ApplicationScoped\npublic class GitLabService {\n\n\tpublic static final String MERGE_REQUEST_EVENT = \"merge-request-event\";\n\n\t@Inject\n\tEventBus resultsBus;\n\n\t@ConfigProperty(name = \"gitlab.host\", defaultValue = \"https://gitlab.com\")\n\tString gitLabHost;\n\n\t@ConfigProperty(name = \"gitlab.api.token\")\n\tString apiToken;\n\n\t@ConfigProperty(name = \"gitlab.api.token.approver\")\n\tOptional<String> apiTokenApprover;\n\n\t@ConfigProperty(name = \"build.commit\", defaultValue = \"n/a\")\n\tString buildCommit;\n\n\t@ConfigProperty(name = \"build.timestamp\", defaultValue = \"n/a\")\n\tString buildTimestamp;\n\n\tprivate static final String UCASCADE_CONFIGURATION_FILE = \"ucascade.json\";\n\tprivate static final String UCASCADE_TAG = \"[ucascade]\";\n\tprivate static final String UCASCADE_BRANCH_PATTERN_PREFIX = \"^mr(\\\\d+)_\";\n\tprivate static final String UCASCADE_BRANCH_PATTERN = UCASCADE_BRANCH_PATTERN_PREFIX + \".+\";\n\tprivate static final int MAX_RETRY_ATTEMPTS = 60;\n\n\tprivate GitLabApi gitlab;\n\tprivate GitLabApi gitlabApprover;\n\tprivate Long ucascadeUser;\n\n\t@PostConstruct\n\tvoid init() throws GitLabApiException {\n\t\tgitlab = new GitLabApi(gitLabHost, apiToken);\n\t\tapiTokenApprover.ifPresent(\n\t\t\t\tvalue -> gitlabApprover = apiToken.equals(value) ? gitlab : new GitLabApi(gitLabHost, value));\n\t\tucascadeUser = gitlab.getUserApi().getCurrentUser().getId();\n\t}\n\n\t@Blocking // Will be called on a worker thread\n\t@ConsumeEvent(MERGE_REQUEST_EVENT)", "\tpublic CascadeResult mergeRequest(MergeRequestSimple mrEvent) {\n\t\tString gitlabEventUUID = mrEvent.getGitlabEventUUID();\n\n\t\tCascadeResult result = createResult(gitlabEventUUID);\n\n\t\tString mrState = mrEvent.getMrState();\n\t\tString mrAction = mrEvent.getMrAction();\n\n\t\tif (mrState.equals(\"merged\") && mrAction.equals(\"merge\")) {\n\t\t\thandleMrMergeEvent(mrEvent, gitlabEventUUID, result);\n\t\t} else if (mrState.equals(\"closed\") && mrAction.equals(\"close\")) {\n\t\t\thandleMrCloseEvent(mrEvent, gitlabEventUUID, result);\n\t\t} else {\n\t\t\thandleSkipEvent(mrEvent, gitlabEventUUID, mrState, mrAction);\n\t\t}\n\n\t\tLog.infof(\"GitlabEvent: '%s' | Finished handling event with result %s\",\n\t\t\t\tgitlabEventUUID, result);\n\t\treturn result;\n\t}\n", "\t\tif (mrState.equals(\"merged\") && mrAction.equals(\"merge\")) {\n\t\t\thandleMrMergeEvent(mrEvent, gitlabEventUUID, result);\n\t\t} else if (mrState.equals(\"closed\") && mrAction.equals(\"close\")) {\n\t\t\thandleMrCloseEvent(mrEvent, gitlabEventUUID, result);\n\t\t} else {\n\t\t\thandleSkipEvent(mrEvent, gitlabEventUUID, mrState, mrAction);\n\t\t}\n\n\t\tLog.infof(\"GitlabEvent: '%s' | Finished handling event with result %s\",\n\t\t\t\tgitlabEventUUID, result);\n\t\treturn result;\n\t}\n", "\tpublic CascadeResult createResult(String gitlabEventUUID) {\n\t\tCascadeResult result = new CascadeResult();\n\t\tresult.setGitlabEventUUID(gitlabEventUUID);\n\t\tresult.setBuildCommit(buildCommit);\n\t\tresult.setBuildTimestamp(buildTimestamp);\n\t\treturn result;\n\t}\n\n\tprivate void handleMrMergeEvent(MergeRequestSimple mrEvent, String gitlabEventUUID, CascadeResult result) {\n\t\tLong userId = mrEvent.getUserId();\n\t\tLong projectId = mrEvent.getProjectId();\n\t\tString sourceBranch = mrEvent.getSourceBranch();\n\t\tString targetBranch = mrEvent.getTargetBranch();\n\t\tLong mrNumber = mrEvent.getMrNumber();\n\t\tString mergeSha = mrEvent.getMergeCommitSha();\n\t\tString prevSourceBranch = removeMrPrefixPattern(sourceBranch);\n\n\t\tLog.infof(\"GitlabEvent: '%s' | Merge MR Event. Project: '%d', User: '%d', Target: '%s', MergeRequestNumber: '%d'\",\n\t\t\t\tgitlabEventUUID, projectId, userId, targetBranch, mrNumber);\n", "\t\ttry {\n\t\t\tmergePreviousAutoMr(result, gitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while merging previous auto merge request. Project: '%d', Target: '%s', PrevSourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t\tresult.setPreviousAutoMrMergedError(e.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tcreateAutoMr(result, gitlabEventUUID, projectId, sourceBranch, targetBranch, mrNumber, mergeSha);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while creating auto merge request. Project: '%d', User: '%d', SourceBranch: '%s', TargetBranch: '%s', MergeRequestNumber: '%d', MergeSha: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, userId, sourceBranch, targetBranch, mrNumber, mergeSha);\n\t\t\tresult.setCreatedAutoMrError(e.getMessage());\n\t\t}\n", "\t\ttry {\n\t\t\tcreateAutoMr(result, gitlabEventUUID, projectId, sourceBranch, targetBranch, mrNumber, mergeSha);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while creating auto merge request. Project: '%d', User: '%d', SourceBranch: '%s', TargetBranch: '%s', MergeRequestNumber: '%d', MergeSha: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, userId, sourceBranch, targetBranch, mrNumber, mergeSha);\n\t\t\tresult.setCreatedAutoMrError(e.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tdeleteExistingBranch(result, gitlabEventUUID, projectId, sourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while deleting existing branch. Project: '%d', SourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, sourceBranch);\n\t\t\tresult.setExistingBranchDeleteError(e.getMessage());\n\t\t}\n\t}\n\n\tprivate void handleMrCloseEvent(MergeRequestSimple mrEvent, String gitlabEventUUID, CascadeResult result) {\n\t\tLong userId = mrEvent.getUserId();\n\t\tLong projectId = mrEvent.getProjectId();\n\t\tString sourceBranch = mrEvent.getSourceBranch();\n\t\tString targetBranch = mrEvent.getTargetBranch();\n\t\tLong mrNumber = mrEvent.getMrNumber();\n\t\tString prevSourceBranch = removeMrPrefixPattern(sourceBranch);\n\n\t\tLog.infof(\"GitlabEvent: '%s' | Close MR Event. Project: '%d', User: '%d', Target: '%s', MergeRequestNumber: '%d'\",\n\t\t\t\tgitlabEventUUID, projectId, userId, targetBranch, mrNumber);\n", "\t\ttry {\n\t\t\tdeleteExistingBranch(result, gitlabEventUUID, projectId, sourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while deleting existing branch. Project: '%d', SourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, sourceBranch);\n\t\t\tresult.setExistingBranchDeleteError(e.getMessage());\n\t\t}\n\t}\n\n\tprivate void handleMrCloseEvent(MergeRequestSimple mrEvent, String gitlabEventUUID, CascadeResult result) {\n\t\tLong userId = mrEvent.getUserId();\n\t\tLong projectId = mrEvent.getProjectId();\n\t\tString sourceBranch = mrEvent.getSourceBranch();\n\t\tString targetBranch = mrEvent.getTargetBranch();\n\t\tLong mrNumber = mrEvent.getMrNumber();\n\t\tString prevSourceBranch = removeMrPrefixPattern(sourceBranch);\n\n\t\tLog.infof(\"GitlabEvent: '%s' | Close MR Event. Project: '%d', User: '%d', Target: '%s', MergeRequestNumber: '%d'\",\n\t\t\t\tgitlabEventUUID, projectId, userId, targetBranch, mrNumber);\n", "\t\ttry {\n\t\t\tdeleteExistingBranch(result, gitlabEventUUID, projectId, sourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while deleting existing branch. Project: '%d', SourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, sourceBranch);\n\t\t\tresult.setExistingBranchDeleteError(e.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tmergePreviousAutoMr(result, gitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while merging previous auto merge request. Project: '%d', Target: '%s', PrevSourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t\tresult.setPreviousAutoMrMergedError(e.getMessage());\n\t\t}\n\t}\n\n\tprivate void handleSkipEvent(MergeRequestSimple mrEvent, String gitlabEventUUID, String mrState, String mrAction) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Skip event for Project: '%d', User: '%d', Target: '%s', MergeRequestNumber: '%d', State: '%s', Action: '%s'\",\n\t\t\t\tgitlabEventUUID, mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);\n\t}\n\n\tprivate void mergePreviousAutoMr(CascadeResult result, String gitlabEventUUID, Long projectId, String sourceBranch, String prevSourceBranch) {\n\t\tString branchPattern = addMrPrefixPattern(prevSourceBranch);\n\n\t\tgetOpenMergeRequests(gitlabEventUUID, projectId)\n\t\t\t\t.filter(openMr -> openMr.getTargetBranch().equals(sourceBranch) &&\n\t\t\t\t\t\topenMr.getSourceBranch().matches(branchPattern))\n\t\t\t\t.sorted(Comparator.comparingLong(MergeRequest::getIid))\n\t\t\t\t.findFirst()\n\t\t\t\t.ifPresent(mr -> {\n\t\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Found auto merge request between '%s' and '%s' - iid: '%s', mergeWhenPipelineSucceeds: '%s'\", gitlabEventUUID, prevSourceBranch, sourceBranch, mr.getIid(), mr.getMergeWhenPipelineSucceeds());", "\t\ttry {\n\t\t\tmergePreviousAutoMr(result, gitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t} catch (Exception e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Exception while merging previous auto merge request. Project: '%d', Target: '%s', PrevSourceBranch: '%s'\",\n\t\t\t\t\tgitlabEventUUID, projectId, targetBranch, prevSourceBranch);\n\t\t\tresult.setPreviousAutoMrMergedError(e.getMessage());\n\t\t}\n\t}\n\n\tprivate void handleSkipEvent(MergeRequestSimple mrEvent, String gitlabEventUUID, String mrState, String mrAction) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Skip event for Project: '%d', User: '%d', Target: '%s', MergeRequestNumber: '%d', State: '%s', Action: '%s'\",\n\t\t\t\tgitlabEventUUID, mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);\n\t}\n\n\tprivate void mergePreviousAutoMr(CascadeResult result, String gitlabEventUUID, Long projectId, String sourceBranch, String prevSourceBranch) {\n\t\tString branchPattern = addMrPrefixPattern(prevSourceBranch);\n\n\t\tgetOpenMergeRequests(gitlabEventUUID, projectId)\n\t\t\t\t.filter(openMr -> openMr.getTargetBranch().equals(sourceBranch) &&\n\t\t\t\t\t\topenMr.getSourceBranch().matches(branchPattern))\n\t\t\t\t.sorted(Comparator.comparingLong(MergeRequest::getIid))\n\t\t\t\t.findFirst()\n\t\t\t\t.ifPresent(mr -> {\n\t\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Found auto merge request between '%s' and '%s' - iid: '%s', mergeWhenPipelineSucceeds: '%s'\", gitlabEventUUID, prevSourceBranch, sourceBranch, mr.getIid(), mr.getMergeWhenPipelineSucceeds());", "\t\t\t\t\tif (mr.getMergeWhenPipelineSucceeds() == Boolean.FALSE) {\n\t\t\t\t\t\tMergeRequestResult mrResult = acceptAutoMergeRequest(gitlabEventUUID, mr);\n\t\t\t\t\t\tresult.setPreviousAutoMrMerged(mrResult);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate void createAutoMr(CascadeResult result, String gitlabEventUUID, Long projectId, String prevMrSourceBranch, String sourceBranch, Long mrNumber, String mergeSha) {\n\t\tString branchModel = getBranchModelConfigurationFile(gitlabEventUUID, projectId, mergeSha);\n\t\tString nextMainBranch = ConfigurationUtils.getNextTargetBranch(branchModel, sourceBranch);\n", "\t\tif (nextMainBranch != null) {\n\t\t\tBranch branch = getBranch(gitlabEventUUID, projectId, nextMainBranch);\n\t\t\tif (!Branch.isValid(branch)) {\n\t\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Branch named '%s' does not exist in project '%d'. Please check the ucascade configuration file.\", gitlabEventUUID, nextMainBranch, projectId));\n\t\t\t}\n\t\t\tif (haveDiff(gitlabEventUUID, projectId, mergeSha, nextMainBranch)) {\n\t\t\t\tString tmpBranchName = \"mr\" + mrNumber + \"_\" + sourceBranch;\n\t\t\t\tcreateBranch(gitlabEventUUID, projectId, tmpBranchName, mergeSha);\n\t\t\t\tMergeRequestResult mrResult = merge(gitlabEventUUID, projectId, sourceBranch, mrNumber, tmpBranchName, nextMainBranch);\n\t\t\t\tresult.setCreatedAutoMr(mrResult);\n\t\t\t} else {\n\t\t\t\tLog.infof(\"GitlabEvent: '%s' | No diff between commit '%s' and branch '%s' - nothing to do\", gitlabEventUUID, mergeSha, nextMainBranch);\n\t\t\t}\n\t\t} else {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | No target branch for '%s' found - nothing to do\", gitlabEventUUID, sourceBranch);\n\t\t}\n\t}\n\n\tprivate void deleteExistingBranch(CascadeResult result, String gitlabEventUUID, Long projectId, String prevMrSourceBranch) {", "\t\tif (prevMrSourceBranch.matches(UCASCADE_BRANCH_PATTERN)) {\n\t\t\tboolean deleted = deleteBranch(projectId, prevMrSourceBranch);\n\t\t\tif (deleted) {\n\t\t\t\tresult.setExistingBranchDelete(new DeleteBranchResult(prevMrSourceBranch));\n\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Deleted branch '%s'\", gitlabEventUUID, prevMrSourceBranch);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Branch createBranch(String gitlabEventUUID, Long project, String branchName, String ref) {\n\t\ttry {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Creating branch: '%s' from '%s'\", gitlabEventUUID, branchName, ref);\n\t\t\treturn gitlab.getRepositoryApi().createBranch(project, branchName, ref);\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot create branch named '%s' from '%s' in project '%d'\", gitlabEventUUID, branchName, ref, project), e);\n\t\t}\n\t}\n\n\tprivate MergeRequestResult merge(String gitlabEventUUID, Long project, String sourceBranchOfSourceBranch, Long prevMergedMRNumber, String sourceBranch, String targetBranch) {\n\t\tMergeRequest mr = createAutoMergeRequest(gitlabEventUUID, project, prevMergedMRNumber, sourceBranch, targetBranch);\n\t\tLong iid = mr.getIid();\n\n\t\t// approve auto merge-request", "\t\ttry {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Creating branch: '%s' from '%s'\", gitlabEventUUID, branchName, ref);\n\t\t\treturn gitlab.getRepositoryApi().createBranch(project, branchName, ref);\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot create branch named '%s' from '%s' in project '%d'\", gitlabEventUUID, branchName, ref, project), e);\n\t\t}\n\t}\n\n\tprivate MergeRequestResult merge(String gitlabEventUUID, Long project, String sourceBranchOfSourceBranch, Long prevMergedMRNumber, String sourceBranch, String targetBranch) {\n\t\tMergeRequest mr = createAutoMergeRequest(gitlabEventUUID, project, prevMergedMRNumber, sourceBranch, targetBranch);\n\t\tLong iid = mr.getIid();\n\n\t\t// approve auto merge-request", "\t\tif (gitlabApprover != null) {\n\t\t\tapproveMergeRequest(gitlabEventUUID, mr);\n\t\t}\n\n\t\tString branchPattern = addMrPrefixPattern(sourceBranchOfSourceBranch);\n\n\t\t// do not merge if other merge requests exist between the same source and target branches\n\t\tOptional<MergeRequest> findConcurrentMr = getOpenMergeRequests(gitlabEventUUID, project)\n\t\t\t\t.filter(openMr -> openMr.getIid() < iid &&\n\t\t\t\t\t\topenMr.getSourceBranch().matches(branchPattern) &&\n\t\t\t\t\t\topenMr.getTargetBranch().equals(targetBranch))\n\t\t\t\t.sorted(Comparator.comparingLong(MergeRequest::getIid))\n\t\t\t\t.findFirst();", "\t\tif (findConcurrentMr.isEmpty()) {\n\t\t\treturn acceptAutoMergeRequest(gitlabEventUUID, mr);\n\t\t}\n\t\tMergeRequestResult result = new MergeRequestResult(mr);\n\t\tresult.setUcascadeState(MergeRequestUcascadeState.NOT_MERGED_CONCURRENT_MRS);\n\t\tLog.infof(\"GitlabEvent: '%s' | MR '!%d' in project '%d' was not merged, because of concurrent MR already open '%d'\", gitlabEventUUID, mr.getIid(), project, findConcurrentMr.get().getIid());\n\t\treturn result;\n\t}\n\n\tprivate MergeRequest createAutoMergeRequest(String gitlabEventUUID, Long project, Long prevMergedMRNumber, String sourceBranch, String targetBranch) {\n\t\tString description = buildDescription(gitlabEventUUID, project, sourceBranch, targetBranch);\n\t\tString sourceBranchPretty = removeMrPrefixPattern(sourceBranch);\n\t\tMergeRequestParams mrParams = new MergeRequestParams();\n\t\tmrParams.withSourceBranch(sourceBranch);\n\t\tmrParams.withTargetBranch(targetBranch);\n\t\tmrParams.withTitle(String.format(\"%s Auto MR: '%s' -> '%s' (!%d)\", UCASCADE_TAG, sourceBranchPretty, targetBranch, prevMergedMRNumber));\n\t\tmrParams.withDescription(description);\n\t\tmrParams.withAssigneeId(ucascadeUser);\n\t\tmrParams.withRemoveSourceBranch(true);\n\n\t\tMergeRequest mr;", "\t\ttry {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Creating MR: '%s' -> '%s'\", gitlabEventUUID, sourceBranch, targetBranch);\n\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\tmr = mrApi.createMergeRequest(project, mrParams);\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot create merge request from '%s' into '%s' in project '%d'\", gitlabEventUUID, sourceBranch, targetBranch, project), e);\n\t\t}\n\n\t\treturn mr;\n\t}\n\n\tprivate String buildDescription(String gitlabEventUUID, Long project, String sourceBranch, String targetBranch) {\n\t\tStringBuilder descriptionBuilder = new StringBuilder(\"Automatic cascade merge request: \");\n\t\tDeque<String> cascadedBranches = getCascadedBranches(gitlabEventUUID, project, sourceBranch, targetBranch);", "\t\tfor (String branch : cascadedBranches) {\n\t\t\tdescriptionBuilder.append(String.format(\"%s\", branch));\n\t\t}\n\t\treturn descriptionBuilder.toString();\n\t}\n\n\tprivate Deque<String> getCascadedBranches(String gitlabEventUUID, Long project, String sourceBranch, String targetBranch) {\n\t\tDeque<String> cascadedBranches = new ArrayDeque<>();\n\t\tfinal String separator = \"-->\";\n\t\tcascadedBranches.push(formatCascadeElement(null, null, targetBranch));\n\t\tLong pastMrNumber = null;\n\t\tLong currMrNumber = getPrevMergeRequestNumber(sourceBranch);\n\t\tcascadedBranches.push(formatCascadeElement(separator, null, sourceBranch));", "\t\twhile (currMrNumber != null && !currMrNumber.equals(pastMrNumber)) {\n\t\t\tMergeRequest currMr = getMr(gitlabEventUUID, project, currMrNumber);\n\t\t\tif (currMr != null) {\n\t\t\t\tpastMrNumber = currMrNumber;\n\t\t\t\tString itBranch = currMr.getSourceBranch();\n\t\t\t\tcascadedBranches.push(formatCascadeElement(separator, currMrNumber, itBranch));\n\t\t\t\tcurrMrNumber = getPrevMergeRequestNumber(itBranch);\n\t\t\t}\n\t\t}\n\n\t\treturn cascadedBranches;\n\t}\n\n\tprivate MergeRequest approveMergeRequest(String gitlabEventUUID, MergeRequest mr) {\n\t\tfinal Long project = mr.getProjectId();\n\t\tfinal Long mrNumber = mr.getIid();\n\t\tMergeRequestApi mrApi = gitlabApprover.getMergeRequestApi();", "\t\ttry {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Approving MR '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project);\n\t\t\tmr = mrApi.approveMergeRequest(project, mrNumber, null);\n\t\t} catch (GitLabApiException e) {\n\t\t\tassignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot approve merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project), e);\n\t\t}\n\n\t\treturn mr;\n\t}\n\n\tprivate boolean isMergeRequestApproved(String gitlabEventUUID, MergeRequest mr) {\n\t\tfinal Long project = mr.getProjectId();\n\t\tfinal Long mrNumber = mr.getIid();", "\t\ttry {\n\t\t\treturn gitlab.getMergeRequestApi()\n\t\t\t\t\t.getApprovals(project, mrNumber)\n\t\t\t\t\t.getApprovalsLeft() <= 0;\n\t\t} catch (GitLabApiException e) {\n\t\t\tassignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve approvals for merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project), e);\n\t\t}\n\t}\n\n\tprivate MergeRequestResult acceptAutoMergeRequest(String gitlabEventUUID, MergeRequest mr) {\n\t\tfinal Long mrNumber = mr.getIid();\n\t\tfinal Long project = mr.getProjectId();\n", "\t\tif (!isMergeRequestApproved(gitlabEventUUID, mr)) {\n\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tLog.warnf(\"GitlabEvent: '%s' | Merge request '!%d' in project '%d' cannot be accepted because it does not have the required amount of approvals\", gitlabEventUUID, mrNumber, project);\n\t\t\tMergeRequestResult result = new MergeRequestResult(mr);\n\t\t\tresult.setUcascadeState(MergeRequestUcascadeState.NOT_MERGED_MISSING_APPROVALS);\n\t\t\treturn result;\n\t\t}\n\n\t\t// wait for MR to leave the checking stage\n\t\tmr = waitForMrToLeaveCheckingStage(gitlabEventUUID, mr);\n\t\tString mergeStatus = mr.getDetailedMergeStatus();\n\n\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\tMergeRequestUcascadeState state = MergeRequestUcascadeState.NOT_MERGED_UNKNOWN_REASON;", "\t\tif (mergeStatus.matches(\"mergeable|ci_still_running|ci_must_pass\")) {\n\t\t\t// Prepare merge:\n\t\t\tString sourceBranch = mr.getSourceBranch();\n\t\t\tString sourceBranchPretty = removeMrPrefixPattern(sourceBranch);\n\t\t\tString targetBranch = mr.getTargetBranch();\n\t\t\tAcceptMergeRequestParams acceptMrParams = new AcceptMergeRequestParams()\n\t\t\t\t\t.withMergeCommitMessage(String.format(\"%s Automatic merge: '%s' -> '%s'\", UCASCADE_TAG, sourceBranchPretty, targetBranch))\n\t\t\t\t\t.withShouldRemoveSourceBranch(mr.getForceRemoveSourceBranch());\n\n\t\t\tint countDown = MAX_RETRY_ATTEMPTS;\n\t\t\twhile (state != MergeRequestUcascadeState.MERGED && countDown-- > 0) {\n\t\t\t\tboolean hasPipeline = hasPipeline(gitlabEventUUID, mr);\n\t\t\t\tacceptMrParams.withMergeWhenPipelineSucceeds(hasPipeline);\n\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Merging MR '!%d': '%s' -> '%s' when pipeline succeeds: '%b'\", gitlabEventUUID, mrNumber, sourceBranch, targetBranch, hasPipeline);", "\t\t\twhile (state != MergeRequestUcascadeState.MERGED && countDown-- > 0) {\n\t\t\t\tboolean hasPipeline = hasPipeline(gitlabEventUUID, mr);\n\t\t\t\tacceptMrParams.withMergeWhenPipelineSucceeds(hasPipeline);\n\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Merging MR '!%d': '%s' -> '%s' when pipeline succeeds: '%b'\", gitlabEventUUID, mrNumber, sourceBranch, targetBranch, hasPipeline);\n\t\t\t\ttry {\n\t\t\t\t\tmr = mrApi.acceptMergeRequest(project, mrNumber, acceptMrParams);\n\t\t\t\t\tstate = MergeRequestUcascadeState.MERGED;\n\t\t\t\t} catch (GitLabApiException e) {\n\t\t\t\t\tif (countDown == 0) {\n\t\t\t\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Cannot accept merge request '!%d' from '%s' into '%s' in project '%d'\", gitlabEventUUID, mrNumber, sourceBranch, targetBranch, project);\n\t\t\t\t\t\tstate = MergeRequestUcascadeState.NOT_MERGED_UNKNOWN_REASON;\n\t\t\t\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Merge failed for MR '!%d', status '%s'. Retrying... %d\", gitlabEventUUID, mrNumber, mergeStatus, Math.abs(countDown - MAX_RETRY_ATTEMPTS));", "\t\t\t\t\tif (countDown == 0) {\n\t\t\t\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Cannot accept merge request '!%d' from '%s' into '%s' in project '%d'\", gitlabEventUUID, mrNumber, sourceBranch, targetBranch, project);\n\t\t\t\t\t\tstate = MergeRequestUcascadeState.NOT_MERGED_UNKNOWN_REASON;\n\t\t\t\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Merge failed for MR '!%d', status '%s'. Retrying... %d\", gitlabEventUUID, mrNumber, mergeStatus, Math.abs(countDown - MAX_RETRY_ATTEMPTS));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\t\t\t\t} catch (InterruptedException ie) {\n\t\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// if possible, assign merge responsibility to a real user\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Automatic merge failed - status: '%s'. Finding cascade responsible for MR '!%d'\", gitlabEventUUID, mergeStatus, mrNumber);\n\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tboolean hasConflicts = mr.getHasConflicts() != null && mr.getHasConflicts();", "\t\t\tif (hasConflicts) {\n\t\t\t\tLog.infof(\"GitlabEvent: '%s' | Abort: conflict detected in MR '!%d'\", gitlabEventUUID, mr.getIid());\n\t\t\t\tstate = MergeRequestUcascadeState.NOT_MERGED_CONFLICTS;\n\t\t\t} else {\n\t\t\t\tLog.warnf(\"GitlabEvent: '%s' | MR '!%d' cannot be merged for unknown reasons\", gitlabEventUUID, mrNumber);\n\t\t\t}\n\t\t}\n\n\t\tMergeRequestResult result = new MergeRequestResult(mr);\n\t\tresult.setUcascadeState(state);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Assign a merge-request to the cascade responsible user(s). The cascade responsible users are all the assignees plus the merger of the merge-request that\n\t * initiated the cascade.\n\t *\n\t * @param gitlabEventUUID the gitlab event UUID\n\t * @param mr the merge-request that will be assigned to the cascade responsible\n\t * @return the updated merge-request object, where the assignee is the cascade responsible user\n\t */\n\tprivate MergeRequest assignMrToCascadeResponsible(String gitlabEventUUID, MergeRequest mr) {\n\t\tfinal Long mrNumber = mr.getIid();\n\t\tfinal Long project = mr.getProjectId();\n\t\tList<Long> cascadeResponsibleIds = getCascadeResponsibleIds(gitlabEventUUID, project, getPrevMergeRequestNumber(mr.getSourceBranch()));", "\t\tif (cascadeResponsibleIds != null) {\n\t\t\tLog.infof(\"GitlabEvent: '%s' | Assigning MR '!%d' to cascade responsible(s) with id(s): '%s'\", gitlabEventUUID, mrNumber, cascadeResponsibleIds);\n\t\t\ttry {\n\t\t\t\tMergeRequestParams mrParams = new MergeRequestParams();\n\t\t\t\tmrParams.withAssigneeIds(cascadeResponsibleIds);\n\t\t\t\tmr = gitlab.getMergeRequestApi().updateMergeRequest(project, mrNumber, mrParams);\n\t\t\t} catch (GitLabApiException e) {\n\t\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | MR '!%d' cannot change the assignee to user %d\", gitlabEventUUID, mrNumber, cascadeResponsibleIds);\n\t\t\t}\n\t\t}\n\t\treturn mr;\n\t}\n\n\tprivate String addMrPrefixPattern(String branchName) {\n\t\treturn UCASCADE_BRANCH_PATTERN_PREFIX + Pattern.quote(branchName);\n\t}\n\n\tprivate MergeRequest waitForMrToLeaveCheckingStage(String gitlabEventUUID, MergeRequest mr) {\n\t\tint countDown = MAX_RETRY_ATTEMPTS;\n\t\tString mrStatus = mr.getDetailedMergeStatus();", "\t\twhile (mrStatus.matches(\"unchecked|checking|preparing\") && countDown-- > 0) {\n\t\t\ttry {\n\t\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// update local object\n\t\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\t\tmr = mrApi.getMergeRequest(mr.getProjectId(), mr.getIid());\n\t\t\t\tmrStatus = mr.getDetailedMergeStatus();\n\t\t\t} catch (GitLabApiException e) {\n\t\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve MR '!%d'\", gitlabEventUUID, mr.getIid()), e);\n\t\t\t}\n\t\t}\n", "\t\tif (countDown < 0) {\n\t\t\tmr = assignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Timeout: MR '!%d' is locked in the '%s' status\", gitlabEventUUID, mr.getIid(), mrStatus));\n\t\t}\n\t\treturn mr;\n\t}\n\n\tprivate Branch getBranch(String gitlabEventUUID, Long project, String branchName) {\n\t\ttry {\n\t\t\treturn gitlab.getRepositoryApi().getBranch(project, branchName);\n\t\t} catch (GitLabApiException e) {", "\t\ttry {\n\t\t\treturn gitlab.getRepositoryApi().getBranch(project, branchName);\n\t\t} catch (GitLabApiException e) {\n\t\t\tif (e.getHttpStatus() == 404) {\n\t\t\t\t// if the branch doesn't exist, return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve branch '%s'\", gitlabEventUUID, branchName), e);\n\t\t}\n\t}\n\n\tprivate boolean deleteBranch(Long project, String branchName) {", "\t\ttry {\n\t\t\tgitlab.getRepositoryApi().deleteBranch(project, branchName);\n\t\t\treturn true;\n\t\t} catch (GitLabApiException e) {\n\t\t\t// fail silently\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate Stream<MergeRequest> getOpenMergeRequests(String gitlabEventUUID, Long project) {\n\t\ttry {\n\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\treturn mrApi.getMergeRequestsStream(project, MergeRequestState.OPENED);\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve open merge requests for project '%d' in '%s'\", gitlabEventUUID, project, gitLabHost), e);\n\t\t}\n\t}\n\n\tprivate String getBranchModelConfigurationFile(String gitlabEventUUID, Long project, String ref) {", "\t\ttry {\n\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\treturn mrApi.getMergeRequestsStream(project, MergeRequestState.OPENED);\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve open merge requests for project '%d' in '%s'\", gitlabEventUUID, project, gitLabHost), e);\n\t\t}\n\t}\n\n\tprivate String getBranchModelConfigurationFile(String gitlabEventUUID, Long project, String ref) {\n\t\ttry {\n\t\t\tString encodedContent = gitlab.getRepositoryFileApi().getFile(project, UCASCADE_CONFIGURATION_FILE, ref).getContent();\n\t\t\treturn new String(Base64.getDecoder().decode(encodedContent));\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Configuration file '%s' not found in remote repository at '%s'\", gitlabEventUUID, UCASCADE_CONFIGURATION_FILE, ref), e);\n\t\t}\n\t}\n\n\tprivate boolean hasPipeline(String gitlabEventUUID, MergeRequest mr) {", "\t\ttry {\n\t\t\tString encodedContent = gitlab.getRepositoryFileApi().getFile(project, UCASCADE_CONFIGURATION_FILE, ref).getContent();\n\t\t\treturn new String(Base64.getDecoder().decode(encodedContent));\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Configuration file '%s' not found in remote repository at '%s'\", gitlabEventUUID, UCASCADE_CONFIGURATION_FILE, ref), e);\n\t\t}\n\t}\n\n\tprivate boolean hasPipeline(String gitlabEventUUID, MergeRequest mr) {\n\t\ttry {\n\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\treturn !mrApi.getMergeRequestPipelines(mr.getProjectId(), mr.getIid()).isEmpty();\n\t\t} catch (GitLabApiException e) {\n\t\t\tassignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve pipelines for merge request '!%d' in project '%d'\", gitlabEventUUID, mr.getIid(), mr.getProjectId()), e);\n\t\t}\n\t}\n\n\tprivate boolean haveDiff(String gitlabEventUUID, Long project, String from, String to) {", "\t\ttry {\n\t\t\tMergeRequestApi mrApi = gitlab.getMergeRequestApi();\n\t\t\treturn !mrApi.getMergeRequestPipelines(mr.getProjectId(), mr.getIid()).isEmpty();\n\t\t} catch (GitLabApiException e) {\n\t\t\tassignMrToCascadeResponsible(gitlabEventUUID, mr);\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot retrieve pipelines for merge request '!%d' in project '%d'\", gitlabEventUUID, mr.getIid(), mr.getProjectId()), e);\n\t\t}\n\t}\n\n\tprivate boolean haveDiff(String gitlabEventUUID, Long project, String from, String to) {\n\t\ttry {\n\t\t\treturn !gitlab.getRepositoryApi().compare(project, from, to, true).getDiffs().isEmpty();\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot get branch diff from '%s' to '%s' in project '%d'\", gitlabEventUUID, from, to, project), e);\n\t\t}\n\t}\n\n\tprivate List<Long> getCascadeResponsibleIds(String gitlabEventUUID, Long project, Long mrNumber) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Backtracing cascade responsible: get merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project);\n\t\tMergeRequest mr = getMr(gitlabEventUUID, project, mrNumber);", "\t\ttry {\n\t\t\treturn !gitlab.getRepositoryApi().compare(project, from, to, true).getDiffs().isEmpty();\n\t\t} catch (GitLabApiException e) {\n\t\t\tthrow new IllegalStateException(String.format(\"GitlabEvent: '%s' | Cannot get branch diff from '%s' to '%s' in project '%d'\", gitlabEventUUID, from, to, project), e);\n\t\t}\n\t}\n\n\tprivate List<Long> getCascadeResponsibleIds(String gitlabEventUUID, Long project, Long mrNumber) {\n\t\tLog.infof(\"GitlabEvent: '%s' | Backtracing cascade responsible: get merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project);\n\t\tMergeRequest mr = getMr(gitlabEventUUID, project, mrNumber);\n\t\tif (mr == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tLong mrMerger = mr.getMergeUser().getId();\n\t\tLog.infof(\"GitlabEvent: '%s' | MR merger has id '%d', ucascade user has id '%d'\", gitlabEventUUID, mrMerger, ucascadeUser);\n", "\t\tif (mr == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tLong mrMerger = mr.getMergeUser().getId();\n\t\tLog.infof(\"GitlabEvent: '%s' | MR merger has id '%d', ucascade user has id '%d'\", gitlabEventUUID, mrMerger, ucascadeUser);\n\n\t\tif (!Objects.equals(mrMerger, ucascadeUser)) {\n\t\t\t// success exit point, found the origin mr\n\t\t\tList<Long> cascadeResponsibleIds = mr.getAssignees().stream().map(Assignee::getId).collect(Collectors.toList());\n\t\t\tif (!cascadeResponsibleIds.contains(mrMerger)) {\n\t\t\t\tcascadeResponsibleIds.add(mrMerger);\n\t\t\t}\n\t\t\treturn cascadeResponsibleIds;\n\t\t}\n\n\t\tLong prevMRNumber = getPrevMergeRequestNumber(mr.getSourceBranch());", "\t\t\tif (!cascadeResponsibleIds.contains(mrMerger)) {\n\t\t\t\tcascadeResponsibleIds.add(mrMerger);\n\t\t\t}\n\t\t\treturn cascadeResponsibleIds;\n\t\t}\n\n\t\tLong prevMRNumber = getPrevMergeRequestNumber(mr.getSourceBranch());\n\t\tif (prevMRNumber == null) {\n\t\t\t// could not find the previous mr\n\t\t\tLog.warnf(\"GitlabEvent: '%s' | Cannot get cascade responsible of merge request '!%d' in project '%d' (could not compute the previous MR)\", gitlabEventUUID, mrNumber, project);\n\t\t\treturn null;\n\t\t}\n\n\t\t// get the cascade responsible for the previous mr\n\t\tList<Long> cascadeResponsibleIds = getCascadeResponsibleIds(gitlabEventUUID, project, prevMRNumber);", "\t\tif (cascadeResponsibleIds == null) {\n\t\t\tLog.warnf(\"GitlabEvent: '%s' | Cannot get cascade responsible of merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project);\n\t\t}\n\t\treturn cascadeResponsibleIds;\n\t}\n\n\tprivate MergeRequest getMr(String gitlabEventUUID, Long project, Long mrNumber) {\n\t\ttry {\n\t\t\treturn gitlab.getMergeRequestApi().getMergeRequest(project, mrNumber);\n\t\t} catch (GitLabApiException e) {\n\t\t\tLog.warnf(e, \"GitlabEvent: '%s' | Cannot get merge request '!%d' in project '%d'\", gitlabEventUUID, mrNumber, project);\n\t\t\treturn null;\n\t\t}\n\t}\n", "\tpublic static Long getPrevMergeRequestNumber(String sourceBranchName) {\n\t\tPattern prevMRNumberPattern = Pattern.compile(UCASCADE_BRANCH_PATTERN);\n\t\tMatcher matcher = prevMRNumberPattern.matcher(sourceBranchName);\n\t\tif (matcher.find()) {\n\t\t\treturn Long.valueOf(matcher.group(1));\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static String removeMrPrefixPattern(String sourceBranch) {\n\t\treturn sourceBranch.replaceFirst(UCASCADE_BRANCH_PATTERN_PREFIX, \"\");\n\t}\n", "\tpublic static String formatCascadeElement(String separator, Long mrNumber, String branchName) {\n\t\tif (mrNumber == null && separator == null) {\n\t\t\treturn String.format(\"`%s`\", removeMrPrefixPattern(branchName));\n\t\t} else if (separator == null) {\n\t\t\treturn String.format(\"`%s` !%d \", removeMrPrefixPattern(branchName), mrNumber);\n\t\t} else if (mrNumber == null) {\n\t\t\treturn String.format(\"`%s` %s \", removeMrPrefixPattern(branchName), separator);\n\t\t} else {\n\t\t\treturn String.format(\"`%s` !%d %s \", removeMrPrefixPattern(branchName), mrNumber, separator);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/configuration/ObjectMapperConfiguration.java", "chunked_list": ["package configuration;\n\nimport javax.enterprise.inject.Instance;\nimport javax.inject.Singleton;\n\nimport org.gitlab4j.api.utils.JacksonJson;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\n", "import com.fasterxml.jackson.databind.SerializationFeature;\n\nimport io.quarkus.jackson.ObjectMapperCustomizer;\n\npublic class ObjectMapperConfiguration {\n\n\t@Singleton\n\tObjectMapper objectMapper(Instance<ObjectMapperCustomizer> customizers) {\n\t\treturn new JacksonJson().getObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n\t}\n}\n"]}
