{"filename": "src/test/java/net/verotek/twitch/chatters/dtos/UserDtoTests.java", "chunked_list": ["package net.verotek.twitch.chatters.dtos;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UserDtoTests {\n\n  @Test\n  void testHashCodeById() {\n    UserDto user1 = new UserDto(\"123\", \"\");\n    UserDto user2 = new UserDto(\"123\", \"test\");\n\n    assertThat(user1.hashCode()).isEqualTo(user2.hashCode());\n  }\n}\n"]}
{"filename": "src/test/java/net/verotek/twitch/chatters/models/ChannelTests.java", "chunked_list": ["package net.verotek.twitch.chatters.models;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.github.philippheuer.credentialmanager.domain.OAuth2Credential;\nimport com.github.twitch4j.auth.domain.TwitchScopes;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;", "import java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass ChannelTests {\n\n  @Test\n  void testPastDateIsExpired() {\n    Channel channel = new Channel();\n    Date pastDate = new Date(new Date().getTime() / 2);\n    channel.setExpiresAt(pastDate);", "    Date pastDate = new Date(new Date().getTime() / 2);\n    channel.setExpiresAt(pastDate);\n\n    assertThat(channel.isAccessTokenExpired()).isTrue();\n  }\n\n  @Test\n  void testFutureDateIsNotExpired() {\n    Channel channel = new Channel();\n    Date pastDate = new Date(new Date().getTime() + 10 * 1000);", "    Channel channel = new Channel();\n    Date pastDate = new Date(new Date().getTime() + 10 * 1000);\n    channel.setExpiresAt(pastDate);\n\n    assertThat(channel.isAccessTokenExpired()).isFalse();\n  }\n\n  @Test\n  void testChannelConvertsScopes() {\n    List<TwitchScopes> scopes = new ArrayList<>();", "  void testChannelConvertsScopes() {\n    List<TwitchScopes> scopes = new ArrayList<>();\n    scopes.add(TwitchScopes.HELIX_AUTOMOD_SETTINGS_MANAGE);\n    scopes.add(TwitchScopes.HELIX_CHANNEL_VIPS_MANAGE);\n\n    List<String> scopeNames = scopes.stream().map(Enum::toString).toList();\n    OAuth2Credential credential =\n        new OAuth2Credential(null, \"\", null, null, null, null, scopeNames);\n    Channel channel = new Channel(credential);\n", "    Channel channel = new Channel(credential);\n\n    assertThat(channel.getScopes()).isEqualTo(scopes);\n  }\n}\n"]}
{"filename": "src/test/java/net/verotek/twitch/chatters/services/TwitchServiceTests.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport com.github.twitch4j.helix.domain.ChannelVip;\nimport com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.Moderator;", "import com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.Moderator;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport net.verotek.twitch.chatters.dtos.ChattersDto;\nimport net.verotek.twitch.chatters.dtos.UserDto;\nimport org.junit.jupiter.api.Test;\nimport org.modelmapper.ModelMapper;", "import org.junit.jupiter.api.Test;\nimport org.modelmapper.ModelMapper;\n\nclass TwitchServiceTests {\n\n  private static final ModelMapper MAPPER = new ModelMapper();\n\n  private HelixWrapperService mockHelixWrapper(\n      Set<Moderator> moderators, Set<ChannelVip> vips, Set<Chatter> chatters) {\n    HelixWrapperService helixWrapper = mock(HelixWrapperService.class);", "      Set<Moderator> moderators, Set<ChannelVip> vips, Set<Chatter> chatters) {\n    HelixWrapperService helixWrapper = mock(HelixWrapperService.class);\n    when(helixWrapper.fetchModerators(any(), any())).thenReturn(moderators);\n    when(helixWrapper.fetchVips(any(), any())).thenReturn(vips);\n    when(helixWrapper.fetchChatters(any(), any())).thenReturn(chatters);\n\n    return helixWrapper;\n  }\n\n  private UserDto mapToUser(Object obj) {", "\n  private UserDto mapToUser(Object obj) {\n    return MAPPER.map(obj, UserDto.class);\n  }\n\n  private Set<UserDto> mapToUsers(Collection<?> collection) {\n    return collection.stream().map(this::mapToUser).collect(Collectors.toSet());\n  }\n\n  @Test", "\n  @Test\n  void testGetModerators() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<Moderator> moderators = new HashSet<>();\n    moderators.add(helixMock.mockModerator(\"56\", \"mod1\"));\n    moderators.add(helixMock.mockModerator(\"95\", \"mod2\"));\n    moderators.add(helixMock.mockModerator(\"29\", \"mod3\"));\n", "    moderators.add(helixMock.mockModerator(\"29\", \"mod3\"));\n\n    Set<UserDto> expectedUsers = mapToUsers(moderators);\n\n    HelixWrapperService helixWrapperMock = mockHelixWrapper(moderators, null, null);\n    TwitchService twitchService = new TwitchService(MAPPER, helixWrapperMock);\n    Set<UserDto> users = twitchService.getModerators(null, null);\n\n    assertThat(users).isEqualTo(expectedUsers);\n  }", "    assertThat(users).isEqualTo(expectedUsers);\n  }\n\n  @Test\n  void testGetVips() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<ChannelVip> vips = new HashSet<>();\n    vips.add(helixMock.mockVip(\"19\", \"vip1\"));\n    vips.add(helixMock.mockVip(\"64\", \"vip2\"));", "    vips.add(helixMock.mockVip(\"19\", \"vip1\"));\n    vips.add(helixMock.mockVip(\"64\", \"vip2\"));\n    vips.add(helixMock.mockVip(\"94\", \"vip3\"));\n\n    Set<UserDto> expectedUsers = mapToUsers(vips);\n\n    HelixWrapperService helixWrapperMock = mockHelixWrapper(null, vips, null);\n    TwitchService twitchService = new TwitchService(MAPPER, helixWrapperMock);\n    Set<UserDto> users = twitchService.getVips(null, null);\n", "    Set<UserDto> users = twitchService.getVips(null, null);\n\n    assertThat(users).isEqualTo(expectedUsers);\n  }\n\n  @Test\n  void testGetChatters() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<Chatter> chatters = new HashSet<>();", "\n    Set<Chatter> chatters = new HashSet<>();\n    chatters.add(helixMock.mockChatter(\"65\", \"chatter1\"));\n    chatters.add(helixMock.mockChatter(\"96\", \"chatter2\"));\n    chatters.add(helixMock.mockChatter(\"74\", \"chatter3\"));\n\n    Set<UserDto> expectedUsers = mapToUsers(chatters);\n\n    HelixWrapperService helixWrapperMock = mockHelixWrapper(null, null, chatters);\n    TwitchService twitchService = new TwitchService(MAPPER, helixWrapperMock);", "    HelixWrapperService helixWrapperMock = mockHelixWrapper(null, null, chatters);\n    TwitchService twitchService = new TwitchService(MAPPER, helixWrapperMock);\n    Set<UserDto> users = twitchService.getChatters(null, null);\n\n    assertThat(users).isEqualTo(expectedUsers);\n  }\n\n  @Test\n  void testGetCategorizedChatters() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();", "  void testGetCategorizedChatters() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Chatter broadcaster = helixMock.mockChatter(\"14\", \"broadcaster1\");\n\n    Set<Moderator> moderators = new HashSet<>();\n    moderators.add(helixMock.mockModerator(\"17\", \"mod1\"));\n    moderators.add(helixMock.mockModerator(\"34\", \"mod2\"));\n    moderators.add(helixMock.mockModerator(\"95\", \"mod3\"));\n", "    moderators.add(helixMock.mockModerator(\"95\", \"mod3\"));\n\n    Set<ChannelVip> vips = new HashSet<>();\n    vips.add(helixMock.mockVip(\"28\", \"vip5\"));\n    vips.add(helixMock.mockVip(\"16\", \"vip6\"));\n    vips.add(helixMock.mockVip(\"84\", \"vip8\"));\n\n    Set<Chatter> viewers = new HashSet<>();\n    viewers.add(helixMock.mockChatter(\"53\", \"chatter1\"));\n    viewers.add(helixMock.mockChatter(\"80\", \"chatter2\"));", "    viewers.add(helixMock.mockChatter(\"53\", \"chatter1\"));\n    viewers.add(helixMock.mockChatter(\"80\", \"chatter2\"));\n    viewers.add(helixMock.mockChatter(\"67\", \"chatter3\"));\n\n    Set<Chatter> allChatters = new HashSet<>();\n    allChatters.add(broadcaster);\n    allChatters.addAll(helixMock.moderatorsToChatters(moderators));\n    allChatters.addAll(helixMock.vipsToChatters(vips));\n    allChatters.addAll(viewers);\n", "    allChatters.addAll(viewers);\n\n    ChattersDto expectedChatters =\n        new ChattersDto(\n            mapToUser(broadcaster), mapToUsers(moderators), mapToUsers(vips), mapToUsers(viewers));\n\n    HelixWrapperService helixWrapperMock = mockHelixWrapper(moderators, vips, allChatters);\n    TwitchService twitchService = new TwitchService(MAPPER, helixWrapperMock);\n    ChattersDto chatters = twitchService.getCategorizedChatters(broadcaster.getUserId(), null);\n", "    ChattersDto chatters = twitchService.getCategorizedChatters(broadcaster.getUserId(), null);\n\n    assertThat(chatters).isEqualTo(expectedChatters);\n  }\n}\n"]}
{"filename": "src/test/java/net/verotek/twitch/chatters/services/TwitchClientHelixMock.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport com.github.twitch4j.TwitchClient;\nimport com.github.twitch4j.helix.TwitchHelix;\nimport com.github.twitch4j.helix.domain.ChannelVip;", "import com.github.twitch4j.helix.TwitchHelix;\nimport com.github.twitch4j.helix.domain.ChannelVip;\nimport com.github.twitch4j.helix.domain.ChannelVipList;\nimport com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.ChattersList;\nimport com.github.twitch4j.helix.domain.HelixPagination;\nimport com.github.twitch4j.helix.domain.Moderator;\nimport com.github.twitch4j.helix.domain.ModeratorList;\nimport com.netflix.hystrix.HystrixCommand;\nimport java.util.ArrayList;", "import com.netflix.hystrix.HystrixCommand;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class TwitchClientHelixMock {\n\n  private final TwitchClient client = mockHelix();\n\n  private TwitchClient mockHelix() {\n    TwitchClient twitchClient = mock(TwitchClient.class);\n    when(twitchClient.getHelix()).thenReturn(mock(TwitchHelix.class));\n    return twitchClient;\n  }\n\n  private ChannelVipList mockVipList(Set<ChannelVip> vips, String cursor) {\n    HelixPagination pagination = mock(HelixPagination.class);\n    when(pagination.getCursor()).thenReturn(cursor);\n\n    ChannelVipList vipSet = mock(ChannelVipList.class);\n    when(vipSet.getPagination()).thenReturn(pagination);\n    when(vipSet.getData()).thenReturn(new ArrayList<>(vips));\n\n    return vipSet;\n  }\n\n  private ModeratorList mockModeratorList(Set<Moderator> moderators, String cursor) {\n    HelixPagination pagination = mock(HelixPagination.class);\n    when(pagination.getCursor()).thenReturn(cursor);\n\n    ModeratorList moderatorSet = mock(ModeratorList.class);\n    when(moderatorSet.getPagination()).thenReturn(pagination);\n    when(moderatorSet.getModerators()).thenReturn(new ArrayList<>(moderators));\n\n    return moderatorSet;\n  }\n\n  private ChattersList mockChattersList(Set<Chatter> chatters, String cursor) {\n    HelixPagination pagination = mock(HelixPagination.class);\n    when(pagination.getCursor()).thenReturn(cursor);\n\n    ChattersList chattersSet = mock(ChattersList.class);\n    when(chattersSet.getPagination()).thenReturn(pagination);\n    when(chattersSet.getChatters()).thenReturn(new ArrayList<>(chatters));\n\n    return chattersSet;\n  }\n\n  private HystrixCommand<ChannelVipList> mockVipCommand(Set<ChannelVip> vips, String cursor) {\n    ChannelVipList vipSet = mockVipList(vips, cursor);\n    @SuppressWarnings(\"unchecked\")\n    HystrixCommand<ChannelVipList> vipCommand = mock(HystrixCommand.class);\n    when(vipCommand.execute()).thenReturn(vipSet);\n\n    return vipCommand;\n  }\n\n  private HystrixCommand<ModeratorList> mockModeratorCommand(\n      Set<Moderator> moderators, String cursor) {\n    ModeratorList moderatorSet = mockModeratorList(moderators, cursor);\n    @SuppressWarnings(\"unchecked\")\n    HystrixCommand<ModeratorList> moderatorCommand = mock(HystrixCommand.class);\n    when(moderatorCommand.execute()).thenReturn(moderatorSet);\n\n    return moderatorCommand;\n  }\n\n  private HystrixCommand<ChattersList> mockChattersCommand(Set<Chatter> chatters, String cursor) {\n    ChattersList chattersSet = mockChattersList(chatters, cursor);\n    @SuppressWarnings(\"unchecked\")\n    HystrixCommand<ChattersList> chattersCommand = mock(HystrixCommand.class);\n    when(chattersCommand.execute()).thenReturn(chattersSet);\n\n    return chattersCommand;\n  }\n", "  public ChannelVip mockVip(String userId, String username) {\n    ChannelVip vip = mock(ChannelVip.class);\n    when(vip.getUserId()).thenReturn(userId);\n    when(vip.getUserLogin()).thenReturn(username.toLowerCase());\n    when(vip.getUserName()).thenReturn(username);\n\n    return vip;\n  }\n\n  public Moderator mockModerator(String userId, String username) {\n    Moderator moderator = mock(Moderator.class);\n    when(moderator.getUserId()).thenReturn(userId);\n    when(moderator.getUserLogin()).thenReturn(username.toLowerCase());\n    when(moderator.getUserName()).thenReturn(username);\n\n    return moderator;\n  }\n", "  public Moderator mockModerator(String userId, String username) {\n    Moderator moderator = mock(Moderator.class);\n    when(moderator.getUserId()).thenReturn(userId);\n    when(moderator.getUserLogin()).thenReturn(username.toLowerCase());\n    when(moderator.getUserName()).thenReturn(username);\n\n    return moderator;\n  }\n\n  public Chatter mockChatter(String userId, String username) {\n    Chatter chatter = mock(Chatter.class);\n    when(chatter.getUserId()).thenReturn(userId);\n    when(chatter.getUserLogin()).thenReturn(username.toLowerCase());\n    when(chatter.getUserName()).thenReturn(username);\n\n    return chatter;\n  }\n", "  public Chatter mockChatter(String userId, String username) {\n    Chatter chatter = mock(Chatter.class);\n    when(chatter.getUserId()).thenReturn(userId);\n    when(chatter.getUserLogin()).thenReturn(username.toLowerCase());\n    when(chatter.getUserName()).thenReturn(username);\n\n    return chatter;\n  }\n\n  public void addVipPage(Set<ChannelVip> vips, String cursor, String nextCursor) {\n    HystrixCommand<ChannelVipList> vipCommand = mockVipCommand(vips, nextCursor);\n    TwitchHelix helix = client.getHelix();\n    when(helix.getChannelVips(any(), any(), any(), any(), eq(cursor))).thenReturn(vipCommand);\n  }\n", "  public void addVipPage(Set<ChannelVip> vips, String cursor, String nextCursor) {\n    HystrixCommand<ChannelVipList> vipCommand = mockVipCommand(vips, nextCursor);\n    TwitchHelix helix = client.getHelix();\n    when(helix.getChannelVips(any(), any(), any(), any(), eq(cursor))).thenReturn(vipCommand);\n  }\n\n  public void addModeratorPage(Set<Moderator> moderators, String cursor, String nextCursor) {\n    HystrixCommand<ModeratorList> moderatorCommand = mockModeratorCommand(moderators, nextCursor);\n    TwitchHelix helix = client.getHelix();\n    when(helix.getModerators(any(), any(), any(), eq(cursor), any())).thenReturn(moderatorCommand);\n  }\n", "  public void addChattersPage(Set<Chatter> chatters, String cursor, String nextCursor) {\n    HystrixCommand<ChattersList> chattersCommand = mockChattersCommand(chatters, nextCursor);\n    TwitchHelix helix = client.getHelix();\n    when(helix.getChatters(any(), any(), any(), any(), eq(cursor))).thenReturn(chattersCommand);\n  }\n\n  public Set<Chatter> moderatorsToChatters(Set<Moderator> moderators) {\n    return moderators.stream()\n        .map(m -> mockChatter(m.getUserId(), m.getUserName()))\n        .collect(Collectors.toSet());\n  }\n\n  public Set<Chatter> vipsToChatters(Set<ChannelVip> vips) {\n    return vips.stream()\n        .map(v -> mockChatter(v.getUserId(), v.getUserName()))\n        .collect(Collectors.toSet());\n  }\n", "  public TwitchClient getClient() {\n    return client;\n  }\n}\n"]}
{"filename": "src/test/java/net/verotek/twitch/chatters/services/TwitchIdentityServiceTests.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n", "import static org.mockito.Mockito.when;\n\nimport com.github.philippheuer.credentialmanager.domain.OAuth2Credential;\nimport com.github.twitch4j.auth.providers.TwitchIdentityProvider;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Optional;\nimport net.verotek.twitch.chatters.exceptions.ChannelNotFoundException;\nimport net.verotek.twitch.chatters.exceptions.InvalidCodeException;", "import net.verotek.twitch.chatters.exceptions.ChannelNotFoundException;\nimport net.verotek.twitch.chatters.exceptions.InvalidCodeException;\nimport net.verotek.twitch.chatters.exceptions.InvalidScopesException;\nimport net.verotek.twitch.chatters.exceptions.InvalidTokenRequestException;\nimport net.verotek.twitch.chatters.models.Channel;\nimport net.verotek.twitch.chatters.repositories.ChannelRepository;\nimport org.junit.jupiter.api.Test;\n\nclass TwitchIdentityServiceTests {\n", "class TwitchIdentityServiceTests {\n\n  @Test\n  void testAuthorizeCodeRequestFails() {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.getCredentialByCode(any())).thenThrow(new RuntimeException());\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n", "    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThrows(InvalidCodeException.class, () -> identityService.authorize(null));\n  }\n\n  @Test\n  void testAuthorizeAdditionalRequestFails() {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.getAdditionalCredentialInformation(any())).thenReturn(Optional.empty());", "    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.getAdditionalCredentialInformation(any())).thenReturn(Optional.empty());\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThrows(InvalidTokenRequestException.class, () -> identityService.authorize(null));\n  }\n\n  @Test\n  void testAuthorizeEmptyScopeToken() {", "  @Test\n  void testAuthorizeEmptyScopeToken() {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    OAuth2Credential credential = mock(OAuth2Credential.class);\n    when(credential.getScopes()).thenReturn(new ArrayList<>());\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.getAdditionalCredentialInformation(any()))\n        .thenReturn(Optional.of(credential));\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);", "\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThrows(InvalidScopesException.class, () -> identityService.authorize(null));\n  }\n\n  @Test\n  void testAuthorizeSavesValidToken() throws Exception {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    OAuth2Credential credential = mock(OAuth2Credential.class);", "    ChannelRepository repository = mock(ChannelRepository.class);\n    OAuth2Credential credential = mock(OAuth2Credential.class);\n    List<String> requiredScopes =\n        TwitchIdentityService.REQUIRED_SCOPES.stream().map(Enum::toString).toList();\n    when(credential.getScopes()).thenReturn(requiredScopes);\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.getAdditionalCredentialInformation(any()))\n        .thenReturn(Optional.of(credential));\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);", "\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n    identityService.authorize(null);\n\n    verify(repository, times(1)).save(any());\n  }\n\n  @Test\n  void testGetAccessTokenUnregisteredChannel() {\n    ChannelRepository repository = mock(ChannelRepository.class);", "  void testGetAccessTokenUnregisteredChannel() {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    when(repository.findById(any())).thenReturn(Optional.empty());\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThrows(ChannelNotFoundException.class, () -> identityService.getAccessToken(null));\n  }\n", "  }\n\n  @Test\n  void testGetAccessTokenReturnsValidChannelToken() throws Exception {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    String token = \"token\";\n    Date futureDate = new Date(new Date().getTime() * 2);\n    Channel validChannel = new Channel(\"\", \"\", new ArrayList<>(), token, futureDate);\n    when(repository.findById(any())).thenReturn(Optional.of(validChannel));\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);", "    when(repository.findById(any())).thenReturn(Optional.of(validChannel));\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThat(identityService.getAccessToken(null)).isEqualTo(token);\n  }\n\n  @Test\n  void testGetAccessTokenRefreshFails() {", "  @Test\n  void testGetAccessTokenRefreshFails() {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    Date pastDate = new Date(new Date().getTime() / 2);\n    Channel validChannel = new Channel(\"\", \"\", new ArrayList<>(), \"\", pastDate);\n    when(repository.findById(any())).thenReturn(Optional.of(validChannel));\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    when(identityProvider.refreshCredential(any())).thenReturn(Optional.empty());\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);", "\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThrows(InvalidTokenRequestException.class, () -> identityService.getAccessToken(null));\n  }\n\n  @Test\n  void testGetAccessTokenRefreshSaves() throws Exception {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    Date pastDate = new Date(new Date().getTime() / 2);", "    ChannelRepository repository = mock(ChannelRepository.class);\n    Date pastDate = new Date(new Date().getTime() / 2);\n    Channel expiredChannel = new Channel(\"\", \"\", new ArrayList<>(), \"\", pastDate);\n    when(repository.findById(any())).thenReturn(Optional.of(expiredChannel));\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    String token = \"token\";\n    OAuth2Credential credential = new OAuth2Credential(null, token);\n    when(identityProvider.refreshCredential(any())).thenReturn(Optional.of(credential));\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);", "\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n    identityService.getAccessToken(null);\n\n    verify(repository, times(1)).save(any());\n  }\n\n  @Test\n  void testGetAccessTokenRefresh() throws Exception {\n    ChannelRepository repository = mock(ChannelRepository.class);", "  void testGetAccessTokenRefresh() throws Exception {\n    ChannelRepository repository = mock(ChannelRepository.class);\n    Date pastDate = new Date(new Date().getTime() / 2);\n    Channel validChannel = new Channel(\"\", \"\", new ArrayList<>(), \"\", pastDate);\n    when(repository.findById(any())).thenReturn(Optional.of(validChannel));\n    TwitchIdentityProvider identityProvider = mock(TwitchIdentityProvider.class);\n    String token = \"token\";\n    OAuth2Credential credential = new OAuth2Credential(null, token);\n    when(identityProvider.refreshCredential(any())).thenReturn(Optional.of(credential));\n", "    when(identityProvider.refreshCredential(any())).thenReturn(Optional.of(credential));\n\n    TwitchIdentityService identityService = new TwitchIdentityService(repository, identityProvider);\n\n    assertThat(identityService.getAccessToken(null)).isEqualTo(token);\n  }\n}\n"]}
{"filename": "src/test/java/net/verotek/twitch/chatters/services/HelixWrapperTests.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.github.twitch4j.helix.domain.ChannelVip;\nimport com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.Moderator;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;", "import java.util.Set;\nimport org.junit.jupiter.api.Test;\n\nclass HelixWrapperTests {\n\n  @Test\n  void testFetchChatters() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<Chatter> chatters1 = new HashSet<>();", "\n    Set<Chatter> chatters1 = new HashSet<>();\n    chatters1.add(helixMock.mockChatter(\"93\", \"chatter1\"));\n    chatters1.add(helixMock.mockChatter(\"21\", \"chatter2\"));\n\n    Set<Chatter> chatters2 = new HashSet<>();\n    chatters2.add(helixMock.mockChatter(\"53\", \"chatter3\"));\n    chatters2.add(helixMock.mockChatter(\"11\", \"chatter4\"));\n\n    Set<Chatter> allChatters = new HashSet<>();", "\n    Set<Chatter> allChatters = new HashSet<>();\n    allChatters.addAll(chatters1);\n    allChatters.addAll(chatters2);\n\n    helixMock.addChattersPage(chatters1, null, \"cursor1\");\n    helixMock.addChattersPage(chatters2, \"cursor1\", null);\n\n    HelixWrapperService helixWrapper = new HelixWrapperService(helixMock.getClient());\n    Set<Chatter> chatters = helixWrapper.fetchChatters(null, null);", "    HelixWrapperService helixWrapper = new HelixWrapperService(helixMock.getClient());\n    Set<Chatter> chatters = helixWrapper.fetchChatters(null, null);\n\n    assertThat(chatters).isEqualTo(allChatters);\n  }\n\n  @Test\n  void testFetchModerators() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n", "    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<Moderator> moderators1 = new HashSet<>();\n    moderators1.add(helixMock.mockModerator(\"32\", \"mod1\"));\n    moderators1.add(helixMock.mockModerator(\"28\", \"mod2\"));\n\n    Set<Moderator> moderators2 = new HashSet<>();\n    moderators2.add(helixMock.mockModerator(\"64\", \"mod3\"));\n    moderators2.add(helixMock.mockModerator(\"17\", \"mod4\"));\n", "    moderators2.add(helixMock.mockModerator(\"17\", \"mod4\"));\n\n    Set<Moderator> allModerators = new HashSet<>();\n    allModerators.addAll(moderators1);\n    allModerators.addAll(moderators2);\n\n    helixMock.addModeratorPage(moderators1, null, \"cursor1\");\n    helixMock.addModeratorPage(moderators2, \"cursor1\", null);\n\n    HelixWrapperService helixWrapper = new HelixWrapperService(helixMock.getClient());", "\n    HelixWrapperService helixWrapper = new HelixWrapperService(helixMock.getClient());\n    Set<Moderator> moderators = helixWrapper.fetchModerators(null, null);\n\n    assertThat(moderators).isEqualTo(allModerators);\n  }\n\n  @Test\n  void testFetchVips() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();", "  void testFetchVips() {\n    TwitchClientHelixMock helixMock = new TwitchClientHelixMock();\n\n    Set<ChannelVip> vips1 = new HashSet<>();\n    vips1.add(helixMock.mockVip(\"1\", \"user1\"));\n    vips1.add(helixMock.mockVip(\"2\", \"user2\"));\n\n    Set<ChannelVip> vips2 = new HashSet<>();\n    vips2.add(helixMock.mockVip(\"3\", \"user3\"));\n    vips2.add(helixMock.mockVip(\"4\", \"user17\"));", "    vips2.add(helixMock.mockVip(\"3\", \"user3\"));\n    vips2.add(helixMock.mockVip(\"4\", \"user17\"));\n\n    Set<ChannelVip> allVips = new HashSet<>();\n    allVips.addAll(vips1);\n    allVips.addAll(vips2);\n\n    helixMock.addVipPage(vips1, null, \"cursor1\");\n    helixMock.addVipPage(vips2, \"cursor1\", null);\n", "    helixMock.addVipPage(vips2, \"cursor1\", null);\n\n    HelixWrapperService helixWrapper = new HelixWrapperService(helixMock.getClient());\n    Set<ChannelVip> vips = helixWrapper.fetchVips(null, null);\n\n    assertThat(vips).isEqualTo(allVips);\n  }\n}\n", ""]}
{"filename": "src/main/java/net/verotek/twitch/chatters/ChattersApplication.java", "chunked_list": ["package net.verotek.twitch.chatters;\n\nimport com.github.twitch4j.TwitchClient;\nimport com.github.twitch4j.TwitchClientBuilder;\nimport com.github.twitch4j.auth.providers.TwitchIdentityProvider;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;", "import org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\npublic class ChattersApplication {\n\n  public static void main(String[] args) {\n    SpringApplication.run(ChattersApplication.class, args);\n  }\n\n  @Bean", "  public ModelMapper modelMapper() {\n    return new ModelMapper();\n  }\n\n  @Bean\n  public TwitchClient twitchClient() {\n    return TwitchClientBuilder.builder().withEnableHelix(true).build();\n  }\n\n  @Bean\n  public TwitchIdentityProvider identityProvider(\n      @Value(\"${twitch.client_secret}\") String clientSecret,\n      @Value(\"${twitch.client_id}\") String clientId,\n      @Value(\"${twitch.redirect_url}\") String redirectUrl) {\n    return new TwitchIdentityProvider(clientId, clientSecret, redirectUrl);\n  }\n}\n", "  public TwitchIdentityProvider identityProvider(\n      @Value(\"${twitch.client_secret}\") String clientSecret,\n      @Value(\"${twitch.client_id}\") String clientId,\n      @Value(\"${twitch.redirect_url}\") String redirectUrl) {\n    return new TwitchIdentityProvider(clientId, clientSecret, redirectUrl);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/dtos/ChattersDto.java", "chunked_list": ["package net.verotek.twitch.chatters.dtos;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport java.util.HashSet;\nimport java.util.Set;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;", "import lombok.Setter;\nimport lombok.ToString;\n\n@AllArgsConstructor\n@Getter\n@Setter\n@Data\n@ToString\n@Schema(name = \"Chatters\")\npublic class ChattersDto {\n\n  private UserDto broadcaster;\n\n  private Set<UserDto> moderators;\n\n  private Set<UserDto> vips;\n\n  private Set<UserDto> viewers;\n\n  public ChattersDto() {\n    moderators = new HashSet<>();\n    vips = new HashSet<>();\n    viewers = new HashSet<>();\n    broadcaster = null;\n  }\n", "@Schema(name = \"Chatters\")\npublic class ChattersDto {\n\n  private UserDto broadcaster;\n\n  private Set<UserDto> moderators;\n\n  private Set<UserDto> vips;\n\n  private Set<UserDto> viewers;\n\n  public ChattersDto() {\n    moderators = new HashSet<>();\n    vips = new HashSet<>();\n    viewers = new HashSet<>();\n    broadcaster = null;\n  }\n", "  public void setBroadcaster(UserDto broadcaster) {\n    this.broadcaster = broadcaster;\n  }\n\n  public void addModerator(UserDto moderator) {\n    moderators.add(moderator);\n  }\n\n  public void addVip(UserDto vip) {\n    vips.add(vip);\n  }\n", "  public void addVip(UserDto vip) {\n    vips.add(vip);\n  }\n\n  public void addViewer(UserDto viewer) {\n    viewers.add(viewer);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/dtos/ErrorDto.java", "chunked_list": ["package net.verotek.twitch.chatters.dtos;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport java.sql.Timestamp;\nimport java.time.LocalDateTime;\nimport lombok.AccessLevel;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;", "import lombok.Setter;\nimport lombok.ToString;\nimport org.springframework.http.HttpStatus;\n\n@Getter\n@Setter(AccessLevel.PRIVATE)\n@Data\n@ToString\n@Schema(name = \"Error\")\npublic class ErrorDto {\n\n  private Long timestamp;\n\n  private Integer status;\n\n  private String message;\n\n  public ErrorDto() {\n    LocalDateTime currentDate = LocalDateTime.now();\n    Timestamp now = Timestamp.valueOf(currentDate);\n    timestamp = now.getTime();\n  }\n\n  public ErrorDto(Throwable ex, HttpStatus status) {\n    this();\n    this.message = ex.getMessage();\n    this.status = status.value();\n  }\n}\n", "@Schema(name = \"Error\")\npublic class ErrorDto {\n\n  private Long timestamp;\n\n  private Integer status;\n\n  private String message;\n\n  public ErrorDto() {\n    LocalDateTime currentDate = LocalDateTime.now();\n    Timestamp now = Timestamp.valueOf(currentDate);\n    timestamp = now.getTime();\n  }\n\n  public ErrorDto(Throwable ex, HttpStatus status) {\n    this();\n    this.message = ex.getMessage();\n    this.status = status.value();\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/dtos/UserDto.java", "chunked_list": ["package net.verotek.twitch.chatters.dtos;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport java.util.Objects;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\nimport lombok.ToString;", "import lombok.Setter;\nimport lombok.ToString;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Getter\n@Setter\n@Data\n@ToString\n@Schema(name = \"User\")\npublic class UserDto {\n\n  private String id;\n\n  private String name;\n\n  @Override", "@ToString\n@Schema(name = \"User\")\npublic class UserDto {\n\n  private String id;\n\n  private String name;\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;", "  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    UserDto userDTO = (UserDto) o;\n    return Objects.equals(id, userDTO.id);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n}\n", "  public int hashCode() {\n    return Objects.hash(id);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/exceptions/InvalidCodeException.java", "chunked_list": ["package net.verotek.twitch.chatters.exceptions;\n\nimport lombok.NoArgsConstructor;\n\n@NoArgsConstructor\npublic class InvalidCodeException extends Exception {\n\n  public InvalidCodeException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/exceptions/InvalidTokenRequestException.java", "chunked_list": ["package net.verotek.twitch.chatters.exceptions;\n\nimport lombok.NoArgsConstructor;\n\n@NoArgsConstructor\npublic class InvalidTokenRequestException extends Exception {\n\n  public InvalidTokenRequestException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/exceptions/InvalidScopesException.java", "chunked_list": ["package net.verotek.twitch.chatters.exceptions;\n\nimport lombok.NoArgsConstructor;\n\n@NoArgsConstructor\npublic class InvalidScopesException extends Exception {\n\n  public InvalidScopesException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/exceptions/ChannelNotFoundException.java", "chunked_list": ["package net.verotek.twitch.chatters.exceptions;\n\nimport lombok.NoArgsConstructor;\n\n@NoArgsConstructor\npublic class ChannelNotFoundException extends Exception {\n\n  public ChannelNotFoundException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/repositories/ChannelRepository.java", "chunked_list": ["package net.verotek.twitch.chatters.repositories;\n\nimport net.verotek.twitch.chatters.models.Channel;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface ChannelRepository extends JpaRepository<Channel, String> {}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/models/Channel.java", "chunked_list": ["package net.verotek.twitch.chatters.models;\n\nimport com.github.philippheuer.credentialmanager.domain.OAuth2Credential;\nimport com.github.twitch4j.auth.domain.TwitchScopes;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.stream.Collectors;", "import java.util.List;\nimport java.util.stream.Collectors;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\nimport org.jetbrains.annotations.NotNull;\n\n@AllArgsConstructor\n@NoArgsConstructor(force = true)", "@AllArgsConstructor\n@NoArgsConstructor(force = true)\n@Entity\n@Getter\n@Setter\npublic class Channel {\n\n  @Id private String id;\n\n  @NotNull private String refreshToken;\n\n  @NotNull private List<TwitchScopes> scopes;\n\n  @NotNull private String accessToken;\n\n  @NotNull private Date expiresAt;\n\n  public Channel(OAuth2Credential credential) {\n    id = credential.getUserId();\n    refreshToken = credential.getRefreshToken();\n    scopes = credential.getScopes().stream().map(Channel::getScopeByName).toList();\n    accessToken = credential.getAccessToken();\n    expiresAt = computeExpiresAt(credential.getExpiresIn());\n  }\n\n  private static TwitchScopes getScopeByName(String scopeName) {", "    for (TwitchScopes scope : TwitchScopes.values()) {\n      if (scope.toString().equals(scopeName)) {\n        return scope;\n      }\n    }\n    return null;\n  }\n\n  public void updateWithCredential(OAuth2Credential credential) {\n    this.refreshToken = credential.getRefreshToken();\n    this.accessToken = credential.getAccessToken();\n    this.expiresAt = computeExpiresAt(credential.getExpiresIn());\n  }\n\n  private Date computeExpiresAt(Integer expiresIn) {\n    Calendar expiresAt = Calendar.getInstance();", "  public void updateWithCredential(OAuth2Credential credential) {\n    this.refreshToken = credential.getRefreshToken();\n    this.accessToken = credential.getAccessToken();\n    this.expiresAt = computeExpiresAt(credential.getExpiresIn());\n  }\n\n  private Date computeExpiresAt(Integer expiresIn) {\n    Calendar expiresAt = Calendar.getInstance();\n    if (expiresIn == null) return expiresAt.getTime();\n\n    expiresAt.add(Calendar.SECOND, expiresIn);\n    return expiresAt.getTime();\n  }\n\n  public List<String> getScopeNames() {\n    return scopes.stream().map(Enum::name).collect(Collectors.toList());\n  }\n", "    if (expiresIn == null) return expiresAt.getTime();\n\n    expiresAt.add(Calendar.SECOND, expiresIn);\n    return expiresAt.getTime();\n  }\n\n  public List<String> getScopeNames() {\n    return scopes.stream().map(Enum::name).collect(Collectors.toList());\n  }\n\n  public boolean isAccessTokenExpired() {\n    Date now = new Date();\n    return now.after(expiresAt);\n  }\n}\n", "  public boolean isAccessTokenExpired() {\n    Date now = new Date();\n    return now.after(expiresAt);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/services/TwitchService.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport com.github.twitch4j.helix.domain.ChannelVip;\nimport com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.Moderator;\nimport jakarta.validation.constraints.NotNull;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.stream.Collectors;", "import java.util.concurrent.CompletableFuture;\nimport java.util.stream.Collectors;\nimport net.verotek.twitch.chatters.dtos.ChattersDto;\nimport net.verotek.twitch.chatters.dtos.UserDto;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TwitchService {\n\n  private final HelixWrapperService helixWrapper;\n\n  private final ModelMapper mapper;\n\n  @Autowired\n  public TwitchService(ModelMapper mapper, HelixWrapperService helixWrapper) {\n    this.mapper = mapper;\n    this.helixWrapper = helixWrapper;\n  }\n", "@Service\npublic class TwitchService {\n\n  private final HelixWrapperService helixWrapper;\n\n  private final ModelMapper mapper;\n\n  @Autowired\n  public TwitchService(ModelMapper mapper, HelixWrapperService helixWrapper) {\n    this.mapper = mapper;\n    this.helixWrapper = helixWrapper;\n  }\n", "  public ChattersDto getCategorizedChatters(String channelId, String accessToken) {\n    CompletableFuture<Set<UserDto>> chattersFuture =\n        CompletableFuture.supplyAsync(() -> getChatters(channelId, accessToken));\n    CompletableFuture<Set<UserDto>> moderatorsFuture =\n        CompletableFuture.supplyAsync(() -> getModerators(channelId, accessToken));\n    CompletableFuture<Set<UserDto>> vipsFuture =\n        CompletableFuture.supplyAsync(() -> getVips(channelId, accessToken));\n\n    return CompletableFuture.allOf(chattersFuture, moderatorsFuture, vipsFuture)\n        .thenApply(\n            res -> {\n              Set<UserDto> chatters = chattersFuture.join();\n              Set<UserDto> vips = vipsFuture.join();\n              Set<UserDto> moderators = moderatorsFuture.join();\n\n              ChattersDto chattersDTO = new ChattersDto();\n              chatters.parallelStream()\n                  .forEach(\n                      chatter -> {", "                        if (moderators.contains(chatter)) {\n                          chattersDTO.addModerator(chatter);\n                        } else if (vips.contains(chatter)) {\n                          chattersDTO.addVip(chatter);\n                        } else if (chatter.getId().equals(channelId)) {\n                          chattersDTO.setBroadcaster(chatter);\n                        } else {\n                          chattersDTO.addViewer(chatter);\n                        }\n                      });\n\n              return chattersDTO;\n            })\n        .join();\n  }\n\n  private Set<UserDto> mapToUsers(@NotNull Collection<?> collection) {\n    return collection.parallelStream()\n        .map(it -> mapper.map(it, UserDto.class))\n        .collect(Collectors.toSet());\n  }\n\n  public Set<UserDto> getChatters(String channelId, String accessToken) {\n    Set<Chatter> vips = helixWrapper.fetchChatters(channelId, accessToken);\n    return mapToUsers(vips);\n  }\n\n  public Set<UserDto> getModerators(String channelId, String accessToken) {\n    Set<Moderator> vips = helixWrapper.fetchModerators(channelId, accessToken);\n    return mapToUsers(vips);\n  }\n\n  public Set<UserDto> getVips(String channelId, String accessToken) {\n    Set<ChannelVip> vips = helixWrapper.fetchVips(channelId, accessToken);\n    return mapToUsers(vips);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/services/HelixWrapperService.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport com.github.twitch4j.TwitchClient;\nimport com.github.twitch4j.helix.TwitchHelix;\nimport com.github.twitch4j.helix.domain.ChannelVip;\nimport com.github.twitch4j.helix.domain.ChannelVipList;\nimport com.github.twitch4j.helix.domain.Chatter;\nimport com.github.twitch4j.helix.domain.ChattersList;\nimport com.github.twitch4j.helix.domain.Moderator;\nimport com.github.twitch4j.helix.domain.ModeratorList;", "import com.github.twitch4j.helix.domain.Moderator;\nimport com.github.twitch4j.helix.domain.ModeratorList;\nimport com.netflix.hystrix.HystrixCommand;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class HelixWrapperService {\n\n  private final TwitchHelix helix;\n\n  @Autowired\n  public HelixWrapperService(TwitchClient twitchClient) {\n    this.helix = twitchClient.getHelix();\n  }\n\n  public Set<Chatter> fetchChatters(String channelId, String accessToken) {\n    Set<Chatter> allChatters = new HashSet<>();\n    String cursor = null;\n\n    do {\n      HystrixCommand<ChattersList> chatterCommand =\n          helix.getChatters(accessToken, channelId, channelId, null, cursor);\n      ChattersList chattersList = chatterCommand.execute();\n      List<Chatter> chatters = chattersList.getChatters();\n      allChatters.addAll(chatters);\n\n      cursor = chattersList.getPagination().getCursor();", "\n@Service\npublic class HelixWrapperService {\n\n  private final TwitchHelix helix;\n\n  @Autowired\n  public HelixWrapperService(TwitchClient twitchClient) {\n    this.helix = twitchClient.getHelix();\n  }\n\n  public Set<Chatter> fetchChatters(String channelId, String accessToken) {\n    Set<Chatter> allChatters = new HashSet<>();\n    String cursor = null;\n\n    do {\n      HystrixCommand<ChattersList> chatterCommand =\n          helix.getChatters(accessToken, channelId, channelId, null, cursor);\n      ChattersList chattersList = chatterCommand.execute();\n      List<Chatter> chatters = chattersList.getChatters();\n      allChatters.addAll(chatters);\n\n      cursor = chattersList.getPagination().getCursor();", "    } while (cursor != null);\n\n    return allChatters;\n  }\n\n  public Set<Moderator> fetchModerators(String channelId, String accessToken) {\n    Set<Moderator> allModerators = new HashSet<>();\n    String cursor = null;\n\n    do {\n      HystrixCommand<ModeratorList> moderatorCommand =\n          helix.getModerators(accessToken, channelId, null, cursor, null);\n      ModeratorList moderatorList = moderatorCommand.execute();\n      List<Moderator> moderators = moderatorList.getModerators();\n      allModerators.addAll(moderators);\n\n      cursor = moderatorList.getPagination().getCursor();", "    } while (cursor != null);\n\n    return allModerators;\n  }\n\n  public Set<ChannelVip> fetchVips(String channelId, String accessToken) {\n    Set<ChannelVip> allVips = new HashSet<>();\n    String cursor = null;\n\n    do {\n      HystrixCommand<ChannelVipList> vipCommand =\n          helix.getChannelVips(accessToken, channelId, null, null, cursor);\n      ChannelVipList vipList = vipCommand.execute();\n      List<ChannelVip> vips = vipList.getData();\n      allVips.addAll(vips);\n\n      cursor = vipList.getPagination().getCursor();", "    } while (cursor != null);\n\n    return allVips;\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/services/TwitchIdentityService.java", "chunked_list": ["package net.verotek.twitch.chatters.services;\n\nimport com.github.philippheuer.credentialmanager.domain.OAuth2Credential;\nimport com.github.twitch4j.auth.domain.TwitchScopes;\nimport com.github.twitch4j.auth.providers.TwitchIdentityProvider;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;", "import java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport net.verotek.twitch.chatters.exceptions.ChannelNotFoundException;\nimport net.verotek.twitch.chatters.exceptions.InvalidCodeException;\nimport net.verotek.twitch.chatters.exceptions.InvalidScopesException;\nimport net.verotek.twitch.chatters.exceptions.InvalidTokenRequestException;\nimport net.verotek.twitch.chatters.models.Channel;\nimport net.verotek.twitch.chatters.repositories.ChannelRepository;\nimport org.slf4j.Logger;", "import net.verotek.twitch.chatters.repositories.ChannelRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TwitchIdentityService {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(TwitchIdentityService.class);\n", "  public static final Set<TwitchScopes> REQUIRED_SCOPES =\n      Set.of(\n          TwitchScopes.HELIX_MODERATION_READ,\n          TwitchScopes.HELIX_CHANNEL_VIPS_READ,\n          TwitchScopes.HELIX_CHATTERS_READ);\n\n  private final TwitchIdentityProvider identityProvider;\n  private final ChannelRepository channelRepository;\n\n  @Autowired\n  public TwitchIdentityService(\n      ChannelRepository channelRepository, TwitchIdentityProvider identityProvider) {\n    this.channelRepository = channelRepository;\n    this.identityProvider = identityProvider;\n  }\n\n  private static Set<String> getRequiredScopeNames() {\n    return REQUIRED_SCOPES.stream().map(Enum::toString).collect(Collectors.toSet());\n  }\n", "  public String getAccessToken(String channelId)\n      throws InvalidTokenRequestException, ChannelNotFoundException {\n    Optional<Channel> optionalChannel = channelRepository.findById(channelId);\n    if (optionalChannel.isEmpty()) {\n      throw new ChannelNotFoundException(\"channel is not yet registered\");\n    }\n\n    Channel channel = optionalChannel.get();\n    if (channel.isAccessTokenExpired()) {\n      refresh(channel);\n    }\n\n    return channel.getAccessToken();\n  }\n", "    if (channel.isAccessTokenExpired()) {\n      refresh(channel);\n    }\n\n    return channel.getAccessToken();\n  }\n\n  public String getAuthorizationUrl() {\n    List<Object> scopes = new ArrayList<>(REQUIRED_SCOPES);\n    return identityProvider.getAuthenticationUrl(scopes, null);\n  }\n", "  public void authorize(String code)\n      throws InvalidTokenRequestException, InvalidScopesException, InvalidCodeException {\n    OAuth2Credential credential;\n    try {\n      credential = identityProvider.getCredentialByCode(code);\n    } catch (Exception ex) {\n      LOGGER.error(ex.getMessage());\n      throw new InvalidCodeException(\"provided code is not valid\");\n    }\n\n    Optional<OAuth2Credential> optionalFullCredential =\n        identityProvider.getAdditionalCredentialInformation(credential);", "    if (optionalFullCredential.isEmpty()) {\n      throw new InvalidTokenRequestException(\"could not request credential details\");\n    }\n\n    OAuth2Credential fullCredential = optionalFullCredential.get();\n    if (!isScopeListValid(fullCredential)) {\n      throw new InvalidScopesException(\"missing scopes from autorization\");\n    }\n\n    Channel channel = new Channel(fullCredential);\n    channelRepository.save(channel);\n  }\n\n  private boolean isScopeListValid(OAuth2Credential credential) {\n    Set<String> scopes = new HashSet<>(credential.getScopes());\n    return getRequiredScopeNames().equals(scopes);\n  }\n\n  private void refresh(Channel channel) throws InvalidTokenRequestException {\n    OAuth2Credential channelCredential =\n        new OAuth2Credential(\n            identityProvider.getProviderName(),\n            channel.getAccessToken(),\n            channel.getRefreshToken(),\n            channel.getId(),\n            null,\n            null,\n            channel.getScopeNames());\n\n    Optional<OAuth2Credential> optionalCredential =\n        identityProvider.refreshCredential(channelCredential);", "    if (optionalCredential.isEmpty()) {\n      throw new InvalidTokenRequestException(\"could not refresh credential, try reauthenticating\");\n    }\n\n    OAuth2Credential credential = optionalCredential.get();\n    channel.updateWithCredential(credential);\n    channelRepository.save(channel);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/controllers/BaseRestController.java", "chunked_list": ["package net.verotek.twitch.chatters.controllers;\n\nimport io.swagger.v3.oas.annotations.media.Content;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport net.verotek.twitch.chatters.dtos.ErrorDto;\nimport net.verotek.twitch.chatters.exceptions.ChannelNotFoundException;\nimport net.verotek.twitch.chatters.exceptions.InvalidTokenRequestException;\nimport net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport net.verotek.twitch.chatters.services.TwitchService;", "import net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport net.verotek.twitch.chatters.services.TwitchService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.ResponseStatus;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n", "import org.springframework.web.bind.annotation.RestControllerAdvice;\n\n@RestControllerAdvice\npublic class BaseRestController {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(AuthController.class);\n\n  protected final TwitchService service;\n\n  protected final TwitchIdentityService identityService;\n\n  public BaseRestController(TwitchService service, TwitchIdentityService identityService) {\n    this.identityService = identityService;\n    this.service = service;\n  }\n\n  @ApiResponse(\n      responseCode = \"400\",\n      content = {\n        @Content(\n            mediaType = MediaType.APPLICATION_JSON_VALUE,\n            schema = @Schema(implementation = ErrorDto.class))\n      })\n  @ExceptionHandler({InvalidTokenRequestException.class})\n  @ResponseStatus(HttpStatus.BAD_REQUEST)", "  public ErrorDto handleBadRequests(Throwable ex) {\n    return new ErrorDto(ex, HttpStatus.BAD_REQUEST);\n  }\n\n  @ApiResponse(\n      responseCode = \"404\",\n      content = {\n        @Content(\n            mediaType = MediaType.APPLICATION_JSON_VALUE,\n            schema = @Schema(implementation = ErrorDto.class))\n      })\n  @ExceptionHandler({ChannelNotFoundException.class})\n  @ResponseStatus(HttpStatus.NOT_FOUND)", "  public ErrorDto handleNotFound(Throwable ex) {\n    return new ErrorDto(ex, HttpStatus.NOT_FOUND);\n  }\n\n  @ApiResponse(\n      responseCode = \"500\",\n      content = {\n        @Content(\n            mediaType = MediaType.APPLICATION_JSON_VALUE,\n            schema = @Schema(implementation = ErrorDto.class))\n      })\n  @ExceptionHandler(Throwable.class)\n  @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)", "  public ErrorDto handleServerError(Throwable ex) {\n    LOGGER.error(\"Unhandled Exception: \" + ex.getMessage());\n    Throwable cause = new Exception(\"Unknown Exception\");\n    return new ErrorDto(cause, HttpStatus.INTERNAL_SERVER_ERROR);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/controllers/RolesController.java", "chunked_list": ["package net.verotek.twitch.chatters.controllers;\n\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport java.util.Set;\nimport net.verotek.twitch.chatters.dtos.UserDto;\nimport net.verotek.twitch.chatters.exceptions.ChannelNotFoundException;\nimport net.verotek.twitch.chatters.exceptions.InvalidTokenRequestException;\nimport net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport net.verotek.twitch.chatters.services.TwitchService;\nimport org.springframework.beans.factory.annotation.Autowired;", "import net.verotek.twitch.chatters.services.TwitchService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(value = \"${api.base_url}/roles\", produces = MediaType.APPLICATION_JSON_VALUE)", "@RestController\n@RequestMapping(value = \"${api.base_url}/roles\", produces = MediaType.APPLICATION_JSON_VALUE)\n@Tag(name = \"Roles\")\npublic class RolesController extends BaseRestController {\n\n  @Autowired\n  public RolesController(TwitchService service, TwitchIdentityService identityService) {\n    super(service, identityService);\n  }\n\n  @GetMapping(value = \"vips\")\n  Set<UserDto> vips(@RequestParam(name = \"channelId\") String channelId)\n      throws InvalidTokenRequestException, ChannelNotFoundException {\n    String accessToken = identityService.getAccessToken(channelId);\n    return service.getVips(channelId, accessToken);\n  }\n\n  @GetMapping(\"moderators\")\n  Set<UserDto> moderators(@RequestParam(name = \"channelId\") String channelId)\n      throws InvalidTokenRequestException, ChannelNotFoundException {\n    String accessToken = identityService.getAccessToken(channelId);\n    return service.getModerators(channelId, accessToken);\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/controllers/IndexController.java", "chunked_list": ["package net.verotek.twitch.chatters.controllers;\n\nimport net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller", "\n@Controller\n@RequestMapping(value = \"/\")\npublic class IndexController {\n\n  private final TwitchIdentityService identityService;\n\n  @Autowired\n  public IndexController(TwitchIdentityService identityService) {\n    this.identityService = identityService;\n  }\n\n  @GetMapping(\"error\")", "  public String error() {\n    return \"error\";\n  }\n\n  @GetMapping(\"/\")\n  public String home(Model model) {\n    String authUrl = identityService.getAuthorizationUrl();\n    model.addAttribute(\"authUrl\", authUrl);\n    return \"index\";\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/controllers/AuthController.java", "chunked_list": ["package net.verotek.twitch.chatters.controllers;\n\nimport net.verotek.twitch.chatters.exceptions.InvalidCodeException;\nimport net.verotek.twitch.chatters.exceptions.InvalidScopesException;\nimport net.verotek.twitch.chatters.exceptions.InvalidTokenRequestException;\nimport net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;", "import org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n@Controller", "\n@Controller\n@RequestMapping(value = \"/\")\npublic class AuthController {\n\n  private final TwitchIdentityService identityService;\n\n  @Autowired\n  public AuthController(TwitchIdentityService identityService) {\n    this.identityService = identityService;\n  }\n\n  @ExceptionHandler({\n    InvalidTokenRequestException.class,\n    InvalidCodeException.class,\n    InvalidScopesException.class\n  })\n  @ResponseStatus(HttpStatus.BAD_REQUEST)", "  public String handleInvalidTokenRequest(Throwable ex, Model model) {\n    model.addAttribute(\"error\", ex.getMessage());\n    model.addAttribute(\"authUrl\", identityService.getAuthorizationUrl());\n    return \"index\";\n  }\n\n  @GetMapping(\"authorize\")\n  public String authorize(@RequestParam(name = \"code\") String code, ModelMap model)\n      throws InvalidTokenRequestException, InvalidScopesException, InvalidCodeException {\n    identityService.authorize(code);\n    model.addAttribute(\"success\", \"Successfully added channel\");\n    return \"index\";\n  }\n}\n"]}
{"filename": "src/main/java/net/verotek/twitch/chatters/controllers/ChattersController.java", "chunked_list": ["package net.verotek.twitch.chatters.controllers;\n\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport net.verotek.twitch.chatters.dtos.ChattersDto;\nimport net.verotek.twitch.chatters.services.TwitchIdentityService;\nimport net.verotek.twitch.chatters.services.TwitchService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;", "import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(value = \"${api.base_url}/chatters\", produces = MediaType.APPLICATION_JSON_VALUE)\n@Tag(name = \"Chatters\")\npublic class ChattersController extends BaseRestController {\n\n  @Autowired\n  public ChattersController(TwitchService service, TwitchIdentityService identityService) {\n    super(service, identityService);\n  }\n\n  @GetMapping(\"all\")", "public class ChattersController extends BaseRestController {\n\n  @Autowired\n  public ChattersController(TwitchService service, TwitchIdentityService identityService) {\n    super(service, identityService);\n  }\n\n  @GetMapping(\"all\")\n  public ChattersDto all(@RequestParam(name = \"channelId\") String channelId) throws Throwable {\n    String accessToken = identityService.getAccessToken(channelId);\n    return service.getCategorizedChatters(channelId, accessToken);\n  }\n}\n", "  public ChattersDto all(@RequestParam(name = \"channelId\") String channelId) throws Throwable {\n    String accessToken = identityService.getAccessToken(channelId);\n    return service.getCategorizedChatters(channelId, accessToken);\n  }\n}\n"]}
