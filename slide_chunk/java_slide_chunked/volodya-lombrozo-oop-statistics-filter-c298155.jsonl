{"filename": "src/test/java/filter/AppTest.java", "chunked_list": ["package filter;\n\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Unit test for simple App.\n */\nfinal class AppTest {", " */\nfinal class AppTest {\n    /**\n     * Rigorous Test :-)\n     */\n    @Test\n    void shouldAnswerWithTrue() {\n        Assertions.assertTrue(true, \"\");\n    }\n}", "    }\n}\n"]}
{"filename": "src/test/java/filter/statistics/GitHubMetricsTest.java", "chunked_list": ["package filter.statistics;\n\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.Test;\n\nclass GitHubMetricsTest {\n\n    @Test\n    void gathersAllTheRequiredMetrics() {", "    @Test\n    void gathersAllTheRequiredMetrics() {\n        MatcherAssert.assertThat(\n            \"Metrics are gathered\",\n            new GitHubMetrics(\n                \"https://github.com/apache/tomcat.git\").cells(),\n            Matchers.not(Matchers.empty())\n        );\n    }\n}", "    }\n}"]}
{"filename": "src/main/java/filter/Application.java", "chunked_list": ["package filter;\n\nimport java.nio.file.Path;\n\npublic interface Application {\n    Path path();\n\n    String githubUrl();\n}\n"]}
{"filename": "src/main/java/filter/CSV.java", "chunked_list": ["package filter;\n\nimport java.io.Reader;\nimport java.util.Set;\n\npublic interface CSV {\n\n    Reader reader();\n\n}\n"]}
{"filename": "src/main/java/filter/Report.java", "chunked_list": ["package filter;\n\nimport filter.csv.CSVCell;\nimport filter.csv.CSVOutput;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n", "import java.util.stream.Collectors;\n\nclass Report {\n\n    private final Collection<StatisticsCase> cases;\n    private final CSVOutput output;\n\n    Report(final String filename, final StatisticsCase... all) {\n        this(Arrays.asList(all), filename);\n    }", "        this(Arrays.asList(all), filename);\n    }\n\n    private Report(final Collection<StatisticsCase> all, final String filename) {\n        this.cases = all;\n        this.output = new CSVOutput(filename);\n    }\n\n    void make() throws IOException {\n        final List<List<CSVCell>> table = this.cases.stream()", "    void make() throws IOException {\n        final List<List<CSVCell>> table = this.cases.stream()\n            .map(StatisticsCase::cells)\n            .collect(Collectors.toList());\n        this.output.print(Report.headers(table));\n        table.stream().map(Report::values).forEach(this.output::print);\n        this.output.close();\n    }\n\n    private static List<String> headers(List<? extends List<CSVCell>> table) {", "\n    private static List<String> headers(List<? extends List<CSVCell>> table) {\n        return table.stream()\n            .findFirst()\n            .orElseThrow(\n                () -> new IllegalStateException(String.format(\"No data found in table %s\", table))\n            ).stream()\n            .map(CSVCell::header)\n            .collect(Collectors.toList());\n    }", "            .collect(Collectors.toList());\n    }\n\n    private static List<Object> values(List<? extends CSVCell> cells) {\n        return cells.stream()\n            .map(CSVCell::value)\n            .collect(Collectors.toList());\n    }\n}\n", "}\n"]}
{"filename": "src/main/java/filter/Statistics.java", "chunked_list": ["package filter;\n\nimport filter.csv.CSVCell;\nimport java.util.List;\n\npublic interface Statistics {\n\n    List<CSVCell> cells();\n\n}\n"]}
{"filename": "src/main/java/filter/FilterLibraries.java", "chunked_list": ["package filter;\n\nimport filter.app.AppGitHub;\nimport filter.app.AppRemoteZip;\nimport filter.csv.CSVRemote;\nimport filter.statistics.StatisticsCaseLibrary;\nimport java.io.IOException;\n\n/**\n * Filter libraries and classify them by modifiers.", "/**\n * Filter libraries and classify them by modifiers.\n * The new approach comparing with {@link filter.FilterLibraries}.\n */\npublic class FilterLibraries {\n\n    public static void main(final String[] args) throws IOException {\n        new Report(\n            \"libraries-new.csv\",\n            new StatisticsCaseLibrary(\n                \"Apache Derby 10.16.1.1\",\n                new CSVRemote(\"derby/method-list-cpu.csv\"),\n                new AppRemoteZip(\n                    \"https://dlcdn.apache.org//db/derby/db-derby-10.16.1.1/db-derby-10.16.1.1-src.zip\",\n                    \"https://github.com/apache/derby.git\"\n                ),\n                \"org.apache.derby\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Kafka 3.4.0\",\n                new CSVRemote(\"kafka/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/kafka.git\",\n                    \"3.4.0\"\n                ),\n                \"org.apache.kafka\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Tomcat 10.1.8\",\n                new CSVRemote(\"tomcat/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"10.1.8\"\n                ),\n                \"org.apache.tomcat\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Catalina 10.1.8\",\n                new CSVRemote(\"tomcat/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"10.1.8\"\n                ),\n                \"org.apache.catalina\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Coyote 10.1.8\",\n                new CSVRemote(\"tomcat/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"10.1.8\"\n                ),\n                \"org.apache.coyote\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Spring Framework 5.3.27\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/spring-projects/spring-framework.git\",\n                    \"v5.3.27\"\n                ),\n                \"org.springframework\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Jackson Databind 2.13.5\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/FasterXML/jackson-databind.git\",\n                    \"jackson-databind-2.13.5\"\n                ),\n                \"com.fasterxml.jackson.databind\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Jackson Core 2.13.5\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/FasterXML/jackson-core.git\",\n                    \"jackson-core-2.13.5\"\n                ),\n                \"com.fasterxml.jackson.core\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Tomcat 9.0.75\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"9.0.75\"\n                ),\n                \"org.apache.tomcat\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Catalina 9.0.75\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"9.0.75\"\n                ),\n                \"org.apache.catalina\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Apache Coyote 9.0.75\",\n                new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/tomcat.git\",\n                    \"9.0.75\"\n                ),\n                \"org.apache.coyote\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Takes 1.24.4\",\n                new CSVRemote(\"takes/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/yegor256/takes.git\",\n                    \"1.24.4\"\n                ),\n                \"org.takes\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Cactoos 0.54.0\",\n                new CSVRemote(\"takes/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/yegor256/cactoos.git\",\n                    \"0.54.0\"\n                ),\n                \"org.cactoos\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Opensymphony 2.4.2\",\n                new CSVRemote(\"struts/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/struts.git\",\n                    \"STRUTS_6_1_2\"\n                ),\n                \"com.opensymphony\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Jetty 10.0.15\",\n                new CSVRemote(\"struts/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/eclipse/jetty.project.git\",\n                    \"jetty-10.0.15\"\n                ),\n                \"org.eclipse.jetty\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Struts 6.1.2\",\n                new CSVRemote(\"struts/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/apache/struts.git\",\n                    \"STRUTS_6_1_2\"\n                ),\n                \"org.apache.struts2\"\n            ),\n            new StatisticsCaseLibrary(\n                \"OGNL 3.3.4\",\n                new CSVRemote(\"struts/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/orphan-oss/ognl.git\",\n                    \"OGNL_3_3_4\"\n                ),\n                \"ognl\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Project Reactor 3.5.0\",\n                new CSVRemote(\"micronaut/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/reactor/reactor-core.git\",\n                    \"v3.5.0\"\n                ),\n                \"reactor.core\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Netty 4.1.92.Final\",\n                new CSVRemote(\"micronaut/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/netty/netty.git\",\n                    \"netty-4.1.92.Final\"\n                ),\n                \"io.netty\"\n            ),\n            new StatisticsCaseLibrary(\n                \"Micronaut 3.9.3\",\n                new CSVRemote(\"micronaut/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/micronaut-projects/micronaut-core.git\",\n                    \"v3.9.3\"\n                ),\n                \"io.micronaut\"\n            )\n        ).make();\n    }\n\n}\n"]}
{"filename": "src/main/java/filter/FilterApplications.java", "chunked_list": ["package filter;\n\nimport filter.app.AppGitHub;\nimport filter.app.AppRemoteZip;\nimport filter.csv.CSVRemote;\nimport filter.statistics.SoftMetrics;\nimport filter.statistics.StatisticCaseApplications;\nimport filter.statistics.StatisticsCollection;\nimport java.io.IOException;\nimport java.time.LocalDate;", "import java.io.IOException;\nimport java.time.LocalDate;\n\npublic class FilterApplications {\n\n    public static void main(String[] args) throws IOException {\n        new Report(\n            \"entire.csv\",\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Apache Derby 10.16.1.1\",\n                    new CSVRemote(\"derby/method-list-cpu.csv\"),\n                    new AppRemoteZip(\n                        \"https://dlcdn.apache.org//db/derby/db-derby-10.16.1.1/db-derby-10.16.1.1-src.zip\"\n                    ),\n                    \"org.apache.derby\"\n                ),\n                //todo: add soft metrics for derby\n                new SoftMetrics(0, LocalDate.of(2000, 1, 1), 0, 0)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Apache Kafka 3.4.0\",\n                    new CSVRemote(\"kafka/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/apache/kafka.git\",\n                        \"3.4.0\"\n                    ),\n                    \"org.apache.kafka\"\n                ),\n                //todo: add soft metrics for kafka\n                new SoftMetrics(0, LocalDate.of(2011, 1, 1), 1030, 25400)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Apache Tomcat 10.1.8\",\n                    new CSVRemote(\"tomcat/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/apache/tomcat.git\",\n                        \"10.1.8\"\n                    ),\n                    \"org.apache.tomcat\"\n                ),\n                //todo: add soft metrics for tomcat\n                new SoftMetrics(0, LocalDate.of(2011, 1, 1), 1030, 25400)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Spring Framework 5.3.27\",\n                    new CSVRemote(\"spring-mvc/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/spring-projects/spring-framework.git\",\n                        \"v5.3.27\"\n                    ),\n                    \"org.springframework\"\n                ),\n                //todo: add soft metrics for spring\n                new SoftMetrics(0, LocalDate.of(2011, 1, 1), 1030, 25400)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Takes 1.24.4\",\n                    new CSVRemote(\"takes/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/yegor256/takes.git\",\n                        \"1.24.4\"\n                    ),\n                    \"org.takes\"\n                ),\n                //todo: add soft metrics for takes\n                new SoftMetrics(0, LocalDate.of(2011, 1, 1), 1030, 25400)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Struts 6.1.2\",\n                    new CSVRemote(\"struts/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/apache/struts.git\",\n                        \"STRUTS_6_1_2\"\n                    ),\n                    \"org.apache.struts2\"\n                ),\n                //todo: add soft metrics for struts\n                new SoftMetrics(0, LocalDate.of(2000, 1, 1), 0, 0)\n            ),\n            new StatisticsCollection(\n                new StatisticCaseApplications(\n                    \"Micronaut 3.9.3\",\n                    new CSVRemote(\"micronaut/method-list-cpu.csv\"),\n                    new AppGitHub(\n                        \"https://github.com/micronaut-projects/micronaut-core.git\",\n                        \"v3.9.3\"\n                    ),\n                    \"io.micronaut\"\n                ),\n                //todo: add soft metrics for micronaut\n                new SoftMetrics(0, LocalDate.of(2018, 1, 1), 0, 0)\n            )\n        ).make();\n    }\n}\n"]}
{"filename": "src/main/java/filter/StatisticsCase.java", "chunked_list": ["package filter;\n\nimport filter.csv.CSVCell;\nimport java.util.List;\n\npublic interface StatisticsCase {\n\n    List<CSVCell> cells();\n\n}\n"]}
{"filename": "src/main/java/filter/FilterVerificationApplications.java", "chunked_list": ["package filter;\n\nimport filter.app.AppGitHub;\nimport filter.csv.CSVRemote;\nimport filter.statistics.StatisticsCaseWithModifiers;\nimport java.io.IOException;\n\n/**\n * CSV profiling filter.\n * Application that generates a report by a CSV data which was received during profiling different", " * CSV profiling filter.\n * Application that generates a report by a CSV data which was received during profiling different\n * verification applications.\n * Just checks that profiling tool works as expected.\n */\npublic class FilterVerificationApplications {\n    public static void main(final String[] args) throws IOException {\n        new Report(\n            \"verification.csv\",\n            new StatisticsCaseWithModifiers(\n                \"Verification Half\",\n                new CSVRemote(\"verification-half/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/volodya-lombrozo/cost-of-oop.git\",\n                    \"main\"\n                ),\n                \"verification.half\"\n            ),\n            new StatisticsCaseWithModifiers(\n                \"Verification Instance\",\n                new CSVRemote(\"verification-instance/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/volodya-lombrozo/cost-of-oop.git\",\n                    \"main\"\n                ),\n                \"verification.instances\"\n            ),\n            new StatisticsCaseWithModifiers(\n                \"Verification Statics\",\n                new CSVRemote(\"verification-static/method-list-cpu.csv\"),\n                new AppGitHub(\n                    \"https://github.com/volodya-lombrozo/cost-of-oop.git\",\n                    \"main\"\n                ),\n                \"verification.statics\"\n            )\n        ).make();\n    }\n}\n"]}
{"filename": "src/main/java/filter/Correlation.java", "chunked_list": ["package filter;\n\nimport filter.csv.CSVLocal;\nimport filter.csv.CorrelationCSV;\n\npublic class Correlation {\n    public static void main(String[] args) {\n        new CorrelationCSV(new CSVLocal(\"libraries-new.csv\")).report();\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/SourceCodeMetrics.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Statistics;\nimport filter.csv.CSVCell;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;", "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class SourceCodeMetrics implements Statistics {\n\n    private static final long TIMEOUT = 60;\n\n    private final Path repository;\n\n    public SourceCodeMetrics(final Path repository) {\n        this.repository = repository;\n    }\n\n\n    @Override\n    public List<CSVCell> cells() {\n        this.docker();\n        return this.parseResults();\n    }\n\n    private List<CSVCell> parseResults() {", "        try {\n            final Path java = this.repository\n                .resolve(\"source-meter\")\n                .resolve(\"source-meter\")\n                .resolve(\"java\");\n            final Path results = Files.list(java)\n                .findFirst()\n                .orElseThrow(\n                    () -> new IllegalStateException(\n                        String.format(\"Can not find results directory in %s\", java)\n                    )\n                );\n            final Path json = java.resolve(results).resolve(\"source-meter-summary.json\");\n            return Collections.emptyList();\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    private void docker() {", "        try {\n            Runtime runtime = Runtime.getRuntime();\n            final Process docker;\n            docker = runtime.exec(this.dockerCommand());\n            docker.waitFor(SourceCodeMetrics.TIMEOUT, TimeUnit.SECONDS);\n            final int exitValue = docker.exitValue();\n            if (exitValue != 0 && exitValue != 1) {\n                throw new IllegalStateException(\n                    String.format(\n                        \"Error while running docker command, the exit value %s is not 0, command is '%s', log is:%n %s\",\n                        exitValue,\n                        String.join(\" \", this.dockerCommand()),\n                        new BufferedReader(\n                            new InputStreamReader(docker.getErrorStream(), StandardCharsets.UTF_8)\n                        ).lines().collect(Collectors.joining(\"\\n\"))\n                    )\n                );\n            }\n        } catch (IOException | InterruptedException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    private String[] dockerCommand() {\n        return new String[]{\n            \"docker\",\n            \"run\",\n            \"-v\",\n            String.format(\"%s:/workdir\", this.repository.toAbsolutePath()),\n            \"lombrozo/sourcemeter-app:latest\"\n        };\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsCaseWithModifiers.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Application;\nimport filter.CSV;\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport filter.csv.CSVRows;\nimport filter.csv.ParsedCSVRow;\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;", "import java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport lombok.ToString;\n\n@ToString\npublic final class StatisticsCaseWithModifiers implements StatisticsCase {\n\n        private final String title;\n        private final CSV csv;\n        private final Application project;\n        private final String[] filters;\n\n    public StatisticsCaseWithModifiers(\n        final String title,\n        final CSV csv,\n        final Application project,\n        final String... filters\n    ) {\n        this.title = title;\n        this.csv = csv;\n        this.project = project;\n        this.filters = filters;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Stream.concat(\n            Stream.of(new CSVCell(\"Application\", this.title)),\n            this.statistics().cells().stream()\n        ).collect(Collectors.toList());\n    }\n\n    StatisticsWithModifiers statistics() {\n        final Set<ParsedCSVRow> csvRows = new CSVRows(this.csv, this.filters).toSet();\n        final Map<String, Modifiers> methods = this.methods();\n        StatisticsWithModifiers stats = new StatisticsWithModifiers();", "        for (final ParsedCSVRow row : csvRows) {\n            final long total = row.getCount();\n            if (row.isConstructor()) {\n                stats.add(new MethodStatistics(total, Modifier.CONSTRUCTOR));\n            } else if (!methods.containsKey(row.shortMethodName())) {\n                final String alternative = row.shortMethodNameWithoutFQNForParameters();\n                if (methods.containsKey(alternative)) {\n                    stats.add(new MethodStatistics(total, methods.get(alternative)));\n                } else {\n                    Logger.getLogger(\"PARSER\")\n                        .warning(\n                            () -> String.format(\"Method not found: %s\", row.fullMethodName())\n                        );\n                    stats.add(new MethodStatistics(total, Modifier.NOT_FOUND));\n                }", "            } else if (methods.containsKey(row.shortMethodName())) {\n                stats.add(new MethodStatistics(total, methods.get(row.shortMethodName())));\n            }\n        }\n        return stats;\n    }\n\n    /**\n     * Parses methods from entire project.\n     * @return Map of methods.\n     */\n    private Map<String, Modifiers> methods() {\n        return this.parseClasses().values()\n            .stream()\n            .flatMap(parsed -> parsed.methods().stream())\n            .collect(Collectors.toMap(ParsedMethod::name, ParsedMethod::modifiers, (a, b) -> a));\n    }\n\n    private Map<String, ParsedClass> parseClasses() {\n        try (final Stream<Path> files = Files.walk(this.project.path())) {\n            return files\n                .filter(Files::exists)\n                .filter(Files::isRegularFile)\n                .parallel()\n                .filter(path -> path.toString().endsWith(\".java\"))\n                .flatMap(ParsedClass::parse)\n                .collect(\n                    Collectors.toMap(\n                        ParsedClass::name,\n                        parsed -> parsed,\n                        ParsedClass::add\n                    )\n                );\n        } catch (final IOException exception) {\n            throw new IllegalStateException(exception);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/GitHubMetrics.java", "chunked_list": ["package filter.statistics;\n\nimport com.jcabi.github.Coordinates;\nimport com.jcabi.github.Github;\nimport com.jcabi.github.RepositoryStatistics;\nimport com.jcabi.github.RtGithub;\nimport com.jcabi.log.Logger;\nimport filter.Statistics;\nimport filter.csv.CSVCell;\nimport java.io.IOException;", "import filter.csv.CSVCell;\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.time.ZonedDateTime;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class GitHubMetrics implements Statistics {\n\n    private final Coordinates coordinates;\n\n    public GitHubMetrics(final String url) {\n        this(new Coordinates.Https(url));\n    }\n\n    public GitHubMetrics(final Coordinates coordinates) {\n        this.coordinates = coordinates;\n    }\n\n    @Override\n    public List<CSVCell> cells() {", "        try {\n            final RepositoryStatistics.Smart stat = new RepositoryStatistics\n                .Smart(this.github().repos().get(this.coordinates));\n            return Arrays.asList(\n                new CSVCell(\"GitHub Forks\", stat.forks()),\n                new CSVCell(\"GitHub Stars\", stat.stargazers()),\n                new CSVCell(\"GitHub Open Issues\", stat.openIssues()),\n                new CSVCell(\"GitHub Size (KB)\", stat.size()),\n                new CSVCell(\n                    \"GitHub Age (ms)\",\n                    Duration.between(stat.created(), ZonedDateTime.now()).toMillis()\n                )\n            );\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Can't get statistics from from repo %s\",\n                    this.coordinates\n                ),\n                ex\n            );\n        }\n    }\n\n    private Github github() {\n        final Github result;\n        final String token = System.getenv(\"GITHUB_TOKEN\");", "        if (token != null) {\n            Logger.info(this, \"Use token for making github requests\");\n            result = new RtGithub(token);\n        } else {\n            Logger.warn(\n                this,\n                \"Use default github WITHOUT token! Please, pay attention to this, since it could lead to crashes\"\n            );\n            result = new RtGithub();\n        }\n\n        return result;\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticCaseApplications.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Application;\nimport filter.CSV;\nimport filter.Statistics;\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;", "import java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport lombok.ToString;\n\n@ToString\npublic class StatisticCaseApplications implements StatisticsCase {\n\n    private final String title;\n    private final CSV csv;\n    private final Application project;\n    private final String[] filters;\n\n    public StatisticCaseApplications(\n        final String title,\n        final CSV csv,\n        final Application project,\n        final String... filters\n    ) {\n        this.title = title;\n        this.csv = csv;\n        this.project = project;\n        this.filters = filters;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Stream.concat(\n            Stream.of(new CSVCell(\"Application\", this.title)),\n            this.statistics().cells().stream()\n        ).collect(Collectors.toList());\n    }\n\n    private Statistics statistics() {\n        return new StatisticsComposite(\n            new StatisticsCaseWithModifiers(\n                this.title,\n                this.csv,\n                this.project,\n                this.filters\n            ),\n            new StatisticsCaseWithoutSources(\n                this.title,\n                this.csv,\n                this.filters\n            ).statistics()\n        );\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsWithoutSources.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Statistics;\nimport filter.csv.CSVCell;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport lombok.ToString;\n", "import lombok.ToString;\n\n@ToString\npublic class StatisticsWithoutSources implements Statistics {\n\n    private final Collection<MethodStatistics> statistics;\n\n    StatisticsWithoutSources() {\n        this(new ArrayList<>(0));\n    }\n\n    private StatisticsWithoutSources(final Collection<MethodStatistics> statistics) {\n        this.statistics = statistics;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Arrays.asList(\n            new CSVCell(\"Library Total\", this.total()),\n            new CSVCell(\"Library Methods\", this.methods()),\n            new CSVCell(\"Library Constructors\", this.constructors())\n        );\n    }\n\n    void add(final MethodStatistics methodStatistics) {\n        this.statistics.add(methodStatistics);\n    }\n\n    private long total() {\n        return this.statistics.stream().mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long methods() {\n        return this.statistics.stream()\n            .filter(method -> !method.isConstructor())\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long constructors() {\n        return this.statistics.stream()\n            .filter(MethodStatistics::isConstructor)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/ParsedClass.java", "chunked_list": ["package filter.statistics;\n\nimport com.github.javaparser.ParseProblemException;\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.Collections;", "import java.util.Collection;\nimport java.util.Collections;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nfinal class ParsedClass {\n\n    private final String name;\n    private final Collection<TypeDeclaration<?>> unit;", "    private final String name;\n    private final Collection<TypeDeclaration<?>> unit;\n\n    private ParsedClass(\n        final String name,\n        final TypeDeclaration<?> unit\n    ) {\n        this(name, Collections.singleton(unit));\n    }\n", "    }\n\n    private ParsedClass(\n        final String name,\n        final Collection<TypeDeclaration<?>> unit\n    ) {\n        this.name = name;\n        this.unit = unit;\n    }\n", "    }\n\n    static Stream<ParsedClass> parse(final Path path) {\n        try {\n            return ParsedClass.classes(StaticJavaParser.parse(path));\n        } catch (final ParseProblemException | IOException ex) {\n            Logger.getLogger(\"PARSER\").warning(\n                () -> String.format(\"Can't parse class '%s', reason: '%s'\", path, ex.getMessage())\n            );\n            return Stream.empty();\n        }\n    }\n\n    private static Stream<ParsedClass> classes(final Node node) {", "        if (ParsedClass.isClass(node)) {\n            final String name = ((TypeDeclaration<?>) node).getFullyQualifiedName()\n                .orElseThrow(IllegalStateException::new);\n            final ParsedClass parsedClass = new ParsedClass(name, (TypeDeclaration<?>) node);\n            return Stream.concat(\n                node.getChildNodes().stream().flatMap(ParsedClass::classes),\n                Stream.of(parsedClass)\n            );\n        } else {\n            return node.getChildNodes().stream().flatMap(ParsedClass::classes);\n        }\n    }\n\n    String name() {\n        return this.name;\n    }\n\n    Collection<ParsedMethod> methods() {\n        return this.unit.stream()\n            .flatMap(u -> u.getMethods().stream())\n            .map(method -> new ParsedMethod(method, this))\n            .collect(Collectors.toSet());\n    }\n\n    ParsedClass add(ParsedClass klass) {\n        return new ParsedClass(\n            this.name,\n            Stream.concat(\n                this.unit.stream(),\n                klass.unit.stream()\n            ).collect(Collectors.toList())\n        );\n    }\n\n    /**\n     * Check whether node is class or not.\n     * @param node Any node.\n     * @return True if test class.\n     */\n    private static boolean isClass(final Node node) {\n        return node instanceof TypeDeclaration<?>\n            && ((TypeDeclaration<?>) node).getFullyQualifiedName().isPresent();\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsCaseWithoutSources.java", "chunked_list": ["package filter.statistics;\n\nimport filter.CSV;\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport filter.csv.CSVRows;\nimport filter.csv.ParsedCSVRow;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;", "import java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport lombok.ToString;\n\n@ToString\npublic class StatisticsCaseWithoutSources implements StatisticsCase {\n\n    private static final String[] EMPTY = {};\n    private final String title;\n    private final CSV csv;\n    private final String[] excluded;\n\n    StatisticsCaseWithoutSources(\n        final String title,\n        final CSV csv,\n        final String... excluded\n    ) {\n        this.title = title;\n        this.csv = csv;\n        this.excluded = excluded;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Stream.concat(\n            Stream.of(new CSVCell(\"Application\", this.title)),\n            this.statistics().cells().stream()\n        ).collect(Collectors.toList());\n    }\n\n    StatisticsWithoutSources statistics() {\n        final Set<ParsedCSVRow> rows = new CSVRows(this.csv, StatisticsCaseWithoutSources.EMPTY,\n            this.excluded\n        ).toSet();\n        final StatisticsWithoutSources stat = new StatisticsWithoutSources();", "        for (final ParsedCSVRow row : rows) {\n            if (row.isConstructor()) {\n                stat.add(new MethodStatistics(row.getCount(), Modifier.CONSTRUCTOR));\n            } else {\n                stat.add(new MethodStatistics(row.getCount()));\n            }\n        }\n        return stat;\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsCollection.java", "chunked_list": ["package filter.statistics;\n\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StatisticsCollection implements StatisticsCase {\n\n    private final Collection<? extends StatisticsCase> all;\n\n    public StatisticsCollection(final StatisticsCase... all) {\n        this(Arrays.asList(all));\n    }\n\n    private StatisticsCollection(final Collection<? extends StatisticsCase> all) {\n        this.all = all;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return this.all.stream()\n            .map(StatisticsCase::cells)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n    }\n}\n", "\npublic class StatisticsCollection implements StatisticsCase {\n\n    private final Collection<? extends StatisticsCase> all;\n\n    public StatisticsCollection(final StatisticsCase... all) {\n        this(Arrays.asList(all));\n    }\n\n    private StatisticsCollection(final Collection<? extends StatisticsCase> all) {\n        this.all = all;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return this.all.stream()\n            .map(StatisticsCase::cells)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/Modifier.java", "chunked_list": ["package filter.statistics;\n\n/**\n *\n */\npublic enum Modifier {\n\n    PRIVATE,\n    PACKAGE_PRIVATE,\n    PUBLIC,\n    INSTANCE,\n    STATIC,\n    OVERRIDDEN,\n    CONSTRUCTOR,\n\n    NOT_FOUND,\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsCaseLibrary.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Application;\nimport filter.CSV;\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport java.util.List;\nimport lombok.ToString;\n\n@ToString\npublic class StatisticsCaseLibrary implements StatisticsCase {\n\n    private final String title;\n    private final CSV csv;\n    private final Application project;\n    private final String[] filters;\n\n    public StatisticsCaseLibrary(\n        final String title,\n        final CSV csv,\n        final Application project,\n        final String... filters\n    ) {\n        this.title = title;\n        this.csv = csv;\n        this.project = project;\n        this.filters = filters;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return new StatisticsComposite(\n            new StatisticsCaseWithModifiers(title, csv, project, filters),\n            new GitHubMetrics(this.project.githubUrl())\n        ).cells();\n    }\n}\n", "\n@ToString\npublic class StatisticsCaseLibrary implements StatisticsCase {\n\n    private final String title;\n    private final CSV csv;\n    private final Application project;\n    private final String[] filters;\n\n    public StatisticsCaseLibrary(\n        final String title,\n        final CSV csv,\n        final Application project,\n        final String... filters\n    ) {\n        this.title = title;\n        this.csv = csv;\n        this.project = project;\n        this.filters = filters;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return new StatisticsComposite(\n            new StatisticsCaseWithModifiers(title, csv, project, filters),\n            new GitHubMetrics(this.project.githubUrl())\n        ).cells();\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/Modifiers.java", "chunked_list": ["package filter.statistics;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Modifiers {\n\n    private final Collection<Modifier> modifiers;\n\n    Modifiers(Modifier... modifiers) {\n        this(Arrays.asList(modifiers));\n    }\n\n    Modifiers(final Collection<Modifier> modifiers) {\n        this.modifiers = modifiers;\n    }\n", "    public boolean isStatic() {\n        return this.modifiers.contains(Modifier.STATIC);\n    }\n\n    boolean isInstancePrivate() {\n        return this.modifiers.contains(Modifier.PRIVATE)\n            && this.modifiers.contains(Modifier.INSTANCE);\n    }\n\n    boolean isInstancePackage() {\n        return this.modifiers.contains(Modifier.PACKAGE_PRIVATE)\n            && this.modifiers.contains(Modifier.INSTANCE);\n    }\n\n    boolean isInstanceOverridden() {\n        return this.modifiers.contains(Modifier.OVERRIDDEN)\n            && this.modifiers.contains(Modifier.INSTANCE);\n    }\n\n    boolean isInstancePublic() {\n        return this.modifiers.contains(Modifier.PUBLIC)\n            && this.modifiers.contains(Modifier.INSTANCE)\n            && !this.modifiers.contains(Modifier.OVERRIDDEN);\n    }\n\n    boolean isStaticPackagePrivate() {\n        return this.modifiers.contains(Modifier.PACKAGE_PRIVATE)\n            && this.modifiers.contains(Modifier.STATIC);\n    }\n\n    boolean isStaticPublic() {\n        return this.modifiers.contains(Modifier.PUBLIC)\n            && this.modifiers.contains(Modifier.STATIC);\n    }\n\n    boolean isStaticPrivate() {\n        return this.modifiers.contains(Modifier.PRIVATE)\n            && this.modifiers.contains(Modifier.STATIC);\n    }\n\n    boolean isConstructor() {\n        return this.modifiers.contains(Modifier.CONSTRUCTOR);\n    }\n\n    boolean isNotFound() {\n        return this.modifiers.contains(Modifier.NOT_FOUND);\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsComposite.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Statistics;\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport lombok.ToString;\n", "import lombok.ToString;\n\n@ToString\npublic class StatisticsComposite implements Statistics {\n\n    private final StatisticsCase application;\n    private final Statistics rest;\n\n    StatisticsComposite(\n        final StatisticsCaseWithModifiers application,\n        final Statistics rest\n    ) {\n        this.application = application;\n        this.rest = rest;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Stream.concat(\n            this.application.cells().stream(),\n            this.rest.cells().stream()\n        ).collect(Collectors.toList());\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/ParsedMethod.java", "chunked_list": ["package filter.statistics;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport java.util.HashSet;\nimport java.util.Set;\n\nfinal class ParsedMethod {\n\n    private final MethodDeclaration method;\n    private final ParsedClass klass;", "    private final MethodDeclaration method;\n    private final ParsedClass klass;\n\n    ParsedMethod(\n        final MethodDeclaration method,\n        final ParsedClass parent\n    ) {\n        this.method = method;\n        this.klass = parent;\n    }", "        this.klass = parent;\n    }\n\n    String name() {\n        return String.format(\n            \"%s.%s\",\n            this.klass.name(),\n            this.method.getSignature().asString()\n        );\n    }", "        );\n    }\n\n    Modifiers modifiers() {\n        final Set<Modifier> modifiers = new HashSet<>();\n        if (this.method.isStatic()) {\n            modifiers.add(Modifier.STATIC);\n        } else {\n            modifiers.add(Modifier.INSTANCE);\n        }\n        if (this.method.getAnnotationByClass(Override.class).isPresent()) {\n            modifiers.add(Modifier.OVERRIDDEN);\n        }", "        if (this.method.getAnnotationByClass(Override.class).isPresent()) {\n            modifiers.add(Modifier.OVERRIDDEN);\n        }\n        if (this.method.isPublic()) {\n            modifiers.add(Modifier.PUBLIC);\n        } else if (this.method.isPrivate()) {\n            modifiers.add(Modifier.PRIVATE);\n        } else {\n            modifiers.add(Modifier.PACKAGE_PRIVATE);\n        }\n        return new Modifiers(modifiers);\n    }\n\n    boolean isStatic() {\n        return this.modifiers().isStatic();\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/SoftMetrics.java", "chunked_list": ["package filter.statistics;\n\nimport filter.StatisticsCase;\nimport filter.csv.CSVCell;\nimport java.time.Duration;\nimport java.time.LocalDate;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SoftMetrics implements StatisticsCase {\n\n    private final long loc;\n    private final LocalDate birth;\n    private final long contributors;\n    private final long stars;\n\n    public SoftMetrics(\n        final long loc,\n        final LocalDate birth,\n        final long contributors,\n        final long stars\n    ) {\n        this.loc = loc;\n        this.birth = birth;\n        this.contributors = contributors;\n        this.stars = stars;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Arrays.asList(\n            new CSVCell(\"Lines of code\", this.loc),\n            new CSVCell(\"Age (Days)\", Duration.between(this.birth, LocalDate.now()).toDays()),\n            new CSVCell(\"Contributors\", this.contributors),\n            new CSVCell(\"Stars\", this.stars)\n        );\n    }\n}\n", "\npublic class SoftMetrics implements StatisticsCase {\n\n    private final long loc;\n    private final LocalDate birth;\n    private final long contributors;\n    private final long stars;\n\n    public SoftMetrics(\n        final long loc,\n        final LocalDate birth,\n        final long contributors,\n        final long stars\n    ) {\n        this.loc = loc;\n        this.birth = birth;\n        this.contributors = contributors;\n        this.stars = stars;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Arrays.asList(\n            new CSVCell(\"Lines of code\", this.loc),\n            new CSVCell(\"Age (Days)\", Duration.between(this.birth, LocalDate.now()).toDays()),\n            new CSVCell(\"Contributors\", this.contributors),\n            new CSVCell(\"Stars\", this.stars)\n        );\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/StatisticsWithModifiers.java", "chunked_list": ["package filter.statistics;\n\nimport filter.Statistics;\nimport filter.csv.CSVCell;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class StatisticsWithModifiers implements Statistics {\n\n    private final Collection<MethodStatistics> rows;\n\n    StatisticsWithModifiers() {\n        this(new ArrayList<>());\n    }\n\n    private StatisticsWithModifiers(final Collection<MethodStatistics> rows) {\n        this.rows = rows;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Arrays.asList(\n            new CSVCell(\"Total\", this.total()),\n            new CSVCell(\"Instance Private Methods\", this.instancePrivate()),\n            new CSVCell(\"Instance Package-Private Methods\", this.instancePackagePrivate()),\n            new CSVCell(\"Instance Public Methods\", this.instancePublic()),\n            new CSVCell(\"Instance Public Overridden Methods\", this.instancePublicOverridden()),\n            new CSVCell(\"Static Private Methods\", this.staticPrivate()),\n            new CSVCell(\"Static Package-Private Methods\", this.staticPackagePrivate()),\n            new CSVCell(\"Static Public Methods\", this.staticPublic()),\n            new CSVCell(\"Not Found Methods\", this.notFound()),\n            new CSVCell(\"Constructors\", this.constructors()),\n            new CSVCell(\"Instance Private Methods, %\", this.instancePrivatePercent()),\n            new CSVCell(\"Instance Package-Private Methods, %\", this.instancePackagePrivatePercent()),\n            new CSVCell(\"Instance Public Methods, %\", this.instancePublicPercent()),\n            new CSVCell(\"Instance Public Overridden Methods, %\", this.instancePublicOverriddenPercent()),\n            new CSVCell(\"Static Private Methods, %\", this.staticPrivatePercent()),\n            new CSVCell(\"Static Package-Private Methods, %\", this.staticPackagePrivatePercent()),\n            new CSVCell(\"Static Public Methods, %\", this.staticPublicPercent()),\n            new CSVCell(\"Not Found Methods, %\", this.notFoundPercent()),\n            new CSVCell(\"Constructors, %\", this.constructorsPercent())\n        );\n    }\n\n    public Object[] csvRow(final String title) {\n        return new Object[]{\n            title,\n            this.total(),\n            this.instancePrivate(),\n            this.instancePackagePrivate(),\n            this.instancePublic(),\n            this.instancePublicOverridden(),\n            this.staticPrivate(),\n            this.staticPackagePrivate(),\n            this.staticPublic(),\n            this.notFound(),\n            this.constructors(),\n            this.instancePrivatePercent(),\n            this.instancePackagePrivatePercent(),\n            this.instancePublicPercent(),\n            this.instancePublicOverriddenPercent(),\n            this.staticPrivatePercent(),\n            this.staticPackagePrivatePercent(),\n            this.staticPublicPercent(),\n            this.notFoundPercent(),\n            this.constructorsPercent(),\n        };\n    }\n\n    StatisticsWithModifiers add(final MethodStatistics statistics) {\n        this.rows.add(statistics);\n        return this;\n    }\n\n    private long total() {\n        return this.rows.stream().mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long notFound() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isNotFound)\n            .mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long instancePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePrivate)\n            .mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long instancePackagePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePackagePrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long instancePublicOverridden() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePublicOverridden)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long instancePublic() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePublic)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPackagePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPackagePrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPublic() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPublic)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long constructors() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isConstructor)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    @Override", "\npublic class StatisticsWithModifiers implements Statistics {\n\n    private final Collection<MethodStatistics> rows;\n\n    StatisticsWithModifiers() {\n        this(new ArrayList<>());\n    }\n\n    private StatisticsWithModifiers(final Collection<MethodStatistics> rows) {\n        this.rows = rows;\n    }\n\n    @Override\n    public List<CSVCell> cells() {\n        return Arrays.asList(\n            new CSVCell(\"Total\", this.total()),\n            new CSVCell(\"Instance Private Methods\", this.instancePrivate()),\n            new CSVCell(\"Instance Package-Private Methods\", this.instancePackagePrivate()),\n            new CSVCell(\"Instance Public Methods\", this.instancePublic()),\n            new CSVCell(\"Instance Public Overridden Methods\", this.instancePublicOverridden()),\n            new CSVCell(\"Static Private Methods\", this.staticPrivate()),\n            new CSVCell(\"Static Package-Private Methods\", this.staticPackagePrivate()),\n            new CSVCell(\"Static Public Methods\", this.staticPublic()),\n            new CSVCell(\"Not Found Methods\", this.notFound()),\n            new CSVCell(\"Constructors\", this.constructors()),\n            new CSVCell(\"Instance Private Methods, %\", this.instancePrivatePercent()),\n            new CSVCell(\"Instance Package-Private Methods, %\", this.instancePackagePrivatePercent()),\n            new CSVCell(\"Instance Public Methods, %\", this.instancePublicPercent()),\n            new CSVCell(\"Instance Public Overridden Methods, %\", this.instancePublicOverriddenPercent()),\n            new CSVCell(\"Static Private Methods, %\", this.staticPrivatePercent()),\n            new CSVCell(\"Static Package-Private Methods, %\", this.staticPackagePrivatePercent()),\n            new CSVCell(\"Static Public Methods, %\", this.staticPublicPercent()),\n            new CSVCell(\"Not Found Methods, %\", this.notFoundPercent()),\n            new CSVCell(\"Constructors, %\", this.constructorsPercent())\n        );\n    }\n\n    public Object[] csvRow(final String title) {\n        return new Object[]{\n            title,\n            this.total(),\n            this.instancePrivate(),\n            this.instancePackagePrivate(),\n            this.instancePublic(),\n            this.instancePublicOverridden(),\n            this.staticPrivate(),\n            this.staticPackagePrivate(),\n            this.staticPublic(),\n            this.notFound(),\n            this.constructors(),\n            this.instancePrivatePercent(),\n            this.instancePackagePrivatePercent(),\n            this.instancePublicPercent(),\n            this.instancePublicOverriddenPercent(),\n            this.staticPrivatePercent(),\n            this.staticPackagePrivatePercent(),\n            this.staticPublicPercent(),\n            this.notFoundPercent(),\n            this.constructorsPercent(),\n        };\n    }\n\n    StatisticsWithModifiers add(final MethodStatistics statistics) {\n        this.rows.add(statistics);\n        return this;\n    }\n\n    private long total() {\n        return this.rows.stream().mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long notFound() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isNotFound)\n            .mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long instancePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePrivate)\n            .mapToLong(MethodStatistics::total).sum();\n    }\n\n    private long instancePackagePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePackagePrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long instancePublicOverridden() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePublicOverridden)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long instancePublic() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isInstancePublic)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPackagePrivate() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPackagePrivate)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long staticPublic() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isStaticPublic)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    private long constructors() {\n        return this.rows.stream()\n            .filter(MethodStatistics::isConstructor)\n            .mapToLong(MethodStatistics::total)\n            .sum();\n    }\n\n    @Override", "    public String toString() {\n        return String.format(\n            \"Total: %d, Instance Private Methods: %d, Instance Package-Private Methods: %d, Instance Public Methods: %d, Instance Public Overridden Methods: %d, Static Private Methods: %d, Static Package-Private Methods: %d, Static Public Methods: %d, Not Found Methods: %d, Constructors: %d, Instance Private Methods, %%: %s, Instance Package-Private Methods, %%: %s, Instance Public Methods, %%: %s, Instance Public Overridden Methods, %%: %s, Static Private Methods, %%: %s, Static Package-Private Methods, %%: %s, Static Public Methods, %%: %s, Not Found Methods, %%: %s, Constructors, %%: %s\",\n            this.total(),\n            this.instancePrivate(),\n            this.instancePackagePrivate(),\n            this.instancePublic(),\n            this.instancePublicOverridden(),\n            this.staticPrivate(),\n            this.staticPackagePrivate(),\n            this.staticPublic(),\n            this.notFound(),\n            this.constructors(),\n            this.instancePrivatePercent(),\n            this.instancePackagePrivatePercent(),\n            this.instancePublicPercent(),\n            this.instancePublicOverriddenPercent(),\n            this.staticPrivatePercent(),\n            this.staticPackagePrivatePercent(),\n            this.staticPublicPercent(),\n            this.notFoundPercent(),\n            this.constructorsPercent()\n        );\n    }\n\n    private String constructorsPercent() {\n        return StatisticsWithModifiers.percent(this.constructors() / (double) this.total());\n    }\n\n    private String notFoundPercent() {\n        return StatisticsWithModifiers.percent(this.notFound() / (double) this.total());\n    }\n\n    private String staticPublicPercent() {\n        return StatisticsWithModifiers.percent(this.staticPublic() / (double) this.total());\n    }\n\n    private String staticPackagePrivatePercent() {\n        return StatisticsWithModifiers.percent(this.staticPackagePrivate() / (double) this.total());\n    }\n\n    private String staticPrivatePercent() {\n        return StatisticsWithModifiers.percent(this.staticPrivate() / (double) this.total());\n    }\n\n    private String instancePublicOverriddenPercent() {\n        return StatisticsWithModifiers.percent(\n            this.instancePublicOverridden() / (double) this.total());\n    }\n\n    private String instancePublicPercent() {\n        return StatisticsWithModifiers.percent(this.instancePublic() / (double) this.total());\n    }\n\n    private String instancePackagePrivatePercent() {\n        return StatisticsWithModifiers.percent(\n            this.instancePackagePrivate() / (double) this.total());\n    }\n\n    private String instancePrivatePercent() {\n        return StatisticsWithModifiers.percent(this.instancePrivate() / (double) this.total());\n    }\n\n    private static String percent(final double value) {\n        return String.format(\"%.4f\", 100 * value);\n    }\n}\n"]}
{"filename": "src/main/java/filter/statistics/MethodStatistics.java", "chunked_list": ["package filter.statistics;\n\nclass MethodStatistics {\n\n    private final long total;\n\n    private final Modifiers modifiers;\n\n    MethodStatistics(\n        final long total,", "    MethodStatistics(\n        final long total,\n        final Modifier... modifier\n    ) {\n        this(total, new Modifiers(modifier));\n    }\n\n    MethodStatistics(\n        final long total,\n        final Modifiers modifiers", "        final long total,\n        final Modifiers modifiers\n    ) {\n        this.total = total;\n        this.modifiers = modifiers;\n    }\n\n    long total() {\n        return this.total;\n    }", "        return this.total;\n    }\n\n    boolean isInstancePrivate() {\n        return this.modifiers.isInstancePrivate();\n    }\n\n    boolean isInstancePackagePrivate() {\n        return this.modifiers.isInstancePackage();\n    }", "        return this.modifiers.isInstancePackage();\n    }\n\n    boolean isInstancePublicOverridden() {\n        return this.modifiers.isInstanceOverridden();\n    }\n\n    boolean isInstancePublic() {\n        return this.modifiers.isInstancePublic();\n    }", "        return this.modifiers.isInstancePublic();\n    }\n\n    boolean isStaticPackagePrivate() {\n        return this.modifiers.isStaticPackagePrivate();\n    }\n\n    boolean isStaticPublic() {\n        return this.modifiers.isStaticPublic();\n    }", "        return this.modifiers.isStaticPublic();\n    }\n\n    boolean isStaticPrivate() {\n        return this.modifiers.isStaticPrivate();\n    }\n\n    boolean isConstructor() {\n        return this.modifiers.isConstructor();\n    }", "        return this.modifiers.isConstructor();\n    }\n\n    public boolean isNotFound() {\n        return this.modifiers.isNotFound();\n    }\n}\n"]}
{"filename": "src/main/java/filter/app/AppRemoteZip.java", "chunked_list": ["package filter.app;\n\nimport filter.Application;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermissions;", "import java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class AppRemoteZip implements Application {\n\n    private static final int TIMEOUT = 30;\n    private static final String DEFAULT_FILENAME = \"sources.zip\";\n\n    private final String url;\n\n    private final String githubUrl;\n\n    public AppRemoteZip(final String url) {\n        this(url, null);\n    }\n\n    public AppRemoteZip(final String url, final String githubUrl) {\n        this.url = url;\n        this.githubUrl = githubUrl;\n    }\n\n    @Override", "    public Path path() {\n        try {\n            final Path destination = Files.createTempDirectory(\"github-app-\");\n            Files.setPosixFilePermissions(destination,\n                PosixFilePermissions.fromString(\"rwxrwxrwx\")\n            );\n            destination.toFile().deleteOnExit();\n            Logger.getLogger(\"Archive Downloader\")\n                .info(\n                    () -> String.format(\n                        \"Downloading the sources archive %s into %s\",\n                        this.url,\n                        destination.toAbsolutePath()\n                    )\n                );\n            Runtime runtime = Runtime.getRuntime();\n            final Process download = runtime.exec(this.download(destination));\n            download.waitFor(AppRemoteZip.TIMEOUT, TimeUnit.SECONDS);\n            final int exitValue = download.exitValue();", "            if (exitValue != 0 && exitValue != 1) {\n                throw new IllegalStateException(\n                    String.format(\n                        \"Error while coping repository, the exit value %s is not 0, command is '%s', log is:%n %s\",\n                        exitValue,\n                        String.join(\" \", this.download(destination)),\n                        new BufferedReader(\n                            new InputStreamReader(download.getErrorStream())\n                        ).lines().collect(Collectors.joining(\"\\n\"))\n                    )\n                );\n            }\n            final Process unzip = runtime.exec(this.unzip(destination));", "            if (!unzip.waitFor(AppRemoteZip.TIMEOUT, TimeUnit.SECONDS)) {\n                throw new IllegalStateException(\n                    String.format(\n                        \"Timeout during unzipping, command is '%s', log is '%s'\",\n                        String.join(\" \", this.unzip(destination)),\n                        new BufferedReader(\n                            new InputStreamReader(unzip.getErrorStream())\n                        ).lines().collect(Collectors.joining(\"\\n\"))\n                    )\n                );\n            }\n            final int unzipExitValue = unzip.exitValue();", "            if (unzipExitValue != 0) {\n                throw new IllegalStateException(\n                    String.format(\n                        \"Error while unzipping repository, the exit value %s is not 0, command is '%s'\",\n                        unzipExitValue,\n                        String.join(\" \", this.unzip(destination))\n                    )\n                );\n            }\n            this.markDownloadedFilesForDelete(destination);\n            return destination;\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Some problems encountered while working with temporary directory and downloading %s\",\n                    this.url\n                ),\n                ex\n            );\n        } catch (final InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(\n                \"Timeout while cloning the repository\",\n                ex\n            );\n        }\n    }\n\n    @Override", "    public String githubUrl() {\n        return this.githubUrl;\n    }\n\n    private void markDownloadedFilesForDelete(final Path destination) {\n        destination.toFile().deleteOnExit();\n        try (final Stream<Path> walk = Files.walk(destination)) {\n            walk.map(Path::toFile).forEach(File::deleteOnExit);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Some problems encountered while marking files for deletion in the folder %s\",\n                    destination\n                ),\n                ex\n            );\n        }\n    }\n\n    private String[] download(final Path destination) {\n        return new String[]{\n            \"wget\",\n            \"-O\",\n            AppRemoteZip.path(destination),\n            this.url\n        };\n    }\n\n    private String[] unzip(final Path destination) {\n        return new String[]{\n            \"unzip\",\n            \"-q\",\n            AppRemoteZip.path(destination),\n            \"-d\",\n            destination.toAbsolutePath().toString()\n        };\n    }\n\n    private static String path(final Path destination) {\n        return destination.resolve(\n            AppRemoteZip.DEFAULT_FILENAME).toAbsolutePath().toString();\n    }\n}\n"]}
{"filename": "src/main/java/filter/app/AppGitHub.java", "chunked_list": ["package filter.app;\n\nimport filter.Application;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\nimport java.util.stream.Stream;", "import java.util.logging.Logger;\nimport java.util.stream.Stream;\n\npublic class AppGitHub implements Application {\n\n    private static final int TIMEOUT = 30;\n    private final String url;\n    private final String tag;\n\n    public AppGitHub(\n        final String http,\n        final String tag\n    ) {\n        this.url = http;\n        this.tag = tag;\n    }\n\n    @Override", "    public Path path() {\n        try {\n            final Path destination = Files.createTempDirectory(\"github-app-\");\n            destination.toFile().deleteOnExit();\n            Logger.getLogger(\"GitHub Downloader\")\n                .info(\n                    () -> String.format(\n                        \"Downloading the git repo %s with tag %s into %s\",\n                        this.url,\n                        this.tag,\n                        destination.toAbsolutePath()\n                    )\n                );\n            Runtime runtime = Runtime.getRuntime();\n            final Process process = runtime.exec(this.command(destination));\n            process.waitFor(AppGitHub.TIMEOUT, TimeUnit.SECONDS);\n            final int exitValue = process.exitValue();", "            if (exitValue != 0) {\n                throw new IllegalStateException(\n                    String.format(\"Error while cloning repository, the exit value %s is not 0\",\n                        exitValue\n                    )\n                );\n            }\n            this.markDownloadedFilesForDelete(destination);\n            return destination;\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Some problems encountered while working with temporary directory and downloading %s\",\n                    this.url\n                ),\n                ex\n            );\n        } catch (final InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(\n                \"Timeout while cloning the repository\",\n                ex\n            );\n        }\n    }\n\n    @Override", "    public String githubUrl() {\n        return this.url;\n    }\n\n    private void markDownloadedFilesForDelete(final Path destination) {\n        destination.toFile().deleteOnExit();\n        try (final Stream<Path> walk = Files.walk(destination)) {\n            walk.map(Path::toFile).forEach(File::deleteOnExit);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Some problems encountered while marking files for deletion in the folder %s\",\n                    destination\n                ),\n                ex\n            );\n        }\n    }\n\n    private String[] command(final Path destination) {\n        return new String[]{\n            \"git\",\n            \"clone\",\n            \"--depth=1\",\n            String.format(\"--branch=%s\", this.tag),\n            this.url,\n            destination.toAbsolutePath().toString()\n        };\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/CSVCell.java", "chunked_list": ["package filter.csv;\n\nimport lombok.EqualsAndHashCode;\nimport lombok.ToString;\n\n@ToString\n@EqualsAndHashCode\npublic class CSVCell {\n\n    private final String header;\n    private final Object value;\n\n    public CSVCell(final String header, final Object value) {\n        this.header = header;\n        this.value = value;\n    }\n", "    public String header() {\n        return this.header;\n    }\n\n    public Object value() {\n        return this.value;\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/CSVRemote.java", "chunked_list": ["package filter.csv;\n\nimport filter.CSV;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;", "import java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class CSVRemote implements CSV {\n\n    private static final String DEFAULT_PATH = \"https://raw.githubusercontent.com/volodya-lombrozo/cost-of-oop/main/src/main/profiling/\";\n\n    private final URL url;\n\n    public CSVRemote(final String subpath) {\n        this(CSVRemote.http(subpath));\n    }\n\n    private CSVRemote(final URL url) {\n        this.url = url;\n    }\n\n    private static URL http(final String subpath) {", "        try {\n            return new URL(String.format(\"%s%s\", CSVRemote.DEFAULT_PATH, subpath));\n        } catch (final MalformedURLException ex) {\n            throw new IllegalStateException(\n                String.format(\"Malformed URL %s\", subpath),\n                ex\n            );\n        }\n    }\n\n    @Override", "    public Reader reader() {\n        try {\n            final InputStream stream = this.url.openStream();\n            return new InputStreamReader(stream, StandardCharsets.UTF_8);\n        } catch (final IOException exception) {\n            throw new IllegalStateException(\n                String.format(\"Problem with reading CSV file by url %s \", this.url),\n                exception\n            );\n        }\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/CSVOutput.java", "chunked_list": ["package filter.csv;\n\nimport java.io.Closeable;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.cactoos.scalar.Sticky;\n\npublic class CSVOutput implements Closeable {\n\n    private final Sticky<CSVPrinter> csv;\n\n    public CSVOutput(final String filename) {\n        this(CSVOutput.printer(filename));\n    }\n\n    private CSVOutput(final Sticky<CSVPrinter> filename) {\n        this.csv = filename;\n    }\n", "\npublic class CSVOutput implements Closeable {\n\n    private final Sticky<CSVPrinter> csv;\n\n    public CSVOutput(final String filename) {\n        this(CSVOutput.printer(filename));\n    }\n\n    private CSVOutput(final Sticky<CSVPrinter> filename) {\n        this.csv = filename;\n    }\n", "    public void print(Iterable<?> cells) {\n        try {\n            final CSVPrinter printer = this.csv.value();\n            printer.printRecord(cells);\n        } catch (final Exception ex) {\n            throw new IllegalStateException(\n                String.format(\n                    \"Can't write CSV values %s\",\n                    cells\n                ),\n                ex\n            );\n        }\n    }\n\n    private static Sticky<CSVPrinter> printer(final String filename) {\n        return new Sticky<>(\n            () -> new CSVPrinter(\n                new FileWriter(filename),\n                CSVFormat.RFC4180\n            )\n        );\n    }\n\n    @Override", "    public void close() throws IOException {\n        try {\n            final CSVPrinter printer = this.csv.value();\n            printer.flush();\n            printer.close();\n        } catch (final Exception ex) {\n            throw new IOException(\"Can't retrieve csv printer\", ex);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/ParsedCSVRow.java", "chunked_list": ["package filter.csv;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport org.apache.commons.csv.CSVRecord;\n\npublic final class ParsedCSVRow {\n\n    private final CSVRecord record;\n\n    ParsedCSVRow(final CSVRecord record) {\n        this.record = record;\n    }\n\n    boolean isNotHeader() {\n        return !\"Method\".equals(this.fullMethodName());\n    }\n\n    boolean withinPackage(final String pckg) {\n        return this.fullMethodName().startsWith(pckg);\n    }\n", "    public boolean isConstructor() {\n        return this.fullMethodName().contains(\"<init>\");\n    }\n\n    public String shortMethodName() {\n        final String full = this.fullMethodName();\n        final int endIndex = full.lastIndexOf(\" \");\n        if (endIndex == -1) {\n            return full;\n        }\n        return full.substring(0, endIndex).replaceAll(\"\\\\$\", \".\");\n    }\n\n    /**\n     * Converts\n     *  ognl.OgnlRuntime.isTypeCompatible(Class, Class, int, OgnlRuntime$ArgsCompatbilityReport) OgnlRuntime.java\n     * Into\n     *  ognl.OgnlRuntime.isTypeCompatible(Class, Class, int, ArgsCompatbilityReport)\n     * @return\n     */", "    public String shortMethodNameWithoutFQNForParameters() {\n        final String full = this.fullMethodName();\n        final int endIndex = full.lastIndexOf(\" \");\n        if (endIndex == -1) {\n            return full;\n        }\n        final String withParams = full.substring(0, endIndex);\n        final int startParams = withParams.indexOf(\"(\");\n        final String name = withParams.substring(0, startParams);\n        final List<String> params = Arrays.stream(withParams.substring(startParams + 1,\n                withParams.length() - 1\n            ).split(\",\"))\n            .map(String::trim)\n            .map(\n                param -> {", "                    if (param.contains(\"$\")) {\n                        return param.substring(param.lastIndexOf(\"$\") + 1);\n                    } else {\n                        return param;\n                    }\n                }\n            )\n            .collect(Collectors.toList());\n        return String.format(\"%s(%s)\", name, String.join(\", \", params));\n    }\n\n", "    public String fullMethodName() {\n        return this.record.get(\"Method\");\n    }\n\n    @Deprecated\n    public double getOwnTime() {\n        final String raw = this.record.get(\"Own Time (ms)\");\n        final double res;\n        if (raw.contains(\"<\")) {\n            res = 0.1;\n        } else {\n            res = Double.parseDouble(raw);\n        }\n        return res;\n    }\n", "        if (raw.contains(\"<\")) {\n            res = 0.1;\n        } else {\n            res = Double.parseDouble(raw);\n        }\n        return res;\n    }\n\n    public long getCount() {\n        return Long.valueOf(this.record.get(\"Count\"));\n    }\n}\n", "    public long getCount() {\n        return Long.valueOf(this.record.get(\"Count\"));\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/CorrelationCSV.java", "chunked_list": ["package filter.csv;\n\nimport filter.CSV;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;", "import java.util.Map;\nimport java.util.stream.Collectors;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVRecord;\nimport org.apache.commons.math3.stat.correlation.PearsonsCorrelation;\nimport static java.math.RoundingMode.HALF_UP;\n\npublic class CorrelationCSV {\n\n    private final CSV csv;\n\n    private final Map<String, List<Double>> columns;\n\n    private final Map<String, Map<String, Double>> pearson;\n\n    public CorrelationCSV(final CSV csv) {\n        this.csv = csv;\n        this.columns = new HashMap<>();\n        this.pearson = new HashMap<>();\n    }\n", "public class CorrelationCSV {\n\n    private final CSV csv;\n\n    private final Map<String, List<Double>> columns;\n\n    private final Map<String, Map<String, Double>> pearson;\n\n    public CorrelationCSV(final CSV csv) {\n        this.csv = csv;\n        this.columns = new HashMap<>();\n        this.pearson = new HashMap<>();\n    }\n", "    public void report() {\n        try {\n            final CSVParser parse = CSVFormat.DEFAULT.parse(csv.reader());\n            final List<CSVRecord> records = parse.getRecords();\n            final List<String> headers = records.get(0)\n                .stream()\n                .sorted()\n                .collect(Collectors.toList());\n            for (int i = 1; i < records.size(); i++) {\n                final CSVRecord record = records.get(i);\n                for (int j = 1; j < record.size(); j++) {\n                    final double value = Double.parseDouble(record.get(j));\n                    final String header = headers.get(j);\n                    this.columns.putIfAbsent(header, new ArrayList<>());\n                    this.columns.get(header).add(value);\n                }\n            }\n            this.calculatePearsonCorrelation();\n            this.printPearsonCorrelation();\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"Can't count correlation\", ex);\n        }\n    }\n\n    private void printPearsonCorrelation() {\n        final CSVOutput output = new CSVOutput(\"correlation.csv\");\n        final List<String> columnHeaders = this.pearson.keySet().stream()\n            .sorted().collect(Collectors.toList());\n        final List<String> leftColumnHeader = this.pearson.values().iterator().next().keySet()\n            .stream().sorted().collect(Collectors.toList());\n\n        List<String> headers = new ArrayList<>();\n        headers.add(\"N/A\");\n        headers.addAll(columnHeaders);\n        output.print(headers);\n", "            for (int i = 1; i < records.size(); i++) {\n                final CSVRecord record = records.get(i);\n                for (int j = 1; j < record.size(); j++) {\n                    final double value = Double.parseDouble(record.get(j));\n                    final String header = headers.get(j);\n                    this.columns.putIfAbsent(header, new ArrayList<>());\n                    this.columns.get(header).add(value);\n                }\n            }\n            this.calculatePearsonCorrelation();\n            this.printPearsonCorrelation();\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"Can't count correlation\", ex);\n        }\n    }\n\n    private void printPearsonCorrelation() {\n        final CSVOutput output = new CSVOutput(\"correlation.csv\");\n        final List<String> columnHeaders = this.pearson.keySet().stream()\n            .sorted().collect(Collectors.toList());\n        final List<String> leftColumnHeader = this.pearson.values().iterator().next().keySet()\n            .stream().sorted().collect(Collectors.toList());\n\n        List<String> headers = new ArrayList<>();\n        headers.add(\"N/A\");\n        headers.addAll(columnHeaders);\n        output.print(headers);\n", "        for (final String rowHeader : leftColumnHeader) {\n            List<Object> row = new ArrayList<>();\n            row.add(rowHeader);\n            for (final String columnHeader : columnHeaders) {\n                final Double value = this.pearson.get(columnHeader).get(rowHeader);\n                BigDecimal bd = BigDecimal.valueOf(value);\n                bd = bd.setScale(2, HALF_UP);\n                row.add(bd.doubleValue());\n            }\n            output.print(row);\n        }", "        try {\n            output.close();\n        } catch (final IOException ex) {\n            throw new IllegalStateException(\n                \"Something strange is happened with closing output CSV\",\n                ex\n            );\n        }\n    }\n\n    private void calculatePearsonCorrelation() {\n        final List<String> headers = new ArrayList<>(this.columns.keySet());", "        for (int i = 0; i < headers.size(); i++) {\n            final String first = headers.get(i);\n            if (!first.contains(\"GitHub\")) {\n                continue;\n            }\n            for (int j = 0; j < headers.size(); j++) {\n                final String second = headers.get(j);\n                if (second.contains(\"GitHub\") || second.contains(\"%\")) {\n                    continue;\n                }\n                final double correlation = this.correlation(\n                    this.columns.get(first),\n                    this.columns.get(second)\n                );\n                setPearsonCell(first, second, correlation);\n                System.out.format(\n                    \"'%s' <-------> '%s' ========== %.2f%n\",\n                    first,\n                    second,\n                    correlation\n                );\n            }\n            System.out.println(\"__________________________________\");\n        }\n    }\n\n    private double correlation(List<Double> first, List<Double> second) {\n        return new PearsonsCorrelation().correlation(\n            first.stream().mapToDouble(a -> a).toArray(),\n            second.stream().mapToDouble(a -> a).toArray()\n        );\n    }\n\n    private void setPearsonCell(final String first, final String second, final double pearson) {\n        this.pearson.putIfAbsent(first, new HashMap<>());\n        final Map<String, Double> column = this.pearson.get(first);\n        column.put(second, pearson);\n    }\n\n}\n"]}
{"filename": "src/main/java/filter/csv/CSVRows.java", "chunked_list": ["package filter.csv;\n\nimport filter.CSV;\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\n\npublic final class CSVRows {\n\n    private static final String[] EMPTY = {};\n    private final CSV csv;\n    private final String[] filters;\n\n    private final String[] excluded;\n\n    public CSVRows(final CSV csv, final String[] filters) {\n        this(csv, filters, CSVRows.EMPTY);\n    }\n\n    public CSVRows(final CSV csv, final String[] filters, final String[] excluded) {\n        this.csv = csv;\n        this.filters = filters;\n        this.excluded = excluded;\n    }\n\n    public Set<ParsedCSVRow> toSet() {", "\npublic final class CSVRows {\n\n    private static final String[] EMPTY = {};\n    private final CSV csv;\n    private final String[] filters;\n\n    private final String[] excluded;\n\n    public CSVRows(final CSV csv, final String[] filters) {\n        this(csv, filters, CSVRows.EMPTY);\n    }\n\n    public CSVRows(final CSV csv, final String[] filters, final String[] excluded) {\n        this.csv = csv;\n        this.filters = filters;\n        this.excluded = excluded;\n    }\n\n    public Set<ParsedCSVRow> toSet() {", "        try {\n            final CSVParser parse = CSVFormat.RFC4180.withHeader(\n                \"Method\",\n                \"Time (ms)\",\n                \"Avg. Time (ms)\",\n                \"Own Time (ms)\",\n                \"Count\"\n            ).parse(this.csv.reader());\n            return parse.getRecords().stream().map(ParsedCSVRow::new)\n                .filter(ParsedCSVRow::isNotHeader)\n                .filter(this::isFiltered)\n                .filter(this::isNotExcluded)\n                .collect(Collectors.toSet());\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    private boolean isFiltered(final ParsedCSVRow row) {\n        boolean result;", "        if (this.filters.length == 0) {\n            result = true;\n        } else {\n            result = row.withinPackage(this.filters[0]);\n        }\n        return result;\n    }\n\n    private boolean isNotExcluded(final ParsedCSVRow row) {\n        boolean result = true;\n        for (final String exclusion : this.excluded) {", "        for (final String exclusion : this.excluded) {\n            if (row.fullMethodName().startsWith(exclusion)) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n}\n"]}
{"filename": "src/main/java/filter/csv/CSVLocal.java", "chunked_list": ["package filter.csv;\n\nimport filter.CSV;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.Reader;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class CSVLocal implements CSV {\n\n    private final Path csv;\n\n    public CSVLocal(final String path) {\n        this(Paths.get(path));\n    }\n\n    private CSVLocal(final Path path) {\n        this.csv = path;\n    }\n\n    @Override", "\npublic class CSVLocal implements CSV {\n\n    private final Path csv;\n\n    public CSVLocal(final String path) {\n        this(Paths.get(path));\n    }\n\n    private CSVLocal(final Path path) {\n        this.csv = path;\n    }\n\n    @Override", "    public Reader reader() {\n        try {\n            return new FileReader(this.csv.toFile());\n        } catch (final FileNotFoundException ex) {\n            throw new IllegalStateException(\n                String.format(\"Problem with reading CSV file %s\", this.csv),\n                ex\n            );\n        }\n    }\n}\n"]}
