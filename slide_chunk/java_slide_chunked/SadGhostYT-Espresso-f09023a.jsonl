{"filename": "src/test/java/PreconditionsTest.java", "chunked_list": ["import dev.sadghost.espresso.base.Preconditions;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass PreconditionsTest {\n\n    @Test\n    void testCheckNotNullWithNonNullObject() {", "    @Test\n    void testCheckNotNullWithNonNullObject() {\n        // Arrange\n        Object obj = new Object();\n\n        // Act and Assert\n        assertDoesNotThrow(() -> Preconditions.checkNonNull(obj));\n    }\n\n    @Test", "\n    @Test\n    void testCheckNotNullWithNullObject() {\n        // Arrange\n        Object obj = null;\n\n        // Act and Assert\n        assertThrows(NullPointerException.class, () -> Preconditions.checkNonNull(obj));\n    }\n", "    }\n\n    @Test\n    void testCheckArgumentWithTrueCondition() {\n        // Arrange\n        boolean condition = true;\n\n        // Act and Assert\n        assertDoesNotThrow(() -> Preconditions.checkArgument(condition));\n    }", "        assertDoesNotThrow(() -> Preconditions.checkArgument(condition));\n    }\n\n    @Test\n    void testCheckArgumentWithFalseCondition() {\n        // Arrange\n        boolean condition = false;\n\n        // Act and Assert\n        assertThrows(IllegalArgumentException.class, () -> Preconditions.checkArgument(condition));", "        // Act and Assert\n        assertThrows(IllegalArgumentException.class, () -> Preconditions.checkArgument(condition));\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/exceptions/NotImplementedException.java", "chunked_list": ["package dev.sadghost.espresso.exceptions;\n\n/**\n * The {@code NotImplementedException} class represents an exception that is thrown to indicate that a particular\n * feature or functionality is not implemented.\n * <p>\n * This class extends the {@link UnsupportedOperationException} class, which is a runtime exception indicating that\n * the requested operation is not supported.\n * <p>\n * This exception can be used to signal that a method or feature is not implemented and should not be called. It can", " * <p>\n * This exception can be used to signal that a method or feature is not implemented and should not be called. It can\n * be thrown when a class or method is under development or when a certain functionality is intentionally omitted.\n * <p>\n * Example usage:\n * <pre>\n * {@code\n * throw new NotImplementedException(\"This feature is not yet implemented\");\n * }\n * </pre>", " * }\n * </pre>\n *\n * @see UnsupportedOperationException\n */\npublic final class NotImplementedException extends UnsupportedOperationException {\n\n    /**\n     * Constructs a new {@code NotImplementedException} with no detail message.\n     */\n    public NotImplementedException() {\n        super();\n    }\n\n    /**\n     * Constructs a new {@code NotImplementedException} with the specified detail message.\n     *\n     * @param message the detail message describing the reason for the exception.\n     */\n    public NotImplementedException(String message) {\n        super(message);\n    }\n\n    /**\n     * Constructs a new {@code NotImplementedException} with the specified detail message and cause.\n     *\n     * @param message the detail message describing the reason for the exception.\n     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method).\n     */\n    public NotImplementedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    /**\n     * Constructs a new {@code NotImplementedException} with the specified cause and a detail message\n     * that is based on the cause.\n     *\n     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).\n     */\n    public NotImplementedException(Throwable cause) {\n        super(cause);\n    }\n}"]}
{"filename": "src/main/java/dev/sadghost/espresso/groups/Pair.java", "chunked_list": ["package dev.sadghost.espresso.groups;\n\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Objects;\n\n/**\n * A simple generic class representing a pair of objects.", "/**\n * A simple generic class representing a pair of objects.\n *\n * @since 1.0.0\n * @author SadGhost\n * @param <A> the type of the first object.\n * @param <B> the type of the second object.\n */\npublic class Pair<A, B> {\n    @NotNull\n    private A a;\n    @NotNull\n    private B b;\n\n    /**\n     * Constructs a new Pair object with the given objects.\n     *\n     * @param a the first object.\n     * @param b the second object.\n     */\n    @Contract(pure = true)\n    public Pair(final @NotNull A a, final @NotNull B b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    /**\n     * Retrieves the first object of the pair.\n     *\n     * @return the first object.\n     */\n    public @NotNull A getA() {\n        return a;\n    }\n\n    /**\n     * Sets the first object of the pair.\n     *\n     * @param a the new value for the first object.\n     */", "public class Pair<A, B> {\n    @NotNull\n    private A a;\n    @NotNull\n    private B b;\n\n    /**\n     * Constructs a new Pair object with the given objects.\n     *\n     * @param a the first object.\n     * @param b the second object.\n     */\n    @Contract(pure = true)\n    public Pair(final @NotNull A a, final @NotNull B b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    /**\n     * Retrieves the first object of the pair.\n     *\n     * @return the first object.\n     */\n    public @NotNull A getA() {\n        return a;\n    }\n\n    /**\n     * Sets the first object of the pair.\n     *\n     * @param a the new value for the first object.\n     */", "    public void setA(final @NotNull A a) {\n        this.a = a;\n    }\n\n    /**\n     * Retrieves the second object of the pair.\n     *\n     * @return the second object.\n     */\n    public @NotNull B getB() {\n        return b;\n    }\n\n    /**\n     * Sets the second object of the pair.\n     *\n     * @param b the new value for the second object.\n     */", "    public void setB(final @NotNull B b) {\n        this.b = b;\n    }\n\n    @Override\n    public boolean equals(final @Nullable Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        final Pair<?, ?> pair = (Pair<?, ?>) o;\n        if (!Objects.equals(a, pair.a)) return false;\n        return Objects.equals(b, pair.b);\n    }\n\n    @Override", "        if (!Objects.equals(a, pair.a)) return false;\n        return Objects.equals(b, pair.b);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = a.hashCode();\n        result = 31 * result + b.hashCode();\n        return result;\n    }\n\n    @Override\n    public @NotNull String toString() {\n        return \"Pair{\" +\n                \"a=\" + a +\n                \", b=\" + b +\n                '}';\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/time/TimeUtils.java", "chunked_list": ["package dev.sadghost.espresso.time;\n\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\n/**\n * The {@code TimeUtils} class is a utility class for formatting and manipulating time.", "/**\n * The {@code TimeUtils} class is a utility class for formatting and manipulating time.\n * It provides methods for retrieving the current date, parsing time strings, formatting time durations,\n * and formatting seconds into a specific time format.\n * <p>\n * The class uses milliseconds as the standard unit of time for calculations and conversions.\n *\n * <h3>Usage Example:</h3>\n * <pre>{@code\n * String currentDate = TimeUtils.getCurrentDate(\"yyyy-MM-dd\");", " * <pre>{@code\n * String currentDate = TimeUtils.getCurrentDate(\"yyyy-MM-dd\");\n * long timeDuration = TimeUtils.parseTime(\"1y2m\");\n * String formattedTime = TimeUtils.formatTime(timeDuration);\n * String formattedSeconds = TimeUtils.formatSeconds(300);\n * }</pre>\n *\n * @author SadGhost\n * @since 1.0.0\n */\npublic class TimeUtils {\n    // Constants for milliseconds conversion\n    private static final long MILLISECONDS_IN_SECOND = 1000;\n    private static final long MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * 60;\n    private static final long MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * 60;\n    private static final long MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * 24;\n    private static final long MILLISECONDS_IN_WEEK = MILLISECONDS_IN_DAY * 7;\n    private static final long MILLISECONDS_IN_MONTH = MILLISECONDS_IN_DAY * 30;\n    private static final long MILLISECONDS_IN_YEAR = MILLISECONDS_IN_DAY * 365;\n\n    /**\n     * Private constructor to prevent instantiation of this utility class.\n     */\n    @Contract(pure = true)\n    private TimeUtils() {\n    }\n\n    /**\n     * Returns the current date formatted according to the given pattern.\n     *\n     * @param pattern the pattern to use for formatting the date\n     * @return the current date as a string formatted according to the pattern\n     * @since 1.0.0\n     */\n    public static @NotNull String getCurrentDate(final @NotNull String pattern) {\n        final DateTimeFormatter dtf = DateTimeFormatter.ofPattern(pattern);\n        return dtf.format(LocalDateTime.now());\n    }\n\n    /**\n     * Parses the given time string and returns the corresponding duration in milliseconds.\n     *\n     * @param time the time string to parse\n     * @return the parsed time duration in milliseconds\n     * @since 1.0.0\n     */", " * @since 1.0.0\n */\npublic class TimeUtils {\n    // Constants for milliseconds conversion\n    private static final long MILLISECONDS_IN_SECOND = 1000;\n    private static final long MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * 60;\n    private static final long MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * 60;\n    private static final long MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * 24;\n    private static final long MILLISECONDS_IN_WEEK = MILLISECONDS_IN_DAY * 7;\n    private static final long MILLISECONDS_IN_MONTH = MILLISECONDS_IN_DAY * 30;\n    private static final long MILLISECONDS_IN_YEAR = MILLISECONDS_IN_DAY * 365;\n\n    /**\n     * Private constructor to prevent instantiation of this utility class.\n     */\n    @Contract(pure = true)\n    private TimeUtils() {\n    }\n\n    /**\n     * Returns the current date formatted according to the given pattern.\n     *\n     * @param pattern the pattern to use for formatting the date\n     * @return the current date as a string formatted according to the pattern\n     * @since 1.0.0\n     */\n    public static @NotNull String getCurrentDate(final @NotNull String pattern) {\n        final DateTimeFormatter dtf = DateTimeFormatter.ofPattern(pattern);\n        return dtf.format(LocalDateTime.now());\n    }\n\n    /**\n     * Parses the given time string and returns the corresponding duration in milliseconds.\n     *\n     * @param time the time string to parse\n     * @return the parsed time duration in milliseconds\n     * @since 1.0.0\n     */", "    public static long parseTime(final @NotNull String time) {\n        long milliseconds = 0;\n        final char[] timeArray = time.toCharArray();\n\n        for (int i = 0; i < timeArray.length; i++) {\n            switch (timeArray[i]) {\n                case 's' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_SECOND);\n                case 'm' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_MINUTE);\n                case 'h' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_HOUR);\n                case 'd' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_DAY);\n                case 'w' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_WEEK);\n                case 'M' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_MONTH);\n                case 'y' -> milliseconds += parseSpecificTime(timeArray, i, MILLISECONDS_IN_YEAR);\n            }\n        }\n\n        return milliseconds;\n    }\n\n    /**\n     * Utility function to parse a specific time unit from the time string.\n     *\n     * @param timeArray the array of characters representing the time string\n     * @param index the current index in the array\n     * @param millisecondsModifier the multiplier to convert the result to milliseconds\n     * @return the parsed specific time unit in milliseconds\n     * @since 1.0.0\n     */\n    private static long parseSpecificTime(final char @NotNull[] timeArray,\n                                          final int index,\n                                          final long millisecondsModifier) {\n        long milliseconds = 0;\n        int j = index - 1;\n        int counter = 1;\n", "        while (j >= 0 && Character.isDigit(timeArray[j])) {\n            milliseconds += counter * Integer.parseInt(String.valueOf(timeArray[j])) * millisecondsModifier;\n            counter = counter * 10;\n            j--;\n        }\n\n        return milliseconds;\n    }\n\n    /**\n     * Formats the given time duration in milliseconds into a human-readable string representation.\n     *\n     * @param time the time duration in milliseconds\n     * @return a human-readable string representation of the time duration\n     * @since 1.0.0\n     */\n    public static @NotNull String formatTime(long time) {", "        if (time < 0) return \"Forever\";\n\n        final long years = time / MILLISECONDS_IN_YEAR;\n        time -= MILLISECONDS_IN_YEAR * years;\n\n        final long months = time / MILLISECONDS_IN_MONTH;\n        time -= MILLISECONDS_IN_MONTH * months;\n\n        final long weeks = time / MILLISECONDS_IN_WEEK;\n        time -= MILLISECONDS_IN_WEEK * weeks;\n\n        final long days = time / MILLISECONDS_IN_DAY;\n        time -= MILLISECONDS_IN_DAY * days;\n\n        final long hours = time / MILLISECONDS_IN_HOUR;\n        time -= MILLISECONDS_IN_HOUR * hours;\n\n        final long minutes = time / MILLISECONDS_IN_MINUTE;\n        time -= MILLISECONDS_IN_MINUTE * minutes;\n\n        final long seconds = time / MILLISECONDS_IN_SECOND;\n\n        final StringBuilder formattedTime = new StringBuilder();", "        if (years > 0) formattedTime.append(years).append(\" year\").append(years > 1 ? \"s\" : \"\").append(\", \");\n        if (months > 0) formattedTime.append(months).append(\" month\").append(months > 1 ? \"s\" : \"\").append(\", \");\n        if (weeks > 0) formattedTime.append(weeks).append(\" week\").append(weeks > 1 ? \"s\" : \"\").append(\", \");\n        if (days > 0) formattedTime.append(days).append(\" day\").append(days > 1 ? \"s\" : \"\").append(\", \");\n        if (hours > 0) formattedTime.append(hours).append(\" hour\").append(hours > 1 ? \"s\" : \"\").append(\", \");\n        if (minutes > 0) formattedTime.append(minutes).append(\" minute\").append(minutes > 1 ? \"s\" : \"\").append(\", \");\n        if (seconds > 0) formattedTime.append(seconds).append(\" second\").append(seconds > 1 ? \"s\" : \"\");\n\n        final int length = formattedTime.length();\n        if (length >= 2 && formattedTime.charAt(length - 2) == ',') {\n            formattedTime.replace(length - 2, length, \"\");\n        }\n\n        return formattedTime.toString();\n    }\n\n    /**\n     * Formats the given number of seconds into the \"XX:XX\" format.\n     *\n     * @param seconds the number of seconds to format\n     * @return the formatted time in the \"XX:XX\" format\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public static @NotNull String formatSeconds(int seconds) {\n        final int minutes = seconds / 60;\n        seconds = seconds % 60;\n\n        String sMinutes = String.valueOf(minutes);\n        String sSeconds = String.valueOf(seconds);\n", "        if (length >= 2 && formattedTime.charAt(length - 2) == ',') {\n            formattedTime.replace(length - 2, length, \"\");\n        }\n\n        return formattedTime.toString();\n    }\n\n    /**\n     * Formats the given number of seconds into the \"XX:XX\" format.\n     *\n     * @param seconds the number of seconds to format\n     * @return the formatted time in the \"XX:XX\" format\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public static @NotNull String formatSeconds(int seconds) {\n        final int minutes = seconds / 60;\n        seconds = seconds % 60;\n\n        String sMinutes = String.valueOf(minutes);\n        String sSeconds = String.valueOf(seconds);\n", "        if (minutes < 10) sMinutes = \"0\" + minutes;\n        if (seconds < 10) sSeconds = \"0\" + seconds;\n\n        return sMinutes + \":\" + sSeconds;\n    }\n}"]}
{"filename": "src/main/java/dev/sadghost/espresso/base/Preconditions.java", "chunked_list": ["package dev.sadghost.espresso.base;\n\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * The {@code Preconditions} class is a utility class used to ensure the conditions of arguments within the code.\n * It provides methods for validating arguments, such as checking for truthiness or non-nullity, and throws appropriate\n * exceptions if the conditions are not met.", " * It provides methods for validating arguments, such as checking for truthiness or non-nullity, and throws appropriate\n * exceptions if the conditions are not met.\n * <p>\n * The class follows a design pattern commonly known as \"preconditions\" or \"assertions,\" which allows developers to\n * express their expectations about the values passed to a method or constructor.\n * <p>\n * By using the preconditions provided by this class, developers can enhance code reliability and catch potential\n * issues early in the development process.\n * <p>\n * This class is marked as final to prevent subclassing and promote the use of its static methods directly.", " * <p>\n * This class is marked as final to prevent subclassing and promote the use of its static methods directly.\n *\n * <h3>Usage Example:</h3>\n * <pre>{@code\n * public void processUser(User user) {\n *     Preconditions.checkNonNull(user, \"User cannot be null\");\n *     // Perform user processing logic\n * }\n * }</pre>\n *\n * @author SadGhost\n * @since 1.0.0\n */", "public final class Preconditions {\n\n    /**\n     * Seals the class to prevent instantiation.\n     */\n    @Contract(pure = true)\n    private Preconditions() {}\n\n    /**\n     * Ensures that the provided boolean value is true.\n     * <p>\n     * If the value is false, an {@link IllegalArgumentException} is thrown without a specific exception message.\n     * <p>\n     * This method is a convenience wrapper for {@link #checkArgument(boolean, String)}, where the message is not\n     * explicitly provided.\n     *\n     * @param value a boolean value.\n     * @throws IllegalArgumentException if the value is {@code false}.\n     * @see #checkArgument(boolean, String)\n     * @since 1.0.0\n     */\n    @Contract(value = \"false -> fail\", pure = true)", "    public static void checkArgument(final boolean value) {\n        checkArgument(value, null);\n    }\n\n    /**\n     * Ensures that the provided boolean value is true.\n     * <p>\n     * If the value is false, an {@link IllegalArgumentException} is thrown with the specified exception message.\n     * <p>\n     * This method is useful for validating conditions that should be met before proceeding with further code execution.\n     *\n     * <h4>Usage Example:</h4>\n     * <pre>{@code", "     * public void processUser(User user) {\n     *     Preconditions.checkArgument(user.isEnabled(), \"User must be enabled\");\n     *     // Perform user processing logic\n     * }\n     * }</pre>\n     *\n     * @param value   the provided value to validate.\n     * @param message the exception message to be included in the thrown exception if the condition is not met.\n     * @throws IllegalArgumentException if the value is {@code false}.\n     * @since 1.0.0\n     */\n    @Contract(value = \"false, _ -> fail\", pure = true)", "    public static void checkArgument(final boolean value,\n                                     final @Nullable String message) {\n        if (!value) {\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    /**\n     * Ensures that the provided argument is not null and returns the argument if it is not null.\n     * <p>\n     * If the argument is null, a {@link NullPointerException} is thrown without a specific exception message.\n     * <p>\n     * This method is a convenience wrapper for {@link #checkNonNull(Object, String)}, where the message is not\n     * explicitly provided.\n     *\n     * @param value the provided value to validate.\n     * @param <T>   the type of argument to validate.\n     * @return the provided argument if it is not null.\n     * @throws NullPointerException if the value is {@code null}.\n     * @see #checkNonNull(Object, String)\n     * @since 1.0.0\n     */\n    @Contract(value = \"null -> fail; !null -> param1\", pure = true)\n    public static <T> @NotNull T checkNonNull(final @Nullable T value) {\n        return checkNonNull(value, null);\n    }\n\n    /**\n     * Ensures that the provided argument is not null and returns the argument if it is not null.\n     * <p>\n     * If the argument is null, a {@link NullPointerException} is thrown with the specified exception message.\n     * <p>\n     * This method is useful for validating that required arguments are not null before using them in code.\n     *\n     * <h4>Usage Example:</h4>\n     * <pre>{@code", "     * public void processUser(User user) {\n     *     Preconditions.checkNonNull(user, \"User cannot be null\");\n     *     // Perform user processing logic\n     * }\n     * }</pre>\n     *\n     * @param value   the provided value to validate.\n     * @param message the exception message to be included in the thrown exception if the value is null.\n     * @param <T>     the type of argument to validate.\n     * @return the provided argument if it is not null.\n     * @throws NullPointerException if the value is {@code null}.\n     * @since 1.0.0\n     */\n    @Contract(value = \"null, _ -> fail; !null, _ -> param1\", pure = true)\n    public static <T> @NotNull T checkNonNull(final @Nullable T value,\n                                              final @Nullable String message) {", "        if (value == null) {\n            throw new NullPointerException(message);\n        }\n        return value;\n    }\n}\n\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/base/IReloadable.java", "chunked_list": ["package dev.sadghost.espresso.base;\n\n/**\n * The {@code IReloadable} interface represents an instance that can be reloaded,\n * providing methods for reloading its data or performing specific actions.\n * <p>\n * This interface is typically used in scenarios where a plugin or module needs to support\n * reloading its configuration or state without restarting the entire application.\n * <p>\n * By implementing this interface, classes indicate that they have the ability to reload their", " * <p>\n * By implementing this interface, classes indicate that they have the ability to reload their\n * internal state or perform any necessary actions to update themselves based on external changes.\n *\n * <h3>Usage Example:</h3>\n * <pre>{@code\n * public class Plugin implements IReloadable {\n *     // Implementation of other methods\n *\n *     {@literal @}Override\n *     public void reload() {\n *         // Perform plugin-specific reloading logic\n *     }\n * }\n *", " *     public void reload() {\n *         // Perform plugin-specific reloading logic\n *     }\n * }\n *\n * public class Configuration implements IReloadable {\n *     // Implementation of other methods\n *\n *     {@literal @}Override\n *     public void reload() {\n *         // Perform configuration-specific reloading logic\n *     }\n * }\n * }</pre>\n *\n * <p>\n * In the above example, both the {@code Plugin} and {@code Configuration} classes implement the\n * {@code IReloadable} interface. This allows instances of these classes to be reloaded using a\n * common interface method, {@code reload()}, which can be called on any object that implements\n * the interface.\n *\n * <p>\n * Here's an example of how to use the {@code IReloadable} interface with instances of these classes:\n *\n * <pre>{@code", " *     public void reload() {\n *         // Perform configuration-specific reloading logic\n *     }\n * }\n * }</pre>\n *\n * <p>\n * In the above example, both the {@code Plugin} and {@code Configuration} classes implement the\n * {@code IReloadable} interface. This allows instances of these classes to be reloaded using a\n * common interface method, {@code reload()}, which can be called on any object that implements\n * the interface.\n *\n * <p>\n * Here's an example of how to use the {@code IReloadable} interface with instances of these classes:\n *\n * <pre>{@code", " * public class PluginCommand implements CommandExecutor {\n *     @Override\n *     public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {\n *         if (args[0].equalsIgnoreCase(\"reload\")) {\n *             IReloadable plugin = ...; // The plugin instance\n *             IReloadable configuration = ...; // The configuration instance\n *             plugin.reload(); // Reload the plugin\n *             configuration.reload(); // Reload the configuration\n *             // Other actions when reloading\n *             return true;\n *         }\n *\n *         // Other command logic\n *         return false;\n *     }\n * }\n * }</pre>\n *\n * <p>\n * In this example, we create instances of the {@code Plugin} and {@code Configuration} classes and\n * assign them to variables of type {@code IReloadable}. Since both classes implement the\n * {@code IReloadable} interface, we can call the {@code reload()} method on these instances to\n * perform the reloading logic specific to each class.\n *\n * @author SadGhost\n * @since 1.0.0\n */", "public interface IReloadable {\n\n    /**\n     * Reloads the instance's data, actions, or any other relevant components.\n     * <p>\n     * Implementations of this method should define the necessary logic to reload the instance,\n     * such as reloading configuration files, refreshing internal caches, or reinitializing\n     * dependent components.\n     *\n     * <h4>Usage Example:</h4>\n     * <pre>{@code", "     * public class Plugin implements IReloadable {\n     *     {@literal @}Override\n     *     public void reload() {\n     *         // Reload plugin configuration\n     *         // Refresh internal caches\n     *         // Reinitialize dependent components\n     *     }\n     * }\n     * }</pre>\n     *\n     * @since 1.0.0\n     */\n    void reload();\n}\n\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/base/IMessagesManager.java", "chunked_list": ["package dev.sadghost.espresso.base;\n\nimport net.kyori.adventure.text.Component;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * The {@code IMessagesManager} interface is used to manage the messages in the plugin\n * in a more professional and organized way. It extends the {@link IReloadable} interface,\n * indicating that message managers can also be reloaded.\n * <p>", " * indicating that message managers can also be reloaded.\n * <p>\n * Message managers are responsible for retrieving and formatting messages to be displayed\n * in the plugin, providing a centralized location for message handling and localization.\n *\n * <h3>Usage Example:</h3>\n * <pre>{@code\n * public class MessagesManager implements IMessagesManager {\n *     // Implementation of other methods\n *\n *     {@literal @}Override", " *     public void reload() {\n *         // Reload message configuration\n *         // Update message cache\n *     }\n * }\n * }</pre>\n *\n * @see IReloadable\n * @since 1.0.0\n * @author SadGhost\n */", "public interface IMessagesManager extends IReloadable {\n\n    /**\n     * Retrieves a message using the specified {@code key} and returns\n     * a {@link Component} containing the formatted message.\n     *\n     * @param key The key associated with the message.\n     * @return The formatted message {@link Component}.\n     * @since 1.0.0\n     */\n    @NotNull Component getMessage(@NotNull String key);\n\n    /**\n     * Retrieves an error message to inform that an issue has occurred.\n     * <p>\n     * This method allows an error code to be included in the error message,\n     * providing additional information to developers and staff about the issue.\n     *\n     * @param code The error code used for identification.\n     * @return The formatted error message {@link Component}.\n     * @since 1.0.0\n     */\n    @NotNull Component getErrorMessage(@NotNull String code);\n}"]}
{"filename": "src/main/java/dev/sadghost/espresso/database/IConnection.java", "chunked_list": ["package dev.sadghost.espresso.database;\n\npublic interface IConnection {\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/database/IDocumentSerializable.java", "chunked_list": ["package dev.sadghost.espresso.database;\n\n/**\n * The {@code IDocumentSerializable} interface defines the contract for objects that can be serialized to and\n * deserialized from a document representation.\n * <p>\n * Implementing classes should provide the ability to convert their state into a document format (serialization),\n * as well as the ability to restore their state from a document (deserialization).\n * <p>\n * The document type is represented by the generic type parameter {@code T}, which can be any suitable document", " * <p>\n * The document type is represented by the generic type parameter {@code T}, which can be any suitable document\n * representation, such as a JSON object.\n *\n * @param <T> the type of document representation used for serialization and deserialization.\n * @since 1.0.0\n * @author SadGhost\n */\npublic interface IDocumentSerializable<T> {\n\n    /**\n     * Deserializes data from a document into the object implementing this method.\n     * <p>\n     * The implementation of this method should extract the relevant information from the document and apply it\n     * to the object's state.\n     *\n     * @param document the document to deserialize from.\n     * @since 1.0.0\n     */\n    void deserialize(T document);\n\n    /**\n     * Serializes the object implementing this method into a document representation.\n     * <p>\n     * The implementation of this method should convert the object's state into a document format and return it.\n     *\n     * @return the serialized document representation of the object.\n     * @since 1.0.0\n     */\n    T serialize();\n}\n", "public interface IDocumentSerializable<T> {\n\n    /**\n     * Deserializes data from a document into the object implementing this method.\n     * <p>\n     * The implementation of this method should extract the relevant information from the document and apply it\n     * to the object's state.\n     *\n     * @param document the document to deserialize from.\n     * @since 1.0.0\n     */\n    void deserialize(T document);\n\n    /**\n     * Serializes the object implementing this method into a document representation.\n     * <p>\n     * The implementation of this method should convert the object's state into a document format and return it.\n     *\n     * @return the serialized document representation of the object.\n     * @since 1.0.0\n     */\n    T serialize();\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/paper/Debugger.java", "chunked_list": ["package dev.sadghost.espresso.paper;\n\nimport dev.sadghost.espresso.base.Preconditions;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.TextReplacementConfig;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.jetbrains.annotations.ApiStatus;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;", "import org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**", "\n/**\n * A debugger class that facilitates the creation of a consistent plugin debugger instance with channels and message formatting.\n *\n * <p>\n * This class allows developers to create a debugger instance for their plugin, manage debug channels, and send debug messages to registered players.\n * It provides flexibility in defining the debug message format and supports multiple debug channels for organizing debugging information.\n * </p>\n *\n * <p>", " *\n * <p>\n * This class is designed to be used internally within the application and is not intended for direct public use.\n * </p>\n *\n * <p>\n * Thread Safety: This class is not thread-safe as the underlying map of channels is not synchronized.\n * If multiple threads access the same Debugger instance concurrently and modify the channels map,\n * external synchronization must be applied to ensure thread safety.\n * </p>", " * external synchronization must be applied to ensure thread safety.\n * </p>\n *\n * <p>\n * Example usage:\n * <pre>{@code\n * Plugin plugin = // get your plugin instance\n * Debugger debugger = Debugger.create(plugin);\n * debugger.register(\"channel1\", \"Channel 1\");\n * debugger.subscribe(\"channel1\", player1);", " * debugger.register(\"channel1\", \"Channel 1\");\n * debugger.subscribe(\"channel1\", player1);\n * debugger.sendDebug(\"channel1\", \"Debug message\");\n * }</pre>\n * </p>\n *\n * @since 1.0.0\n * @author SadGhost\n */\n@ApiStatus.Experimental\npublic final class Debugger {\n    @NotNull\n    private final Map<String, DebugChannel> channels;\n\n    /**\n     * The default debug message format.\n     *\n     * @since 1.0.0\n     */\n    @NotNull\n    private static Component debugMessage = Component.text(\"[DEBUG:%plugin%] [%channel%] %message%\");\n\n    /**\n     * Constructs a Debugger instance using the specified plugin and the default debug message format.\n     *\n     * @param plugin the plugin using the debugger.\n     */\n    private Debugger(final @NotNull Plugin plugin) {\n        this(plugin, debugMessage);\n    }\n\n    /**\n     * Constructs a Debugger instance using the specified plugin and debug message format.\n     *\n     * @param plugin      the plugin using the debugger.\n     * @param debugFormat the debug message format.\n     */\n    private Debugger(final @NotNull Plugin plugin, final @NotNull Component debugFormat) {\n        channels = new HashMap<>();\n        init(plugin, debugFormat);\n    }\n\n    /**\n     * Creates a new Debugger instance using the provided plugin.\n     *\n     * @param plugin the plugin using the debugger.\n     * @return the debugger instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> new\")\n    public static @NotNull Debugger create(final @NotNull Plugin plugin) {\n        return new Debugger(plugin);\n    }\n\n    /**\n     * Creates a new Debugger instance using the provided plugin and debug message format.\n     *\n     * @param plugin      the plugin using the debugger.\n     * @param debugFormat the debug message format.\n     * @return the debugger instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> new\")\n    public static @NotNull Debugger create(final @NotNull Plugin plugin, final @NotNull Component debugFormat) {\n        return new Debugger(plugin, debugFormat);\n    }\n\n    /**\n     * Sends a debug message to all the registered players listening to the specified debugging channel.\n     *\n     * @param key     the identifier of the debug channel.\n     * @param message the debug message.\n     * @return {@code true} if the sending was successful, {@code false} if the channel is not registered.\n     * @since 1.0.0\n     */", " */\n@ApiStatus.Experimental\npublic final class Debugger {\n    @NotNull\n    private final Map<String, DebugChannel> channels;\n\n    /**\n     * The default debug message format.\n     *\n     * @since 1.0.0\n     */\n    @NotNull\n    private static Component debugMessage = Component.text(\"[DEBUG:%plugin%] [%channel%] %message%\");\n\n    /**\n     * Constructs a Debugger instance using the specified plugin and the default debug message format.\n     *\n     * @param plugin the plugin using the debugger.\n     */\n    private Debugger(final @NotNull Plugin plugin) {\n        this(plugin, debugMessage);\n    }\n\n    /**\n     * Constructs a Debugger instance using the specified plugin and debug message format.\n     *\n     * @param plugin      the plugin using the debugger.\n     * @param debugFormat the debug message format.\n     */\n    private Debugger(final @NotNull Plugin plugin, final @NotNull Component debugFormat) {\n        channels = new HashMap<>();\n        init(plugin, debugFormat);\n    }\n\n    /**\n     * Creates a new Debugger instance using the provided plugin.\n     *\n     * @param plugin the plugin using the debugger.\n     * @return the debugger instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> new\")\n    public static @NotNull Debugger create(final @NotNull Plugin plugin) {\n        return new Debugger(plugin);\n    }\n\n    /**\n     * Creates a new Debugger instance using the provided plugin and debug message format.\n     *\n     * @param plugin      the plugin using the debugger.\n     * @param debugFormat the debug message format.\n     * @return the debugger instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> new\")\n    public static @NotNull Debugger create(final @NotNull Plugin plugin, final @NotNull Component debugFormat) {\n        return new Debugger(plugin, debugFormat);\n    }\n\n    /**\n     * Sends a debug message to all the registered players listening to the specified debugging channel.\n     *\n     * @param key     the identifier of the debug channel.\n     * @param message the debug message.\n     * @return {@code true} if the sending was successful, {@code false} if the channel is not registered.\n     * @since 1.0.0\n     */", "    public boolean sendDebug(final @NotNull String key, final @NotNull String message) {\n        final DebugChannel channel = getChannel(key);\n        if (channel == null) return false;\n\n        final Component debug = debugMessage.replaceText(\n                TextReplacementConfig.builder()\n                        .match(\"%channel%\")\n                        .replacement(channel.getFriendlyName())\n                        .build()\n        ).replaceText(\n                TextReplacementConfig.builder()\n                        .match(\"%message%\")\n                        .replacement(message)\n                        .build()\n        );\n", "        for (final Player player : channel.getListeners()) {\n            if (!player.isOnline()) unsubscribe(key, player);\n            else player.sendMessage(debug);\n        }\n\n        if (!key.equals(\"*\")) sendToAllDebug(message);\n        return true;\n    }\n\n    /**\n     * Returns the debug channel associated with the specified key.\n     *\n     * @param key the identifier of the debug channel.\n     * @return the debug channel, or {@code null} if the channel is not registered.\n     * @since 1.0.0\n     */\n    public @Nullable DebugChannel getChannel(final @NotNull String key) {\n        return channels.get(key);\n    }\n\n    /**\n     * Subscribes a player as a listener to the specified debug channel.\n     *\n     * @param key    the identifier of the debug channel.\n     * @param player the player to subscribe.\n     * @return {@code true} if the player was subscribed successfully, {@code false} if the channel is not registered.\n     * @since 1.0.0\n     */", "    public boolean subscribe(final @NotNull String key, final @NotNull Player player) {\n        final DebugChannel channel = Preconditions.checkNonNull(getChannel(key));\n        return channel.addListener(player);\n    }\n\n    /**\n     * Unsubscribes a player from the specified debug channel.\n     *\n     * @param key    the identifier of the debug channel.\n     * @param player the player to unsubscribe.\n     * @return {@code true} if the player was unsubscribed successfully, {@code false} if the channel is not registered.\n     * @since 1.0.0\n     */", "    public boolean unsubscribe(final @NotNull String key, final @NotNull Player player) {\n        final DebugChannel channel = Preconditions.checkNonNull(getChannel(key));\n        return channel.removeListener(player);\n    }\n\n    /**\n     * Registers a debug channel with the specified identifier and friendly name.\n     *\n     * @param key          the identifier of the debug channel.\n     * @param friendlyName the friendly name of the debug channel.\n     * @since 1.0.0\n     */", "    public void register(final @NotNull String key, final @NotNull String friendlyName) {\n        channels.put(key, new DebugChannel(friendlyName));\n    }\n\n    /**\n     * Sends a debug message to the debug channel that receives every debug message sent.\n     *\n     * @param message the debug message.\n     * @since 1.0.0\n     */\n    private void sendToAllDebug(final @NotNull String message) {\n        final DebugChannel channel = getChannel(\"*\");\n        assert channel != null; // Should never happen, but added for safety.\n\n        final Component debug = debugMessage.replaceText(\n                TextReplacementConfig.builder()\n                        .match(\"%channel%\")\n                        .replacement(channel.getFriendlyName())\n                        .build()\n        ).replaceText(\n                TextReplacementConfig.builder()\n                        .match(\"%message%\")\n                        .replacement(message)\n                        .build()\n        );\n", "        for (final Player player : channel.getListeners()) {\n            if (!player.isOnline()) unsubscribe(\"*\", player);\n            else player.sendMessage(debug);\n        }\n    }\n\n    /**\n     * Initializes the debugger instance.\n     *\n     * @param plugin    the plugin using the debugger.\n     * @param component the message format\n\n    .\n     * @since 1.0.0\n     */\n    private void init(final @NotNull Plugin plugin, final @NotNull Component component) {\n        debugMessage = component.replaceText(\n                TextReplacementConfig.builder()\n                        .match(\"%plugin%\")\n                        .replacement(plugin.getName())\n                        .build()\n        );\n\n        channels.put(\"*\", new DebugChannel(\"*\"));\n        plugin.getLogger().info(\"Debugger has been initialized for the plugin '\" + plugin.getName() + \"'.\");\n    }\n\n    /**\n     * An object representing a debug channel.\n     *\n     * <p>\n     * This class encapsulates a debug channel with a friendly name and a set of listeners.\n     * The debug channel can be used to track and manage debugging information in a specific context.\n     * </p>\n     *\n     * <p>\n     * This class is designed to be used internally within the application and is not intended for direct public use.\n     * </p>\n     *\n     * <p>\n     * Thread Safety: This class is not thread-safe as the underlying set of listeners is not synchronized.\n     * If multiple threads access the same DebugChannel instance concurrently and modify the listeners set,\n     * external synchronization must be applied to ensure thread safety.\n     * </p>\n     *\n     * <p>\n     * Example usage:\n     * <pre>{@code\n     * DebugChannel channel = new DebugChannel(\"channel_name\");\n     * channel.addListener(player1);\n     * channel.addListener(player2);\n     * Set<Player> listeners = channel.getListeners();\n     * }</pre>\n     * </p>\n     *\n     * @author SadGhost\n     * @since 1.0.0\n     */\n    private static final class DebugChannel {\n        @NotNull private final String friendlyName;\n        @NotNull private final Set<Player> listeners;\n\n        /**\n         * Constructs a DebugChannel object with the specified friendly name.\n         *\n         * @param friendlyName the friendly name of the debug channel.\n         */\n        @Contract(pure = true)\n        private DebugChannel(final @NotNull String friendlyName) {\n            this.friendlyName = friendlyName;\n            this.listeners = new HashSet<>();\n        }\n\n        /**\n         * Returns a set containing all the listeners of the debug channel.\n         *\n         * @return the set of listeners.\n         * @since 1.0.0\n         */\n        @Contract(pure = true)\n        public @NotNull Set<Player> getListeners() {\n            return listeners;\n        }\n\n        /**\n         * Adds a player as a listener to the debug channel.\n         *\n         * @param player the player to add as a listener.\n         * @return {@code true} if the player was added as a listener, {@code false} if the player was already a listener.\n         * @since 1.0.0\n         */", "        public boolean addListener(final @NotNull Player player) {\n            return listeners.add(player);\n        }\n\n        /**\n         * Removes a player from the listeners of the debug channel.\n         *\n         * @param player the player to remove from the listeners.\n         * @return {@code true} if the player was removed from the listeners, {@code false} if the player was not a listener.\n         * @since 1.0.0\n         */", "        public boolean removeListener(final @NotNull Player player) {\n            return listeners.remove(player);\n        }\n\n        /**\n         * Returns the friendly name of the debug channel.\n         *\n         * @return the friendly name of the channel.\n         * @since 1.0.0\n         */\n        @Contract(pure = true)\n        public @NotNull String getFriendlyName() {\n            return friendlyName;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/paper/ItemBuilder.java", "chunked_list": ["package dev.sadghost.espresso.paper;\n\nimport com.destroystokyo.paper.Namespaced;\nimport com.google.common.collect.Multimap;\nimport dev.sadghost.espresso.base.Preconditions;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.Material;\nimport org.bukkit.attribute.Attribute;\nimport org.bukkit.attribute.AttributeModifier;\nimport org.bukkit.enchantments.Enchantment;", "import org.bukkit.attribute.AttributeModifier;\nimport org.bukkit.enchantments.Enchantment;\nimport org.bukkit.inventory.EquipmentSlot;\nimport org.bukkit.inventory.ItemFlag;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.Damageable;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;", "import org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A builder class for creating ItemStack objects with custom properties.\n *", " * A builder class for creating ItemStack objects with custom properties.\n *\n * <p>\n * This class provides a convenient way to create ItemStack objects with various properties such as material, amount, and item meta.\n * It follows the builder pattern and allows chaining of method calls to configure the item.\n * </p>\n *\n * <p>\n * Example usage:\n * </p>", " * Example usage:\n * </p>\n *\n * <pre>{@code\n * ItemStack item = ItemBuilder.of(Material.DIAMOND_SWORD)\n *                           .withAmount(1)\n *                           .withDisplayName(\"Sharp Sword\")\n *                           .withLore(\"Powerful weapon\")\n *                           .build();\n * }</pre>", " *                           .build();\n * }</pre>\n *\n * <p>\n * This class is immutable, meaning that once an ItemBuilder object is created, its properties cannot be changed.\n * To modify the properties, a new ItemBuilder object should be created.\n * </p>\n *\n * <p>\n * Thread Safety: This class is not thread-safe. It should not be accessed concurrently from multiple threads.", " * <p>\n * Thread Safety: This class is not thread-safe. It should not be accessed concurrently from multiple threads.\n * </p>\n *\n * @author SadGhost\n * @since 1.0.0\n */\npublic final class ItemBuilder {\n    @NotNull private final ItemStack itemStack;\n    @NotNull private final ItemMeta meta;\n\n    /**\n     * Creates an ItemBuilder object with a default amount of 1 from the provided material.\n     *\n     * @param material the material of the item.\n     */\n    public ItemBuilder(final @NotNull Material material) {\n        this(material, 1);\n    }\n\n    /**\n     * Creates an ItemBuilder object with the provided amount and material.\n     *\n     * @param material the material of the item.\n     * @param amount   the amount of the item.\n     */\n    public ItemBuilder(final @NotNull Material material,\n                       final int amount) {\n        this(new ItemStack(material, amount));\n    }\n\n    /**\n     * Creates an ItemBuilder object with the provided ItemStack.\n     *\n     * @param itemStack the ItemStack to use.\n     */\n    public ItemBuilder(final @NotNull ItemStack itemStack) {\n        this.itemStack = itemStack;\n        this.meta = Preconditions.checkNonNull(itemStack.getItemMeta());\n    }\n\n    /**\n     * Returns a new ItemBuilder instance with the provided material.\n     *\n     * @param material the material of the item.\n     * @return a new ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> new\")\n    public static @NotNull ItemBuilder of(final @NotNull Material material) {\n        return new ItemBuilder(material);\n    }\n\n    /**\n     * Returns a new ItemBuilder instance with the provided material and amount.\n     *\n     * @param material the material of the item.\n     * @param amount   the amount of the item.\n     * @return a new ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> new\")\n    public static @NotNull ItemBuilder of(final @NotNull Material material, final int amount) {\n        return new ItemBuilder(material, amount);\n    }\n\n    /**\n     * Returns a new ItemBuilder instance with the provided ItemStack.\n     *\n     * @param itemStack the ItemStack to use.\n     * @return a new ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> new\")\n    public static @NotNull ItemBuilder of(final @NotNull ItemStack itemStack) {\n        return new ItemBuilder(itemStack);\n    }\n\n    /**\n     * Sets the display name of the item.\n     *\n     * @param displayName the display name of the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withName(final @NotNull Component displayName) {\n        meta.displayName(displayName);\n        return this;\n    }\n\n\n    /**\n     * Sets the damage on the item.\n     *\n     * @param damage the damage on the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withDamage(final int damage) {", "        if (!(meta instanceof Damageable damageable))\n            throw new IllegalStateException(\"Cannot set the damage of a non-damageable item.\");\n\n        damageable.setDamage(damage);\n        return this;\n    }\n\n\n    /**\n     * Sets the lore of the item.\n     *\n     * @param lore the lore of the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withLore(final @NotNull Component @NotNull... lore) {\n        meta.lore(Arrays.asList(lore));\n        return this;\n    }\n\n    /**\n     * Sets the lore of the item.\n     *\n     * @param lore the lore of the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withLore(final @NotNull List<Component> lore) {\n        meta.lore(lore);\n        return this;\n    }\n\n    /**\n     * Removed the lore line from the item.\n     *\n     * @param line the lore line on the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutLoreLine(final @NotNull Component line) {\n        final List<Component> lore = meta.lore();", "        if (lore == null) return this;\n        if (!lore.contains(line)) return this;\n\n        lore.remove(line);\n        meta.lore(lore);\n        return this;\n    }\n\n    /**\n     * Removes the lore line from the item using an index.\n     *\n     * @param index the lore line's index on the item\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutLoreLine(final int index) {\n        final List<Component> lore = meta.lore();", "        if (lore == null) return this;\n        if (index < 0 || index > lore.size()) return this;\n\n        lore.remove(index);\n        meta.lore(lore);\n        return this;\n    }\n\n    /**\n     * Adds the lore line to the item.\n     *\n     * @param line the new lore line.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder addLoreLine(final @NotNull Component line) {\n        final List<Component> lore = meta.lore();", "        if (lore != null) {\n            lore.add(line);\n            meta.lore(lore);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds the lore line to a specific position on the lore of the item\n     *\n     * @param line the new lore line.\n     * @param pos the position on the lore.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> this\")\n    public @NotNull ItemBuilder withLoreLine(final @NotNull Component line,\n                                             final int pos) {\n        final List<Component> lore = meta.lore();", "        if (lore != null) {\n            lore.set(pos, line);\n            meta.lore(lore);\n        }\n        return this;\n    }\n\n    /**\n     * Sets the custom model data of the item.\n     *\n     * @param i the custom model data of the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withCustomModelData(final int i) {\n        meta.setCustomModelData(i);\n        return this;\n    }\n\n    /**\n     * Adds an enchantment to the item.\n     *\n     * @param enchant the new enchantment.\n     * @param level the enchantment level.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> this\")\n    public @NotNull ItemBuilder addEnchant(final @NotNull Enchantment enchant,\n                                           final int level) {\n        meta.addEnchant(enchant, level, true);\n        return this;\n    }\n\n    /**\n     * Removes an enchantment from the item.\n     *\n     * @param enchant the enchantment on the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutEnchant(final @NotNull Enchantment enchant) {\n        meta.removeEnchant(enchant);\n        return this;\n    }\n\n    /**\n     * Adds item flags to the item.\n     *\n     * @param itemFlags the new item flags.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder addItemFlags(final @NotNull ItemFlag @NotNull... itemFlags) {\n        meta.addItemFlags(itemFlags);\n        return this;\n    }\n\n    /**\n     * Removes item flags from the item.\n     *\n     * @param itemFlags the item flags on the item.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutItemFlags(@NotNull ItemFlag @NotNull... itemFlags) {\n        meta.removeItemFlags(itemFlags);\n        return this;\n    }\n\n    /**\n     * Sets the breaking state of the item.\n     *\n     * @param unbreakable the new breaking state.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder asUnbreakable(final boolean unbreakable) {\n        meta.setUnbreakable(unbreakable);\n        return this;\n    }\n\n    /**\n     * Adds an attribute modifier to the item.\n     *\n     * @param attribute the attribute of the modifier.\n     * @param attributeModifier the attribute modifier.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> this\")\n    public @NotNull ItemBuilder addAttributeModifier(final @NotNull Attribute attribute,\n                                                     final @NotNull AttributeModifier attributeModifier) {\n        meta.addAttributeModifier(attribute, attributeModifier);\n        return this;\n    }\n\n    /**\n     * Sets the attribute modifiers of the item.\n     *\n     * @param attributeModifiers the attribute modifiers map.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withAttributeModifiers(final @Nullable Multimap<Attribute, AttributeModifier> attributeModifiers) {\n        meta.setAttributeModifiers(attributeModifiers);\n        return this;\n    }\n\n    /**\n     * Removes the attribute modifier from the item.\n     *\n     * @param attribute the attribute of the modifier.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutAttributeModifier(final @NotNull Attribute attribute) {\n        meta.removeAttributeModifier(attribute);\n        return this;\n    }\n\n    /**\n     * The equipment slot to remove attribute modifiers from on the item.\n     *\n     * @param equipmentSlot the equipment slot to remove modifiers from.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withoutAttributeModifier(final @NotNull EquipmentSlot equipmentSlot) {\n        meta.removeAttributeModifier(equipmentSlot);\n        return this;\n    }\n\n    /**\n     * Removes a specific attribute modifier from the item.\n     *\n     * @param attribute the attribute of the modifier.\n     * @param attributeModifier the attribute modifier to remove.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> this\")\n    public @NotNull ItemBuilder withoutAttributeModifier(final @NotNull Attribute attribute,\n                                                         final @NotNull AttributeModifier attributeModifier) {\n        meta.removeAttributeModifier(attribute, attributeModifier);\n        return this;\n    }\n\n    /**\n     * Sets the destroyable block keys on the item.\n     *\n     * @param keys the destroyable block keys.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withDestroyableKeys(final @NotNull Collection<Namespaced> keys) {\n        meta.setDestroyableKeys(keys);\n        return this;\n    }\n\n    /**\n     * Sets the placeable block keys on the item.\n     *\n     * @param keys the placeable block keys.\n     * @return the ItemBuilder instance.\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> this\")\n    public @NotNull ItemBuilder withPlaceableKeys(final @NotNull Collection<Namespaced> keys) {\n        meta.setPlaceableKeys(keys);\n        return this;\n    }\n\n    /**\n     * Builds and returns the final ItemStack.\n     *\n     * @return the final ItemStack.\n     */\n    public @NotNull ItemStack build() {\n        final ItemStack item = itemStack.clone();\n        item.setItemMeta(meta);\n        return item;\n    }\n}"]}
{"filename": "src/main/java/dev/sadghost/espresso/paper/ColorUtils.java", "chunked_list": ["package dev.sadghost.espresso.paper;\n\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;\nimport net.md_5.bungee.api.ChatColor;\nimport org.bukkit.DyeColor;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\n/**", "\n/**\n * A utility class for handling color formatting and translation using the Kyori Adventure library.\n * Supports servers running Paper, Velocity, or any software that supports Kyori Adventure.\n *\n * @author SadGhost, LielAmar\n * @since 1.0.0\n */\npublic final class ColorUtils {\n\n    /**\n     * The most common color translation character.\n     *\n     * @since 1.0.0\n     */", "public final class ColorUtils {\n\n    /**\n     * The most common color translation character.\n     *\n     * @since 1.0.0\n     */\n    public static final char COLOR_CHAR = '&';\n\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private ColorUtils() {}\n\n    /**\n     * Colors a message that uses Bungee's color format and returns the formatted message deserialized into a {@code Component}.\n     *\n     * @param text The Bungee format message\n     * @return The formatted message as a {@code Component}\n     * @since 1.0.0\n     */\n    public static @NotNull Component color(final @Nullable String text) {\n        return color(COLOR_CHAR, text);\n    }\n\n    /**\n     * Colors a message that uses Bukkit's color format and returns the formatted message deserialized into a {@code Component}.\n     *\n     * @param colorChar The color character to use in the deserialization\n     * @param text      The Bukkit format message\n     * @return The formatted message as a {@code Component}\n     * @since 1.0.0\n     */\n    public static @NotNull Component color(final char colorChar, final @Nullable String text) {", "        if (text == null) return Component.empty();\n        return LegacyComponentSerializer.legacy(colorChar).deserialize(text);\n    }\n\n    /**\n     * Colors a Bukkit message with support for hex color codes.\n     *\n     * @param text Message to color\n     * @return Colored message\n     * @deprecated in favor of {@link #color(String)}\n     * @see #color(char, String)\n     * @since 1.0.0\n     */\n    @Deprecated(since = \"1.0.0\")\n    public static @NotNull String colorLegacy(final @Nullable String text) {\n        return colorLegacy(COLOR_CHAR, text);\n    }\n\n    /**\n     * Colors a Bukkit message with support for hex color codes.\n     *\n     * @param colorChar The color character\n     * @param text      Message to color\n     * @return Colored message\n     * @deprecated in favor of {@link #color(char, String)}\n     * @since 1.0.0\n     */\n    @Deprecated(since = \"1.0.0\")\n    public static @NotNull String colorLegacy(final char colorChar, final @Nullable String text) {\n        return text == null ? \"\" : ChatColor.translateAlternateColorCodes(colorChar, text);\n    }\n\n    /**\n     * Removes all colors from the given string and replaces them with the color character.\n     *\n     * @param text Text to replace\n     * @return Uncolored message\n     * @deprecated in favor of {@link LegacyComponentSerializer#deserialize(String)}\n     * @see #uncolorLegacy(char, String)\n     * @since 1.0.0\n     */\n    @Deprecated(since = \"1.0.0\")\n    public static @NotNull String uncolorLegacy(final @Nullable String text) {\n        return uncolorLegacy(COLOR_CHAR, text);\n    }\n\n    /**\n     * Removes all colors from the given string and replaces them with the color character.\n     *\n     * @param colorChar The color code character\n     * @param text      Text to replace\n     * @return Uncolored message\n     * @deprecated in favor of {@link LegacyComponentSerializer#deserialize(String)}\n     * @since 1.0.0\n     */\n    @Deprecated(since = \"1.0.0\")\n    public static @NotNull String uncolorLegacy(final char colorChar, final @Nullable String text) {", "        if (text == null) return \"\";\n\n        final char[] array = text.toCharArray();\n        for (int i = 0; i < array.length - 1; i++) {\n            if (array[i] == colorChar && \"0123456789AaBbCcDdEeFfKkLlMmNnOoRrXx\".indexOf(array[i + 1]) != -1) {\n                array[i] = colorChar;\n                array[i + 1] = Character.toLowerCase(array[i + 1]);\n            }\n        }\n        return new String(array);\n    }\n\n    /**\n     * Translates a DyeColor object to an integer.\n     *\n     * @param color The {@link DyeColor} object\n     * @return Integer equivalent of the color\n     * @throws IllegalArgumentException if {@code color} is null\n     * @since 1.0.0\n     */", "    public static int translateColorToInt(final @NotNull DyeColor color) {\n        return switch (color) {\n            case WHITE -> 0;\n            case ORANGE -> 1;\n            case MAGENTA -> 2;\n            case LIGHT_BLUE -> 3;\n            case YELLOW -> 4;\n            case LIME -> 5;\n            case PINK -> 6;\n            case GRAY -> 7;\n            case LIGHT_GRAY -> 8;\n            case CYAN -> 9;\n            case PURPLE -> 10;\n            case BLUE -> 11;\n            case BROWN -> 12;\n            case GREEN -> 13;\n            case RED -> 14;\n            case BLACK -> 15;\n        };\n    }\n\n    /**\n     * Translates an integer to a DyeColor object.\n     *\n     * @param color The color's id\n     * @return {@link DyeColor} equivalent of the color\n     * @since 1.0.0\n     */\n    public static @Nullable DyeColor translateIntToColor(final int color) {\n        return switch (color) {\n            case 0 -> DyeColor.WHITE;\n            case 1 -> DyeColor.ORANGE;\n            case 2 -> DyeColor.MAGENTA;\n            case 3 -> DyeColor.LIGHT_BLUE;\n            case 4 -> DyeColor.YELLOW;\n            case 5 -> DyeColor.LIME;\n            case 6 -> DyeColor.PINK;\n            case 7 -> DyeColor.GRAY;\n            case 8 -> DyeColor.LIGHT_GRAY;\n            case 9 -> DyeColor.CYAN;\n            case 10 -> DyeColor.PURPLE;\n            case 11 -> DyeColor.BLUE;\n            case 12 -> DyeColor.BROWN;\n            case 13 -> DyeColor.GREEN;\n            case 14 -> DyeColor.RED;\n            case 15 -> DyeColor.BLACK;\n            default -> null;\n        };\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/nbt/NBTTag.java", "chunked_list": ["package dev.sadghost.espresso.spigot.nbt;\n\nimport org.bukkit.NamespacedKey;\nimport org.bukkit.persistence.PersistentDataType;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Optional;\n\n/**", "\n/**\n * An object representing an NBT tag in the new NBT API known as PersistentDataContainer.\n *\n * @param <T> the value type in the NBT.\n * @author SadGhost\n * @since 1.0.0\n */\npublic final class NBTTag<T> {\n    private final @NotNull NamespacedKey key;\n    private final @NotNull PersistentDataType<T, T> type;\n    private final @NotNull T value;\n\n    @Contract(pure = true)\n    NBTTag(final @NotNull NamespacedKey key,\n           final @NotNull PersistentDataType<T, T> type,\n           final @NotNull T value) {\n        this.key = key;\n        this.type = type;\n        this.value = value;\n    }\n\n    /**\n     * Returns a builder instance to construct an NBTTag.\n     *\n     * @param <T> the value type used for the NBT tag\n     * @return a new instance of the Builder\n     * @since 1.0.0\n     */\n    @Contract(\" -> new\")\n    public static <T> @NotNull Builder<T> builder() {\n        return new Builder<>();\n    }\n\n    /**\n     * Returns the namespace key of the NBT tag.\n     *\n     * @return the namespace key of the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull NamespacedKey getKey() {\n        return key;\n    }\n\n    /**\n     * Returns the data type used by the NBT tag.\n     *\n     * @return the data type used by the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull PersistentDataType<T, T> getType() {\n        return type;\n    }\n\n    /**\n     * Returns the value stored in the NBT tag.\n     *\n     * @return the value of the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull T getValue() {\n        return value;\n    }\n\n    /**\n     * A builder class for constructing NBTTag instances.\n     *\n     * @param <T> the value type used for the NBT tag\n     * @since 1.0.0\n     */\n    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")", "public final class NBTTag<T> {\n    private final @NotNull NamespacedKey key;\n    private final @NotNull PersistentDataType<T, T> type;\n    private final @NotNull T value;\n\n    @Contract(pure = true)\n    NBTTag(final @NotNull NamespacedKey key,\n           final @NotNull PersistentDataType<T, T> type,\n           final @NotNull T value) {\n        this.key = key;\n        this.type = type;\n        this.value = value;\n    }\n\n    /**\n     * Returns a builder instance to construct an NBTTag.\n     *\n     * @param <T> the value type used for the NBT tag\n     * @return a new instance of the Builder\n     * @since 1.0.0\n     */\n    @Contract(\" -> new\")\n    public static <T> @NotNull Builder<T> builder() {\n        return new Builder<>();\n    }\n\n    /**\n     * Returns the namespace key of the NBT tag.\n     *\n     * @return the namespace key of the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull NamespacedKey getKey() {\n        return key;\n    }\n\n    /**\n     * Returns the data type used by the NBT tag.\n     *\n     * @return the data type used by the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull PersistentDataType<T, T> getType() {\n        return type;\n    }\n\n    /**\n     * Returns the value stored in the NBT tag.\n     *\n     * @return the value of the tag\n     * @since 1.0.0\n     */\n    @Contract(pure = true)\n    public @NotNull T getValue() {\n        return value;\n    }\n\n    /**\n     * A builder class for constructing NBTTag instances.\n     *\n     * @param <T> the value type used for the NBT tag\n     * @since 1.0.0\n     */\n    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")", "    public static final class Builder<T> {\n        private Optional<NamespacedKey> key = Optional.empty();\n        private Optional<PersistentDataType<T, T>> type = Optional.empty();\n        private Optional<T> value = Optional.empty();\n\n        /**\n         * Sets the namespace key for the NBT tag.\n         *\n         * @param key the namespace key\n         * @return the builder instance\n         * @since 1.0.0\n         */\n        @Contract(value = \"_ -> this\", mutates = \"this\")\n        public @NotNull Builder<T> setKey(final @NotNull NamespacedKey key) {\n            this.key = Optional.of(key);\n            return this;\n        }\n\n        /**\n         * Sets the data type for the NBT tag.\n         *\n         * @param type the data type\n         * @return the builder instance\n         * @since 1.0.0\n         */\n        @Contract(value = \"_ -> this\", mutates = \"this\")\n        public @NotNull Builder<T> setType(final @NotNull PersistentDataType<T, T> type) {\n            this.type = Optional.of(type);\n            return this;\n        }\n\n        /**\n         * Sets the value for the NBT tag.\n         *\n         * @param value the value\n         * @return the builder instance\n         * @since 1.0.0\n         */\n        @Contract(value = \"_ -> this\", mutates = \"this\")\n        public @NotNull Builder<T> setValue(final @NotNull T value) {\n            this.value = Optional.of(value);\n            return this;\n        }\n\n        /**\n         * Constructs an NBTTag instance using the provided values.\n         *\n         * @return the constructed NBTTag instance\n         * @throws IllegalStateException if any of the required values are missing\n         * @since 1.0.0\n         */\n        @Contract(\" -> new\")\n        public @NotNull NBTTag<T> build() {\n            return new NBTTag<>(\n                    key.orElseThrow(() -> new IllegalStateException(\"Missing 'key' for the tag.\")),\n                    type.orElseThrow(() -> new IllegalStateException(\"Missing 'type' for the tag.\")),\n                    value.orElseThrow(() -> new IllegalStateException(\"Missing 'value' for the tag.\"))\n            );\n        }\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/nbt/NBTUtils.java", "chunked_list": ["package dev.sadghost.espresso.spigot.nbt;\n\nimport dev.sadghost.espresso.base.Preconditions;\nimport org.bukkit.NamespacedKey;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.persistence.PersistentDataContainer;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\n", "import org.jetbrains.annotations.NotNull;\n\n/**\n * An item NBT modification utility which uses the modern PDC methods to modify instead of NMS.\n * Provides methods to add and remove NBT tags from ItemStacks.\n * Note: Requires a Bukkit-based environment.\n *\n * @author SadGhost\n * @since 1.0.0\n */\npublic final class NBTUtils {\n\n    /**\n     * Seals the class to prevent instantiation.\n     */\n    @Contract(pure = true)\n    private NBTUtils() {}\n\n    /**\n     * Adds an NBT tag to an ItemStack's metadata.\n     *\n     * @param itemStack the ItemStack to add the tag to\n     * @param tag       the NBT tag to add\n     * @param <T>       the value type in the NBT tag\n     * @return the modified ItemStack with the added NBT tag\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> param1\")\n    public static <T> @NotNull ItemStack addTag(final @NotNull ItemStack itemStack,\n                                                final @NotNull NBTTag<T> tag) {\n        final ItemMeta meta = Preconditions.checkNonNull(itemStack.getItemMeta());\n        final PersistentDataContainer pdc = meta.getPersistentDataContainer();\n        pdc.set(tag.getKey(), tag.getType(), tag.getValue());\n        itemStack.setItemMeta(meta);\n        return itemStack;\n    }\n\n    /**\n     * Removes an NBT tag from an ItemStack's metadata.\n     *\n     * @param itemStack the ItemStack to remove the tag from\n     * @param namespace the namespace of the NBT tag to remove\n     * @return the modified ItemStack with the removed NBT tag\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> param1\")\n    public static @NotNull ItemStack removeTag(final @NotNull ItemStack itemStack,\n                                               final @NotNull NamespacedKey namespace) {\n        final ItemMeta meta = itemStack.getItemMeta();\n        final PersistentDataContainer pdc = meta.getPersistentDataContainer();\n        pdc.remove(namespace);\n        itemStack.setItemMeta(meta);\n        return itemStack;\n    }\n}\n", " * @since 1.0.0\n */\npublic final class NBTUtils {\n\n    /**\n     * Seals the class to prevent instantiation.\n     */\n    @Contract(pure = true)\n    private NBTUtils() {}\n\n    /**\n     * Adds an NBT tag to an ItemStack's metadata.\n     *\n     * @param itemStack the ItemStack to add the tag to\n     * @param tag       the NBT tag to add\n     * @param <T>       the value type in the NBT tag\n     * @return the modified ItemStack with the added NBT tag\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> param1\")\n    public static <T> @NotNull ItemStack addTag(final @NotNull ItemStack itemStack,\n                                                final @NotNull NBTTag<T> tag) {\n        final ItemMeta meta = Preconditions.checkNonNull(itemStack.getItemMeta());\n        final PersistentDataContainer pdc = meta.getPersistentDataContainer();\n        pdc.set(tag.getKey(), tag.getType(), tag.getValue());\n        itemStack.setItemMeta(meta);\n        return itemStack;\n    }\n\n    /**\n     * Removes an NBT tag from an ItemStack's metadata.\n     *\n     * @param itemStack the ItemStack to remove the tag from\n     * @param namespace the namespace of the NBT tag to remove\n     * @return the modified ItemStack with the removed NBT tag\n     * @since 1.0.0\n     */\n    @Contract(\"_, _ -> param1\")\n    public static @NotNull ItemStack removeTag(final @NotNull ItemStack itemStack,\n                                               final @NotNull NamespacedKey namespace) {\n        final ItemMeta meta = itemStack.getItemMeta();\n        final PersistentDataContainer pdc = meta.getPersistentDataContainer();\n        pdc.remove(namespace);\n        itemStack.setItemMeta(meta);\n        return itemStack;\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/files/IConfig.java", "chunked_list": ["package dev.sadghost.espresso.spigot.files;\n\nimport org.bukkit.Color;\nimport org.bukkit.Location;\nimport org.bukkit.OfflinePlayer;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.serialization.ConfigurationSerializable;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.util.Vector;\nimport org.jetbrains.annotations.ApiStatus.Experimental;", "import org.bukkit.util.Vector;\nimport org.jetbrains.annotations.ApiStatus.Experimental;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**", "\n/**\n * Interface for managing configuration files of different types.\n * <p>\n * Implementations of this interface represent different file types received\n * from the file manager. They provide methods to retrieve and manipulate\n * configuration values based on their data types.\n *\n * @apiNote This interface is experimental and subject to change in future versions.\n * @since 1.0.0", " * @apiNote This interface is experimental and subject to change in future versions.\n * @since 1.0.0\n * @author SadGhost\n */\n@Experimental\npublic sealed interface IConfig permits YAMLConfig {\n\n    // Methods for retrieving configuration values\n\n    @Nullable Object get(@NotNull String path);\n    @NotNull Object get(@NotNull String path, @NotNull Object defaultValue);\n\n    @Nullable String getString(@NotNull String path);\n    @NotNull String getString(@NotNull String path, @NotNull String defaultValue);\n\n    int getInt(@NotNull String path);\n    int getInt(@NotNull String path, int defaultValue);\n\n    double getDouble(@NotNull String path);\n    double getDouble(@NotNull String path, double defaultValue);\n\n    long getLong(@NotNull String path);\n    long getLong(@NotNull String path, long defaultValue);\n\n    boolean getBoolean(@NotNull String path);\n    boolean getBoolean(@NotNull String path, boolean defaultValue);\n\n    @Nullable Location getLocation(@NotNull String path);\n    @NotNull Location getLocation(@NotNull String path, @NotNull Location defaultValue);\n\n    @Nullable OfflinePlayer getOfflinePlayer(@NotNull String path);\n    @NotNull OfflinePlayer getOfflinePlayer(@NotNull String path, @NotNull OfflinePlayer defaultValue);\n\n    @Nullable Vector getVector(@NotNull String path);\n    @NotNull Vector getVector(@NotNull String path, @NotNull Vector defaultValue);\n\n    @Nullable ItemStack getItemStack(@NotNull String path);\n    @NotNull ItemStack getItemStack(@NotNull String path, @NotNull ItemStack defaultValue);\n\n    @Nullable List<?> getList(@NotNull String path);\n    @NotNull List<?> getList(@NotNull String path, @NotNull List<?> defaultValue);\n\n    @Nullable Color getColor(@NotNull String path);\n    @NotNull Color getColor(@NotNull String path, @NotNull Color defaultValue);\n\n    @Nullable <T extends ConfigurationSerializable> T getSerializable(@NotNull String path, @NotNull Class<T> clazz);\n    @NotNull <T extends ConfigurationSerializable> T getSerializable(@NotNull String path, @NotNull Class<T> clazz, @NotNull T defaultValue);\n\n    @NotNull List<String> getStringList(@NotNull String path);\n    @NotNull List<Integer> getIntegerList(@NotNull String path);\n    @NotNull List<Double> getDoubleList(@NotNull String path);\n    @NotNull List<Float> getFloatList(@NotNull String path);\n    @NotNull List<Boolean> getBooleanList(@NotNull String path);\n    @NotNull List<Character> getCharacterList(@NotNull String path);\n    @NotNull List<Long> getLongList(@NotNull String path);\n    @NotNull List<Byte> getByteList(@NotNull String path);\n    @NotNull List<Short> getShortList(@NotNull String path);\n    @NotNull List<Map<?, ?>> getMapList(@NotNull String path);\n\n    @NotNull Set<String> getKeys();\n    @NotNull Set<String> getKeys(boolean deep);\n\n    @NotNull ConfigurationSection createSection(@NotNull String path);\n    @Nullable ConfigurationSection getConfigurationSection(@NotNull String path);\n\n    boolean contains(@NotNull String path);\n    void removeKey(@NotNull String path);\n    void set(@NotNull String path, @Nullable Object value);\n\n    boolean isString(@NotNull String path);\n    boolean isInt(@NotNull String path);\n    boolean isDouble(@NotNull String path);\n    boolean isLong(@NotNull String path);\n    boolean isBoolean(@NotNull String path);\n    boolean isLocation(@NotNull String path);\n    boolean isOfflinePlayer(@NotNull String path);\n    boolean isVector(@NotNull String path);\n    boolean isItemStack(@NotNull String path);\n    boolean isColor(@NotNull String path);\n    boolean isList(@NotNull String path);\n    boolean isConfigurationSection(@NotNull String path);\n    boolean isSet(@NotNull String path);\n\n    // Configuration file management methods\n\n    /**\n     * Reloads the configuration from the saved file on disk.\n     * <p>\n     * This method discards any changes made to the configuration and\n     * reloads the values from the original file.\n     */\n    void reloadConfig();\n\n    /**\n     * Saves the configuration to the underlying file.\n     * <p>\n     * This method saves the current configuration values to the original file\n     * on disk, overwriting any existing data in the file.\n     */\n    void saveConfig();\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/files/FileManager.java", "chunked_list": ["package dev.sadghost.espresso.spigot.files;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport org.jetbrains.annotations.ApiStatus.Experimental;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.io.*;", "\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n\n/**\n * The {@code FileManager} class is a file management utility that simplifies the management of\n * configuration files for the plugin. It provides methods for retrieving and creating configuration files,", " * The {@code FileManager} class is a file management utility that simplifies the management of\n * configuration files for the plugin. It provides methods for retrieving and creating configuration files,\n * loading configuration objects, and handling file operations.\n *\n * <p>This class is designed to be used within a plugin context and is specifically tailored for managing\n * configuration files in that context.\n *\n * <p>Usage Example:\n * <pre>{@code\n * FileManager fileManager = new FileManager(plugin);", " * <pre>{@code\n * FileManager fileManager = new FileManager(plugin);\n * IConfig config = fileManager.getConfig(\"config.yml\");\n * }</pre>\n *\n * @author LielAmar, SadGhost\n * @since 1.0.0\n */\n@Experimental\npublic final class FileManager {\n    // Instance variables\n    @NotNull private final JavaPlugin plugin;\n    @NotNull private final Map<String, IConfig> configs;\n\n    /**\n     * Constructs a {@code FileManager} object with the specified {@code JavaPlugin} instance.\n     *\n     * @param plugin the JavaPlugin instance associated with this FileManager\n     * @since 1.0.0\n     */\n    public FileManager(final @NotNull JavaPlugin plugin) {\n        this.plugin = plugin;\n        this.configs = new ConcurrentHashMap<>();\n    }\n\n    /**\n     * Returns a configuration object representing a single configuration file.\n     *\n     * @param path     the path to the configuration file\n     * @param fileName the name of the configuration file\n     * @return a configuration object representing the specified configuration file,\n     *         or {@code null} if the file does not exist or an error occurred\n     * @since 1.0.0\n     */\n    public @Nullable IConfig getConfig(final @NotNull String path,\n                                       final @NotNull String fileName) {\n        IConfig config = this.configs.get(fileName);", "@Experimental\npublic final class FileManager {\n    // Instance variables\n    @NotNull private final JavaPlugin plugin;\n    @NotNull private final Map<String, IConfig> configs;\n\n    /**\n     * Constructs a {@code FileManager} object with the specified {@code JavaPlugin} instance.\n     *\n     * @param plugin the JavaPlugin instance associated with this FileManager\n     * @since 1.0.0\n     */\n    public FileManager(final @NotNull JavaPlugin plugin) {\n        this.plugin = plugin;\n        this.configs = new ConcurrentHashMap<>();\n    }\n\n    /**\n     * Returns a configuration object representing a single configuration file.\n     *\n     * @param path     the path to the configuration file\n     * @param fileName the name of the configuration file\n     * @return a configuration object representing the specified configuration file,\n     *         or {@code null} if the file does not exist or an error occurred\n     * @since 1.0.0\n     */\n    public @Nullable IConfig getConfig(final @NotNull String path,\n                                       final @NotNull String fileName) {\n        IConfig config = this.configs.get(fileName);", "        if (config != null) return config;\n\n        final File configFile = getConfigFile(path, fileName);\n        if (configFile == null) return null;\n        // If the config doesn't already exist, we want to create it, copy the resource and set its header\n        if (!configFile.exists()) createFile(configFile, this.plugin.getResource(fileName));\n\n        config = loadConfig(configFile);\n        this.configs.put(fileName, config);\n        return config;\n    }\n\n    /**\n     * Returns a configuration object representing a single configuration file located in the plugin's data folder.\n     *\n     * @param fileName the name of the configuration file\n     * @return a configuration object representing the specified configuration file,\n     *         or {@code null} if the file does not exist or an error occurred\n     * @since 1.0.0\n     */\n    public @Nullable IConfig getConfig(final @NotNull String fileName) {\n        return getConfig(this.plugin.getDataFolder().getPath(), fileName);\n    }\n\n    /**\n     * Returns the File object of a configuration file.\n     *\n     * @param path the path to the configuration file\n     * @param fileName the name of the configuration file\n     * @return the File object representing the specified configuration file,\n     *         or {@code null} if the file name is empty\n     * @since 1.0.0\n     */\n    private @Nullable File getConfigFile(final @NotNull String path,\n                                         final @NotNull String fileName) {", "        if (fileName.isEmpty()) return null;\n        return new File(path, fileName);\n    }\n\n    /**\n     * Creates a File object for a configuration file and optionally copies the source stream to the file.\n     *\n     * @param configFile the File object to create\n     * @param source the optional source stream to apply to the configuration file\n     * @since 1.0.0\n     */\n    private void createFile(final @NotNull File configFile,\n                            final @Nullable InputStream source) {", "        if (configFile.exists()) return;\n        try {\n            configFile.getParentFile().mkdir();\n            configFile.createNewFile();\n\n            if (source != null) {\n                loadSource(configFile, source);\n            }\n        } catch (final IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads a source stream to a file.\n     *\n     * @param configFile the file to load the source stream to\n     * @param source the source stream to load\n     * @since 1.0.0\n     */\n    private void loadSource(final @NotNull File configFile,\n                            final @NotNull InputStream source) {", "        if (!configFile.exists()) return;\n\n        try (final BufferedReader reader = new BufferedReader(new InputStreamReader(source, StandardCharsets.UTF_8));\n             final BufferedWriter out = new BufferedWriter(new FileWriter(configFile))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                out.write(line + \"\\n\");\n            }\n        } catch (final IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the configuration file based on its type, or throws a {@code NotImplementedException}\n     * if support is not implemented for the provided file type.\n     *\n     * @param file the configuration file\n     * @return the loaded configuration object\n     * @throws NotImplementedException if support is not implemented for the provided file type\n     * @since 1.0.0\n     */\n    @Contract(\"_ -> new\")\n    private @NotNull IConfig loadConfig(final @NotNull File file) {", "        if (file.getName().toLowerCase().endsWith(\".yml\")) {\n            return new YAMLConfig(file);\n        }\n\n        throw new NotImplementedException(\"This file type is not supported yet.\");\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/files/YAMLConfig.java", "chunked_list": ["package dev.sadghost.espresso.spigot.files;\n\nimport org.bukkit.Color;\nimport org.bukkit.Location;\nimport org.bukkit.OfflinePlayer;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.configuration.serialization.ConfigurationSerializable;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.util.Vector;", "import org.bukkit.inventory.ItemStack;\nimport org.bukkit.util.Vector;\nimport org.jetbrains.annotations.ApiStatus.Experimental;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.List;", "import java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A YAMLConfig object representing a .yml configuration file.\n * Used to access .yml files.\n *\n * @author LielAmar, SadGhost", " *\n * @author LielAmar, SadGhost\n * @since 1.0.0\n */\n@Experimental\npublic final class YAMLConfig implements IConfig {\n    @NotNull private final File configFile;\n    private YamlConfiguration configuration;\n    \n    YAMLConfig(final @NotNull File configFile) {\n        this.configFile = configFile;\n\n        this.loadConfig();\n    }\n\n    @Override\n    public @Nullable Object get(final @NotNull String path) {\n        return this.configuration.get(path);\n    }\n    @Override\n    public @NotNull Object get(final @NotNull String path, final @NotNull Object defaultValue) {\n        return this.configuration.get(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable String getString(final @NotNull String path) {\n        return this.configuration.getString(path);\n    }\n    @Override\n    public @NotNull String getString(final @NotNull String path, final @NotNull String defaultValue) {\n        return this.configuration.getString(path, defaultValue);\n    }\n\n    @Override", "    public int getInt(final @NotNull String path) {\n        return this.configuration.getInt(path);\n    }\n    @Override\n    public int getInt(final @NotNull String path, final int defaultValue) {\n        return this.configuration.getInt(path, defaultValue);\n    }\n\n    @Override\n    public double getDouble(final @NotNull String path) {\n        return this.configuration.getDouble(path);\n    }\n    @Override", "    public double getDouble(final @NotNull String path) {\n        return this.configuration.getDouble(path);\n    }\n    @Override\n    public double getDouble(final @NotNull String path, final double defaultValue) {\n        return this.configuration.getDouble(path, defaultValue);\n    }\n\n    @Override\n    public long getLong(final @NotNull String path) {\n        return this.configuration.getLong(path);\n    }\n    @Override", "    public long getLong(final @NotNull String path) {\n        return this.configuration.getLong(path);\n    }\n    @Override\n    public long getLong(final @NotNull String path, final long defaultValue) {\n        return this.configuration.getLong(path, defaultValue);\n    }\n\n    @Override\n    public boolean getBoolean(final @NotNull String path) {\n        return this.configuration.getBoolean(path);\n    }\n    @Override", "    public boolean getBoolean(final @NotNull String path) {\n        return this.configuration.getBoolean(path);\n    }\n    @Override\n    public boolean getBoolean(final @NotNull String path, final boolean defaultValue) {\n        return this.configuration.getBoolean(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable Location getLocation(final @NotNull String path) {\n        return this.configuration.getLocation(path);\n    }\n    @Override\n    public @NotNull Location getLocation(final @NotNull String path, final @NotNull Location defaultValue) {\n        return this.configuration.getLocation(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable OfflinePlayer getOfflinePlayer(final @NotNull String path) {\n        return this.configuration.getOfflinePlayer(path);\n    }\n    @Override\n    public @NotNull OfflinePlayer getOfflinePlayer(final @NotNull String path, final @NotNull OfflinePlayer defaultValue) {\n        return this.configuration.getOfflinePlayer(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable Vector getVector(final @NotNull String path) {\n        return this.configuration.getVector(path);\n    }\n    @Override\n    public @NotNull Vector getVector(final @NotNull String path, final @NotNull Vector defaultValue) {\n        return this.configuration.getVector(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable ItemStack getItemStack(final @NotNull String path) {\n        return this.configuration.getItemStack(path);\n    }\n    @Override\n    public @NotNull ItemStack getItemStack(final @NotNull String path, final @NotNull ItemStack defaultValue) {\n        return this.configuration.getItemStack(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable List<?> getList(final @NotNull String path) {\n        return this.configuration.getList(path);\n    }\n    @Override\n    public @NotNull List<?> getList(final @NotNull String path, final @NotNull List<?> defaultValue) {\n        return this.configuration.getList(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable Color getColor(final @NotNull String path) {\n        return this.configuration.getColor(path);\n    }\n    @Override\n    public @NotNull Color getColor(final @NotNull String path, final @NotNull Color defaultValue) {\n        return this.configuration.getColor(path, defaultValue);\n    }\n\n    @Override\n    public @Nullable <T extends ConfigurationSerializable> T getSerializable(final @NotNull String path, final @NotNull Class<T> clazz) {\n        return this.configuration.getSerializable(path, clazz);\n    }\n    @Override\n    public @NotNull <T extends ConfigurationSerializable> T getSerializable(final @NotNull String path, final @NotNull Class<T> clazz, final @NotNull T defaultValue) {\n        return this.configuration.getSerializable(path, clazz, defaultValue);\n    }\n\n    @Override\n    public @NotNull List<String> getStringList(final @NotNull String path) {\n        return this.configuration.getStringList(path);\n    }\n\n    @Override\n    public @NotNull List<Integer> getIntegerList(final @NotNull String path) {\n        return this.configuration.getIntegerList(path);\n    }\n\n    @Override\n    public @NotNull List<Double> getDoubleList(final @NotNull String path) {\n        return this.configuration.getDoubleList(path);\n    }\n\n    @Override\n    public @NotNull List<Float> getFloatList(final @NotNull String path) {\n        return this.configuration.getFloatList(path);\n    }\n\n    @Override\n    public @NotNull List<Boolean> getBooleanList(final @NotNull String path) {\n        return this.configuration.getBooleanList(path);\n    }\n\n    @Override\n    public @NotNull List<Character> getCharacterList(final @NotNull String path) {\n        return this.configuration.getCharacterList(path);\n    }\n\n    @Override\n    public @NotNull List<Long> getLongList(final @NotNull String path) {\n        return this.configuration.getLongList(path);\n    }\n\n    @Override\n    public @NotNull List<Byte> getByteList(final @NotNull String path) {\n        return this.configuration.getByteList(path);\n    }\n\n    @Override\n    public @NotNull List<Short> getShortList(final @NotNull String path) {\n        return this.configuration.getShortList(path);\n    }\n\n    @Override\n    public @NotNull List<Map<?, ?>> getMapList(final @NotNull String path) {\n        return this.configuration.getMapList(path);\n    }\n\n    @Override\n    public @NotNull Set<String> getKeys() {\n        return this.configuration.getKeys(false);\n    }\n\n    @Override\n    public @NotNull Set<String> getKeys(final boolean deep) {\n        return this.configuration.getKeys(deep);\n    }\n\n    @Override\n    public @NotNull ConfigurationSection createSection(final @NotNull String path) {\n        return this.configuration.createSection(path);\n    }\n\n    @Override\n    public @Nullable ConfigurationSection getConfigurationSection(final @NotNull String path) {\n        return this.configuration.getConfigurationSection(path);\n    }\n\n    @Override", "    public boolean contains(final @NotNull String path) {\n        return this.configuration.contains(path);\n    }\n\n    @Override\n    public void removeKey(final @NotNull String path) {\n        this.configuration.set(path, null);\n    }\n\n    @Override\n    public void set(final @NotNull String path, final @Nullable Object value) {\n        this.configuration.set(path, value);\n    }\n\n    @Override", "    public void set(final @NotNull String path, final @Nullable Object value) {\n        this.configuration.set(path, value);\n    }\n\n    @Override\n    public boolean isString(final @NotNull String path) {\n        return this.configuration.isString(path);\n    }\n\n    @Override\n    public boolean isInt(final @NotNull String path) {\n        return this.configuration.isInt(path);\n    }\n\n    @Override", "    public boolean isInt(final @NotNull String path) {\n        return this.configuration.isInt(path);\n    }\n\n    @Override\n    public boolean isDouble(final @NotNull String path) {\n        return this.configuration.isDouble(path);\n    }\n\n    @Override\n    public boolean isLong(final @NotNull String path) {\n        return this.configuration.isLong(path);\n    }\n\n    @Override", "    public boolean isLong(final @NotNull String path) {\n        return this.configuration.isLong(path);\n    }\n\n    @Override\n    public boolean isBoolean(final @NotNull String path) {\n        return this.configuration.isBoolean(path);\n    }\n\n    @Override\n    public boolean isLocation(final @NotNull String path) {\n        return this.configuration.isLocation(path);\n    }\n\n    @Override", "    public boolean isLocation(final @NotNull String path) {\n        return this.configuration.isLocation(path);\n    }\n\n    @Override\n    public boolean isOfflinePlayer(final @NotNull String path) {\n        return this.configuration.isOfflinePlayer(path);\n    }\n\n    @Override\n    public boolean isVector(final @NotNull String path) {\n        return this.configuration.isVector(path);\n    }\n\n    @Override", "    public boolean isVector(final @NotNull String path) {\n        return this.configuration.isVector(path);\n    }\n\n    @Override\n    public boolean isItemStack(final @NotNull String path) {\n        return this.configuration.isItemStack(path);\n    }\n\n    @Override\n    public boolean isColor(final @NotNull String path) {\n        return this.configuration.isColor(path);\n    }\n\n    @Override", "    public boolean isColor(final @NotNull String path) {\n        return this.configuration.isColor(path);\n    }\n\n    @Override\n    public boolean isList(final @NotNull String path) {\n        return this.configuration.isList(path);\n    }\n\n    @Override\n    public boolean isConfigurationSection(final @NotNull String path) {\n        return this.configuration.isConfigurationSection(path);\n    }\n\n    @Override", "    public boolean isConfigurationSection(final @NotNull String path) {\n        return this.configuration.isConfigurationSection(path);\n    }\n\n    @Override\n    public boolean isSet(final @NotNull String path) {\n        return this.configuration.isSet(path);\n    }\n\n    // Configuration file management methods\n\n    /**\n     * Loads the configuration file into the plugin's configuration object.\n     * <p>\n     * This method reads the config file and sets the value of the configuration object.\n     * If the config file does not exist, this method does nothing.\n     * <p>\n     * Note: Comments in the config file will be ignored during the loading process.\n     *\n     * @since 1.0.0\n     */\n    private void loadConfig() {", "        if (!this.configFile.exists()) return;\n\n        try {\n            String currentLine;\n\n            final List<String> lines = Files.readAllLines(this.configFile.toPath(), StandardCharsets.UTF_8);\n            final StringBuilder configData = new StringBuilder();\n\n            for (final String line : lines) {\n                currentLine = line.trim();\n", "            for (final String line : lines) {\n                currentLine = line.trim();\n\n                if (!currentLine.startsWith(\"#\")) {\n                    // Append the line to the config data\n                    configData.append(line).append(\"\\n\");\n                }\n\n            }\n\n            // Load the configData into this.configuration through a reader\n            final Reader inputString = new StringReader(configData.toString());\n            final BufferedReader reader = new BufferedReader(inputString);\n\n            this.configuration = YamlConfiguration.loadConfiguration(reader);\n\n            // Close the reader\n            inputString.close();\n            reader.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    /**\n     * Returns a key from a path.\n     * <p>\n     * If the path has any parents, we want to only get the children.\n     * We also want to add 2 spaces before the key, for every parent it has.\n     * This way, the key matches with the one from the initial load of the config (through {@link #loadConfig()}).\n     * <p>\n     * Example:\n     *   hello.i.am.liel\n     *   - 3 parents (hello, i, am)\n     *   - key is \"liel\"\n     *   - final key would have 6 spaces (3 parents * 2 spaces for each parent) -> \"      liel\"\n     *\n     * @param path the path to get the key of\n     * @return the key of the path\n     * @since 1.0.0\n     */\n    private @NotNull String getKeyFromPath(final @NotNull String path) {\n        StringBuilder key;\n", "        if (!path.contains(\".\")) {\n            key = new StringBuilder(path);\n        } else {\n            final String[] pathParts = path.split(\"\\\\.\");\n            key = new StringBuilder(pathParts[pathParts.length - 1]);\n\n            // Adding the spaces before the key\n            for (int i = 0; i < pathParts.length - 1; i++) {\n                key.insert(0, \"  \");\n            }\n        }\n\n        return key.toString();\n    }\n\n    /**\n     * Reloads the configuration from the file.\n     * <p>\n     * This method reloads the configuration by calling {@link #loadConfig()}.\n     *\n     * @since 1.0.0\n     */\n    @Override", "    public void reloadConfig() {\n        this.loadConfig();\n    }\n\n    /**\n     * Saves the configuration to the file.\n     * <p>\n     * This method saves the configuration by converting it to a string, applying comments,\n     * and then writing it to the config file.\n     *\n     * @since 1.0.0\n     */\n    @Override", "    public void saveConfig() {\n        this.saveConfig(this.getConfigAsString());\n    }\n\n    /**\n     * Saves the provided configuration string to the config file.\n     *\n     * @param configString the string to save to the config\n     * @since 1.0.0\n     */\n    private void saveConfig(final @NotNull String configString) {\n        try (final BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(this.configFile), StandardCharsets.UTF_8))) {\n            writer.write(configString);\n            writer.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Returns the configuration as a string.\n     *\n     * @return the string value of the config, including comments\n     * @since 1.0.0\n     */\n    private @NotNull String getConfigAsString() {\n        return this.configuration.saveToString();\n    }\n}"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/direction/DirectionUtils.java", "chunked_list": ["package dev.sadghost.espresso.spigot.direction;\n\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\nimport org.bukkit.util.Vector;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * A utility class for calculating directions.\n *", " * A utility class for calculating directions.\n *\n * <p>\n * This class provides methods for calculating angles and directions between locations and players.\n * It is used to determine the direction in which a player is relevant to a location or to calculate the yaw angle between two locations.\n * </p>\n *\n * <p>\n * This class is optimized for performance and efficiency.\n * </p>", " * This class is optimized for performance and efficiency.\n * </p>\n *\n * <p>\n * Thread Safety: This class is thread-safe and can be used concurrently from multiple threads.\n * </p>\n *\n * @author SadGhost\n * @since 1.0.0\n */\npublic final class DirectionUtils {\n\n    /**\n     * Private constructor to prevent instantiation of this utility class.\n     */\n    private DirectionUtils() {\n    }\n\n    /**\n     * Calculates the yaw angle between two locations.\n     *\n     * @param point1 the first location.\n     * @param point2 the second location.\n     * @return the yaw angle in degrees.\n     * @since 1.0.0\n     */", " * @since 1.0.0\n */\npublic final class DirectionUtils {\n\n    /**\n     * Private constructor to prevent instantiation of this utility class.\n     */\n    private DirectionUtils() {\n    }\n\n    /**\n     * Calculates the yaw angle between two locations.\n     *\n     * @param point1 the first location.\n     * @param point2 the second location.\n     * @return the yaw angle in degrees.\n     * @since 1.0.0\n     */", "    public static float getAngle(final @NotNull Vector point1,\n                                 final @NotNull Vector point2) {\n        final double dx = point2.getX() - point1.getX();\n        final double dz = point2.getZ() - point1.getZ();\n        float angle = (float) Math.toDegrees(Math.atan2(dz, dx)) - 90;\n\n        if (angle < 0) angle += 360.0F;\n        return angle;\n    }\n\n    /**\n     * Returns the direction in which a player is relevant to a location.\n     *\n     * @param player the player.\n     * @param to     the destination location.\n     * @return the direction.\n     * @since 1.0.0\n     */\n    public static @NotNull Direction getDirectionFromLocations(final @NotNull Player player,\n                                                               final @NotNull Location to) {", "        if (player.getWorld() != to.getWorld()) return Direction.X;\n        final Vector vector = to.toVector().subtract(player.getLocation().toVector());\n        final Vector direction = player.getEyeLocation().getDirection();\n        final double angle = vector.angle(direction);\n        final double deg = angle * 180 / Math.PI;\n\n        if (deg <= 22) return Direction.N;\n        else if (deg <= 67) return Direction.NE;\n        else if (deg <= 112) return Direction.E;\n        else if (deg <= 157) return Direction.SE;\n        else if (deg <= 202) return Direction.S;", "        else if (deg <= 112) return Direction.E;\n        else if (deg <= 157) return Direction.SE;\n        else if (deg <= 202) return Direction.S;\n        else if (deg <= 247) return Direction.SW;\n        else if (deg <= 292) return Direction.W;\n        else if (deg <= 337) return Direction.NW;\n        else if (deg <= 360) return Direction.N;\n\n        return Direction.X;\n    }\n}\n"]}
{"filename": "src/main/java/dev/sadghost/espresso/spigot/direction/Direction.java", "chunked_list": ["package dev.sadghost.espresso.spigot.direction;\n\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Enum representing directions with key names.\n *\n * <p>\n * This enum provides a set of directions with associated key names.", " * <p>\n * This enum provides a set of directions with associated key names.\n * Each direction is represented by an enum constant with its corresponding key name.\n * </p>\n *\n * <p>\n * This enum is used to represent directions in various contexts, such as player orientation or movement.\n * The enum constants also provide a method to retrieve the raw key name associated with each direction.\n * </p>\n *", " * </p>\n *\n * <p>\n * Thread Safety: This enum is thread-safe because it is an immutable and stateless representation of directions.\n * </p>\n *\n * <p>\n * Example usage:\n * <pre>{@code\n * Direction direction = Direction.N;", " * <pre>{@code\n * Direction direction = Direction.N;\n * String keyName = direction.getRawName(); // \"north\"\n * }</pre>\n * </p>\n *\n * <p>\n * <b>Note:</b> The \"X\" direction represents an unknown or invalid direction.\n * </p>\n *", " * </p>\n *\n * <p>\n * <b>Note:</b> The key names provided in this enum are arbitrary and may vary depending on the specific context or convention being used.\n * </p>\n *\n * <p>\n * <b>Note:</b> This enum can be extended to support additional directions if needed.\n * </p>\n *", " * </p>\n *\n * @author SadGhost\n * @since 1.0.0\n */\npublic enum Direction {\n    N(\"north\"),\n    NE(\"north_east\"),\n    E(\"east\"),\n    SE(\"south_east\"),\n    S(\"south\"),\n    SW(\"south_west\"),\n    W(\"west\"),\n    NW(\"north_west\"),\n    X(\"unknown_direction\");\n\n    @NotNull\n    private final String rawName;\n\n    /**\n     * Constructs a Direction enum constant with the given raw key name.\n     *\n     * @param rawName the raw key name associated with the direction.\n     */\n    @Contract(pure = true)\n    Direction(final @NotNull String rawName) {\n        this.rawName = rawName;\n    }\n\n    /**\n     * Retrieves the raw key name associated with the direction.\n     *\n     * @return the raw key name.\n     */\n    public @NotNull String getRawName() {\n        return rawName;\n    }\n}\n\n"]}
