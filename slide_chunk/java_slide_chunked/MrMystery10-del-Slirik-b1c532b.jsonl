{"filename": "Compiler/src/statements/Variable.java", "chunked_list": ["package statements;\n\n/**\n * This statement creates a new variable\n */\npublic class Variable extends Statement {\n\n    private static final String STATEMENT = \"var\";\n\n    public Variable(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Directory.java", "chunked_list": ["package statements;\n\n/**\n * This statement sets the current variable directory,\n * global directory or unique directory for each method\n */\npublic class Directory extends Statement {\n\n    private static final String STATEMENT = \"dir\";\n\n    public Directory(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}"]}
{"filename": "Compiler/src/statements/Setter.java", "chunked_list": ["package statements;\n\n/**\n * Sets a value to current container\n */\npublic class Setter extends Statement {\n\n    private static final String STATEMENT = \"set\";\n\n    public Setter(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/End.java", "chunked_list": ["package statements;\n\n/**\n * Sets a border for skiper\n */\npublic class End extends Statement {\n\n    private static final String STATEMENT = \"end\";\n\n    public End() {\n        super(STATEMENT, \"NONE\");\n    }\n\n    public End(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}"]}
{"filename": "Compiler/src/statements/Getter.java", "chunked_list": ["package statements;\n\n/**\n * Gets the variable container\n */\npublic class Getter extends Statement {\n\n    private static final String STATEMENT = \"get\";\n\n    public Getter(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Skip.java", "chunked_list": ["package statements;\n\n/**\n * Skips until end statement when condition is false\n */\npublic class Skip extends Statement {\n\n    private static final String STATEMENT = \"skip\";\n\n    public Skip() {\n        super(STATEMENT, \"NONE\");\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Condition.java", "chunked_list": ["package statements;\n\n/**\n * Sets a value to check for condition\n */\npublic class Condition extends Statement {\n\n    private static final String STATEMENT = \"con\";\n\n    public Condition(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}"]}
{"filename": "Compiler/src/statements/Type.java", "chunked_list": ["package statements;\n\n/**\n * Sets the type for next variables\n */\npublic class Type extends Statement {\n\n    private static final String STATEMENT = \"type\";\n\n    public Type(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}"]}
{"filename": "Compiler/src/statements/Adder.java", "chunked_list": ["package statements;\n\n/**\n * Adds the value to container\n */\npublic class Adder extends Statement {\n\n    private static final String STATEMENT = \"add\";\n\n    public Adder(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Operation.java", "chunked_list": ["package statements;\n\n/**\n * Sets the operation-type for next operation between numbers or containers\n */\npublic class Operation extends Statement {\n\n    private static final String STATEMENT = \"op\";\n\n    /**\n     * @param VALUE\n     *             + = PLUS,\n     *             - = MINUS,\n     *             * = MULTIPLY,\n     *             / = DIVIDE,\n     *             % = MODULO,\n     *             ^ = X TO THE POWER OF Y,\n     *             # = X ROOT OF Y\n     */\n    public Operation(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Jump.java", "chunked_list": ["package statements;\n\n/**\n * Jump back to last block\n */\npublic class Jump extends Statement {\n\n    private static final String STATEMENT = \"jump\";\n\n    public Jump(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}"]}
{"filename": "Compiler/src/statements/Block.java", "chunked_list": ["package statements;\n\n/**\n * Sets a block for back jumping\n */\npublic class Block extends Statement {\n\n    private static final String STATEMENT = \"block\";\n\n    public Block(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Call.java", "chunked_list": ["package statements;\n\n/**\n * Calls a defined function\n */\npublic class Call extends Statement {\n\n    private static final String STATEMENT = \"reva\";\n\n    public Call(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Statement.java", "chunked_list": ["package statements;\n\nimport java.util.Objects;\n\npublic abstract class Statement {\n\n    private final String STATEMENT;\n    private final String VALUE;\n\n    protected Statement(String STATEMENT, String VALUE) {\n        this.STATEMENT = STATEMENT;\n        this.VALUE = VALUE;\n    }\n", "    public String getSTATEMENT() {\n        return STATEMENT;\n    }\n\n    public String getVALUE() {\n        return VALUE;\n    }\n\n    /**\n     * Generates a bytecode statement\n     */\n    @Override", "    public String toString() {\n        return STATEMENT + \" \" + VALUE;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Statement statement)) return false;\n        return STATEMENT.equals(statement.STATEMENT) && VALUE.equals(statement.VALUE);\n    }\n\n    @Override", "    public int hashCode() {\n        return Objects.hash(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Parameter.java", "chunked_list": ["package statements;\n\n/**\n * Sets a required parameter for calling a method\n */\npublic class Parameter extends Statement {\n\n    private static final String STATEMENT = \"param\";\n\n    public Parameter(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Load.java", "chunked_list": ["package statements;\n\n/**\n * Load a register\n */\npublic class Load extends Statement {\n\n    private static final String STATEMENT = \"load\";\n\n    public Load(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/ConditionOperation.java", "chunked_list": ["package statements;\n\n/**\n * Sets an operation for comparing conditions\n */\npublic class ConditionOperation extends Statement {\n\n    private static final String STATEMENT = \"cop\";\n\n    public ConditionOperation(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/ReturnValue.java", "chunked_list": ["package statements;\n\n/**\n * Sets the return type of function\n */\npublic class ReturnValue extends Statement {\n\n    private static final String STATEMENT = \"reva\";\n\n    public ReturnValue(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/statements/Return.java", "chunked_list": ["package statements;\n\n/**\n * Returns a value to last caller\n */\npublic class Return extends Statement {\n\n    private static final String STATEMENT = \"return\";\n\n    public Return(String VALUE) {\n        super(STATEMENT, VALUE);\n    }\n}\n"]}
{"filename": "Compiler/src/keywords/Function.java", "chunked_list": ["package keywords;\n\nimport core.Lexer;\nimport statements.*;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Function implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public Function(List<Lexer.Token> tokens) {\n\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}", "public class Function implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public Function(List<Lexer.Token> tokens) {\n\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}"]}
{"filename": "Compiler/src/keywords/Keyword.java", "chunked_list": ["package keywords;\n\nimport statements.Statement;\n\nimport java.util.List;\n\npublic interface Keyword {\n    List<Statement> getKeywordBody();\n}\n"]}
{"filename": "Compiler/src/keywords/While.java", "chunked_list": ["package keywords;\n\nimport core.Lexer;\nimport statements.*;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class While implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public While(List<Lexer.Token> tokens) {\n        body.add(new Block(\"NONE\"));\n\n        Lexer.Token token;\n        Iterator<Lexer.Token> iterator = tokens.iterator();\n", "\npublic class While implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public While(List<Lexer.Token> tokens) {\n        body.add(new Block(\"NONE\"));\n\n        Lexer.Token token;\n        Iterator<Lexer.Token> iterator = tokens.iterator();\n", "        while (iterator.hasNext()) {\n            token = iterator.next();\n            if (token.tokenType() == Lexer.TokenType.NUMBER || token.tokenType() == Lexer.TokenType.IDENTIFIER) {\n                body.add(new Condition(token.value()));\n            } else throw new IllegalArgumentException();\n\n            if (iterator.hasNext())\n                token = iterator.next();\n            else break;\n\n            if (token.tokenType() == Lexer.TokenType.CONDITION) {\n                body.add(new ConditionOperation(token.value()));\n            } else {\n                //TODO implement multiple conditions\n            }\n        }\n\n        body.add(new Skip());\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}\n", "            if (token.tokenType() == Lexer.TokenType.CONDITION) {\n                body.add(new ConditionOperation(token.value()));\n            } else {\n                //TODO implement multiple conditions\n            }\n        }\n\n        body.add(new Skip());\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}\n"]}
{"filename": "Compiler/src/keywords/Else.java", "chunked_list": ["package keywords;\n\nimport core.Lexer;\nimport statements.*;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Else implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public Else() {\n        body.add(new Block(\"NONE\"));\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}\n", "\npublic class Else implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public Else() {\n        body.add(new Block(\"NONE\"));\n    }\n\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}\n"]}
{"filename": "Compiler/src/keywords/If.java", "chunked_list": ["package keywords;\n\nimport core.Lexer;\nimport statements.*;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class If implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public If(List<Lexer.Token> tokens) {\n        body.add(new Block(\"NONE\"));\n\n        Lexer.Token token;\n        Iterator<Lexer.Token> iterator = tokens.iterator();\n", "\npublic class If implements Keyword {\n\n    private final List<Statement> body = new LinkedList<>();\n\n    public If(List<Lexer.Token> tokens) {\n        body.add(new Block(\"NONE\"));\n\n        Lexer.Token token;\n        Iterator<Lexer.Token> iterator = tokens.iterator();\n", "        while (iterator.hasNext()) {\n            token = iterator.next();\n            if (token.tokenType() == Lexer.TokenType.NUMBER || token.tokenType() == Lexer.TokenType.IDENTIFIER) {\n                body.add(new Condition(token.value()));\n            } else \n            {\n                throw new IllegalArgumentException(\"Invalid Token Type\");\n            }\n            if (iterator.hasNext())\n            {\n                token = iterator.next();", "            if (iterator.hasNext())\n            {\n                token = iterator.next();\n                if (token.tokenType() == Lexer.TokenType.CONDITION) {\n                    body.add(new ConditionOperation(token.value()));\n                } else {\n                    throw new IllegalArgumentException(\"Expected condition token\");\n                    }\n            }\n            else {\n                throw new IllegalArgumentException(\"Missing condition token\");\n            }\n        }\n        body.add(new Skip());\n    }\n    @Override\n    public List<Statement> getKeywordBody() {\n        return body;\n    }\n}\n"]}
{"filename": "Compiler/src/core/Validator.java", "chunked_list": ["package core;\n\nimport statements.Statement;\n\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Validator {\n    // Queue to store validated statements\n    private Queue<Statement> validated = new LinkedList<>();\n    //Queue to store non-validated statements\n    private Queue<Statement> nonValidated;\n\n    // Set to store variables ecountered during the validation proccess\n    private Set<String> variables = new HashSet<>();\n    // Directory, type, and operator used for validation\n    private String directory = \"\";\n    private String type = \"\";\n    private String operator = \"\";\n\n    // Constructor for validator object with a queue of statements that need ot be validated\n    protected Validator(Queue<Statement> statements) {\n        this.nonValidated = statements;\n    }\n\n    // Returns the queue of validated statements\n    protected Queue<Statement> getValidatedStatements() {", "\npublic class Validator {\n    // Queue to store validated statements\n    private Queue<Statement> validated = new LinkedList<>();\n    //Queue to store non-validated statements\n    private Queue<Statement> nonValidated;\n\n    // Set to store variables ecountered during the validation proccess\n    private Set<String> variables = new HashSet<>();\n    // Directory, type, and operator used for validation\n    private String directory = \"\";\n    private String type = \"\";\n    private String operator = \"\";\n\n    // Constructor for validator object with a queue of statements that need ot be validated\n    protected Validator(Queue<Statement> statements) {\n        this.nonValidated = statements;\n    }\n\n    // Returns the queue of validated statements\n    protected Queue<Statement> getValidatedStatements() {", "        while (!nonValidated.isEmpty()) {\n            Statement statement = nonValidated.poll();\n             // Checks to see the statement type\n            switch (statement.getSTATEMENT()) {\n                case \"dir\" -> validateDir(statement, statement.getVALUE());\n                case \"op\" -> validateOp(statement, statement.getVALUE());\n                case \"type\" -> validateType(statement, statement.getVALUE());\n                case \"var\" -> validateVar(statement, statement.getVALUE());\n                default -> validated.offer(statement);\n            }\n        }\n        return validated;\n    }\n\n    //Validates the directory statement and updates the directory value as neccessary\n    private void validateDir(Statement statement, String value) {", "        if (!directory.equals(value)) {\n            validated.offer(statement);\n            directory = value;\n        }\n    }\n\n    // Validates the operator statement and updates the operator value as neccesarry\n    private void validateOp(Statement statement, String value) {\n        if (!operator.equals(value)) {\n            validated.offer(statement);\n            operator = value;\n        }\n    }\n\n    // Validates the type statememnt and updates the type value as neccessarry\n    private void validateType(Statement statement, String value) {", "        if (!operator.equals(value)) {\n            validated.offer(statement);\n            operator = value;\n        }\n    }\n\n    // Validates the type statememnt and updates the type value as neccessarry\n    private void validateType(Statement statement, String value) {\n        if (!type.equals(value)) {\n            validated.offer(statement);\n            type = value;\n        }\n    }\n\n    // Validates the variable statement and adds it to the set of variables f it is unique\n    private void validateVar(Statement statement, String value) {", "        if (!type.equals(value)) {\n            validated.offer(statement);\n            type = value;\n        }\n    }\n\n    // Validates the variable statement and adds it to the set of variables f it is unique\n    private void validateVar(Statement statement, String value) {\n        if (variables.add(value)) {\n            validated.offer(statement);\n        }\n    }\n}\n", "        if (variables.add(value)) {\n            validated.offer(statement);\n        }\n    }\n}\n"]}
{"filename": "Compiler/src/core/Lexer.java", "chunked_list": ["package core;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Lexer {\n\n    public enum TokenType {\n        TYPE, IDENTIFIER, EQUALS, NUMBER, BINARY_OPERATOR, OPEN_PAREN, CLOSE_PAREN, OPEN_HEAD, CLOSE_HEAD, END,\n        KEYWORD, FUNCTION, CONDITION\n    }\n\n    protected static List<Token> tokenize(String s) {\n        List<Token> tokenList = new ArrayList<>();\n        int i = 0;", "        while (i < s.length()) {\n            char c = s.charAt(i);\n            if (Character.isWhitespace(c)) {\n                i++;\n                continue;\n            }\n            if (Character.isDigit(c) || c == '.') {\n                StringBuilder numberBuilder = new StringBuilder();\n                while (i < s.length() && Character.isDigit(s.charAt(i)) || s.charAt(i) == '.') {\n                    numberBuilder.append(s.charAt(i));\n                    i++;\n                }\n                tokenList.add(new Token(numberBuilder.toString(), TokenType.NUMBER));\n                continue;\n            }", "                while (i < s.length() && Character.isDigit(s.charAt(i)) || s.charAt(i) == '.') {\n                    numberBuilder.append(s.charAt(i));\n                    i++;\n                }\n                tokenList.add(new Token(numberBuilder.toString(), TokenType.NUMBER));\n                continue;\n            }\n            if (Character.isLetter(c)) {\n                StringBuilder identifierBuilder = new StringBuilder();\n                while (i < s.length() && Character.isLetterOrDigit(s.charAt(i))) {\n                    identifierBuilder.append(s.charAt(i));\n                    i++;\n                }\n                String identifier = identifierBuilder.toString();", "                while (i < s.length() && Character.isLetterOrDigit(s.charAt(i))) {\n                    identifierBuilder.append(s.charAt(i));\n                    i++;\n                }\n                String identifier = identifierBuilder.toString();\n                if (identifier.equals(\"int\") || identifier.equals(\"float\") || identifier.equals(\"bool\")) {\n                    tokenList.add(new Token(identifier, TokenType.TYPE));\n                } else if (identifier.equals(\"if\") || identifier.equals(\"else\") || identifier.equals(\"while\") || identifier.equals(\"for\")) {\n                    tokenList.add(new Token(identifier, TokenType.KEYWORD));\n                } else {\n                    tokenList.add(new Token(identifier, TokenType.IDENTIFIER));\n                }\n                continue;\n            }", "            if (c == '=') {\n                char next = s.charAt(i + 1);\n                if (next == '=') {\n                    tokenList.add(new Token(\"\" + c + next, TokenType.CONDITION));\n                    i += 2;\n                } else {\n                    tokenList.add(new Token(String.valueOf(c), TokenType.EQUALS));\n                    i++;\n                }\n                continue;\n            }", "            if (c == '{') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.OPEN_PAREN));\n                i++;\n                continue;\n            }\n            if (c == '}') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.CLOSE_PAREN));\n                i++;\n                continue;\n            }\n            if (c == '(') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.OPEN_HEAD));\n                i++;\n                continue;\n            }", "            if (c == '(') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.OPEN_HEAD));\n                i++;\n                continue;\n            }\n            if (c == ')') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.CLOSE_HEAD));\n                i++;\n                continue;\n            }\n            if (c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^' || c == '#') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.BINARY_OPERATOR));\n                i++;\n                continue;\n            }", "            if (c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^' || c == '#') {\n                tokenList.add(new Token(String.valueOf(c), TokenType.BINARY_OPERATOR));\n                i++;\n                continue;\n            }\n            if (c == '<' || c == '>') {\n                char next = s.charAt(i + 1);\n                if (next == '=') {\n                    tokenList.add(new Token(\"\" + c + next, TokenType.CONDITION));\n                    i += 2;\n                } else {\n                    tokenList.add(new Token(String.valueOf(c), TokenType.CONDITION));\n                    i++;\n                }\n                continue;\n            }", "            if (c == ';') {\n                tokenList.add(new Token(\";\", TokenType.END));\n                break;\n            }\n            throw new IllegalArgumentException(\"Invalid character: \" + c);\n        }\n        return tokenList;\n    }\n\n    public record Token(String value, TokenType tokenType) {\n\n        @Override", "    public record Token(String value, TokenType tokenType) {\n\n        @Override\n        public String toString() {\n            return \"TokenImpl {\" +\n                    \"value = '\" + value + '\\'' +\n                    \" | tokenType = \" + tokenType +\n                    '}';\n        }\n    }\n}"]}
{"filename": "Compiler/src/core/Main.java", "chunked_list": ["package core;\n\nimport statements.Statement;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {", "import java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        long time;\n        long compileTime;\n        long writeTime;\n\n        File inputFile;\n        String outPutDirectory = \"VirtualMachine/\";\n", "        if (args.length == 1) {\n            inputFile = new File(args[0]);\n        } else if (args.length == 2) {\n            inputFile = new File(args[0]);\n            outPutDirectory = args[1];\n        } else inputFile = new File(selectFile());\n\n\n        time = System.nanoTime();\n\n        List<Lexer.Token> tokens = tokenizeFile(inputFile);\n\n        Parser parser = new Parser(tokens);\n\n        Queue<Statement> statements = parser.getStatements();\n        compileTime = ((System.nanoTime() - time) / 1_000_000);\n        time = System.nanoTime();\n\n        generateBytecodeFile(outPutDirectory + inputFile.getName(), statements);\n        writeTime = ((System.nanoTime() - time) / 1_000_000);\n\n        System.out.println(\"Compile time: \" + compileTime + \"ms\");\n        System.out.println(\"Writing time: \" + writeTime + \"ms\");\n        System.out.println(\"Total time: \" + (compileTime + writeTime) + \"ms\");\n\n        System.exit(0);\n    }\n\n    // Returns a list of tokens which got generated based on provided file\n    private static List<Lexer.Token> tokenizeFile(File file) {\n        List<Lexer.Token> tokens = new LinkedList<>();\n", "        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n\n            String s;\n            while ((s = reader.readLine()) != null)\n                tokens.addAll(Lexer.tokenize(s));\n            reader.close();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n\n        return tokens;\n    }\n\n    private static void generateBytecodeFile(String fileIdentifier, Queue<Statement> statements) {\n        File byteCode = new File(fileIdentifier.substring(0, fileIdentifier.length() - 3) + \".sks\");\n        try (FileWriter writer = new FileWriter(byteCode)) {", "            while (!statements.isEmpty())\n                writer.write(statements.poll().toString() + \"\\n\");\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n\n    private static String selectFile() {\n        FileDialog dialog = new FileDialog(new Frame(), \"Select .sk File\");\n        dialog.setMode(FileDialog.LOAD);\n        dialog.setFilenameFilter((dir, name) -> name.endsWith(\".sk\"));\n        dialog.setVisible(true);\n\n        return dialog.getDirectory() + dialog.getFile();\n    }\n}"]}
{"filename": "Compiler/src/core/Trees.java", "chunked_list": ["package core;\n\nimport keywords.Else;\nimport keywords.If;\nimport keywords.While;\nimport statements.*;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;", "import java.util.LinkedList;\nimport java.util.List;\n\npublic class Trees {\n\n    // Constructor for type tree\n    protected static List<Statement> typeTree(Iterator<Lexer.Token> tokens) {\n        return typeTree(tokens, tokens.next());\n    }\n\n    // Constuructor of a type Tree that takes a stream of tokens, Starting from the given token (currentToken)\n    protected static List<Statement> typeTree(Iterator<Lexer.Token> tokens, Lexer.Token currentToken) {\n        List<Statement> statements = new LinkedList<>();\n\n        Lexer.Token token = currentToken;\n        statements.add(new Type(token.value()));\n        // Checks the type of token \n        token = tokens.next();", "        if (token.tokenType() == Lexer.TokenType.END) {\n            return statements;\n        } else if (token.tokenType() == Lexer.TokenType.IDENTIFIER) {\n            // Calls indenfierTree and adds reslut to the statement list\n            statements.addAll(identifierTree(tokens, token));\\\n            // Exeption if token is neither END or IDENTIFIER\n        } else throw new IllegalArgumentException(token.value() + \" is not allowed after type\");\n\n        return statements;\n    }\n\n    // Constructor for identifier tree from a stream of tokens\n    protected static List<Statement> identifierTree(Iterator<Lexer.Token> tokens) {\n        return identifierTree(tokens, tokens.next());\n    }\n\n\n     // Constructor for identifier tree from a stream of tokens, starting from a given token (currentToken)\n    protected static List<Statement> identifierTree(Iterator<Lexer.Token> tokens, Lexer.Token currentToken) {\n        List<Statement> statements = new LinkedList<>();\n\n        Lexer.Token token = currentToken;\n        statements.add(new Variable(token.value()));\n        statements.add(new Load(token.value()));\n\n        token = tokens.next();\n        // Checks the token type", "        if (token.tokenType() == Lexer.TokenType.EQUALS) {\n            statements.addAll(equalsTree(tokens));\n        } else if (token.tokenType() == Lexer.TokenType.BINARY_OPERATOR) {\n            statements.addAll(equalsTree(tokens, false));\n        } else if (token.tokenType() == Lexer.TokenType.END) {\n            return statements;\n            // Exception of token is not one of the above listed\n        } else throw new IllegalArgumentException(token.value() + \" is not allowed after identifier\");\n\n        return statements;\n    }\n\n    // Constructor for equals tree from a stream of tokens\n    private static List<Statement> equalsTree(Iterator<Lexer.Token> tokens) {\n        return equalsTree(tokens, true);\n    }\n\n    // Constructor for equals tree from a stream of tokens, optionally starting with a new value\n    private static List<Statement> equalsTree(Iterator<Lexer.Token> tokens, boolean newValue) {\n        List<Statement> statements = new LinkedList<>();\n", "        if (newValue)\n            statements.add(new Setter(\"0\"));\n        statements.add(new Operation(\"+\"));\n\n        Lexer.Token token;\n        // While loop that iterates until there are no more tokens\n        while (tokens.hasNext()) {\n            token = tokens.next();\n            \n            // Checks the token type\n            switch (token.tokenType()) {\n                case NUMBER -> statements.add(new Adder(token.value()));\n                case IDENTIFIER -> statements.add(new Getter(token.value()));\n                case BINARY_OPERATOR -> statements.add(new Operation(token.value()));\n            }\n        }\n\n        return statements;\n    }\n\n    // Creates a keyword tree from a stream of tokens\n    protected static List<Statement> keywordTree(Iterator<Lexer.Token> tokens) {\n        List<Statement> statements = new LinkedList<>();\n\n        Lexer.Token token = tokens.next();\n        String keyword = token.value();\n\n        token = tokens.next();\n        // Checks for if and while statements", "        if (keyword.equals(\"if\") || keyword.equals(\"while\")) {\n            List<Lexer.Token> headTokens = new LinkedList<>();\n\n            // Add the tokens before the opening parenthesis to the headTokens list\n            while (token.tokenType() != Lexer.TokenType.OPEN_PAREN) {\n                headTokens.add(token);\n                token = tokens.next();\n            }\n\n            if (keyword.equals(\"if\")) {\n                statements.addAll(new If(headTokens).getKeywordBody());\n                statements.addAll(bodyTree(false, tokens));\n            // Checks for while statements\n            } else {\n                statements.addAll(new While(headTokens).getKeywordBody());\n                statements.addAll(bodyTree(true, tokens));\n            }\n            // Checks for else statements", "            if (keyword.equals(\"if\")) {\n                statements.addAll(new If(headTokens).getKeywordBody());\n                statements.addAll(bodyTree(false, tokens));\n            // Checks for while statements\n            } else {\n                statements.addAll(new While(headTokens).getKeywordBody());\n                statements.addAll(bodyTree(true, tokens));\n            }\n            // Checks for else statements\n        } else if (keyword.equals(\"else\")) {\n            statements.addAll(new Else().getKeywordBody());\n            statements.addAll(bodyTree(false, tokens));\n        }\n\n        return statements;\n    }\n\n    // Creates a bopdy tree from a stream of tokens\n\n    private static List<Statement> bodyTree(boolean jump, Iterator<Lexer.Token> tokens) {\n        List<Statement> statements = new LinkedList<>();\n        Lexer.Token token = tokens.next();\n\n        List<Lexer.Token> expressionTokens = new LinkedList<>();\n\n        boolean foundBody = false;\n        int closedParensAvailable = 1;\n        // Adds tokens if they're in parenthesis", "        } else if (keyword.equals(\"else\")) {\n            statements.addAll(new Else().getKeywordBody());\n            statements.addAll(bodyTree(false, tokens));\n        }\n\n        return statements;\n    }\n\n    // Creates a bopdy tree from a stream of tokens\n\n    private static List<Statement> bodyTree(boolean jump, Iterator<Lexer.Token> tokens) {\n        List<Statement> statements = new LinkedList<>();\n        Lexer.Token token = tokens.next();\n\n        List<Lexer.Token> expressionTokens = new LinkedList<>();\n\n        boolean foundBody = false;\n        int closedParensAvailable = 1;\n        // Adds tokens if they're in parenthesis", "        while (closedParensAvailable != 0) {\n            expressionTokens.add(token);\n            token = tokens.next();\n\n            if (token.tokenType() == Lexer.TokenType.OPEN_PAREN)\n                closedParensAvailable++;\n            else if (token.tokenType() == Lexer.TokenType.CLOSE_PAREN)\n                closedParensAvailable--;\n        }\n        statements.addAll(identifyToken(expressionTokens.iterator()));\n\n        //Checks for Jump statements", "        if (jump) statements.add(new Jump(\"NONE\"));\n        statements.add(new End());\n\n        return statements;\n    }\n\n    // Identifier for type of token ofr the correct tree construction\n    private static List<Statement> identifyToken(Iterator<Lexer.Token> tokens) {\n        List<Statement> statements = new LinkedList<>();\n\n        Lexer.Token token;\n        // Iterates through tokens until there are no more", "        while (tokens.hasNext()) {\n            token = tokens.next();\n\n            // Checks the token type\n            statements.addAll(switch (token.tokenType()) {\n                case TYPE -> typeTree(tokens, token);\n                case IDENTIFIER -> identifierTree(tokens, token);\n                case KEYWORD -> keywordTree(tokens);\n                default -> throw new IllegalArgumentException(\"Illegal start of statement\");\n            });\n        }\n        return statements;\n    }\n}\n"]}
{"filename": "Compiler/src/core/Parser.java", "chunked_list": ["package core;\n\nimport statements.*;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Parser {\n\n    // List of the Lexer generated tokens from the source code\n    private final List<Lexer.Token> tokens;\n\n    // Queue of generated bytecode statements\n    private Queue<Statement> statements = new LinkedList<>();\n\n    // Current index of the given tokens\n    private int index = 0;\n\n    protected Parser(List<Lexer.Token> tokens) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * @return a new Queue of generated bytecode statements based on the tokens given to the Parser object\n     */\n    protected Queue<Statement> getStatements() {\n        statements.add(new Directory(\"global\"));\n        statements.add(new Type(\"int\"));\n        statements.add(new Operation(\"+\"));\n\n        // Loop through tokens and decide which operation should happen to generate a bytecode statement for each token", "\npublic class Parser {\n\n    // List of the Lexer generated tokens from the source code\n    private final List<Lexer.Token> tokens;\n\n    // Queue of generated bytecode statements\n    private Queue<Statement> statements = new LinkedList<>();\n\n    // Current index of the given tokens\n    private int index = 0;\n\n    protected Parser(List<Lexer.Token> tokens) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * @return a new Queue of generated bytecode statements based on the tokens given to the Parser object\n     */\n    protected Queue<Statement> getStatements() {\n        statements.add(new Directory(\"global\"));\n        statements.add(new Type(\"int\"));\n        statements.add(new Operation(\"+\"));\n\n        // Loop through tokens and decide which operation should happen to generate a bytecode statement for each token", "        for (; index < tokens.size(); index++) identifyToken();\n        return new Validator(statements).getValidatedStatements();\n    }\n\n    // Executes an action for adding statements based on token\n    private void identifyToken() {\n        switch (tokens.get(index).tokenType()) {\n            case TYPE -> whenType();\n            case IDENTIFIER -> whenIdentifier();\n            case EQUALS -> whenEquals();\n            case NUMBER -> whenNumber();\n            case BINARY_OPERATOR -> whenBinaryOperation();\n            case OPEN_PAREN -> whenOpenParen();\n            case CLOSE_PAREN -> whenCloseParen();\n            case OPEN_HEAD -> whenOpenHead();\n            case CLOSE_HEAD -> whenCloseHead();\n            case END -> whenEnd();\n            case KEYWORD -> whenKeyWord();\n        }\n    }\n\n    private void whenType() {\n        List<Lexer.Token> expressionTokens = new LinkedList<>();", "        for (; tokens.get(index).tokenType() != Lexer.TokenType.END; index++) {\n            expressionTokens.add(tokens.get(index));\n        }\n        expressionTokens.add(tokens.get(index));\n\n        statements.addAll(Trees.typeTree(expressionTokens.iterator()));\n    }\n\n    private void whenIdentifier() {\n        List<Lexer.Token> expressionTokens = new LinkedList<>();\n        for (; tokens.get(index).tokenType() != Lexer.TokenType.END; index++) {\n            expressionTokens.add(tokens.get(index));\n        }\n        expressionTokens.add(tokens.get(index));\n\n        statements.addAll(Trees.identifierTree(expressionTokens.iterator()));\n    }\n\n    private void whenEquals() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenNumber() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenBinaryOperation() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenOpenParen() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenCloseParen() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenOpenHead() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenCloseHead() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenEnd() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenKeyWord() {\n        List<Lexer.Token> expressionTokens = new LinkedList<>();\n\n        boolean foundBody = false;\n        int closedParensAvailable = 0;", "        for (; tokens.get(index).tokenType() != Lexer.TokenType.END; index++) {\n            expressionTokens.add(tokens.get(index));\n        }\n        expressionTokens.add(tokens.get(index));\n\n        statements.addAll(Trees.identifierTree(expressionTokens.iterator()));\n    }\n\n    private void whenEquals() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenNumber() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenBinaryOperation() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenOpenParen() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenCloseParen() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenOpenHead() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenCloseHead() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenEnd() {\n        throw new IllegalArgumentException(\"Illegal start of statement\");\n    }\n\n    private void whenKeyWord() {\n        List<Lexer.Token> expressionTokens = new LinkedList<>();\n\n        boolean foundBody = false;\n        int closedParensAvailable = 0;", "        for (; closedParensAvailable != 0 || closedParensAvailable == 0 && !foundBody; index++) {\n            Lexer.Token token = tokens.get(index);\n            expressionTokens.add(token);\n\n            if (token.tokenType() == Lexer.TokenType.OPEN_PAREN) {\n                closedParensAvailable++;\n                foundBody = true;\n            } else if (token.tokenType() == Lexer.TokenType.CLOSE_PAREN)\n                closedParensAvailable--;\n        }\n        boolean haveElse = false;", "        if (index < tokens.size() && tokens.get(index).value().equals(\"else\")) {\n            haveElse = true;\n        }\n\n        index--;\n\n        statements.addAll(Trees.keywordTree(expressionTokens.iterator()));\n\n        if (haveElse) {\n            Deque<Statement> deque = new LinkedList<>(statements);\n            deque.removeLast();\n            deque.addLast(new End(\"next\"));\n            statements = new LinkedList<>(deque);\n        }\n    }\n}", "        if (haveElse) {\n            Deque<Statement> deque = new LinkedList<>(statements);\n            deque.removeLast();\n            deque.addLast(new End(\"next\"));\n            statements = new LinkedList<>(deque);\n        }\n    }\n}"]}
