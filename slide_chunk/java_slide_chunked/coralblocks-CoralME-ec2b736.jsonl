{"filename": "src/test/java/com/coralblocks/coralme/OrderBookTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport static org.junit.Assert.*;", "\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;", "import com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\nimport com.coralblocks.coralme.Order.Side;\nimport com.coralblocks.coralme.Order.TimeInForce;\nimport com.coralblocks.coralme.util.DoubleUtils;\n\n\npublic class OrderBookTest {\n\n\t\n\tprivate OrderBookListener called(OrderBookListener listener, int times) {\n\t\treturn Mockito.verify(listener, Mockito.times(times));\n\t}\n\t\n\tprivate void done(OrderBookListener listener) {\n\t\tMockito.verifyNoMoreInteractions(listener);\n\t}\n\t\n\tprivate static class OrderExecutedCaptor {\n\t\t\n\t\tArgumentCaptor<OrderBook> \t\tbook = ArgumentCaptor.forClass(OrderBook.class);\n\t\tArgumentCaptor<Long> \t\t\ttime = ArgumentCaptor.forClass(Long.class);\n\t\tArgumentCaptor<Order> \t\t\torder = ArgumentCaptor.forClass(Order.class);\n\t\tArgumentCaptor<ExecuteSide>\t\texecuteSide = ArgumentCaptor.forClass(ExecuteSide.class);\n\t\tArgumentCaptor<Long> \t\t\texecuteSize = ArgumentCaptor.forClass(Long.class);\n\t\tArgumentCaptor<Long>  \t\t\texecutePrice = ArgumentCaptor.forClass(Long.class);\n\t\tArgumentCaptor<Long>  \t\t\texecuteId = ArgumentCaptor.forClass(Long.class);\n\t\tArgumentCaptor<Long>  \t\t\texecuteMatchId = ArgumentCaptor.forClass(Long.class);\n\t}\n\t\n\t@Test", "\tpublic void test_Order_Accepted() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder order = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t}\n\t\n\t@Test", "\tpublic void test_Order_Rejected_Due_To_Price() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\t// Market order cannot have a price\n\t\tOrder order = book.createOrder(\"1\", 1, Side.BUY, 800, DoubleUtils.toLong(432.12), Order.Type.MARKET, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 0).onOrderAccepted(null, 0, null);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 1).onOrderRejected(book, order.getRejectTime(), order, RejectReason.BAD_PRICE);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t}\n\t\n\t@Test", "\tpublic void test_Order_Rejected_Due_To_Odd_Lot() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener) {\n\t\t\t@Override\n\t\t\tprotected RejectReason validateOrder(Order order) {\n\t\t\t\tif (order.getOriginalSize() % 100 != 0) {\n\t\t\t\t\treturn RejectReason.BAD_LOT;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tOrder order = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t\t\n\t\t// Odd lot not accepted...\n\t\torder = book.createLimit(\"2\", 2, Side.SELL, 850, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 0).onOrderAccepted(null, 0, null);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 1).onOrderRejected(book, order.getRejectTime(), order, RejectReason.BAD_LOT);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t}\n\t\n\t@Test", "\tpublic void test_IoC_Order_Misses() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder order = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t\t\n\t\torder = book.createLimit(\"2\", 2, Side.SELL, 100, 432.13, TimeInForce.IOC);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 1).onOrderCanceled(book, order.getCancelTime(), order, CancelReason.MISSED);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null,0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t}\n\t\n\t@Test", "\tpublic void test_Limit_Order_Rests() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder order = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t\t\n\t\torder = book.createLimit(\"2\", 2, Side.SELL, 100, 432.13, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t\t\n\t\tassertEquals(1, book.getAskLevels());\n\t\tassertEquals(1, book.getBidLevels());\n\t\tassertEquals(OrderBook.State.NORMAL, book.getState());\n\t\tassertEquals(DoubleUtils.toLong(0.01), book.getSpread());\n\t\tassertEquals(DoubleUtils.toLong(432.12), book.getBestBidPrice());\n\t\tassertEquals(DoubleUtils.toLong(432.13), book.getBestAskPrice());\n\t\tassertEquals(800, book.getBestBidSize());\n\t\tassertEquals(100, book.getBestAskSize());\n\t}\n\t\n\t@Test", "\tpublic void test_Order_Reduced_Then_Canceled() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder order = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, order.getAcceptTime(), order);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, order.getRestTime(), order, order.getOriginalSize(), order.getPrice());\n\t\t\n\t\tdone(listener);\n\t\t\n\t\torder.reduceTo(book.getTimestamper().nanoEpoch(), 300);\n\t\t\n\t\tcalled(listener, 0).onOrderAccepted(null, 0, null);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 1).onOrderReduced(book, order.getReduceTime(), order, 300);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t\t\n\t\torder.cancel(book.getTimestamper().nanoEpoch());\n\t\t\n\t\tcalled(listener, 0).onOrderAccepted(null, 0, null);\n\t\tcalled(listener, 1).onOrderCanceled(book, order.getCancelTime(), order, CancelReason.USER);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t}\n\t\n\t@Test", "\tpublic void test_Limit_Order_Fills_With_Price_Improvement() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder buyOrder = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, buyOrder.getAcceptTime(), buyOrder);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderExecuted(null, 0, null, null, 0, 0, 0, 0);\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 1).onOrderRested(book, buyOrder.getRestTime(), buyOrder, buyOrder.getOriginalSize(), buyOrder.getPrice());\n\t\t\n\t\tdone(listener);\n\n\t\tOrderExecutedCaptor captor = new OrderExecutedCaptor();\n\t\t\n\t\tOrder sellOrder = book.createLimit(\"2\", 2, Side.SELL, 100, 430.00, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, sellOrder.getAcceptTime(), sellOrder);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 2).onOrderExecuted(captor.book.capture(), captor.time.capture(), captor.order.capture(), captor.executeSide.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeSize.capture(), captor.executePrice.capture(), captor.executeId.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeMatchId.capture());\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(0));\n\t\tassertEquals(buyOrder.getExecuteTime(), captor.time.getAllValues().get(0).longValue());\n\t\tassertEquals(buyOrder, captor.order.getAllValues().get(0));\n\t\tassertEquals(ExecuteSide.MAKER, captor.executeSide.getAllValues().get(0));\n\t\tassertEquals(100, captor.executeSize.getAllValues().get(0).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(0).longValue());\n\t\tassertEquals(1, captor.executeId.getAllValues().get(0).longValue());\n\t\tassertEquals(1, captor.executeMatchId.getAllValues().get(0).longValue());\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(1));\n\t\tassertEquals(sellOrder.getExecuteTime(), captor.time.getAllValues().get(1).longValue());\n\t\tassertEquals(sellOrder, captor.order.getAllValues().get(1));\n\t\tassertEquals(ExecuteSide.TAKER, captor.executeSide.getAllValues().get(1));\n\t\tassertEquals(100, captor.executeSize.getAllValues().get(1).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(1).longValue());\n\t\tassertEquals(2, captor.executeId.getAllValues().get(1).longValue());\n\t\tassertEquals(1, captor.executeMatchId.getAllValues().get(1).longValue());\n\t\t\n\t\tMockito.reset(listener);\n\t\tcaptor = new OrderExecutedCaptor();\n\t\t\n\t\tsellOrder = book.createLimit(\"3\", 3, Side.SELL, 100, 430.00, TimeInForce.DAY);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, sellOrder.getAcceptTime(), sellOrder);\n\t\tcalled(listener, 0).onOrderCanceled(null, 0, null, null);\n\t\tcalled(listener, 2).onOrderExecuted(captor.book.capture(), captor.time.capture(), captor.order.capture(), captor.executeSide.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeSize.capture(), captor.executePrice.capture(), captor.executeId.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeMatchId.capture());\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(0));\n\t\tassertEquals(buyOrder.getExecuteTime(), captor.time.getAllValues().get(0).longValue());\n\t\tassertEquals(buyOrder, captor.order.getAllValues().get(0));\n\t\tassertEquals(ExecuteSide.MAKER, captor.executeSide.getAllValues().get(0));\n\t\tassertEquals(100, captor.executeSize.getAllValues().get(0).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(0).longValue());\n\t\tassertEquals(3, captor.executeId.getAllValues().get(0).longValue());\n\t\tassertEquals(2, captor.executeMatchId.getAllValues().get(0).longValue());\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(1));\n\t\tassertEquals(sellOrder.getExecuteTime(), captor.time.getAllValues().get(1).longValue());\n\t\tassertEquals(sellOrder, captor.order.getAllValues().get(1));\n\t\tassertEquals(ExecuteSide.TAKER, captor.executeSide.getAllValues().get(1));\n\t\tassertEquals(100, captor.executeSize.getAllValues().get(1).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(1).longValue());\n\t\tassertEquals(4, captor.executeId.getAllValues().get(1).longValue());\n\t\tassertEquals(2, captor.executeMatchId.getAllValues().get(1).longValue());\n\t}\n\t\n\t@Test", "\tpublic void test_IoC_Partial_Fill() {\n\t\t\n\t\tOrderBookListener listener = Mockito.mock(OrderBookListener.class);\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", listener);\n\t\t\n\t\tOrder buyOrder = book.createLimit(\"1\", 1, Side.BUY, 800, 432.12, TimeInForce.DAY);\n\t\tbook.createLimit(\"2\", 2, Side.BUY, 400, 432.11, TimeInForce.DAY);\n\t\t\n\t\tMockito.reset(listener);\n\t\tOrderExecutedCaptor captor = new OrderExecutedCaptor();\n\t\t\n\t\tOrder sellOrder = book.createLimit(\"3\", 3, Side.SELL, 1000, 432.12, TimeInForce.IOC);\n\t\t\n\t\tcalled(listener, 1).onOrderAccepted(book, sellOrder.getAcceptTime(), sellOrder);\n\t\tcalled(listener, 1).onOrderCanceled(book, sellOrder.getCancelTime(), sellOrder, CancelReason.MISSED);\n\t\tcalled(listener, 2).onOrderExecuted(captor.book.capture(), captor.time.capture(), captor.order.capture(), captor.executeSide.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeSize.capture(), captor.executePrice.capture(), captor.executeId.capture(), \n\t\t\t\t\t\t\t\t\t\t\tcaptor.executeMatchId.capture());\n\t\tcalled(listener, 0).onOrderReduced(null, 0, null, 0);\n\t\tcalled(listener, 0).onOrderRejected(null, 0, null, null);\n\t\tcalled(listener, 0).onOrderRested(null, 0, null, 0, 0);\n\t\t\n\t\tdone(listener);\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(0));\n\t\tassertEquals(buyOrder.getExecuteTime(), captor.time.getAllValues().get(0).longValue());\n\t\tassertEquals(buyOrder, captor.order.getAllValues().get(0));\n\t\tassertEquals(ExecuteSide.MAKER, captor.executeSide.getAllValues().get(0));\n\t\tassertEquals(800, captor.executeSize.getAllValues().get(0).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(0).longValue());\n\t\tassertEquals(1, captor.executeId.getAllValues().get(0).longValue());\n\t\tassertEquals(1, captor.executeMatchId.getAllValues().get(0).longValue());\n\t\t\n\t\tassertEquals(book, captor.book.getAllValues().get(1));\n\t\tassertEquals(sellOrder.getExecuteTime(), captor.time.getAllValues().get(1).longValue());\n\t\tassertEquals(sellOrder, captor.order.getAllValues().get(1));\n\t\tassertEquals(ExecuteSide.TAKER, captor.executeSide.getAllValues().get(1));\n\t\tassertEquals(800, captor.executeSize.getAllValues().get(1).longValue());\n\t\tassertEquals(DoubleUtils.toLong(432.12), captor.executePrice.getAllValues().get(1).longValue());\n\t\tassertEquals(2, captor.executeId.getAllValues().get(1).longValue());\n\t\tassertEquals(1, captor.executeMatchId.getAllValues().get(1).longValue());\n\t\t\n\t\tassertEquals(true, sellOrder.isTerminal());\n\t\tassertEquals(1, book.getNumberOfOrders());\n\t\tassertEquals(200, sellOrder.getCanceledSize());\n\t\tassertEquals(OrderBook.State.ONESIDED, book.getState());\n\t\tassertEquals(false, book.hasAsks());\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/SystemTimestamperTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport org.junit.Assert;", "\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class SystemTimestamperTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tTimestamper t = new SystemTimestamper();\n\t\t\n\t\tlong start = t.nanoEpoch();\n\t\t", "\t\ttry {\n\t\t\tThread.sleep(5);\n\t\t} catch(InterruptedException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tlong end = t.nanoEpoch();\n\t\t\n\t\tAssert.assertTrue(end > start);\n\t\tAssert.assertTrue(end - start > 1000000L);\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/StringUtilsTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport org.junit.Assert;", "\nimport org.junit.Assert;\nimport org.junit.Test;\n\n\npublic class StringUtilsTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tString s = \"house\";\n\t\t\n\t\tCharSequence cs1 = new StringBuilder(s);\n\t\tCharSequence cs2 = new StringBuilder(s);\n\t\t\n\t\tAssert.assertFalse(cs1.equals(cs2)); // yes, they are not equal, don't ask me why\n\t\tAssert.assertFalse(cs1.equals(s)); // expected... (different types)\n\t\tAssert.assertFalse(s.equals(cs1)); // expected... (different types)\n\t\t\n\t\t// now magic:\n\t\t\n\t\tAssert.assertTrue(StringUtils.equals(cs1, cs2));\n\t\tAssert.assertTrue(StringUtils.equals(cs1, s));\n\t\tAssert.assertTrue(StringUtils.equals(s, cs1));\n\t}\n}", "\tpublic void test1() {\n\t\t\n\t\tString s = \"house\";\n\t\t\n\t\tCharSequence cs1 = new StringBuilder(s);\n\t\tCharSequence cs2 = new StringBuilder(s);\n\t\t\n\t\tAssert.assertFalse(cs1.equals(cs2)); // yes, they are not equal, don't ask me why\n\t\tAssert.assertFalse(cs1.equals(s)); // expected... (different types)\n\t\tAssert.assertFalse(s.equals(cs1)); // expected... (different types)\n\t\t\n\t\t// now magic:\n\t\t\n\t\tAssert.assertTrue(StringUtils.equals(cs1, cs2));\n\t\tAssert.assertTrue(StringUtils.equals(cs1, s));\n\t\tAssert.assertTrue(StringUtils.equals(s, cs1));\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/LongMapTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/*\n * Copied from CharMapTest\n */\npublic class LongMapTest {\n\t\n\t@Test", " */\npublic class LongMapTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tLongMap<String> map = new LongMap<String>();\n\t\t\n\t\tmap.put('c', \"C\");\n\t\t\n\t\tAssert.assertEquals(1, map.size());\n\t\t\n\t\tmap.put('d', \"D\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\t\n\t\tString ret = map.put('d', \"DD\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"D\", ret);\n\t\t\n\t\tmap.put('a', \"A\");\n\t\tAssert.assertEquals(3, map.size());\n\t\t\n\t\tret = map.remove('a');\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"A\", ret);\n\t\t\n\t\tAssert.assertEquals(true, map.containsKey('c'));\n\t\tAssert.assertEquals(false, map.containsKey('a'));\n\t\t\n\t\tmap.clear();\n\t\t\n\t\tAssert.assertEquals(true, map.isEmpty());\n\t}\n\t\n\t@Test", "\tpublic void test2() {\n\t\t\n\t\tLongMap<String> map = new LongMap<String>();\n\t\t\n\t\tmap.put('a', \"A\");\n\t\tmap.put('b', \"B\");\n\t\tmap.put('c', \"C\");\n\t\tmap.put('d', \"D\");\n\t\tmap.put('e', \"E\");\n\t\t\n\t\tmap.remove('c');\n\t\t\n\t\tAssert.assertEquals(4, map.size());\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tIterator<String> iter = map.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tString value = iter.next();\n\t\t\tchar key = (char) map.getCurrIteratorKey();\n\t\t\tAssert.assertEquals(value, String.valueOf(key).toUpperCase());\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tAssert.assertEquals(4, count);\n\t\t\n\t\tcount = 0;\n\t\t\n\t\titer = map.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tString value = iter.next();\n\t\t\tchar key = (char) map.getCurrIteratorKey();\n\t\t\tAssert.assertEquals(value, String.valueOf(key).toUpperCase());\n\t\t\tif (key == 'b' || key == 'd') iter.remove();\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tAssert.assertEquals(4, count);\n\t\tAssert.assertEquals(2, map.size());\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/MathUtilsTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport org.junit.Assert;", "\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class MathUtilsTest {\n\t\n\t@Test\n\tpublic void testSeveral() {\n\t\t\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tlong x = (long) Math.pow(2, i);\n\t\t\tAssert.assertEquals(true, MathUtils.isPowerOfTwo(x));\n\t\t}\n\t}\n\t\n\t@Test", "\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tlong x = (long) Math.pow(2, i);\n\t\t\tAssert.assertEquals(true, MathUtils.isPowerOfTwo(x));\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testFalse() {\n\n\t\tAssert.assertEquals(false, MathUtils.isPowerOfTwo(3));\n\t\tAssert.assertEquals(false, MathUtils.isPowerOfTwo(33));\n\t\t\n\t\tlong x = (long) Math.pow(2, 11);\n\t\tAssert.assertEquals(false, MathUtils.isPowerOfTwo(x + 1));\n\t}\n\t\n\t@Test", "\tpublic void testLargest() {\n\t\tlong x = (long) Math.pow(2, 62);\n\t\tAssert.assertEquals(true, MathUtils.isPowerOfTwo(x));\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/LinkedObjectPoolTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.HashSet;", "\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n\npublic class LinkedObjectPoolTest {\n\t\n\t@Test", "\npublic class LinkedObjectPoolTest {\n\t\n\t@Test\n\tpublic void testSameInstance() {\n\t\t\n\t\tLinkedObjectPool<StringBuilder> pool = new LinkedObjectPool<StringBuilder>(8, StringBuilder.class);\n\t\t\n\t\tAssert.assertEquals(8, pool.size());\n\t\t\n\t\tStringBuilder sb1 = pool.get();\n\t\t\n\t\tAssert.assertEquals(7, pool.size());\n\t\t\n\t\tpool.release(sb1);\n\t\t\n\t\tAssert.assertEquals(8, pool.size());\n\t\t\n\t\tStringBuilder sb2 = pool.get();\n\t\t\n\t\tAssert.assertEquals(7, pool.size());\n\t\t\n\t\tAssert.assertTrue(sb1 == sb2); // has to be same instance\n\t\t\n\t\tStringBuilder sb3 = pool.get();\n\t\tStringBuilder sb4 = pool.get();\n\t\t\n\t\tAssert.assertEquals(5, pool.size());\n\t\t\n\t\tpool.release(sb4);\n\t\tpool.release(sb3);\n\t\t\n\t\tAssert.assertEquals(7, pool.size());\n\t\t\n\t\tStringBuilder sb5 = pool.get();\n\t\tStringBuilder sb6 = pool.get();\n\t\t\n\t\tAssert.assertEquals(5, pool.size());\n\t\t\n\t\t// pool is LIFO (stack)\n\t\tAssert.assertTrue(sb5 == sb3);\n\t\tAssert.assertTrue(sb6 == sb4);\n\t}\n\t\n\t@Test", "\tpublic void testRunOutOfInstances() {\n\t\t\n\t\tLinkedObjectPool<StringBuilder> pool = new LinkedObjectPool<StringBuilder>(2, StringBuilder.class);\n\t\t\n\t\tSet<StringBuilder> set = new HashSet<StringBuilder>(2);\n\t\t\n\t\tAssert.assertEquals(2, pool.size());\n\t\t\n\t\tset.add(pool.get());\n\t\tset.add(pool.get());\n\t\t\n\t\tAssert.assertEquals(0, pool.size());\n\t\t\n\t\tStringBuilder sb = pool.get();\n\t\tAssert.assertNotEquals(null, sb);\n\t\t\n\t\tAssert.assertEquals(false, set.contains(sb));\n\t\t\n\t\tAssert.assertEquals(0, pool.size());\n\t\t\n\t\tpool.release(sb);\n\t\t\n\t\tIterator<StringBuilder> iter = set.iterator();", "\t\twhile(iter.hasNext()) pool.release(iter.next());\n\t\t\n\t\tAssert.assertEquals(3, pool.size()); // pool has grown from initial 2 to 3\n\t\t\n\t\tStringBuilder sb1 = pool.get();\n\t\tStringBuilder sb2 = pool.get();\n\t\t\n\t\tAssert.assertEquals(1, pool.size());\n\t\t\n\t\tAssert.assertEquals(true, set.contains(sb1));\n\t\tAssert.assertEquals(true, set.contains(sb2));\n\t\tAssert.assertEquals(false, set.contains(pool.get()));\n\t\t\n\t\tAssert.assertEquals(0, pool.size());\n\t}\n\t\n\t@Test", "\tpublic void testIncreasingPoolSize() {\n\t\t\n\t\tLinkedObjectPool<StringBuilder> pool = new LinkedObjectPool<StringBuilder>(2, StringBuilder.class);\n\t\t\n\t\tAssert.assertEquals(2, pool.size());\n\t\t\n\t\tfor(int i = 0; i < 2; i++) pool.release(new StringBuilder());\n\t\t\n\t\tAssert.assertEquals(4, pool.size());\n\t\t\n\t\tfor(int i = 0; i < 4; i++) pool.get();\n\t\t\n\t\tAssert.assertEquals(0, pool.size());\n\t}\n\t\n\t@Test", "\t\tfor(int i = 0; i < 4; i++) pool.get();\n\t\t\n\t\tAssert.assertEquals(0, pool.size());\n\t}\n\t\n\t@Test\n\tpublic void testLIFOForGoodCaching() {\n\t\t\n\t\tLinkedObjectPool<StringBuilder> pool = new LinkedObjectPool<StringBuilder>(2, StringBuilder.class);\n\t\t\n\t\tAssert.assertEquals(2, pool.size());\n\t\t\n\t\tStringBuilder sb1 = pool.get();\n\t\tpool.release(sb1);\n\t\t\n\t\tStringBuilder sb2 = pool.get();\n\t\tAssert.assertTrue(sb1 == sb2); \n\t}\n\t\n\t\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/LinkedObjectListTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class LinkedObjectListTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\tpublic void test1() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();\n\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\tAssert.assertEquals(5, iter.next().intValue());", "\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\tAssert.assertEquals(5, iter.next().intValue());\n\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(false, iter.hasNext());\n\t\t\n\t\tAssert.assertEquals(1, list.size());\n\t\titer.remove();\n\t\tAssert.assertEquals(0, list.size());\n\t}\n\t\n\t@Test\n\tpublic void test2() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\tlist.addFirst(4);\n\t\tlist.addLast(6);\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\tpublic void test2() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\tlist.addFirst(4);\n\t\tlist.addLast(6);\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\tfor(int x = 4; x <= 6; x++) {\n\t\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\t\tAssert.assertEquals(x, iter.next().intValue());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(false, iter.hasNext());\n\t\t\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tAssert.assertEquals(6, list.removeLast().intValue());\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(4, list.removeFirst().intValue());\n\t\tAssert.assertEquals(1, list.size());\n\t\t\n\t\titer = list.iterator();", "\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\tAssert.assertEquals(5, iter.next().intValue());\n\t\tAssert.assertEquals(1, list.size());\n\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(false, iter.hasNext());\n\t\titer.remove();\n\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(false, iter.hasNext());\n\t\tAssert.assertEquals(0, list.size());\n\t}\n\t\n\t@Test\n\tpublic void test3() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\tlist.addFirst(4);\n\t\tlist.addLast(6);\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\tpublic void test3() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\tlist.addFirst(4);\n\t\tlist.addLast(6);\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\tfor(int x = 4; x <= 6; x++) {\n\t\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(true, iter.hasNext());\n\t\t\tAssert.assertEquals(x, iter.next().intValue());\n\t\t\tint size = list.size();\n\t\t\tif (x == 4 || x == 6) {\n\t\t\t\titer.remove();\n\t\t\t\tAssert.assertEquals(size - 1, list.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(5, list.first().intValue());\n\t\tAssert.assertEquals(5, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(5, list.removeFirst().intValue());\n\t\tAssert.assertEquals(0, list.size());\n\t\tAssert.assertEquals(null, list.first());\n\t\tAssert.assertEquals(null, list.last());\n\t\tAssert.assertEquals(null, list.removeFirst());\n\t\tAssert.assertEquals(null, list.removeLast());\n\t}\n\t\n\t@Test", "\tpublic void test4() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tlist.addLast(5);\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(5, list.first().intValue());\n\t\tAssert.assertEquals(5, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(5, list.removeFirst().intValue());\n\t\tAssert.assertEquals(0, list.size());\n\t\tAssert.assertEquals(null, list.first());\n\t\tAssert.assertEquals(null, list.last());\n\t\tAssert.assertEquals(null, list.removeFirst());\n\t\tAssert.assertEquals(null, list.removeLast());\n\t\t\n\t\tlist.addFirst(6);\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(6, list.first().intValue());\n\t\tAssert.assertEquals(6, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(6, list.removeLast().intValue());\n\t\tAssert.assertEquals(0, list.size());\n\t\tAssert.assertEquals(null, list.first());\n\t\tAssert.assertEquals(null, list.last());\n\t\tAssert.assertEquals(null, list.removeFirst());\n\t\tAssert.assertEquals(null, list.removeLast());\n\t\t\n\t\tlist.addLast(7);\n\t\tlist.addLast(8);\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(7, list.first().intValue());\n\t\tAssert.assertEquals(8, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(8, list.removeLast().intValue());\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(7, list.first().intValue());\n\t\tAssert.assertEquals(7, list.last().intValue());\n\t\t\n\t\tlist.addFirst(6);\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(6, list.first().intValue());\n\t\tAssert.assertEquals(7, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(6, list.removeFirst().intValue());\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(7, list.first().intValue());\n\t\tAssert.assertEquals(7, list.last().intValue());\n\t\t\n\t\tlist.addLast(8);\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(7, list.first().intValue());\n\t\tAssert.assertEquals(8, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(7, list.removeFirst().intValue());\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(8, list.first().intValue());\n\t\tAssert.assertEquals(8, list.last().intValue());\n\t\t\n\t\tAssert.assertEquals(8, list.removeFirst().intValue());\n\t\tAssert.assertEquals(0, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 2; i++) Assert.assertEquals(false, iter.hasNext());\n\t}\n\t\n\t@Test\n\tpublic void test5() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\n\t\tfor(int i = 0; i < 16; i++) {", "\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t}\n\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\tlist.clear();\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\t", "\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\titer = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t}\n\n\t\tAssert.assertEquals(16, list.size());\n\t}\n\t\n\t@Test", "\tpublic void test6() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(8);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t\titer.remove();\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t\titer.remove();\n\t\t}\n\n\t\tAssert.assertEquals(0, list.size());\n\t\t", "\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\titer = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t}\n\n\t\tAssert.assertEquals(16, list.size());\n\t}\n\t\n\t@Test", "\tpublic void test7() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(0);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t\titer.remove();\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t\titer.remove();\n\t\t}\n\n\t\tAssert.assertEquals(0, list.size());\n\t\t", "\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\tlist.addFirst(i);\n\t\t\t} else {\n\t\t\t\tlist.addLast(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssert.assertEquals(16, list.size());\n\t\t\n\t\titer = list.iterator();", "\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 != 0);\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tAssert.assertTrue(iter.next().intValue() % 2 == 0);\n\t\t}\n\n\t\tAssert.assertEquals(16, list.size());\n\t}\n\t\n\t@Test", "\tpublic void test8() {\n\t\t\n\t\tLinkedObjectList<Integer> list = new LinkedObjectList<Integer>(1);\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t\tAssert.assertEquals(null, list.first());\n\t\tAssert.assertEquals(null, list.last());\n\t\tAssert.assertEquals(null, list.removeFirst());\n\t\tAssert.assertEquals(null, list.removeLast());\n\t\t\n\t\tlist.addLast(4);\n\t\tlist.addLast(5);\n\t\tlist.addLast(6);\n\t\t\n\t\tAssert.assertEquals(3, list.size());\n\t\t\n\t\tIterator<Integer> iter = list.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tif (iter.next().intValue() == 5) iter.remove();\n\t\t}\n\t\t\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(4, list.first().intValue());\n\t\tAssert.assertEquals(6, list.last().intValue());\n\t\t\n\t\tlist.addFirst(3);\n\t\t\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(3, list.first().intValue());\n\t\tAssert.assertEquals(6, list.last().intValue());\n\t\t\n\t\titer = list.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tif (iter.next().intValue() == 6) iter.remove();\n\t\t}\n\t\t\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(3, list.first().intValue());\n\t\tAssert.assertEquals(4, list.last().intValue());\n\t\t\n\t\tlist.addLast(5);\n\t\t\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(3, list.first().intValue());\n\t\tAssert.assertEquals(5, list.last().intValue());\n\t\t\n\t\titer = list.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tif (iter.next().intValue() == 3) iter.remove();\n\t\t}\n\t\t\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(4, list.first().intValue());\n\t\tAssert.assertEquals(5, list.last().intValue());\n\t\t\n\t\twhile(list.size() > 0) {\n\t\t\tlist.removeFirst();\n\t\t}\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t}\n}", "\t\twhile(list.size() > 0) {\n\t\t\tlist.removeFirst();\n\t\t}\n\t\t\n\t\tAssert.assertEquals(0, list.size());\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/CharMapTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class CharMapTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tCharMap<String> map = new CharMap<String>();\n\t\t\n\t\tmap.put('c', \"C\");\n\t\t\n\t\tAssert.assertEquals(1, map.size());\n\t\t\n\t\tmap.put('d', \"D\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\t\n\t\tString ret = map.put('d', \"DD\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"D\", ret);\n\t\t\n\t\tmap.put('a', \"A\");\n\t\tAssert.assertEquals(3, map.size());\n\t\t\n\t\tret = map.remove('a');\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"A\", ret);\n\t\t\n\t\tAssert.assertEquals(true, map.containsKey('c'));\n\t\tAssert.assertEquals(false, map.containsKey('a'));\n\t\t\n\t\tmap.clear();\n\t\t\n\t\tAssert.assertEquals(true, map.isEmpty());\n\t}\n\t\n\t@Test", "\tpublic void test1() {\n\t\t\n\t\tCharMap<String> map = new CharMap<String>();\n\t\t\n\t\tmap.put('c', \"C\");\n\t\t\n\t\tAssert.assertEquals(1, map.size());\n\t\t\n\t\tmap.put('d', \"D\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\t\n\t\tString ret = map.put('d', \"DD\");\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"D\", ret);\n\t\t\n\t\tmap.put('a', \"A\");\n\t\tAssert.assertEquals(3, map.size());\n\t\t\n\t\tret = map.remove('a');\n\t\t\n\t\tAssert.assertEquals(2, map.size());\n\t\tAssert.assertEquals(\"A\", ret);\n\t\t\n\t\tAssert.assertEquals(true, map.containsKey('c'));\n\t\tAssert.assertEquals(false, map.containsKey('a'));\n\t\t\n\t\tmap.clear();\n\t\t\n\t\tAssert.assertEquals(true, map.isEmpty());\n\t}\n\t\n\t@Test", "\tpublic void test2() {\n\t\t\n\t\tCharMap<String> map = new CharMap<String>();\n\t\t\n\t\tmap.put('a', \"A\");\n\t\tmap.put('b', \"B\");\n\t\tmap.put('c', \"C\");\n\t\tmap.put('d', \"D\");\n\t\tmap.put('e', \"E\");\n\t\t\n\t\tmap.remove('c');\n\t\t\n\t\tAssert.assertEquals(4, map.size());\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tIterator<String> iter = map.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tString value = iter.next();\n\t\t\tchar key = map.getCurrIteratorKey();\n\t\t\tAssert.assertEquals(value, String.valueOf(key).toUpperCase());\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tAssert.assertEquals(4, count);\n\t\t\n\t\tcount = 0;\n\t\t\n\t\titer = map.iterator();", "\t\twhile(iter.hasNext()) {\n\t\t\tString value = iter.next();\n\t\t\tchar key = map.getCurrIteratorKey();\n\t\t\tAssert.assertEquals(value, String.valueOf(key).toUpperCase());\n\t\t\tif (key == 'b' || key == 'd') iter.remove();\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tAssert.assertEquals(4, count);\n\t\tAssert.assertEquals(2, map.size());\n\t}\n}"]}
{"filename": "src/test/java/com/coralblocks/coralme/util/DoubleUtilsTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport org.junit.Assert;", "\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class DoubleUtilsTest {\n\t\n\t@Test\n\tpublic void test1() {\n\t\t\n\t\tdouble d1 = 3.13222;\n\t\tlong l1 = DoubleUtils.toLong(d1);\n\t\t\n\t\tdouble d2 = DoubleUtils.toDouble(l1);\n\t\t\n\t\tAssert.assertTrue(d1 == d2);\n\t}\n\t\n\t@Test", "\tpublic void test2() {\n\t\t\n\t\tlong l1 = 123123123;\n\t\tdouble d1 = DoubleUtils.toDouble(l1);\n\t\t\n\t\tlong l2 = DoubleUtils.toLong(d1);\n\t\t\n\t\tAssert.assertTrue(l1 == l2);\n\t}\n}"]}
{"filename": "src/main/java/com/coralblocks/coralme/PriceLevel.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport com.coralblocks.coralme.Order.CancelReason;", "\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\nimport com.coralblocks.coralme.Order.Side;\n\npublic class PriceLevel implements OrderListener {\n    \n    private long price;\n    \n    private Side side;\n    \n    private String security;\n    \n    private long size;\n    \n    private boolean sizeDirty;\n    \n    private int orders;\n    \n    private Order head = null;\n    \n    private Order tail = null;\n    \n    PriceLevel next = null;\n    \n    PriceLevel prev = null;\n    \n    public PriceLevel() {\n    \t\n    }\n    \n    PriceLevel(String security, Side side, long price) {\n    \t\n    \tinit(security, side, price);\n    }\n    ", "    public void init(String security, Side side, long price) {\n    \t\n    \tthis.security = security;\n    \t\n    \tthis.price = price;\n    \t\n    \tthis.side = side;\n    \t\n    \tthis.size = 0;\n    \t\n    \tthis.sizeDirty = false;\n    \t\n    \tthis.orders = 0;\n    \t\n    \tthis.head = this.tail = null;\n    }\n    ", "    public final long getPrice() {\n    \t\n    \treturn price;\n    }\n\n    public final Side getSide() {\n    \t\n    \treturn side;\n    }\n    \n    public final String getSecurity() {\n    \t\n    \treturn security;\n    }\n    ", "    public final String getSecurity() {\n    \t\n    \treturn security;\n    }\n    \n    public final int getOrders() {\n    \t\n    \treturn orders;\n    }\n    \n    public final boolean isEmpty() {\n    \t\n    \treturn orders == 0;\n    }\n    ", "    public final boolean isEmpty() {\n    \t\n    \treturn orders == 0;\n    }\n    \n    public final Order head() {\n    \t\n    \treturn head;\n    }\n    \n    public final Order tail() {\n    \t\n    \treturn tail;\n    }\n    ", "    public final Order tail() {\n    \t\n    \treturn tail;\n    }\n    \n    public void addOrder(Order order) {\n        \n        if (head == null) {\n            \n            head = tail = order;\n            \n            order.prev = order.next = null;\n            \n        } else {\n            \n            tail.next = order;\n            \n            order.prev = tail;\n            \n            tail = order;\n            \n            order.next = null;\n        }\n        \n        size += order.getOpenSize();\n        \n        orders++;\n        \n        sizeDirty = true;\n        \n        order.addListener(this);\n    }\n    ", "    public void removeOrder(Order order) {\n        \n        if (order.prev != null) {\n            \n            order.prev.next = order.next;\n        }\n        \n        if (order.next != null) {\n            \n            order.next.prev = order.prev;\n        }\n        ", "        if (tail == order) {\n            \n            tail = order.prev;\n        }\n        \n        if (head == order) {\n            \n            head = order.next;\n        }\n\n        orders--;\n        \n        sizeDirty = true;\n    }\n    ", "    public final long getSize() {\n        \n        if (sizeDirty) {\n            \n            size = 0;\n            \n            for(Order o = head; o != null; o = o.next) {\n                \n                size += o.getOpenSize();\n            }\n        }\n        \n        return size;\n    }\n\n    @Override", "    public void onOrderReduced(long time, Order order, long newTotaSize) {\n\n        sizeDirty = true;\n    }\n\n    @Override\n    public void onOrderCanceled(long time, Order order, CancelReason reason) {\n\n        sizeDirty = true;\n        \n        removeOrder(order);\n    }\n\n    @Override", "    public void onOrderExecuted(long time, Order order, ExecuteSide execSide, long sizeExecuted, long priceExecuted, long executionId, long matchId) {\n\n        sizeDirty = true;\n        \n        if (order.isTerminal()) {\n        \t\n        \tremoveOrder(order);\n        }\n    }\n    \n\t@Override", "\tpublic void onOrderAccepted(long time, Order order) {\n\t\t\n\t\t// NOOP\n\t}\n\n\t@Override\n    public void onOrderRejected(long time, Order order, RejectReason reason) {\n\t\t\n\t\t// NOOP\n    }\n\n\t@Override", "    public void onOrderRested(long time, Order order, long restSize, long restPrice) {\n\n\t\t// NOOP\n    }\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/OrderBookListener.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport com.coralblocks.coralme.Order.CancelReason;", "\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\n\npublic interface OrderBookListener {\n    \n    public void onOrderReduced(OrderBook orderBook, long time, Order order, long reduceNewTotalSize);\n    \n    public void onOrderCanceled(OrderBook orderBook, long time, Order order, CancelReason cancelReason);\n    ", "    public void onOrderCanceled(OrderBook orderBook, long time, Order order, CancelReason cancelReason);\n    \n    public void onOrderExecuted(OrderBook orderBook, long time, Order order, ExecuteSide executeSide, long executeSize, long executePrice, long executeId, long executeMatchId);\n    \n    public void onOrderAccepted(OrderBook orderBook, long time, Order order);\n    \n    public void onOrderRejected(OrderBook orderBook, long time, Order order, RejectReason rejectReason);\n    \n    public void onOrderRested(OrderBook orderBook, long time, Order order, long restSize, long restPrice);\n    \n}\n", "    public void onOrderRested(OrderBook orderBook, long time, Order order, long restSize, long restPrice);\n    \n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/Order.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.coralblocks.coralme.util.CharEnum;\nimport com.coralblocks.coralme.util.CharMap;\nimport com.coralblocks.coralme.util.DoubleUtils;\nimport com.coralblocks.coralme.util.StringUtils;\n\npublic class Order {\n\n\tfinal static String EMPTY_CLIENT_ORDER_ID = \"NULL\";\n\t", "\npublic class Order {\n\n\tfinal static String EMPTY_CLIENT_ORDER_ID = \"NULL\";\n\t\n\tpublic final static int CLIENT_ORDER_ID_MAX_LENGTH = 64;\n\t\n    private final List<OrderListener> listeners = new ArrayList<OrderListener>(64);\n    \n    private Side side;\n    \n    private long originalSize;\n    \n    private long totalSize;\n    \n    private long executedSize;\n    \n    private PriceLevel priceLevel;\n    \n    private final StringBuilder clientOrderId = new StringBuilder(CLIENT_ORDER_ID_MAX_LENGTH);\n    \n    private long price;\n    \n    private long acceptTime;\n    \n    private long restTime;\n    \n    private long cancelTime;\n    \n    private long rejectTime;\n    \n    private long reduceTime;\n    \n    private long executeTime;\n    \n    private long id;\n    \n    private String security;\n    \n    private TimeInForce tif;\n    \n    private Type type;\n    \n    Order next = null;\n    \n    Order prev = null;\n    \n    private boolean isResting;\n    \n    private boolean isPendingCancel;\n    \n    private long pendingSize;\n    \n    public Order() {\n    \t\n    }\n    ", "\tpublic void init(CharSequence clientOrderId, long exchangeOrderId, String security, Side side, long size, long price, Type type, TimeInForce tif) {\n    \t\n    \tthis.clientOrderId.setLength(0);\n    \tthis.clientOrderId.append(clientOrderId);\n    \t\n    \tthis.side = side;\n    \t\n    \tthis.type = type;\n    \t\n    \tthis.originalSize = this.totalSize = size;\n    \t\n    \tthis.price = price;\n    \t\n    \tthis.executedSize = 0;\n    \t\n    \tthis.security = security;\n    \t\n    \tthis.id = exchangeOrderId;\n    \t\n    \tthis.acceptTime = -1;\n    \t\n    \tthis.restTime = -1;\n    \t\n    \tthis.reduceTime = -1;\n    \t\n    \tthis.executeTime = -1;\n    \t\n    \tthis.cancelTime = -1;\n    \t\n    \tthis.rejectTime = -1;\n    \t\n    \tthis.priceLevel = null;\n    \t\n    \tthis.tif = tif;\n    \t\n    \tthis.isResting = false;\n    \t\n    \tthis.isPendingCancel = false;\n    \t\n    \tthis.pendingSize = -1;\n    }\n\t", "\tpublic final void setPendingCancel() {\n\t\tthis.isPendingCancel = true;\n\t}\n\t\n\tpublic final void setPendingSize(long size) {\n\t\tthis.pendingSize = size;\n\t}\n\t\n\tpublic final long getPendingSize() {\n\t\treturn pendingSize;\n\t}\n\t", "\tpublic final long getPendingSize() {\n\t\treturn pendingSize;\n\t}\n\t\n\tpublic final boolean isPendingCancel() {\n\t\treturn isPendingCancel;\n\t}\n\t\n\tpublic final boolean isResting() {\n\t\t\n\t\treturn isResting;\n\t}\n\t", "\tpublic final boolean isResting() {\n\t\t\n\t\treturn isResting;\n\t}\n\t\n\tpublic final double getPriceAsDouble() {\n\t\t\n\t\treturn DoubleUtils.toDouble(price);\n\t}\n\t\n    public final void setPriceLevel(PriceLevel priceLevel) {\n    \t\n    \tthis.priceLevel = priceLevel;\n    }\n    ", "    public final void setPriceLevel(PriceLevel priceLevel) {\n    \t\n    \tthis.priceLevel = priceLevel;\n    }\n    \n    public final PriceLevel getPriceLevel() {\n    \t\n    \treturn priceLevel;\n    }\n    \n    public final Type getType() {\n    \t\n    \treturn type;\n    }\n    ", "    public final Type getType() {\n    \t\n    \treturn type;\n    }\n    \n    public final boolean isLimit() {\n    \t\n    \treturn type == Type.LIMIT;\n    }\n    \n    public final boolean isMarket() {\n    \t\n    \treturn type == Type.MARKET;\n    }\n    ", "    public final boolean isMarket() {\n    \t\n    \treturn type == Type.MARKET;\n    }\n    \n    public final long getOriginalSize() {\n    \t\n    \treturn originalSize;\n    }\n    \n    public final long getExecutedSize() {\n    \t\n    \treturn executedSize;\n    }\n    ", "    public final long getExecutedSize() {\n    \t\n    \treturn executedSize;\n    }\n    \n    public final long getFilledSize() {\n    \t\n    \treturn executedSize;\n    }\n    \n    public final long getOpenSize() {\n    \t\n    \treturn totalSize - executedSize;\n    }\n    ", "    public final long getOpenSize() {\n    \t\n    \treturn totalSize - executedSize;\n    }\n    \n    public final long getTotalSize() {\n    \t\n    \treturn totalSize;\n    }\n    \n    public final long getAcceptTime() {\n    \t\n    \treturn acceptTime;\n    }\n    ", "    public final long getAcceptTime() {\n    \t\n    \treturn acceptTime;\n    }\n    \n    public final long getRestTime() {\n    \t\n    \treturn restTime;\n    }\n    \n    public final long getReduceTime() {\n    \t\n    \treturn reduceTime;\n    }\n    ", "    public final long getReduceTime() {\n    \t\n    \treturn reduceTime;\n    }\n    \n    public final long getExecuteTime() {\n    \t\n    \treturn executeTime;\n    }\n    \n    public final long getCancelTime() {\n    \t\n    \treturn cancelTime;\n    }\n    ", "    public final long getCancelTime() {\n    \t\n    \treturn cancelTime;\n    }\n    \n    public final long getRejectTime() {\n    \t\n    \treturn rejectTime;\n    }\n    \n    public final long getCanceledSize() {\n    \t\n    \t// originalSize = openSize + canceledSize + executedSize\n    \treturn originalSize - getOpenSize() - executedSize;\n    }\n    ", "    public final long getCanceledSize() {\n    \t\n    \t// originalSize = openSize + canceledSize + executedSize\n    \treturn originalSize - getOpenSize() - executedSize;\n    }\n    \n    public final boolean isTerminal() {\n    \t\n    \treturn getOpenSize() == 0;\n    }\n    ", "    public final TimeInForce getTimeInForce() {\n    \t\n    \treturn tif;\n    }\n    \n    public final boolean isAccepted() {\n    \t\n    \treturn id > 0;\n    }\n    \n    public final boolean isIoC() {\n    \t\n    \treturn tif == TimeInForce.IOC;\n    }\n    ", "    public final boolean isIoC() {\n    \t\n    \treturn tif == TimeInForce.IOC;\n    }\n    \n    public final boolean isDay() {\n    \t\n    \treturn tif == TimeInForce.DAY;\n    }\n    \n    public final boolean isGTC() {\n    \t\n    \treturn tif == TimeInForce.GTC;\n    }\n    ", "    public final boolean isGTC() {\n    \t\n    \treturn tif == TimeInForce.GTC;\n    }\n    \n    public final long getPrice() {\n    \t\n    \treturn price;\n    }\n    \n    public final Side getSide() {\n    \t\n    \treturn side;\n    }\n    ", "    public final Side getSide() {\n    \t\n    \treturn side;\n    }\n    \n    public final Side getOtherSide() {\n    \t\n    \treturn side == Side.BUY ? Side.SELL : Side.BUY;\n    }\n    \n    public final long getId() {\n    \t\n    \treturn id;\n    }\n    ", "    public final long getId() {\n    \t\n    \treturn id;\n    }\n    \n    public final long getExchangeOrderId() {\n    \t\n    \treturn id;\n    }\n    \n    public final CharSequence getClientOrderId() {\n    \t\n    \treturn clientOrderId;\n    }\n    ", "    public final CharSequence getClientOrderId() {\n    \t\n    \treturn clientOrderId;\n    }\n    \n    public final String getSecurity() {\n    \t\n    \treturn security;\n    }\n    \n    public final TimeInForce getTif() {\n    \t\n    \treturn tif;\n    }\n    ", "    public final TimeInForce getTif() {\n    \t\n    \treturn tif;\n    }\n    \n    public void addListener(OrderListener listener) {\n    \t\n    \t/*\n    \t * It is very important that the OrderListener from OrderBook be executed LAST, in other words, it \n    \t * should be executed AFTER the OrderListener from PriceLevel, so the level can be removed if empty.\n    \t * \n    \t * That's why the listeners will be called from last to first.\n    \t */\n    \t\n        listeners.add(listener);\n    }\n    ", "    public void accept(long time, long id) {\n    \t\n    \tthis.id = id;\n    \t\n    \tthis.acceptTime = time;\n        \n        int x = listeners.size();\n        \n        for(int i = x - 1; i >= 0; i--) {\n        \t\n        \tlisteners.get(i).onOrderAccepted(time, this);\n        }\n    }\n    ", "        for(int i = x - 1; i >= 0; i--) {\n        \t\n        \tlisteners.get(i).onOrderAccepted(time, this);\n        }\n    }\n    \n    public void rest(long time) {\n    \t\n    \tthis.isResting = true;\n    \t\n    \tthis.restTime = time;\n        \n        int x = listeners.size();\n        ", "        for(int i = x - 1; i >= 0; i--) {\n        \t\n        \tlisteners.get(i).onOrderRested(time, this, getOpenSize(), getPrice());\n        }\n    }\n    \n    public void reject(long time, RejectReason reason) {\n    \t\n    \tthis.totalSize = this.executedSize = 0;\n    \t\n    \tthis.rejectTime = time;\n    \t\n        int x = listeners.size();\n        ", "        for(int i = x - 1; i >= 0; i--) {\n        \t\n        \tlisteners.get(i).onOrderRejected(time, this, reason);\n        }\n        \n        listeners.clear();\n    }\n    \n    public void reduceTo(long time, long newTotalSize) {\n    \t\n    \tif (newTotalSize <= executedSize) {\n    \t\t\n    \t\tcancel(time, CancelReason.USER);\n    \t\t\n    \t\treturn;\n    \t}\n    \t", "    public void reduceTo(long time, long newTotalSize) {\n    \t\n    \tif (newTotalSize <= executedSize) {\n    \t\t\n    \t\tcancel(time, CancelReason.USER);\n    \t\t\n    \t\treturn;\n    \t}\n    \t\n    \tif (newTotalSize > totalSize) {\n    \t\t\n    \t\tnewTotalSize = totalSize;\n    \t}\n    \t\n    \tthis.totalSize = newTotalSize;\n    \t\n    \tthis.reduceTime = time;\n    \t\n    \tint x = listeners.size();\n    \t", "    \tif (newTotalSize > totalSize) {\n    \t\t\n    \t\tnewTotalSize = totalSize;\n    \t}\n    \t\n    \tthis.totalSize = newTotalSize;\n    \t\n    \tthis.reduceTime = time;\n    \t\n    \tint x = listeners.size();\n    \t", "    \tfor(int i = x - 1; i >= 0; i--) {\n    \t\t\n    \t\tlisteners.get(i).onOrderReduced(time, this, this.totalSize);\n    \t}\n    }\n    \n    public void cancel(long time, long sizeToCancel) {\n    \t\n    \tcancel(time, sizeToCancel, CancelReason.USER);\n    }\n    ", "    public void cancel(long time, long sizeToCancel, CancelReason reason) {\n    \t\n    \tif (sizeToCancel >= getOpenSize()) {\n    \t\t\n    \t\tcancel(time, reason);\n    \t\t\n    \t\treturn;\n    \t}\n    \t\n    \tlong newSize = getOpenSize() - sizeToCancel + executedSize;\n    \t\n    \tthis.totalSize = newSize;\n    \t\n    \tthis.reduceTime = time;\n    \t\n    \tint x = listeners.size();\n    \t", "    \tfor(int i = x - 1; i >= 0; i--) {\n    \t\t\n    \t\tlisteners.get(i).onOrderReduced(time, this, newSize);\n    \t}\n    }\n    \n    public void cancel(long time) {\n    \t\n    \tcancel(time, CancelReason.USER);\n    }\n    ", "    public void cancel(long time, CancelReason reason) {\n    \t\n    \tthis.totalSize = this.executedSize;\n    \t\n    \tthis.cancelTime = time;\n    \t\n    \tint x = listeners.size();\n    \t\n    \tfor(int i = x - 1; i >= 0; i--) {\n    \t\t\n    \t\tlisteners.get(i).onOrderCanceled(time, this, reason);\n    \t}\n    \t\n    \tlisteners.clear();\n    }\n    ", "    \tfor(int i = x - 1; i >= 0; i--) {\n    \t\t\n    \t\tlisteners.get(i).onOrderCanceled(time, this, reason);\n    \t}\n    \t\n    \tlisteners.clear();\n    }\n    \n    public void execute(long time, long sizeToExecute) {\n    \t\n    \texecute(time, ExecuteSide.TAKER, sizeToExecute, this.price, -1, -1);\n    }\n    ", "    public void execute(long time, long sizeToExecute) {\n    \t\n    \texecute(time, ExecuteSide.TAKER, sizeToExecute, this.price, -1, -1);\n    }\n    \n    public void execute(long time, ExecuteSide execSide, long sizeToExecute, long priceExecuted, long executionId, long matchId) {\n    \t\n    \tif (sizeToExecute > getOpenSize()) {\n    \t\t\n    \t\tsizeToExecute = getOpenSize();\n    \t}\n    \t\n    \tthis.executedSize += sizeToExecute;\n    \t\n    \tthis.executeTime = time;\n    \t\n    \tint x = listeners.size();\n    \t", "    \tfor(int i = x - 1; i >= 0; i--) {\n    \t\t\n    \t\tlisteners.get(i).onOrderExecuted(time, this, execSide, sizeToExecute, priceExecuted, executionId, matchId);\n    \t}\n    \t\n    \tif (isTerminal()) {\n    \t\t\n    \t\tlisteners.clear();\n    \t}\n    }\n    ", "\tpublic static enum TimeInForce implements CharEnum { \n\n\t\tGTC \t\t\t('T', \"1\"), \n\t\tIOC\t\t\t\t('I', \"3\"),\n\t\tDAY\t\t\t\t('D', \"0\");\n\n\t\tprivate final char b;\n\t\tprivate final String fixCode;\n\t\tpublic final static CharMap<TimeInForce> ALL = new CharMap<TimeInForce>();\n\t\t\n\t\tstatic {", "\t\tpublic final static CharMap<TimeInForce> ALL = new CharMap<TimeInForce>();\n\t\t\n\t\tstatic {\n\t\t\tfor(TimeInForce tif : TimeInForce.values()) {\n\t\t\t\tif (ALL.put(tif.getChar(), tif) != null) throw new IllegalStateException(\"Duplicate: \" + tif);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate TimeInForce(char b, String fixCode) {\n\t\t\tthis.b = b;\n\t\t\tthis.fixCode = fixCode;\n\t\t}\n\t\t", "\t\tpublic static final TimeInForce fromFixCode(CharSequence sb) {\n\t\t\tfor(TimeInForce s : TimeInForce.values()) {\n\t\t\t\tif (StringUtils.equals(s.getFixCode(), sb)) {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n    \t@Override\n        public final char getChar() {\n    \t    return b;\n        }\n    \t", "        public final char getChar() {\n    \t    return b;\n        }\n    \t\n    \tpublic final String getFixCode() {\n    \t\treturn fixCode;\n    \t}\n\t}\n\t\n\tpublic static enum RejectReason implements CharEnum { \n\n\t\tMISSING_FIELD\t\t('1'),\n\t\tBAD_TYPE\t\t\t('2'),\n\t\tBAD_TIF\t\t\t\t('3'),\n\t\tBAD_SIDE\t\t\t('4'),\n\t\tBAD_SYMBOL\t\t\t('5'),\n\t\t\n\t\tBAD_PRICE \t\t\t('P'), \n\t\tBAD_SIZE\t\t\t('S'),\n\t\tTRADING_HALTED\t\t('H'),\n\t\tBAD_LOT\t\t\t\t('L'),\n\t\tUNKNOWN_SYMBOL\t\t('U'),\n\t\tDUPLICATE_ORDER_ID\t('D');\n\n\t\tprivate final char b;", "\tpublic static enum RejectReason implements CharEnum { \n\n\t\tMISSING_FIELD\t\t('1'),\n\t\tBAD_TYPE\t\t\t('2'),\n\t\tBAD_TIF\t\t\t\t('3'),\n\t\tBAD_SIDE\t\t\t('4'),\n\t\tBAD_SYMBOL\t\t\t('5'),\n\t\t\n\t\tBAD_PRICE \t\t\t('P'), \n\t\tBAD_SIZE\t\t\t('S'),\n\t\tTRADING_HALTED\t\t('H'),\n\t\tBAD_LOT\t\t\t\t('L'),\n\t\tUNKNOWN_SYMBOL\t\t('U'),\n\t\tDUPLICATE_ORDER_ID\t('D');\n\n\t\tprivate final char b;", "\t\tpublic final static CharMap<RejectReason> ALL = new CharMap<RejectReason>();\n\t\t\n\t\tstatic {\n\t\t\tfor(RejectReason rr : RejectReason.values()) {\n\t\t\t\tif (ALL.put(rr.getChar(), rr) != null) throw new IllegalStateException(\"Duplicate: \" + rr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate RejectReason(char b) {\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n    \t@Override", "        public final char getChar() {\n    \t    return b;\n        }\n\t}\n\n\tpublic static enum CancelRejectReason implements CharEnum {\n\t\t\n\t\tNOT_FOUND\t\t('F');\n\t\t\n\t\tprivate final char b;\n\t\tpublic final static CharMap<CancelRejectReason> ALL = new CharMap<CancelRejectReason>();\n\t\t\n\t\tstatic {", "\t\tpublic final static CharMap<CancelRejectReason> ALL = new CharMap<CancelRejectReason>();\n\t\t\n\t\tstatic {\n\t\t\tfor(CancelRejectReason crr : CancelRejectReason.values()) {\n\t\t\t\tif (ALL.put(crr.getChar(), crr) != null) throw new IllegalStateException(\"Duplicate: \" + crr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate CancelRejectReason(char b) {\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n    \t@Override", "        public final char getChar() {\n    \t    return b;\n        }\n\t}\n\t\n\tpublic static enum CancelReason implements CharEnum { \n\n\t\tMISSED \t\t\t('M'), \n\t\tUSER\t\t\t('U'),\n\t\tNO_LIQUIDITY\t('L'),\n\t\tPRICE\t\t\t('E'),\n\t\tPURGED\t\t\t('P');\n\n\t\tprivate final char b;", "\t\tpublic final static CharMap<CancelReason> ALL = new CharMap<CancelReason>();\n\t\t\n\t\tstatic {\n\t\t\tfor(CancelReason cr : CancelReason.values()) {\n\t\t\t\tif (ALL.put(cr.getChar(), cr) != null) throw new IllegalStateException(\"Duplicate: \" + cr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate CancelReason(char b) {\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n    \t@Override", "        public final char getChar() {\n    \t    return b;\n        }\n\t}\n\t\n\tpublic static enum ReduceRejectReason implements CharEnum { \n\n\t\tZERO \t\t\t('Z'), \n\t\tNEGATIVE\t\t('N'),\n\t\tINCREASE\t\t('I'),\n\t\tSUPERFLUOUS\t\t('S'),\n\t\tNOT_FOUND\t\t('F');\n\n\t\tprivate final char b;", "\t\tpublic final static CharMap<ReduceRejectReason> ALL = new CharMap<ReduceRejectReason>();\n\t\t\n\t\tstatic {\n\t\t\tfor(ReduceRejectReason rrr : ReduceRejectReason.values()) {\n\t\t\t\tif (ALL.put(rrr.getChar(), rrr) != null) throw new IllegalStateException(\"Duplicate: \" + rrr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate ReduceRejectReason(char b) {\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n    \t@Override", "        public final char getChar() {\n    \t    return b;\n        }\n\t}\n\t\n\tpublic static enum Type implements CharEnum { \n\n\t\tMARKET \t\t\t('M', \"1\"), \n\t\tLIMIT\t\t\t('L', \"2\");\n\n\t\tprivate final char b;\n\t\tprivate final String fixCode;", "\t\tpublic final static CharMap<Type> ALL = new CharMap<Type>();\n\t\t\n\t\tstatic {\n\t\t\tfor(Type t : Type.values()) {\n\t\t\t\tif (ALL.put(t.getChar(), t) != null) throw new IllegalStateException(\"Duplicate: \" + t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate Type(char b, String fixCode) {\n\t\t\tthis.b = b;\n\t\t\tthis.fixCode = fixCode;\n\t\t}\n\t\t", "\t\tpublic static final Type fromFixCode(CharSequence sb) {\n\t\t\tfor(Type s : Type.values()) {\n\t\t\t\tif (StringUtils.equals(s.getFixCode(), sb)) {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n    \t@Override\n        public final char getChar() {\n    \t    return b;\n        }\n    \t", "        public final char getChar() {\n    \t    return b;\n        }\n    \t\n    \tpublic final String getFixCode() {\n    \t\treturn fixCode;\n    \t}\n\t}\n\t\n\tpublic static enum ExecuteSide implements CharEnum {\n\t\t\n\t\tTAKER\t\t\t('T', \"Y\"),\n\t\tMAKER\t\t\t('M', \"N\");\n\t\t\n\t\tprivate final char b;\n\t\tprivate final String fixCode;", "\tpublic static enum ExecuteSide implements CharEnum {\n\t\t\n\t\tTAKER\t\t\t('T', \"Y\"),\n\t\tMAKER\t\t\t('M', \"N\");\n\t\t\n\t\tprivate final char b;\n\t\tprivate final String fixCode;\n\t\tpublic final static CharMap<ExecuteSide> ALL = new CharMap<ExecuteSide>();\n\t\t\n\t\tstatic {\n\t\t\tfor(ExecuteSide es : ExecuteSide.values()) {", "\t\t\tfor(ExecuteSide es : ExecuteSide.values()) {\n\t\t\t\tif (ALL.put(es.getChar(), es) != null) throw new IllegalStateException(\"Duplicate: \" + es);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate ExecuteSide(char b, String fixCode) {\n\t\t\tthis.b = b;\n\t\t\tthis.fixCode = fixCode;\n\t\t}\n\t\t\n\t\tpublic static final ExecuteSide fromFixCode(CharSequence sb) {", "\t\tpublic static final ExecuteSide fromFixCode(CharSequence sb) {\n\t\t\tfor(ExecuteSide s : ExecuteSide.values()) {\n\t\t\t\tif (StringUtils.equals(s.getFixCode(), sb)) {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n    \t@Override\n        public final char getChar() {\n    \t    return b;\n        }\n    \t", "        public final char getChar() {\n    \t    return b;\n        }\n    \t\n    \tpublic final String getFixCode() {\n    \t\treturn fixCode;\n    \t}\n\t}\n\t\n\tpublic static enum Side implements CharEnum { \n\n\t\tBUY \t\t\t('B', \"1\", 0), \n\t\tSELL\t\t\t('S', \"2\", 1);\n\n\t\tprivate final char b;\n\t\tprivate final String fixCode;\n\t\tprivate final int index;", "\tpublic static enum Side implements CharEnum { \n\n\t\tBUY \t\t\t('B', \"1\", 0), \n\t\tSELL\t\t\t('S', \"2\", 1);\n\n\t\tprivate final char b;\n\t\tprivate final String fixCode;\n\t\tprivate final int index;\n\t\tpublic final static CharMap<Side> ALL = new CharMap<Side>();\n\t\t\n\t\tstatic {\n\t\t\t", "\t\tpublic final static CharMap<Side> ALL = new CharMap<Side>();\n\t\t\n\t\tstatic {\n\t\t\t\n\t\t\tfor(Side s : Side.values()) {\n\t\t\t\tif (ALL.put(s.getChar(), s) != null) throw new IllegalStateException(\"Duplicate: \" + s);\n\t\t\t}\n\t\t\t\n\t\t\tif (ALL.size() != 2) {\n\t\t\t\tthrow new IllegalStateException(\"Side must have only two values: BUY and SELL!\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate Side(char b, String fixCode, int index) {\n\t\t\tthis.b = b;\n\t\t\tthis.fixCode = fixCode;\n\t\t\tthis.index = index;\n\t\t}\n\t\t", "\t\t\tif (ALL.size() != 2) {\n\t\t\t\tthrow new IllegalStateException(\"Side must have only two values: BUY and SELL!\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate Side(char b, String fixCode, int index) {\n\t\t\tthis.b = b;\n\t\t\tthis.fixCode = fixCode;\n\t\t\tthis.index = index;\n\t\t}\n\t\t", "\t\tpublic static final Side fromFixCode(CharSequence sb) {\n\t\t\tfor(Side s : Side.values()) {\n\t\t\t\tif (StringUtils.equals(s.getFixCode(), sb)) {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n    \t@Override\n        public final char getChar() {\n    \t    return b;\n        }\n    \t", "        public final char getChar() {\n    \t    return b;\n        }\n    \t\n    \tpublic final String getFixCode() {\n    \t\treturn fixCode;\n    \t}\n    \n    \tpublic final int index() {\n    \t\treturn index;\n    \t}\n    \t", "    \tpublic final int index() {\n    \t\treturn index;\n    \t}\n    \t\n    \tpublic final int invertedIndex() {\n    \t\treturn this == BUY ? SELL.index() : BUY.index();\n    \t}\n    \t\n    \tpublic final boolean isBuy() {\n    \t\treturn this == BUY;\n    \t}\n    \t", "    \tpublic final boolean isBuy() {\n    \t\treturn this == BUY;\n    \t}\n    \t\n    \tpublic final boolean isSell() {\n    \t\treturn this == SELL;\n    \t}\n    \t\n    \tpublic final boolean isOutside(long price, long market) {\n    \t\treturn this == BUY ? price < market : price > market;\n    \t}\n    \t", "    \tpublic final boolean isOutside(long price, long market) {\n    \t\treturn this == BUY ? price < market : price > market;\n    \t}\n    \t\n    \tpublic final boolean isInside(long price, long market) {\n    \t\treturn this == BUY ? price >= market : price <= market;\n    \t}\n\t}\n\n\t/**\n\t * This method of course produces garbage and should be used only for debugging purposes.\n\t * Use toCharSequence(StringBuilder) instead in order to avoid producing garbage.\n\t * \n\t *  @return a newly created String object containing the information about this order instance\n\t */\n\t@Override", "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(256);\n\t\treturn toCharSequence(sb).toString();\n\t}\n\t\n\t/**\n\t * This method does not produce garbage. Re-use the same StringBuilder over and over again in order to avoid creating garbage.\n\t * \n\t * @param sb the StringBuilder where the information will be written to.\n\t * @return a CharSequence (i.e. the StringBuilder passed) containing the order information\n\t */", "\tpublic CharSequence toCharSequence(StringBuilder sb) {\n\t\tsb.append(\"Order [id=\").append(id).append(\", clientOrderId=\").append(clientOrderId).append(\", side=\")\n\t\t\t.append(side).append(\", security=\").append(security).append(\", originalSize=\").append(originalSize)\n\t\t\t.append(\", openSize=\").append(getOpenSize()).append(\", executedSize=\").append(executedSize)\n\t\t\t.append(\", canceledSize=\").append(getCanceledSize());\n\t\t\n\t\tif (type != Type.MARKET) {\n\t\t\tsb.append(\", price=\").append(DoubleUtils.toDouble(price));\n\t\t}\n\t\t\n\t\tsb.append(\", type=\").append(type);\n\t\t", "\t\tif (type != Type.MARKET) {\n\t\t\tsb.append(\", tif=\").append(tif);\n\t\t}\n\t\t\t\n\t\tsb.append(\"]\");\n\t\t\n\t\treturn sb;\n\t}\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/OrderBookAdapter.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport com.coralblocks.coralme.Order.CancelReason;", "\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\n\npublic class OrderBookAdapter implements OrderBookListener {\n    \n\t@Override\n    public void onOrderReduced(OrderBook orderBook, long time, Order order, long reduceNewTotalSize) {\n    \t\n    }\n    \n\t@Override", "    public void onOrderReduced(OrderBook orderBook, long time, Order order, long reduceNewTotalSize) {\n    \t\n    }\n    \n\t@Override\n    public void onOrderCanceled(OrderBook orderBook, long time, Order order, CancelReason cancelReason) {\n    \t\n    }\n    \n\t@Override\n    public void onOrderExecuted(OrderBook orderBook, long time, Order order, ExecuteSide executeSide, long executeSize, long executePrice, long executeId, long executeMatchId) {\n    \t\n    }\n    \n\t@Override", "    public void onOrderExecuted(OrderBook orderBook, long time, Order order, ExecuteSide executeSide, long executeSize, long executePrice, long executeId, long executeMatchId) {\n    \t\n    }\n    \n\t@Override\n    public void onOrderAccepted(OrderBook orderBook, long time, Order order) {\n    \t\n    }\n    \n\t@Override\n    public void onOrderRejected(OrderBook orderBook, long time, Order order, RejectReason rejectReason) {\n    \t\n    }\n    \n\t@Override", "    public void onOrderRejected(OrderBook orderBook, long time, Order order, RejectReason rejectReason) {\n    \t\n    }\n    \n\t@Override\n    public void onOrderRested(OrderBook orderBook, long time, Order order, long restSize, long restPrice) {\n    \t\n    }\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/OrderBook.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\nimport com.coralblocks.coralme.Order.Side;\nimport com.coralblocks.coralme.Order.TimeInForce;", "import com.coralblocks.coralme.Order.Side;\nimport com.coralblocks.coralme.Order.TimeInForce;\nimport com.coralblocks.coralme.Order.Type;\nimport com.coralblocks.coralme.util.DoubleUtils;\nimport com.coralblocks.coralme.util.LinkedObjectPool;\nimport com.coralblocks.coralme.util.LongMap;\nimport com.coralblocks.coralme.util.ObjectPool;\nimport com.coralblocks.coralme.util.SystemTimestamper;\nimport com.coralblocks.coralme.util.Timestamper;\n\npublic class OrderBook implements OrderListener {\n\t\n\tprivate static final Timestamper TIMESTAMPER = new SystemTimestamper();\n\t", "import com.coralblocks.coralme.util.Timestamper;\n\npublic class OrderBook implements OrderListener {\n\t\n\tprivate static final Timestamper TIMESTAMPER = new SystemTimestamper();\n\t\n\tpublic static enum State { NORMAL, LOCKED, CROSSED, ONESIDED, EMPTY }\n\t\n\tprivate static final ObjectPool<Order> ORDER_POOL = new LinkedObjectPool<Order>(1024, Order.class);\n\t\n\tprivate static final ObjectPool<PriceLevel> PRICE_LEVEL_POOL = new LinkedObjectPool<PriceLevel>(1024, PriceLevel.class);\n\t\n\tprivate long execId = 0;\n\t\n\tprivate long matchId = 0;\n\t\n\tprivate PriceLevel[] head = new PriceLevel[2];\n\t\n\tprivate PriceLevel[] tail = new PriceLevel[2];\n\t\n\tprivate int[] levels = new int[] { 0, 0 };\n\t\n\tprivate final LongMap<Order> orders = new LongMap<Order>();\n\t\n\tprivate final String security;\n\t\n\tprivate long lastExecutedPrice = Long.MAX_VALUE;\n\t\n\tprivate final List<OrderBookListener> listeners = new ArrayList<OrderBookListener>(8);\n\t\n\tprivate final Timestamper timestamper;\n\t\n\t\n\tpublic OrderBook(String security) {\n\t\t\n\t\tthis(security, TIMESTAMPER, null);\n\t}\n\t\n\tpublic OrderBook(String security, Timestamper timestamper) {\n\t\t\n\t\tthis(security, timestamper, null);\n\t}\n\t\n\tpublic OrderBook(String security, OrderBookListener listener) {\n\t\tthis(security, TIMESTAMPER, listener);\n\t}\n\n\tpublic OrderBook(String security, Timestamper timestamper, OrderBookListener listener) {\n\t\t\n\t\tthis.security = security;\n\t\t\n\t\tthis.timestamper = timestamper;\n\t\t", "\t\tif (listener != null) listeners.add(listener);\n\t}\n\t\n\tpublic void addListener(OrderBookListener listener) {\n\t\tif (!listeners.contains(listener)) listeners.add(listener);\n\t}\n\t\n\tpublic void removeListener(OrderBookListener listener) {\n\t\tlisteners.remove(listener);\n\t}\n\t", "\tpublic Timestamper getTimestamper() {\n\t\treturn timestamper;\n\t}\n\t\n\tpublic String getSecurity() {\n\t\t\n\t\treturn security;\n\t}\n\t\n\tpublic final Order getBestBidOrder() {\n\t\t", "\tpublic final Order getBestBidOrder() {\n\t\t\n\t\tif (!hasBids()) return null;\n\t\t\n\t\tPriceLevel pl = head(Side.BUY);\n\t\t\n\t\treturn pl.head();\n\t}\n\t\n\tpublic final Order getBestAskOrder() {\n\t\t", "\tpublic final Order getBestAskOrder() {\n\t\t\n\t\tif (!hasAsks()) return null;\n\t\t\n\t\tPriceLevel pl = head(Side.SELL);\n\t\t\t\t\n\t\treturn pl.head();\n\t}\n\t\n\tpublic final Order getOrder(long id) {\n\t\t\n\t\treturn orders.get(id);\n\t}\n\t", "\tpublic final Order getOrder(long id) {\n\t\t\n\t\treturn orders.get(id);\n\t}\n\t\n\tpublic final int getNumberOfOrders() {\n\t\t\n\t\treturn orders.size();\n\t}\n\t\n\tpublic final boolean isEmpty() {\n\n\t\treturn orders.isEmpty();\n\t}\n\t", "\tpublic final boolean isEmpty() {\n\n\t\treturn orders.isEmpty();\n\t}\n\t\n\tpublic final PriceLevel head(Side side) {\n\t\t\n\t\treturn head[side.index()];\n\t}\n\t\n\tpublic final PriceLevel tail(Side side) {\n\t\t\n\t\treturn tail[side.index()];\n\t}\n\t", "\tpublic final PriceLevel tail(Side side) {\n\t\t\n\t\treturn tail[side.index()];\n\t}\n\t\n\tpublic long getLastExecutedPrice() {\n\t\t\n\t\treturn lastExecutedPrice;\n\t}\n\t\n\tpublic final boolean hasSpread() {\n\t\treturn hasBestBid() && hasBestAsk();\n\t}\n\t", "\tpublic final boolean hasSpread() {\n\t\treturn hasBestBid() && hasBestAsk();\n\t}\n\t\n\tpublic final long getSpread() {\n\t\t\n\t\tPriceLevel bestBid = head[Side.BUY.index()];\n\t\t\n\t\tPriceLevel bestAsk = head[Side.SELL.index()];\n\t\t\n\t\tassert bestBid != null && bestAsk != null;\n\t\t\n\t\treturn bestAsk.getPrice() - bestBid.getPrice();\n\t}\n\t", "\tpublic final State getState() {\n\n\t\tPriceLevel bestBid = head[Side.BUY.index()];\n\t\t\n\t\tPriceLevel bestAsk = head[Side.SELL.index()];\n\n\t\tif (bestBid != null && bestAsk != null) {\n\t\t\t\n\t\t\tlong spread = bestAsk.getPrice() - bestBid.getPrice();\n\t\t\t\n\t\t\tif (spread == 0) return State.LOCKED;\n\t\t\t", "\t\t\tif (spread == 0) return State.LOCKED;\n\t\t\t\n\t\t\tif (spread < 0) return State.CROSSED;\n\t\t\t\n\t\t\treturn State.NORMAL;\n\t\t\t\n\t\t} else if (bestBid == null && bestAsk == null) {\n\t\t\t\n\t\t\treturn State.EMPTY;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn State.ONESIDED;\n\t\t}\n\t}\n\t", "\tpublic final boolean hasTop(Side side) {\n\t\t\n\t\treturn side.isBuy() ? hasBestBid() : hasBestAsk();\n\t}\n\t\n\tpublic final boolean hasAsks() {\n\t\treturn hasBestAsk();\n\t}\n\t\n\tpublic final boolean hasBids() {\n\t\treturn hasBestBid();\n\t}\n\t", "\tpublic final boolean hasBids() {\n\t\treturn hasBestBid();\n\t}\n\t\n\tpublic final boolean hasBestBid() {\n\t\t\n\t\treturn head[Side.BUY.index()] != null;\n\t}\n\t\n\tpublic final boolean hasBestAsk() {\n\t\t\n\t\treturn head[Side.SELL.index()] != null;\n\t}\n\t", "\tpublic final boolean hasBestAsk() {\n\t\t\n\t\treturn head[Side.SELL.index()] != null;\n\t}\n\t\n\tpublic final long getBestPrice(Side side) {\n\t\t\n\t\treturn side.isBuy() ? getBestBidPrice() : getBestAskPrice();\n\t}\n\t\n\tpublic final long getBestBidPrice() {\n\t\t\n\t\tint index = Side.BUY.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getPrice();\n\t}\n\t", "\tpublic final long getBestBidPrice() {\n\t\t\n\t\tint index = Side.BUY.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getPrice();\n\t}\n\t\n\tpublic final long getBestAskPrice() {\n\t\t\n\t\tint index = Side.SELL.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getPrice();\n\t}\n\t", "\tpublic final long getBestAskPrice() {\n\t\t\n\t\tint index = Side.SELL.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getPrice();\n\t}\n\t\n\tpublic final long getBestSize(Side side) {\n\t\t\n\t\treturn side.isBuy() ? getBestBidSize() : getBestAskSize();\n\t}\n\t", "\tpublic final long getBestSize(Side side) {\n\t\t\n\t\treturn side.isBuy() ? getBestBidSize() : getBestAskSize();\n\t}\n\t\n\tpublic final long getBestBidSize() {\n\t\t\n\t\tint index = Side.BUY.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getSize();\n\t}\n\t", "\tpublic final long getBestAskSize() {\n\t\t\n\t\tint index = Side.SELL.index();\n\t\t\n\t\tassert head[index] != null;\n\t\t\n\t\treturn head[index].getSize();\n\t}\n\t\n\tpublic final int getLevels(Side side) {\n\t\t\n\t\treturn side.isBuy() ? getBidLevels() : getAskLevels();\n\t}\n\t", "\tpublic final int getLevels(Side side) {\n\t\t\n\t\treturn side.isBuy() ? getBidLevels() : getAskLevels();\n\t}\n\t\n\tpublic final int getBidLevels() {\n\t\t\n\t\treturn levels[Side.BUY.index()];\n\t}\n\t\n\tpublic final int getAskLevels() {\n\t\t\n\t\treturn levels[Side.SELL.index()];\n\t}\n\t", "\tpublic final int getAskLevels() {\n\t\t\n\t\treturn levels[Side.SELL.index()];\n\t}\n\t\n\tpublic void showOrders() {\n\t\tSystem.out.println(orders());\n\t}\n\t\n\tpublic void showLevels() {\n\t\tSystem.out.println(levels());\n\t}\n\t", "\tpublic void showLevels() {\n\t\tSystem.out.println(levels());\n\t}\n\t\n\tpublic String levels() {\n\t\tStringBuilder sb = new StringBuilder(1024);\n\t\tlevels(sb);\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String orders() {\n\t\tStringBuilder sb = new StringBuilder(1024);\n\t\torders(sb);\n\t\treturn sb.toString();\n\t}\n\t", "\tpublic String orders() {\n\t\tStringBuilder sb = new StringBuilder(1024);\n\t\torders(sb);\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic void levels(StringBuilder sb, Side side) {\n\n\t\tif (side == Side.SELL) {\n\t\t\t\n\t\t\tif (!hasAsks()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t", "\t\tif (side == Side.SELL) {\n\t\t\t\n\t\t\tif (!hasAsks()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tfor(PriceLevel pl = head[side.index()]; pl != null; pl = pl.next) {\n\t\t\t\t\n\t\t\t\tString size = String.format(\"%6d\", pl.getSize());\n\t\t\t\tString price = String.format(\"%9.2f\", DoubleUtils.toDouble(pl.getPrice()));\n\t\t\t\t\n\t\t\t\tsb.append(size).append(\" @ \").append(price);\n\t\t\t\tsb.append(\" (orders=\").append(pl.getOrders()).append(\")\\n\");\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t", "\t\t\tif (!hasBids()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(PriceLevel pl = tail[side.index()]; pl != null; pl = pl.prev) {\n\t\t\t\t\n\t\t\t\tString size = String.format(\"%6d\", pl.getSize());\n\t\t\t\tString price = String.format(\"%9.2f\", DoubleUtils.toDouble(pl.getPrice()));\n\t\t\t\t\n\t\t\t\tsb.append(size).append(\" @ \").append(price);\n\t\t\t\tsb.append(\" (orders=\").append(pl.getOrders()).append(\")\\n\");\n\t\t\t}\n\t\t}\n\t}\n\t", "\tpublic void orders(StringBuilder sb, Side side) {\n\n\t\tif (side == Side.SELL) {\n\t\t\t\n\t\t\tif (!hasAsks()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tfor(PriceLevel pl = head[side.index()]; pl != null; pl = pl.next) {\n\t\t\t\t\n\t\t\t\tfor(Order o = pl.head(); o != null; o = o.next) {\n\n\t\t\t\t\tString size = String.format(\"%6d\", o.getOpenSize());\n\t\t\t\t\tString price = String.format(\"%9.2f\", DoubleUtils.toDouble(o.getPrice()));\n\t\t\t\t\t\n\t\t\t\t\tsb.append(size).append(\" @ \").append(price);\n\t\t\t\t\tsb.append(\" (id=\").append(o.getId()).append(\")\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t", "\t\t\tfor(PriceLevel pl = head[side.index()]; pl != null; pl = pl.next) {\n\t\t\t\t\n\t\t\t\tfor(Order o = pl.head(); o != null; o = o.next) {\n\n\t\t\t\t\tString size = String.format(\"%6d\", o.getOpenSize());\n\t\t\t\t\tString price = String.format(\"%9.2f\", DoubleUtils.toDouble(o.getPrice()));\n\t\t\t\t\t\n\t\t\t\t\tsb.append(size).append(\" @ \").append(price);\n\t\t\t\t\tsb.append(\" (id=\").append(o.getId()).append(\")\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t", "\t\t\tif (!hasBids()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(PriceLevel pl = tail[side.index()]; pl != null; pl = pl.prev) {\n\t\t\t\t\n\t\t\t\tfor(Order o = pl.head(); o != null; o = o.next) {\n\n\t\t\t\t\tString size = String.format(\"%6d\", o.getOpenSize());\n\t\t\t\t\tString price = String.format(\"%9.2f\", DoubleUtils.toDouble(o.getPrice()));\n\t\t\t\t\t\n\t\t\t\t\tsb.append(size).append(\" @ \").append(price);\n\t\t\t\t\tsb.append(\" (id=\").append(o.getId()).append(\")\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t", "\tpublic void orders(StringBuilder sb) {\n\t\t\n\t\tif (hasBids()) orders(sb, Side.BUY);\n\t\tif (hasSpread()) {\n\t\t\tsb.append(\"-------- \");\n\t\t\tString spread = String.format(\"%9.2f\", DoubleUtils.toDouble(getSpread()));\n\t\t\tsb.append(spread).append('\\n');\n\t\t} else {\n\t\t\tsb.append(\"-------- \\n\");\n\t\t}\n\t\tif (hasAsks()) orders(sb, Side.SELL);\n\t}\n\t", "\t\tif (hasAsks()) orders(sb, Side.SELL);\n\t}\n\t\n\tpublic void levels(StringBuilder sb) {\n\t\t\n\t\tif (hasBids()) levels(sb, Side.BUY);\n\t\tif (hasSpread()) {\n\t\t\tsb.append(\"-------- \");\n\t\t\tString spread = String.format(\"%9.2f\", DoubleUtils.toDouble(getSpread()));\n\t\t\tsb.append(spread).append('\\n');\n\t\t} else {\n\t\t\tsb.append(\"-------- \\n\");\n\t\t}", "\t\tif (hasAsks()) levels(sb, Side.SELL);\n\t}\n\t\n\tprivate final void match(Order order) {\n\t\t\n\t\tint index = order.getSide().invertedIndex(); // NOTE: Inverted because bid hits ask and vice-versa\n\t\t\n\t\tOUTER:\n\t\tfor(PriceLevel pl = head[index]; pl != null; pl = pl.next) {\n\t\t\t\n\t\t\tif (order.getType() != Type.MARKET && order.getSide().isOutside(order.getPrice(), pl.getPrice())) break;\n\t\t\t", "\t\tfor(PriceLevel pl = head[index]; pl != null; pl = pl.next) {\n\t\t\t\n\t\t\tif (order.getType() != Type.MARKET && order.getSide().isOutside(order.getPrice(), pl.getPrice())) break;\n\t\t\t\n\t\t\tfor(Order o = pl.head(); o != null; o = o.next) {\n\t\t\t\t\n\t\t\t\tlong sizeToExecute = Math.min(order.getOpenSize(), o.getOpenSize());\n\t\t\t\t\n\t\t\t\tlong priceExecuted = o.getPrice(); // always price improve the taker\n\t\t\t\t\n\t\t\t\tlong ts = timestamper.nanoEpoch();\n\t\t\t\t\n\t\t\t\tlastExecutedPrice = priceExecuted;\n\t\t\t\t\n\t\t\t\tlong execId1 = ++execId;\n\t\t\t\tlong execId2 = ++execId;\n\t\t\t\tlong matchId = ++this.matchId;\n\t\t\t\t\n\t\t\t\to.execute(ts, ExecuteSide.MAKER, sizeToExecute, priceExecuted, execId1, matchId); // notify the maker first?\n\t\t\t\t\n\t\t\t\torder.execute(ts, ExecuteSide.TAKER, sizeToExecute, priceExecuted, execId2, matchId);\n\t\t\t\t", "\t\t\t\tif (order.isTerminal()) {\n\t\t\t\t\t\n\t\t\t\t\tbreak OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate final PriceLevel findPriceLevel(Side side, long price) {\n\t\t\n\t\tPriceLevel foundPriceLevel = null;\n\t\t\n\t\tint index = side.index();\n\t\t", "\t\tfor(PriceLevel pl = head[index]; pl != null; pl = pl.next) {\n\t\t\t\n\t\t\tif (side.isInside(price, pl.getPrice())) {\n\t\t\t\t\n\t\t\t\tfoundPriceLevel = pl;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPriceLevel priceLevel;\n\t\t", "\t\tif (foundPriceLevel == null) {\n\t\t\t\n\t\t\tpriceLevel = PRICE_LEVEL_POOL.get();\n\n\t\t\tpriceLevel.init(security, side, price);\n\t\t\t\n\t\t\tlevels[index]++;\n\t\t\t\n\t\t\tif (head[index] == null) {\n\t\t\t\t\n\t\t\t\thead[index] = tail[index] = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.next = priceLevel.prev = null;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\ttail[index].next = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.prev = tail[index];\n\t\t\t\t\n\t\t\t\tpriceLevel.next = null;\n\t\t\t\t\n\t\t\t\ttail[index] = priceLevel;\n\t\t\t}\n\t\t\t", "\t\t\tif (head[index] == null) {\n\t\t\t\t\n\t\t\t\thead[index] = tail[index] = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.next = priceLevel.prev = null;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\ttail[index].next = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.prev = tail[index];\n\t\t\t\t\n\t\t\t\tpriceLevel.next = null;\n\t\t\t\t\n\t\t\t\ttail[index] = priceLevel;\n\t\t\t}\n\t\t\t", "\t\t} else if (foundPriceLevel.getPrice() != price) {\n\t\t\t\n\t\t\tpriceLevel = PRICE_LEVEL_POOL.get();\n\t\t\t\n\t\t\tpriceLevel.init(security, side, price);\n\t\t\t\n\t\t\tlevels[index]++;\n\n\t\t\tif (foundPriceLevel.prev != null) {\n\t\t\t\t\n\t\t\t\tfoundPriceLevel.prev.next = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.prev = foundPriceLevel.prev;\n\t\t\t}\n\n\t\t\tpriceLevel.next = foundPriceLevel;\n\t\t\t\n\t\t\tfoundPriceLevel.prev = priceLevel;\n\t\t\t", "\t\t\tif (foundPriceLevel.prev != null) {\n\t\t\t\t\n\t\t\t\tfoundPriceLevel.prev.next = priceLevel;\n\t\t\t\t\n\t\t\t\tpriceLevel.prev = foundPriceLevel.prev;\n\t\t\t}\n\n\t\t\tpriceLevel.next = foundPriceLevel;\n\t\t\t\n\t\t\tfoundPriceLevel.prev = priceLevel;\n\t\t\t", "\t\t\tif (head[index] == foundPriceLevel) {\n\t\t\t\t\n\t\t\t\thead[index] = priceLevel;\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tpriceLevel = foundPriceLevel;\n\t\t}\n\n\t\treturn priceLevel;\n\t}\n\t", "\tpublic Order createLimit(CharSequence clientOrderId, long exchangeOrderId, Side side, long size, double price, TimeInForce tif) {\n\t\treturn createLimit(clientOrderId, exchangeOrderId, side, size, DoubleUtils.toLong(price), tif);\n\t}\n\n\tpublic Order createLimit(CharSequence clientOrderId, long exchangeOrderId, Side side, long size, long price, TimeInForce tif) {\n\t\treturn createOrder(clientOrderId, exchangeOrderId, side, size, price, Type.LIMIT, tif);\n\t}\n\t\n\tpublic Order createMarket(CharSequence clientOrderId, long exchangeOrderId, Side side, long size) {\n\t\treturn createOrder(clientOrderId, exchangeOrderId, side, size, 0, Type.MARKET, null);\n\t}\n\n\tprotected RejectReason validateOrder(Order order) {\n\t\treturn null;\n\t}\n\t\n\tprivate final Order fillOrCancel(Order order, long exchangeOrderId) {\n\t\t\n\t\tType type = order.getType();\n\t\t", "\tpublic Order createMarket(CharSequence clientOrderId, long exchangeOrderId, Side side, long size) {\n\t\treturn createOrder(clientOrderId, exchangeOrderId, side, size, 0, Type.MARKET, null);\n\t}\n\n\tprotected RejectReason validateOrder(Order order) {\n\t\treturn null;\n\t}\n\t\n\tprivate final Order fillOrCancel(Order order, long exchangeOrderId) {\n\t\t\n\t\tType type = order.getType();\n\t\t", "\t\tif (type == Type.MARKET && order.getPrice() != 0) {\n\t\t\t\n\t\t\torder.reject(timestamper.nanoEpoch(), RejectReason.BAD_PRICE); // remember... the OrderListener callback will return the order to the pool...\n\t\t\t\n\t\t\treturn order;\n\t\t}\n\t\t\n\t\tRejectReason rejectReason = validateOrder(order);\n\n\t\tif (rejectReason != null) {\n\t\t\n\t\t\torder.reject(timestamper.nanoEpoch(), rejectReason); // remember... the OrderListener callback will return the order to the pool...\n\t\t\t\n\t\t\treturn order;\n\t\t}\n\n\t\t// always accept first...\n\t\torder.accept(timestamper.nanoEpoch(), exchangeOrderId);\n\t\t\n\t\t// walk through the book matching:\n\n\t\tmatch(order);\n\t\t\n\t\t// check if there is quantity left that needs to be canceled:\n", "\t\tif (rejectReason != null) {\n\t\t\n\t\t\torder.reject(timestamper.nanoEpoch(), rejectReason); // remember... the OrderListener callback will return the order to the pool...\n\t\t\t\n\t\t\treturn order;\n\t\t}\n\n\t\t// always accept first...\n\t\torder.accept(timestamper.nanoEpoch(), exchangeOrderId);\n\t\t\n\t\t// walk through the book matching:\n\n\t\tmatch(order);\n\t\t\n\t\t// check if there is quantity left that needs to be canceled:\n", "\t\tif (!order.isTerminal()) {\n\t\t\t\n\t\t\tif (type == Type.MARKET) {\n\t\t\t\t\n\t\t\t\torder.cancel(timestamper.nanoEpoch(), CancelReason.NO_LIQUIDITY);\n\t\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tCancelReason cancelReason = CancelReason.MISSED;\n\t\t\t\t\n\t\t\t\tif (!hasTop(order.getOtherSide())) {\n\t\t\t\t\tcancelReason = CancelReason.NO_LIQUIDITY;\n\t\t\t\t}\n\t\t\t\n\t\t\t\torder.cancel(timestamper.nanoEpoch(), cancelReason);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn order;\n\t}\n\t\n\tprivate Order fillOrRest(Order order, long exchangeOrderId) {\n\t\t\n\t\tRejectReason rejectReason = validateOrder(order);\n", "\t\t\t\tif (!hasTop(order.getOtherSide())) {\n\t\t\t\t\tcancelReason = CancelReason.NO_LIQUIDITY;\n\t\t\t\t}\n\t\t\t\n\t\t\t\torder.cancel(timestamper.nanoEpoch(), cancelReason);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn order;\n\t}\n\t\n\tprivate Order fillOrRest(Order order, long exchangeOrderId) {\n\t\t\n\t\tRejectReason rejectReason = validateOrder(order);\n", "\t\tif (rejectReason != null) {\n\t\t\n\t\t\torder.reject(timestamper.nanoEpoch(), rejectReason); // remember... the OrderListener callback will return the order to the pool...\n\t\t\t\n\t\t\treturn order;\n\t\t}\n\t\t\n\t\t// always accept first:\n\t\torder.accept(timestamper.nanoEpoch(), exchangeOrderId);\n\t\t\n\t\t// something needs to be executed first...\n\t\t\t\n\t\tmatch(order);\n\t\t\t", "\t\tif (order.isTerminal()) {\n\t\t\t\t\n\t\t\treturn order;\n\t\t}\n\t\t\t\n\t\t// rest the remaining in the book:\n\t\t\n\t\trest(order);\n\t\t\n\t\treturn order;\n\t}\n\t\n\tfinal Order createOrder(CharSequence clientOrderId, long exchangeOrderId, Side side, long size, long price, Type type,TimeInForce tif) {\n\t\t\n\t\tOrder order = getOrder(clientOrderId, security, side, size, price, type, tif);\n\t\t", "\t\tif (tif == TimeInForce.IOC || type == Type.MARKET) {\n\t\t\t\n\t\t\treturn fillOrCancel(order, exchangeOrderId);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn fillOrRest(order, exchangeOrderId);\n\t\t}\n\t\t\n\t}\n\t", "\tpublic final void purge() {\n\t\t\n\t\tIterator<Order> iter = orders.iterator();\n\t\t\n\t\twhile(iter.hasNext()) {\n\t\t\t\n\t\t\tOrder order = iter.next();\n\t\t\t\n\t\t\tassert order.isTerminal() == false;\n\t\t\t\n\t\t\titer.remove(); // important otherwise you get a ConcurrentModificationException!\n\t\t\t\n\t\t\torder.cancel(timestamper.nanoEpoch(), CancelReason.PURGED);\n\t\t}\n\t}\n\t\n\tprivate final void rest(Order order) {\n\t\t\n\t\tPriceLevel priceLevel = findPriceLevel(order.getSide(), order.getPrice());\n\t\t\n\t\torder.setPriceLevel(priceLevel);\n\t\t\n\t\tpriceLevel.addOrder(order);\n\t\t\n\t\torders.put(order.getId(), order);\n\t\t\n\t\torder.rest(timestamper.nanoEpoch());\n\t}\n\t\n\tprivate Order getOrder(CharSequence clientOrderId, String security, Side side, long size, long price, Type type, TimeInForce tif) {\n\t\t\n\t\tOrder order = ORDER_POOL.get();\n\t\t\n\t\torder.init(clientOrderId, 0, security, side, size, price, type, tif);\n\t\t\n\t\torder.addListener(this);\n\t\t\n\t\treturn order;\n\t}\n\t\n\tprivate void removeOrder(Order order) {\n\t\t\n\t\tPriceLevel priceLevel = order.getPriceLevel();\n\t\t", "\t\tif (priceLevel != null && priceLevel.isEmpty()) {\n\t\t\t\n\t\t\t// remove priceLevel...\n\t\t\t\n\t\t\tif (priceLevel.prev != null) {\n\t\t\t\t\n\t\t\t\tpriceLevel.prev.next = priceLevel.next;\n\t\t\t}\n\t\t\t\n\t\t\tif (priceLevel.next != null) {\n\t\t\t\t\n\t\t\t\tpriceLevel.next.prev = priceLevel.prev;\n\t\t\t}\n\t\t\t\n\t\t\tint index = order.getSide().index();\n\t\t\t", "\t\t\tif (priceLevel.next != null) {\n\t\t\t\t\n\t\t\t\tpriceLevel.next.prev = priceLevel.prev;\n\t\t\t}\n\t\t\t\n\t\t\tint index = order.getSide().index();\n\t\t\t\n\t\t\tif (tail[index] == priceLevel) {\n\t\t\t\t\n\t\t\t\ttail[index] = priceLevel.prev;\n\t\t\t}\n\t\t\t", "\t\t\tif (head[index] == priceLevel) {\n\t\t\t\t\n\t\t\t\thead[index] = priceLevel.next;\n\t\t\t}\n\t\t\t\n\t\t\tlevels[index]--;\n\t\t\t\n\t\t\tPRICE_LEVEL_POOL.release(priceLevel);\n\t\t}\n\t\t\n\t\torders.remove(order.getId());\n\t\t\n\t\tORDER_POOL.release(order);\n\t}\n\t\n\t@Override", "    public void onOrderReduced(long time, Order order, long newSize) {\n\t\t\n\t\tint size = listeners.size();\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderReduced(this, time, order, newSize);\n\t\t}\n    }\n\n\t@Override\n    public void onOrderCanceled(long time, Order order, CancelReason reason) {\n\t\t\n\t\tremoveOrder(order);\n\t\t\n\t\tint size = listeners.size();\n", "    public void onOrderCanceled(long time, Order order, CancelReason reason) {\n\t\t\n\t\tremoveOrder(order);\n\t\t\n\t\tint size = listeners.size();\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderCanceled(this, time, order, reason);\n\t\t}\n\t\t\n    }\n\n\t@Override", "    public void onOrderExecuted(long time, Order order, ExecuteSide execSide, long sizeExecuted, long priceExecuted, long executionId, long matchId) {\n\t \n\t\tif (order.isTerminal()) {\n\t\t\t\n\t\t\tremoveOrder(order);\n\t\t}\n\t\t\n\t\tint size = listeners.size();\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderExecuted(this, time, order, execSide, sizeExecuted, priceExecuted, executionId, matchId);\n\t\t}\n    }\n\n\t@Override", "\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderExecuted(this, time, order, execSide, sizeExecuted, priceExecuted, executionId, matchId);\n\t\t}\n    }\n\n\t@Override\n\tpublic void onOrderAccepted(long time, Order order) {\n\t\t\n\t\tint size = listeners.size();\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderAccepted(this, time, order);\n\t\t}\n\t\t\n\t}\n\t\n\t@Override", "\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderAccepted(this, time, order);\n\t\t}\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void onOrderRejected(long time, Order order, Order.RejectReason reason) {\n\t\n\t\tremoveOrder(order);\n\t\t\n\t\tint size = listeners.size();\n", "\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderRejected(this, time, order, reason);\n\t\t}\n\t}\n\n\t@Override\n    public void onOrderRested(long time, Order order, long restSize, long restPrice) {\n\t    \n\t\tint size = listeners.size();\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderRested(this, time, order, restSize, restPrice);\n\t\t}\n    }\n\t\n\t@Override", "\t\tfor(int i = 0; i < size; i++) {\n\t\t\tlisteners.get(i).onOrderRested(this, time, order, restSize, restPrice);\n\t\t}\n    }\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn security;\n\t}\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/OrderBookLogger.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport com.coralblocks.coralme.Order.CancelReason;", "\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\nimport com.coralblocks.coralme.util.DoubleUtils;\n\n/**\n * This is a simple OrderBookListener that prints its callbacks to System.out for debugging. \n */\npublic class OrderBookLogger implements OrderBookListener {\n\t\n\tprivate boolean isOn = true;\n\t\n\t/**\n\t * Turns on logging to System.out\n\t */", " */\npublic class OrderBookLogger implements OrderBookListener {\n\t\n\tprivate boolean isOn = true;\n\t\n\t/**\n\t * Turns on logging to System.out\n\t */\n\tpublic void on() {\n\t\tisOn = true;\n\t}\n\t\n\t/**\n\t * Turns off logging to System.out\n\t */", "\tpublic void on() {\n\t\tisOn = true;\n\t}\n\t\n\t/**\n\t * Turns off logging to System.out\n\t */\n\tpublic void off() {\n\t\tisOn = false;\n\t}\n\t\n\t/**\n\t * Is currently logging to System.out?\n\t * \n\t * @return true if logging\n\t */", "\tpublic boolean isOn() {\n\t\treturn isOn;\n\t}\n    \n\t@Override\n    public void onOrderReduced(OrderBook orderBook, long time, Order order, long reduceNewTotalSize) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderReduced called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println(\"  reduceNewTotalSize=\" + reduceNewTotalSize);\n    \tSystem.out.println();\n    }\n    \n\t@Override", "    public void onOrderCanceled(OrderBook orderBook, long time, Order order, CancelReason cancelReason) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderCanceled called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println(\"  cancelReason=\" + cancelReason);\n    \tSystem.out.println();\n    }\n    \n\t@Override", "    public void onOrderExecuted(OrderBook orderBook, long time, Order order, ExecuteSide executeSide, long executeSize, long executePrice, long executeId, long executeMatchId) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderExecuted called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println(\"  executeSide=\" + executeSide);\n    \tSystem.out.println(\"  executeSize=\" + executeSize);\n    \tSystem.out.println(\"  executePrice=\" + DoubleUtils.toDouble(executePrice));\n    \tSystem.out.println(\"  executeId=\" + executeId);\n    \tSystem.out.println(\"  executeMatchId=\" + executeMatchId);\n    \tSystem.out.println();    \t\n    }\n    \n\t@Override", "    public void onOrderAccepted(OrderBook orderBook, long time, Order order) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderAccepted called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println();\n    }\n    \n\t@Override\n    public void onOrderRejected(OrderBook orderBook, long time, Order order, RejectReason rejectReason) {", "    public void onOrderRejected(OrderBook orderBook, long time, Order order, RejectReason rejectReason) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderRejected called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println(\"  rejectReason=\" + rejectReason);\n    \tSystem.out.println();\n    }\n    \n\t@Override", "    public void onOrderRested(OrderBook orderBook, long time, Order order, long restSize, long restPrice) {\n\t\tif (!isOn) return;\n    \tSystem.out.println(\"-----> onOrderRested called:\");\n    \tSystem.out.println(\"  orderBook=\" + orderBook);\n    \tSystem.out.println(\"  time=\" + time);\n    \tSystem.out.println(\"  order=\" + order);\n    \tSystem.out.println(\"  restSize=\" + restSize);\n    \tSystem.out.println(\"  restPrice=\" + DoubleUtils.toDouble(restPrice));\n    \tSystem.out.println();\n    }\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/OrderListener.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme;\n\nimport com.coralblocks.coralme.Order.CancelReason;", "\nimport com.coralblocks.coralme.Order.CancelReason;\nimport com.coralblocks.coralme.Order.ExecuteSide;\nimport com.coralblocks.coralme.Order.RejectReason;\n\npublic interface OrderListener {\n    \n    public void onOrderReduced(long time, Order order, long reduceNewTotalSize);\n    \n    public void onOrderCanceled(long time, Order order, CancelReason cancelReason);\n    ", "    public void onOrderCanceled(long time, Order order, CancelReason cancelReason);\n    \n    public void onOrderExecuted(long time, Order order, ExecuteSide executeSide, long executeSize, long executePrice, long executeId, long executeMatchId);\n    \n    public void onOrderAccepted(long time, Order order);\n    \n    public void onOrderRejected(long time, Order order, RejectReason rejectReason);\n    \n    public void onOrderRested(long time, Order order, long restSize, long restPrice);\n    \n}\n", "    public void onOrderRested(long time, Order order, long restSize, long restPrice);\n    \n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/CharMap.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n/**\n * A hash map that uses a single primitive char as keys and is backed up by an array with 256 elements for super fast access.\n * \n * <p><b>NOTE:</b> This data structure is designed on purpose to be used by <b>single-threaded systems</b>, in other words, \n *  it will break if used concurrently by multiple threads.</p>\n *    ", " *  it will break if used concurrently by multiple threads.</p>\n *    \n * @param <E> the entry type this hash map will hold\n */\npublic final class CharMap<E> implements Iterable<E> {\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final E[] data = (E[]) new Object[256];\n\t\n\tprivate int count = 0;\n\tprivate final ReusableIterator iter = new ReusableIterator();\n\tprivate int currIteratorKey;\n\t\n\t/**\n\t * Creates a new CharMap instance\n\t */\n\tpublic CharMap() {\n\t\t\n\t}\n\n\tprivate final int convert(char key) {\n\t\treturn ((byte) key) & 0xff;\n\t}\n\t\n\t/**\n\t * Does the map contain the given key?\n\t * \n\t * @param key the key to check\n\t * @return true if the map contains the given key\n\t */", "\tpublic final boolean containsKey(char key) {\n\t\treturn data[convert(key)] != null;\n\t}\n\n\t/**\n\t * Adds a value for the given key in this map\n\t * \n\t * @param key the key to add\n\t * @param value the value to add\n\t * @return any previous value associated with the given key or null if there was not a value associated with this key\n\t */", "\tpublic final E put(char key, E value) {\n\t\t\n\t\tif (value == null) {\n\t\t\tthrow new NullPointerException(\"CharMap does not support NULL values: \" + key);\n\t\t}\n\n\t\tint index = convert(key);\n\t\tE old = data[index];\n\t\tdata[index] = value;\n\t\tif (old == null) {\n\t\t\t// not replacing...\n\t\t\tcount++;\n\t\t}\n\t\treturn old;\n\t}\n\t\n\t/**\n\t * When using the Iterator for this CharMap, this method will return the current key of the last \n\t * element returned by Iterator.next().\n\t * \n\t * @return the current key of the last iterated element\n\t */", "\t\tif (old == null) {\n\t\t\t// not replacing...\n\t\t\tcount++;\n\t\t}\n\t\treturn old;\n\t}\n\t\n\t/**\n\t * When using the Iterator for this CharMap, this method will return the current key of the last \n\t * element returned by Iterator.next().\n\t * \n\t * @return the current key of the last iterated element\n\t */", "\tpublic char getCurrIteratorKey() {\n\t\treturn (char) currIteratorKey;\n\t}\n\n\t/**\n\t * Returns the value associated with the given key in this map\n\t * \n\t * @param key the key to get the value\n\t * @return the value associated with the given key\n\t */\n\tpublic final E get(char key) {\n\t\treturn data[convert(key)];\n\t}\n\n\t/**\n\t * Removes and returns the value associated with the given key in the map\n\t * \n\t * @param key the key to remove\n\t * @return the value for the removed key\n\t */", "\tpublic final E get(char key) {\n\t\treturn data[convert(key)];\n\t}\n\n\t/**\n\t * Removes and returns the value associated with the given key in the map\n\t * \n\t * @param key the key to remove\n\t * @return the value for the removed key\n\t */\n\tpublic final E remove(char key) {\n\t\tint index = convert(key);\n\t\tE old = data[index];\n\t\tdata[index] = null;", "\tpublic final E remove(char key) {\n\t\tint index = convert(key);\n\t\tE old = data[index];\n\t\tdata[index] = null;\n\t\tif (old != null) {\n\t\t\t// really removing something...\n\t\t\tcount--;\n\t\t}\n\t\treturn old;\n\t}\n\n\tprivate class ReusableIterator implements Iterator<E> {\n\n\t\tint index = 0;\n\t\tint position = 0;\n\t\tint size;\n", "\t\tpublic void reset() {\n\t\t\tthis.index = 0;\n\t\t\tthis.position = 0;\n\t\t\tthis.size = count;\n\t\t\tcurrIteratorKey = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic final boolean hasNext() {\n\t\t\treturn position < size;\n\t\t}\n\n\t\t@Override", "\t\tpublic final boolean hasNext() {\n\t\t\treturn position < size;\n\t\t}\n\n\t\t@Override\n\t\tpublic final E next() {\n\t\t\t\n\t\t\tif (position >= size) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\t\n\t\t\tE e = null;", "\t\t\twhile(e == null) {\n\t\t\t\te = data[index];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tcurrIteratorKey = index - 1;\n\t\t\tposition++;\n\t\t\treturn e;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {", "\t\tpublic void remove() {\n\t\t\tif (index == 0 || data[index - 1] == null) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tdata[index - 1] = null;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the same instance of the iterator (garbage-free)\n\t * \n\t * @return the same instance of the iterator\n\t */\n\t@Override", "\tpublic final Iterator<E> iterator() {\n\t\titer.reset();\n\t\treturn iter;\n\t}\n\n\t/**\n\t * Is this map empty? (size == 0)\n\t * \n\t * @return true if empty\n\t */\n\tpublic final boolean isEmpty() {\n\t\treturn count == 0;\n\t}\n\n\t/**\n\t * Clears the map. The map will be empty (size == 0) after this operation.\n\t */", "\tpublic final boolean isEmpty() {\n\t\treturn count == 0;\n\t}\n\n\t/**\n\t * Clears the map. The map will be empty (size == 0) after this operation.\n\t */\n\tpublic final void clear() {\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tdata[i] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n\n\t/**\n\t * Returns the size of this map\n\t * \n\t * @return the size of this map\n\t */", "\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tdata[i] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n\n\t/**\n\t * Returns the size of this map\n\t * \n\t * @return the size of this map\n\t */", "\tpublic final int size() {\n\t\treturn count;\n\t}\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/CharEnum.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * A contract for enums so that they can return and be represented by a single character \n */\npublic interface CharEnum {\n\t\n\t/**\n\t * Returns the character associated with this enum. \n\t * The enum implementation must enforce that different enums will return different characters.\n\t * In other words, all enums will have unique characters.\n\t * \n\t * @return the unique character for this enum\n\t */", "\tpublic char getChar();\n\t\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/StringUtils.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * This utility class provides methods to work with <tt>String</tt>s and <tt>CharSequence</tt>s in an efficient way and without producing any garbage.\n */\npublic class StringUtils {\n\n\t/**\n\t * Checks if these two CharSequences represent the same String\n\t * \n\t * @param cs1 the first CharSequence\n\t * @param cs2 the second CharSequence\n\t * @return true if they represent the same String\n\t */", "\tpublic final static boolean equals(CharSequence cs1, CharSequence cs2) {\n\t\tif (cs1.length() == cs2.length()) {\n\t\t\tfor (int i = 0; i < cs1.length(); i++) {\n\t\t\t\tif (cs1.charAt(i) != cs2.charAt(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/LinkedObjectList.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\n\n/**\n * A fast and garbage-free double-linked list.\n * \n * <p><b>NOTE:</b> This data structure is designed on purpose to be used by <b>single-threaded systems</b>, in other words, \n *  it will break if used concurrently by multiple threads.</p>\n * \n * @param <E> the type of objects this object list will hold", " * \n * @param <E> the type of objects this object list will hold\n */\npublic class LinkedObjectList<E> implements Iterable<E> {\n\n\tprivate static class Entry<E> {\n\t\tE value = null;\n\t\tEntry<E> next = null;\n\t\tEntry<E> prev = null;\n\t}\n\t\n\tprivate Entry<E> poolHead = null;\n\t\n\tprivate Entry<E> head = null;\n\tprivate Entry<E> tail = null;\n\tprivate int size = 0;\n\n\t/**\n\t * Creates a LinkedObjectList\n\t * \n\t * @param initialCapacity the initial number of preallocated internal entries\n\t */\n\tpublic LinkedObjectList(int initialCapacity) {", "\t\tfor(int i = 0; i < initialCapacity; i++) {\n\t\t\treleaseEntryBackToPool(new Entry<E>());\n\t\t}\n\t}\n\t\n\tprivate Entry<E> getEntryFromPool() {\n\t\tif (poolHead != null) {\n\t\t\tEntry<E> toReturn = poolHead;\n\t\t\tpoolHead = poolHead.next;\n\t\t\ttoReturn.next = null;\n\t\t\ttoReturn.prev = null;\n\t\t\treturn toReturn;\n\t\t} else {\n\t\t\treturn new Entry<E>();\n\t\t}\n\t}\n\t\n\tprivate void releaseEntryBackToPool(Entry<E> entry) {\n\t\tentry.value = null;\n\t\tentry.prev = null; // the pool does not need/use this reference for anything...\n\t\tentry.next = poolHead;\n\t\tpoolHead = entry;\n\t}\n\t\n\t/**\n\t * Clears this list. The list will be empty after this operation.\n\t */", "\tpublic void clear() {\n\t\twhile(head != null) {\n\t\t\tEntry<E> saveNext = head.next;\n\t\t\treleaseEntryBackToPool(head);\n\t\t\thead = saveNext;\n\t\t}\n\t\ttail = null;\n\t\tsize = 0;\n\t}\n\t\n\t/**\n\t * Adds an element to the head of the list.\n\t * \n\t * @param value the value to be added\n\t */", "\tpublic void addFirst(E value) {\n\t\tEntry<E> entry = getEntryFromPool();\n\t\tentry.value = value;\n\t\tif (head == null) {\n\t\t\t// entry.next = null; // redundant\n\t\t\t// entry.prev = null; // redundant\n\t\t\thead = entry;\n\t\t\ttail = entry;\n\t\t} else {\n\t\t\t// entry.prev = null; // redundant\n\t\t\tentry.next = head;\n\t\t\thead.prev = entry;\n\t\t\thead = entry;\n\t\t}\n\t\tsize++;\n\t}\n\t\n\t/**\n\t * Adds an element to the tail of the list.\n\t * \n\t * @param value the value to be added\n\t */", "\tpublic void addLast(E value) {\n\t\tEntry<E> entry = getEntryFromPool();\n\t\tentry.value = value;\n\t\tif (tail == null) {\n\t\t\t// entry.next = null; // redundant\n\t\t\t// entry.prev = null; // redundant\n\t\t\ttail = entry;\n\t\t\thead = entry;\n\t\t} else {\n\t\t\t// entry.next = null; // redundant\n\t\t\tentry.prev = tail;\n\t\t\ttail.next = entry;\n\t\t\ttail = entry;\n\t\t}\n\t\tsize++;\n\t}\n\t\n\t/**\n\t * Returns the element on the head of the list.\n\t * \n\t * @return the first element in the list\n\t */", "\tpublic E first() {\n\t\tif (head == null) return null;\n\t\treturn head.value;\n\t}\n\t\n\t/**\n\t * Removes the element from the head of the list.\n\t * \n\t * @return the first element from the list that was removed\n\t */\n\tpublic E removeFirst() {", "\tpublic E removeFirst() {\n\t\tif (head == null) return null;\n\t\tEntry<E> entry = head;\n\t\thead = head.next;\n\t\tif (head != null) head.prev = null;\n\t\tE toReturn = entry.value;\n\t\treleaseEntryBackToPool(entry);\n\t\tif (--size == 0) tail = null;\n\t\treturn toReturn;\n\t}\n\t\n\t\n\t/**\n\t * Returns the element on the tail of the list.\n\t * \n\t * @return the last element in the list\n\t */", "\tpublic E last() {\n\t\tif (tail == null) return null;\n\t\treturn tail.value;\n\t}\n\t\n\t/**\n\t * Removes the element from the tail of the list.\n\t * \n\t * @return the last element from the list that was removed\n\t */\n\tpublic E removeLast() {", "\tpublic E removeLast() {\n\t\tif (tail == null) return null;\n\t\tEntry<E> entry = tail;\n\t\ttail = tail.prev;\n\t\tif (tail != null) tail.next = null;\n\t\tE toReturn = entry.value;\n\t\treleaseEntryBackToPool(entry);\n\t\tif (--size == 0) head = null;\n\t\treturn toReturn;\n\t}\n\t\n\t/**\n\t * Is this list empty? (with size 0)\n\t * \n\t * @return true if empty\n\t */", "\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\t/**\n\t * Returns the number of elements currently present in the list\n\t * \n\t * @return the number of elements currently present in the list\n\t */\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tprivate class ReusableIterator implements Iterator<E> {\n\n\t\tEntry<E> start;\n\t\tEntry<E> curr;\n", "\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tprivate class ReusableIterator implements Iterator<E> {\n\n\t\tEntry<E> start;\n\t\tEntry<E> curr;\n\n\t\tpublic void reset() {\n\t\t\tthis.start = head;\n\t\t\tthis.curr = null;\n\t\t}\n\n\t\t@Override", "\t\tpublic void reset() {\n\t\t\tthis.start = head;\n\t\t\tthis.curr = null;\n\t\t}\n\n\t\t@Override\n\t\tpublic final boolean hasNext() {\n\t\t\treturn start != null;\n\t\t}\n\n\t\t@Override", "\t\tpublic final E next() {\n\n\t\t\tthis.curr = start;\n\t\t\t\n\t\t\tE toReturn = start.value;\n\t\t\t\n\t\t\tstart = start.next;\n\n\t\t\treturn toReturn;\n\t\t}\n\n\t\t@Override", "\t\tpublic final void remove() {\n\t\t\t\n\t\t\tboolean isTail = curr == tail;\n\t\t\tboolean isHead = curr == head;\n\n\t\t\tif (isTail) {\n\t\t\t\tremoveLast();\n\t\t\t} else if (isHead) {\n\t\t\t\tremoveFirst();\n\t\t\t} else {\n\t\t\t\tcurr.prev.next = curr.next;\n\t\t\t\tcurr.next.prev = curr.prev;\n\t\t\t\treleaseEntryBackToPool(curr);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\tcurr = null;\n\t\t}\n\t}\n\t\n\tprivate ReusableIterator reusableIter = new ReusableIterator();\n\t\n\t/**\n\t * Return the same iterator instance (garbage-free operation)\n\t * \n\t * @return the same instance of the iterator\n\t */\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treusableIter.reset();\n\t\treturn reusableIter;\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/ObjectPool.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * The basic contract of a simple object pool\n *\n * @param <E> the type of the objects in the pool\n */\npublic interface ObjectPool<E> {\n\n\t/**\n\t * Returns an instance from the pool\n\t * \n\t * @return the instance from the pool\n\t */", "\tpublic E get();\n\n\t/**\n\t * Releases an instance back to the pool\n\t * \n\t * @param e the instance to return to the pool\n\t */\n\tpublic void release(E e);\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/LinkedObjectPool.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * An object pool backed up by an internal linked list. Note that instances will be created on demand if the pool runs out of instances.\n * \n * <p><b>NOTE:</b> This data structure is designed on purpose to be used by <b>single-threaded systems</b>, in other words, \n *  it will break if used concurrently by multiple threads.</p>\n * \n * @param <E> the type of objects this object pool will hold\n */\npublic class LinkedObjectPool<E> implements ObjectPool<E> {\n\n\tprivate final LinkedObjectList<E> queue;\n\n\tprivate final Builder<E> builder;\n\n\t/**\n\t * Creates a LinkedObjectPool.\n\t * \n\t * @param initialSize the initial size of the pool (how many instance it will initially have)\n\t * @param klass the class with a default constructor that will be used to create the instances\n\t */\n\tpublic LinkedObjectPool(int initialSize, final Class<E> klass) {\n\n\t\tthis(initialSize, new Builder<E>() {\n\t\t\t@Override", " */\npublic class LinkedObjectPool<E> implements ObjectPool<E> {\n\n\tprivate final LinkedObjectList<E> queue;\n\n\tprivate final Builder<E> builder;\n\n\t/**\n\t * Creates a LinkedObjectPool.\n\t * \n\t * @param initialSize the initial size of the pool (how many instance it will initially have)\n\t * @param klass the class with a default constructor that will be used to create the instances\n\t */\n\tpublic LinkedObjectPool(int initialSize, final Class<E> klass) {\n\n\t\tthis(initialSize, new Builder<E>() {\n\t\t\t@Override", "\t\t\tpublic E newInstance() {\n\t\t\t\ttry {\n\t\t\t\t\treturn klass.newInstance();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates a LinkedObjectPool.\n\t * \n\t * @param initialSize the initial size of the pool (how many instance it will initially have)\n\t * @param builder the builder that will be used to create the instances\n\t */\n\tpublic LinkedObjectPool(int initialSize, Builder<E> builder) {\n\n\t\tthis.builder = builder;\n\n\t\tthis.queue = new LinkedObjectList<E>(initialSize);\n", "\t\tfor (int i = 0; i < initialSize; i++) {\n\t\t\tqueue.addLast(builder.newInstance());\n\t\t}\n\t}\n\t\n\t/**\n\t * The number of instance currently inside this pool. Note that if all the instances are checked-out from this pool, the size returned will be zero.\n\t * \n\t * @return the number of instance currently sitting inside this pool (and not checked-out by anyone)\n\t */\n\tpublic int size() {\n\t\treturn queue.size();\n\t}\n\n\t/**\n\t * Note that if the pool is empty, this method will instantiate and return a new instance. This will cause the pool to grow when this extra instance is\n\t * returned back to the pool.\n\t * \n\t * @return an instance from the pool\n\t */\n\t@Override", "\tpublic int size() {\n\t\treturn queue.size();\n\t}\n\n\t/**\n\t * Note that if the pool is empty, this method will instantiate and return a new instance. This will cause the pool to grow when this extra instance is\n\t * returned back to the pool.\n\t * \n\t * @return an instance from the pool\n\t */\n\t@Override", "\tpublic E get() {\n\n\t\tif (queue.isEmpty()) {\n\n\t\t\treturn builder.newInstance();\n\n\t\t}\n\t\t\n\t\treturn queue.removeLast();\n\t}\n\n\t/**\n\t * Returns an instance back to the pool. Note that this method can be used to grow the pool if the instance released was not in the pool in the first place.\n\t * \n\t * @param e the instance to return back to the pool (i.e. release to the pool)\n\t */\n\t@Override", "\tpublic void release(E e) {\n\n\t\tqueue.addLast(e);\n\t}\n\t\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/LongMap.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n/**\n * <p>A fast hash map that uses long primitives as keys.</p>\n * \n * <p>It produces <b>ZERO garbage.</b>.</p>\n *  \n * <p>Its default initial capacity (before a rehash is needed) is 128. The default load factor is 80%.</p>", " *  \n * <p>Its default initial capacity (before a rehash is needed) is 128. The default load factor is 80%.</p>\n *  \n * <p>Initial capacity must be a <b>power of two</b> or an IllegalArgumentException will be thrown by the constructor. That's for <b>bitwise fast hashing</b>.</p>\n *  \n * <p>You should choose the initial capacity wisely, according to your needs, in order to avoid a rehash which of course produces garbage.</p>\n *  \n * <p>It re-uses the same iterator instance not to produce garbage.</p>\n *  \n * <p><b>NOTE:</b> This data structure is designed on purpose to be used by <b>single-threaded systems</b>, in other words, ", " *  \n * <p><b>NOTE:</b> This data structure is designed on purpose to be used by <b>single-threaded systems</b>, in other words, \n *  it will break if used concurrently by multiple threads.</p>\n * \n * @param <E> the entry type this hash map will hold\n */\npublic class LongMap<E> implements Iterable<E> {\n\t\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 128;\n\tprivate static final float DEFAULT_LOAD_FACTOR = 0.80f;\n\t\n\tprivate static class Entry<T> {\n\t\tlong key;\n\t\tT value;\n\t\tEntry<T> next;\n\t}\n\t\n\tprivate Entry<E>[] data;\n\n\tprivate int lengthMinusOne;\n\n\tprivate int count;\n\n\tprivate int threshold;\n\n\tprivate float loadFactor;\n\n\tprivate Entry<E> poolHead;\n\n\tprivate final ReusableIterator reusableIter = new ReusableIterator();\n\n\tprivate long currIteratorKey;\n\n\t/**\n\t * Creates a LongMap with the default initial capacity and load factor.\n\t */\n\tpublic LongMap() {\n\t\tthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Creates a LongMap with the default load factor.\n\t * \n\t * @param initialCapacity the desired initial capacity\n\t */\n\tpublic LongMap(int initialCapacity) {\n\t\tthis(initialCapacity, DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Creates a LongMap.\n\t * \n\t * @param initialCapacity the desired initial capacity\n\t * @param loadFactor the desired load factor\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic LongMap(int initialCapacity, float loadFactor) {\n", "\t\tif (!MathUtils.isPowerOfTwo(initialCapacity)) {\n\t\t\tthrow new IllegalArgumentException(\"Size must be power of two: \" + initialCapacity);\n\t\t}\n\n\t\tthis.data = new Entry[initialCapacity];\n\t\tthis.lengthMinusOne = initialCapacity - 1;\n\t\tthis.loadFactor = loadFactor;\n\t\tthis.threshold =  Math.round(initialCapacity * loadFactor);\n\t}\n\t\n\tprivate Entry<E> getEntryFromPool(long key, E value, Entry<E> next) {\n\n\t\tEntry<E> newEntry = poolHead;\n", "\t\tif (newEntry != null) {\n\t\t\tpoolHead = newEntry.next;\n\t\t} else {\n\t\t\tnewEntry = new Entry<E>();\n\t\t}\n\n\t\tnewEntry.key = key;\n\t\tnewEntry.value = value;\n\t\tnewEntry.next = next;\n\n\t\treturn newEntry;\n\t}\n\n\tprivate void releaseEntryBackToPool(Entry<E> e) {\n\t\te.value = null;\n\t\te.next = poolHead;\n\t\tpoolHead = e;\n\t}\n\t\n\t/**\n\t * When using the Iterator for this LongMap, this method will return the current key of the last \n\t * element returned by Iterator.next().\n\t * \n\t * @return the current key of the last iterated element\n\t */", "\tpublic final long getCurrIteratorKey() {\n\t\treturn currIteratorKey;\n\t}\n\n\t/**\n\t * Returns the size of this map\n\t * \n\t * @return the size of this map\n\t */\n\tpublic int size() {\n\t\treturn count;\n\t}\n\n\t/**\n\t * Is this map empty? (size == 0)\n\t * \n\t * @return true if empty\n\t */", "\tpublic int size() {\n\t\treturn count;\n\t}\n\n\t/**\n\t * Is this map empty? (size == 0)\n\t * \n\t * @return true if empty\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn size() == 0;\n\t}\n\n\t/**\n\t * Does the map contain the given value?\n\t * \n\t * @param value the value to be checked\n\t * @return true if the map contains this value\n\t */", "\tpublic boolean isEmpty() {\n\t\treturn size() == 0;\n\t}\n\n\t/**\n\t * Does the map contain the given value?\n\t * \n\t * @param value the value to be checked\n\t * @return true if the map contains this value\n\t */\n\tpublic boolean contains(E value) {\n", "\tpublic boolean contains(E value) {\n\n\t\tfor(int i = data.length - 1; i >= 0; i--) {\n\n\t\t\tEntry<E> e = data[i];\n\n\t\t\twhile(e != null) {\n\n\t\t\t\tif (e.value.equals(value)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\te = e.next;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate final int toArrayIndex(long key) {\n\t\treturn (((int) key) & 0x7FFFFFFF) & lengthMinusOne;\n\t}\n\n\t/**\n\t * Does the map contain the given key?\n\t * \n\t * @param key the key to check\n\t * @return true if the map contains the given key\n\t */", "\t\t\t\tif (e.value.equals(value)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\te = e.next;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate final int toArrayIndex(long key) {\n\t\treturn (((int) key) & 0x7FFFFFFF) & lengthMinusOne;\n\t}\n\n\t/**\n\t * Does the map contain the given key?\n\t * \n\t * @param key the key to check\n\t * @return true if the map contains the given key\n\t */", "\tpublic boolean containsKey(long key) {\n\n\t\tEntry<E> e = data[toArrayIndex(key)];\n\n\t\twhile(e != null) {\n\n\t\t\tif (e.key == key) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\te = e.next;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the value associated with the given key in this map\n\t * \n\t * @param key the key to get the value\n\t * @return the value associated with the given key\n\t */", "\tpublic E get(long key) {\n\n\t\tEntry<E> e = data[toArrayIndex(key)];\n\n\t\twhile(e != null) {\n\n\t\t\tif (e.key == key) {\n\n\t\t\t\treturn e.value;\n\t\t\t}\n\n\t\t\te = e.next;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void rehash() {\n\n\t\tint oldCapacity = data.length;\n\n\t\tEntry<E> oldData[] = data;\n\n\t\tint newCapacity = oldCapacity * 2; // power of two, always!\n\n\t\tdata = new Entry[newCapacity];\n\t\tlengthMinusOne = newCapacity - 1;\n\n\t\tthreshold = Math.round(newCapacity * loadFactor);\n", "\t\tfor(int i = oldCapacity - 1; i >= 0; i--) {\n\n\t\t\tEntry<E> old = oldData[i];\n\n\t\t\twhile(old != null) {\n\n\t\t\t\tEntry<E> e = old;\n\n\t\t\t\told = old.next;\n\n\t\t\t\tint index = toArrayIndex(e.key);\n\n\t\t\t\te.next = data[index];\n\n\t\t\t\tdata[index] = e;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds a value for the given key in this map\n\t * \n\t * @param key the key to add\n\t * @param value the value to add\n\t * @return any previous value associated with the given key or null if there was not a value associated with this key\n\t */", "\tpublic E put(long key, E value) {\n\n\t\tif (value == null) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot put null value!\");\n\t\t}\n\n\t\tint index = toArrayIndex(key);\n\n\t\tEntry<E> e = data[index];\n\n\t\twhile(e != null) {\n", "\t\twhile(e != null) {\n\n\t\t\tif (e.key == key) {\n\n\t\t\t\tE old = e.value;\n\n\t\t\t\te.value = value;\n\n\t\t\t\treturn old;\n\t\t\t}\n\n\t\t\te = e.next;\n\t\t}\n", "\t\tif (count >= threshold) {\n\n\t\t\trehash();\n\n\t\t\tindex = toArrayIndex(key); // lengthMinusOne has changed!\n\n\t\t\tdata[index] = getEntryFromPool(key, value, data[index]);\n\n\t\t} else {\n\n\t\t\tdata[index] = getEntryFromPool(key, value, data[index]);\n\t\t}\n\n\t\tcount++;\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes and returns the value associated with the given key in the map\n\t * \n\t * @param key the key to remove\n\t * @return the value for the removed key\n\t */", "\tpublic E remove(long key) {\n\n\t\tint index = toArrayIndex(key);\n\n\t\tEntry<E> e = data[index];\n\t\tEntry<E> prev = null;\n\n\t\twhile(e != null) {\n\n\t\t\tif (e.key == key) {\n", "\t\t\tif (e.key == key) {\n\n\t\t\t\tif (prev != null) {\n\n\t\t\t\t\tprev.next = e.next;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[index] = e.next;\n\t\t\t\t}\n\n\t\t\t\tE oldValue = e.value;\n\n\t\t\t\treleaseEntryBackToPool(e);\n\n\t\t\t\tcount--;\n\n\t\t\t\treturn oldValue;\n\t\t\t}\n\n\t\t\tprev = e;\n\t\t\te = e.next;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clears the map. The map will be empty (size == 0) after this operation.\n\t */", "\tpublic void clear() {\n\n\t\tfor(int index = data.length - 1; index >= 0; index--) {\n\n\t\t\twhile(data[index] != null) {\n\n\t\t\t\tEntry<E> next = data[index].next;\n\n\t\t\t\treleaseEntryBackToPool(data[index]);\n\n\t\t\t\tdata[index] = next;\n\t\t\t}\n\t\t}\n\n\t\tcount = 0;\n\t}\n\n\tprivate class ReusableIterator implements Iterator<E> {\n\n\t\tint size = count;\n\t\tint index = 0;\n\t\tint dataIndex = 0;\n\t\tEntry<E> prev = null;\n\t\tEntry<E> next = null;\n\t\tEntry<E> entry = null;\n\t\tboolean wasRemoved = false;\n", "\t\tpublic void reset() {\n\t\t\tthis.size = count;\n\t\t\tthis.index = 0;\n\t\t\tthis.dataIndex = 0;\n\t\t\tthis.prev = null;\n\t\t\tthis.next = data[0];\n\t\t\tthis.entry = null;\n\t\t\tthis.wasRemoved = false;\n\t\t}\n\n\t\t@Override", "\t\tpublic final boolean hasNext() {\n\t\t\treturn index < size;\n\t\t}\n\n\t\t@Override\n\t\tpublic final E next() {\n\n\t\t\tif (index >= size) throw new NoSuchElementException();\n\n\t\t\tif (!wasRemoved) prev = entry;\n\t\t\t\n\t\t\twasRemoved = false;\n\n\t\t\tentry = next;\n", "\t\t\tif (!wasRemoved) prev = entry;\n\t\t\t\n\t\t\twasRemoved = false;\n\n\t\t\tentry = next;\n\n\t\t\tif (entry == null) {\n    \t\t\twhile(entry == null) {\n    \t\t\t\tdataIndex++;\n    \t\t\t\tentry = data[dataIndex];\n    \t\t\t}\n    \t\t\tprev = null;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t\t\n\t\t\tE o = entry.value;\n\n\t\t\tcurrIteratorKey = entry.key;\n\n\t\t\tnext = entry.next;\n\n\t\t\treturn o;\n\t\t}\n\n\t\t@Override", "\t\tpublic final void remove() {\n\n\t\t\tif (wasRemoved || entry == null) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\t\n\t\t\twasRemoved = true;\n\n\t\t\tif (prev == null) {\n\t\t\t\tdata[dataIndex] = next;\n\t\t\t} else {\n\t\t\t\tprev.next = next;\n\t\t\t}\n\n\t\t\treleaseEntryBackToPool(entry);\n\n\t\t\tentry = null;\n\n\t\t\tcount--;\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the same instance of the iterator (garbage-free)\n\t * \n\t * @return the same instance of the iterator\n\t */\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treusableIter.reset();\n\t\treturn reusableIter;\n\t}\n\t\n}\n", "\t\t\tif (prev == null) {\n\t\t\t\tdata[dataIndex] = next;\n\t\t\t} else {\n\t\t\t\tprev.next = next;\n\t\t\t}\n\n\t\t\treleaseEntryBackToPool(entry);\n\n\t\t\tentry = null;\n\n\t\t\tcount--;\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the same instance of the iterator (garbage-free)\n\t * \n\t * @return the same instance of the iterator\n\t */\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treusableIter.reset();\n\t\treturn reusableIter;\n\t}\n\t\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/Builder.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * Creates new instances of a given type. A builder is useful for object pools that need to instantiate new objects on demand and/or during startup. \n *\n * @param <E> the type of objects this builder produces\n */\npublic interface Builder<E> {\n\n\t/**\n\t * Creates a fresh new instance of the given type. Note that a builder must never return the same instance twice.\n\t * \n\t * @return a fresh new instance\n\t */", "\tpublic E newInstance();\n}"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/MathUtils.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * This utility class provides methods to work with mathematics in an efficient way and without producing any garbage. \n */\npublic class MathUtils {\n\t\n\t/**\n\t * Is this long a power of two?\n\t * \n\t * @param l the long\n\t * @return true if it is a power of two\n\t */", "\tpublic final static boolean isPowerOfTwo(long l) {\n\t    return (l & (l - 1)) == 0;\n\t}\n\t\n\t/**\n\t * Throws an IllegalArgumentException if this long is not a power of two\n\t * \n\t * @param number the long\n\t */\n\tpublic final static void ensurePowerOfTwo(long number) {\n\t\tif (!isPowerOfTwo(number)) {\n\t\t\tthrow new IllegalArgumentException(\"Not a power of two: \" + number);\n\t\t}\n\t}\n}\n\n", "\tpublic final static void ensurePowerOfTwo(long number) {\n\t\tif (!isPowerOfTwo(number)) {\n\t\t\tthrow new IllegalArgumentException(\"Not a power of two: \" + number);\n\t\t}\n\t}\n}\n\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/DoubleUtils.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * This utility class convert doubles with 8-decimal precision to longs and vice-versa. \n */\npublic class DoubleUtils {\n\t\n\t/**\n\t * The precision we are using, which is 8 decimals.\n\t */\n\tpublic static final int PRECISION = 8;\n\t\n\tprivate static final long MULTIPLIER = (long) Math.pow(10, PRECISION);\n\t\n\t/**\n\t * Converts a double value to a long, rounding to 8 decimals of precision.\n\t * \n\t * @param value the double value to convert to a long\n\t * @return the long representing the double value\n\t */", "\tpublic static final int PRECISION = 8;\n\t\n\tprivate static final long MULTIPLIER = (long) Math.pow(10, PRECISION);\n\t\n\t/**\n\t * Converts a double value to a long, rounding to 8 decimals of precision.\n\t * \n\t * @param value the double value to convert to a long\n\t * @return the long representing the double value\n\t */\n\tpublic static long toLong(double value) {\n\t\treturn Math.round(value * MULTIPLIER);\n\t}\n\t\n\t/**\n\t * Converts a long value to a double with 8 decimals of precision.\n\t * \n\t * @param value the long value to convert to a double\n\t * @return the double representing the long value\n\t */", "\tpublic static long toLong(double value) {\n\t\treturn Math.round(value * MULTIPLIER);\n\t}\n\t\n\t/**\n\t * Converts a long value to a double with 8 decimals of precision.\n\t * \n\t * @param value the long value to convert to a double\n\t * @return the double representing the long value\n\t */\n\tpublic static double toDouble(long value) {\n\t\treturn ((double) value) / ((double) MULTIPLIER);\n\t}\n}\n", "\tpublic static double toDouble(long value) {\n\t\treturn ((double) value) / ((double) MULTIPLIER);\n\t}\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/Timestamper.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * A basic contract to return a timestamp, which is epoch in nanoseconds.\n */\npublic interface Timestamper {\n\t\n\t/**\n\t * Return the epoch time in nanoseconds.\n\t * \n\t * @return epoch time in nanoseconds\n\t */", "\tpublic abstract long nanoEpoch();\n}\n"]}
{"filename": "src/main/java/com/coralblocks/coralme/util/SystemTimestamper.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.util;\n\n/**", "\n/**\n * <p>This timestamper is here just for illustrative purposes.</p>\n * \n * <p>There are of course much better ways to get the epoch with nanosecond precision. And without producing any garbage for the GC.</p>\n */\npublic class SystemTimestamper implements Timestamper {\n\t\n\t/**\n\t * Simply returns System.currentTimeMillis * 1000000L.\n\t * Of course this is bad, so feel free to implement other better/native/garbage-free timestampers ;)\n\t * \n\t * @return the epoch timestamp in nanoseconds\n\t */\n\t@Override", "\tpublic long nanoEpoch() {\n\t\treturn System.currentTimeMillis() * 1000000L;\n\t}\n}"]}
{"filename": "src/main/java/com/coralblocks/coralme/example/Example.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.example;\n\nimport com.coralblocks.coralme.Order;", "\nimport com.coralblocks.coralme.Order;\nimport com.coralblocks.coralme.Order.Side;\nimport com.coralblocks.coralme.Order.TimeInForce;\nimport com.coralblocks.coralme.OrderBook;\nimport com.coralblocks.coralme.OrderBookLogger;\n\npublic class Example {\n\t\n\tpublic static void main(String[] args) {\n\n\t\tlong orderId = 0;\n\t\t\n\t\t// This OrderBookListener will print all callbacks to System.out\n\t\tOrderBookLogger orderBookLogger = new OrderBookLogger();\n\t\t\n\t\tOrderBook orderBook = new OrderBook(\"AAPL\", orderBookLogger);\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 200, 150.44, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006570000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  restSize=200\n\t\t\t  restPrice=150.44\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   200 @    150.44 (orders=1)\n\t\t-------- \n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   200 @    150.44 (id=1)\n\t\t-------- \t\t\t  \n\t\t*/\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 500, 149.44, TimeInForce.DAY);\n\t\t\n\t\t/* \n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006574000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=500, openSize=500, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=149.44, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006574000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=500, openSize=500, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=149.44, type=LIMIT, tif=DAY]\n\t\t\t  restSize=500\n\t\t\t  restPrice=149.44\t\n\t\t*/\n\n\t\torderBookLogger.off(); // omit callbacks output for clarity\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 100, 149.44, TimeInForce.GTC);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 100, 148.14, TimeInForce.DAY);\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 300, 153.24, TimeInForce.GTC);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 500, 156.43, TimeInForce.DAY);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 1500, 158.54, TimeInForce.DAY);\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   200 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   300 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\t\n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (id=4)\n\t\t   500 @    149.44 (id=2)\n\t\t   100 @    149.44 (id=3)\n\t\t   200 @    150.44 (id=1)\n\t\t--------      2.80\n\t\t   300 @    153.24 (id=5)\n\t\t   500 @    156.43 (id=6)\n\t\t  1500 @    158.54 (id=7)\n\t\t*/\n\t\t\n\t\torderBookLogger.on();\n\t\t\n\t\t// Buy 100 @ market\n\t\t\n\t\torderBook.createMarket(String.valueOf(++orderId), orderId, Side.BUY, 100);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=8, clientOrderId=8, side=BUY, security=AAPL, originalSize=100, openSize=100, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, type=MARKET]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=5, clientOrderId=5, side=SELL, security=AAPL, originalSize=300, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=100, canceledSize=0, price=153.24, type=LIMIT, tif=GTC]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=100\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=1\n\t\t\t  executeMatchId=1\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=8, clientOrderId=8, side=BUY, security=AAPL, originalSize=100, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=100, canceledSize=0, type=MARKET]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=100\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=2\n\t\t\t  executeMatchId=1\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   200 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1) \n\t\t*/\n\t\t\n\t\t// reduce order with id = 1 to 100 shares\n\t\t\n\t\tOrder order = orderBook.getOrder(1);\n\t\torder.reduceTo(orderBook.getTimestamper().nanoEpoch(), 100);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderReduced called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=100, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=100, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  reduceNewTotalSize=100\t\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   100 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t \n\t\t*/\n\t\t\n\t\t// now cancel the order\n\t\t\n\t\torder.cancel(orderBook.getTimestamper().nanoEpoch());\n\t\t\n\t\t/*\n\t\t\t-----> onOrderCanceled called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=200, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  cancelReason=USER\t \n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      3.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\n\t\t*/\n\t\t\n\t\t// hit the sell side of the book with a LIMIT IOC and notice your price improvement\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 3000, 155.00, TimeInForce.IOC);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=3000, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=5, clientOrderId=5, side=SELL, security=AAPL, originalSize=300, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=300, canceledSize=0, price=153.24, type=LIMIT, tif=GTC]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=200\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=3\n\t\t\t  executeMatchId=2\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=2800, \n\t\t\t  \t\t\t\texecutedSize=200, canceledSize=0, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=200\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=4\n\t\t\t  executeMatchId=2\n\t\t\t\n\t\t\t-----> onOrderCanceled called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=200, canceledSize=2800, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t  cancelReason=MISSED\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      6.99\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\t \n\t\t*/\n\t\t\n\t\torderBookLogger.off();\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 3000, 160.00, TimeInForce.DAY);\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      6.99\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\n\t\t  3000 @    160.00 (orders=1)\n\t\t*/\n\t\t\n\t\t// now hit two ask levels, price improve and sit on the book at 159.00\n\t\t\n\t\torderBookLogger.on();\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 3900, 159.00, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=3900, executedSize=0, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=6, clientOrderId=6, side=SELL, security=AAPL, originalSize=500, openSize=0, executedSize=500, canceledSize=0, price=156.43, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=500\n\t\t\t  executePrice=156.43\n\t\t\t  executeId=5\n\t\t\t  executeMatchId=3\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=3400, executedSize=500, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=500\n\t\t\t  executePrice=156.43\n\t\t\t  executeId=6\n\t\t\t  executeMatchId=3\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=7, clientOrderId=7, side=SELL, security=AAPL, originalSize=1500, openSize=0, executedSize=1500, canceledSize=0, price=158.54, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=1500\n\t\t\t  executePrice=158.54\n\t\t\t  executeId=7\n\t\t\t  executeMatchId=4\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=1900, executedSize=2000, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=1500\n\t\t\t  executePrice=158.54\n\t\t\t  executeId=8\n\t\t\t  executeMatchId=4\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732575000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=1900, executedSize=2000, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  restSize=1900\n\t\t\t  restPrice=159.0\t \n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (id=4)\n\t\t   500 @    149.44 (id=2)\n\t\t   100 @    149.44 (id=3)\n\t\t  1900 @    159.00 (id=11)    <==== You order sat here after hitting some asks...\n\t\t--------      1.00\n\t\t  3000 @    160.00 (id=10)\t \n\t\t*/\n\t}\n}", "\tpublic static void main(String[] args) {\n\n\t\tlong orderId = 0;\n\t\t\n\t\t// This OrderBookListener will print all callbacks to System.out\n\t\tOrderBookLogger orderBookLogger = new OrderBookLogger();\n\t\t\n\t\tOrderBook orderBook = new OrderBook(\"AAPL\", orderBookLogger);\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 200, 150.44, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006570000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  restSize=200\n\t\t\t  restPrice=150.44\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   200 @    150.44 (orders=1)\n\t\t-------- \n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   200 @    150.44 (id=1)\n\t\t-------- \t\t\t  \n\t\t*/\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 500, 149.44, TimeInForce.DAY);\n\t\t\n\t\t/* \n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006574000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=500, openSize=500, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=149.44, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006574000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=500, openSize=500, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=149.44, type=LIMIT, tif=DAY]\n\t\t\t  restSize=500\n\t\t\t  restPrice=149.44\t\n\t\t*/\n\n\t\torderBookLogger.off(); // omit callbacks output for clarity\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 100, 149.44, TimeInForce.GTC);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 100, 148.14, TimeInForce.DAY);\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 300, 153.24, TimeInForce.GTC);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 500, 156.43, TimeInForce.DAY);\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 1500, 158.54, TimeInForce.DAY);\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   200 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   300 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\t\n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (id=4)\n\t\t   500 @    149.44 (id=2)\n\t\t   100 @    149.44 (id=3)\n\t\t   200 @    150.44 (id=1)\n\t\t--------      2.80\n\t\t   300 @    153.24 (id=5)\n\t\t   500 @    156.43 (id=6)\n\t\t  1500 @    158.54 (id=7)\n\t\t*/\n\t\t\n\t\torderBookLogger.on();\n\t\t\n\t\t// Buy 100 @ market\n\t\t\n\t\torderBook.createMarket(String.valueOf(++orderId), orderId, Side.BUY, 100);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=8, clientOrderId=8, side=BUY, security=AAPL, originalSize=100, openSize=100, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, type=MARKET]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=5, clientOrderId=5, side=SELL, security=AAPL, originalSize=300, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=100, canceledSize=0, price=153.24, type=LIMIT, tif=GTC]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=100\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=1\n\t\t\t  executeMatchId=1\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732570000000\n\t\t\t  order=Order [id=8, clientOrderId=8, side=BUY, security=AAPL, originalSize=100, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=100, canceledSize=0, type=MARKET]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=100\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=2\n\t\t\t  executeMatchId=1\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   200 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1) \n\t\t*/\n\t\t\n\t\t// reduce order with id = 1 to 100 shares\n\t\t\n\t\tOrder order = orderBook.getOrder(1);\n\t\torder.reduceTo(orderBook.getTimestamper().nanoEpoch(), 100);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderReduced called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=100, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=100, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  reduceNewTotalSize=100\t\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t   100 @    150.44 (orders=1)\n\t\t--------      2.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t \n\t\t*/\n\t\t\n\t\t// now cancel the order\n\t\t\n\t\torder.cancel(orderBook.getTimestamper().nanoEpoch());\n\t\t\n\t\t/*\n\t\t\t-----> onOrderCanceled called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732572000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=200, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  cancelReason=USER\t \n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      3.80\n\t\t   200 @    153.24 (orders=1)\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\n\t\t*/\n\t\t\n\t\t// hit the sell side of the book with a LIMIT IOC and notice your price improvement\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 3000, 155.00, TimeInForce.IOC);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=3000, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=5, clientOrderId=5, side=SELL, security=AAPL, originalSize=300, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=300, canceledSize=0, price=153.24, type=LIMIT, tif=GTC]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=200\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=3\n\t\t\t  executeMatchId=2\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=2800, \n\t\t\t  \t\t\t\texecutedSize=200, canceledSize=0, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=200\n\t\t\t  executePrice=153.24\n\t\t\t  executeId=4\n\t\t\t  executeMatchId=2\n\t\t\t\n\t\t\t-----> onOrderCanceled called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=9, clientOrderId=9, side=BUY, security=AAPL, originalSize=3000, openSize=0, \n\t\t\t  \t\t\t\texecutedSize=200, canceledSize=2800, price=155.0, type=LIMIT, tif=IOC]\n\t\t\t  cancelReason=MISSED\n\t\t*/\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      6.99\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\t\t \n\t\t*/\n\t\t\n\t\torderBookLogger.off();\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.SELL, 3000, 160.00, TimeInForce.DAY);\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (orders=1)\n\t\t   600 @    149.44 (orders=2)\n\t\t--------      6.99\n\t\t   500 @    156.43 (orders=1)\n\t\t  1500 @    158.54 (orders=1)\n\t\t  3000 @    160.00 (orders=1)\n\t\t*/\n\t\t\n\t\t// now hit two ask levels, price improve and sit on the book at 159.00\n\t\t\n\t\torderBookLogger.on();\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 3900, 159.00, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t-----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=3900, executedSize=0, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=6, clientOrderId=6, side=SELL, security=AAPL, originalSize=500, openSize=0, executedSize=500, canceledSize=0, price=156.43, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=500\n\t\t\t  executePrice=156.43\n\t\t\t  executeId=5\n\t\t\t  executeMatchId=3\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=3400, executedSize=500, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=500\n\t\t\t  executePrice=156.43\n\t\t\t  executeId=6\n\t\t\t  executeMatchId=3\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=7, clientOrderId=7, side=SELL, security=AAPL, originalSize=1500, openSize=0, executedSize=1500, canceledSize=0, price=158.54, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=MAKER\n\t\t\t  executeSize=1500\n\t\t\t  executePrice=158.54\n\t\t\t  executeId=7\n\t\t\t  executeMatchId=4\n\t\t\t\n\t\t\t-----> onOrderExecuted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732574000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=1900, executedSize=2000, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  executeSide=TAKER\n\t\t\t  executeSize=1500\n\t\t\t  executePrice=158.54\n\t\t\t  executeId=8\n\t\t\t  executeMatchId=4\n\t\t\t\n\t\t\t-----> onOrderRested called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732575000000\n\t\t\t  order=Order [id=11, clientOrderId=11, side=BUY, security=AAPL, originalSize=3900, openSize=1900, executedSize=2000, canceledSize=0, price=159.0, type=LIMIT, tif=DAY]\n\t\t\t  restSize=1900\n\t\t\t  restPrice=159.0\t \n\t\t*/\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t/*\n\t\t   100 @    148.14 (id=4)\n\t\t   500 @    149.44 (id=2)\n\t\t   100 @    149.44 (id=3)\n\t\t  1900 @    159.00 (id=11)    <==== You order sat here after hitting some asks...\n\t\t--------      1.00\n\t\t  3000 @    160.00 (id=10)\t \n\t\t*/\n\t}\n}"]}
{"filename": "src/main/java/com/coralblocks/coralme/example/NoGCTest.java", "chunked_list": ["/* \n * Copyright 2023 (c) CoralBlocks - http://www.coralblocks.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.coralblocks.coralme.example;\n\nimport com.coralblocks.coralme.Order;", "\nimport com.coralblocks.coralme.Order;\nimport com.coralblocks.coralme.Order.Side;\nimport com.coralblocks.coralme.Order.TimeInForce;\nimport com.coralblocks.coralme.OrderBook;\nimport com.coralblocks.coralme.OrderBookAdapter;\nimport com.coralblocks.coralme.OrderBookListener;\nimport com.coralblocks.coralme.util.Timestamper;\n\n/**", "\n/**\n * <p>Run this test with <b>-verbose:gc</b> and look for any GC activity. <b>You must not see any.</b></p>\n * \n * <p>Alternatively you can pass <i>true</i> to createGarbage to see a lot of GC activity.</p>\n * \n * <p>You should also decrease the max size of your heap memory so that if the GC has to kick in, it will do it sooner than later.</p>\n * \n * <p>A good command-line example is:  <b><code>java -verbose:gc -Xms128m -Xmx256m -cp target/classes com.coralblocks.coralme.example.NoGCTest</code></b></p>\n */\npublic class NoGCTest {\n\n\tprivate static final boolean USE_BAD_SYSTEM_OUT_PRINT = false; // turn this on and you will see a lot of garbage from System.out.print\n\tprivate final static StringBuilder sb = new StringBuilder(1024);\n\tprivate static long orderId = 1;\n\t\n\tprivate static CharSequence getClientOrderId() {\n\t\tsb.setLength(0);\n\t\tsb.append(orderId);\n\t\treturn sb;\n\t}\n\t\n\tprivate static void printWithoutGarbage(CharSequence cs) {\n\t\tint size = cs.length();", " * <p>A good command-line example is:  <b><code>java -verbose:gc -Xms128m -Xmx256m -cp target/classes com.coralblocks.coralme.example.NoGCTest</code></b></p>\n */\npublic class NoGCTest {\n\n\tprivate static final boolean USE_BAD_SYSTEM_OUT_PRINT = false; // turn this on and you will see a lot of garbage from System.out.print\n\tprivate final static StringBuilder sb = new StringBuilder(1024);\n\tprivate static long orderId = 1;\n\t\n\tprivate static CharSequence getClientOrderId() {\n\t\tsb.setLength(0);\n\t\tsb.append(orderId);\n\t\treturn sb;\n\t}\n\t\n\tprivate static void printWithoutGarbage(CharSequence cs) {\n\t\tint size = cs.length();", "\t\tfor(int i = 0; i < size; i++) System.out.write(cs.charAt(i));\n\t\tSystem.out.flush();\n\t}\n\t\n\tprivate static void printIteration(int x) {\n\t\t\n\t\tsb.setLength(0);\n\t\tsb.append('\\r').append(x); // does not produce garbage\n\t\t\n\t\tif (USE_BAD_SYSTEM_OUT_PRINT) {\n\t\t\tSystem.out.print(sb); // produces garbage!\n\t\t} else {\n\t\t\tprintWithoutGarbage(sb);\n\t\t}\n\t}\n\t", "\t\tif (USE_BAD_SYSTEM_OUT_PRINT) {\n\t\t\tSystem.out.print(sb); // produces garbage!\n\t\t} else {\n\t\t\tprintWithoutGarbage(sb);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tboolean createGarbage = args.length >= 1 ? Boolean.parseBoolean(args[0]) : false;\n\t\tint iterations = args.length >= 2 ? Integer.parseInt(args[1]) : 1000000;\n\t\t\n\t\tOrderBookListener noOpListener = new OrderBookAdapter();\n\t\t\n\t\tOrderBook book = new OrderBook(\"AAPL\", noOpListener);\n\t\t", "\t\tfor(int i = 1; i <= iterations; i++) {\n\t\t\t\n\t\t\tprintIteration(i);\n\t\t\t\n\t\t\tTimestamper ts = book.getTimestamper();\n\t\t\t\n\t\t\t// Bids:\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY, 1000, 100.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  900,  99.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  800,  98.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  700,  97.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  500,  95.00, TimeInForce.DAY);\n\t\t\t\n\t\t\t// Asks:\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL,  500, 102.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL,  400, 104.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL,  800, 105.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL,  700, 108.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++, Side.SELL,  500, 115.00, TimeInForce.DAY);\n\t\t\t\n\t\t\t// Hit top of book with IOCs:\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  600, 103.00, TimeInForce.IOC);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL, 900, 96.00,  TimeInForce.IOC);\n\t\t\t\n\t\t\t// Reduce and cancel top of book orders\n\t\t\tOrder bidOrder = book.getBestBidOrder();\n\t\t\tOrder askOrder = book.getBestAskOrder();\n\t\t\t", "\t\t\tif (createGarbage) {\n\t\t\t\t// create some garbage for the garbage collector\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(\"someGarbage\"); // appending a CharSequence does not produce garbage\n\t\t\t\tfor(int x = 0; x < 10; x++) sb.toString(); // but this produces garbage\n\t\t\t}\n\t\t\t\n\t\t\tbidOrder.reduceTo(ts.nanoEpoch(), 100);\n\t\t\taskOrder.reduceTo(ts.nanoEpoch(), 100);\n\t\t\t\n\t\t\tbidOrder.cancel(ts.nanoEpoch());\n\t\t\taskOrder.cancel(ts.nanoEpoch());\n\t\t\t\n\t\t\t// Order rejects due odd lot\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  620, 103.00, TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL, 940, 96.00,  TimeInForce.DAY);\n\t\t\t\n\t\t\t// Add a couple of more orders in the middle of the book\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.BUY,  600, 96.00,  TimeInForce.DAY);\n\t\t\tbook.createLimit(getClientOrderId(),  orderId++,  Side.SELL, 990, 111.00, TimeInForce.DAY);\n\t\t\t\n\t\t\t// Now use a market order to remove all liquidity from both sides\n\t\t\tbook.createMarket(getClientOrderId(),  orderId++,  Side.BUY,  15000);\n\t\t\tbook.createMarket(getClientOrderId(),  orderId++,  Side.SELL, 15000);\n\t\t\t\n\t\t\t// Book must now be empty", "\t\t\tif (!book.isEmpty()) throw new IllegalStateException(\"Book must be empty here!\");\n\t\t}\n\t\t\n\t\tSystem.out.println(\" ... DONE!\");\n\t}\n}\n"]}
