{"filename": "src/main/java/net/gerasiov/particleapi/ParticleAPI.java", "chunked_list": ["package net.gerasiov.particleapi;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.World;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.logging.Logger;\n\npublic final class ParticleAPI extends JavaPlugin {\n    public static Plugin instance;", "\npublic final class ParticleAPI extends JavaPlugin {\n    public static Plugin instance;\n    public Logger PluginLogger = Bukkit.getLogger();\n\n    @Override\n    public void onEnable() {\n        PluginLogger.info(\"Enabled\");\n        instance = this;\n    }\n\n    @Override", "    public void onDisable() {\n        PluginLogger.info(\"Disabled\");\n    }\n\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/ParticleSpawnInjector.java", "chunked_list": ["package net.gerasiov.particleapi;\n\npublic interface ParticleSpawnInjector {\n    void reply(int index);\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/VibrationParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.Vibration;\n\npublic class VibrationParticle extends RegularParticle {\n    private Vibration vibration;\n\n    /**\n     * Creates a new {@link VibrationParticle} object with the specified parameters.\n     *\n     * @param vibration The {@link Vibration} for the particle.\n     */\n    public VibrationParticle(Vibration vibration) {\n        super(Particle.VIBRATION, vibration.getOrigin());\n        this.vibration = vibration;\n    }\n", "public class VibrationParticle extends RegularParticle {\n    private Vibration vibration;\n\n    /**\n     * Creates a new {@link VibrationParticle} object with the specified parameters.\n     *\n     * @param vibration The {@link Vibration} for the particle.\n     */\n    public VibrationParticle(Vibration vibration) {\n        super(Particle.VIBRATION, vibration.getOrigin());\n        this.vibration = vibration;\n    }\n", "    public Vibration getVibration() {\n        return vibration;\n    }\n\n    public void setVibration(Vibration vibration) {\n        this.vibration = vibration;\n    }\n\n    @Override\n    public VibrationParticle clone() {\n        return new VibrationParticle(vibration);\n    }\n\n    @Override", "    public VibrationParticle clone() {\n        return new VibrationParticle(vibration);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(Particle.VIBRATION, getLocation(), 1, vibration);\n        }\n    }\n}\n", "        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(Particle.VIBRATION, getLocation(), 1, vibration);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/ItemParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport java.util.Collection;\nimport java.util.function.Predicate;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.inventory.ItemStack;", "import org.bukkit.entity.Entity;\nimport org.bukkit.inventory.ItemStack;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\n\npublic class ItemParticle extends RegularParticle {\n    private final ItemStack itemData;\n\n    /**\n     * Creates a new {@link ItemParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param itemData The {@link ItemStack} to be used as item data.\n     */\n    public ItemParticle(Location location, ItemStack itemData) {\n        super(Particle.ITEM_CRACK, location);\n        this.itemData = itemData;\n    }\n", "    public ItemStack getItemData() {\n        return itemData;\n    }\n\n    @Override\n    public ItemParticle clone() {\n        return new ItemParticle(getLocation().clone(), itemData.clone());\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, itemData);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/SculkChargeParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\n\npublic class SculkChargeParticle extends RegularParticle {\n    private float angle;\n\n    /**\n     * Creates a new {@link SculkChargeParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param angle    The angle for the particle in radians. 0 will display it upright, while Math.PI will display it upside down\n     */\n    public SculkChargeParticle(Location location, float angle) {\n        super(Particle.SCULK_CHARGE, location);\n        this.angle = angle;\n    }\n", "    public float getAngle() {\n        return angle;\n    }\n\n    public void setAngle(float angle) {\n        this.angle = angle;\n    }\n\n    @Override\n    public SculkChargeParticle clone() {\n        return new SculkChargeParticle(getLocation().clone(), angle);\n    }\n\n    @Override", "    public SculkChargeParticle clone() {\n        return new SculkChargeParticle(getLocation().clone(), angle);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, angle);\n        }\n    }\n}\n", "        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, angle);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/DustParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport java.util.function.Predicate;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Color;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.Particle.DustOptions;\nimport org.bukkit.Particle.DustTransition;", "import org.bukkit.Particle.DustOptions;\nimport org.bukkit.Particle.DustTransition;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\n\npublic class DustParticle extends RegularParticle {\n    private Color color;\n    private Color secondaryColor;\n    private float size;\n\n    /**\n     * Creates a new {@link DustParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param color    The color for the particle.\n     * @param size     The size for the particle.\n     */\n    public DustParticle(Location location, Color color, float size) {\n        super(Particle.REDSTONE, location);\n        this.color = color;\n        this.size = size;\n    }\n\n    /**\n     * Creates a new {@link DustParticle} object with the specified parameters.\n     *\n     * @param location        The location for the particle.\n     * @param color           The color for the particle.\n     * @param secondaryColor  The secondary color for the particle, towards which the main color will transition.\n     * @param size            The size for the particle.\n     */\n    public DustParticle(Location location, Color color, Color secondaryColor, float size) {\n        super(Particle.DUST_COLOR_TRANSITION, location);\n        this.color = color;\n        this.secondaryColor = secondaryColor;\n        this.size = size;\n    }\n", "    public Color getColor() {\n        return color;\n    }\n\n    public Color getSecondaryColor() {\n        return secondaryColor;\n    }\n\n    public float getSize() {\n        return size;\n    }\n", "    public float getSize() {\n        return size;\n    }\n\n    public void setColor(Color color) {\n        this.color = color;\n    }\n\n    public void setSecondaryColor(Color secondaryColor) {\n        this.secondaryColor = secondaryColor;\n    }\n", "    public void setSecondaryColor(Color secondaryColor) {\n        this.secondaryColor = secondaryColor;\n    }\n\n    public void setSize(float size) {\n        this.size = size;\n    }\n\n    @Override\n    public DustParticle clone() {\n        if (getType() == Particle.REDSTONE) {\n            return new DustParticle(getLocation().clone(), color, size);\n        }\n        return new DustParticle(getLocation(), color, secondaryColor, size);\n    }\n\n    @Override", "    public DustParticle clone() {\n        if (getType() == Particle.REDSTONE) {\n            return new DustParticle(getLocation().clone(), color, size);\n        }\n        return new DustParticle(getLocation(), color, secondaryColor, size);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            if (getType() == Particle.REDSTONE) {\n                DustOptions dustOptions = new DustOptions(color, size);\n                getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, dustOptions);\n            } else {\n                DustTransition dustTransition = new DustTransition(color, secondaryColor, size);\n                getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, dustTransition);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/SpellMobParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Color;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\n\nimport java.util.function.Predicate;\n\npublic class SpellMobParticle extends RegularParticle {\n    private double red;\n    private double green;\n    private double blue;\n    // I don't know what this value is, maybe alpha? Until then, it will be called extra. extra=1D should produce normal results.\n    private double extra;\n\n\t/**\n     * Creates a new {@link SpellMobParticle} object with the specified parameters.\n     *\n     * @param type     Particle type. Can be either {@link Particle#SPELL_MOB} or {@link Particle#SPELL_MOB_AMBIENT}.\n     * @param location The location for the particle.\n     * @param color    The color for the particle.\n     * @param extra    The extra value for the particle. Presumably alpha, 1D should produce normal results.\n     */\n    public SpellMobParticle(Particle type, Location location, Color color, double extra) {\n        super(type, location);", "import java.util.function.Predicate;\n\npublic class SpellMobParticle extends RegularParticle {\n    private double red;\n    private double green;\n    private double blue;\n    // I don't know what this value is, maybe alpha? Until then, it will be called extra. extra=1D should produce normal results.\n    private double extra;\n\n\t/**\n     * Creates a new {@link SpellMobParticle} object with the specified parameters.\n     *\n     * @param type     Particle type. Can be either {@link Particle#SPELL_MOB} or {@link Particle#SPELL_MOB_AMBIENT}.\n     * @param location The location for the particle.\n     * @param color    The color for the particle.\n     * @param extra    The extra value for the particle. Presumably alpha, 1D should produce normal results.\n     */\n    public SpellMobParticle(Particle type, Location location, Color color, double extra) {\n        super(type, location);", "        if (!(type == Particle.SPELL_MOB || type == Particle.SPELL_MOB_AMBIENT)) {\n            throw new IllegalArgumentException(\"Invalid particle type provided\");\n        }\n        this.red = color.getRed() / 255D;\n        this.green = color.getGreen() / 255D;\n        this.blue = color.getBlue() / 255D;\n        this.extra = extra;\n    }\n\n    /**\n     * Creates a new {@link SpellMobParticle} object with the specified parameters.\n     *\n     * @param type     Particle type. Can be either {@link Particle#SPELL_MOB} or {@link Particle#SPELL_MOB_AMBIENT}.\n     * @param location The location for the particle.\n     * @param red      The red component of the color. The value must be an integer between 0 and 255.\n     * @param green    The green component of the color. The value must be an integer between 0 and 255.\n     * @param blue     The blue component of the color. The value must be an integer between 0 and 255.\n     * @param extra    The extra value for the particle. Presumably alpha, 1D should produce normal results.\n     */\n    public SpellMobParticle(Particle type, Location location, int red, int green, int blue, double extra) {\n        super(type, location);", "        if (!(type == Particle.SPELL_MOB || type == Particle.SPELL_MOB_AMBIENT)) {\n            throw new IllegalArgumentException(\"Invalid particle type provided\");\n        }\n        this.red = red / 255D;\n        this.green = green / 255D;\n        this.blue = blue / 255D;\n        this.extra = extra;\n    }\n\n    /**\n     * Creates a new {@link SpellMobParticle} object with the specified parameters.\n     *\n     * @param type Particle type. Can be either {@link Particle#SPELL_MOB} or {@link Particle#SPELL_MOB_AMBIENT}.\n     * @param location The location for the particle.\n     * @param red The red component of the color. The value must be a double between 0 and 1, also divisible by 1/255.;\n     * @param green The green component of the color. The value must be a double between 0 and 1, also divisible by 1/255.;\n     * @param blue The blue component of the colo. The value must be a double between 0 and 1, also divisible by 1/255.;\n     * @param extra The extra value for the particle. Presumably alpha, 1D should produce normal results.\n     */\n    public SpellMobParticle(Particle type, Location location, double red, double green, double blue, double extra) {\n        super(type, location);", "        if (!(type == Particle.SPELL_MOB || type == Particle.SPELL_MOB_AMBIENT)) {\n            throw new IllegalArgumentException(\"Invalid particle type provided\");\n        }\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.extra = extra;\n    }\n\n    public int getRed() {\n        return (int) (this.red * 255);\n    }\n", "    public int getRed() {\n        return (int) (this.red * 255);\n    }\n\n    public int getGreen() {\n        return (int) (this.green * 255);\n    }\n\n    public int getBlue() {\n        return (int) (this.blue * 255);\n    }\n", "    public int getBlue() {\n        return (int) (this.blue * 255);\n    }\n\n    public double getExtra() {\n        return this.extra;\n    }\n\n    public void setRed(double red) {\n        this.red = red;\n    }\n", "    public void setRed(double red) {\n        this.red = red;\n    }\n\n    public void setGreen(double green) {\n        this.green = green;\n    }\n\n    public void setBlue(double blue) {\n        this.blue = blue;\n    }\n", "    public void setBlue(double blue) {\n        this.blue = blue;\n    }\n\n    public void setExtra(double extra) {\n        this.extra = extra;\n    }\n\n    public void setColor(Color color) {\n        this.red = color.getRed() / 255D;\n        this.green = color.getGreen() / 255D;\n        this.blue = color.getBlue() / 255D;\n    }\n\n    @Override", "    public void setColor(Color color) {\n        this.red = color.getRed() / 255D;\n        this.green = color.getGreen() / 255D;\n        this.blue = color.getBlue() / 255D;\n    }\n\n    @Override\n    public SpellMobParticle clone() {\n        return new SpellMobParticle(getType(), getLocation().clone(), this.red, this.green, this.blue, this.extra);\n    }\n\n    @Override", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 0, red, green, blue, extra);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/NoteParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\n\npublic class NoteParticle extends RegularParticle {\n    private double note;\n\n    /**\n     * Creates a new {@link NoteParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param note     The double value for note's color. Should be between 0 and 1 and also divisible by 1/24.\n     */\n    public NoteParticle(Location location, double note) {\n        super(Particle.NOTE, location);\n        this.note = note;\n    }\n\n    /**\n     * Creates a new {@link NoteParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param note     The int value for note's color. Should be between 0 and 24.\n     */\n    public NoteParticle(Location location, int note) {\n        super(Particle.NOTE, location);\n        this.note = note / 24D;\n    }\n", "public class NoteParticle extends RegularParticle {\n    private double note;\n\n    /**\n     * Creates a new {@link NoteParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param note     The double value for note's color. Should be between 0 and 1 and also divisible by 1/24.\n     */\n    public NoteParticle(Location location, double note) {\n        super(Particle.NOTE, location);\n        this.note = note;\n    }\n\n    /**\n     * Creates a new {@link NoteParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param note     The int value for note's color. Should be between 0 and 24.\n     */\n    public NoteParticle(Location location, int note) {\n        super(Particle.NOTE, location);\n        this.note = note / 24D;\n    }\n", "    public double getNote() {\n        return note;\n    }\n\n    public void setNote(int note) {\n        this.note = note / 24D;\n    }\n\n    public void setNote(double note) {\n        this.note = note;\n    }\n\n    @Override", "    public void setNote(double note) {\n        this.note = note;\n    }\n\n    @Override\n    public NoteParticle clone() {\n        return new NoteParticle(getLocation().clone(), note);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent particleSpawnEvent = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(particleSpawnEvent);\n", "    public void spawn() {\n        ParticleSpawnEvent particleSpawnEvent = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(particleSpawnEvent);\n\n        if (!particleSpawnEvent.isCancelled()) {\n            getLocation().getWorld().spawnParticle(Particle.NOTE, getLocation(), 0, note, 0, 0, 1);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/DirectionalParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.util.Vector;\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\nimport net.gerasiov.particleapi.particles.types.DirectionalParticleTypes;\n\nimport java.util.function.Predicate;", "\nimport java.util.function.Predicate;\n\npublic class DirectionalParticle extends RegularParticle {\n\n    private Vector direction;\n    private double speed;\n\n    /**\n     * Creates a new {@link DirectionalParticle} object with the specified parameters.\n     *\n     * @param location   The start location of the particle. This is where it will spawn.\n     * @param direction  The direction in which the particle will travel.\n     * @param type       The particle type. Should be one of the {@link DirectionalParticleTypes} values.\n     * @param speed      The particle speed.\n     * @throws IllegalArgumentException If an invalid particle type is provided.\n     */\n    public DirectionalParticle(Particle type, Location location, Vector direction, double speed) {\n        super(type, location);", "        if (!DirectionalParticleTypes.contains(type)) {\n            throw new IllegalArgumentException(\"Invalid particle type provided.\");\n        }\n        this.direction = direction;\n        this.speed = speed;\n    }\n\n    public Vector getDirection() {\n        return this.direction;\n    }\n", "    public double getSpeed() {\n        return this.speed;\n    }\n\n    public void setDirection(Vector direction) {\n        this.direction = direction;\n    }\n\n    public void setSpeed(double speed) {\n        this.speed = speed;\n    }\n\n    @Override", "    public void setSpeed(double speed) {\n        this.speed = speed;\n    }\n\n    @Override\n    public DirectionalParticle clone() {\n        return new DirectionalParticle(getType(), getLocation().clone(), direction.clone(), speed);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 0, direction.getX(), direction.getY(), direction.getZ(), speed);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/RegularParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.plugin.PluginManager;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\n", "import net.gerasiov.particleapi.events.ParticleSpawnEvent;\n\nimport java.util.Collection;\nimport java.util.function.Predicate;\n\npublic class RegularParticle {\n    private final Particle type;\n    private Location location;\n\n    public RegularParticle(Particle type, Location location) {\n        this.type = type;\n        this.location = location;\n    }\n", "    public Particle getType() {\n        return type;\n    }\n\n    public Location getLocation() {\n        return location;\n    }\n\n    public void setLocation(Location location) {\n        this.location = location;\n    }\n", "    public void setLocation(Location location) {\n        this.location = location;\n    }\n\n    public RegularParticle clone() {\n        return new RegularParticle(type, location.clone());\n    }\n\n    public Collection<Entity> getNearbyEntities(double radiusX, double radiusY, double radiusZ) {\n        return location.getWorld().getNearbyEntities(location, radiusX, radiusY, radiusZ);\n    }\n\n    public Collection<Entity> getNearbyEntities(double radiusX, double radiusY, double radiusZ, Predicate<Entity> filter) {\n        return location.getWorld().getNearbyEntities(location, radiusX, radiusY, radiusZ, filter);\n    }\n", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            location.getWorld().spawnParticle(type, location, 1);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/BlockParticle.java", "chunked_list": ["package net.gerasiov.particleapi.particles;\n\nimport net.gerasiov.particleapi.events.ParticleSpawnEvent;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.block.data.BlockData;\nimport org.bukkit.inventory.ItemStack;\n\npublic class BlockParticle extends RegularParticle {\n    private final BlockData blockData;\n\n    /**\n     * Creates a new {@link BlockParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param blockData The {@link BlockData} for the particle.\n     */\n    public BlockParticle(Particle type, Location location, BlockData blockData) {\n        super(type, location);\n        this.blockData = blockData;\n    }\n", "\npublic class BlockParticle extends RegularParticle {\n    private final BlockData blockData;\n\n    /**\n     * Creates a new {@link BlockParticle} object with the specified parameters.\n     *\n     * @param location The location for the particle.\n     * @param blockData The {@link BlockData} for the particle.\n     */\n    public BlockParticle(Particle type, Location location, BlockData blockData) {\n        super(type, location);\n        this.blockData = blockData;\n    }\n", "    public BlockData getBlockData() {\n        return blockData;\n    }\n\n    @Override\n    public BlockParticle clone() {\n        return new BlockParticle(getType(), getLocation().clone(), blockData.clone());\n    }\n\n    @Override\n    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n", "    public void spawn() {\n        ParticleSpawnEvent event = new ParticleSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n\n        if (!event.isCancelled()) {\n            getLocation().getWorld().spawnParticle(getType(), getLocation(), 1, blockData);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/particles/types/DirectionalParticleTypes.java", "chunked_list": ["package net.gerasiov.particleapi.particles.types;\n\nimport org.bukkit.Particle;\n\npublic enum DirectionalParticleTypes {\n    BUBBLE_COLUMN_UP(Particle.BUBBLE_COLUMN_UP),\n    BUBBLE_POP(Particle.BUBBLE_POP),\n    CAMPFIRE_COZY_SMOKE(Particle.CAMPFIRE_COSY_SMOKE),\n    CAMPFIRE_SIGNAL_SMOKE(Particle.CAMPFIRE_SIGNAL_SMOKE),\n    CLOUD(Particle.CLOUD),\n    CRIT(Particle.CRIT),\n    CRIT_MAGIC(Particle.CRIT_MAGIC),\n    DAMAGE_INDICATOR(Particle.DAMAGE_INDICATOR),\n    DRAGON_BREATH(Particle.DRAGON_BREATH),\n    ELECTRIC_SPARK(Particle.ELECTRIC_SPARK),\n    ENCHANTMENT_TABLE(Particle.ENCHANTMENT_TABLE),\n    END_ROD(Particle.END_ROD),\n    EXPLOSION_NORMAL(Particle.EXPLOSION_NORMAL),\n    FIREWORKS_SPARK(Particle.FIREWORKS_SPARK),\n    FLAME(Particle.FLAME),\n    NAUTILUS(Particle.NAUTILUS),\n    PORTAL(Particle.PORTAL),\n    REVERSE_PORTAL(Particle.REVERSE_PORTAL),\n    SCRAPE(Particle.SCRAPE),\n    SCULK_CHARGE(Particle.SCULK_CHARGE),\n    SCULK_CHARGE_POP(Particle.SCULK_CHARGE_POP),\n    SCULK_SOUL(Particle.SCULK_SOUL),\n    SMALL_FLAME(Particle.SMALL_FLAME),\n    SMOKE_LARGE(Particle.SMOKE_LARGE),\n    SMOKE_NORMAL(Particle.SMOKE_NORMAL),\n    SOUL(Particle.SOUL),\n    SOUL_FIRE_FLAME(Particle.SOUL_FIRE_FLAME),\n    SPIT(Particle.SPIT),\n    SQUID_INK(Particle.SQUID_INK),\n    TOTEM(Particle.TOTEM),\n    WATER_BUBBLE(Particle.WATER_BUBBLE),\n    WATER_WAKE(Particle.WATER_WAKE),\n    WAX_OFF(Particle.WAX_OFF),\n    WAX_ON(Particle.WAX_ON);\n\n    private final Particle type;\n\n    DirectionalParticleTypes(Particle particle) {\n        this.type = particle;\n    }\n", "    public Particle getParticle() {\n        return type;\n    }\n\n    public static boolean contains(Particle particle) {\n        for (DirectionalParticleTypes directionalParticleTypes : DirectionalParticleTypes.values()) {\n            if (directionalParticleTypes.getParticle() == particle) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/events/ParticleConstructSpawnEvent.java", "chunked_list": ["package net.gerasiov.particleapi.events;\n\nimport net.gerasiov.particleapi.geometry.ParticleConstruct;\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.HandlerList;\n\npublic class ParticleConstructSpawnEvent extends Event implements Cancellable {\n    private final ParticleConstruct particleConstruct;\n    private boolean cancelled;\n    private static final HandlerList handlers = new HandlerList();\n\n    public ParticleConstructSpawnEvent(ParticleConstruct particleConstruct) {\n        this.particleConstruct = particleConstruct;\n    }\n", "    public ParticleConstruct getParticleConstruct() {\n        return particleConstruct;\n    }\n    \n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }   \n\n    @Override", "    public static HandlerList getHandlerList() {\n        return handlers;\n    }   \n\n    @Override\n    public boolean isCancelled() {\n        return cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancelled) {\n        this.cancelled = cancelled;\n    }\n}\n", "    public void setCancelled(boolean cancelled) {\n        this.cancelled = cancelled;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/events/ParticleSpawnEvent.java", "chunked_list": ["package net.gerasiov.particleapi.events;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\n\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.HandlerList;\n\npublic class ParticleSpawnEvent extends Event implements Cancellable {\n    private static final HandlerList handlers = new HandlerList();\n    private final RegularParticle particle;\n    private boolean cancelled;\n\n    public ParticleSpawnEvent(RegularParticle particle) {\n        this.particle = particle;\n    }\n", "public class ParticleSpawnEvent extends Event implements Cancellable {\n    private static final HandlerList handlers = new HandlerList();\n    private final RegularParticle particle;\n    private boolean cancelled;\n\n    public ParticleSpawnEvent(RegularParticle particle) {\n        this.particle = particle;\n    }\n\n    public RegularParticle getParticle() {\n        return particle;\n    }\n", "    public RegularParticle getParticle() {\n        return particle;\n    }\n\n    public static HandlerList getHandlerList() {\n        return handlers;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    @Override", "    public HandlerList getHandlers() {\n        return handlers;\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancelled) {\n        this.cancelled = cancelled;\n    }\n}\n", "    public void setCancelled(boolean cancelled) {\n        this.cancelled = cancelled;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleGroup.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\nimport net.gerasiov.particleapi.ParticleAPI;\nimport net.gerasiov.particleapi.ParticleSpawnInjector;\nimport net.gerasiov.particleapi.events.ParticleConstructSpawnEvent;\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\nimport net.gerasiov.particleapi.schemes.spawn.line.SpawnLineScheme;\nimport org.bukkit.Bukkit;\nimport org.bukkit.scheduler.BukkitRunnable;", "import org.bukkit.Bukkit;\nimport org.bukkit.scheduler.BukkitRunnable;\n\npublic class ParticleGroup implements ParticleConstruct{\n\n    private RegularParticle[] particles;\n\n    public ParticleGroup(RegularParticle[] particles) {\n        this.particles = particles;\n    }\n\n    public RegularParticle[] getParticles() {\n        return particles;\n    }\n", "    public RegularParticle getParticle(int index) {\n        return particles[index];\n    }\n\n    public void setParticles(RegularParticle[] particles) {\n        this.particles = particles;\n    }\n\n    public void setParticle(RegularParticle particle, int index) {particles[index] = particle;}\n\n    public ParticleGroup clone() {\n        return new ParticleGroup(particles.clone());\n    }\n", "    public void setParticle(RegularParticle particle, int index) {particles[index] = particle;}\n\n    public ParticleGroup clone() {\n        return new ParticleGroup(particles.clone());\n    }\n\n    public void spawn() {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        for (RegularParticle particle : particles) {\n            particle.spawn();\n        }\n    }\n\n    /**\n     * Spawn all particles in group with a period between each spawn.\n     *\n     * @param delay  Delay before the first spawn in ticks.\n     * @param period Period between every spawn in ticks.\n     * @param spawnScheme The spawn scheme for the group.\n     */", "        if (event.isCancelled()) return;\n        for (RegularParticle particle : particles) {\n            particle.spawn();\n        }\n    }\n\n    /**\n     * Spawn all particles in group with a period between each spawn.\n     *\n     * @param delay  Delay before the first spawn in ticks.\n     * @param period Period between every spawn in ticks.\n     * @param spawnScheme The spawn scheme for the group.\n     */", "    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[]> spawnScheme) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }", "            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n\n    /**\n     * Spawn all particles in group with a period between each spawn.\n     *\n     * @param delay    Delay before the first spawn in ticks.\n     * @param period   Period between every spawn in ticks.\n     * @param spawnScheme The spawn scheme for the group.\n     * @param injector An object that allows the user to inject their own code\n     */", "                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n\n    /**\n     * Spawn all particles in group with a period between each spawn.\n     *\n     * @param delay    Delay before the first spawn in ticks.\n     * @param period   Period between every spawn in ticks.\n     * @param spawnScheme The spawn scheme for the group.\n     * @param injector An object that allows the user to inject their own code\n     */", "    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[]> spawnScheme, ParticleSpawnInjector injector) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                injector.reply(index);", "            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                injector.reply(index);\n                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n}\n", "                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleConstruct.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\npublic interface ParticleConstruct {\n    void spawn();\n    ParticleConstruct clone();\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleLine.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.build.line.BuildLineScheme;\nimport org.bukkit.Location;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class ParticleLine extends ParticleArray {\n\n    /**\n     * Constructs a {@link ParticleLine} object representing a line of RegularParticles\n     * between the given start and end locations, with the given interval between RegularParticles.\n     *\n     * @param startLocation the starting {@link Location} of the line\n     * @param endLocation the ending {@link Location} of the line\n     * @param interval the desired distance between RegularParticles along the line\n     */\n    public ParticleLine(@NotNull Location startLocation, @NotNull Location endLocation, double interval, RegularParticle particle) {\n        super(startLocation, endLocation, interval);\n        setParticles(new BuildLineScheme(particle).buildLine(getLocations().length));\n    }\n\n    /**\n     * Constructs a {@link ParticleLine} object representing a line of RegularParticles\n     * between the given start and end locations, with the given interval between RegularParticles,\n     * and using the provided {@link BuildLineScheme} to define the particle effect to be displayed.\n     *\n     * @param startLocation the starting {@link Location} of the line\n     * @param endLocation the ending {@link Location} of the line\n     * @param interval the desired distance between RegularParticles along the line\n     * @param buildScheme the {@link BuildLineScheme} object, defining the particle effects to be displayed\n     */\n    public ParticleLine(@NotNull Location startLocation, @NotNull Location endLocation, double interval, BuildLineScheme buildScheme) {\n        super(startLocation, endLocation, interval);\n        setParticles(buildScheme.buildLine(getLocations().length));\n    }\n\n\n}\n", "public class ParticleLine extends ParticleArray {\n\n    /**\n     * Constructs a {@link ParticleLine} object representing a line of RegularParticles\n     * between the given start and end locations, with the given interval between RegularParticles.\n     *\n     * @param startLocation the starting {@link Location} of the line\n     * @param endLocation the ending {@link Location} of the line\n     * @param interval the desired distance between RegularParticles along the line\n     */\n    public ParticleLine(@NotNull Location startLocation, @NotNull Location endLocation, double interval, RegularParticle particle) {\n        super(startLocation, endLocation, interval);\n        setParticles(new BuildLineScheme(particle).buildLine(getLocations().length));\n    }\n\n    /**\n     * Constructs a {@link ParticleLine} object representing a line of RegularParticles\n     * between the given start and end locations, with the given interval between RegularParticles,\n     * and using the provided {@link BuildLineScheme} to define the particle effect to be displayed.\n     *\n     * @param startLocation the starting {@link Location} of the line\n     * @param endLocation the ending {@link Location} of the line\n     * @param interval the desired distance between RegularParticles along the line\n     * @param buildScheme the {@link BuildLineScheme} object, defining the particle effects to be displayed\n     */\n    public ParticleLine(@NotNull Location startLocation, @NotNull Location endLocation, double interval, BuildLineScheme buildScheme) {\n        super(startLocation, endLocation, interval);\n        setParticles(buildScheme.buildLine(getLocations().length));\n    }\n\n\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleRectangle.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\nimport net.gerasiov.particleapi.schemes.build.rectangle.BuildRectangleScheme;\nimport org.bukkit.Location;\nimport org.jetbrains.annotations.NotNull;\n\npublic class ParticleRectangle extends ParticleMatrix {\n    /**\n     * Creates a ParticleRectangle which will be in the upright position.\n     * The 2 locations provided should be the opposite corners of the rectangle.\n     *\n     * @param firstCorner        The first corner of the rectangle.\n     * @param oppositeCorner     The opposite to the first corner of the rectangle.\n     * @param verticalInterval   The initial interval between all particle locations. (Vertical in relation to matrix columns)\n     * @param horizontalInterval The initial horizontal interval between particles. (Horizontal in relation to matrix rows)\n     * @param buildScheme        The BuildRectangleScheme instance to create the RegularParticle[][]\n     */\n    public ParticleRectangle(@NotNull Location firstCorner, @NotNull Location oppositeCorner, double verticalInterval, double horizontalInterval, BuildRectangleScheme buildScheme) {\n        super(firstCorner, oppositeCorner, verticalInterval, horizontalInterval);\n        setParticles(buildScheme.buildRectangle(getLocations().length, getLocations()[0].length));\n    }\n\n    /**\n     * Creates a ParticleRectangle.\n     * The 3 locations provided should form a right angle. Order doesn't matter.\n     *\n     * @param firstCorner        The first corner of the rectangle.\n     * @param secondCorner       The second corner of the rectangle.\n     * @param thirdCorner        The third corner of the rectangle.\n     * @param verticalInterval   The initial interval between all particle locations. (Vertical in relation to matrix columns)\n     * @param horizontalInterval The initial horizontal interval between particles. (Horizontal in relation to matrix rows)\n     * @param buildScheme        The BuildRectangleScheme instance to create the RegularParticle[][]\n     */\n    public ParticleRectangle(@NotNull Location firstCorner, @NotNull Location secondCorner, @NotNull Location thirdCorner, double verticalInterval, double horizontalInterval, BuildRectangleScheme buildScheme) {\n        super(firstCorner, secondCorner, thirdCorner, verticalInterval, horizontalInterval);\n        setParticles(buildScheme.buildRectangle(getParticles().length, getLocations()[0].length));\n    }\n\n\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleMatrix.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\nimport net.gerasiov.particleapi.ParticleAPI;\nimport net.gerasiov.particleapi.ParticleSpawnInjector;\nimport net.gerasiov.particleapi.events.ParticleConstructSpawnEvent;\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.scheduler.BukkitRunnable;", "import org.bukkit.Location;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport org.bukkit.util.Vector;\nimport org.jetbrains.annotations.NotNull;\n\npublic class ParticleMatrix implements ParticleConstruct {\n    private RegularParticle[][] particles;\n    private Location[][] locations;\n    private Location center;\n    private double verticalInterval;\n    private double horizontalInterval;\n\n    /**\n     * Creates a ParticleMatrix which will be represented with an upright rectangle.\n     * The 2 locations provided should be the opposite corners of the rectangle.\n     *\n     * @param firstCorner        The first corner of the rectangle.\n     * @param oppositeCorner     The opposite to the first corner of the rectangle.\n     * @param verticalInterval   The initial interval between all particle locations. (Vertical in relation to matrix columns)\n     * @param horizontalInterval The initial horizontal interval between particles. (Horizontal in relation to matrix rows)\n     */\n    public ParticleMatrix(@NotNull Location firstCorner, @NotNull Location oppositeCorner, double verticalInterval, double horizontalInterval) {", "        if (verticalInterval <= 0 || horizontalInterval <= 0) {\n            throw new IllegalArgumentException(\"Intervals must be greater than 0\");\n        }\n        fillLocationMatrix(new Location(oppositeCorner.getWorld(), oppositeCorner.getX(), firstCorner.getY(), oppositeCorner.getZ()), firstCorner, oppositeCorner, verticalInterval, horizontalInterval);\n    }\n\n    /**\n     * Creates a ParticleMatrix which will be represented by a rectangle.\n     * The 3 locations provided should form a right angle. Order doesn't matter.\n     *\n     * @param firstCorner        The first corner of the rectangle.\n     * @param secondCorner       The second corner of the rectangle.\n     * @param thirdCorner        The third corner of the rectangle.\n     * @param verticalInterval   The initial interval between all particle locations. (Vertical in relation to matrix columns)\n     * @param horizontalInterval The initial horizontal interval between particles. (Horizontal in relation to matrix rows)\n     */\n    public ParticleMatrix(@NotNull Location firstCorner, @NotNull Location secondCorner, @NotNull Location thirdCorner, double verticalInterval, double horizontalInterval) {", "        if (verticalInterval <= 0 || horizontalInterval <= 0) {\n            throw new IllegalArgumentException(\"Interval must be greater than 0\");\n        }\n        double distance12, distance13, distance23;\n        distance12 = firstCorner.distance(secondCorner);\n        distance13 = firstCorner.distance(thirdCorner);\n        distance23 = secondCorner.distance(thirdCorner);\n        if (doubleEquals(distance12 * distance12 + distance13 * distance13, distance23 * distance23)) {\n            fillLocationMatrix(firstCorner, secondCorner, thirdCorner, verticalInterval, horizontalInterval);\n        } else if (doubleEquals(distance12 * distance12 + distance23 * distance23, distance13 * distance13)) {\n            fillLocationMatrix(secondCorner, firstCorner, thirdCorner, verticalInterval, horizontalInterval);", "        } else if (doubleEquals(distance12 * distance12 + distance23 * distance23, distance13 * distance13)) {\n            fillLocationMatrix(secondCorner, firstCorner, thirdCorner, verticalInterval, horizontalInterval);\n        } else if (doubleEquals(distance13 * distance13 + distance23 * distance23, distance12 * distance12)){\n            fillLocationMatrix(thirdCorner, firstCorner, secondCorner, verticalInterval, horizontalInterval);\n        } else {\n            throw new IllegalArgumentException(\"Locations don't form a rectangle\");\n        }\n    }\n\n    private ParticleMatrix(RegularParticle[][] particles, Location[][] locations, Location center, double verticalInterval, double horizontalInterval) {\n        this.particles = particles;\n        this.locations = locations;\n        this.center = center;\n        this.verticalInterval = verticalInterval;\n        this.horizontalInterval = horizontalInterval;\n    }\n\n    /**\n     * This function is used to compare 2 doubles for equality.\n     */\n    private boolean doubleEquals(double a, double b) {\n        double epsilon = 1E-6;\n        return Math.abs(a - b) < epsilon;\n    }\n\n    /**\n     * Calculates the real interval based on 2 locations and the initial interval.\n     *\n     * @param startLocation The first location.\n     * @param endLocation   The second location.\n     * @param interval      The initial interval.\n     * @return              The correct interval\n     */", "    public static double calculateRealInterval(Location startLocation, Location endLocation, double interval) {\n        double distance = endLocation.toVector().subtract(startLocation.toVector()).length();\n        double numberOfParticles = Math.round(distance / interval);\n        return distance / numberOfParticles;\n    }\n\n    private void fillLocationMatrix(Location l1, Location l2, Location l3, double verticalInterval, double horizontalInterval) {\n        center = l1.clone();\n        // Vertical\n        verticalInterval = calculateRealInterval(l1, l2, verticalInterval);\n        this.verticalInterval = verticalInterval;\n        Vector verticalDirectionVector = l2.clone().toVector().subtract(l1.toVector()).normalize().multiply(verticalInterval);\n        double distance = l2.distance(l1);\n        int verticalNumberOfParticles = (int) Math.ceil(distance / verticalInterval);\n        center.add(verticalDirectionVector.clone().multiply(((double) verticalNumberOfParticles) / 2));\n\n        // Horizontal\n        horizontalInterval = calculateRealInterval(l1, l3, horizontalInterval);\n        this.horizontalInterval = horizontalInterval;\n        Vector horizontalDirectionVector = l3.clone().toVector().subtract(l1.toVector()).normalize().multiply(horizontalInterval);\n        distance = l3.distance(l1);\n        int horizontalNumberOfParticles = (int) Math.ceil(distance / horizontalInterval);\n        center.add(horizontalDirectionVector.clone().multiply(((double) horizontalNumberOfParticles) / 2));\n\n        locations = new Location[horizontalNumberOfParticles][verticalNumberOfParticles];", "        for (int i = 0; i < horizontalNumberOfParticles; i++) {\n            for (int j = 0; j < verticalNumberOfParticles; j++) {\n                locations[i][j] = l1.clone().add(horizontalDirectionVector.clone().multiply(i)).add(verticalDirectionVector.clone().multiply(j));\n            }\n        }\n\n        particles = new RegularParticle[horizontalNumberOfParticles][verticalNumberOfParticles];\n    }\n\n    public Location getCenter() {\n        return center;\n    }\n\n    public RegularParticle[][] getParticles() {\n        return particles;\n    }\n", "    public Location getCenter() {\n        return center;\n    }\n\n    public RegularParticle[][] getParticles() {\n        return particles;\n    }\n\n    public RegularParticle getParticle(int row, int column) {\n        return particles[row][column];\n    }\n\n    public Location[][] getLocations() {\n        return locations;\n    }\n", "    public RegularParticle getParticle(int row, int column) {\n        return particles[row][column];\n    }\n\n    public Location[][] getLocations() {\n        return locations;\n    }\n\n    public Location getLocation(int row, int column) {\n        return locations[row][column];\n    }\n", "    public Location getLocation(int row, int column) {\n        return locations[row][column];\n    }\n\n    public void setParticle(RegularParticle particle, int row, int column) {\n        RegularParticle newParticle = particle.clone();\n        newParticle.setLocation(locations[row][column]);\n        particles[row][column] = newParticle;\n    }\n\n    public void setParticles(RegularParticle[][] particles) {", "    public void setParticles(RegularParticle[][] particles) {\n        if (particles.length != locations.length || particles[0].length != locations[0].length) {\n            throw new IllegalArgumentException(\"RegularParticle[][] lengths must be equal to Location[][] lengths\");\n        }\n\n        for (int i = 0; i < locations.length; i++) {\n            for (int j = 0; j < locations[0].length; j++) {\n                RegularParticle clonedParticle = particles[i][j].clone();\n                clonedParticle.setLocation(locations[i][j]);\n                this.particles[i][j] = clonedParticle;\n            }\n        }\n    }\n", "    public void rotate(double xRotation, double yRotation, double zRotation) {\n        for (int i = 0; i < locations.length; i++) {\n            for (int j = 0; j < locations[0].length; j++) {\n                locations[i][j] = center.clone().add(locations[i][j].clone().subtract(center.clone()).toVector().rotateAroundX(xRotation).rotateAroundY(yRotation).rotateAroundZ(zRotation));\n            }\n        }\n        updateParticleLocations();\n    }\n\n    public void rotateAroundLocation(Location rotationCenter, double xRotation, double yRotation, double zRotation) {\n        for (int i = 0; i < locations.length; i++) {", "    public void rotateAroundLocation(Location rotationCenter, double xRotation, double yRotation, double zRotation) {\n        for (int i = 0; i < locations.length; i++) {\n            for (int j = 0; j < locations[0].length; j++) {\n                locations[i][j] = rotationCenter.clone().add(locations[i][j].clone().subtract(rotationCenter.clone()).toVector().rotateAroundX(xRotation).rotateAroundY(yRotation).rotateAroundZ(zRotation));\n            }\n        }\n        updateParticleLocations();\n    }\n\n    private void updateParticleLocations() {\n        for (int i = 0; i < particles.length; i++) {", "        for (int i = 0; i < particles.length; i++) {\n            for (int j = 0; j < particles[0].length; j++) {\n                particles[i][j].setLocation(locations[i][j]);\n            }\n        }\n    }\n\n    @Override\n    public ParticleMatrix clone() {\n        return new ParticleMatrix(particles.clone(), locations.clone(), center.clone(), verticalInterval, horizontalInterval);\n    }\n\n    @Override", "    public ParticleMatrix clone() {\n        return new ParticleMatrix(particles.clone(), locations.clone(), center.clone(), verticalInterval, horizontalInterval);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        for (int i = 0; i < particles.length; i++) {\n            for (int j = 0; j < particles[0].length; j++) {", "        if (event.isCancelled()) return;\n        for (int i = 0; i < particles.length; i++) {\n            for (int j = 0; j < particles[0].length; j++) {\n                if (particles[i][j] != null) {\n                    particles[i][j].spawn();\n                }\n            }\n        }\n    }\n\n    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[][]> spawnScheme) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);", "    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[][]> spawnScheme) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }", "            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n", "                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n\n    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[][]> spawnScheme, ParticleSpawnInjector injector) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override", "        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                injector.reply(index);", "                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/geometry/ParticleArray.java", "chunked_list": ["package net.gerasiov.particleapi.geometry;\n\nimport net.gerasiov.particleapi.ParticleAPI;\nimport net.gerasiov.particleapi.ParticleSpawnInjector;\nimport net.gerasiov.particleapi.events.ParticleConstructSpawnEvent;\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.scheduler.BukkitRunnable;", "import org.bukkit.Location;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport org.bukkit.util.Vector;\nimport org.jetbrains.annotations.NotNull;\n\npublic class ParticleArray implements ParticleConstruct {\n    private Location startLocation;\n    private Location endLocation;\n    private double interval;\n\n    private RegularParticle[] particles;\n\n    private Location[] locations;\n\n    public ParticleArray(@NotNull Location startLocation, @NotNull Location endLocation, double interval) {\n        this.startLocation = startLocation;\n        this.endLocation = endLocation;", "        if (interval <= 0) {\n            throw new IllegalArgumentException(\"Interval must be greater than 0\");\n        }\n        this.interval = calculateRealInterval(startLocation, endLocation, interval);\n        fillLocationArray();\n    }\n\n    /**\n     * Calculates the real interval based on 2 locations and the initial interval.\n     *\n     * @param startLocation The first location.\n     * @param endLocation   The second location.\n     * @param interval      The initial interval.\n     * @return The correct interval\n     */", "    public static double calculateRealInterval(@NotNull Location startLocation, @NotNull Location endLocation, double interval) {\n        double distance = endLocation.toVector().subtract(startLocation.toVector()).length();\n        double numberOfParticles = Math.round(distance / interval);\n        return distance / numberOfParticles;\n    }\n\n    /**\n     * Based on instance's fields creates and fills an array with locations for the particles to be spawned in.\n     */\n    private void fillLocationArray() {\n        Vector directionVector = endLocation.toVector().subtract(startLocation.toVector()).normalize().multiply(interval);\n        double distance = endLocation.distance(startLocation);\n        int numberOfParticles = (int) Math.ceil(distance / interval);\n\n        locations = new Location[numberOfParticles];\n        particles = new RegularParticle[numberOfParticles];\n", "        for (int i = 0; i < numberOfParticles; i++) {\n            locations[i] = startLocation.clone().add(directionVector.clone().multiply(i));\n        }\n    }\n\n    private void updateParticleLocations() {\n        for (int i = 0; i < particles.length; i++) {\n            particles[i].setLocation(locations[i]);\n        }\n    }\n", "    public Location getStartLocation() {\n        return startLocation;\n    }\n\n    public void setStartLocation(Location startLocation) {\n        this.startLocation = startLocation;\n        interval = calculateRealInterval(startLocation, endLocation, interval);\n        fillLocationArray();\n    }\n\n    public Location getEndLocation() {\n        return endLocation;\n    }\n", "    public Location getEndLocation() {\n        return endLocation;\n    }\n\n    public void setEndLocation(Location endLocation) {\n        this.endLocation = endLocation;\n        interval = calculateRealInterval(startLocation, endLocation, interval);\n        fillLocationArray();\n    }\n\n    public double getInterval() {\n        return interval;\n    }\n", "    public double getInterval() {\n        return interval;\n    }\n\n    public void setInterval(double interval) {\n        this.interval = interval;\n        this.interval = calculateRealInterval(startLocation, endLocation, interval);\n        fillLocationArray();\n    }\n\n    public Location[] getLocations() {\n        return locations;\n    }\n", "    public Location getLocation(int i) {\n        return locations[i];\n    }\n\n    public RegularParticle[] getParticles() {\n        return particles;\n    }\n\n    public RegularParticle getParticle(int i) {\n        return particles[i];\n    }\n", "    public RegularParticle getParticle(int i) {\n        return particles[i];\n    }\n\n    public void setParticles(RegularParticle[] particles) {\n        if (particles.length != locations.length) {\n            throw new IllegalArgumentException(\"RegularParticle[] length must be equal to Location[] length\");\n        }\n\n        for (int i = 0; i < particles.length; i++) {\n            RegularParticle clonedParticle = particles[i].clone();\n            clonedParticle.setLocation(locations[i]);\n            this.particles[i] = clonedParticle;\n        }\n    }\n", "        for (int i = 0; i < particles.length; i++) {\n            RegularParticle clonedParticle = particles[i].clone();\n            clonedParticle.setLocation(locations[i]);\n            this.particles[i] = clonedParticle;\n        }\n    }\n\n    public void setParticle(RegularParticle particle, int i) {\n        RegularParticle copyParticle = particle.clone();\n        copyParticle.setLocation(locations[i]);\n        this.particles[i] = copyParticle;\n    }\n", "    public void rotate(double xRotation, double yRotation, double zRotation) {\n        Location center = locations.length % 2 == 0 ? locations[locations.length / 2].clone().add(locations[locations.length / 2 + 1].clone().subtract(locations[locations.length / 2].clone()).multiply(0.5)) : locations[locations.length / 2 + 1].clone();\n        for (int i = 0; i < locations.length; i++) {\n            locations[i] = center.clone().add(locations[i].clone().subtract(center.clone()).toVector().rotateAroundX(xRotation).rotateAroundY(yRotation).rotateAroundZ(zRotation));\n        }\n        updateParticleLocations();\n    }\n\n    public void rotateAroundLocation(Location rotationCenter, double xRotation, double yRotation, double zRotation) {\n        for (int i = 0; i < locations.length; i++) {\n            locations[i] = rotationCenter.clone().add(locations[i].clone().subtract(rotationCenter.clone()).toVector().rotateAroundX(xRotation).rotateAroundY(yRotation).rotateAroundZ(zRotation));\n        }\n        updateParticleLocations();\n    }\n\n    @Override", "    public void rotateAroundLocation(Location rotationCenter, double xRotation, double yRotation, double zRotation) {\n        for (int i = 0; i < locations.length; i++) {\n            locations[i] = rotationCenter.clone().add(locations[i].clone().subtract(rotationCenter.clone()).toVector().rotateAroundX(xRotation).rotateAroundY(yRotation).rotateAroundZ(zRotation));\n        }\n        updateParticleLocations();\n    }\n\n    @Override\n    public ParticleArray clone() {\n        return new ParticleArray(startLocation.clone(), endLocation.clone(), interval);\n    }\n\n    @Override", "    public ParticleArray clone() {\n        return new ParticleArray(startLocation.clone(), endLocation.clone(), interval);\n    }\n\n    @Override\n    public void spawn() {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        for (RegularParticle particle : particles) {\n            particle.spawn();\n        }\n    }\n\n    /**\n     * Spawn all particles in the array with a period between each spawn.\n     *\n     * @param delay       Delay before the first spawn in ticks.\n     * @param period      Period between every spawn in ticks.\n     * @param spawnScheme A scheme that decides the order in which to spawn particles.\n     */", "        if (event.isCancelled()) return;\n        for (RegularParticle particle : particles) {\n            particle.spawn();\n        }\n    }\n\n    /**\n     * Spawn all particles in the array with a period between each spawn.\n     *\n     * @param delay       Delay before the first spawn in ticks.\n     * @param period      Period between every spawn in ticks.\n     * @param spawnScheme A scheme that decides the order in which to spawn particles.\n     */", "    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[]> spawnScheme) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }", "            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n\n    /**\n     * Spawn all particles in the array with a period between each spawn.\n     *\n     * @param delay       Delay before the first spawn in ticks.\n     * @param period      Period between every spawn in ticks.\n     * @param spawnScheme A scheme that decides the order in which to spawn particles.\n     * @param injector    An object that allows the user to inject their own code\n     */", "                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n\n    /**\n     * Spawn all particles in the array with a period between each spawn.\n     *\n     * @param delay       Delay before the first spawn in ticks.\n     * @param period      Period between every spawn in ticks.\n     * @param spawnScheme A scheme that decides the order in which to spawn particles.\n     * @param injector    An object that allows the user to inject their own code\n     */", "    public void spawnWithDelays(int delay, int period, SpawnScheme<RegularParticle[]> spawnScheme, ParticleSpawnInjector injector) {\n        ParticleConstructSpawnEvent event = new ParticleConstructSpawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        new BukkitRunnable() {\n            int index = 0;\n\n            @Override\n            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                injector.reply(index);", "            public void run() {\n                if (event.isCancelled()) {\n                    cancel();\n                    return;\n                }\n                injector.reply(index);\n                for (RegularParticle particle : spawnScheme.getNextParticles(index, particles)) {\n                    particle.spawn();\n                }\n                index++;\n                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n}\n", "                if (spawnScheme.isFinished(index, particles)) {\n                    cancel();\n                }\n            }\n        }.runTaskTimer(ParticleAPI.instance, delay, period);\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/SpawnScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes;\n\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\n\n/**\n * Is responsible for how particles in ParticleGroups spawn\n * @param <T> Used to declare whether the ParticleGroup uses 1 dimension, 2 or 3.\n *          Possible uses: RegularParticle[], RegularParticle[][], RegularParticle[][][]\n */\npublic interface SpawnScheme<T> {\n    RegularParticle[] getNextParticles(int index, T spawnParticles);\n    boolean isFinished(int index, T particles);\n}\n", " *          Possible uses: RegularParticle[], RegularParticle[][], RegularParticle[][][]\n */\npublic interface SpawnScheme<T> {\n    RegularParticle[] getNextParticles(int index, T spawnParticles);\n    boolean isFinished(int index, T particles);\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/spawn/line/SpawnLineScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.spawn.line;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\n\npublic class SpawnLineScheme implements SpawnScheme<RegularParticle[]> {\n    @Override\n    public RegularParticle[] getNextParticles(int index, RegularParticle[] spawnParticles) {\n        return new RegularParticle[] { spawnParticles[index] };\n    }\n\n    @Override", "    public boolean isFinished(int index, RegularParticle[] spawnParticles) {\n        return index == spawnParticles.length;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/spawn/matrix/SpawnMatrixBTScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.spawn.matrix;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\n\npublic class SpawnMatrixBTScheme implements SpawnScheme<RegularParticle[][]> {\n    @Override\n    public RegularParticle[] getNextParticles(int index, RegularParticle[][] spawnParticles) {\n        RegularParticle[] particles = new RegularParticle[spawnParticles[0].length];\n        for (int j = 0; j < spawnParticles[0].length; j++) particles[j] = spawnParticles[index][j];\n        return particles;\n    }\n\n    @Override", "        for (int j = 0; j < spawnParticles[0].length; j++) particles[j] = spawnParticles[index][j];\n        return particles;\n    }\n\n    @Override\n    public boolean isFinished(int index, RegularParticle[][] particles) {\n        return index == particles.length;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/spawn/matrix/SpawnMatrixLRScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.spawn.matrix;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.SpawnScheme;\n\npublic class SpawnMatrixLRScheme implements SpawnScheme<RegularParticle[][]> {\n\n    @Override\n    public RegularParticle[] getNextParticles(int index, RegularParticle[][] spawnParticles) {\n        RegularParticle[] particles = new RegularParticle[spawnParticles.length];\n        for (int i = 0; i < spawnParticles.length; i++) particles[i] = spawnParticles[i][index];\n        return particles;\n    }\n\n    @Override", "        for (int i = 0; i < spawnParticles.length; i++) particles[i] = spawnParticles[i][index];\n        return particles;\n    }\n\n    @Override\n    public boolean isFinished(int index, RegularParticle[][] particles) {\n        return index == particles[0].length;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/build/BuildScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.build;\n\npublic interface BuildScheme {\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/build/rectangle/BuildRectangleScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.build.rectangle;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.build.BuildScheme;\n\npublic class BuildRectangleScheme implements BuildScheme {\n    private final RegularParticle particle;\n\n    public BuildRectangleScheme(RegularParticle particle){this.particle = particle;}\n\n    public RegularParticle[][] buildRectangle(int length, int length2) {\n        RegularParticle[][] particles = new RegularParticle[length][length2];\n", "        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length2; j++) {\n                RegularParticle clonedParticle = particle.clone();\n                particles[i][j] = clonedParticle;\n            }\n        }\n\n        return particles;\n    }\n}\n"]}
{"filename": "src/main/java/net/gerasiov/particleapi/schemes/build/line/BuildLineScheme.java", "chunked_list": ["package net.gerasiov.particleapi.schemes.build.line;\n\nimport net.gerasiov.particleapi.particles.RegularParticle;\nimport net.gerasiov.particleapi.schemes.build.BuildScheme;\nimport org.bukkit.Location;\nimport org.jetbrains.annotations.NotNull;\n\npublic class BuildLineScheme implements BuildScheme {\n    \n    private final RegularParticle particle;\n\n    public BuildLineScheme(RegularParticle particle) {\n        this.particle = particle;\n    }\n\n    /**\n     * Creates a RegularParticle array in a specific way and assigns a location to each.\n     *\n     * @param length The length of the needed line.\n     * @return The filled RegularParticle array\n     */\n    public RegularParticle[] buildLine(int length) {\n\n        RegularParticle[] particles = new RegularParticle[length];\n", "        for (int i = 0; i < length; i++) {\n            RegularParticle clonedParticle = particle.clone();\n            particles[i] = clonedParticle;\n        }\n        return particles;\n    }\n}\n"]}
