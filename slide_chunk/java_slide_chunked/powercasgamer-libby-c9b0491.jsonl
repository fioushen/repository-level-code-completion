{"filename": "nukkit/src/main/java/net/byteflux/libby/NukkitLibraryManager.java", "chunked_list": ["package net.byteflux.libby;\n\nimport cn.nukkit.plugin.Plugin;\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;\nimport net.byteflux.libby.logging.adapters.NukkitLogAdapter;\n\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\n\nimport static java.util.Objects.requireNonNull;", "\nimport static java.util.Objects.requireNonNull;\n\n/**\n * A runtime dependency manager for Nukkit plugins.\n */\npublic class NukkitLibraryManager extends LibraryManager {\n\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Nukkit library manager.\n     *\n     * @param plugin the plugin to manage\n     */\n    public NukkitLibraryManager(final Plugin plugin) {\n        this(plugin, \"libs\");\n    }\n\n    /**\n     * Creates a new Nukkit library manager.\n     *\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public NukkitLibraryManager(final Plugin plugin, final String directoryName) {\n        super(new NukkitLogAdapter(requireNonNull(plugin, \"plugin\").getLogger()), plugin.getDataFolder().toPath(), directoryName);\n        this.classLoader = new URLClassLoaderHelper((URLClassLoader) plugin.getClass().getClassLoader(), this);\n    }\n\n    /**\n     * Adds a file to the Nukkit plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n"]}
{"filename": "nukkit/src/main/java/net/byteflux/libby/logging/adapters/NukkitLogAdapter.java", "chunked_list": ["package net.byteflux.libby.logging.adapters;\n\nimport cn.nukkit.plugin.PluginLogger;\nimport net.byteflux.libby.logging.LogLevel;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Logging adapter that logs to a Nukkit plugin logger.\n */\npublic class NukkitLogAdapter implements LogAdapter {\n\n    /**\n     * Nukkit plugin logger\n     */\n    private final PluginLogger logger;\n\n    /**\n     * Creates a new Nukkit log adapter that logs to a {@link PluginLogger}.\n     *\n     * @param logger the plugin logger to wrap\n     */\n    public NukkitLogAdapter(final PluginLogger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the Nukkit plugin logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", " * Logging adapter that logs to a Nukkit plugin logger.\n */\npublic class NukkitLogAdapter implements LogAdapter {\n\n    /**\n     * Nukkit plugin logger\n     */\n    private final PluginLogger logger;\n\n    /**\n     * Creates a new Nukkit log adapter that logs to a {@link PluginLogger}.\n     *\n     * @param logger the plugin logger to wrap\n     */\n    public NukkitLogAdapter(final PluginLogger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the Nukkit plugin logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", "    public void log(final LogLevel level, final String message) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message);\n                break;\n            case INFO:\n                this.logger.info(message);\n                break;\n            case WARN:\n                this.logger.warning(message);\n                break;\n            case ERROR:\n                this.logger.error(message);\n                break;\n        }\n    }\n\n    /**\n     * Logs a message and stack trace with the provided level to the Nukkit\n     * plugin logger.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */\n    @Override", "    public void log(final LogLevel level, final String message, final Throwable throwable) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message, throwable);\n                break;\n            case INFO:\n                this.logger.info(message, throwable);\n                break;\n            case WARN:\n                this.logger.warning(message, throwable);\n                break;\n            case ERROR:\n                this.logger.error(message, throwable);\n                break;\n        }\n    }\n}\n"]}
{"filename": "bungee/src/main/java/net/byteflux/libby/BungeeLibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;", "\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;\nimport net.byteflux.libby.logging.adapters.JDKLogAdapter;\nimport net.md_5.bungee.api.plugin.Plugin;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\n", "import java.nio.file.Path;\n\n/**\n * A runtime dependency manager for Bungee plugins.\n */\npublic class BungeeLibraryManager extends LibraryManager {\n\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Bungee library manager.\n     *\n     * @param plugin the plugin to manage\n     */\n    public BungeeLibraryManager(final Plugin plugin) {\n        this(plugin, \"libs\");\n    }\n\n    /**\n     * Creates a new Bungee library manager.\n     *\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public BungeeLibraryManager(final Plugin plugin, final String directoryName) {\n        super(new JDKLogAdapter(requireNonNull(plugin, \"plugin\").getLogger()), plugin.getDataFolder().toPath(), directoryName);\n        this.classLoader = new URLClassLoaderHelper((URLClassLoader) plugin.getClass().getClassLoader(), this);\n    }\n\n    /**\n     * Adds a file to the Bungee plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n"]}
{"filename": "velocity/src/main/java/net/byteflux/libby/VelocityLibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport com.velocitypowered.api.plugin.PluginManager;", "\nimport com.velocitypowered.api.plugin.PluginManager;\nimport net.byteflux.libby.logging.adapters.SLF4JLogAdapter;\nimport org.jetbrains.annotations.NotNull;\nimport org.slf4j.Logger;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.nio.file.Path;\n", "import java.nio.file.Path;\n\n/**\n * A runtime dependency manager for Velocity plugins.\n */\npublic class VelocityLibraryManager<T> extends LibraryManager {\n\n    /**\n     * Velocity plugin manager used for adding files to the plugin's classpath\n     */\n    private final PluginManager pluginManager;\n\n    /**\n     * The plugin instance required by the plugin manager to add files to the\n     * plugin's classpath\n     */\n    private final T plugin;\n\n    /**\n     * Creates a new Velocity library manager.\n     *\n     * @param logger        the plugin logger\n     * @param dataDirectory plugin's data directory\n     * @param pluginManager Velocity plugin manager\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public VelocityLibraryManager(final Logger logger,\n                                  final Path dataDirectory,\n                                  final PluginManager pluginManager,\n                                  final T plugin,\n                                  final String directoryName) {\n\n        super(new SLF4JLogAdapter(logger), dataDirectory, directoryName);\n        this.pluginManager = requireNonNull(pluginManager, \"pluginManager\");\n        this.plugin = requireNonNull(plugin, \"plugin\");\n    }\n\n    /**\n     * Creates a new Velocity library manager.\n     *\n     * @param logger        the plugin logger\n     * @param dataDirectory plugin's data directory\n     * @param pluginManager Velocity plugin manager\n     * @param plugin        the plugin to manage\n     */\n    public VelocityLibraryManager(final Logger logger,\n                                  final Path dataDirectory,\n                                  final PluginManager pluginManager,\n                                  final T plugin) {\n        this(logger, dataDirectory, pluginManager, plugin, \"libs\");\n    }\n\n    /**\n     * Adds a file to the Velocity plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final @NotNull Path file) {\n        this.pluginManager.addToClasspath(this.plugin, file);\n    }\n}\n"]}
{"filename": "slf4j/src/main/java/net/byteflux/libby/logging/adapters/SLF4JLogAdapter.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging.adapters;\n\nimport net.byteflux.libby.logging.LogLevel;", "\nimport net.byteflux.libby.logging.LogLevel;\nimport org.slf4j.Logger;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Logging adapter that logs to a SLF4J logger.\n */\npublic class SLF4JLogAdapter implements LogAdapter {\n    /**\n     * SLF4J logger\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a new SLF4J log adapter that logs to a {@link Logger}.\n     *\n     * @param logger the SLF4J logger to wrap\n     */\n    public SLF4JLogAdapter(final Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the SLF4J logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", " */\npublic class SLF4JLogAdapter implements LogAdapter {\n    /**\n     * SLF4J logger\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a new SLF4J log adapter that logs to a {@link Logger}.\n     *\n     * @param logger the SLF4J logger to wrap\n     */\n    public SLF4JLogAdapter(final Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the SLF4J logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", "    public void log(final LogLevel level, final String message) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message);\n                break;\n            case INFO:\n                this.logger.info(message);\n                break;\n            case WARN:\n                this.logger.warn(message);\n                break;\n            case ERROR:\n                this.logger.error(message);\n                break;\n        }\n    }\n\n    /**\n     * Logs a message and stack trace with the provided level to the SLF4J\n     * logger.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */\n    @Override", "    public void log(final LogLevel level, final String message, final Throwable throwable) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message, throwable);\n                break;\n            case INFO:\n                this.logger.info(message, throwable);\n                break;\n            case WARN:\n                this.logger.warn(message, throwable);\n                break;\n            case ERROR:\n                this.logger.error(message, throwable);\n                break;\n        }\n    }\n}\n"]}
{"filename": "bukkit/src/main/java/net/byteflux/libby/BukkitLibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;", "\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;\nimport net.byteflux.libby.logging.adapters.JDKLogAdapter;\nimport org.bukkit.plugin.Plugin;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\n", "import java.nio.file.Path;\n\n/**\n * A runtime dependency manager for Bukkit plugins.\n */\npublic class BukkitLibraryManager extends LibraryManager {\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Bukkit library manager.\n     *\n     * @param plugin the plugin to manage\n     */\n    public BukkitLibraryManager(final Plugin plugin) {\n        this(plugin, \"libs\");\n    }\n\n    /**\n     * Creates a new Bukkit library manager.\n     *\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public BukkitLibraryManager(final Plugin plugin, final String directoryName) {\n        super(new JDKLogAdapter(requireNonNull(plugin, \"plugin\").getLogger()), plugin.getDataFolder().toPath(), directoryName);\n        this.classLoader = new URLClassLoaderHelper((URLClassLoader) plugin.getClass().getClassLoader(), this);\n    }\n\n    /**\n     * Adds a file to the Bukkit plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n"]}
{"filename": "paper/src/main/java/net/byteflux/libby/PaperLibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;", "\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;\nimport net.byteflux.libby.logging.adapters.JDKLogAdapter;\nimport org.bukkit.plugin.Plugin;\nimport org.jetbrains.annotations.NotNull;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.lang.reflect.Field;\nimport java.net.URLClassLoader;", "import java.lang.reflect.Field;\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\n\n/**\n * A runtime dependency manager for Paper Plugins. (Not to be confused with bukkit plugins loaded on paper)\n * See: <a href=\"https://docs.papermc.io/paper/dev/getting-started/paper-plugins\">Paper docs</a>\n *\n * @since 2.0.0\n */\npublic class PaperLibraryManager extends LibraryManager {\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Paper library manager.\n     *\n     * @param plugin the plugin to manage\n     */\n    public PaperLibraryManager(final Plugin plugin) {\n        this(plugin, \"libs\");\n    }\n\n    /**\n     * Creates a new Paper library manager.\n     *\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public PaperLibraryManager(final Plugin plugin, final String directoryName) {\n        super(new JDKLogAdapter(requireNonNull(plugin, \"plugin\").getLogger()), plugin.getDataFolder().toPath(), directoryName);\n\n        final ClassLoader cl = plugin.getClass().getClassLoader();\n        final Class<?> paperClClazz;\n", " * @since 2.0.0\n */\npublic class PaperLibraryManager extends LibraryManager {\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Paper library manager.\n     *\n     * @param plugin the plugin to manage\n     */\n    public PaperLibraryManager(final Plugin plugin) {\n        this(plugin, \"libs\");\n    }\n\n    /**\n     * Creates a new Paper library manager.\n     *\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     */\n    public PaperLibraryManager(final Plugin plugin, final String directoryName) {\n        super(new JDKLogAdapter(requireNonNull(plugin, \"plugin\").getLogger()), plugin.getDataFolder().toPath(), directoryName);\n\n        final ClassLoader cl = plugin.getClass().getClassLoader();\n        final Class<?> paperClClazz;\n", "        try {\n            paperClClazz = Class.forName(\"io.papermc.paper.plugin.entrypoint.classloader.PaperPluginClassLoader\");\n        } catch (final ClassNotFoundException e) {\n            plugin.getSLF4JLogger().error(\"PaperPluginClassLoader not found, are you using Paper 1.19.3+?\", e);\n            throw new RuntimeException(e);\n        }\n\n        if (!paperClClazz.isAssignableFrom(cl.getClass())) {\n            throw new RuntimeException(\"Plugin classloader is not a PaperPluginClassLoader, are you using paper-plugin.yml?\");\n        }\n\n        final Field libraryLoaderField;\n", "        try {\n            libraryLoaderField = paperClClazz.getDeclaredField(\"libraryLoader\");\n        } catch (final NoSuchFieldException e) {\n            plugin.getSLF4JLogger().error(\"Cannot find libraryLoader field in PaperPluginClassLoader, please open a bug report.\", e);\n            throw new RuntimeException(e);\n        }\n\n        libraryLoaderField.setAccessible(true);\n\n        final URLClassLoader libraryLoader;\n        try {\n            libraryLoader = (URLClassLoader) libraryLoaderField.get(cl);\n        } catch (final IllegalAccessException e) {\n            throw new RuntimeException(e); // Should never happen\n        }\n\n        this.classLoader = new URLClassLoaderHelper(libraryLoader, this);\n    }\n\n    /**\n     * Adds a file to the Paper plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final @NotNull Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n", "        try {\n            libraryLoader = (URLClassLoader) libraryLoaderField.get(cl);\n        } catch (final IllegalAccessException e) {\n            throw new RuntimeException(e); // Should never happen\n        }\n\n        this.classLoader = new URLClassLoaderHelper(libraryLoader, this);\n    }\n\n    /**\n     * Adds a file to the Paper plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final @NotNull Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n"]}
{"filename": "paper/src/main/java/net/byteflux/libby/paper/LibbyTestLoader.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.paper;\n\nimport io.papermc.paper.plugin.loader.PluginClasspathBuilder;", "\nimport io.papermc.paper.plugin.loader.PluginClasspathBuilder;\nimport io.papermc.paper.plugin.loader.PluginLoader;\nimport io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver;\nimport org.eclipse.aether.artifact.DefaultArtifact;\nimport org.eclipse.aether.graph.Dependency;\nimport org.eclipse.aether.repository.RemoteRepository;\nimport org.jetbrains.annotations.NotNull;\n\npublic class LibbyTestLoader implements PluginLoader {\n    @Override", "\npublic class LibbyTestLoader implements PluginLoader {\n    @Override\n    public void classloader(final @NotNull PluginClasspathBuilder classpathBuilder) {\n        final MavenLibraryResolver resolver = new MavenLibraryResolver();\n        resolver.addDependency(new Dependency(new DefaultArtifact(\"org.spongepowered:configurate-core:4.2.0-SNAPSHOT\"), null));\n        resolver.addRepository(new RemoteRepository.Builder(\"paper\", \"default\", \"https://repo.papermc.io/repository/maven-public/\").build());\n        resolver.addRepository(new RemoteRepository.Builder(\"sponge\", \"default\", \"https://repo.spongepowered.org/repository/maven-snapshots/\").build());\n\n//        classpathBuilder.addLibrary(resolver);\n    }\n}\n"]}
{"filename": "paper/src/main/java/net/byteflux/libby/paper/LibbyTestPlugin.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.paper;\n\nimport io.papermc.paper.event.player.AsyncChatEvent;", "\nimport io.papermc.paper.event.player.AsyncChatEvent;\nimport net.byteflux.libby.Library;\nimport net.byteflux.libby.PaperLibraryManager;\nimport net.byteflux.libby.relocation.Relocation;\nimport net.kyori.adventure.identity.Identity;\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.Bukkit;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;", "import org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\n\nimport java.util.logging.LogManager;\n\npublic class LibbyTestPlugin extends org.bukkit.plugin.java.JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        LogManager.getLogManager().getLogger(\"LibbyTestPlugin\").setLevel(java.util.logging.Level.ALL);\n        final PaperLibraryManager libraryManager = new PaperLibraryManager(this, \"libs\");\n        final Relocation configurate = new Relocation(\"org{}spongepowered{}configurate\", \"libby.libs.\" + \"configurate\");\n        libraryManager.addMavenCentral();\n        libraryManager.addRepository(\"https://maven.deltapvp.net/\");\n        libraryManager.addRepository(\"https://repo.spongepowered.org/repository/maven-public/\");\n        libraryManager.addRepository(\"https://repo.spongepowered.org/repository/maven-snapshots/\");\n        final Library configurateCore = Library.builder()\n                .groupId(\"org{}spongepowered\")\n                .artifactId(\"configurate-core\")\n                .version(\"4.1.2-SNAPSHOT\")\n                .id(\"configurateCore\")\n                .relocate(configurate)\n                .build();\n        final Library math = Library.builder()\n                .groupId(\"org{}spongepowered\")\n                .artifactId(\"math\")\n                .version(\"2.1.0-SNAPSHOT\")\n                .id(\"math\")\n//                .relocate(configurate)\n                .build();\n        final Library luckPerms = Library.builder()\n                .groupId(\"net{}luckperms\")\n                .artifactId(\"api\")\n                .version(\"5.4\")\n                .build();\n        final Library axel = Library.builder()\n                .groupId(\"org{}minearcade{}axel\")\n                .artifactId(\"axel-velocity\")\n                .classifier(\"sources\")\n                .version(\"0.0.40-SNAPSHOT\")\n                .build();\n        libraryManager.loadLibraries(luckPerms, math, axel, configurateCore);\n\n        Bukkit.getPluginManager().registerEvents(new Listener() {\n\n            @EventHandler", "    public void onEnable() {\n        LogManager.getLogManager().getLogger(\"LibbyTestPlugin\").setLevel(java.util.logging.Level.ALL);\n        final PaperLibraryManager libraryManager = new PaperLibraryManager(this, \"libs\");\n        final Relocation configurate = new Relocation(\"org{}spongepowered{}configurate\", \"libby.libs.\" + \"configurate\");\n        libraryManager.addMavenCentral();\n        libraryManager.addRepository(\"https://maven.deltapvp.net/\");\n        libraryManager.addRepository(\"https://repo.spongepowered.org/repository/maven-public/\");\n        libraryManager.addRepository(\"https://repo.spongepowered.org/repository/maven-snapshots/\");\n        final Library configurateCore = Library.builder()\n                .groupId(\"org{}spongepowered\")\n                .artifactId(\"configurate-core\")\n                .version(\"4.1.2-SNAPSHOT\")\n                .id(\"configurateCore\")\n                .relocate(configurate)\n                .build();\n        final Library math = Library.builder()\n                .groupId(\"org{}spongepowered\")\n                .artifactId(\"math\")\n                .version(\"2.1.0-SNAPSHOT\")\n                .id(\"math\")\n//                .relocate(configurate)\n                .build();\n        final Library luckPerms = Library.builder()\n                .groupId(\"net{}luckperms\")\n                .artifactId(\"api\")\n                .version(\"5.4\")\n                .build();\n        final Library axel = Library.builder()\n                .groupId(\"org{}minearcade{}axel\")\n                .artifactId(\"axel-velocity\")\n                .classifier(\"sources\")\n                .version(\"0.0.40-SNAPSHOT\")\n                .build();\n        libraryManager.loadLibraries(luckPerms, math, axel, configurateCore);\n\n        Bukkit.getPluginManager().registerEvents(new Listener() {\n\n            @EventHandler", "            public void onAsyncChat(final AsyncChatEvent event) {\n                event.renderer((source, sourceDisplayName, message, viewer) -> {\n                    return Component.text()\n                            .append(sourceDisplayName.append(Component.text(\": \")))\n                            .append(message)\n                            .appendNewline()\n                            .append(Component.text(\"Viewer: \").append(viewer.getOrDefault(Identity.DISPLAY_NAME, Component.text(\"Unknown\"))))\n                            .appendNewline()\n                            .append(Component.text(\"Source: \").append(source.name()))\n                            .build();\n                });\n            }\n        }, this);\n\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/Library.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.relocation.Relocation;", "\nimport net.byteflux.libby.relocation.Relocation;\nimport org.jetbrains.annotations.NotNull;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedList;", "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.UUID;\n\n/**\n * An immutable representation of a Maven artifact that can be downloaded,\n * relocated and then loaded into a plugin's classpath at runtime.\n *\n * @see #builder()\n */\npublic class Library {\n    /**\n     * Direct download URLs for this library\n     */\n    private final Collection<String> urls;\n\n    /**\n     * Repository URLs for this library\n     */\n    private final Collection<String> repositories;\n\n    /**\n     * Library id (used by Isolated Class Loaders)\n     */\n    private final String id;\n\n    /**\n     * Maven group ID\n     */\n    private final @NotNull String groupId;\n\n    /**\n     * Maven artifact ID\n     */\n    private final @NotNull String artifactId;\n\n    /**\n     * Artifact version\n     */\n    private final @NotNull String version;\n\n    /**\n     * Artifact classifier\n     */\n    private final String classifier;\n\n    /**\n     * Binary SHA-256 checksum for this library's jar file\n     */\n    private final byte[] checksum;\n\n    /**\n     * Jar relocations to apply\n     */\n    private final Collection<Relocation> relocations;\n\n    /**\n     * Relative Maven path to this library's artifact\n     */\n    private final String path;\n\n    /**\n     * Relative path to this library's relocated jar\n     */\n    private final String relocatedPath;\n\n    /**\n     * Should this library be loaded in an isolated class loader?\n     */\n    private final boolean isolatedLoad;\n\n    /**\n     * Creates a new library.\n     *\n     * @param urls         direct download URLs\n     * @param id           library ID\n     * @param groupId      Maven group ID\n     * @param artifactId   Maven artifact ID\n     * @param version      artifact version\n     * @param classifier   artifact classifier or null\n     * @param checksum     binary SHA-256 checksum or null\n     * @param relocations  jar relocations or null\n     * @param isolatedLoad isolated load for this library\n     */\n    private Library(final Collection<String> urls,\n                    final String id,\n                    final @NotNull String groupId,\n                    final @NotNull String artifactId,\n                    final @NotNull String version,\n                    final String classifier,\n                    final byte[] checksum,\n                    final Collection<Relocation> relocations,\n                    final boolean isolatedLoad) {\n\n        this(urls, null, id, groupId, artifactId, version, classifier, checksum, relocations, isolatedLoad);\n    }\n\n    /**\n     * Creates a new library.\n     *\n     * @param urls         direct download URLs\n     * @param repositories repository URLs\n     * @param id           library ID\n     * @param groupId      Maven group ID\n     * @param artifactId   Maven artifact ID\n     * @param version      artifact version\n     * @param classifier   artifact classifier or null\n     * @param checksum     binary SHA-256 checksum or null\n     * @param relocations  jar relocations or null\n     * @param isolatedLoad isolated load for this library\n     */\n    private Library(final Collection<String> urls,\n                    final Collection<String> repositories,\n                    final String id,\n                    final @NotNull String groupId,\n                    final @NotNull String artifactId,\n                    final @NotNull String version,\n                    final String classifier,\n                    final byte[] checksum,\n                    final Collection<Relocation> relocations,\n                    final boolean isolatedLoad) {\n\n        this.urls = urls != null ? Collections.unmodifiableList(new LinkedList<>(urls)) : Collections.emptyList();\n        this.id = id != null ? id : UUID.randomUUID().toString();\n        this.groupId = requireNonNull(groupId, \"groupId\").replace(\"{}\", \".\");\n        this.artifactId = requireNonNull(artifactId, \"artifactId\");\n        this.version = requireNonNull(version, \"version\");\n        this.classifier = classifier;\n        this.checksum = checksum;\n        this.relocations = relocations != null ? Collections.unmodifiableList(new LinkedList<>(relocations)) : Collections.emptyList();\n\n        String path = this.groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/' + artifactId + '-' + version;", " * @see #builder()\n */\npublic class Library {\n    /**\n     * Direct download URLs for this library\n     */\n    private final Collection<String> urls;\n\n    /**\n     * Repository URLs for this library\n     */\n    private final Collection<String> repositories;\n\n    /**\n     * Library id (used by Isolated Class Loaders)\n     */\n    private final String id;\n\n    /**\n     * Maven group ID\n     */\n    private final @NotNull String groupId;\n\n    /**\n     * Maven artifact ID\n     */\n    private final @NotNull String artifactId;\n\n    /**\n     * Artifact version\n     */\n    private final @NotNull String version;\n\n    /**\n     * Artifact classifier\n     */\n    private final String classifier;\n\n    /**\n     * Binary SHA-256 checksum for this library's jar file\n     */\n    private final byte[] checksum;\n\n    /**\n     * Jar relocations to apply\n     */\n    private final Collection<Relocation> relocations;\n\n    /**\n     * Relative Maven path to this library's artifact\n     */\n    private final String path;\n\n    /**\n     * Relative path to this library's relocated jar\n     */\n    private final String relocatedPath;\n\n    /**\n     * Should this library be loaded in an isolated class loader?\n     */\n    private final boolean isolatedLoad;\n\n    /**\n     * Creates a new library.\n     *\n     * @param urls         direct download URLs\n     * @param id           library ID\n     * @param groupId      Maven group ID\n     * @param artifactId   Maven artifact ID\n     * @param version      artifact version\n     * @param classifier   artifact classifier or null\n     * @param checksum     binary SHA-256 checksum or null\n     * @param relocations  jar relocations or null\n     * @param isolatedLoad isolated load for this library\n     */\n    private Library(final Collection<String> urls,\n                    final String id,\n                    final @NotNull String groupId,\n                    final @NotNull String artifactId,\n                    final @NotNull String version,\n                    final String classifier,\n                    final byte[] checksum,\n                    final Collection<Relocation> relocations,\n                    final boolean isolatedLoad) {\n\n        this(urls, null, id, groupId, artifactId, version, classifier, checksum, relocations, isolatedLoad);\n    }\n\n    /**\n     * Creates a new library.\n     *\n     * @param urls         direct download URLs\n     * @param repositories repository URLs\n     * @param id           library ID\n     * @param groupId      Maven group ID\n     * @param artifactId   Maven artifact ID\n     * @param version      artifact version\n     * @param classifier   artifact classifier or null\n     * @param checksum     binary SHA-256 checksum or null\n     * @param relocations  jar relocations or null\n     * @param isolatedLoad isolated load for this library\n     */\n    private Library(final Collection<String> urls,\n                    final Collection<String> repositories,\n                    final String id,\n                    final @NotNull String groupId,\n                    final @NotNull String artifactId,\n                    final @NotNull String version,\n                    final String classifier,\n                    final byte[] checksum,\n                    final Collection<Relocation> relocations,\n                    final boolean isolatedLoad) {\n\n        this.urls = urls != null ? Collections.unmodifiableList(new LinkedList<>(urls)) : Collections.emptyList();\n        this.id = id != null ? id : UUID.randomUUID().toString();\n        this.groupId = requireNonNull(groupId, \"groupId\").replace(\"{}\", \".\");\n        this.artifactId = requireNonNull(artifactId, \"artifactId\");\n        this.version = requireNonNull(version, \"version\");\n        this.classifier = classifier;\n        this.checksum = checksum;\n        this.relocations = relocations != null ? Collections.unmodifiableList(new LinkedList<>(relocations)) : Collections.emptyList();\n\n        String path = this.groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/' + artifactId + '-' + version;", "        if (hasClassifier()) {\n            path += '-' + classifier;\n        }\n\n        this.path = path + \".jar\";\n\n        this.repositories = repositories != null ? Collections.unmodifiableList(new LinkedList<>(repositories)) : Collections.emptyList();\n        this.relocatedPath = hasRelocations() ? path + \"-relocated.jar\" : null;\n        this.isolatedLoad = isolatedLoad;\n    }\n\n    /**\n     * Creates a new library builder.\n     *\n     * @return new library builder\n     */", "    public static Builder builder() {\n        return new Builder();\n    }\n\n    /**\n     * Gets the direct download URLs for this library.\n     *\n     * @return direct download URLs\n     */\n    public Collection<String> getUrls() {\n        return this.urls;\n    }\n\n    /**\n     * Gets the repositories URLs for this library.\n     *\n     * @return repositories URLs\n     */\n    public Collection<String> getRepositories() {\n        return this.repositories;\n    }\n\n    /**\n     * Gets the library ID\n     *\n     * @return the library id\n     */", "    public String getId() {\n        return this.id;\n    }\n\n    /**\n     * Gets the Maven group ID for this library.\n     *\n     * @return Maven group ID\n     */\n    public @NotNull String getGroupId() {\n        return this.groupId;\n    }\n\n    /**\n     * Gets the Maven artifact ID for this library.\n     *\n     * @return Maven artifact ID\n     */\n    public @NotNull String getArtifactId() {\n        return this.artifactId;\n    }\n\n    /**\n     * Gets the artifact version for this library.\n     *\n     * @return artifact version\n     */\n    public @NotNull String getVersion() {\n        return this.version;\n    }\n\n    /**\n     * Gets the artifact classifier for this library.\n     *\n     * @return artifact classifier or null\n     */", "    public String getClassifier() {\n        return this.classifier;\n    }\n\n    /**\n     * Gets whether this library has an artifact classifier.\n     *\n     * @return true if library has classifier, false otherwise\n     */\n    public boolean hasClassifier() {\n        return this.classifier != null;\n    }\n\n    /**\n     * Gets the binary SHA-256 checksum of this library's jar file.\n     *\n     * @return checksum or null\n     */\n    public byte[] getChecksum() {\n        return this.checksum;\n    }\n\n    /**\n     * Gets whether this library has a checksum.\n     *\n     * @return true if library has checksum, false otherwise\n     */", "    public boolean hasClassifier() {\n        return this.classifier != null;\n    }\n\n    /**\n     * Gets the binary SHA-256 checksum of this library's jar file.\n     *\n     * @return checksum or null\n     */\n    public byte[] getChecksum() {\n        return this.checksum;\n    }\n\n    /**\n     * Gets whether this library has a checksum.\n     *\n     * @return true if library has checksum, false otherwise\n     */", "    public boolean hasChecksum() {\n        return this.checksum != null;\n    }\n\n    /**\n     * Gets the jar relocations to apply to this library.\n     *\n     * @return jar relocations to apply\n     */\n    public Collection<Relocation> getRelocations() {\n        return this.relocations;\n    }\n\n    /**\n     * Gets whether this library has any jar relocations.\n     *\n     * @return true if library has relocations, false otherwise\n     */", "    public boolean hasRelocations() {\n        return !this.relocations.isEmpty();\n    }\n\n    /**\n     * Gets the relative Maven path to this library's artifact.\n     *\n     * @return Maven path for this library\n     */\n    public String getPath() {\n        return this.path;\n    }\n\n    /**\n     * Gets the GAV of this library.\n     *\n     * @return the GAV in the format groupId:artifactId:version\n     * @since 2.0.4\n     */", "    public String getPath() {\n        return this.path;\n    }\n\n    /**\n     * Gets the GAV of this library.\n     *\n     * @return the GAV in the format groupId:artifactId:version\n     * @since 2.0.4\n     */\n    public String getGAV() {\n        return this.groupId + \":\" + this.artifactId + \":\" + this.version;\n    }\n\n    /**\n     * Gets the relative path to this library's relocated jar.\n     *\n     * @return path to relocated artifact or null if has no relocations\n     */", "    public String getGAV() {\n        return this.groupId + \":\" + this.artifactId + \":\" + this.version;\n    }\n\n    /**\n     * Gets the relative path to this library's relocated jar.\n     *\n     * @return path to relocated artifact or null if has no relocations\n     */\n    public String getRelocatedPath() {\n        return this.relocatedPath;\n    }\n\n    /**\n     * Is the library loaded isolated?\n     *\n     * @return true if the library is loaded isolated\n     */", "    public String getRelocatedPath() {\n        return this.relocatedPath;\n    }\n\n    /**\n     * Is the library loaded isolated?\n     *\n     * @return true if the library is loaded isolated\n     */\n    public boolean isIsolatedLoad() {\n        return this.isolatedLoad;\n    }\n\n    /**\n     * Gets a concise, human-readable string representation of this library.\n     *\n     * @return string representation\n     */\n    @Override", "    public boolean isIsolatedLoad() {\n        return this.isolatedLoad;\n    }\n\n    /**\n     * Gets a concise, human-readable string representation of this library.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        String name = this.groupId + ':' + this.artifactId + ':' + this.version;", "    public String toString() {\n        String name = this.groupId + ':' + this.artifactId + ':' + this.version;\n        if (hasClassifier()) {\n            name += ':' + this.classifier;\n        }\n\n        return name;\n    }\n\n    /**\n     * Due to the constructor complexity of an immutable {@link Library},\n     * instead this fluent builder is used to configure and then construct\n     * a new library.\n     */", "    public static class Builder {\n        /**\n         * Direct download URLs for this library\n         */\n        private final Collection<String> urls = new LinkedList<>();\n\n        /**\n         * Repository URLs for this library\n         */\n        private final Collection<String> repositories = new LinkedList<>();\n        /**\n         * Jar relocations to apply\n         */\n        private final Collection<Relocation> relocations = new LinkedList<>();\n        /**\n         * The library ID\n         */\n        private String id;\n        /**\n         * Maven group ID\n         */\n        private @NotNull String groupId;\n        /**\n         * Maven artifact ID\n         */\n        private @NotNull String artifactId;\n        /**\n         * Artifact version\n         */\n        private @NotNull String version;\n        /**\n         * Artifact classifier\n         */\n        private String classifier;\n        /**\n         * Binary SHA-256 checksum for this library's jar file\n         */\n        private byte[] checksum;\n        /**\n         * Isolated load\n         */\n        private boolean isolatedLoad;\n\n        /**\n         * Adds a direct download URL for this library.\n         *\n         * @param url direct download URL\n         * @return this builder\n         */", "        public Builder url(final String url) {\n            this.urls.add(requireNonNull(url, \"url\"));\n            return this;\n        }\n\n        /**\n         * Adds a repository URL for this library.\n         * <p>Most common repositories can be found in {@link Repositories} class as constants.\n         * <p>Note that repositories should be preferably added to the {@link LibraryManager} via {@link LibraryManager#addRepository(String)}.\n         *\n         * @param url repository URL\n         * @return this builder\n         */", "        public Builder repository(final String url) {\n            this.repositories.add(!requireNonNull(url, \"repository\").isEmpty() && requireNonNull(url, \"repository\").charAt(requireNonNull(url, \"repository\").length() - 1) == '/' ? url : url + '/');\n            return this;\n        }\n\n        /**\n         * Sets the id for this library.\n         *\n         * @param id the ID\n         * @return this builder\n         */", "        public Builder id(final String id) {\n            this.id = id != null ? id : UUID.randomUUID().toString();\n            return this;\n        }\n\n        /**\n         * Sets the Maven group ID for this library.\n         *\n         * @param groupId Maven group ID\n         * @return this builder\n         */", "        public Builder groupId(final @NotNull String groupId) {\n            this.groupId = requireNonNull(groupId, \"groupId\");\n            return this;\n        }\n\n        /**\n         * Sets the Maven artifact ID for this library.\n         *\n         * @param artifactId Maven artifact ID\n         * @return this builder\n         */", "        public Builder artifactId(final @NotNull String artifactId) {\n            this.artifactId = requireNonNull(artifactId, \"artifactId\");\n            return this;\n        }\n\n        /**\n         * Sets the artifact version for this library.\n         *\n         * @param version artifact version\n         * @return this builder\n         */", "        public Builder version(final @NotNull String version) {\n            this.version = requireNonNull(version, \"version\");\n            return this;\n        }\n\n        /**\n         * Sets the artifact classifier for this library.\n         *\n         * @param classifier artifact classifier\n         * @return this builder\n         */", "        public Builder classifier(final String classifier) {\n            this.classifier = requireNonNull(classifier, \"classifier\");\n            return this;\n        }\n\n        /**\n         * Sets the binary SHA-256 checksum for this library.\n         *\n         * @param checksum binary SHA-256 checksum\n         * @return this builder\n         */", "        public Builder checksum(final byte[] checksum) {\n            this.checksum = requireNonNull(checksum, \"checksum\");\n            return this;\n        }\n\n        /**\n         * Sets the Base64-encoded SHA-256 checksum for this library.\n         *\n         * @param checksum Base64-encoded SHA-256 checksum\n         * @return this builder\n         */", "        public Builder checksum(final String checksum) {\n            return checksum(Base64.getDecoder().decode(requireNonNull(checksum, \"checksum\")));\n        }\n\n        /**\n         * Sets the isolated load for this library.\n         *\n         * @param isolatedLoad the isolated load boolean\n         * @return this builder\n         */\n        public Builder isolatedLoad(final boolean isolatedLoad) {\n            this.isolatedLoad = isolatedLoad;\n            return this;\n        }\n\n        /**\n         * Adds a jar relocation to apply to this library.\n         *\n         * @param relocation jar relocation to apply\n         * @return this builder\n         */", "        public Builder isolatedLoad(final boolean isolatedLoad) {\n            this.isolatedLoad = isolatedLoad;\n            return this;\n        }\n\n        /**\n         * Adds a jar relocation to apply to this library.\n         *\n         * @param relocation jar relocation to apply\n         * @return this builder\n         */", "        public Builder relocate(final Relocation relocation) {\n            this.relocations.add(requireNonNull(relocation, \"relocation\"));\n            return this;\n        }\n\n        /**\n         * Adds a jar relocation to apply to this library.\n         *\n         * @param pattern          search pattern\n         * @param relocatedPattern replacement pattern\n         * @return this builder\n         */", "        public Builder relocate(final String pattern, final String relocatedPattern) {\n            return relocate(new Relocation(pattern, relocatedPattern));\n        }\n\n        /**\n         * Creates a new library using this builder's configuration.\n         *\n         * @return new library\n         */\n        public Library build() {\n            return new Library(this.urls, this.repositories, this.id, this.groupId, this.artifactId, this.version, this.classifier, this.checksum, this.relocations, this.isolatedLoad);\n        }\n    }\n}\n", "        public Library build() {\n            return new Library(this.urls, this.repositories, this.id, this.groupId, this.artifactId, this.version, this.classifier, this.checksum, this.relocations, this.isolatedLoad);\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/Repositories.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport org.jetbrains.annotations.ApiStatus;", "\nimport org.jetbrains.annotations.ApiStatus;\n\n/**\n * Class containing URLs of public repositories.\n */\npublic final class Repositories {\n\n    /**\n     * Maven Central repository URL.\n     */", "    public static final String MAVEN_CENTRAL = \"https://repo1.maven.org/maven2/\";\n\n    /**\n     * Sonatype OSS repository URL.\n     */\n    public static final String SONATYPE = \"https://oss.sonatype.org/content/groups/public/\";\n\n    /**\n     * Sonatype OSS repository URL.\n     *\n     * @since 2.0.0\n     */", "    public static final String SONATYPE_ALT = \"https://s%s.oss.sonatype.org/content/repositories/snapshots/\";\n\n    /**\n     * Bintray JCenter repository URL.\n     */\n    @Deprecated(\n            forRemoval = true,\n            since = \"2.0.0\"\n    )\n    @ApiStatus.ScheduledForRemoval(inVersion = \"2.1.0\")\n    @ApiStatus.Obsolete", "    public static final String JCENTER = \"https://jcenter.bintray.com/\";\n\n    /**\n     * JitPack repository URL.\n     */\n    public static final String JITPACK = \"https://jitpack.io/\";\n\n    private Repositories() {\n        throw new UnsupportedOperationException(\"Private constructor\");\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/LibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.classloader.IsolatedClassLoader;", "\nimport net.byteflux.libby.classloader.IsolatedClassLoader;\nimport net.byteflux.libby.logging.LogLevel;\nimport net.byteflux.libby.logging.Logger;\nimport net.byteflux.libby.logging.adapters.LogAdapter;\nimport net.byteflux.libby.relocation.Relocation;\nimport net.byteflux.libby.relocation.RelocationHelper;\nimport org.apache.maven.artifact.repository.metadata.Metadata;\nimport org.apache.maven.artifact.repository.metadata.Snapshot;\nimport org.apache.maven.artifact.repository.metadata.Versioning;", "import org.apache.maven.artifact.repository.metadata.Snapshot;\nimport org.apache.maven.artifact.repository.metadata.Versioning;\nimport org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader;\nimport org.jetbrains.annotations.ApiStatus;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.jetbrains.annotations.UnknownNullability;\n\nimport static java.util.Objects.requireNonNull;\n", "import static java.util.Objects.requireNonNull;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.MalformedURLException;\nimport java.net.SocketTimeoutException;\nimport java.net.URI;", "import java.net.SocketTimeoutException;\nimport java.net.URI;\nimport java.net.UnknownHostException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;", "import java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A runtime dependency manager for plugins.\n * <p>", " * A runtime dependency manager for plugins.\n * <p>\n * The library manager can resolve a dependency jar through the configured\n * Maven repositories, download it into a local cache, relocate it and then\n * load it into the plugin's classpath.\n * <p>\n * Transitive dependencies for a library aren't downloaded automatically and\n * must be explicitly loaded like every other library.\n * <p>\n * It's recommended that libraries are relocated to prevent any namespace", " * <p>\n * It's recommended that libraries are relocated to prevent any namespace\n * conflicts with different versions of the same library bundled with other\n * plugins or maybe even bundled with the server itself.\n *\n * @see Library\n */\npublic abstract class LibraryManager {\n\n    static final HttpClient HTTP_CLIENT = HttpClient.newBuilder()\n            .priority(5)\n            .build();\n\n    /**\n     * Wrapped plugin logger\n     */\n    protected final Logger logger;\n\n    /**\n     * Directory where downloaded library jars are saved to\n     */\n    protected final Path saveDirectory;\n\n    /**\n     * Maven repositories used to resolve artifacts\n     */\n    private final Set<String> repositories = new LinkedHashSet<>();\n\n    /**\n     * Map of isolated class loaders and theirs id\n     */\n    private final Map<String, IsolatedClassLoader> isolatedLibraries = new HashMap<>();\n\n    /**\n     * Lazily-initialized relocation helper that uses reflection to call into\n     * Luck's Jar Relocator\n     */\n    private RelocationHelper relocator;\n\n    /**\n     * Creates a new library manager.\n     *\n     * @param logAdapter    plugin logging adapter\n     * @param dataDirectory plugin's data directory\n     * @param directoryName download directory name\n     */\n    protected LibraryManager(final @NotNull LogAdapter logAdapter, final @NotNull Path dataDirectory, final @NotNull String directoryName) {\n        this.logger = new Logger(requireNonNull(logAdapter, \"logAdapter\"));\n        this.saveDirectory = requireNonNull(dataDirectory, \"dataDirectory\").toAbsolutePath().resolve(requireNonNull(directoryName, \"directoryName\"));\n    }\n\n    /**\n     * Adds a file to the plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    protected abstract void addToClasspath(final @NotNull Path file);\n\n    /**\n     * Adds a file to the isolated class loader\n     *\n     * @param library the library to add\n     * @param file    the file to add\n     */\n    protected void addToIsolatedClasspath(final @NotNull Library library, final @NotNull Path file) {\n        final IsolatedClassLoader classLoader;\n        final String id = library.getId();", "        if (id != null) {\n            classLoader = this.isolatedLibraries.computeIfAbsent(id, s -> new IsolatedClassLoader());\n        } else {\n            classLoader = new IsolatedClassLoader();\n        }\n        classLoader.addPath(file);\n    }\n\n    /**\n     * Get the isolated class loader of the library\n     *\n     * @param libraryId the id of the library\n     */\n    public @Nullable IsolatedClassLoader getIsolatedClassLoaderOf(final @NotNull String libraryId) {\n        return this.isolatedLibraries.get(libraryId);\n    }\n\n    /**\n     * Gets the logging level for this library manager.\n     *\n     * @return log level\n     */\n    public @NotNull LogLevel getLogLevel() {\n        return this.logger.getLevel();\n    }\n\n    /**\n     * Sets the logging level for this library manager.\n     * <p>\n     * By setting this value, the library manager's logger will not log any\n     * messages with a level less severe than the configured level. This can be\n     * useful for silencing the download and relocation logging.\n     * <p>\n     * Setting this value to {@link LogLevel#WARN} would silence informational\n     * logging but still print important things like invalid checksum warnings.\n     *\n     * @param level the log level to set\n     */", "    public void setLogLevel(final @NotNull LogLevel level) {\n        this.logger.setLevel(level);\n    }\n\n    /**\n     * Gets the currently added repositories used to resolve artifacts.\n     * <p>\n     * For each library this list is traversed to download artifacts after the\n     * direct download URLs have been attempted.\n     *\n     * @return current repositories\n     */\n    public @NotNull Collection<@Nullable String> getRepositories() {\n        final List<String> urls;\n        synchronized (this.repositories) {\n            urls = new LinkedList<>(this.repositories);\n        }\n\n        return Collections.unmodifiableList(urls);\n    }\n\n    /**\n     * Adds a repository URL to this library manager.\n     * <p>\n     * Artifacts will be resolved using this repository when attempts to locate\n     * the artifact through previously added repositories are all unsuccessful.\n     *\n     * @param url repository URL to add\n     */", "    public void addRepository(final @NotNull String url) {\n        final String repo = !requireNonNull(url, \"url\").isEmpty() && requireNonNull(url, \"url\").charAt(requireNonNull(url, \"url\").length() - 1) == '/' ? url : url + '/';\n        synchronized (this.repositories) {\n            this.repositories.add(repo);\n        }\n    }\n\n    /**\n     * Adds a {@link Collection} of repository URLs to this library manager.\n     * <p>\n     * Artifacts will be resolved using these repositories when attempts to locate\n     * the artifact through previously added repositories are all unsuccessful.\n     *\n     * @param urls repository URLs to add\n     * @since 2.0.1\n     */\n    @ApiStatus.AvailableSince(\"2.0.1\")", "    public void addRepositories(final @NotNull Collection<@NotNull String> urls) {\n        for (final String url : urls) {\n            addRepository(url);\n        }\n    }\n\n    /**\n     * Adds an array of repository URLs to this library manager.\n     * <p>\n     * Artifacts will be resolved using these repositories when attempts to locate\n     * the artifact through previously added repositories are all unsuccessful.\n     *\n     * @param urls repository URLs to add\n     * @since 2.0.1\n     */\n    @ApiStatus.AvailableSince(\"2.0.1\")", "    public void addRepositories(final @NotNull String @NotNull ... urls) {\n        for (final String url : urls) {\n            addRepository(url);\n        }\n    }\n\n    /**\n     * Adds the current user's local Maven repository.\n     */\n    public void addMavenLocal() {\n        addRepository(Path.of(System.getProperty(\"user.home\")).resolve(\".m2/repository\").toUri().toString());\n    }\n\n    /**\n     * Adds the Maven Central repository.\n     */", "    public void addMavenLocal() {\n        addRepository(Path.of(System.getProperty(\"user.home\")).resolve(\".m2/repository\").toUri().toString());\n    }\n\n    /**\n     * Adds the Maven Central repository.\n     */\n    public void addMavenCentral() {\n        addRepository(Repositories.MAVEN_CENTRAL);\n    }\n\n    /**\n     * Adds the Sonatype OSS repository.\n     */", "    public void addSonatype() {\n        addRepository(Repositories.SONATYPE);\n    }\n\n    /**\n     * Adds the Sonatype OSS repository.\n     *\n     * @since 2.0.0\n     */\n    public void addSonatype(final int alt) {\n        addRepository(String.format(Repositories.SONATYPE_ALT, alt));\n    }\n\n    /**\n     * Adds the Bintray JCenter repository.\n     * <p>\n     * NOTE: This repository is being shut down. Use another repository.\n     * DOES NOT DO ANYTHING\n     *\n     * @deprecated This repository is being shut down. Use another repository\n     */\n    @Deprecated(\n            forRemoval = true,\n            since = \"2.0.0\"\n    )\n    @ApiStatus.ScheduledForRemoval(inVersion = \"2.1.0\")\n    @ApiStatus.Obsolete", "    public void addSonatype(final int alt) {\n        addRepository(String.format(Repositories.SONATYPE_ALT, alt));\n    }\n\n    /**\n     * Adds the Bintray JCenter repository.\n     * <p>\n     * NOTE: This repository is being shut down. Use another repository.\n     * DOES NOT DO ANYTHING\n     *\n     * @deprecated This repository is being shut down. Use another repository\n     */\n    @Deprecated(\n            forRemoval = true,\n            since = \"2.0.0\"\n    )\n    @ApiStatus.ScheduledForRemoval(inVersion = \"2.1.0\")\n    @ApiStatus.Obsolete", "    public void addJCenter() {\n        throw new UnsupportedOperationException(\"JCenter has shut down. Use another repository.\");\n    }\n\n    /**\n     * Adds the JitPack repository.\n     */\n    public void addJitPack() {\n        addRepository(Repositories.JITPACK);\n    }\n\n    /**\n     * Gets all the possible download URLs for this library. Entries are\n     * ordered by direct download URLs first and then repository download URLs.\n     *\n     * @param library the library to resolve\n     * @return download URLs\n     */\n    public @NotNull Collection<@Nullable String> resolveLibrary(final @NotNull Library library) {\n        final Set<String> urls = new LinkedHashSet<>(requireNonNull(library, \"library\").getUrls());\n        final boolean snapshot = library.getVersion().endsWith(\"-SNAPSHOT\");\n        final Set<String> repos = new HashSet<>();\n        repos.addAll(library.getRepositories());\n        repos.addAll(getRepositories());\n", "        if (!snapshot) {\n            for (final String repository : repos) {\n                urls.add(repository + library.getPath());\n            }\n        } else {\n            final MetadataXpp3Reader reader = new MetadataXpp3Reader();\n            final String pathv2 = library.getPath().substring(0, library.getGAV().length()) + \"/maven-metadata.xml\";\n            final String pathv3 = library.getPath().substring(0, library.getGAV().length());\n            try {\n                for (final String repository : repos) {\n                    final HttpResponse<InputStream> response = HTTP_CLIENT.send(\n                            HttpRequest.newBuilder()\n                                    .GET()\n                                    .header(\"User-Agent\", \"powercasgamer/libby\")\n                                    .uri(URI.create(repository + pathv2))\n                                    .build(), HttpResponse.BodyHandlers.ofInputStream());", "            try {\n                for (final String repository : repos) {\n                    final HttpResponse<InputStream> response = HTTP_CLIENT.send(\n                            HttpRequest.newBuilder()\n                                    .GET()\n                                    .header(\"User-Agent\", \"powercasgamer/libby\")\n                                    .uri(URI.create(repository + pathv2))\n                                    .build(), HttpResponse.BodyHandlers.ofInputStream());\n                    if (response.statusCode() != 200) continue;\n                    final Metadata metadata = reader.read(response.body());\n                    final Versioning versioning = metadata.getVersioning();\n                    final Snapshot snapshat = versioning.getSnapshot();\n                    urls.add(repository + pathv3 + \"/\" + library.getArtifactId() + \"-\" + library.getVersion().replace(\"-SNAPSHOT\", \"\") + \"-\" + snapshat.getTimestamp() + \"-\" + snapshat.getBuildNumber() + \".jar\");\n                }\n            } catch (final Exception exc) {\n                throw new RuntimeException(exc);\n            }\n        }\n\n        return Collections.unmodifiableSet(urls);\n    }\n\n    /**\n     * Downloads a library jar and returns the contents as a byte array.\n     *\n     * @param url the URL to the library jar\n     * @return downloaded jar as byte array or null if nothing was downloaded\n     */\n    private byte[] downloadLibrary(final @NotNull String url) {", "                    if (response.statusCode() != 200) continue;\n                    final Metadata metadata = reader.read(response.body());\n                    final Versioning versioning = metadata.getVersioning();\n                    final Snapshot snapshat = versioning.getSnapshot();\n                    urls.add(repository + pathv3 + \"/\" + library.getArtifactId() + \"-\" + library.getVersion().replace(\"-SNAPSHOT\", \"\") + \"-\" + snapshat.getTimestamp() + \"-\" + snapshat.getBuildNumber() + \".jar\");\n                }\n            } catch (final Exception exc) {\n                throw new RuntimeException(exc);\n            }\n        }\n\n        return Collections.unmodifiableSet(urls);\n    }\n\n    /**\n     * Downloads a library jar and returns the contents as a byte array.\n     *\n     * @param url the URL to the library jar\n     * @return downloaded jar as byte array or null if nothing was downloaded\n     */\n    private byte[] downloadLibrary(final @NotNull String url) {", "        try {\n            final HttpResponse<InputStream> input = HTTP_CLIENT.send(HttpRequest.newBuilder()\n                    .GET()\n                    .header(\"User-Agent\", \"powercasgamer/libby\")\n                    .uri(URI.create(url))\n                    .timeout(Duration.ofMillis(5000))\n                    .build(), HttpResponse.BodyHandlers.ofInputStream());\n\n            try (final InputStream in = input.body()) {\n                int len;\n                final byte[] buf = new byte[8192];\n                final ByteArrayOutputStream out = new ByteArrayOutputStream();\n", "                try {\n                    while ((len = in.read(buf)) != -1) {\n                        out.write(buf, 0, len);\n                    }\n                } catch (final SocketTimeoutException e) {\n                    this.logger.warn(\"Download timed out: \" + input.uri(), e);\n                    return null;\n                }\n\n                this.logger.info(\"Downloaded library \" + input.uri());\n                return out.toByteArray();\n            }\n        } catch (final MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        } catch (final IOException e) {", "            if (e instanceof FileNotFoundException) {\n                this.logger.debug(\"File not found: \" + url, e);\n            } else if (e instanceof SocketTimeoutException) {\n                this.logger.debug(\"Connect timed out: \" + url, e);\n            } else if (e instanceof UnknownHostException) {\n                this.logger.debug(\"Unknown host: \" + url, e);\n            } else {\n                this.logger.debug(\"Unexpected IOException\", e);\n            }\n            return null;\n        } catch (final InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Downloads a library jar to the save directory if it doesn't already\n     * exist and returns the local file path.\n     * <p>\n     * If the library has a checksum, it will be compared against the\n     * downloaded jar's checksum to verify the integrity of the download. If\n     * the checksums don't match, a warning is generated and the next download\n     * URL is attempted.\n     * <p>\n     * Checksum comparison is ignored if the library doesn't have a checksum\n     * or if the library jar already exists in the save directory.\n     * <p>\n     * Most of the time it is advised to use {@link #loadLibrary(Library)}\n     * instead of this method because this one is only concerned with\n     * downloading the jar and returning the local path. It's usually more\n     * desirable to download the jar and add it to the plugin's classpath in\n     * one operation.\n     *\n     * @param library the library to download\n     * @return local file path to library\n     * @see #loadLibrary(Library)\n     */\n    public @UnknownNullability Path downloadLibrary(final @NotNull Library library) {\n        final Path file = this.saveDirectory.resolve(requireNonNull(library, \"library\").getPath());", "        if (Files.exists(file)) {\n            return file;\n        }\n\n        final Collection<String> urls = resolveLibrary(library);\n        if (urls.isEmpty()) {\n            throw new RuntimeException(\"Library '\" + library + \"' couldn't be resolved, add a repository\");\n        }\n\n        MessageDigest md = null;\n        if (library.hasChecksum()) {", "        if (library.hasChecksum()) {\n            try {\n                md = MessageDigest.getInstance(\"SHA-256\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        final Path out = file.resolveSibling(file.getFileName() + \".tmp\");\n        out.toFile().deleteOnExit();\n", "        try {\n            Files.createDirectories(file.getParent());\n\n            for (final String url : urls) {\n                final byte[] bytes = downloadLibrary(url);\n                if (bytes == null) {\n                    continue;\n                }\n\n                if (md != null) {\n                    final byte[] checksum = md.digest(bytes);", "                if (md != null) {\n                    final byte[] checksum = md.digest(bytes);\n                    if (!Arrays.equals(checksum, library.getChecksum())) {\n                        this.logger.warn(\"*** INVALID CHECKSUM ***\");\n                        this.logger.warn(\" Library :  \" + library);\n                        this.logger.warn(\" URL :  \" + url);\n                        this.logger.warn(\" Expected :  \" + Base64.getEncoder().encodeToString(library.getChecksum()));\n                        this.logger.warn(\" Actual :  \" + Base64.getEncoder().encodeToString(checksum));\n                        continue;\n                    }\n                }\n\n                Files.write(out, bytes);\n                Files.move(out, file);\n\n                return file;\n            }\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (final Exception e) {\n            throw new RuntimeException(\"Failed to download library '\" + library + \"'\", e);\n        } finally {", "            try {\n                Files.deleteIfExists(out);\n            } catch (final IOException exc) {\n                this.logger.debug(\"Failed to delete temporary file: \" + out, exc);\n            } catch (final Exception exc) {\n                this.logger.error(\"Failed to download library '\" + library + \"'\", exc);\n            }\n        }\n\n        throw new RuntimeException(\"Failed to download library '\" + library + \"'\");\n    }\n\n    /**\n     * Processes the input jar and generates an output jar with the provided\n     * relocation rules applied, then returns the path to the relocated jar.\n     *\n     * @param in          input jar\n     * @param out         output jar\n     * @param relocations relocations to apply\n     * @return the relocated file\n     * @see RelocationHelper#relocate(Path, Path, Collection)\n     */\n    private @NotNull Path relocate(final @NotNull Path in, final @NotNull String out, final @NotNull Collection<@Nullable Relocation> relocations) {\n        requireNonNull(in, \"in\");\n        requireNonNull(out, \"out\");\n        requireNonNull(relocations, \"relocations\");\n\n        final Path file = this.saveDirectory.resolve(out);", "        if (Files.exists(file)) {\n            return file;\n        }\n\n        final Path tmpOut = file.resolveSibling(file.getFileName() + \".tmp\");\n        tmpOut.toFile().deleteOnExit();\n\n        synchronized (this) {\n            if (this.relocator == null) {\n                this.relocator = new RelocationHelper(this);\n            }\n        }\n", "            if (this.relocator == null) {\n                this.relocator = new RelocationHelper(this);\n            }\n        }\n\n        try {\n            this.relocator.relocate(in, tmpOut, relocations);\n            Files.move(tmpOut, file);\n\n            this.logger.info(\"Relocations applied to \" + this.saveDirectory.getParent().relativize(in));\n\n            return file;\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {", "            try {\n                Files.deleteIfExists(tmpOut);\n            } catch (final IOException ignored) {\n            }\n        }\n    }\n\n    /**\n     * Loads a library jar into the plugin's classpath. If the library jar\n     * doesn't exist locally, it will be downloaded.\n     * <p>\n     * If the provided library has any relocations, they will be applied to\n     * create a relocated jar and the relocated jar will be loaded instead.\n     *\n     * @param library the library to load\n     * @see #downloadLibrary(Library)\n     */", "    public void loadLibrary(final @NotNull Library library) {\n        Path file = downloadLibrary(requireNonNull(library, \"library\"));\n        if (library.hasRelocations()) {\n            file = relocate(file, library.getRelocatedPath(), library.getRelocations());\n        }\n\n        if (library.isIsolatedLoad()) {\n            addToIsolatedClasspath(library, file);\n        } else {\n            addToClasspath(file);\n        }\n    }\n\n    /**\n     * Loads a {@link Collection} of {@link Library}'s jars into the plugin's classpath. If the library jar\n     * doesn't exist locally, it will be downloaded.\n     * <p>\n     * If the provided library has any relocations, they will be applied to\n     * create a relocated jar and the relocated jar will be loaded instead.\n     *\n     * @param libraries the libraries to load\n     * @see #loadLibrary(Library)\n     * @since 2.0.1\n     */\n    @ApiStatus.AvailableSince(\"2.0.1\")", "    public void loadLibraries(final @NotNull Collection<? extends Library> libraries) {\n        for (final Library library : libraries) {\n            loadLibrary(library);\n        }\n    }\n\n    /**\n     * Loads an array of {@link Library}'s jars into the plugin's classpath. If the library jar\n     * doesn't exist locally, it will be downloaded.\n     * <p>\n     * If the provided library has any relocations, they will be applied to\n     * create a relocated jar and the relocated jar will be loaded instead.\n     *\n     * @param libraries the libraries to load\n     * @see #loadLibrary(Library)\n     * @since 2.0.1\n     */\n    @ApiStatus.AvailableSince(\"2.0.1\")", "    public void loadLibraries(final @NotNull Library... libraries) {\n        for (final Library library : libraries) {\n            loadLibrary(library);\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/classloader/URLClassLoaderHelper.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.classloader;\n\nimport net.byteflux.libby.Library;", "\nimport net.byteflux.libby.Library;\nimport net.byteflux.libby.LibraryManager;\nimport net.byteflux.libby.Repositories;\nimport sun.misc.Unsafe;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;", "import java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\nimport java.util.Collections;", "import java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A reflection-based wrapper around {@link URLClassLoader} for adding URLs to\n * the classpath.\n */\npublic class URLClassLoaderHelper {\n\n    /**\n     * Unsafe class instance. Used in {@link #getPrivilegedMethodHandle(Method)}.\n     */\n    private static final Unsafe theUnsafe;\n\n    static {\n        Unsafe unsafe = null; // Used to make theUnsafe field final\n\n        // getDeclaredField(\"theUnsafe\") is not used to avoid breakage on JVMs with changed field name", " */\npublic class URLClassLoaderHelper {\n\n    /**\n     * Unsafe class instance. Used in {@link #getPrivilegedMethodHandle(Method)}.\n     */\n    private static final Unsafe theUnsafe;\n\n    static {\n        Unsafe unsafe = null; // Used to make theUnsafe field final\n\n        // getDeclaredField(\"theUnsafe\") is not used to avoid breakage on JVMs with changed field name", "        for (final Field f : Unsafe.class.getDeclaredFields()) {\n            try {\n                if (f.getType() == Unsafe.class && Modifier.isStatic(f.getModifiers())) {\n                    f.setAccessible(true);\n                    unsafe = (Unsafe) f.get(null);\n                }\n            } catch (final Exception ignored) {\n            }\n        }\n        theUnsafe = unsafe;\n    }\n\n    /**\n     * The class loader being managed by this helper.\n     */\n    private final URLClassLoader classLoader;\n\n    /**\n     * A reflected method in {@link URLClassLoader}, when invoked adds a URL to the classpath.\n     */\n    private MethodHandle addURLMethodHandle;\n\n    /**\n     * Creates a new URL class loader helper.\n     *\n     * @param classLoader    the class loader to manage\n     * @param libraryManager the library manager used to download dependencies\n     */\n    public URLClassLoaderHelper(final URLClassLoader classLoader, final LibraryManager libraryManager) {\n        requireNonNull(libraryManager, \"libraryManager\");\n        this.classLoader = requireNonNull(classLoader, \"classLoader\");\n", "        try {\n            final Method addURLMethod = URLClassLoader.class.getDeclaredMethod(\"addURL\", URL.class);\n\n            try {\n                openUrlClassLoaderModule();\n            } catch (final Exception ignored) {\n            }\n\n            try {\n                addURLMethod.setAccessible(true);\n            } catch (final Exception exception) {\n                // InaccessibleObjectException has been added in Java 9", "            try {\n                addURLMethod.setAccessible(true);\n            } catch (final Exception exception) {\n                // InaccessibleObjectException has been added in Java 9\n                if (exception.getClass().getName().equals(\"java.lang.reflect.InaccessibleObjectException\")) {\n                    // It is Java 9+, try to open java.net package\n                    if (theUnsafe != null)\n                        try {\n                            this.addURLMethodHandle = getPrivilegedMethodHandle(addURLMethod).bindTo(classLoader);\n                            return; // We're done\n                        } catch (final Exception ignored) {\n                            this.addURLMethodHandle = null; // Just to be sure the field is set to null\n                        }\n                    // Cannot use privileged MethodHandles.Lookup, trying with java agent", "                    try {\n                        addOpensWithAgent(libraryManager);\n                        addURLMethod.setAccessible(true);\n                    } catch (final Exception e) {\n                        // Cannot access at all\n                        System.err.println(\"Cannot access URLClassLoader#addURL(URL), if you are using Java 9+ try to add the following option to your java command: --add-opens java.base/java.net=ALL-UNNAMED\");\n                        throw new RuntimeException(\"Cannot access URLClassLoader#addURL(URL)\", e);\n                    }\n                } else {\n                    throw new RuntimeException(\"Cannot set accessible URLClassLoader#addURL(URL)\", exception);\n                }\n            }\n            this.addURLMethodHandle = MethodHandles.lookup().unreflect(addURLMethod).bindTo(classLoader);\n        } catch (final NoSuchMethodException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void openUrlClassLoaderModule() throws Exception {\n        //\n        // Thanks to lucko (Luck) <luck@lucko.me> for this snippet used in his own class loader\n        //\n        // This is a workaround used to maintain Java 9+ support with reflections\n        // Thanks to this you will be able to run this class loader with Java 8+\n\n        // This is effectively calling:\n        //\n        // URLClassLoader.class.getModule().addOpens(\n        //     URLClassLoader.class.getPackageName(),\n        //     URLClassLoaderHelper.class.getModule()\n        // );\n        //\n        // We use reflection since we build against Java 8.\n\n        final Class<?> moduleClass = Class.forName(\"java.lang.Module\");\n        final Method getModuleMethod = Class.class.getMethod(\"getModule\");\n        final Method addOpensMethod = moduleClass.getMethod(\"addOpens\", String.class, moduleClass);\n\n        final Object urlClassLoaderModule = getModuleMethod.invoke(URLClassLoader.class);\n        final Object thisModule = getModuleMethod.invoke(URLClassLoaderHelper.class);\n\n        addOpensMethod.invoke(urlClassLoaderModule, URLClassLoader.class.getPackage().getName(), thisModule);\n    }\n\n    /**\n     * Adds a URL to the class loader's classpath.\n     *\n     * @param url the URL to add\n     */", "    public void addToClasspath(final URL url) {\n        try {\n            this.addURLMethodHandle.invokeWithArguments(requireNonNull(url, \"url\"));\n        } catch (final Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Adds a path to the class loader's classpath.\n     *\n     * @param path the path to add\n     */", "    public void addToClasspath(final Path path) {\n        try {\n            addToClasspath(requireNonNull(path, \"path\").toUri().toURL());\n        } catch (final MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    private MethodHandle getPrivilegedMethodHandle(final Method method) throws Exception {\n        // Try to get a MethodHandle to URLClassLoader#addURL.\n        // The Unsafe class is used to get a privileged MethodHandles.Lookup instance.\n\n        // Looking for MethodHandles.Lookup#IMPL_LOOKUP private static field\n        // getDeclaredField(\"IMPL_LOOKUP\") is not used to avoid breakage on JVMs with changed field name", "        for (final Field trustedLookup : MethodHandles.Lookup.class.getDeclaredFields()) {\n            if (trustedLookup.getType() != MethodHandles.Lookup.class || !Modifier.isStatic(trustedLookup.getModifiers()) || trustedLookup.isSynthetic())\n                continue;\n\n            try {\n                final MethodHandles.Lookup lookup = (MethodHandles.Lookup) theUnsafe.getObject(theUnsafe.staticFieldBase(trustedLookup), theUnsafe.staticFieldOffset(trustedLookup));\n                return lookup.unreflect(method);\n            } catch (final Exception ignored) {\n                // Unreflect went wrong, trying the next field\n            }\n        }\n\n        // Every field has been tried\n        throw new RuntimeException(\"Cannot get privileged method handle.\");\n    }\n\n    private void addOpensWithAgent(final LibraryManager libraryManager) throws Exception {\n        // To open URLClassLoader's module we need permissions.\n        // Try to add a java agent at runtime (specifically, ByteBuddy's agent) and use it to open the module,\n        // since java agents should have such permission.\n\n        // Download ByteBuddy's agent and load it through an IsolatedClassLoader\n        try (final IsolatedClassLoader isolatedClassLoader = new IsolatedClassLoader()) {\n            isolatedClassLoader.addPath(libraryManager.downloadLibrary(\n                    Library.builder()\n                            .groupId(\"net.bytebuddy\")\n                            .artifactId(\"byte-buddy-agent\")\n                            .version(\"1.14.2\")\n                            .checksum(\"9CjHQXtM9wMdiPH2PYdoEc6jsBWAMBe6ngbOKs3Voec=\")\n                            .repository(Repositories.MAVEN_CENTRAL)\n                            .build()\n            ));\n\n            final Class<?> byteBuddyAgent = isolatedClassLoader.loadClass(\"net.bytebuddy.agent.ByteBuddyAgent\");\n\n            // This is effectively calling:\n            //\n            // Instrumentation instrumentation = ByteBuddyAgent.install();\n            // instrumentation.redefineModule(\n            //     URLClassLoader.class.getModule(),\n            //     Collections.emptySet(),\n            //     Collections.emptyMap(),\n            //     Collections.singletonMap(\"java.net\", Collections.singleton(getClass().getModule())),\n            //     Collections.emptySet(),\n            //     Collections.emptyMap()\n            // );\n            //\n            // For more information see https://docs.oracle.com/en/java/javase/16/docs/api/java.instrument/java/lang/instrument/Instrumentation.html\n            //\n            // We use reflection since we build against Java 8.\n\n            final Object instrumentation = byteBuddyAgent.getDeclaredMethod(\"install\").invoke(null);\n            final Class<?> instrumentationClass = Class.forName(\"java.lang.instrument.Instrumentation\");\n            final Method redefineModule = instrumentationClass.getDeclaredMethod(\"redefineModule\", Class.forName(\"java.lang.Module\"), Set.class, Map.class, Map.class, Set.class, Map.class);\n            final Method getModule = Class.class.getDeclaredMethod(\"getModule\");\n            final Map<String, Set<?>> toOpen = Collections.singletonMap(\"java.net\", Collections.singleton(getModule.invoke(getClass())));\n            redefineModule.invoke(instrumentation, getModule.invoke(URLClassLoader.class), Collections.emptySet(), Collections.emptyMap(), toOpen, Collections.emptySet(), Collections.emptyMap());\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/classloader/IsolatedClassLoader.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.classloader;\n\nimport static java.util.Objects.requireNonNull;", "\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\n\n/**\n * This class loader is a simple child of {@code URLClassLoader} that uses", "/**\n * This class loader is a simple child of {@code URLClassLoader} that uses\n * the JVM's Extensions Class Loader as the parent instead of the system class\n * loader to provide an unpolluted classpath.\n */\npublic class IsolatedClassLoader extends URLClassLoader {\n    static {\n        ClassLoader.registerAsParallelCapable();\n    }\n\n    /**\n     * Creates a new isolated class loader for the given URLs.\n     *\n     * @param urls the URLs to add to the classpath\n     */\n    public IsolatedClassLoader(final URL... urls) {\n        super(requireNonNull(urls, \"urls\"), ClassLoader.getSystemClassLoader().getParent());\n    }\n\n    /**\n     * Adds a URL to the classpath.\n     *\n     * @param url the URL to add\n     */\n    @Override", "    public void addURL(final URL url) {\n        super.addURL(url);\n    }\n\n    /**\n     * Adds a path to the classpath.\n     *\n     * @param path the path to add\n     */\n    public void addPath(final Path path) {\n        try {\n            addURL(requireNonNull(path, \"path\").toUri().toURL());\n        } catch (final MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}\n", "    public void addPath(final Path path) {\n        try {\n            addURL(requireNonNull(path, \"path\").toUri().toURL());\n        } catch (final MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/logging/LogLevel.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging;\n\n/**", "\n/**\n * Represents the severity of a log message in {@link Logger}.\n */\npublic enum LogLevel {\n    /**\n     * Stuff that isn't useful to end-users\n     */\n    DEBUG,\n\n    /**\n     * Stuff that might be useful to know\n     */\n    INFO,\n\n    /**\n     * Non-fatal, often recoverable errors or notices\n     */\n    WARN,\n\n    /**\n     * Probably an unrecoverable error\n     */\n    ERROR\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/logging/Logger.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging;\n\nimport net.byteflux.libby.logging.adapters.LogAdapter;", "\nimport net.byteflux.libby.logging.adapters.LogAdapter;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * A logging wrapper that logs to a log adapter and can be configured to filter\n * log messages by severity.\n */\npublic class Logger {\n    /**\n     * Log adapter for the current platform\n     */\n    private final LogAdapter adapter;\n\n    /**\n     * Log level controlling which messages are logged\n     */\n    private LogLevel level = LogLevel.INFO;\n\n    /**\n     * Creates a new logger with the provided adapter.\n     *\n     * @param adapter the adapter to wrap\n     */\n    public Logger(final LogAdapter adapter) {\n        this.adapter = requireNonNull(adapter, \"adapter\");\n    }\n\n    /**\n     * Gets the current log level.\n     *\n     * @return current log level\n     */", " */\npublic class Logger {\n    /**\n     * Log adapter for the current platform\n     */\n    private final LogAdapter adapter;\n\n    /**\n     * Log level controlling which messages are logged\n     */\n    private LogLevel level = LogLevel.INFO;\n\n    /**\n     * Creates a new logger with the provided adapter.\n     *\n     * @param adapter the adapter to wrap\n     */\n    public Logger(final LogAdapter adapter) {\n        this.adapter = requireNonNull(adapter, \"adapter\");\n    }\n\n    /**\n     * Gets the current log level.\n     *\n     * @return current log level\n     */", "    public LogLevel getLevel() {\n        return this.level;\n    }\n\n    /**\n     * Sets a new log level.\n     *\n     * @param level new log level\n     */\n    public void setLevel(final LogLevel level) {\n        this.level = requireNonNull(level, \"level\");\n    }\n\n    /**\n     * Gets whether messages matching the provided level can be logged under\n     * the current log level setting.\n     * <p>\n     * Returns true if provided log level is equal to or more severe than the\n     * logger's configured log level.\n     *\n     * @param level the level to check\n     * @return true if message can be logged, or false\n     */\n    private boolean canLog(final LogLevel level) {\n        return requireNonNull(level, \"level\").compareTo(this.level) >= 0;\n    }\n\n    /**\n     * Logs a message with the provided level.\n     * <p>\n     * If the provided log level is less severe than the logger's\n     * configured log level, this message won't be logged.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     * @see #debug(String)\n     * @see #info(String)\n     * @see #warn(String)\n     * @see #error(String)\n     */", "    public void setLevel(final LogLevel level) {\n        this.level = requireNonNull(level, \"level\");\n    }\n\n    /**\n     * Gets whether messages matching the provided level can be logged under\n     * the current log level setting.\n     * <p>\n     * Returns true if provided log level is equal to or more severe than the\n     * logger's configured log level.\n     *\n     * @param level the level to check\n     * @return true if message can be logged, or false\n     */\n    private boolean canLog(final LogLevel level) {\n        return requireNonNull(level, \"level\").compareTo(this.level) >= 0;\n    }\n\n    /**\n     * Logs a message with the provided level.\n     * <p>\n     * If the provided log level is less severe than the logger's\n     * configured log level, this message won't be logged.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     * @see #debug(String)\n     * @see #info(String)\n     * @see #warn(String)\n     * @see #error(String)\n     */", "    public void log(final LogLevel level, final String message) {\n        if (canLog(level)) {\n            this.adapter.log(level, message);\n        }\n    }\n\n    /**\n     * Logs a message and stack trace with the provided level.\n     * <p>\n     * If the provided log level is less severe than the logger's\n     * configured log level, this message won't be logged.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     * @see #debug(String, Throwable)\n     * @see #info(String, Throwable)\n     * @see #warn(String, Throwable)\n     * @see #error(String, Throwable)\n     */", "    public void log(final LogLevel level, final String message, final Throwable throwable) {\n        if (canLog(level)) {\n            this.adapter.log(level, message, throwable);\n        }\n    }\n\n    /**\n     * Logs a debug message.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#DEBUG}, this message won't be logged.\n     *\n     * @param message the message to log\n     */", "    public void debug(final String message) {\n        log(LogLevel.DEBUG, message);\n    }\n\n    /**\n     * Logs a debug message with a stack trace.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#DEBUG}, this message won't be logged.\n     *\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */", "    public void debug(final String message, final Throwable throwable) {\n        log(LogLevel.DEBUG, message, throwable);\n    }\n\n    /**\n     * Logs an informational message.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#INFO}, this message won't be logged.\n     *\n     * @param message the message to log\n     */", "    public void info(final String message) {\n        log(LogLevel.INFO, message);\n    }\n\n    /**\n     * Logs an informational message with a stack trace.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#INFO}, this message won't be logged.\n     *\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */", "    public void info(final String message, final Throwable throwable) {\n        log(LogLevel.INFO, message, throwable);\n    }\n\n    /**\n     * Logs a warning message.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#WARN}, this message won't be logged.\n     *\n     * @param message the message to log\n     */", "    public void warn(final String message) {\n        log(LogLevel.WARN, message);\n    }\n\n    /**\n     * Logs a warning message with a stack trace.\n     * <p>\n     * If the logger's configured log level is more severe than\n     * {@link LogLevel#WARN}, this message won't be logged.\n     *\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */", "    public void warn(final String message, final Throwable throwable) {\n        log(LogLevel.WARN, message, throwable);\n    }\n\n    /**\n     * Logs an error message.\n     *\n     * @param message the message to log\n     */\n    public void error(final String message) {\n        log(LogLevel.ERROR, message);\n    }\n\n    /**\n     * Logs an error message with a stack trace.\n     *\n     * @param message   message to log\n     * @param throwable the throwable to print\n     */", "    public void error(final String message) {\n        log(LogLevel.ERROR, message);\n    }\n\n    /**\n     * Logs an error message with a stack trace.\n     *\n     * @param message   message to log\n     * @param throwable the throwable to print\n     */\n    public void error(final String message, final Throwable throwable) {\n        log(LogLevel.ERROR, message, throwable);\n    }\n}\n", "    public void error(final String message, final Throwable throwable) {\n        log(LogLevel.ERROR, message, throwable);\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/logging/adapters/LogAdapter.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging.adapters;\n\nimport net.byteflux.libby.logging.LogLevel;", "\nimport net.byteflux.libby.logging.LogLevel;\n\n/**\n * Logging interface for adapting platform-specific loggers to our logging API.\n */\npublic interface LogAdapter {\n    /**\n     * Logs a message with the provided level.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    void log(LogLevel level, String message);\n\n    /**\n     * Logs a message and stack trace with the provided level.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */\n    void log(LogLevel level, String message, Throwable throwable);\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/logging/adapters/JDKLogAdapter.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging.adapters;\n\nimport net.byteflux.libby.logging.LogLevel;", "\nimport net.byteflux.libby.logging.LogLevel;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Logging adapter that logs to a JDK logger.", "/**\n * Logging adapter that logs to a JDK logger.\n */\npublic class JDKLogAdapter implements LogAdapter {\n    /**\n     * JDK logger\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a new JDK log adapter that logs to a {@link Logger}.\n     *\n     * @param logger the JDK logger to wrap\n     */\n    public JDKLogAdapter(final Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the JDK logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", "    public void log(final LogLevel level, final String message) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.log(Level.FINE, message);\n                break;\n            case INFO:\n                this.logger.log(Level.INFO, message);\n                break;\n            case WARN:\n                this.logger.log(Level.WARNING, message);\n                break;\n            case ERROR:\n                this.logger.log(Level.SEVERE, message);\n                break;\n        }\n    }\n\n    /**\n     * Logs a message and stack trace with the provided level to the JDK\n     * logger.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */\n    @Override", "    public void log(final LogLevel level, final String message, final Throwable throwable) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.log(Level.FINE, message, throwable);\n                break;\n            case INFO:\n                this.logger.log(Level.INFO, message, throwable);\n                break;\n            case WARN:\n                this.logger.log(Level.WARNING, message, throwable);\n                break;\n            case ERROR:\n                this.logger.log(Level.SEVERE, message, throwable);\n                break;\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/relocation/RelocationHelper.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.relocation;\n\nimport net.byteflux.libby.Library;", "\nimport net.byteflux.libby.Library;\nimport net.byteflux.libby.LibraryManager;\nimport net.byteflux.libby.Repositories;\nimport net.byteflux.libby.classloader.IsolatedClassLoader;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.io.File;\nimport java.lang.reflect.Constructor;", "import java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * A reflection-based helper for relocating library jars. It automatically", "/**\n * A reflection-based helper for relocating library jars. It automatically\n * downloads and invokes Luck's Jar Relocator to perform jar relocations.\n *\n * @see <a href=\"https://github.com/lucko/jar-relocator\">Luck's Jar Relocator</a>\n */\npublic class RelocationHelper {\n    /**\n     * Reflected constructor for creating new jar relocator instances\n     */\n    private final Constructor<?> jarRelocatorConstructor;\n\n    /**\n     * Reflected method for running a jar relocator\n     */\n    private final Method jarRelocatorRunMethod;\n\n    /**\n     * Reflected constructor for creating relocation instances\n     */\n    private final Constructor<?> relocationConstructor;\n\n    /**\n     * Creates a new relocation helper using the provided library manager to\n     * download the dependencies required for runtime relocation.\n     *\n     * @param libraryManager the library manager used to download dependencies\n     */\n    public RelocationHelper(final LibraryManager libraryManager) {\n        requireNonNull(libraryManager, \"libraryManager\");\n\n        final IsolatedClassLoader classLoader = new IsolatedClassLoader();\n\n        // ObjectWeb ASM Commons\n        classLoader.addPath(libraryManager.downloadLibrary(\n                Library.builder()\n                        .groupId(\"org.ow2.asm\")\n                        .artifactId(\"asm-commons\")\n                        .version(\"9.5\")\n                        .checksum(\"cu7p+6+53o2UY/IN1YSkjO635RUq1MmHv74X3UgRya4=\")\n                        .repository(Repositories.MAVEN_CENTRAL)\n                        .build()\n        ));\n\n        // ObjectWeb ASM\n        classLoader.addPath(libraryManager.downloadLibrary(\n                Library.builder()\n                        .groupId(\"org.ow2.asm\")\n                        .artifactId(\"asm\")\n                        .version(\"9.5\")\n                        .checksum(\"ti6EtZgHKXUbBFjFNM8TZvcnVCu40VhiEzVoKkYPA1M=\")\n                        .repository(Repositories.MAVEN_CENTRAL)\n                        .build()\n        ));\n\n        // Luck's Jar Relocator\n        classLoader.addPath(libraryManager.downloadLibrary(\n                Library.builder()\n                        .groupId(\"me.lucko\")\n                        .artifactId(\"jar-relocator\")\n                        .version(\"1.7\")\n                        .checksum(\"b30RhOF6kHiHl+O5suNLh/+eAr1iOFEFLXhwkHHDu4I=\")\n                        .repository(Repositories.MAVEN_CENTRAL)\n                        .build()\n        ));\n", "        try {\n            final Class<?> jarRelocatorClass = classLoader.loadClass(\"me.lucko.jarrelocator.JarRelocator\");\n            final Class<?> relocationClass = classLoader.loadClass(\"me.lucko.jarrelocator.Relocation\");\n\n            // me.lucko.jarrelocator.JarRelocator(File, File, Collection)\n            this.jarRelocatorConstructor = jarRelocatorClass.getConstructor(File.class, File.class, Collection.class);\n\n            // me.lucko.jarrelocator.JarRelocator#run()\n            this.jarRelocatorRunMethod = jarRelocatorClass.getMethod(\"run\");\n\n            // me.lucko.jarrelocator.Relocation(String, String, Collection, Collection)\n            this.relocationConstructor = relocationClass.getConstructor(String.class, String.class, Collection.class, Collection.class);\n        } catch (final ReflectiveOperationException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Invokes the jar relocator to process the input jar and generate an\n     * output jar with the provided relocation rules applied.\n     *\n     * @param in          input jar\n     * @param out         output jar\n     * @param relocations relocations to apply\n     */", "    public void relocate(final Path in, final Path out, final Collection<Relocation> relocations) {\n        requireNonNull(in, \"in\");\n        requireNonNull(out, \"out\");\n        requireNonNull(relocations, \"relocations\");\n\n        try {\n            final List<Object> rules = new LinkedList<>();\n            for (final Relocation relocation : relocations) {\n                rules.add(this.relocationConstructor.newInstance(\n                        relocation.getPattern(),\n                        relocation.getRelocatedPattern(),\n                        relocation.getIncludes(),\n                        relocation.getExcludes()\n                ));\n            }\n\n            this.jarRelocatorRunMethod.invoke(this.jarRelocatorConstructor.newInstance(in.toFile(), out.toFile(), rules));\n        } catch (final ReflectiveOperationException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/net/byteflux/libby/relocation/Relocation.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.relocation;\n\nimport static java.util.Objects.requireNonNull;", "\nimport static java.util.Objects.requireNonNull;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedList;\n\n/**\n * Relocations are used to describe a search and replace pattern for renaming\n * packages in a library jar for the purpose of preventing namespace conflicts", " * Relocations are used to describe a search and replace pattern for renaming\n * packages in a library jar for the purpose of preventing namespace conflicts\n * with other plugins that bundle their own version of the same library.\n */\npublic class Relocation {\n    /**\n     * Search pattern\n     */\n    private final String pattern;\n\n    /**\n     * Replacement pattern\n     */\n    private final String relocatedPattern;\n\n    /**\n     * Classes and resources to include\n     */\n    private final Collection<String> includes;\n\n    /**\n     * Classes and resources to exclude\n     */\n    private final Collection<String> excludes;\n\n    /**\n     * Creates a new relocation.\n     *\n     * @param pattern          search pattern\n     * @param relocatedPattern replacement pattern\n     * @param includes         classes and resources to include\n     * @param excludes         classes and resources to exclude\n     */\n    public Relocation(final String pattern, final String relocatedPattern, final Collection<String> includes, final Collection<String> excludes) {\n        this.pattern = requireNonNull(pattern, \"pattern\").replace(\"{}\", \".\");\n        this.relocatedPattern = requireNonNull(relocatedPattern, \"relocatedPattern\").replace(\"{}\", \".\");\n        this.includes = includes != null ? Collections.unmodifiableList(new LinkedList<>(includes)) : Collections.emptyList();\n        this.excludes = excludes != null ? Collections.unmodifiableList(new LinkedList<>(excludes)) : Collections.emptyList();\n    }\n\n    /**\n     * Creates a new relocation with empty includes and excludes.\n     *\n     * @param pattern          search pattern\n     * @param relocatedPattern replacement pattern\n     */\n    public Relocation(final String pattern, final String relocatedPattern) {\n        this(pattern, relocatedPattern, null, null);\n    }\n\n    /**\n     * Creates a new relocation builder.\n     *\n     * @return new relocation builder\n     */", "    public static Builder builder() {\n        return new Builder();\n    }\n\n    /**\n     * Gets the search pattern.\n     *\n     * @return pattern to search\n     */\n    public String getPattern() {\n        return this.pattern;\n    }\n\n    /**\n     * Gets the replacement pattern.\n     *\n     * @return pattern to replace with\n     */", "    public String getPattern() {\n        return this.pattern;\n    }\n\n    /**\n     * Gets the replacement pattern.\n     *\n     * @return pattern to replace with\n     */\n    public String getRelocatedPattern() {\n        return this.relocatedPattern;\n    }\n\n    /**\n     * Gets included classes and resources.\n     *\n     * @return classes and resources to include\n     */\n    public Collection<String> getIncludes() {\n        return this.includes;\n    }\n\n    /**\n     * Gets excluded classes and resources.\n     *\n     * @return classes and resources to exclude\n     */\n    public Collection<String> getExcludes() {\n        return this.excludes;\n    }\n\n    /**\n     * Provides an alternative method of creating a {@link Relocation}. This\n     * builder may be more intuitive for configuring relocations that also have\n     * any includes or excludes.\n     */", "    public String getRelocatedPattern() {\n        return this.relocatedPattern;\n    }\n\n    /**\n     * Gets included classes and resources.\n     *\n     * @return classes and resources to include\n     */\n    public Collection<String> getIncludes() {\n        return this.includes;\n    }\n\n    /**\n     * Gets excluded classes and resources.\n     *\n     * @return classes and resources to exclude\n     */\n    public Collection<String> getExcludes() {\n        return this.excludes;\n    }\n\n    /**\n     * Provides an alternative method of creating a {@link Relocation}. This\n     * builder may be more intuitive for configuring relocations that also have\n     * any includes or excludes.\n     */", "    public static class Builder {\n        /**\n         * Classes and resources to include\n         */\n        private final Collection<String> includes = new LinkedList<>();\n        /**\n         * Classes and resources to exclude\n         */\n        private final Collection<String> excludes = new LinkedList<>();\n        /**\n         * Search pattern\n         */\n        private String pattern;\n        /**\n         * Replacement pattern\n         */\n        private String relocatedPattern;\n\n        /**\n         * Sets the search pattern.\n         *\n         * @param pattern pattern to search\n         * @return this builder\n         */", "        public Builder pattern(final String pattern) {\n            this.pattern = requireNonNull(pattern, \"pattern\");\n            return this;\n        }\n\n        /**\n         * Sets the replacement pattern.\n         *\n         * @param relocatedPattern pattern to replace with\n         * @return this builder\n         */", "        public Builder relocatedPattern(final String relocatedPattern) {\n            this.relocatedPattern = requireNonNull(relocatedPattern, \"relocatedPattern\");\n            return this;\n        }\n\n        /**\n         * Adds a class or resource to be included.\n         *\n         * @param include class or resource to include\n         * @return this builder\n         */", "        public Builder include(final String include) {\n            this.includes.add(requireNonNull(include, \"include\"));\n            return this;\n        }\n\n        /**\n         * Adds a class or resource to be excluded.\n         *\n         * @param exclude class or resource to exclude\n         * @return this builder\n         */", "        public Builder exclude(final String exclude) {\n            this.excludes.add(requireNonNull(exclude, \"exclude\"));\n            return this;\n        }\n\n        /**\n         * Creates a new relocation using this builder's configuration.\n         *\n         * @return new relocation\n         */\n        public Relocation build() {\n            return new Relocation(this.pattern, this.relocatedPattern, this.includes, this.excludes);\n        }\n    }\n}\n", "        public Relocation build() {\n            return new Relocation(this.pattern, this.relocatedPattern, this.includes, this.excludes);\n        }\n    }\n}\n"]}
{"filename": "log4j/src/main/java/net/byteflux/libby/logging/adapters/Log4jLogAdapter.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby.logging.adapters;\n\nimport net.byteflux.libby.logging.LogLevel;", "\nimport net.byteflux.libby.logging.LogLevel;\nimport org.apache.logging.log4j.Logger;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Logging adapter that logs to a Log4J logger.\n * @since 2.0.1\n */\npublic class Log4jLogAdapter implements LogAdapter {\n\n    /**\n     * Log4J logger\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a new Log4J log adapter that logs to a {@link Logger}.\n     *\n     * @param logger the Log4J logger to wrap\n     */\n    public Log4jLogAdapter(final Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the Log4J logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", " * @since 2.0.1\n */\npublic class Log4jLogAdapter implements LogAdapter {\n\n    /**\n     * Log4J logger\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a new Log4J log adapter that logs to a {@link Logger}.\n     *\n     * @param logger the Log4J logger to wrap\n     */\n    public Log4jLogAdapter(final Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }\n\n    /**\n     * Logs a message with the provided level to the Log4J logger.\n     *\n     * @param level   message severity level\n     * @param message the message to log\n     */\n    @Override", "    public void log(final LogLevel level, final String message) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message);\n                break;\n            case INFO:\n                this.logger.info(message);\n                break;\n            case WARN:\n                this.logger.warn(message);\n                break;\n            case ERROR:\n                this.logger.error(message);\n                break;\n        }\n    }\n\n    /**\n     * Logs a message and stack trace with the provided level to the Log4J logger.\n     *\n     * @param level     message severity level\n     * @param message   the message to log\n     * @param throwable the throwable to print\n     */\n    @Override", "    public void log(final LogLevel level, final String message, final Throwable throwable) {\n        switch (requireNonNull(level, \"level\")) {\n            case DEBUG:\n                this.logger.debug(message, throwable);\n                break;\n            case INFO:\n                this.logger.info(message, throwable);\n                break;\n            case WARN:\n                this.logger.warn(message, throwable);\n                break;\n            case ERROR:\n                this.logger.error(message, throwable);\n                break;\n        }\n    }\n}\n"]}
{"filename": "sponge/src/main/java/net/byteflux/libby/SpongeLibraryManager.java", "chunked_list": ["/*\n * This file is part of Libby, licensed under the MIT License.\n *\n * Copyright (c) 2019-2023 Matthew Harris\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage net.byteflux.libby;\n\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;", "\nimport net.byteflux.libby.classloader.URLClassLoaderHelper;\nimport net.byteflux.libby.logging.adapters.Log4jLogAdapter;\nimport org.apache.logging.log4j.Logger;\nimport org.jetbrains.annotations.NotNull;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;", "import java.net.URLClassLoader;\nimport java.nio.file.Path;\n\n/**\n * A runtime dependency manager for Sponge plugins.\n */\npublic class SpongeLibraryManager<T> extends LibraryManager {\n\n    /**\n     * The plugin instance required by the plugin manager to add files to the\n     * plugin's classpath\n     */\n    private final T plugin;\n\n\n    /**\n     * Plugin classpath helper\n     */\n    private final URLClassLoaderHelper classLoader;\n\n    /**\n     * Creates a new Sponge library manager.\n     *\n     * @param logger        the plugin logger\n     * @param dataDirectory plugin's data directory\n     * @param plugin        the plugin to manage\n     * @param directoryName download directory name\n     * @since 2.0.1\n     */\n    public SpongeLibraryManager(final Logger logger,\n                                  final Path dataDirectory,\n                                  final T plugin,\n                                  final String directoryName) {\n\n        super(new Log4jLogAdapter(logger), dataDirectory, directoryName);\n        this.plugin = requireNonNull(plugin, \"plugin\");\n        this.classLoader = new URLClassLoaderHelper((URLClassLoader) requireNonNull(plugin, \"plugin\").getClass().getClassLoader(), this);\n    }\n\n    /**\n     * Creates a new Sponge library manager.\n     *\n     * @param logger        the plugin logger\n     * @param dataDirectory plugin's data directory\n     * @param plugin        the plugin to manage\n     * @since 2.0.1\n     */\n    public SpongeLibraryManager(final Logger logger,\n                                  final Path dataDirectory,\n                                  final T plugin) {\n        this(logger, dataDirectory, plugin, \"libs\");\n    }\n\n    /**\n     * Adds a file to the Sponge plugin's classpath.\n     *\n     * @param file the file to add\n     */\n    @Override\n    protected void addToClasspath(final @NotNull Path file) {\n        this.classLoader.addToClasspath(file);\n    }\n}\n"]}
