{"filename": "src/test/java/com/microsoft/lst_bench/DriverSparkTest.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench;\n\nimport com.microsoft.lst_bench.input.TaskLibrary;", "\nimport com.microsoft.lst_bench.input.TaskLibrary;\nimport com.microsoft.lst_bench.input.Workload;\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.ImmutableExperimentConfig;\nimport com.microsoft.lst_bench.input.config.TelemetryConfig;\nimport com.microsoft.lst_bench.util.FileParser;\nimport java.io.File;\nimport java.nio.file.Path;", "import java.io.File;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIfSystemProperty;\nimport org.junit.jupiter.api.io.TempDir;", "import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\nimport org.junit.jupiter.api.io.TempDir;\n\n/** Unit test for LST-Bench driver running on Spark. */\n@EnabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \"spark\")\npublic class DriverSparkTest {\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"delta\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")\n  public void testJDBCTPCDSAllTasksDelta() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds-delta.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCDSAllTasksDelta() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds-delta.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCDSAllTasksHudi() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-hudi.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds-hudi.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"iceberg\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCDSAllTasksIceberg() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds-iceberg.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"delta\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCHAllTasksDelta() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpch/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpch-delta.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCHAllTasksHudi() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-hudi.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpch/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpch-hudi.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"iceberg\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCTPCHAllTasksIceberg() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpch/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpch-iceberg.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"delta\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCMultiConnectionDelta() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/test/resources/config/spark/simplified_task_library.yaml\",\n        \"src/test/resources/config/spark/w_multi_connection-delta.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCMultiConnectionHudi() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-hudi.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/test/resources/config/spark/simplified_task_library.yaml\",\n        \"src/test/resources/config/spark/w_multi_connection-hudi.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"iceberg\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCMultiConnectionIceberg() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/test/resources/config/spark/simplified_task_library.yaml\",\n        \"src/test/resources/config/spark/w_multi_connection-iceberg.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"delta\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCSessionDelta() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session_jdbc-delta.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCSessionHudi() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-hudi.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session_jdbc-hudi.yaml\");\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"iceberg\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"jdbc\")", "  public void testJDBCSessionIceberg() throws Exception {\n    runDriver(\n        \"src/test/resources/config/spark/jdbc_connection_config.yaml\",\n        \"src/test/resources/config/spark/experiment_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session_jdbc-iceberg.yaml\");\n  }\n\n  private void runDriver(String arg0, String arg1, String arg2, String arg3, String arg4)\n      throws Exception {\n    Driver.main(new String[] {\"-c\", arg0, \"-e\", arg1, \"-t\", arg2, \"-l\", arg3, \"-w\", arg4});\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"delta\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"spark\")", "  public void testSparkSessionDelta(@TempDir Path tempDir) throws Exception {\n    testSparkSession(\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session-delta.yaml\",\n        \"src/test/resources/config/spark/spark_connection_config-delta.yaml\",\n        \"src/test/resources/config/spark/experiment_config-delta.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        tempDir);\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"hudi\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"spark\")", "  public void testSparkSessionHudi(@TempDir Path tempDir) throws Exception {\n    testSparkSession(\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session-hudi.yaml\",\n        \"src/test/resources/config/spark/spark_connection_config-hudi.yaml\",\n        \"src/test/resources/config/spark/experiment_config-hudi.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        tempDir);\n  }\n\n  @Test\n  @EnabledIfSystemProperty(named = \"lst-bench.test.lst\", matches = \"iceberg\")\n  @EnabledIfSystemProperty(named = \"lst-bench.test.connection\", matches = \"spark\")", "  public void testSparkSessionIceberg(@TempDir Path tempDir) throws Exception {\n    testSparkSession(\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/test/resources/config/spark/w_all_tpcds_single_session-iceberg.yaml\",\n        \"src/test/resources/config/spark/spark_connection_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/experiment_config-iceberg.yaml\",\n        \"src/test/resources/config/spark/telemetry_config.yaml\",\n        tempDir);\n  }\n\n  private void testSparkSession(\n      String arg0, String arg1, String arg2, String arg3, String arg4, Path tempDir)\n      throws Exception {\n    // Create Java objects from input files\n    TaskLibrary taskLibrary = FileParser.createObject(arg0, TaskLibrary.class);\n    Workload workload = FileParser.createObject(arg1, Workload.class);\n    ConnectionsConfig connectionsConfig = FileParser.createObject(arg2, ConnectionsConfig.class);\n    ExperimentConfig experimentConfig = FileParser.createObject(arg3, ExperimentConfig.class);\n    TelemetryConfig telemetryConfig = FileParser.createObject(arg4, TelemetryConfig.class);\n\n    // Setup path\n    experimentConfig = ingestTempDir(experimentConfig, tempDir);\n    createTempDirs(\n        Path.of(\n            Objects.requireNonNull(experimentConfig.getParameterValues())\n                .get(\"external_data_path\")\n                .toString()));\n\n    // Run driver\n    Driver.run(taskLibrary, workload, connectionsConfig, experimentConfig, telemetryConfig);\n  }\n\n  private ExperimentConfig ingestTempDir(ExperimentConfig experimentConfig, Path tempDir) {\n    Map<String, Object> parameterValues =\n        new HashMap<>(Objects.requireNonNull(experimentConfig.getParameterValues()));\n    parameterValues.compute(\"external_data_path\", (k, value) -> tempDir.toString() + value);\n    parameterValues.compute(\"data_path\", (k, value) -> tempDir.toString() + value);\n    return ImmutableExperimentConfig.builder()\n        .from(experimentConfig)\n        .parameterValues(parameterValues)\n        .build();\n  }\n\n  private void createTempDirs(Path tempDir) {\n    List<String> tableDirs =\n        Arrays.asList(\n            \"/call_center\",\n            \"/catalog_page\",\n            \"/catalog_returns\",\n            \"/catalog_sales\",\n            \"/customer\",\n            \"/customer_address\",\n            \"/customer_demographics\",\n            \"/date_dim\",\n            \"/household_demographics\",\n            \"/income_band\",\n            \"/inventory\",\n            \"/item\",\n            \"/promotion\",\n            \"/reason\",\n            \"/ship_mode\",\n            \"/store\",\n            \"/store_returns\",\n            \"/store_sales\",\n            \"/time_dim\",\n            \"/warehouse\",\n            \"/web_page\",\n            \"/web_returns\",\n            \"/web_sales\",\n            \"/web_site\");", "    for (String tableDir : tableDirs) {\n      File dir = new File(tempDir + tableDir);\n      dir.mkdirs();\n    }\n  }\n}\n"]}
{"filename": "src/test/java/com/microsoft/lst_bench/common/LSTBenchmarkExecutorTest.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.microsoft.lst_bench.client.ClientException;", "\nimport com.microsoft.lst_bench.client.ClientException;\nimport com.microsoft.lst_bench.client.Connection;\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.input.BenchmarkObjectFactory;\nimport com.microsoft.lst_bench.input.ImmutableTaskLibrary;\nimport com.microsoft.lst_bench.input.ImmutableWorkload;\nimport com.microsoft.lst_bench.input.TaskLibrary;\nimport com.microsoft.lst_bench.input.Workload;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;", "import com.microsoft.lst_bench.input.Workload;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.ImmutableExperimentConfig;\nimport com.microsoft.lst_bench.input.config.ImmutableJDBCConnectionConfig;\nimport com.microsoft.lst_bench.input.config.TelemetryConfig;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.util.FileParser;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;", "import java.io.IOException;\nimport java.net.URL;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.UUID;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.DisabledIfSystemProperty;\nimport org.mockito.Mockito;\n\n@DisabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \".*\")\nclass LSTBenchmarkExecutorTest {\n\n  private UUID telemetryDbFileName;\n", "  private UUID telemetryDbFileName;\n\n  @BeforeEach\n  void setUp() {\n    telemetryDbFileName = UUID.randomUUID();\n  }\n\n  @AfterEach\n  void tearDown() {\n    File telemetryDbFile = new File(telemetryDbFileName.toString());\n    if (telemetryDbFile.exists()) {\n      telemetryDbFile.delete();\n    }\n\n    File telemetryDbWalFile = new File(telemetryDbFileName.toString() + \".wal\");", "  void tearDown() {\n    File telemetryDbFile = new File(telemetryDbFileName.toString());\n    if (telemetryDbFile.exists()) {\n      telemetryDbFile.delete();\n    }\n\n    File telemetryDbWalFile = new File(telemetryDbFileName.toString() + \".wal\");\n    if (telemetryDbWalFile.exists()) {\n      telemetryDbWalFile.delete();\n    }\n  }\n\n  /**\n   * This is a no-op test that does not actually run any tasks. It tests that the benchmark executor\n   * can be created and run without any exceptions, even without a valid workload. It also captures\n   * the minimum configuration required to run the benchmark executor.\n   */\n  @Test\n  void testNoOpSetup() throws Exception {\n    var idToConnectionManager = new ArrayList<ConnectionManager>();\n    ExperimentConfig experimentConfig =\n        ImmutableExperimentConfig.builder().id(\"nooptest\").version(1).repetitions(1).build();\n    TaskLibrary taskLibrary = ImmutableTaskLibrary.builder().version(1).build();\n    Workload workload = ImmutableWorkload.builder().id(\"nooptest\").version(1).build();\n\n    var config = BenchmarkObjectFactory.benchmarkConfig(experimentConfig, taskLibrary, workload);\n\n    SQLTelemetryRegistry telemetryRegistry = getTelemetryRegistry();\n\n    LSTBenchmarkExecutor benchmark =\n        new LSTBenchmarkExecutor(idToConnectionManager, config, telemetryRegistry);\n    benchmark.run();\n  }\n\n  /**\n   * This test runs a sample benchmark workload with a mock connection manager. The mock connection\n   * manager does not execute any sql. As such the test can validate the telemetry events that are\n   * generated by the benchmark executor. The test events are fetched from the telemetry database.\n   */\n  @Test\n  void testExperimentTimelineTelemetry() throws Exception {\n\n    Connection mockConnection = Mockito.mock(Connection.class);\n    ConnectionManager mockConnectionManager = Mockito.mock(ConnectionManager.class);\n    Mockito.when(mockConnectionManager.createConnection()).thenReturn(mockConnection);\n\n    // Current workload relies on 2 connection managers\n    var connectionManagers = new ArrayList<ConnectionManager>();\n    connectionManagers.add(mockConnectionManager);\n    connectionManagers.add(mockConnectionManager);\n\n    ExperimentConfig experimentConfig =\n        ImmutableExperimentConfig.builder().id(\"telemetryTest\").version(1).repetitions(1).build();\n\n    URL taskLibFile =\n        getClass().getClassLoader().getResource(\"./config/samples/task_library_0.yaml\");\n    Assertions.assertNotNull(taskLibFile);\n    TaskLibrary taskLibrary = FileParser.createObject(taskLibFile.getFile(), TaskLibrary.class);\n\n    URL workloadFile =\n        getClass().getClassLoader().getResource(\"./config/spark/w_all_tpcds-delta.yaml\");\n    Assertions.assertNotNull(workloadFile);\n    Workload workload = FileParser.createObject(workloadFile.getFile(), Workload.class);\n\n    var config = BenchmarkObjectFactory.benchmarkConfig(experimentConfig, taskLibrary, workload);\n\n    SQLTelemetryRegistry telemetryRegistry = getTelemetryRegistry();\n\n    LSTBenchmarkExecutor benchmark =\n        new LSTBenchmarkExecutor(connectionManagers, config, telemetryRegistry);\n    benchmark.run();\n\n    try (var validationConnection =\n        DriverManager.getConnection(\"jdbc:duckdb:./\" + telemetryDbFileName)) {\n      ResultSet resultset =\n          validationConnection.createStatement().executeQuery(\"SELECT * FROM experiment_telemetry\");\n      int totalEvents = 0;", "      while (resultset.next()) {\n        totalEvents++;\n      }\n      Assertions.assertEquals(170, totalEvents);\n\n      // TODO improve event validation\n    }\n  }\n\n  private SQLTelemetryRegistry getTelemetryRegistry() throws ClientException, IOException {\n    URL telemetryConfigFile =\n        getClass().getClassLoader().getResource(\"./config/spark/telemetry_config.yaml\");\n    Assertions.assertNotNull(telemetryConfigFile);\n    TelemetryConfig telemetryConfig =\n        FileParser.createObject(telemetryConfigFile.getFile(), TelemetryConfig.class);\n\n    var uniqueTelemetryDbName =\n        ImmutableJDBCConnectionConfig.builder()\n            .from(telemetryConfig.getConnection())\n            .url(\"jdbc:duckdb:./\" + telemetryDbFileName)\n            .build();\n\n    return new SQLTelemetryRegistry(\n        BenchmarkObjectFactory.connectionManager(uniqueTelemetryDbName),\n        telemetryConfig.isExecuteDDL(),\n        telemetryConfig.getDDLFile(),\n        telemetryConfig.getInsertFile(),\n        telemetryConfig.getParameterValues());\n  }\n}\n"]}
{"filename": "src/test/java/com/microsoft/lst_bench/input/ValidationTest.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.databind.JsonNode;", "\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.TelemetryConfig;\nimport com.microsoft.lst_bench.util.FileParser;\nimport com.networknt.schema.JsonSchema;\nimport com.networknt.schema.JsonSchemaFactory;", "import com.networknt.schema.JsonSchema;\nimport com.networknt.schema.JsonSchemaFactory;\nimport com.networknt.schema.SpecVersion;\nimport com.networknt.schema.ValidationMessage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Set;\nimport org.junit.jupiter.api.Assertions;", "import java.util.Set;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.condition.DisabledIfSystemProperty;\nimport org.junit.jupiter.api.condition.EnabledOnOs;\nimport org.junit.jupiter.api.condition.OS;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/** Tests for POJO representation matching to YAML schema. */\n@DisabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \".*\")\npublic class ValidationTest {\n\n  private static final String SCHEMAS_PATH =\n      \"src\"\n          + File.separator\n          + \"main\"\n          + File.separator\n          + \"resources\"\n          + File.separator\n          + \"schemas\"\n          + File.separator;\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(\n      strings = {\n        \"src/main/resources/config/spark/sample_experiment_config.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-delta.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-hudi.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-iceberg.yaml\"\n      })", "/** Tests for POJO representation matching to YAML schema. */\n@DisabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \".*\")\npublic class ValidationTest {\n\n  private static final String SCHEMAS_PATH =\n      \"src\"\n          + File.separator\n          + \"main\"\n          + File.separator\n          + \"resources\"\n          + File.separator\n          + \"schemas\"\n          + File.separator;\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(\n      strings = {\n        \"src/main/resources/config/spark/sample_experiment_config.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-delta.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-hudi.yaml\",\n        \"src/main/resources/config/trino/sample_experiment_config-iceberg.yaml\"\n      })", "  public void testValidationExperimentConfigUnix(String experimentConfigFilePath)\n      throws IOException {\n    testValidationExperimentConfig(experimentConfigFilePath);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.WINDOWS})\n  @ValueSource(\n      strings = {\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\sample_experiment_config.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\sample_experiment_config-delta.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\sample_experiment_config-hudi.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\sample_experiment_config-iceberg.yaml\"\n      })", "  public void testValidationExperimentConfigWin(String experimentConfigFilePath)\n      throws IOException {\n    testValidationExperimentConfig(experimentConfigFilePath);\n  }\n\n  private void testValidationExperimentConfig(String experimentConfigFilePath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(Files.newInputStream(Paths.get(SCHEMAS_PATH + \"experiment_config.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect =\n        mapper.readTree(Files.newInputStream(Paths.get(experimentConfigFilePath)));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    ExperimentConfig experimentConfig =\n        FileParser.createObject(experimentConfigFilePath, ExperimentConfig.class);\n    JsonNode jsonNodeObject = mapper.convertValue(experimentConfig, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(\n      strings = {\n        \"src/test/resources/config/samples/connections_config_test0.yaml\",\n        \"src/main/resources/config/spark/sample_connections_config.yaml\",\n        \"src/main/resources/config/trino/sample_connections_config.yaml\"\n      })", "  public void testValidationConnectionsConfigUnix(String configFilePath) throws IOException {\n    testValidationConnectionsConfig(configFilePath);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.WINDOWS})\n  @ValueSource(\n      strings = {\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\sample_connections_config.yaml\",\n        \"src\\\\test\\\\resources\\\\config\\\\samples\\\\connections_config_test0.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\sample_connections_config.yaml\"\n      })", "  public void testValidationConnectionsConfigWin(String configFilePath) throws IOException {\n    testValidationConnectionsConfig(configFilePath);\n  }\n\n  private void testValidationConnectionsConfig(String configFilePath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(\n            Files.newInputStream(Paths.get(SCHEMAS_PATH + \"connections_config.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect = mapper.readTree(Files.newInputStream(Paths.get(configFilePath)));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    ConnectionsConfig connectionsConfig =\n        FileParser.createObject(configFilePath, ConnectionsConfig.class);\n    JsonNode jsonNodeObject = mapper.convertValue(connectionsConfig, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(\n      strings = {\n        \"src/main/resources/config/spark/tpcds/task_library.yaml\",\n        \"src/main/resources/config/trino/tpcds/task_library.yaml\",\n        \"src/main/resources/config/spark/tpch/task_library.yaml\"\n      })", "  public void testValidationTaskLibraryUnix(String taskLibraryPath) throws IOException {\n    testValidationTaskLibrary(taskLibraryPath);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.WINDOWS})\n  @ValueSource(\n      strings = {\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\task_library.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\tpcds\\\\task_library.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpch\\\\task_library.yaml\"\n      })", "  public void testValidationTaskLibraryWin(String taskLibraryPath) throws IOException {\n    testValidationTaskLibrary(taskLibraryPath);\n  }\n\n  private void testValidationTaskLibrary(String taskLibraryPath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(Files.newInputStream(Paths.get(SCHEMAS_PATH + \"task_library.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect = mapper.readTree(Files.newInputStream(Paths.get(taskLibraryPath)));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    TaskLibrary taskLibrary = FileParser.createObject(taskLibraryPath, TaskLibrary.class);\n    JsonNode jsonNodeObject = mapper.convertValue(taskLibrary, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(\n      strings = {\n        \"src/main/resources/config/spark/tpcds/w0_tpcds-delta.yaml\",\n        \"src/main/resources/config/spark/tpcds/w0_tpcds-hudi.yaml\",\n        \"src/main/resources/config/spark/tpcds/w0_tpcds-iceberg.yaml\",\n        \"src/main/resources/config/spark/tpcds/wp1_longevity.yaml\",\n        \"src/main/resources/config/spark/tpcds/wp2_resilience.yaml\",\n        \"src/main/resources/config/spark/tpcds/wp3_rw_concurrency.yaml\",\n        \"src/main/resources/config/spark/tpcds/wp3_rw_concurrency_multi.yaml\",\n        \"src/main/resources/config/spark/tpcds/wp4_time_travel.yaml\",\n        \"src/main/resources/config/trino/tpcds/w0_tpcds.yaml\",\n        \"src/main/resources/config/trino/tpcds/wp1_longevity.yaml\",\n        \"src/main/resources/config/trino/tpcds/wp2_resilience.yaml\",\n        \"src/main/resources/config/trino/tpcds/wp3_rw_concurrency.yaml\",\n        \"src/main/resources/config/spark/tpch/w0_tpch-delta.yaml\",\n        \"src/main/resources/config/spark/tpch/w0_tpch-hudi.yaml\",\n        \"src/main/resources/config/spark/tpch/w0_tpch-iceberg.yaml\"\n      })", "  public void testValidationWorkloadUnix(String workloadFilePath) throws IOException {\n    testValidationWorkload(workloadFilePath);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.WINDOWS})\n  @ValueSource(\n      strings = {\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\w0_tpcds-delta.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\w0_tpcds-hudi.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\w0_tpcds-iceberg.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\wp1_longevity.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\wp2_resilience.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\wp3_rw_concurrency.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\wp3_rw_concurrency_multi.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpcds\\\\wp4_time_travel.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\tpcds\\\\w0_tpcds.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\tpcds\\\\wp1_longevity.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\tpcds\\\\wp2_resilience.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\trino\\\\tpcds\\\\wp3_rw_concurrency.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpch\\\\w0_tpch-delta.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpch\\\\w0_tpch-hudi.yaml\",\n        \"src\\\\main\\\\resources\\\\config\\\\spark\\\\tpch\\\\w0_tpch-iceberg.yaml\"\n      })", "  public void testValidationWorkloadWin(String workloadFilePath) throws IOException {\n    testValidationWorkload(workloadFilePath);\n  }\n\n  private void testValidationWorkload(String workloadFilePath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(Files.newInputStream(Paths.get(SCHEMAS_PATH + \"workload.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect = mapper.readTree(Files.newInputStream(Paths.get(workloadFilePath)));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    Workload workload = FileParser.createObject(workloadFilePath, Workload.class);\n    JsonNode jsonNodeObject = mapper.convertValue(workload, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.LINUX, OS.MAC})\n  @ValueSource(strings = {\"src/main/resources/config/spark/\", \"src/main/resources/config/trino/\"})", "  public void testValidationTelemetryConfigUnix(String configPath) throws IOException {\n    testValidationTelemetryConfig(configPath);\n  }\n\n  @ParameterizedTest\n  @EnabledOnOs({OS.WINDOWS})\n  @ValueSource(\n      strings = {\"src\\\\main\\\\resources\\\\config\\\\spark\\\\\", \"src\\\\main\\\\resources\\\\config\\\\trino\\\\\"})\n  public void testValidationTelemetryConfigWin(String configPath) throws IOException {\n    testValidationTelemetryConfig(configPath);\n  }\n\n  private void testValidationTelemetryConfig(String configPath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(Files.newInputStream(Paths.get(SCHEMAS_PATH + \"telemetry_config.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect =\n        mapper.readTree(\n            Files.newInputStream(Paths.get(configPath + \"sample_telemetry_config.yaml\")));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    TelemetryConfig telemetryConfig =\n        FileParser.createObject(configPath + \"sample_telemetry_config.yaml\", TelemetryConfig.class);\n    JsonNode jsonNodeObject = mapper.convertValue(telemetryConfig, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n}\n", "  public void testValidationTelemetryConfigWin(String configPath) throws IOException {\n    testValidationTelemetryConfig(configPath);\n  }\n\n  private void testValidationTelemetryConfig(String configPath) throws IOException {\n    ObjectMapper mapper = new YAMLMapper();\n    // Read schema\n    JsonSchemaFactory factory =\n        JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))\n            .objectMapper(mapper)\n            .build();\n    JsonSchema schema =\n        factory.getSchema(Files.newInputStream(Paths.get(SCHEMAS_PATH + \"telemetry_config.json\")));\n    // Validate YAML file contents\n    JsonNode jsonNodeDirect =\n        mapper.readTree(\n            Files.newInputStream(Paths.get(configPath + \"sample_telemetry_config.yaml\")));\n    Set<ValidationMessage> errorsFromFile = schema.validate(jsonNodeDirect);\n    Assertions.assertEquals(\n        0, errorsFromFile.size(), () -> \"Errors found in validation: \" + errorsFromFile);\n    // Validate YAML generated from POJO object\n    TelemetryConfig telemetryConfig =\n        FileParser.createObject(configPath + \"sample_telemetry_config.yaml\", TelemetryConfig.class);\n    JsonNode jsonNodeObject = mapper.convertValue(telemetryConfig, JsonNode.class);\n    Set<ValidationMessage> errorsFromPOJO = schema.validate(jsonNodeObject);\n    Assertions.assertEquals(\n        0, errorsFromPOJO.size(), () -> \"Errors found in validation: \" + errorsFromPOJO);\n  }\n}\n"]}
{"filename": "src/test/java/com/microsoft/lst_bench/input/ParserTest.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;", "\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.JDBCConnectionConfig;\nimport com.microsoft.lst_bench.input.config.SparkConnectionConfig;\nimport com.microsoft.lst_bench.input.config.TelemetryConfig;\nimport com.microsoft.lst_bench.util.FileParser;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;", "import java.io.IOException;\nimport java.util.List;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.DisabledIfSystemProperty;\nimport org.junitpioneer.jupiter.SetEnvironmentVariable;\n\n/** Tests for YAML parser into POJO representation. */\n@DisabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \".*\")\npublic class ParserTest {\n\n  private static final String CONFIG_PATH =\n      \"src\"\n          + File.separator\n          + \"main\"\n          + File.separator\n          + \"resources\"\n          + File.separator\n          + \"config\"\n          + File.separator\n          + \"spark\"\n          + File.separator;\n\n  @Test", "@DisabledIfSystemProperty(named = \"lst-bench.test.db\", matches = \".*\")\npublic class ParserTest {\n\n  private static final String CONFIG_PATH =\n      \"src\"\n          + File.separator\n          + \"main\"\n          + File.separator\n          + \"resources\"\n          + File.separator\n          + \"config\"\n          + File.separator\n          + \"spark\"\n          + File.separator;\n\n  @Test", "  public void testParseExperimentConfig() throws IOException {\n    ExperimentConfig experimentConfig =\n        FileParser.createObject(\n            CONFIG_PATH + \"sample_experiment_config.yaml\", ExperimentConfig.class);\n    Assertions.assertEquals(1, experimentConfig.getVersion());\n    Assertions.assertEquals(\"spark_del_sf_10\", experimentConfig.getId());\n    Assertions.assertNotNull(experimentConfig.getMetadata());\n    Assertions.assertEquals(\"spark\", experimentConfig.getMetadata().get(\"system\"));\n    Assertions.assertEquals(\"3.3.1\", experimentConfig.getMetadata().get(\"system_version\"));\n    Assertions.assertEquals(\"delta\", experimentConfig.getMetadata().get(\"table_format\"));\n    Assertions.assertEquals(\"2.2.0\", experimentConfig.getMetadata().get(\"table_format_version\"));\n    Assertions.assertEquals(\"10\", experimentConfig.getMetadata().get(\"scale_factor\"));\n    Assertions.assertEquals(\"cow\", experimentConfig.getMetadata().get(\"mode\"));\n    Assertions.assertNotNull(experimentConfig.getParameterValues());\n    Assertions.assertEquals(\n        \"spark_catalog\", experimentConfig.getParameterValues().get(\"external_catalog\"));\n    Assertions.assertEquals(\n        \"external_tpcds\", experimentConfig.getParameterValues().get(\"external_database\"));\n    Assertions.assertEquals(\n        \"csv\", experimentConfig.getParameterValues().get(\"external_table_format\"));\n    Assertions.assertEquals(\n        \"abfss://mycontainer@myaccount.dfs.core.windows.net/sf_10/\",\n        experimentConfig.getParameterValues().get(\"external_data_path\"));\n    Assertions.assertEquals(\n        \",header=\\\"true\\\"\", experimentConfig.getParameterValues().get(\"external_options_suffix\"));\n    Assertions.assertEquals(\n        \"\", experimentConfig.getParameterValues().get(\"external_tblproperties_suffix\"));\n    Assertions.assertEquals(\"spark_catalog\", experimentConfig.getParameterValues().get(\"catalog\"));\n    Assertions.assertEquals(\"delta_tpcds\", experimentConfig.getParameterValues().get(\"database\"));\n    Assertions.assertEquals(\"delta\", experimentConfig.getParameterValues().get(\"table_format\"));\n    Assertions.assertEquals(\n        \"abfss://mycontainer@myaccount.dfs.core.windows.net/delta/sf_10/\",\n        experimentConfig.getParameterValues().get(\"data_path\"));\n    Assertions.assertEquals(\"\", experimentConfig.getParameterValues().get(\"options_suffix\"));\n    Assertions.assertEquals(\"\", experimentConfig.getParameterValues().get(\"tblproperties_suffix\"));\n  }\n\n  @Test\n  @SetEnvironmentVariable(key = \"DATABASE_PASSWORD\", value = \"p@ssw0rd0\")", "  public void testParseConnectionConfig() throws IOException {\n    ConnectionsConfig connectionsConfig =\n        FileParser.createObject(\n            CONFIG_PATH + \"sample_connections_config.yaml\", ConnectionsConfig.class);\n    Assertions.assertEquals(1, connectionsConfig.getVersion());\n    Assertions.assertEquals(3, connectionsConfig.getConnections().size());\n    JDBCConnectionConfig connection0 =\n        (JDBCConnectionConfig) connectionsConfig.getConnections().get(0);\n    Assertions.assertEquals(\"spark_0\", connection0.getId());\n    Assertions.assertEquals(\"org.apache.hive.jdbc.HiveDriver\", connection0.getDriver());\n    Assertions.assertEquals(\"jdbc:hive2://127.0.0.1:10000\", connection0.getUrl());\n    Assertions.assertEquals(\"spark_admin\", connection0.getUsername()); // Default value.\n    Assertions.assertEquals(\n        \"p@ssw0rd0\", connection0.getPassword()); // Set via DATABASE_PASSWORD environment variable.\n    JDBCConnectionConfig connection1 =\n        (JDBCConnectionConfig) connectionsConfig.getConnections().get(1);\n    Assertions.assertEquals(\"spark_1\", connection1.getId());\n    Assertions.assertEquals(\"org.apache.hive.jdbc.HiveDriver\", connection1.getDriver());\n    Assertions.assertEquals(\"jdbc:hive2://127.0.0.1:10001\", connection1.getUrl());\n    Assertions.assertEquals(\"admin\", connection1.getUsername());\n    Assertions.assertEquals(\"p@ssw0rd1\", connection1.getPassword());\n    SparkConnectionConfig connection2 =\n        (SparkConnectionConfig) connectionsConfig.getConnections().get(2);\n    Assertions.assertEquals(\"spark_2\", connection2.getId());\n    Assertions.assertEquals(\"spark://127.0.0.1:7077\", connection2.getUrl());\n    // TODO\n  }\n\n  @Test", "  public void testParseTaskLibrary() throws IOException {\n    TaskLibrary taskLibrary =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"task_library.yaml\", TaskLibrary.class);\n    Assertions.assertEquals(1, taskLibrary.getVersion());\n    Assertions.assertEquals(13, taskLibrary.getTaskTemplates().size());\n    for (TaskTemplate taskTemplate : taskLibrary.getTaskTemplates()) {\n      switch (taskTemplate.getId()) {\n        case \"setup\":\n          Assertions.assertEquals(\n              \"src/main/resources/scripts/tpcds/setup/spark/ddl-external-tables.sql\",\n              taskTemplate.getFiles().get(0));\n          Assertions.assertNull(taskTemplate.getParameterValuesFile());\n          Assertions.assertNull(taskTemplate.getPermutationOrdersDirectory());\n          Assertions.assertNull(taskTemplate.supportsTimeTravel());\n          break;\n        case \"setup_data_maintenance\":\n          Assertions.assertEquals(\n              \"src/main/resources/auxiliary/tpcds/setup_data_maintenance/parameter_values.dat\",\n              taskTemplate.getParameterValuesFile());\n          break;\n        case \"single_user\":\n          Assertions.assertEquals(\n              \"src/main/resources/auxiliary/tpcds/single_user/permutation_orders/\",\n              taskTemplate.getPermutationOrdersDirectory());\n          Assertions.assertEquals(Boolean.TRUE, taskTemplate.supportsTimeTravel());\n          break;\n        case \"init\":\n        case \"build\":\n        case \"analyze\":\n        case \"optimize_delta\":\n        case \"optimize_hudi\":\n        case \"optimize_iceberg\":\n          Assertions.assertNull(taskTemplate.getParameterValuesFile());\n          Assertions.assertNull(taskTemplate.getPermutationOrdersDirectory());\n          Assertions.assertNull(taskTemplate.supportsTimeTravel());\n          break;\n        case \"data_maintenance_delta\":\n        case \"data_maintenance_dependent\":\n        case \"data_maintenance_hudi\":\n        case \"data_maintenance_iceberg\":\n          Assertions.assertNotNull(taskTemplate.getParameterValuesFile());\n          Assertions.assertNull(taskTemplate.getPermutationOrdersDirectory());\n          Assertions.assertNull(taskTemplate.supportsTimeTravel());\n          break;\n        default:\n          Assertions.fail(\"Unexpected task template id: \" + taskTemplate.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseW0Delta() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"w0_tpcds-delta.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"w0_tpcds_delta\", workload.getId());\n    Assertions.assertEquals(9, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"setup\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasks.size());\n            Task task = tasks.get(0);\n            Assertions.assertEquals(\"setup\", task.getTemplateId());\n            Assertions.assertNull(task.isPermuteOrder());\n            Assertions.assertNull(task.getReplaceRegex());\n          }\n          break;\n        case \"throughput_1\":\n        case \"throughput_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(4, sessions.size());", "            for (Session session : sessions) {\n              Assertions.assertEquals(1, session.getTasks().size());\n              Task task = session.getTasks().get(0);\n              Assertions.assertEquals(\"single_user\", task.getTemplateId());\n              Assertions.assertEquals(Boolean.TRUE, task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n              Assertions.assertNull(task.getTimeTravelPhaseId());\n            }\n          }\n          break;\n        case \"data_maintenance_1\":\n        case \"data_maintenance_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();", "            for (Task task : tasks) {\n              Assertions.assertEquals(\"data_maintenance_delta\", task.getTemplateId());\n              Assertions.assertNull(task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n            }\n          }\n          break;\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseW0Hudi() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"w0_tpcds-hudi.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"w0_tpcds_hudi\", workload.getId());\n    Assertions.assertEquals(9, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"setup\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasks.size());\n            Task task = tasks.get(0);\n            Assertions.assertEquals(\"setup\", task.getTemplateId());\n            Assertions.assertNull(task.isPermuteOrder());\n            Assertions.assertNull(task.getReplaceRegex());\n          }\n          break;\n        case \"throughput_1\":\n        case \"throughput_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(4, sessions.size());", "            for (Session session : sessions) {\n              Assertions.assertEquals(1, session.getTasks().size());\n              Task task = session.getTasks().get(0);\n              Assertions.assertEquals(\"single_user\", task.getTemplateId());\n              Assertions.assertEquals(Boolean.TRUE, task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n              Assertions.assertNull(task.getTimeTravelPhaseId());\n            }\n          }\n          break;\n        case \"data_maintenance_1\":\n        case \"data_maintenance_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();", "            for (Task task : tasks) {\n              Assertions.assertEquals(\"data_maintenance_hudi\", task.getTemplateId());\n              Assertions.assertNull(task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n            }\n          }\n          break;\n        case \"build\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Task task = tasks.get(0);\n            Assertions.assertEquals(\"build\", task.getTemplateId());\n            Assertions.assertNull(task.isPermuteOrder());\n            Assertions.assertNotNull(task.getReplaceRegex());\n            List<Task.ReplaceRegex> replaceRegex = task.getReplaceRegex();\n            Assertions.assertEquals(1, replaceRegex.size());\n            Assertions.assertEquals(\n                \"(?i)varchar\\\\(.*\\\\)|char\\\\(.*\\\\)\", replaceRegex.get(0).getPattern());\n            Assertions.assertEquals(\"string\", replaceRegex.get(0).getReplacement());\n          }\n          break;\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"single_user\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseW0Iceberg() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"w0_tpcds-iceberg.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"w0_tpcds_iceberg\", workload.getId());\n    Assertions.assertEquals(9, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"setup\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasks.size());\n            Task task = tasks.get(0);\n            Assertions.assertEquals(\"setup\", task.getTemplateId());\n            Assertions.assertNull(task.isPermuteOrder());\n            Assertions.assertNull(task.getReplaceRegex());\n          }\n          break;\n        case \"throughput_1\":\n        case \"throughput_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(4, sessions.size());", "            for (Session session : sessions) {\n              Assertions.assertEquals(1, session.getTasks().size());\n              Task task = session.getTasks().get(0);\n              Assertions.assertEquals(\"single_user\", task.getTemplateId());\n              Assertions.assertEquals(Boolean.TRUE, task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n              Assertions.assertNull(task.getTimeTravelPhaseId());\n            }\n          }\n          break;\n        case \"data_maintenance_1\":\n        case \"data_maintenance_2\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();", "            for (Task task : tasks) {\n              Assertions.assertEquals(\"data_maintenance_iceberg\", task.getTemplateId());\n              Assertions.assertNull(task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n            }\n          }\n          break;\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseWP1Longevity() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp1_longevity.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp1_longevity\", workload.getId());\n    Assertions.assertEquals(15, workload.getPhases().size());\n  }\n\n  @Test\n  public void testParseWP2Resilience() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp2_resilience.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp2_resilience\", workload.getId());\n    Assertions.assertEquals(17, workload.getPhases().size());", "  public void testParseWP2Resilience() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp2_resilience.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp2_resilience\", workload.getId());\n    Assertions.assertEquals(17, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"setup\":\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user_1\":\n        case \"data_maintenance_1\":\n        case \"single_user_2\":\n        case \"optimize_1\":\n        case \"single_user_2o\":\n        case \"data_maintenance_2\":\n        case \"single_user_3\":\n        case \"optimize_2\":\n        case \"single_user_3o\":\n        case \"data_maintenance_3\":\n        case \"single_user_4\":\n        case \"optimize_3\":\n        case \"single_user_4o\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseWP3RWConcurrency() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp3_rw_concurrency.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp3_rw_concurrency\", workload.getId());\n    Assertions.assertEquals(10, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"single_user_1_data_maintenance_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksSU = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasksSU.size());\n            Task taskSU = tasksSU.get(0);\n            Assertions.assertEquals(\"single_user\", taskSU.getTemplateId());\n            Assertions.assertNull(taskSU.isPermuteOrder());\n            Assertions.assertNull(taskSU.getReplaceRegex());\n            Assertions.assertNull(taskSU.getTimeTravelPhaseId());\n            List<Task> tasksDM = sessions.get(1).getTasks();\n            Assertions.assertEquals(2, tasksDM.size());", "            for (Task task : tasksDM) {\n              Assertions.assertEquals(\"data_maintenance_delta\", task.getTemplateId());\n              Assertions.assertNull(task.isPermuteOrder());\n              Assertions.assertNull(task.getReplaceRegex());\n              Assertions.assertNull(task.getTimeTravelPhaseId());\n            }\n          }\n          break;\n        case \"single_user_2_optimize_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksSU = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasksSU.size());\n            Task taskSU = tasksSU.get(0);\n            Assertions.assertEquals(\"single_user\", taskSU.getTemplateId());\n            Assertions.assertNull(taskSU.isPermuteOrder());\n            Assertions.assertNull(taskSU.getReplaceRegex());\n            Assertions.assertNull(taskSU.getTimeTravelPhaseId());\n            List<Task> tasksO = sessions.get(1).getTasks();\n            Assertions.assertEquals(1, tasksO.size());\n            Task taskO = tasksO.get(0);\n            Assertions.assertEquals(\"optimize_delta\", taskO.getTemplateId());\n            Assertions.assertNull(taskO.isPermuteOrder());\n            Assertions.assertNull(taskO.getReplaceRegex());\n            Assertions.assertNull(taskO.getTimeTravelPhaseId());\n          }\n          break;\n        case \"setup\":\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user_2o_data_maintenance_2\":\n        case \"single_user_3_optimize_2\":\n        case \"single_user_3o_data_maintenance_3\":\n        case \"single_user_4_optimize_3\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseWP3RWConcurrencyMulti() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp3_rw_concurrency_multi.yaml\",\n            Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp3_rw_concurrency_multi\", workload.getId());\n    Assertions.assertEquals(10, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"single_user_1_data_maintenance_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksDM = sessions.get(1).getTasks();\n            Assertions.assertEquals(2, tasksDM.size());\n            Assertions.assertEquals(1, sessions.get(1).getTargetEndpoint());\n          }\n          break;\n        case \"single_user_2_optimize_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksO = sessions.get(1).getTasks();\n            Assertions.assertEquals(1, tasksO.size());\n            Assertions.assertEquals(1, sessions.get(1).getTargetEndpoint());\n          }\n          break;\n        case \"setup\":\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user_2o_data_maintenance_2\":\n        case \"single_user_3_optimize_2\":\n        case \"single_user_3o_data_maintenance_3\":\n        case \"single_user_4_optimize_3\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"single_user_1_data_maintenance_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksDM = sessions.get(1).getTasks();\n            Assertions.assertEquals(2, tasksDM.size());\n            Assertions.assertEquals(1, sessions.get(1).getTargetEndpoint());\n          }\n          break;\n        case \"single_user_2_optimize_1\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(2, sessions.size());\n            List<Task> tasksO = sessions.get(1).getTasks();\n            Assertions.assertEquals(1, tasksO.size());\n            Assertions.assertEquals(1, sessions.get(1).getTargetEndpoint());\n          }\n          break;\n        case \"setup\":\n        case \"setup_data_maintenance\":\n        case \"init\":\n        case \"build\":\n        case \"single_user_2o_data_maintenance_2\":\n        case \"single_user_3_optimize_2\":\n        case \"single_user_3o_data_maintenance_3\":\n        case \"single_user_4_optimize_3\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseWP4TimeTravel() throws IOException {\n    Workload workload =\n        FileParser.createObject(\n            CONFIG_PATH + \"tpcds\" + File.separator + \"wp4_time_travel.yaml\", Workload.class);\n    Assertions.assertEquals(1, workload.getVersion());\n    Assertions.assertEquals(\"wp4_time_travel\", workload.getId());\n    Assertions.assertEquals(18, workload.getPhases().size());\n    for (Phase phase : workload.getPhases()) {\n      switch (phase.getId()) {\n        case \"single_user_2_0\":\n        case \"single_user_3_0\":\n        case \"single_user_3_1\":\n        case \"single_user_4_0\":\n        case \"single_user_4_1\":\n        case \"single_user_4_2\":\n        case \"single_user_5_0\":\n        case \"single_user_5_1\":\n        case \"single_user_5_2\":\n        case \"single_user_5_3\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Assertions.assertEquals(1, tasks.size());\n            Task task = tasks.get(0);\n            Assertions.assertEquals(\"single_user\", task.getTemplateId());\n            Assertions.assertNull(task.isPermuteOrder());\n            Assertions.assertNull(task.getReplaceRegex());\n            Assertions.assertNotNull(task.getTimeTravelPhaseId());\n          }\n          break;\n        case \"setup_data_maintenance\":\n          {\n            List<Session> sessions = phase.getSessions();\n            Assertions.assertEquals(1, sessions.size());\n            List<Task> tasks = sessions.get(0).getTasks();\n            Assertions.assertEquals(8, tasks.size());\n          }\n          break;\n        case \"setup\":\n        case \"init\":\n        case \"build\":\n        case \"data_maintenance_1\":\n        case \"data_maintenance_2\":\n        case \"data_maintenance_3\":\n        case \"data_maintenance_4\":\n          // Nothing checked\n          break;\n        default:\n          Assertions.fail(\"Unexpected phase id: \" + phase.getId());\n      }\n    }\n  }\n\n  @Test", "  public void testParseTelemetryConfig() throws IOException {\n    TelemetryConfig telemetryConfig =\n        FileParser.createObject(\n            CONFIG_PATH + \"sample_telemetry_config.yaml\", TelemetryConfig.class);\n    Assertions.assertEquals(1, telemetryConfig.getVersion());\n    Assertions.assertNotNull(telemetryConfig.getConnection());\n    JDBCConnectionConfig connectionConfig = (JDBCConnectionConfig) telemetryConfig.getConnection();\n    Assertions.assertEquals(\"duckdb_0\", connectionConfig.getId());\n    Assertions.assertEquals(\"org.duckdb.DuckDBDriver\", connectionConfig.getDriver());\n    Assertions.assertEquals(\"jdbc:duckdb:./telemetry\", connectionConfig.getUrl());\n    Assertions.assertNull(connectionConfig.getUsername());\n    Assertions.assertNull(connectionConfig.getPassword());\n    Assertions.assertEquals(Boolean.TRUE, telemetryConfig.isExecuteDDL());\n    Assertions.assertEquals(\n        \"src/main/resources/scripts/logging/duckdb/ddl.sql\", telemetryConfig.getDDLFile());\n    Assertions.assertEquals(\n        \"src/main/resources/scripts/logging/duckdb/insert.sql\", telemetryConfig.getInsertFile());\n    Assertions.assertNotNull(telemetryConfig.getParameterValues());\n    Assertions.assertEquals(\"\", telemetryConfig.getParameterValues().get(\"data_path\"));\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/Driver.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench;\n\nimport com.microsoft.lst_bench.client.ConnectionManager;", "\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.common.BenchmarkConfig;\nimport com.microsoft.lst_bench.common.BenchmarkRunnable;\nimport com.microsoft.lst_bench.common.LSTBenchmarkExecutor;\nimport com.microsoft.lst_bench.input.BenchmarkObjectFactory;\nimport com.microsoft.lst_bench.input.TaskLibrary;\nimport com.microsoft.lst_bench.input.Workload;\nimport com.microsoft.lst_bench.input.config.ConnectionConfig;\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;", "import com.microsoft.lst_bench.input.config.ConnectionConfig;\nimport com.microsoft.lst_bench.input.config.ConnectionsConfig;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.TelemetryConfig;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.telemetry.TelemetryHook;\nimport com.microsoft.lst_bench.util.FileParser;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;", "import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.MissingOptionException;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;", "import org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.UnrecognizedOptionException;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** This is the main class. */\npublic class Driver {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(Driver.class);\n\n  private static final String OPT_INPUT_TASK_LIBRARY_FILE = \"task-library\";\n  private static final String OPT_INPUT_WORKLOAD_FILE = \"workload\";\n  private static final String OPT_INPUT_CONNECTION_CONFIG_FILE = \"connections-config\";\n  private static final String OPT_INPUT_EXPERIMENT_CONFIG_FILE = \"experiment-config\";\n  private static final String OPT_INPUT_TELEMETRY_CONFIG_FILE = \"input-log-config\";\n\n  /** Defeat instantiation. */\n  private Driver() {}\n\n  /** Main method. */", "public class Driver {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(Driver.class);\n\n  private static final String OPT_INPUT_TASK_LIBRARY_FILE = \"task-library\";\n  private static final String OPT_INPUT_WORKLOAD_FILE = \"workload\";\n  private static final String OPT_INPUT_CONNECTION_CONFIG_FILE = \"connections-config\";\n  private static final String OPT_INPUT_EXPERIMENT_CONFIG_FILE = \"experiment-config\";\n  private static final String OPT_INPUT_TELEMETRY_CONFIG_FILE = \"input-log-config\";\n\n  /** Defeat instantiation. */\n  private Driver() {}\n\n  /** Main method. */", "  public static void main(String[] args) throws Exception {\n    String inputTaskLibraryFile = null;\n    String inputWorkloadFile = null;\n    String inputConnectionsConfigFile = null;\n    String inputExperimentConfigFile = null;\n    String inputTelemetryConfigFile = null;\n\n    // Retrieve program input values\n    final Options options = createOptions();\n    final CommandLineParser parser = new DefaultParser();\n    try {\n      final CommandLine cmd = parser.parse(options, args);", "    try {\n      final CommandLine cmd = parser.parse(options, args);\n      if (cmd.getOptions().length == 0) {\n        usageAndHelp();\n      } else {\n        if (cmd.hasOption(OPT_INPUT_TASK_LIBRARY_FILE)) {\n          inputTaskLibraryFile = cmd.getOptionValue(OPT_INPUT_TASK_LIBRARY_FILE);\n        }\n        if (cmd.hasOption(OPT_INPUT_WORKLOAD_FILE)) {\n          inputWorkloadFile = cmd.getOptionValue(OPT_INPUT_WORKLOAD_FILE);\n        }", "        if (cmd.hasOption(OPT_INPUT_WORKLOAD_FILE)) {\n          inputWorkloadFile = cmd.getOptionValue(OPT_INPUT_WORKLOAD_FILE);\n        }\n        if (cmd.hasOption(OPT_INPUT_CONNECTION_CONFIG_FILE)) {\n          inputConnectionsConfigFile = cmd.getOptionValue(OPT_INPUT_CONNECTION_CONFIG_FILE);\n        }\n        if (cmd.hasOption(OPT_INPUT_EXPERIMENT_CONFIG_FILE)) {\n          inputExperimentConfigFile = cmd.getOptionValue(OPT_INPUT_EXPERIMENT_CONFIG_FILE);\n        }\n        if (cmd.hasOption(OPT_INPUT_TELEMETRY_CONFIG_FILE)) {\n          inputTelemetryConfigFile = cmd.getOptionValue(OPT_INPUT_TELEMETRY_CONFIG_FILE);\n        }\n      }\n    } catch (MissingOptionException | UnrecognizedOptionException e) {\n      usageAndHelp();\n      return;\n    }\n\n    // Validate input values\n    Validate.notNull(inputTaskLibraryFile, \"TaskExec library file is required.\");\n    Validate.notNull(inputWorkloadFile, \"Workload file is required.\");\n    Validate.notNull(inputConnectionsConfigFile, \"Connections config file is required.\");\n    Validate.notNull(inputExperimentConfigFile, \"Experiment config file is required.\");\n    Validate.notNull(inputTelemetryConfigFile, \"Telemetry config file is required.\");\n\n    // Create Java objects from input files\n    final TaskLibrary taskLibrary =\n        FileParser.createObject(inputTaskLibraryFile, TaskLibrary.class);\n    final Workload workload = FileParser.createObject(inputWorkloadFile, Workload.class);\n    final ConnectionsConfig connectionsConfig =\n        FileParser.createObject(inputConnectionsConfigFile, ConnectionsConfig.class);\n    final ExperimentConfig experimentConfig =\n        FileParser.createObject(inputExperimentConfigFile, ExperimentConfig.class);\n    final TelemetryConfig telemetryConfig =\n        FileParser.createObject(inputTelemetryConfigFile, TelemetryConfig.class);\n\n    run(taskLibrary, workload, connectionsConfig, experimentConfig, telemetryConfig);\n  }\n\n  /** Run benchmark. */", "        if (cmd.hasOption(OPT_INPUT_TELEMETRY_CONFIG_FILE)) {\n          inputTelemetryConfigFile = cmd.getOptionValue(OPT_INPUT_TELEMETRY_CONFIG_FILE);\n        }\n      }\n    } catch (MissingOptionException | UnrecognizedOptionException e) {\n      usageAndHelp();\n      return;\n    }\n\n    // Validate input values\n    Validate.notNull(inputTaskLibraryFile, \"TaskExec library file is required.\");\n    Validate.notNull(inputWorkloadFile, \"Workload file is required.\");\n    Validate.notNull(inputConnectionsConfigFile, \"Connections config file is required.\");\n    Validate.notNull(inputExperimentConfigFile, \"Experiment config file is required.\");\n    Validate.notNull(inputTelemetryConfigFile, \"Telemetry config file is required.\");\n\n    // Create Java objects from input files\n    final TaskLibrary taskLibrary =\n        FileParser.createObject(inputTaskLibraryFile, TaskLibrary.class);\n    final Workload workload = FileParser.createObject(inputWorkloadFile, Workload.class);\n    final ConnectionsConfig connectionsConfig =\n        FileParser.createObject(inputConnectionsConfigFile, ConnectionsConfig.class);\n    final ExperimentConfig experimentConfig =\n        FileParser.createObject(inputExperimentConfigFile, ExperimentConfig.class);\n    final TelemetryConfig telemetryConfig =\n        FileParser.createObject(inputTelemetryConfigFile, TelemetryConfig.class);\n\n    run(taskLibrary, workload, connectionsConfig, experimentConfig, telemetryConfig);\n  }\n\n  /** Run benchmark. */", "  public static void run(\n      TaskLibrary taskLibrary,\n      Workload workload,\n      ConnectionsConfig connectionsConfig,\n      ExperimentConfig experimentConfig,\n      TelemetryConfig telemetryConfig)\n      throws Exception {\n    // Create connections managers\n    Set<String> connectionManagerIds = new HashSet<>();\n    List<ConnectionManager> connectionManagers = new ArrayList<>();\n    for (ConnectionConfig connectionConfig : connectionsConfig.getConnections()) {\n      ConnectionManager connectionManager =\n          BenchmarkObjectFactory.connectionManager(connectionConfig);", "    for (ConnectionConfig connectionConfig : connectionsConfig.getConnections()) {\n      ConnectionManager connectionManager =\n          BenchmarkObjectFactory.connectionManager(connectionConfig);\n      if (!connectionManagerIds.add(connectionConfig.getId())) {\n        throw new IllegalArgumentException(\"Duplicate connection id: \" + connectionConfig.getId());\n      }\n      connectionManagers.add(connectionManager);\n    }\n\n    // Create log utility\n    final ConnectionManager telemetryConnectionManager =\n        BenchmarkObjectFactory.connectionManager(telemetryConfig.getConnection());\n    final SQLTelemetryRegistry telemetryRegistry =\n        new SQLTelemetryRegistry(\n            telemetryConnectionManager,\n            telemetryConfig.isExecuteDDL(),\n            telemetryConfig.getDDLFile(),\n            telemetryConfig.getInsertFile(),\n            telemetryConfig.getParameterValues());\n    Thread telemetryHook = new TelemetryHook(telemetryRegistry);\n    Runtime.getRuntime().addShutdownHook(telemetryHook);\n\n    // Create experiment configuration\n    final BenchmarkConfig benchmarkConfig =\n        BenchmarkObjectFactory.benchmarkConfig(experimentConfig, taskLibrary, workload);\n\n    // Run experiment\n    final BenchmarkRunnable experiment =\n        new LSTBenchmarkExecutor(connectionManagers, benchmarkConfig, telemetryRegistry);\n    experiment.execute();\n  }\n\n  private static Options createOptions() {\n    final Options options = new Options();\n\n    final Option inputTaskLibraryFile =\n        Option.builder()\n            .required()\n            .option(\"l\")\n            .longOpt(OPT_INPUT_TASK_LIBRARY_FILE)\n            .hasArg()\n            .argName(\"arg\")\n            .desc(\"Path to input file containing the library with task templates\")\n            .build();\n    options.addOption(inputTaskLibraryFile);\n\n    final Option inputWorkloadFile =\n        Option.builder()\n            .required()\n            .option(\"w\")\n            .longOpt(OPT_INPUT_WORKLOAD_FILE)\n            .hasArg()\n            .argName(\"arg\")\n            .desc(\"Path to input file containing the workload definition\")\n            .build();\n    options.addOption(inputWorkloadFile);\n\n    final Option inputConnectionConfigFile =\n        Option.builder()\n            .required()\n            .option(\"c\")\n            .longOpt(OPT_INPUT_CONNECTION_CONFIG_FILE)\n            .hasArg()\n            .argName(\"arg\")\n            .desc(\"Path to input file containing connections config details\")\n            .build();\n    options.addOption(inputConnectionConfigFile);\n\n    final Option inputExperimentConfigFile =\n        Option.builder()\n            .required()\n            .option(\"e\")\n            .longOpt(OPT_INPUT_EXPERIMENT_CONFIG_FILE)\n            .hasArg()\n            .argName(\"arg\")\n            .desc(\"Path to input file containing the experiment config details\")\n            .build();\n    options.addOption(inputExperimentConfigFile);\n\n    final Option inputTelemetryConfigFile =\n        Option.builder()\n            .required()\n            .option(\"t\")\n            .longOpt(OPT_INPUT_TELEMETRY_CONFIG_FILE)\n            .hasArg()\n            .argName(\"arg\")\n            .desc(\"Path to input file containing the telemetry gathering config details\")\n            .build();\n    options.addOption(inputTelemetryConfigFile);\n\n    return options;\n  }\n\n  private static void usageAndHelp() {\n    // Print usage and help\n    final HelpFormatter formatter = new HelpFormatter();\n    formatter.setWidth(120);\n    formatter.printHelp(\"./launcher.sh\", createOptions(), true);\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/sql/SQLParser.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.sql;\n\nimport com.microsoft.lst_bench.exec.FileExec;", "\nimport com.microsoft.lst_bench.exec.FileExec;\nimport com.microsoft.lst_bench.exec.ImmutableFileExec;\nimport com.microsoft.lst_bench.exec.ImmutableStatementExec;\nimport com.microsoft.lst_bench.exec.StatementExec;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;", "import java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** Utility class with methods to parse files with a list of SQL statements. */\npublic class SQLParser {\n\n  private SQLParser() {\n    // Defeat instantiation\n  }\n", "  public static FileExec getStatements(String filepath) {\n    return getStatements(new File(filepath));\n  }\n\n  public static FileExec getStatements(File file) {\n    final List<StatementExec> statements = new ArrayList<>();\n    try (BufferedReader br =\n        new BufferedReader(\n            new InputStreamReader(Files.newInputStream(file.toPath()), StandardCharsets.UTF_8))) {\n      int i = 0;\n      for (; ; ) {\n        String statement;", "      for (; ; ) {\n        String statement;\n        try {\n          statement = nextStatement(br);\n        } catch (IOException e) {\n          throw new RuntimeException(\"Error while reading next statement\", e);\n        }\n        if (statement == null) {\n          break;\n        }\n        statements.add(ImmutableStatementExec.of(file.getName() + \"_\" + i++, statement));\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Cannot read query in file: \" + file, e);\n    }\n    return ImmutableFileExec.of(file.getName(), statements);\n  }\n\n  private static String nextStatement(BufferedReader reader) throws IOException {\n    final StringBuilder sb = new StringBuilder();", "    for (; ; ) {\n      String line = reader.readLine();\n      if (line == null) {\n        if (sb.length() != 0) {\n          throw new RuntimeException(\"End of file reached before end of SQL statement\");\n        }\n        return null;\n      }\n      if (line.startsWith(\"#\") || line.startsWith(\"--\") || line.isEmpty()) {\n        continue;\n      }\n      boolean last = false;", "      if (line.startsWith(\"#\") || line.startsWith(\"--\") || line.isEmpty()) {\n        continue;\n      }\n      boolean last = false;\n      if (line.endsWith(\";\")) {\n        last = true;\n        line = line.substring(0, line.length() - 1);\n      }\n      sb.append(line);\n      if (last) {\n        String statement = sb.toString();\n        sb.setLength(0);\n        return statement;\n      }\n      sb.append(\"\\n\");\n    }\n  }\n}\n", "      if (last) {\n        String statement = sb.toString();\n        sb.setLength(0);\n        return statement;\n      }\n      sb.append(\"\\n\");\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/BenchmarkConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.microsoft.lst_bench.exec.WorkloadExec;", "\nimport com.microsoft.lst_bench.exec.WorkloadExec;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** A benchmark configuration. */\npublic class BenchmarkConfig {\n\n  private final String id;\n  private final int repetitions;\n  private final Map<String, String> metadata;\n  private final Map<String, Object> arguments;\n  private final WorkloadExec workload;\n\n  public BenchmarkConfig(\n      String id,\n      int repetitions,\n      Map<String, String> metadata,\n      Map<String, Object> arguments,\n      WorkloadExec workload) {\n    this.id = id;\n    this.repetitions = repetitions;\n    this.metadata = Collections.unmodifiableMap(metadata == null ? new HashMap<>() : metadata);\n    this.arguments = Collections.unmodifiableMap(arguments == null ? new HashMap<>() : arguments);\n    this.workload = workload;\n  }\n", "  public String getId() {\n    return id;\n  }\n\n  public int getRepetitions() {\n    return repetitions;\n  }\n\n  public Map<String, String> getMetadata() {\n    return metadata;\n  }\n\n  public Map<String, Object> getArguments() {\n    return arguments;\n  }\n", "  public WorkloadExec getWorkload() {\n    return workload;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/TaskExecutor.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.microsoft.lst_bench.client.ClientException;", "\nimport com.microsoft.lst_bench.client.ClientException;\nimport com.microsoft.lst_bench.client.Connection;\nimport com.microsoft.lst_bench.exec.FileExec;\nimport com.microsoft.lst_bench.exec.StatementExec;\nimport com.microsoft.lst_bench.exec.TaskExec;\nimport com.microsoft.lst_bench.telemetry.EventInfo;\nimport com.microsoft.lst_bench.telemetry.EventInfo.EventType;\nimport com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.ImmutableEventInfo;", "import com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.ImmutableEventInfo;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.util.StringUtils;\nimport java.time.Instant;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**", "\n/**\n * Default executor for tasks. Iterates over all files and all the statements contained in those\n * files and executes them sequentially.\n */\npublic class TaskExecutor {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(TaskExecutor.class);\n\n  protected final SQLTelemetryRegistry telemetryRegistry;\n  protected final String experimentStartTime;\n\n  public TaskExecutor(SQLTelemetryRegistry telemetryRegistry, String experimentStartTime) {\n    this.experimentStartTime = experimentStartTime;\n    this.telemetryRegistry = telemetryRegistry;\n  }\n", "  public void executeTask(Connection connection, TaskExec task, Map<String, Object> values)\n      throws ClientException {\n    for (FileExec file : task.getFiles()) {\n      Instant fileStartTime = Instant.now();\n      try {\n        for (StatementExec statement : file.getStatements()) {\n          Instant statementStartTime = Instant.now();\n          try {\n            connection.execute(StringUtils.replaceParameters(statement, values).getStatement());\n          } catch (Exception e) {\n            LOGGER.error(\"Exception executing statement: \" + statement.getId());\n            writeStatementEvent(\n                statementStartTime,\n                statement.getId(),\n                Status.FAILURE,\n                e.getMessage() + \"; \" + e.getStackTrace());\n            throw e;\n          }\n          writeStatementEvent(\n              statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing file: \" + file.getId());\n        writeFileEvent(fileStartTime, file.getId(), Status.FAILURE);\n        throw e;\n      }\n      writeFileEvent(fileStartTime, file.getId(), Status.SUCCESS);\n    }\n  }\n\n  protected final EventInfo writeFileEvent(Instant startTime, String id, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.of(\n            experimentStartTime, startTime, Instant.now(), id, EventType.EXEC_FILE, status);\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n\n  protected final EventInfo writeStatementEvent(\n      Instant startTime, String id, Status status, String payload) {\n    EventInfo eventInfo = null;", "    if (payload != null) {\n      eventInfo =\n          ImmutableEventInfo.of(\n                  experimentStartTime,\n                  startTime,\n                  Instant.now(),\n                  id,\n                  EventType.EXEC_STATEMENT,\n                  status)\n              .withPayload(payload);\n    } else {\n      eventInfo =\n          ImmutableEventInfo.of(\n              experimentStartTime, startTime, Instant.now(), id, EventType.EXEC_STATEMENT, status);\n    }\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/SessionExecutor.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.microsoft.lst_bench.client.ClientException;", "\nimport com.microsoft.lst_bench.client.ClientException;\nimport com.microsoft.lst_bench.client.Connection;\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.exec.SessionExec;\nimport com.microsoft.lst_bench.exec.TaskExec;\nimport com.microsoft.lst_bench.input.Task.CustomTaskExecutorArguments;\nimport com.microsoft.lst_bench.telemetry.EventInfo;\nimport com.microsoft.lst_bench.telemetry.EventInfo.EventType;\nimport com.microsoft.lst_bench.telemetry.EventInfo.Status;", "import com.microsoft.lst_bench.telemetry.EventInfo.EventType;\nimport com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.ImmutableEventInfo;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.util.DateTimeFormatter;\nimport com.microsoft.lst_bench.util.StringUtils;\nimport java.lang.reflect.Constructor;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.HashMap;", "import java.time.temporal.ChronoUnit;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Default executor for sessions. Iterates over all tasks contained in the session and executes them\n * sequentially.", " * Default executor for sessions. Iterates over all tasks contained in the session and executes them\n * sequentially.\n */\npublic class SessionExecutor implements Callable<Boolean> {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SessionExecutor.class);\n\n  private final ConnectionManager connectionManager;\n  private final SQLTelemetryRegistry telemetryRegistry;\n  private final SessionExec session;\n  private final Map<String, Object> runtimeParameterValues;\n  private final Map<String, Instant> phaseIdToEndTime;\n  private String experimentStartTime;\n\n  public SessionExecutor(\n      ConnectionManager connectionManager,\n      SQLTelemetryRegistry telemetryRegistry,\n      SessionExec session,\n      Map<String, Object> runtimeParameterValues,\n      Map<String, Instant> phaseIdToEndTime,\n      String experimentStartTime) {\n    this.connectionManager = connectionManager;\n    this.telemetryRegistry = telemetryRegistry;\n    this.session = session;\n    this.runtimeParameterValues = runtimeParameterValues;\n    this.phaseIdToEndTime = phaseIdToEndTime;\n    this.experimentStartTime = experimentStartTime;\n  }\n\n  @Override", "  public Boolean call() throws ClientException {\n    Instant sessionStartTime = Instant.now();\n    try (Connection connection = connectionManager.createConnection()) {\n      for (TaskExec task : session.getTasks()) {\n        Map<String, Object> values = updateRuntimeParameterValues(task);\n        TaskExecutor taskExecutor = getTaskExecutor(task);\n        Instant taskStartTime = Instant.now();\n        try {\n          taskExecutor.executeTask(connection, task, values);\n        } catch (Exception e) {\n          LOGGER.error(\"Exception executing task: \" + task.getId());\n          writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE);\n          throw e;\n        }\n        writeTaskEvent(taskStartTime, task.getId(), Status.SUCCESS);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"Exception executing session: \" + session.getId());\n      writeSessionEvent(sessionStartTime, session.getId(), Status.FAILURE);\n      throw e;\n    }\n    writeSessionEvent(sessionStartTime, session.getId(), Status.SUCCESS);\n    return true;\n  }\n\n  private Map<String, Object> updateRuntimeParameterValues(TaskExec task) {\n    Map<String, Object> values = new HashMap<>(this.runtimeParameterValues);", "    if (task.getTimeTravelPhaseId() != null) {\n      Instant ttPhaseEndTime = this.phaseIdToEndTime.get(task.getTimeTravelPhaseId());\n      if (ttPhaseEndTime == null) {\n        throw new RuntimeException(\n            \"Time travel phase identifier not found: \" + task.getTimeTravelPhaseId());\n      }\n      // We round to the next second to make sure we are capturing the changes in case\n      // are consecutive phases\n      String timeTravelValue =\n          DateTimeFormatter.AS_OF_FORMATTER.format(\n              ttPhaseEndTime.truncatedTo(ChronoUnit.SECONDS).plusSeconds(1));\n      values.put(\"asof\", \"TIMESTAMP AS OF \" + StringUtils.quote(timeTravelValue));\n    } else {\n      values.put(\"asof\", \"\");\n    }\n    return values;\n  }\n\n  private TaskExecutor getTaskExecutor(TaskExec task) {", "    if (task.getCustomTaskExecutor() == null) {\n      return new TaskExecutor(this.telemetryRegistry, this.experimentStartTime);\n    } else {\n      try {\n        Constructor<?> constructor =\n            Class.forName(task.getCustomTaskExecutor())\n                .getDeclaredConstructor(\n                    SQLTelemetryRegistry.class, String.class, CustomTaskExecutorArguments.class);\n        return (TaskExecutor)\n            constructor.newInstance(\n                this.telemetryRegistry,\n                this.experimentStartTime,\n                task.getCustomTaskExecutorArguments());\n      } catch (Exception e) {\n        throw new IllegalArgumentException(\n            \"Unable to load custom task class: \" + task.getCustomTaskExecutor(), e);\n      }\n    }\n  }\n\n  private EventInfo writeSessionEvent(Instant startTime, String id, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.of(\n            experimentStartTime, startTime, Instant.now(), id, EventType.EXEC_SESSION, status);\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n\n  private EventInfo writeTaskEvent(Instant startTime, String id, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.of(\n            experimentStartTime, startTime, Instant.now(), id, EventType.EXEC_TASK, status);\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/DependentTaskExecutor.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.microsoft.lst_bench.client.ClientException;", "\nimport com.microsoft.lst_bench.client.ClientException;\nimport com.microsoft.lst_bench.client.Connection;\nimport com.microsoft.lst_bench.client.QueryResult;\nimport com.microsoft.lst_bench.exec.FileExec;\nimport com.microsoft.lst_bench.exec.StatementExec;\nimport com.microsoft.lst_bench.exec.TaskExec;\nimport com.microsoft.lst_bench.input.Task.CustomTaskExecutorArguments;\nimport com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;", "import com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.util.StringUtils;\nimport java.time.Instant;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**", "\n/**\n * Custom task executor implementation that allows users to execute dependent tasks. We call a\n * dependent task a task that iteratively executes a) a statement that is expected to return a\n * result; and b) a statement repeatedly that is expected to use that result. The result of the\n * first statement is stored in an intermediate object that can be specific to the connection. The\n * expected object for a JDBC connection is of type List<Map<String, Object>>, handling of other\n * objects would need to be added to the if-clause that checks the instance of the object.\n */\npublic class DependentTaskExecutor extends TaskExecutor {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(DependentTaskExecutor.class);\n\n  private final CustomTaskExecutorArguments arguments;\n\n  private final int DEFAULT_BATCH_SIZE = 1;\n\n  public DependentTaskExecutor(\n      SQLTelemetryRegistry telemetryRegistry,\n      String experimentStartTime,\n      CustomTaskExecutorArguments arguments) {\n    super(telemetryRegistry, experimentStartTime);\n    this.arguments = arguments;\n  }\n\n  @Override", " */\npublic class DependentTaskExecutor extends TaskExecutor {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(DependentTaskExecutor.class);\n\n  private final CustomTaskExecutorArguments arguments;\n\n  private final int DEFAULT_BATCH_SIZE = 1;\n\n  public DependentTaskExecutor(\n      SQLTelemetryRegistry telemetryRegistry,\n      String experimentStartTime,\n      CustomTaskExecutorArguments arguments) {\n    super(telemetryRegistry, experimentStartTime);\n    this.arguments = arguments;\n  }\n\n  @Override", "  public void executeTask(Connection connection, TaskExec task, Map<String, Object> values)\n      throws ClientException {\n    int batch_size;\n    if (this.arguments == null || this.arguments.getDependentTaskBatchSize() == null) {\n      batch_size = DEFAULT_BATCH_SIZE;\n    } else {\n      batch_size = this.arguments.getDependentTaskBatchSize().intValue();\n    }\n\n    QueryResult queryResult = null;\n    for (FileExec file : task.getFiles()) {\n      Instant fileStartTime = Instant.now();\n", "    for (FileExec file : task.getFiles()) {\n      Instant fileStartTime = Instant.now();\n\n      if (file.getStatements().size() != 1) {\n        writeFileEvent(fileStartTime, file.getId(), Status.FAILURE);\n        throw new ClientException(\n            \"For dependent task execution, statements have to be in separate files.\");\n      }\n\n      StatementExec statement = file.getStatements().get(0);\n      try {", "      try {\n        if (queryResult == null) {\n          // Execute first query that retrieves the iterable input for the second query.\n          Instant statementStartTime = Instant.now();\n          queryResult =\n              connection.executeQuery(\n                  StringUtils.replaceParameters(statement, values).getStatement());\n          writeStatementEvent(\n              statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n          if (queryResult == null || queryResult.containsEmptyResultColumnOnly()) {\n            // Reset queryResult variable if result is (intentionally) empty.\n            queryResult = null;\n          }\n        } else {\n          // Execute second query repeatedly with the parameters extracted from the first query.\n          Integer size = queryResult.getValueListSize();", "          if (queryResult == null || queryResult.containsEmptyResultColumnOnly()) {\n            // Reset queryResult variable if result is (intentionally) empty.\n            queryResult = null;\n          }\n        } else {\n          // Execute second query repeatedly with the parameters extracted from the first query.\n          Integer size = queryResult.getValueListSize();\n          for (int j = 0; j < size; j += batch_size) {\n            int localMax = (j + batch_size) > size ? size : (j + batch_size);\n            Map<String, Object> localValues = new HashMap<>(values);\n            localValues.putAll(queryResult.getStringMappings(j, localMax));\n\n            Instant statementStartTime = Instant.now();\n            connection.execute(\n                StringUtils.replaceParameters(statement, localValues).getStatement());\n            writeStatementEvent(\n                statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n          }\n          // Reset query result.\n          queryResult = null;\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing file: \" + file.getId());\n        writeStatementEvent(\n            fileStartTime,\n            file.getId(),\n            Status.FAILURE,\n            /* payload= */ e.getMessage() + \"; \" + e.getStackTrace());\n        throw e;\n      }\n      writeFileEvent(fileStartTime, file.getId(), Status.SUCCESS);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/BenchmarkRunnable.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\n/** A benchmark runnable. */\npublic abstract class BenchmarkRunnable implements Runnable {\n\n  @Override", "\n/** A benchmark runnable. */\npublic abstract class BenchmarkRunnable implements Runnable {\n\n  @Override\n  public void run() {\n    try {\n      execute();\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Execute the benchmark. */", "  public abstract void execute() throws Exception;\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/common/LSTBenchmarkExecutor.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.common;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;", "\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.exec.PhaseExec;\nimport com.microsoft.lst_bench.exec.SessionExec;\nimport com.microsoft.lst_bench.exec.WorkloadExec;\nimport com.microsoft.lst_bench.telemetry.EventInfo;\nimport com.microsoft.lst_bench.telemetry.EventInfo.EventType;\nimport com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.ImmutableEventInfo;", "import com.microsoft.lst_bench.telemetry.EventInfo.Status;\nimport com.microsoft.lst_bench.telemetry.ImmutableEventInfo;\nimport com.microsoft.lst_bench.telemetry.SQLTelemetryRegistry;\nimport com.microsoft.lst_bench.util.DateTimeFormatter;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;", "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;", "import org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** Benchmark executor implementation. */\npublic class LSTBenchmarkExecutor extends BenchmarkRunnable {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(LSTBenchmarkExecutor.class);\n\n  private final List<ConnectionManager> connectionManagers;\n  private final BenchmarkConfig config;\n  private final SQLTelemetryRegistry telemetryRegistry;\n\n  // timestamp of the start of the first iteration of an experiment.\n  private String experimentStartTime;\n\n  public LSTBenchmarkExecutor(\n      List<ConnectionManager> connectionManagers,\n      BenchmarkConfig config,\n      SQLTelemetryRegistry telemetryRegistry) {\n    super();\n    this.connectionManagers = Collections.unmodifiableList(connectionManagers);\n    this.config = config;\n    this.telemetryRegistry = telemetryRegistry;\n  }\n\n  /** This method runs the experiment. */", "  public void execute() throws Exception {\n    this.experimentStartTime = DateTimeFormatter.U_FORMATTER.format(Instant.now());\n    LOGGER.info(\"Running experiment: {}, start-time: {}\", config.getId(), experimentStartTime);\n\n    final WorkloadExec workload = config.getWorkload();\n    // Thread pool size to max number of concurrent sessions\n    int maxConcurrentSessions = 1;\n    for (PhaseExec phase : workload.getPhases()) {\n      if (phase.getSessions().size() > maxConcurrentSessions) {\n        maxConcurrentSessions = phase.getSessions().size();\n      }\n    }\n\n    ExecutorService executor = null;", "      if (phase.getSessions().size() > maxConcurrentSessions) {\n        maxConcurrentSessions = phase.getSessions().size();\n      }\n    }\n\n    ExecutorService executor = null;\n    for (int i = 0; i < config.getRepetitions(); i++) {\n      LOGGER.info(\"Starting repetition: {}\", i);\n      final Instant repetitionStartTime = Instant.now();\n      Map<String, Object> experimentMetadata = new HashMap<>(config.getMetadata());\n      try {\n        executor = Executors.newFixedThreadPool(maxConcurrentSessions);\n\n        // Fill in specific runtime parameter values\n        Map<String, Object> runtimeParameterValues = new HashMap<>();\n        runtimeParameterValues.put(\"repetition\", i);\n        runtimeParameterValues.put(\"experiment_start_time\", experimentStartTime);\n        experimentMetadata.putAll(runtimeParameterValues);\n        // Go over phases and execute\n        Map<String, Instant> phaseIdToEndTime = new HashMap<>();", "      try {\n        executor = Executors.newFixedThreadPool(maxConcurrentSessions);\n\n        // Fill in specific runtime parameter values\n        Map<String, Object> runtimeParameterValues = new HashMap<>();\n        runtimeParameterValues.put(\"repetition\", i);\n        runtimeParameterValues.put(\"experiment_start_time\", experimentStartTime);\n        experimentMetadata.putAll(runtimeParameterValues);\n        // Go over phases and execute\n        Map<String, Instant> phaseIdToEndTime = new HashMap<>();\n        for (PhaseExec phase : workload.getPhases()) {\n          LOGGER.info(\"Running \" + phase.getId() + \" phase...\");\n          final Instant phaseStartTime = Instant.now();\n          EventInfo eventInfo;", "        for (PhaseExec phase : workload.getPhases()) {\n          LOGGER.info(\"Running \" + phase.getId() + \" phase...\");\n          final Instant phaseStartTime = Instant.now();\n          EventInfo eventInfo;\n          try {\n            final List<SessionExecutor> threads = new ArrayList<>();\n            for (SessionExec session : phase.getSessions()) {\n              threads.add(\n                  new SessionExecutor(\n                      connectionManagers.get(session.getTargetEndpoint()),\n                      this.telemetryRegistry,\n                      session,\n                      runtimeParameterValues,\n                      phaseIdToEndTime,\n                      this.experimentStartTime));\n            }\n            checkResults(executor.invokeAll(threads));\n            eventInfo = writePhaseEvent(phaseStartTime, phase.getId(), Status.SUCCESS);\n          } catch (Exception e) {\n            LOGGER.error(\"Exception executing phase: \" + phase.getId());\n            writePhaseEvent(phaseStartTime, phase.getId(), Status.FAILURE);\n            throw e;\n          } finally {\n            telemetryRegistry.flush();\n          }\n          LOGGER.info(\n              \"Phase {} finished in {} seconds.\",\n              phase.getId(),\n              ChronoUnit.SECONDS.between(phaseStartTime, eventInfo.getEndTime()));\n          phaseIdToEndTime.put(phase.getId(), eventInfo.getEndTime());\n        }\n\n        // Log end-to-end execution of experiment.\n        writeExperimentEvent(\n            repetitionStartTime,\n            config.getId(),\n            Status.SUCCESS,\n            new ObjectMapper().writeValueAsString(experimentMetadata));\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing experiment: \" + config.getId());\n        writeExperimentEvent(\n            repetitionStartTime,\n            config.getId(),\n            Status.FAILURE,\n            new ObjectMapper().writeValueAsString(experimentMetadata));\n        throw e;\n      } finally {", "        if (executor != null) {\n          executor.shutdown();\n          Validate.isTrue(executor.awaitTermination(1, TimeUnit.MINUTES));\n        }\n        telemetryRegistry.flush();\n      }\n      LOGGER.info(\"Finished repetition {}\", i);\n    }\n    LOGGER.info(\"Finished experiment: {}\", config.getId());\n  }\n\n  private void checkResults(List<Future<Boolean>> results) {", "    for (Future<Boolean> result : results) {\n      try {\n        Validate.isTrue(result.get());\n      } catch (InterruptedException | ExecutionException e) {\n        throw new RuntimeException(\"Thread did not finish correctly\", e);\n      }\n    }\n  }\n\n  private EventInfo writeExperimentEvent(\n      Instant startTime, String id, Status status, String payload) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.of(\n                experimentStartTime,\n                startTime,\n                Instant.now(),\n                id,\n                EventType.EXEC_EXPERIMENT,\n                status)\n            .withPayload(payload);\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n\n  private EventInfo writePhaseEvent(Instant startTime, String id, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.of(\n            experimentStartTime, startTime, Instant.now(), id, EventType.EXEC_PHASE, status);\n    telemetryRegistry.writeEvent(eventInfo);\n    return eventInfo;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/PhaseExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport java.util.List;", "\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** Represents a phase in a workload. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface PhaseExec {\n\n  String getId();\n\n  List<SessionExec> getSessions();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/TaskExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport com.microsoft.lst_bench.input.Task.CustomTaskExecutorArguments;", "\nimport com.microsoft.lst_bench.input.Task.CustomTaskExecutorArguments;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Represents a task in a session. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface TaskExec {\n\n  String getId();\n\n  List<FileExec> getFiles();\n\n  @Value.Parameter(false)\n  @Nullable String getTimeTravelPhaseId();\n\n  @Value.Parameter(false)\n  @Nullable String getCustomTaskExecutor();\n\n  @Value.Parameter(false)\n  @Nullable CustomTaskExecutorArguments getCustomTaskExecutorArguments();\n}\n", "@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface TaskExec {\n\n  String getId();\n\n  List<FileExec> getFiles();\n\n  @Value.Parameter(false)\n  @Nullable String getTimeTravelPhaseId();\n\n  @Value.Parameter(false)\n  @Nullable String getCustomTaskExecutor();\n\n  @Value.Parameter(false)\n  @Nullable CustomTaskExecutorArguments getCustomTaskExecutorArguments();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/FileExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport java.util.List;", "\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** Represents a file in a task. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface FileExec {\n\n  String getId();\n\n  List<StatementExec> getStatements();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/WorkloadExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport java.util.List;", "\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** Represents a workload. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface WorkloadExec {\n\n  String getId();\n\n  List<PhaseExec> getPhases();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/StatementExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport org.immutables.value.Value;", "\nimport org.immutables.value.Value;\n\n/** Represents a statement in a file. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface StatementExec {\n\n  String getId();\n\n  String getStatement();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/exec/SessionExec.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.exec;\n\nimport java.util.List;", "\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** Represents a session in a phase. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface SessionExec {\n\n  String getId();\n\n  List<TaskExec> getTasks();\n\n  /** Connection manager for this session (positional index). */\n  int getTargetEndpoint();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/Workload.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** POJO class meant to be used to deserialize an input workload. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)", "@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableWorkload.class)\n@JsonDeserialize(as = ImmutableWorkload.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface Workload {\n  int getVersion();\n\n  String getId();\n\n  List<Phase> getPhases();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/TaskTemplate.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/**", "\n/**\n * A task template is a template for a task. Importantly, it references the files that are required\n * to run the task. It also contains additional parameters that are required to instantiate the\n * task.\n */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableTaskTemplate.class)\n@JsonDeserialize(as = ImmutableTaskTemplate.class)", "@JsonSerialize(as = ImmutableTaskTemplate.class)\n@JsonDeserialize(as = ImmutableTaskTemplate.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface TaskTemplate {\n  String getId();\n\n  List<String> getFiles();\n\n  @JsonProperty(\"parameter_values_file\")\n  @Nullable String getParameterValuesFile();\n\n  @JsonProperty(\"permutation_orders_path\")\n  @Nullable String getPermutationOrdersDirectory();\n\n  @JsonProperty(\"supports_time_travel\")\n  @Nullable Boolean supportsTimeTravel();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/Phase.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** POJO class meant to be used to deserialize an input phase. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)", "@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutablePhase.class)\n@JsonDeserialize(as = ImmutablePhase.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface Phase {\n  String getId();\n\n  List<Session> getSessions();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/BenchmarkObjectFactory.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.microsoft.lst_bench.client.ConnectionManager;", "\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.client.JDBCConnectionManager;\nimport com.microsoft.lst_bench.client.SparkConnectionManager;\nimport com.microsoft.lst_bench.common.BenchmarkConfig;\nimport com.microsoft.lst_bench.exec.FileExec;\nimport com.microsoft.lst_bench.exec.ImmutablePhaseExec;\nimport com.microsoft.lst_bench.exec.ImmutableSessionExec;\nimport com.microsoft.lst_bench.exec.ImmutableTaskExec;\nimport com.microsoft.lst_bench.exec.ImmutableWorkloadExec;", "import com.microsoft.lst_bench.exec.ImmutableTaskExec;\nimport com.microsoft.lst_bench.exec.ImmutableWorkloadExec;\nimport com.microsoft.lst_bench.exec.PhaseExec;\nimport com.microsoft.lst_bench.exec.SessionExec;\nimport com.microsoft.lst_bench.exec.TaskExec;\nimport com.microsoft.lst_bench.input.config.ConnectionConfig;\nimport com.microsoft.lst_bench.input.config.ExperimentConfig;\nimport com.microsoft.lst_bench.input.config.JDBCConnectionConfig;\nimport com.microsoft.lst_bench.input.config.SparkConnectionConfig;\nimport com.microsoft.lst_bench.sql.SQLParser;", "import com.microsoft.lst_bench.input.config.SparkConnectionConfig;\nimport com.microsoft.lst_bench.sql.SQLParser;\nimport com.microsoft.lst_bench.util.FileParser;\nimport com.microsoft.lst_bench.util.StringUtils;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport org.apache.commons.lang3.ObjectUtils;", "import java.util.stream.Collectors;\nimport org.apache.commons.lang3.ObjectUtils;\n\n/** Factory class for creating benchmark objects from the input configuration. */\npublic class BenchmarkObjectFactory {\n\n  private BenchmarkObjectFactory() {\n    // Defeat instantiation\n  }\n\n  /**\n   * Creates a connection manager from the connection configuration.\n   *\n   * @param connectionConfig the connection configuration\n   */", "  public static ConnectionManager connectionManager(ConnectionConfig connectionConfig) {\n    if (connectionConfig instanceof JDBCConnectionConfig) {\n      return jdbcConnectionManager((JDBCConnectionConfig) connectionConfig);\n    } else if (connectionConfig instanceof SparkConnectionConfig) {\n      return sparkConnectionManager((SparkConnectionConfig) connectionConfig);\n    } else {\n      throw new IllegalArgumentException(\n          \"Unsupported connection config type: \" + connectionConfig.getClass().getName());\n    }\n  }\n\n  private static JDBCConnectionManager jdbcConnectionManager(\n      JDBCConnectionConfig connectionConfig) {", "    try {\n      Class.forName(connectionConfig.getDriver());\n    } catch (ClassNotFoundException e) {\n      throw new IllegalArgumentException(\n          \"Unable to load driver class: \" + connectionConfig.getDriver(), e);\n    }\n    return new JDBCConnectionManager(\n        connectionConfig.getUrl(),\n        connectionConfig.getMaxNumRetries(),\n        connectionConfig.getUsername(),\n        connectionConfig.getPassword());\n  }\n\n  private static SparkConnectionManager sparkConnectionManager(\n      SparkConnectionConfig connectionConfig) {\n    return new SparkConnectionManager(connectionConfig.getUrl(), connectionConfig.getConfig());\n  }\n\n  /**\n   * Creates a benchmark configuration from the experiment configuration, task library, and\n   * workload.\n   *\n   * @param experimentConfig the experiment configuration\n   * @param taskLibrary the task library\n   * @param workload the workload\n   * @return a benchmark configuration\n   */", "  public static BenchmarkConfig benchmarkConfig(\n      ExperimentConfig experimentConfig, TaskLibrary taskLibrary, Workload workload) {\n    Map<String, TaskTemplate> idToTaskTemplate = parseTaskLibrary(taskLibrary);\n    ImmutableWorkloadExec workloadExec =\n        createWorkloadExec(workload, idToTaskTemplate, experimentConfig);\n    return new BenchmarkConfig(\n        experimentConfig.getId(),\n        experimentConfig.getRepetitions(),\n        experimentConfig.getMetadata(),\n        experimentConfig.getArguments(),\n        workloadExec);\n  }\n\n  /**\n   * Parses the task library to create a map of task templates with unique IDs.\n   *\n   * @param taskLibrary the task library to parse\n   * @return a map of task templates with unique IDs\n   * @throws IllegalArgumentException if there are duplicate task template IDs\n   */\n  private static Map<String, TaskTemplate> parseTaskLibrary(TaskLibrary taskLibrary) {\n    Map<String, TaskTemplate> idToTaskTemplate = new HashMap<>();", "    for (TaskTemplate taskTemplate : taskLibrary.getTaskTemplates()) {\n      if (idToTaskTemplate.containsKey(taskTemplate.getId())) {\n        throw new IllegalArgumentException(\"Duplicate task template id: \" + taskTemplate.getId());\n      }\n      idToTaskTemplate.put(taskTemplate.getId(), taskTemplate);\n    }\n    return idToTaskTemplate;\n  }\n\n  /**\n   * Creates a workload execution from the workload and task library.\n   *\n   * @param workload the workload to execute\n   * @param idToTaskTemplate a map of task templates with unique IDs\n   * @param experimentConfig the experiment configuration\n   * @return a workload execution\n   * @throws IllegalArgumentException if the workload contains an invalid task template ID\n   */\n  private static ImmutableWorkloadExec createWorkloadExec(\n      Workload workload,\n      Map<String, TaskTemplate> idToTaskTemplate,\n      ExperimentConfig experimentConfig) {\n    Map<String, Integer> taskTemplateIdToPermuteOrderCounter = new HashMap<>();\n    Map<String, Integer> taskTemplateIdToParameterValuesCounter = new HashMap<>();\n    List<PhaseExec> phases = new ArrayList<>();", "    for (Phase phase : workload.getPhases()) {\n      PhaseExec phaseExec =\n          createPhaseExec(\n              phase,\n              idToTaskTemplate,\n              experimentConfig,\n              taskTemplateIdToPermuteOrderCounter,\n              taskTemplateIdToParameterValuesCounter);\n      phases.add(phaseExec);\n    }\n    return ImmutableWorkloadExec.of(workload.getId(), phases);\n  }\n\n  private static PhaseExec createPhaseExec(\n      Phase phase,\n      Map<String, TaskTemplate> idToTaskTemplate,\n      ExperimentConfig experimentConfig,\n      Map<String, Integer> taskTemplateIdToPermuteOrderCounter,\n      Map<String, Integer> taskTemplateIdToParameterValuesCounter) {\n    List<SessionExec> sessions = new ArrayList<>();", "    for (int i = 0; i < phase.getSessions().size(); i++) {\n      Session session = phase.getSessions().get(i);\n      String sessionId = String.valueOf(i);\n      SessionExec sessionExec =\n          createSessionExec(\n              sessionId,\n              session,\n              idToTaskTemplate,\n              experimentConfig,\n              taskTemplateIdToPermuteOrderCounter,\n              taskTemplateIdToParameterValuesCounter);\n      sessions.add(sessionExec);\n    }\n    return ImmutablePhaseExec.of(phase.getId(), sessions);\n  }\n\n  private static SessionExec createSessionExec(\n      String sessionId,\n      Session session,\n      Map<String, TaskTemplate> idToTaskTemplate,\n      ExperimentConfig experimentConfig,\n      Map<String, Integer> taskTemplateIdToPermuteOrderCounter,\n      Map<String, Integer> taskTemplateIdToParameterValuesCounter) {\n    List<TaskExec> tasks = new ArrayList<>();", "    for (int j = 0; j < session.getTasks().size(); j++) {\n      Task task = session.getTasks().get(j);\n      String taskId = task.getTemplateId() + \"_\" + j;\n      TaskExec taskExec =\n          createTaskExec(\n              taskId,\n              task,\n              idToTaskTemplate,\n              experimentConfig,\n              taskTemplateIdToPermuteOrderCounter,\n              taskTemplateIdToParameterValuesCounter);\n      tasks.add(taskExec);\n    }\n    return ImmutableSessionExec.of(\n        sessionId, tasks, ObjectUtils.defaultIfNull(session.getTargetEndpoint(), 0));\n  }\n\n  private static TaskExec createTaskExec(\n      String taskId,\n      Task task,\n      Map<String, TaskTemplate> idToTaskTemplate,\n      ExperimentConfig experimentConfig,\n      Map<String, Integer> taskTemplateIdToPermuteOrderCounter,\n      Map<String, Integer> taskTemplateIdToParameterValuesCounter) {\n    TaskTemplate taskTemplate = idToTaskTemplate.get(task.getTemplateId());", "    if (taskTemplate == null) {\n      throw new IllegalArgumentException(\"Unknown task template id: \" + task.getTemplateId());\n    }\n    List<FileExec> files =\n        createFileExecList(\n            taskTemplate,\n            task,\n            experimentConfig,\n            taskTemplateIdToPermuteOrderCounter,\n            taskTemplateIdToParameterValuesCounter);\n    return ImmutableTaskExec.of(taskId, files)\n        .withTimeTravelPhaseId(task.getTimeTravelPhaseId())\n        .withCustomTaskExecutor(task.getCustomTaskExecutor())\n        .withCustomTaskExecutorArguments(task.getCustomTaskExecutorArguments());\n  }\n\n  private static List<FileExec> createFileExecList(\n      TaskTemplate taskTemplate,\n      Task task,\n      ExperimentConfig experimentConfig,\n      Map<String, Integer> taskTemplateIdToPermuteOrderCounter,\n      Map<String, Integer> taskTemplateIdToParameterValuesCounter) {\n    List<FileExec> files = new ArrayList<>();", "    for (String file : taskTemplate.getFiles()) {\n      files.add(SQLParser.getStatements(file));\n    }\n    files = applyPermutationOrder(taskTemplate, task, taskTemplateIdToPermuteOrderCounter, files);\n    files = applyReplaceRegex(task, files);\n    files =\n        applyParameterValues(\n            taskTemplate, experimentConfig, taskTemplateIdToParameterValuesCounter, files);\n    return files;\n  }\n\n  private static List<FileExec> applyPermutationOrder(\n      TaskTemplate taskTemplate,\n      Task task,\n      Map<String, Integer> taskTemplateIdToPermuteOrderCounter,\n      List<FileExec> files) {", "    if (taskTemplate.getPermutationOrdersDirectory() == null) {\n      // Create statements with certain order\n      return files;\n    }\n    Map<String, FileExec> idToFile = new HashMap<>();\n    for (FileExec file : files) {\n      idToFile.put(file.getId(), file);\n    }\n    int counter;\n    if (Boolean.TRUE.equals(task.isPermuteOrder())) {\n      counter =\n          taskTemplateIdToPermuteOrderCounter.compute(\n              taskTemplate.getId(), (k, v) -> v == null ? 1 : v + 1);\n    } else {\n      counter = 0;\n    }\n    List<String> permutationOrder =\n        FileParser.getPermutationOrder(taskTemplate.getPermutationOrdersDirectory(), counter);\n    List<FileExec> sortedFiles = new ArrayList<>();", "    if (Boolean.TRUE.equals(task.isPermuteOrder())) {\n      counter =\n          taskTemplateIdToPermuteOrderCounter.compute(\n              taskTemplate.getId(), (k, v) -> v == null ? 1 : v + 1);\n    } else {\n      counter = 0;\n    }\n    List<String> permutationOrder =\n        FileParser.getPermutationOrder(taskTemplate.getPermutationOrdersDirectory(), counter);\n    List<FileExec> sortedFiles = new ArrayList<>();\n    for (String fileId : permutationOrder) {\n      sortedFiles.add(idToFile.get(fileId));\n    }\n    return sortedFiles;\n  }\n\n  private static List<FileExec> applyReplaceRegex(Task task, List<FileExec> files) {", "    for (String fileId : permutationOrder) {\n      sortedFiles.add(idToFile.get(fileId));\n    }\n    return sortedFiles;\n  }\n\n  private static List<FileExec> applyReplaceRegex(Task task, List<FileExec> files) {\n    if (task.getReplaceRegex() == null) {\n      return files;\n    }\n    return files.stream()\n        .map(\n            file -> {", "              for (Task.ReplaceRegex regex : task.getReplaceRegex()) {\n                file = StringUtils.replaceRegex(file, regex.getPattern(), regex.getReplacement());\n              }\n              return file;\n            })\n        .collect(Collectors.toList());\n  }\n\n  private static List<FileExec> applyParameterValues(\n      TaskTemplate taskTemplate,\n      ExperimentConfig experimentConfig,\n      Map<String, Integer> taskTemplateIdToParameterValuesCounter,\n      List<FileExec> files) {\n    Map<String, Object> parameterValues = new HashMap<>();", "    if (taskTemplate.getParameterValuesFile() != null) {\n      // Include parameter values defined in the task template\n      parameterValues.putAll(\n          FileParser.getParameterValues(\n              taskTemplate.getParameterValuesFile(),\n              taskTemplateIdToParameterValuesCounter.compute(\n                  taskTemplate.getId(), (k, v) -> v == null ? 1 : v + 1)));\n    }\n    if (experimentConfig.getParameterValues() != null) {\n      // Include experiment-specific parameter values (they can override the ones defined in\n      // the task template)\n      parameterValues.putAll(experimentConfig.getParameterValues());\n    }\n    return files.stream()\n        .map(f -> StringUtils.replaceParameters(f, parameterValues))\n        .collect(Collectors.toList());\n  }\n}\n", "    if (experimentConfig.getParameterValues() != null) {\n      // Include experiment-specific parameter values (they can override the ones defined in\n      // the task template)\n      parameterValues.putAll(experimentConfig.getParameterValues());\n    }\n    return files.stream()\n        .map(f -> StringUtils.replaceParameters(f, parameterValues))\n        .collect(Collectors.toList());\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/Task.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** POJO class meant to be used to deserialize an input task. */", "\n/** POJO class meant to be used to deserialize an input task. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableTask.class)\n@JsonDeserialize(as = ImmutableTask.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface Task {\n  @JsonProperty(\"template_id\")\n  String getTemplateId();\n\n  @JsonProperty(\"permute_order\")\n  @Nullable Boolean isPermuteOrder();\n\n  @JsonProperty(\"time_travel_phase_id\")\n  @Nullable String getTimeTravelPhaseId();\n\n  @JsonProperty(\"custom_task_executor\")\n  @Nullable String getCustomTaskExecutor();\n\n  @JsonProperty(\"custom_task_executor_arguments\")\n  @Nullable CustomTaskExecutorArguments getCustomTaskExecutorArguments();\n\n  @Value.Immutable\n  @JsonSerialize(as = ImmutableCustomTaskExecutorArguments.class)\n  @JsonDeserialize(as = ImmutableCustomTaskExecutorArguments.class)\n  interface CustomTaskExecutorArguments {\n    @JsonProperty(\"dependent_task_batch_size\")\n    @Nullable Integer getDependentTaskBatchSize();\n  }\n\n  @JsonProperty(\"replace_regex\")\n  @Nullable List<ReplaceRegex> getReplaceRegex();\n\n  @Value.Immutable\n  @JsonSerialize(as = ImmutableReplaceRegex.class)\n  @JsonDeserialize(as = ImmutableReplaceRegex.class)\n  interface ReplaceRegex {\n    String getPattern();\n\n    String getReplacement();\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/TaskLibrary.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/**\n * Represents an input task library containing task templates that can be instantiated to create", "/**\n * Represents an input task library containing task templates that can be instantiated to create\n * tasks.\n */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableTaskLibrary.class)\n@JsonDeserialize(as = ImmutableTaskLibrary.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface TaskLibrary {\n  int getVersion();\n\n  @JsonProperty(\"task_templates\")\n  List<TaskTemplate> getTaskTemplates();\n}\n", "@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface TaskLibrary {\n  int getVersion();\n\n  @JsonProperty(\"task_templates\")\n  List<TaskTemplate> getTaskTemplates();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/Session.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** POJO class meant to be used to deserialize an input session. */", "\n/** POJO class meant to be used to deserialize an input session. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableSession.class)\n@JsonDeserialize(as = ImmutableSession.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface Session {\n  List<Task> getTasks();\n\n  @JsonProperty(\"target_endpoint\")\n  @Nullable Integer getTargetEndpoint();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/TelemetryConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Represents an input experiment configuration. */", "\n/** Represents an input experiment configuration. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableTelemetryConfig.class)\n@JsonDeserialize(as = ImmutableTelemetryConfig.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface TelemetryConfig {\n  int getVersion();\n\n  ConnectionConfig getConnection();\n\n  @JsonProperty(\"execute_ddl\")\n  Boolean isExecuteDDL();\n\n  @JsonProperty(\"ddl_file\")\n  String getDDLFile();\n\n  @JsonProperty(\"insert_file\")\n  String getInsertFile();\n\n  @JsonProperty(\"parameter_values\")\n  @Nullable Map<String, Object> getParameterValues();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/ExperimentConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Represents an input experiment configuration. */", "\n/** Represents an input experiment configuration. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableExperimentConfig.class)\n@JsonDeserialize(as = ImmutableExperimentConfig.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface ExperimentConfig {\n  int getVersion();\n\n  String getId();\n\n  int getRepetitions();\n\n  @Nullable Map<String, String> getMetadata();\n\n  @JsonProperty(\"parameter_values\")\n  @Nullable Map<String, Object> getParameterValues();\n\n  @JsonProperty(\"arguments\")\n  @Nullable Map<String, Object> getArguments();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/ConnectionConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonSubTypes;", "\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\n/** Represents a single input connection configuration. */\n@JsonTypeInfo(\n    use = JsonTypeInfo.Id.NAME,\n    property = \"type\",\n    defaultImpl = JDBCConnectionConfig.class)\n@JsonSubTypes({", "    defaultImpl = JDBCConnectionConfig.class)\n@JsonSubTypes({\n  @JsonSubTypes.Type(value = JDBCConnectionConfig.class, name = \"jdbc\"),\n  @JsonSubTypes.Type(value = SparkConnectionConfig.class, name = \"spark\")\n})\npublic interface ConnectionConfig {\n  String getId();\n\n  String getUrl();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/JDBCConnectionConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Represents a single input connection configuration. */\n@Value.Immutable", "/** Represents a single input connection configuration. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableJDBCConnectionConfig.class)\n@JsonDeserialize(as = ImmutableJDBCConnectionConfig.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface JDBCConnectionConfig extends ConnectionConfig {\n  String getDriver();\n\n  @JsonProperty(\"max_num_retries\")\n  @Value.Default\n  default int getMaxNumRetries() {\n    return 1;\n  }\n\n  @Nullable String getUsername();\n\n  @Nullable String getPassword();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/ConnectionsConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.List;\nimport org.immutables.value.Value;\n\n/** Represents multiple input connection configurations. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)", "@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableConnectionsConfig.class)\n@JsonDeserialize(as = ImmutableConnectionsConfig.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface ConnectionsConfig {\n  int getVersion();\n\n  List<ConnectionConfig> getConnections();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/input/config/SparkConnectionConfig.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.input.config;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;", "\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Represents a single input connection configuration. */\n@Value.Immutable", "/** Represents a single input connection configuration. */\n@Value.Immutable\n@Value.Style(jdkOnly = true)\n@JsonSerialize(as = ImmutableSparkConnectionConfig.class)\n@JsonDeserialize(as = ImmutableSparkConnectionConfig.class)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic interface SparkConnectionConfig extends ConnectionConfig {\n  @Nullable Map<String, String> getConfig();\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/util/StringUtils.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.util;\n\nimport com.microsoft.lst_bench.exec.FileExec;", "\nimport com.microsoft.lst_bench.exec.FileExec;\nimport com.microsoft.lst_bench.exec.ImmutableFileExec;\nimport com.microsoft.lst_bench.exec.ImmutableStatementExec;\nimport com.microsoft.lst_bench.exec.StatementExec;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.regex.Pattern;", "import java.util.Map;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.text.StringSubstitutor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** Utility class for string operations. */\npublic class StringUtils {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(StringUtils.class);\n\n  private StringUtils() {\n    // Defeat instantiation\n  }\n", "/** Utility class for string operations. */\npublic class StringUtils {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(StringUtils.class);\n\n  private StringUtils() {\n    // Defeat instantiation\n  }\n\n  public static String format(String format, Map<String, Object> values) {\n    return StringSubstitutor.replace(format, values);\n  }\n", "  public static String format(String format, Map<String, Object> values) {\n    return StringSubstitutor.replace(format, values);\n  }\n\n  public static String quote(String str) {\n    if (str == null) {\n      return null;\n    }\n    return \"'\" + str + \"'\";\n  }\n", "  public static StatementExec replaceParameters(\n      StatementExec statement, Map<String, Object> parameterValues) {\n    if (parameterValues == null || parameterValues.isEmpty()) {\n      // Nothing to do\n      return statement;\n    }\n    return ImmutableStatementExec.of(\n        statement.getId(), StringUtils.format(statement.getStatement(), parameterValues));\n  }\n\n  public static FileExec replaceParameters(FileExec file, Map<String, Object> parameterValues) {", "  public static FileExec replaceParameters(FileExec file, Map<String, Object> parameterValues) {\n    if (parameterValues == null || parameterValues.isEmpty()) {\n      // Nothing to do\n      return file;\n    }\n    return ImmutableFileExec.of(\n        file.getId(),\n        file.getStatements().stream()\n            .map(s -> replaceParameters(s, parameterValues))\n            .collect(Collectors.toList()));\n  }\n", "  public static FileExec replaceRegex(FileExec f, String regex, String replacement) {\n    Pattern pattern = Pattern.compile(regex);\n    return ImmutableFileExec.of(\n        f.getId(),\n        f.getStatements().stream()\n            .map(\n                s ->\n                    ImmutableStatementExec.of(\n                        s.getId(), pattern.matcher(s.getStatement()).replaceAll(replacement)))\n            .collect(Collectors.toList()));\n  }\n\n  /**\n   * Reads the contents of the `sourceFile` and replaces any environment variables if present. If\n   * the environment variable is not set, the default value is used if specified. All other\n   * parameters are ignored.\n   */", "  public static String replaceEnvVars(File sourceFile) throws IOException {\n    if (sourceFile == null || !sourceFile.isFile()) {\n      // Nothing to do.\n      LOGGER.debug(\"replaceEnvVars received a null or missing file.\");\n      return null;\n    }\n    StringSubstitutor envSub = new StringSubstitutor(System.getenv());\n    return envSub.replace(FileUtils.readFileToString(sourceFile, StandardCharsets.UTF_8));\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/util/DateTimeFormatter.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.util;\n\nimport java.time.ZoneOffset;", "\nimport java.time.ZoneOffset;\n\n/** Date time formatter. */\npublic class DateTimeFormatter {\n\n  /** Formatter for experiment identifier based on its start time. */\n  public static final java.time.format.DateTimeFormatter U_FORMATTER =\n      java.time.format.DateTimeFormatter.ofPattern(\"yyyy_MM_dd_HH_mm_ss_SSS\")\n          .withZone(ZoneOffset.UTC);\n\n  /** Formatter for AS OF clause in SQL queries. */", "  public static final java.time.format.DateTimeFormatter AS_OF_FORMATTER =\n      java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.000\")\n          .withZone(ZoneOffset.UTC);\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/util/FileParser.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.util;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;", "\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.ArrayList;", "import java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\n/** Utility class with methods to parse auxiliary files for the benchmark. */\npublic class FileParser {\n\n  private static final ObjectMapper yamlMapper = new YAMLMapper();\n\n  private FileParser() {\n    // Defeat instantiation\n  }\n", "public class FileParser {\n\n  private static final ObjectMapper yamlMapper = new YAMLMapper();\n\n  private FileParser() {\n    // Defeat instantiation\n  }\n\n  public static List<String> getPermutationOrder(String permutationOrdersDirectory, int counter) {\n    File directory = new File(permutationOrdersDirectory);\n    File[] files = directory.listFiles();", "  public static List<String> getPermutationOrder(String permutationOrdersDirectory, int counter) {\n    File directory = new File(permutationOrdersDirectory);\n    File[] files = directory.listFiles();\n    if (files == null) {\n      throw new IllegalArgumentException(\n          \"Cannot find permutation order files in directory: \" + permutationOrdersDirectory);\n    }\n    if (counter >= files.length) {\n      throw new IllegalArgumentException(\n          \"Cannot find permutation order file with index: \" + counter);\n    }\n    File file = files[counter];\n    List<String> permutationOrder = new ArrayList<>();\n    try (BufferedReader br =\n        new BufferedReader(\n            new InputStreamReader(Files.newInputStream(file.toPath()), StandardCharsets.UTF_8))) {\n      String filename;", "      while ((filename = br.readLine()) != null) {\n        if (filename.startsWith(\"#\") || filename.startsWith(\"--\") || filename.isEmpty()) {\n          continue;\n        }\n        permutationOrder.add(filename);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\n          \"Cannot read permutation order file: \" + file.getAbsolutePath(), e);\n    }\n    return permutationOrder;\n  }\n", "  public static Map<String, Object> getParameterValues(String parameterValuesFile, int counter) {\n    Map<String, Object> values = new HashMap<>();\n    File file = new File(parameterValuesFile);\n    if (!file.exists()) {\n      throw new IllegalArgumentException(\n          \"Cannot find parameter values file: \" + parameterValuesFile);\n    }\n    try (BufferedReader br =\n        new BufferedReader(\n            new InputStreamReader(Files.newInputStream(file.toPath()), StandardCharsets.UTF_8))) {\n      String header = br.readLine();\n      String line = null;", "      for (int j = 1; j <= counter; j++) {\n        line = br.readLine();\n      }\n      if (line == null) {\n        throw new IllegalArgumentException(\"Cannot find parameter values with index: \" + counter);\n      }\n      StringTokenizer stHeader = new StringTokenizer(header, \"|\");\n      StringTokenizer stLine = new StringTokenizer(line, \"|\");\n      while (stHeader.hasMoreTokens()) {\n        String headerToken = stHeader.nextToken();\n        String lineToken = stLine.nextToken();\n        values.put(headerToken, lineToken);\n      }", "      while (stHeader.hasMoreTokens()) {\n        String headerToken = stHeader.nextToken();\n        String lineToken = stLine.nextToken();\n        values.put(headerToken, lineToken);\n      }\n      if (stLine.hasMoreTokens()) {\n        throw new IllegalArgumentException(\n            \"Parameter values line \" + counter + \" has more values than header\");\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Cannot read parameter values file: \" + file.getAbsolutePath(), e);\n    }\n    return values;\n  }\n\n  /**\n   * Reads the YAML file and replaces all environment variables (if present). Creates and returns an\n   * object of `objectType` class.\n   */\n  public static <T> T createObject(String filePath, Class<T> objectType) throws IOException {\n    return yamlMapper.readValue(StringUtils.replaceEnvVars(new File(filePath)), objectType);\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/SparkConnection.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\nimport java.util.List;", "\nimport java.util.List;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\n\n/** A Spark connection. */\npublic class SparkConnection implements Connection {\n\n  private final SparkSession session;\n\n  public SparkConnection(SparkSession session) {\n    this.session = session;\n  }\n\n  @Override", "  public void execute(String sqlText) {\n    List<Row> results = session.sql(sqlText).collectAsList();\n    for (Row row : results) {\n      // do nothing\n    }\n  }\n\n  @Override\n  public QueryResult executeQuery(String sqlText) throws ClientException {\n    throw new UnsupportedOperationException(\"This function has not been implemented yet.\");\n  }\n\n  @Override", "  public QueryResult executeQuery(String sqlText) throws ClientException {\n    throw new UnsupportedOperationException(\"This function has not been implemented yet.\");\n  }\n\n  @Override\n  public void close() {\n    session.close();\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/ConnectionManager.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\n/** A connection manager. */\npublic interface ConnectionManager {\n\n  Connection createConnection() throws ClientException;\n}\n", "\n/** A connection manager. */\npublic interface ConnectionManager {\n\n  Connection createConnection() throws ClientException;\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/SparkConnectionManager.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\nimport java.util.Collections;", "\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.spark.sql.SparkSession;\n\n/** Simple Spark session connection manager. */\npublic class SparkConnectionManager implements ConnectionManager {\n\n  private final String url;\n\n  private final Map<String, String> config;\n\n  public SparkConnectionManager(String url, Map<String, String> config) {\n    this.url = url;\n    this.config = Collections.unmodifiableMap(config == null ? new HashMap<>() : config);\n  }\n", "  public Connection createConnection() {\n    SparkSession.Builder builder = SparkSession.builder().master(url);\n    this.config.forEach(builder::config);\n    return new SparkConnection(builder.getOrCreate());\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/Connection.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\n/** A connection. */\npublic interface Connection extends AutoCloseable {\n\n  void execute(String sqlText) throws ClientException;\n\n  QueryResult executeQuery(String sqlText) throws ClientException;\n\n  void close() throws ClientException;\n}\n", "\n/** A connection. */\npublic interface Connection extends AutoCloseable {\n\n  void execute(String sqlText) throws ClientException;\n\n  QueryResult executeQuery(String sqlText) throws ClientException;\n\n  void close() throws ClientException;\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/ClientException.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\n/** A client exception. */\npublic class ClientException extends Exception {\n\n  public ClientException(Exception cause) {\n    super(cause);\n  }\n\n  public ClientException(String message) {\n    super(message);\n  }\n}\n", "\n/** A client exception. */\npublic class ClientException extends Exception {\n\n  public ClientException(Exception cause) {\n    super(cause);\n  }\n\n  public ClientException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/JDBCConnection.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\nimport java.sql.ResultSet;", "\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** A JDBC connection. */\npublic class JDBCConnection implements Connection {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(JDBCConnection.class);\n\n  private final java.sql.Connection connection;\n  private final int max_num_retries;\n\n  public JDBCConnection(java.sql.Connection connection, int max_num_retries) {\n    this.connection = connection;\n    this.max_num_retries = max_num_retries;\n  }\n\n  @Override", "/** A JDBC connection. */\npublic class JDBCConnection implements Connection {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(JDBCConnection.class);\n\n  private final java.sql.Connection connection;\n  private final int max_num_retries;\n\n  public JDBCConnection(java.sql.Connection connection, int max_num_retries) {\n    this.connection = connection;\n    this.max_num_retries = max_num_retries;\n  }\n\n  @Override", "  public void execute(String sqlText) throws ClientException {\n    Exception last_error = null;\n    int error_count = 0;\n\n    while (error_count < this.max_num_retries) {\n      try (Statement s = connection.createStatement()) {\n        boolean hasResults = s.execute(sqlText);\n        if (hasResults) {\n          ResultSet rs = s.getResultSet();\n          while (rs.next()) {\n            // do nothing\n          }\n        }\n        return;\n\n      } catch (Exception e) {\n        last_error = e;\n        error_count++;\n      }\n    }\n", "          while (rs.next()) {\n            // do nothing\n          }\n        }\n        return;\n\n      } catch (Exception e) {\n        last_error = e;\n        error_count++;\n      }\n    }\n", "    if (last_error != null) {\n      String last_error_msg =\n          \"Query retries (\"\n              + this.max_num_retries\n              + \") unsuccessful. Error occurred while executing the following query: \"\n              + sqlText\n              + \"; stack trace: \"\n              + ExceptionUtils.getStackTrace(last_error);\n      LOGGER.warn(last_error_msg);\n      throw new ClientException(last_error_msg);\n    }\n  }\n\n  @Override", "  public QueryResult executeQuery(String sqlText) throws ClientException {\n    QueryResult qr = new QueryResult();\n    Exception last_error = null;\n    int error_count = 0;\n\n    while (error_count < this.max_num_retries) {\n      try (Statement s = connection.createStatement()) {\n        ResultSet rs = s.executeQuery(sqlText);\n        qr.populate(rs);\n\n        return qr;\n      } catch (Exception e) {\n        last_error = e;\n        error_count++;\n      }\n    }\n", "    if (last_error != null) {\n      String last_error_msg =\n          \"Query retries (\"\n              + this.max_num_retries\n              + \") unsuccessful. Error occurred while executing the following query: \"\n              + sqlText\n              + \"; stack trace: \"\n              + ExceptionUtils.getStackTrace(last_error);\n      LOGGER.warn(last_error_msg);\n      throw new ClientException(last_error_msg);\n    }\n\n    // This should never be reached because either the QueryResult is returned or an error is\n    // thrown.\n    return null;\n  }\n\n  @Override", "  public void close() throws ClientException {\n    try {\n      connection.close();\n    } catch (SQLException e) {\n      throw new ClientException(e);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/JDBCConnectionManager.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\nimport java.sql.DriverManager;", "\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport javax.annotation.Nullable;\nimport org.apache.commons.lang3.StringUtils;\n\n/** Simple JDBC connection manager. */\npublic class JDBCConnectionManager implements ConnectionManager {\n\n  private final String url;\n  private final int max_num_retries;\n\n  @Nullable private final String username;\n\n  @Nullable private final String password;\n\n  public JDBCConnectionManager(String url, int max_num_retries, String username, String password) {\n    this.url = url;\n    this.max_num_retries = max_num_retries;\n    this.username = username;\n    this.password = password;\n  }\n\n  @Override", "  public Connection createConnection() throws ClientException {\n    try {\n      if (StringUtils.isEmpty(username)) {\n        return new JDBCConnection(DriverManager.getConnection(url), this.max_num_retries);\n      } else {\n        return new JDBCConnection(\n            DriverManager.getConnection(url, username, password), this.max_num_retries);\n      }\n    } catch (SQLException e) {\n      throw new ClientException(e);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/client/QueryResult.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.client;\n\nimport java.sql.ResultSet;", "\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;", "import java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n/**\n * Represents the query result of a query issued against a source. Query result entries should be\n * mapped to column name -> list of column values.\n */\npublic class QueryResult {\n\n  private final Map<String, List<Object>> valueList;\n\n  private static final String RESULT = \"Result\";\n\n  public QueryResult() {\n    this.valueList = new HashMap<>();\n  }\n\n  // TODO: Determine whether this can be done lazily i.e., after the statement has finished\n  // executing and the query is not timed anymore.", "  public void populate(ResultSet rs) throws SQLException {\n    ResultSetMetaData rsmd = rs.getMetaData();\n\n    for (int j = 1; j <= rsmd.getColumnCount(); j++) {\n      valueList.put(rsmd.getColumnName(j), new ArrayList<>());\n    }\n\n    while (rs.next()) {\n      for (int j = 1; j <= rsmd.getColumnCount(); j++) {\n        valueList.get(rsmd.getColumnName(j)).add(rs.getObject(j));\n      }\n    }\n  }\n", "      for (int j = 1; j <= rsmd.getColumnCount(); j++) {\n        valueList.get(rsmd.getColumnName(j)).add(rs.getObject(j));\n      }\n    }\n  }\n\n  public Integer getValueListSize() {\n    Integer size = null;\n    for (Entry<String, List<Object>> pair : valueList.entrySet()) {\n      size = pair.getValue().size();\n      break;\n    }\n    return size;\n  }\n", "    for (Entry<String, List<Object>> pair : valueList.entrySet()) {\n      size = pair.getValue().size();\n      break;\n    }\n    return size;\n  }\n\n  public boolean containsEmptyResultColumnOnly() {\n    if (valueList.keySet().size() == 1\n        && valueList.containsKey(RESULT)\n        && valueList.get(RESULT).size() == 0) {\n      return true;\n    }\n    return false;\n  }\n\n  public Map<String, Object> getStringMappings(int listMin, int listMax) {\n    Map<String, Object> result = new HashMap<>();", "    if (valueList.keySet().size() == 1\n        && valueList.containsKey(RESULT)\n        && valueList.get(RESULT).size() == 0) {\n      return true;\n    }\n    return false;\n  }\n\n  public Map<String, Object> getStringMappings(int listMin, int listMax) {\n    Map<String, Object> result = new HashMap<>();\n    for (String key : this.valueList.keySet()) {\n      List<String> localList =\n          this.valueList.get(key).subList(listMin, listMax).stream()\n              .map(s -> s.toString())\n              .collect(Collectors.toUnmodifiableList());\n      result.put(key, \"'\" + String.join(\"','\", localList) + \"'\");\n    }\n    return result;\n  }\n}\n", "    for (String key : this.valueList.keySet()) {\n      List<String> localList =\n          this.valueList.get(key).subList(listMin, listMax).stream()\n              .map(s -> s.toString())\n              .collect(Collectors.toUnmodifiableList());\n      result.put(key, \"'\" + String.join(\"','\", localList) + \"'\");\n    }\n    return result;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/telemetry/EventInfo.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.telemetry;\n\nimport java.time.Instant;", "\nimport java.time.Instant;\nimport javax.annotation.Nullable;\nimport org.immutables.value.Value;\n\n/** Captures information about an event. */\n@Value.Immutable\n@Value.Style(jdkOnly = true, allParameters = true, defaults = @Value.Immutable(builder = false))\npublic interface EventInfo {\n  /**\n   * Returns the unique identifier for the experiment run. This identifier helps in distinguishing\n   * events of one experiment run from another. Currently, the experiment run start timestamp is\n   * used as the unique identifier.\n   */\n  String getExperimentId();\n\n  Instant getStartTime();\n\n  Instant getEndTime();\n\n  String getEventId();\n\n  EventType getEventType();\n\n  Status getStatus();\n\n  @Value.Parameter(false)\n  @Nullable String getPayload();\n\n  /** Enumerates the different types of events that can be captured. */\n  enum EventType {\n    EXEC_EXPERIMENT,\n    EXEC_PHASE,\n    EXEC_SESSION,\n    EXEC_TASK,\n    EXEC_FILE,\n    EXEC_STATEMENT;\n  }\n\n  /** Enumerates the different types of status that can be captured. */\n  enum Status {\n    SUCCESS,\n    FAILURE,\n    UNKNOWN;\n  }\n}\n", "public interface EventInfo {\n  /**\n   * Returns the unique identifier for the experiment run. This identifier helps in distinguishing\n   * events of one experiment run from another. Currently, the experiment run start timestamp is\n   * used as the unique identifier.\n   */\n  String getExperimentId();\n\n  Instant getStartTime();\n\n  Instant getEndTime();\n\n  String getEventId();\n\n  EventType getEventType();\n\n  Status getStatus();\n\n  @Value.Parameter(false)\n  @Nullable String getPayload();\n\n  /** Enumerates the different types of events that can be captured. */\n  enum EventType {\n    EXEC_EXPERIMENT,\n    EXEC_PHASE,\n    EXEC_SESSION,\n    EXEC_TASK,\n    EXEC_FILE,\n    EXEC_STATEMENT;\n  }\n\n  /** Enumerates the different types of status that can be captured. */\n  enum Status {\n    SUCCESS,\n    FAILURE,\n    UNKNOWN;\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/telemetry/EventException.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.telemetry;\n\n/** An exception related to management of {@link EventInfo}. */\npublic class EventException extends Exception {\n\n  public EventException(Exception cause) {\n    super(cause);\n  }\n\n  public EventException(String message) {\n    super(message);\n  }\n}\n", "\n/** An exception related to management of {@link EventInfo}. */\npublic class EventException extends Exception {\n\n  public EventException(Exception cause) {\n    super(cause);\n  }\n\n  public EventException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/telemetry/SQLTelemetryRegistry.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.telemetry;\n\nimport com.microsoft.lst_bench.client.ClientException;", "\nimport com.microsoft.lst_bench.client.ClientException;\nimport com.microsoft.lst_bench.client.Connection;\nimport com.microsoft.lst_bench.client.ConnectionManager;\nimport com.microsoft.lst_bench.exec.StatementExec;\nimport com.microsoft.lst_bench.sql.SQLParser;\nimport com.microsoft.lst_bench.util.StringUtils;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;", "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** A telemetry registry that writes events to a SQL-compatible database. */\npublic class SQLTelemetryRegistry {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SQLTelemetryRegistry.class);\n\n  private final ConnectionManager connectionManager;\n\n  private final List<StatementExec> insertFileStatements;\n\n  // TODO: Make writing events thread-safe.\n  private List<EventInfo> eventsStream;\n\n  public SQLTelemetryRegistry(\n      ConnectionManager connectionManager,\n      boolean executeDdl,\n      String ddlFile,\n      String insertFile,\n      Map<String, Object> parameterValues)\n      throws ClientException {\n    this.connectionManager = connectionManager;\n    this.eventsStream = Collections.synchronizedList(new ArrayList<>());\n    this.insertFileStatements =\n        SQLParser.getStatements(insertFile).getStatements().stream()\n            .map(s -> StringUtils.replaceParameters(s, parameterValues))\n            .collect(Collectors.toUnmodifiableList());\n    // Create the tables if they don't exist.", "/** A telemetry registry that writes events to a SQL-compatible database. */\npublic class SQLTelemetryRegistry {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SQLTelemetryRegistry.class);\n\n  private final ConnectionManager connectionManager;\n\n  private final List<StatementExec> insertFileStatements;\n\n  // TODO: Make writing events thread-safe.\n  private List<EventInfo> eventsStream;\n\n  public SQLTelemetryRegistry(\n      ConnectionManager connectionManager,\n      boolean executeDdl,\n      String ddlFile,\n      String insertFile,\n      Map<String, Object> parameterValues)\n      throws ClientException {\n    this.connectionManager = connectionManager;\n    this.eventsStream = Collections.synchronizedList(new ArrayList<>());\n    this.insertFileStatements =\n        SQLParser.getStatements(insertFile).getStatements().stream()\n            .map(s -> StringUtils.replaceParameters(s, parameterValues))\n            .collect(Collectors.toUnmodifiableList());\n    // Create the tables if they don't exist.", "    if (executeDdl) {\n      executeDdl(ddlFile, parameterValues);\n    }\n  }\n\n  private void executeDdl(String ddlFile, Map<String, Object> parameterValues)\n      throws ClientException {\n    LOGGER.info(\"Creating new logging tables...\");\n    try (Connection connection = connectionManager.createConnection()) {\n      List<StatementExec> ddlFileStatements = SQLParser.getStatements(ddlFile).getStatements();\n      for (StatementExec query : ddlFileStatements) {\n        String currentQuery = StringUtils.replaceParameters(query, parameterValues).getStatement();\n        connection.execute(currentQuery);\n      }\n    }\n    LOGGER.info(\"Logging tables created.\");\n  }\n\n  /** Inserts an event into the stream. */", "      for (StatementExec query : ddlFileStatements) {\n        String currentQuery = StringUtils.replaceParameters(query, parameterValues).getStatement();\n        connection.execute(currentQuery);\n      }\n    }\n    LOGGER.info(\"Logging tables created.\");\n  }\n\n  /** Inserts an event into the stream. */\n  public void writeEvent(EventInfo eventInfo) {\n    eventsStream.add(eventInfo);\n  }\n\n  /** Flushes the events to the database. */", "  public void writeEvent(EventInfo eventInfo) {\n    eventsStream.add(eventInfo);\n  }\n\n  /** Flushes the events to the database. */\n  public void flush() throws EventException {\n    if (eventsStream.isEmpty()) return;\n\n    LOGGER.info(\"Flushing events to database...\");\n    try (Connection connection = connectionManager.createConnection()) {\n      Map<String, Object> values = new HashMap<>();\n      values.put(\n          \"tuples\",\n          eventsStream.stream()\n              .map(\n                  o ->\n                      String.join(\n                          \",\",\n                          StringUtils.quote(o.getExperimentId()),\n                          StringUtils.quote(o.getStartTime().toString()),\n                          StringUtils.quote(o.getEndTime().toString()),\n                          StringUtils.quote(o.getEventId()),\n                          StringUtils.quote(o.getEventType().toString()),\n                          StringUtils.quote(o.getStatus().toString()),\n                          StringUtils.quote(o.getPayload())))\n              .collect(Collectors.joining(\"),(\", \"(\", \")\")));", "      for (StatementExec query : insertFileStatements) {\n        String currentQuery = StringUtils.replaceParameters(query, values).getStatement();\n        connection.execute(currentQuery);\n      }\n\n      eventsStream = Collections.synchronizedList(new ArrayList<>());\n      LOGGER.info(\"Events flushed to database.\");\n    } catch (ClientException e) {\n      throw new EventException(e);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/microsoft/lst_bench/telemetry/TelemetryHook.java", "chunked_list": ["/*\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.microsoft.lst_bench.telemetry;\n\npublic class TelemetryHook extends Thread {\n\n  private final SQLTelemetryRegistry telemetryRegistry;\n\n  public TelemetryHook(SQLTelemetryRegistry telemetryRegistry) {\n    this.telemetryRegistry = telemetryRegistry;\n  }\n\n  @Override", "\npublic class TelemetryHook extends Thread {\n\n  private final SQLTelemetryRegistry telemetryRegistry;\n\n  public TelemetryHook(SQLTelemetryRegistry telemetryRegistry) {\n    this.telemetryRegistry = telemetryRegistry;\n  }\n\n  @Override\n  public void run() {", "  public void run() {\n    try {\n      telemetryRegistry.flush();\n    } catch (EventException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n"]}
