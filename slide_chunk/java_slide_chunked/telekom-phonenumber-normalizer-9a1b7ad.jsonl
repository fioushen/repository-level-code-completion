{"filename": "src/main/java/de/telekom/phonenumbernormalizer/PhoneNumberAreaLabelImpl.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer;\n\n", "\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.i18n.phonenumbers.NumberParseException;\nimport com.google.i18n.phonenumbers.PhoneNumberUtil;\nimport com.google.i18n.phonenumbers.Phonenumber;\n\nimport lombok.RequiredArgsConstructor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.io.Resource;\nimport org.springframework.stereotype.Component;\n\n\nimport javax.annotation.PostConstruct;\nimport java.io.IOException;\nimport java.util.*;", "import java.io.IOException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n * Concrete implementation of {@link PhoneNumberAreaLabel}, which is using per default provided label configuration from resources folder:\n * <ul>\n *     <li>Country Calling Code to German Country Names</li>\n *     <li>AU-NDC: \"Weihnachtsinsel\" &amp; \"Kokosinseln\"</li>\n *     <li>DE-NDC: German City-Names replacing formal abbreviation with long name</li>", " *     <li>AU-NDC: \"Weihnachtsinsel\" &amp; \"Kokosinseln\"</li>\n *     <li>DE-NDC: German City-Names replacing formal abbreviation with long name</li>\n *     <li>RU-NDC: Country seperation \"Russland\" &amp; \"Kasachstan\"</li>\n *     <li>US-NDC: For US and CA just the state names</li>\n * </ul>\n */\n@RequiredArgsConstructor\n@Component\npublic class PhoneNumberAreaLabelImpl implements PhoneNumberAreaLabel {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PhoneNumberAreaLabelImpl.class);\n\n    /**\n     * Array of full (path + filename + extension) files, where:<br/>\n     * filename: matches ISO2 country code of country\n     * content: JSON array with one object. Each key is a phone number prefix (similar to NDC, but without NAC) and the value its corresponding label. If keys have overlapping, the one with the longest key will be used.\n     */\n    @Value(\"classpath:${service.areaLabel.nationalLabels}\")\n    Resource[] numberPlanResources;\n\n    /**\n     * full (path + filename + extension) file, where:<br/>\n     * content: JSON array with one object. Each key is the Country Calling Code (without \"+\" or IDP) and the value its corresponding label.\n     */\n    @Value(\"classpath:${service.areaLabel.countryLabels}\")\n    Resource countryCodeResource;\n\n\n    /**\n     * First key is the region code represented by an ISO2 country code of (the main) country.<br/>\n     * Second key (key of the inner HashMap) is the phone number prefix (similar to NDC, but without NAC).<br/>\n     * Value of the inner HashMap is corresponding label.\n     *\n     * @see PhoneNumberAreaLabelImpl#numberPlanResources\n     *\n     */\n    private HashMap<String, HashMap<?, ?>> areaCodes;\n\n\n    /**\n     * Each key is the Country Calling Code (without \"+\" or IDP) and the value its corresponding label.\n     *\n     * @see PhoneNumberAreaLabelImpl#countryCodeResource\n     */\n    private HashMap<?, ?> internationalCountryCodes;\n\n    /**\n     * <ul>\n     * <li>Loading {@link PhoneNumberAreaLabelImpl#internationalCountryCodes} from {@link PhoneNumberAreaLabelImpl#countryCodeResource}</li>\n     * <li>Loading {@link PhoneNumberAreaLabelImpl#areaCodes} from {@link PhoneNumberAreaLabelImpl#numberPlanResources}</li>\n     * </ul>\n     */\n    @PostConstruct", "public class PhoneNumberAreaLabelImpl implements PhoneNumberAreaLabel {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PhoneNumberAreaLabelImpl.class);\n\n    /**\n     * Array of full (path + filename + extension) files, where:<br/>\n     * filename: matches ISO2 country code of country\n     * content: JSON array with one object. Each key is a phone number prefix (similar to NDC, but without NAC) and the value its corresponding label. If keys have overlapping, the one with the longest key will be used.\n     */\n    @Value(\"classpath:${service.areaLabel.nationalLabels}\")\n    Resource[] numberPlanResources;\n\n    /**\n     * full (path + filename + extension) file, where:<br/>\n     * content: JSON array with one object. Each key is the Country Calling Code (without \"+\" or IDP) and the value its corresponding label.\n     */\n    @Value(\"classpath:${service.areaLabel.countryLabels}\")\n    Resource countryCodeResource;\n\n\n    /**\n     * First key is the region code represented by an ISO2 country code of (the main) country.<br/>\n     * Second key (key of the inner HashMap) is the phone number prefix (similar to NDC, but without NAC).<br/>\n     * Value of the inner HashMap is corresponding label.\n     *\n     * @see PhoneNumberAreaLabelImpl#numberPlanResources\n     *\n     */\n    private HashMap<String, HashMap<?, ?>> areaCodes;\n\n\n    /**\n     * Each key is the Country Calling Code (without \"+\" or IDP) and the value its corresponding label.\n     *\n     * @see PhoneNumberAreaLabelImpl#countryCodeResource\n     */\n    private HashMap<?, ?> internationalCountryCodes;\n\n    /**\n     * <ul>\n     * <li>Loading {@link PhoneNumberAreaLabelImpl#internationalCountryCodes} from {@link PhoneNumberAreaLabelImpl#countryCodeResource}</li>\n     * <li>Loading {@link PhoneNumberAreaLabelImpl#areaCodes} from {@link PhoneNumberAreaLabelImpl#numberPlanResources}</li>\n     * </ul>\n     */\n    @PostConstruct", "    public void initFile() {\n        try {\n            LOGGER.debug(\"init code files\");\n            LOGGER.debug(\"read international country codes\");\n            this.internationalCountryCodes = this.initResource(countryCodeResource);\n            LOGGER.debug(\"read number plans folder\");\n            this.areaCodes = new HashMap<>();\n            for (Resource res : numberPlanResources) {\n                String filename = res.getFilename();\n                if (filename!=null) {\n                    LOGGER.debug(\"read number plan file: {}\", filename);\n                    String prefix = this.getFilePrefix(filename).toUpperCase(Locale.ROOT);\n                    LOGGER.debug(\"add prefix: {}\", prefix);\n                    this.areaCodes.put(prefix, this.initResource(res));\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"init file failed\");\n            LOGGER.error(\"{}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public Optional<String> getLocationByNationalNumberAndRegionCode(String nationalNumber, String regionCode) {\n        regionCode = regionCode.toUpperCase(Locale.ROOT);", "                if (filename!=null) {\n                    LOGGER.debug(\"read number plan file: {}\", filename);\n                    String prefix = this.getFilePrefix(filename).toUpperCase(Locale.ROOT);\n                    LOGGER.debug(\"add prefix: {}\", prefix);\n                    this.areaCodes.put(prefix, this.initResource(res));\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"init file failed\");\n            LOGGER.error(\"{}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public Optional<String> getLocationByNationalNumberAndRegionCode(String nationalNumber, String regionCode) {\n        regionCode = regionCode.toUpperCase(Locale.ROOT);", "        if (!this.areaCodes.containsKey(regionCode)) {\n            LOGGER.debug(\"no number plan for regioncode: {} available\", regionCode);\n            return Optional.empty();\n        }\n        String locationName = this.getLabelForNDCasNumberPrefixinPlan(nationalNumber, this.areaCodes.get(regionCode));\n\n        return Optional.ofNullable(locationName);\n    }\n\n    @Override\n    public Optional<String> getCountryNameByCountryCode(String countryCode) {\n        return Optional.ofNullable((String) this.internationalCountryCodes.get(countryCode));\n    }\n\n    @Override\n    public Optional<String> getLocationByE164Number(String e164number) {\n        // be sure number is E164 normalized (leading +) ... and not fallback to dialable, where area information might be missing\n        String resultLabel = null;", "        if ((e164number.length()>0) && (e164number.charAt(0) == '+')) {\n            PhoneNumberUtil phoneUtil = PhoneNumberUtil.getInstance();\n            try {\n                Phonenumber.PhoneNumber pn = phoneUtil.parse(e164number, \"\");\n\n                Optional<String> locationName = Optional.empty();\n\n                if (pn!=null) {\n                    String regionCode=phoneUtil.getRegionCodeForCountryCode(pn.getCountryCode());\n                    locationName = this.getLocationByNationalNumberAndRegionCode(String.valueOf(pn.getNationalNumber()), regionCode);\n                    if (locationName.isEmpty()) {\n                        return this.getCountryNameByCountryCode(String.valueOf(pn.getCountryCode()));\n                    }\n                }\n\n                return locationName;\n            } catch (NumberParseException e) {\n                LOGGER.warn(\"could not parse normalize number: {}\", e164number);\n                LOGGER.warn(e.getMessage(), e);\n                // removing leading \"+\"\n                String tooShortNumber = e164number.substring(1);", "                    if (locationName.isEmpty()) {\n                        return this.getCountryNameByCountryCode(String.valueOf(pn.getCountryCode()));\n                    }\n                }\n\n                return locationName;\n            } catch (NumberParseException e) {\n                LOGGER.warn(\"could not parse normalize number: {}\", e164number);\n                LOGGER.warn(e.getMessage(), e);\n                // removing leading \"+\"\n                String tooShortNumber = e164number.substring(1);", "                for (int i=tooShortNumber.length();i>0;i--)\n                {\n                    Optional<String> tempResult = this.getCountryNameByCountryCode(tooShortNumber.substring(0,i));\n                    if (tempResult.isPresent()) {\n                        resultLabel = tempResult.get();\n                    }\n                }\n            }\n        }\n        return Optional.ofNullable(resultLabel);\n    }\n\n    /**\n     * Returns the \"main\" file name - before the first \".\", to exclude the extension.\n     * @param filename where the extension should be removed\n     * @return part before the first \".\"\n     */\n    private String getFilePrefix(String filename) {\n        return filename.split(Pattern.quote(\".\"))[0];\n    }\n\n    /**\n     * Reads a resource (JSON Array of one Object into a HashMap of that object attributes).\n     * @param res JSON to be loaded\n     * @return Number prefix mapped to label\n     * @throws IOException if there is a problem with the given resource\n     */\n    private HashMap<?, ?> initResource(Resource res) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return (HashMap<?, ?>) mapper.readValue(res.getInputStream(), List.class).get(0);\n    }\n\n    /**\n     * Returns the label (value) for a NDC, if the number in national format starts with it.<br/>\n     * If multiple NAC matches as number prefix, the longest one will be taken.\n     * @param nationalNumber without NAC\n     * @param plan maps NDC to Label\n     * @return a label specifying the NDC location / area (might be city, state or country)\n     */\n    private String getLabelForNDCasNumberPrefixinPlan(String nationalNumber, Map<?, ?> plan) {", "        for (int i = nationalNumber.length(); i > 0; i--) {\n            String key = nationalNumber.substring(0, i);\n            if (plan.containsKey(key)) {\n                return plan.get(key).toString();\n            }\n        }\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/PhoneNumberNormalizerImpl.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer;\n\nimport de.telekom.phonenumbernormalizer.dto.DeviceContext;", "\nimport de.telekom.phonenumbernormalizer.dto.DeviceContext;\nimport de.telekom.phonenumbernormalizer.dto.DeviceContextMapper;\nimport de.telekom.phonenumbernormalizer.numberplans.PhoneLibWrapper;\nimport de.telekom.phonenumbernormalizer.numberplans.NumberPlan;\nimport de.telekom.phonenumbernormalizer.numberplans.NumberPlanFactory;\nimport lombok.RequiredArgsConstructor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;", "import org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n\n/**\n *  Concrete implementation of {@link PhoneNumberNormalizer} using {@link PhoneLibWrapper} to normalize a number by mitigating some inaccuracies when it comes to number plans of optional NDC and NAC as zero.\n *  <p>\n *  Also supports {@link DeviceContext} to enrich a phone number during normalization if the optional NDC is missing.\n *  </p>\n */", " *  </p>\n */\n@RequiredArgsConstructor\n@Component\npublic class PhoneNumberNormalizerImpl implements PhoneNumberNormalizer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PhoneNumberNormalizerImpl.class);\n\n    /**\n     * Storage for {@link PhoneNumberNormalizer#setFallbackRegionCode(String)}\n     */\n    private String fallbackRegionCode = null;\n\n    @Override", "    public void setFallbackRegionCode(String fallBackRegionCode) {\n        if (PhoneLibWrapper.getCountryCodeForRegion(fallBackRegionCode) > 0) {\n            this.fallbackRegionCode = fallBackRegionCode;\n        } else {\n            this.fallbackRegionCode = null; //invalid region code!\n        }\n    }\n\n    /**\n     * Fallback normalization within the number-plan of the fallback region.\n     * @param number the original number to be normalized\n     * @param dialableNumber the original number reduced to dialable digits\n     * @return E164 formatted phone number or at least a dialable version of the number\n     *\n     * @see PhoneNumberNormalizer#setFallbackRegionCode(String)\n     * @see PhoneNumberNormalizer#normalizePhoneNumber(String, String)\n     */\n    private String fallbackNormalizationFromDeviceContextToDefaultRegionCode(String number, String dialableNumber) {", "        if (this.fallbackRegionCode == null) {\n            LOGGER.debug(\"Fallback Region was set!\");\n            return dialableNumber;\n        } else {\n            return this.normalizePhoneNumber(number, this.fallbackRegionCode);\n        }\n    }\n\n    /**\n     * Uses wrapper of PhoneLib to identify if special rules apply for normalization.<br/>\n     * Using device context for enriching the number make it normalizable to E164 format if NDC is optional in the used number plan, but not used in the phone number to be normalized.\n     * @param wrapper instanced wrapper of PhoneLib\n     * @param deviceContext information like CC, NDC and {@link de.telekom.phonenumbernormalizer.dto.DeviceContextLineType} from which the number is dialled\n     * @return E164 formatted phone number or dialable version of it or null\n     */\n    private String normalize(PhoneLibWrapper wrapper, DeviceContext deviceContext) {\n        // international prefix has been added by PhoneLib even if it's not valid in the number plan.", "        if (wrapper == null) {\n            LOGGER.debug(\"PhoneLipWrapper was not initialized\");\n            return null;\n        }\n\n        if (wrapper.getSemiNormalizedNumber() == null) {\n            return wrapper.getDialableNumber();\n        }\n\n        NumberPlan numberplan = null;\n        if (deviceContext != null) {\n            numberplan = NumberPlanFactory.INSTANCE.getNumberPlan(deviceContext.getLineType(), deviceContext.getCountryCode());\n        }\n", "        if (deviceContext != null) {\n            numberplan = NumberPlanFactory.INSTANCE.getNumberPlan(deviceContext.getLineType(), deviceContext.getCountryCode());\n        }\n\n        if (wrapper.isShortNumber(numberplan)) {\n            //if it is a short number, we can't add area code nor country code, so returning the dialable.\n            return wrapper.getDialableNumber();\n        }\n\n        if (wrapper.hasRegionNationalAccessCode() && deviceContext != null) {\n            //Number plan is using a NationalPrefix aka Trunc Code ... so we could add Area Code if not included in the number.\n            return wrapper.extendNumberByDefaultAreaCodeAndCountryCode(wrapper.getNationalAccessCode(), deviceContext.getNationalDestinationCode());\n        }\n        // Number plan is not using NationalPrefix aka Trunc Code ... its also not a short number, so country code can be added:\n        return wrapper.getE164Formatted();\n    }\n\n    @Override", "        if (wrapper.hasRegionNationalAccessCode() && deviceContext != null) {\n            //Number plan is using a NationalPrefix aka Trunc Code ... so we could add Area Code if not included in the number.\n            return wrapper.extendNumberByDefaultAreaCodeAndCountryCode(wrapper.getNationalAccessCode(), deviceContext.getNationalDestinationCode());\n        }\n        // Number plan is not using NationalPrefix aka Trunc Code ... its also not a short number, so country code can be added:\n        return wrapper.getE164Formatted();\n    }\n\n    @Override\n    public String normalizePhoneNumber(String number, String regionCode) {\n\n        PhoneLibWrapper wrapper = new PhoneLibWrapper(number, regionCode);\n", "    public String normalizePhoneNumber(String number, String regionCode) {\n\n        PhoneLibWrapper wrapper = new PhoneLibWrapper(number, regionCode);\n\n        if (wrapper.getSemiNormalizedNumber() == null) {\n            return wrapper.getDialableNumber();\n        }\n        if (wrapper.isShortNumber()) {\n            //if it is a short number, we can't add area code nor country code, so returning the dialable.\n            return wrapper.getDialableNumber();\n        }\n\n        // international prefix is added by the lib even if it's not valid in the number plan.\n        //checking if the input number is equal to the nationalNumber based on number plan and trunc code logic.\n        boolean hasNoCCAndNoNAC = wrapper.hasNoCountryCodeNorNationalAccessCode();\n\n        LOGGER.debug(\"Number has no CC and no NAC: {}.\", hasNoCCAndNoNAC);\n\n        //if the number is definitely a short number or needs an area code but does not have it, we do not add the country code.\n        return (hasNoCCAndNoNAC) ?\n                wrapper.getDialableNumber() : wrapper.getE164Formatted();\n\n    }\n\n    @Override", "    public String normalizePhoneNumber(String number, DeviceContext deviceContext) {\n\n        // checking if the number has a special format or is not valid at all.\n        PhoneLibWrapper normalizerPhoneNumber = new PhoneLibWrapper(number, null);\n        if (! normalizerPhoneNumber.isNormalizingTried()) {\n            return normalizerPhoneNumber.getDialableNumber();\n        }\n\n        DeviceContext normalizedDeviceContext = DeviceContextMapper.normalized(deviceContext);\n\n        if (!normalizedDeviceContext.getCountryCode().equals(DeviceContext.UNKNOWN_VALUE)) {\n            String regionCode = PhoneLibWrapper.getRegionCodeForCountryCode(normalizedDeviceContext.getCountryCode());\n            // now working again with the region code\n            normalizerPhoneNumber = new PhoneLibWrapper(number, regionCode);", "        if (!normalizedDeviceContext.getCountryCode().equals(DeviceContext.UNKNOWN_VALUE)) {\n            String regionCode = PhoneLibWrapper.getRegionCodeForCountryCode(normalizedDeviceContext.getCountryCode());\n            // now working again with the region code\n            normalizerPhoneNumber = new PhoneLibWrapper(number, regionCode);\n            if (!normalizedDeviceContext.getNationalDestinationCode().equals(DeviceContext.UNKNOWN_VALUE)) {\n                // Number needs normalization:\n                return normalize(normalizerPhoneNumber, deviceContext);\n            }\n            // Device Context with CountryCode but without AreaCode ...\n            if (!(PhoneLibWrapper.UNKNOWN_REGIONCODE.equals(regionCode))) {\n                return this.normalizePhoneNumber(number, regionCode);\n            }\n        }\n        LOGGER.debug(\"Normalization based on DeviceContext did not work - falling back to normalization with fallback region.\");\n        return this.fallbackNormalizationFromDeviceContextToDefaultRegionCode(number, normalizerPhoneNumber.getDialableNumber());\n    }\n\n}\n", "            if (!(PhoneLibWrapper.UNKNOWN_REGIONCODE.equals(regionCode))) {\n                return this.normalizePhoneNumber(number, regionCode);\n            }\n        }\n        LOGGER.debug(\"Normalization based on DeviceContext did not work - falling back to normalization with fallback region.\");\n        return this.fallbackNormalizationFromDeviceContextToDefaultRegionCode(number, normalizerPhoneNumber.getDialableNumber());\n    }\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/PhoneNumberNormalizer.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer;\n\n", "\n\nimport de.telekom.phonenumbernormalizer.dto.DeviceContext;\n\n/**\n * An interface for dependency injection - for direct use within your code just use {@link PhoneNumberNormalizerImpl}.\n */\npublic interface PhoneNumberNormalizer {\n\n    /**\n     * Sets the ISO2 country code, which is used if the {@link DeviceContext} does not indicate one.\n     * The country might represent a region, like \"US\" for North America.\n     *\n     * @param fallBackRegionCode ISO2 code of the country\n     *\n     * @see PhoneNumberNormalizer#normalizePhoneNumber(String, DeviceContext)\n     */\n    void setFallbackRegionCode(String fallBackRegionCode);\n\n    /**\n     * Normalizes the number using PhoneLib with some additions to compensate.\n     * <p>\n     * Preferable to {@link PhoneNumberNormalizer#normalizePhoneNumber(String, String)}, because default NDC can be provided, so that more compensation for generating a valid E164 can be done.\n     * </p>\n     * @param number plain number to normalize\n     * @param deviceContext  information like CC, NDC and {@link de.telekom.phonenumbernormalizer.dto.DeviceContextLineType} from which the number is dialled\n     * @return E164 formatted phone number or at least a dialable version of the number\n     *\n     * @see PhoneNumberNormalizer#setFallbackRegionCode(String)\n     */\n    String normalizePhoneNumber(String number, DeviceContext deviceContext);\n\n    /**\n     * Normalizes the number using PhoneLib with some additions to compensate.\n     * <p>\n     * Not as powerful as {@link PhoneNumberNormalizer#normalizePhoneNumber(String, DeviceContext)}, because no default NDC can be set.\n     * </p>\n     * @param number plain number to normalize\n     * @param regionCode ISO2 code of the country, which number-plan is used for normalization\n     * @return E164 formatted phone number or at least a dialable version of the number\n     */\n    String normalizePhoneNumber(String number, String regionCode);\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/PhoneNumberAreaLabel.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer;\n\n", "\n\nimport java.util.Optional;\n\n/**\n * An interface for dependency injection - for direct use within your code just use {@link PhoneNumberAreaLabel}\n */\npublic interface PhoneNumberAreaLabel {\n\n\n\n    /**\n     * Get a location name for a E164 formated number\n     *\n     * @param e164number number following E164 schema eg. +4961511234567\n     * @return nullable optional with either a national label or if non is available a country label\n     */\n    Optional<String> getLocationByE164Number(String e164number);\n\n    /**\n     * Get a location name for a nationalnumber and region code\n     *\n     * @param nationalNumber number without the country prefix like 61511234567 (for number +4961511234567)\n     * @param regionCode region code for the number plan like de, us\n     * @return nullable optional with location name if present\n     */\n    Optional<String> getLocationByNationalNumberAndRegionCode(String nationalNumber, String regionCode);\n\n    /**\n     * Get country name string by country code\n     *\n     * @param countryCode - specific telephony code of country (telephone number prefix) like 49 (Germany), 1 (US),\n     * @return nullable optional with country name if present\n     */\n    Optional<String> getCountryNameByCountryCode(String countryCode);\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/numberplans/NumberPlanFactory.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.numberplans;\n\n", "\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.telekom.phonenumbernormalizer.dto.DeviceContextLineType;\nimport de.telekom.phonenumbernormalizer.numberplans.constants.DeFixedLineNumberPlan;\n\nimport java.util.EnumMap;\nimport java.util.HashMap;", "import java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A factory to retrieve a NumberPlan for a given line-type and country calling code. Currently supporting:\n * <ul>\n *     <li>German Fixed-Line</li>\n * </ul>\n *", " * </ul>\n *\n * @see NumberPlanFactory#getNumberPlan(DeviceContextLineType, String)\n */\npublic class NumberPlanFactory {\n    private static final Logger LOGGER = LoggerFactory.getLogger(NumberPlanFactory.class);\n    public static final NumberPlanFactory INSTANCE = new NumberPlanFactory();\n\n    /**\n     * Two-dimensional map - The first key is DeviceContextLineType and second key is the Country Calling Code while the value is a NumberPlan object.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType\n     */\n    private final Map<DeviceContextLineType, Map<String, NumberPlan>> numberPlans = new EnumMap<>(DeviceContextLineType.class);\n\n    /**\n     * Adding all coded NumberPlans to the factory\n     */\n    private NumberPlanFactory() {\n       this.initFixedLineNumberPlans();\n       this.initMobileNumberPlans();\n       this.initFallBackNumberPlans();\n    }\n\n    /**\n     * Adds coded NumberPlans for fixed-line context to the factory.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType#FIXEDLINE\n     */\n    private void initFixedLineNumberPlans() {\n        Map<String, NumberPlan> fixedLineNumberPlans = new HashMap<>();\n        fixedLineNumberPlans.put(DeFixedLineNumberPlan.getCountryCode(), new DeFixedLineNumberPlan());\n        numberPlans.put(DeviceContextLineType.FIXEDLINE, fixedLineNumberPlans);\n    }\n\n    /**\n     * Adds coded NumberPlans for mobile context to the factory.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType#MOBILE\n     */\n    private void initMobileNumberPlans() {\n        // TODO: Mobile Number Plan\n    }\n\n    /**\n     * Adds coded NumberPlans for unknown context to the factory. These are just the common rules for mobile and fixed-line, so that they could be applied regardless of which actual line context is used.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private void initFallBackNumberPlans() {\n        Map<String, NumberPlan> fixedLineNumberPlans = new HashMap<>();\n        // For Germany all short numbers of the fixed-line are also valid in mobile, so we can reuse it, if unknown.\n        fixedLineNumberPlans.put(DeFixedLineNumberPlan.getCountryCode(), new DeFixedLineNumberPlan());\n        numberPlans.put(DeviceContextLineType.UNKNOWN, fixedLineNumberPlans);\n    }\n\n    /**\n     * Gets a NumberPlan for a line-type of a specific country.\n     *\n     * @param numberPlanType line-type where the NumberPlan is valid\n     * @param countryCode country calling code for which the NumberPlan\n     * @return {@link NumberPlan}  for further checks\n     *\n     * @see DeviceContextLineType\n     * @see NumberPlan#isMatchingShortNumber(String)\n     */", "    public NumberPlan getNumberPlan(DeviceContextLineType numberPlanType, String countryCode) {\n        if (numberPlans.containsKey(numberPlanType)) {\n            LOGGER.debug(\"use number plan for type: {}\", numberPlanType);\n            Map<String, NumberPlan> numberPlan = numberPlans.get(numberPlanType);\n            if (numberPlan.containsKey(countryCode)) {\n                LOGGER.debug(\"use number plan for country code: {}\", countryCode);\n                return numberPlan.get(countryCode);\n            }\n        }\n        LOGGER.debug(\"no number plan for country available\");\n        return null;\n    }\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/numberplans/NumberPlan.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.numberplans;\n\n", "\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\nimport java.util.Collections;\nimport java.util.Optional;\nimport java.util.Comparator;\n", "import java.util.Comparator;\n\n\n/**\n * This class provides basic logic to check a given number against a simple set of rules to identify if it is short numbers, which does not need normalization.\n * It also needs to provide its country calling code, to specify where the rules apply.\n * <p>\n * PhoneLib already provide a ShortNumbers, but for EU wide 116xxx range only a few countries are configured to support the range. \n * For Germany only currently assigned numbers are configured which is in contrast to Googles definition of checks, \n * but nevertheless the <a href=\"https://issuetracker.google.com/u/1/issues/183669955\">corresponding Issues</a> has been rejected.", " * For Germany only currently assigned numbers are configured which is in contrast to Googles definition of checks, \n * but nevertheless the <a href=\"https://issuetracker.google.com/u/1/issues/183669955\">corresponding Issues</a> has been rejected.\n * </p><p>\n * Additionally, we designed the NumberPlanFactory to have a NumberPlan class for each DeviceContextLineType, so we can support short numbers which are valid only in fixed-line or mobile context.\n * </p>\n * @see NumberPlanFactory\n * @see de.telekom.phonenumbernormalizer.dto.DeviceContextLineType\n */\npublic abstract class NumberPlan {\n    private static final Logger LOGGER = LoggerFactory.getLogger(NumberPlan.class);\n\n    /**\n     * A subclass needs to provide a Map&lt;String, Integer&gt; as tbe rules to identify short numbers\n     * The key (String) is representing a prefix for the number and the value (Integer) is the total length of the short code (including the prefix)\n     * <ul>\n     * <li>e.g. \"110\"; 3 - the total length is already the length of the prefix, so its exactly the short number</li>\n     * <li>e.g. \"1100\"; 5 - the total length is longer than the length of the prefix, so all number from 11000 to 11009 are coverd</li>\n     * <li>e.g. both rules above can be combined, because longer prefixes are evaluated first, so that partical ranges of rules with shorter prefix can be overriden.</li>\n     * </ul>\n     * @return Map of rules for the short codes\n     *\n     * @see NumberPlan#isNumberPlanValid()\n     */\n    protected abstract Map<String, Integer> getShortNumberCodes();\n\n    /**\n     * A subclass can provide Country Calling Code of the rules - not used inside this class, but\n     * re-usable when adding the subclass to the factory.\n     *\n     * @return Country Calling Code without leading international Dialing Prefix\n     *\n     * @see NumberPlanFactory\n     */", "public abstract class NumberPlan {\n    private static final Logger LOGGER = LoggerFactory.getLogger(NumberPlan.class);\n\n    /**\n     * A subclass needs to provide a Map&lt;String, Integer&gt; as tbe rules to identify short numbers\n     * The key (String) is representing a prefix for the number and the value (Integer) is the total length of the short code (including the prefix)\n     * <ul>\n     * <li>e.g. \"110\"; 3 - the total length is already the length of the prefix, so its exactly the short number</li>\n     * <li>e.g. \"1100\"; 5 - the total length is longer than the length of the prefix, so all number from 11000 to 11009 are coverd</li>\n     * <li>e.g. both rules above can be combined, because longer prefixes are evaluated first, so that partical ranges of rules with shorter prefix can be overriden.</li>\n     * </ul>\n     * @return Map of rules for the short codes\n     *\n     * @see NumberPlan#isNumberPlanValid()\n     */\n    protected abstract Map<String, Integer> getShortNumberCodes();\n\n    /**\n     * A subclass can provide Country Calling Code of the rules - not used inside this class, but\n     * re-usable when adding the subclass to the factory.\n     *\n     * @return Country Calling Code without leading international Dialing Prefix\n     *\n     * @see NumberPlanFactory\n     */", "    public static String getCountryCode() {\n        return null;\n    }\n\n    /**\n     * Checks if a number is matching any a short number rule of the current number plan.\n     *\n     * @param number - number that should be checked against the number plan\n     * @return boolean - if short number was matched\n     */\n    public boolean isMatchingShortNumber(String number) {\n\n        // first check if we have rules at all", "    public boolean isMatchingShortNumber(String number) {\n\n        // first check if we have rules at all\n        if (this.getShortNumberCodes() == null) {\n            LOGGER.debug(\"no short number code rules available\");\n            return false;\n        }\n\n        // check if the number is in the length range of short numbers defined by the rules.\n        int minShortNumberLength = this.getMinShortNumberLength();\n        int maxShortNumberLength = this.getMaxShortNumberLength();\n", "        if (number.length() < minShortNumberLength) {\n            LOGGER.debug(\"no short number, to short number: {}\", number);\n            return false;\n        }\n\n        if (number.length() > maxShortNumberLength) {\n            LOGGER.debug(\"no short number, too long number: {}\", number);\n            return false;\n        }\n\n\n        // check if the number is starting with a prefix defined in the rule\n        int minShortNumberKeyLength = this.getMinShortNumberKeyLength();\n        int maxShortNumberKeyLength = this.getMaxShortNumberKeyLength();\n\n        Integer validShortNumberLength;\n\n        // starting prefix check with the longest prefix, so overlapping prefixes could be realized\n        // e.g. 1180 is in Germany a starting prefix for a 6 digit short number while 1181 - 1189 is in Germany a starting\n        // prefix for a 5 digits number and could be summed up by 118 and only 1180 is overriding this prefix part.", "        for (int i = maxShortNumberKeyLength; i >= minShortNumberKeyLength; i--) {\n            if (number.length() >= i) {\n                String shortNumber = number.substring(0, i);\n                if (this.getShortNumberCodes().containsKey(shortNumber)) {\n                    validShortNumberLength = this.getShortNumberCodes().get(shortNumber);\n                    return number.length() == validShortNumberLength;\n                }\n            }\n        }\n\n        LOGGER.debug(\"no short number, to code found for number: {}\", number);\n        return false;\n    }\n\n    /**\n     * Returns the length of the shortest configured short Number within the rules.\n     *\n     * @return the length of the shortest short Number within the rules or 0 if no rule exists\n     *\n     * @see NumberPlan#getShortNumberCodes()\n     */\n    private int getMinShortNumberLength() {", "        if (getShortNumberCodes() != null) {\n            return Collections.min(getShortNumberCodes().values());\n        } else return 0;\n    }\n\n    /**\n     * Returns the length of the shortest prefix within the rules.\n     *\n     * @return the length of the shortest prefix within the rules or 0 if no rule exists\n     *\n     * @see NumberPlan#getShortNumberCodes()\n     */\n    private int getMinShortNumberKeyLength() {", "        if (getShortNumberCodes() != null) {\n            Optional<String> minKey = getShortNumberCodes().keySet().stream()\n                    .min(Comparator.comparing(String::length));\n            if (minKey.isPresent()) {\n                return minKey.get().length();\n            }\n        }\n        return 0;\n    }\n\n\n    /**\n     * Returns the length of the longest configured short Number within the rules.\n     *\n     * @return the length of the longest short Number within the rules or 0 if no rule exists\n     *\n     * @see NumberPlan#getShortNumberCodes()\n     */\n    private int getMaxShortNumberLength() {", "        if (getShortNumberCodes() != null) {\n            return Collections.max(getShortNumberCodes().values());\n        } else return 0;\n    }\n\n    /**\n     * Returns the length of the longest prefix within the rules.\n     *\n     * @return the length of the longest prefix within the rules or 0 if no rule exists\n     *\n     * @see NumberPlan#getShortNumberCodes()\n     */\n    private int getMaxShortNumberKeyLength() {", "        if (getShortNumberCodes() != null) {\n            Optional<String> maxKey = getShortNumberCodes().keySet().stream()\n                    .max(Comparator.comparing(String::length));\n            if (maxKey.isPresent()) {\n                return maxKey.get().length();\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Checks if the rules are logically without conflict.\n     * Conflicts happen, if the length of a short number (value) is defined lower than the length of its prefix (key).\n     *\n     * @return are the rules free of conflict\n     *\n     * @see NumberPlan#getShortNumberCodes()\n     */", "    public Boolean isNumberPlanValid() {\n        if (this.getShortNumberCodes() != null) {\n            for ( Map.Entry<String, Integer> entry : this.getShortNumberCodes().entrySet()) {\n                if (entry.getKey().length() > entry.getValue()) {\n                    LOGGER.warn(\"The length of the ShortNumberCode '{}' is longer then its ShortnumberCodeLength '{}'\", entry.getKey(), entry.getValue());\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/numberplans/PhoneLibWrapper.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.numberplans;\n\n", "\n\nimport com.google.i18n.phonenumbers.*;\nimport lombok.Data;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\nimport java.lang.reflect.Method;\nimport java.util.Objects;", "import java.lang.reflect.Method;\nimport java.util.Objects;\n\n/**\n * Wrapper around the PhoneLib library from Google\n * <p>\n * Using reflection to access internal information to know if a region has a nation prefix &amp; which one it is.\n * </p><p>\n * Providing own NumberPlans logic as an alternative to PhoneLib ShortNumber.\n * </p>", " * Providing own NumberPlans logic as an alternative to PhoneLib ShortNumber.\n * </p>\n * @see NumberPlan\n */\n@Data\npublic class PhoneLibWrapper {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PhoneLibWrapper.class);\n\n    public static final String UNKNOWN_REGIONCODE = \"ZZ\"; // see https://github.com/google/libphonenumber/blob/5e9507a46051405120bc73fcc13d0b0be1b93c29/java/libphonenumber/test/com/google/i18n/phonenumbers/RegionCode.java#L62\n\n    /**\n     * The given number reduced to characters which could be dialed\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    String dialableNumber;\n\n    /**\n     * The given number normalized with PhoneLib, risking we get a incorrect normalization\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#isNormalizingTried()\n     * @see PhoneLibWrapper#getSemiNormalizedNumber()\n     */\n    Phonenumber.PhoneNumber semiNormalizedNumber;\n\n    /**\n     * The given region code for which the given number should be normalized.<br/>\n     * This is an ISO2 code for the country.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    String regionCode;\n\n    /**\n     * The number plan metadata which PhoneLib is using for the given region code.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    Phonemetadata.PhoneMetadata metadata;\n\n    /**\n     * An instance of the PhoneLib short number utility.\n     */\n    private static final ShortNumberInfo shortNumberUtil = ShortNumberInfo.getInstance();\n\n    /**\n     * An instance of the PhoneLib number utility.\n     */\n    private static final PhoneNumberUtil phoneUtil = PhoneNumberUtil.getInstance();\n\n    /**\n     * Storing if PhoneLib has been used to parse the given number into semiNormalizedNumber.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#semiNormalizedNumber\n     * @see PhoneLibWrapper#isNormalizingTried()\n     */\n    private boolean isNormalizingTried = false;\n\n    /**\n     * Initialize the wrapper by giving a phone number to be analyzed against a number plan of a given region\n     * @param number the phone number to be analyzed\n     * @param regionCode the ISO2 Code of the Region / Country, which telephone number plan is used\n     */\n    public PhoneLibWrapper(String number, String regionCode) {\n        this.regionCode = regionCode;\n        this.metadata = getMetadataForRegion();\n", "    public static final String UNKNOWN_REGIONCODE = \"ZZ\"; // see https://github.com/google/libphonenumber/blob/5e9507a46051405120bc73fcc13d0b0be1b93c29/java/libphonenumber/test/com/google/i18n/phonenumbers/RegionCode.java#L62\n\n    /**\n     * The given number reduced to characters which could be dialed\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    String dialableNumber;\n\n    /**\n     * The given number normalized with PhoneLib, risking we get a incorrect normalization\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#isNormalizingTried()\n     * @see PhoneLibWrapper#getSemiNormalizedNumber()\n     */\n    Phonenumber.PhoneNumber semiNormalizedNumber;\n\n    /**\n     * The given region code for which the given number should be normalized.<br/>\n     * This is an ISO2 code for the country.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    String regionCode;\n\n    /**\n     * The number plan metadata which PhoneLib is using for the given region code.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */\n    Phonemetadata.PhoneMetadata metadata;\n\n    /**\n     * An instance of the PhoneLib short number utility.\n     */\n    private static final ShortNumberInfo shortNumberUtil = ShortNumberInfo.getInstance();\n\n    /**\n     * An instance of the PhoneLib number utility.\n     */\n    private static final PhoneNumberUtil phoneUtil = PhoneNumberUtil.getInstance();\n\n    /**\n     * Storing if PhoneLib has been used to parse the given number into semiNormalizedNumber.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#semiNormalizedNumber\n     * @see PhoneLibWrapper#isNormalizingTried()\n     */\n    private boolean isNormalizingTried = false;\n\n    /**\n     * Initialize the wrapper by giving a phone number to be analyzed against a number plan of a given region\n     * @param number the phone number to be analyzed\n     * @param regionCode the ISO2 Code of the Region / Country, which telephone number plan is used\n     */\n    public PhoneLibWrapper(String number, String regionCode) {\n        this.regionCode = regionCode;\n        this.metadata = getMetadataForRegion();\n", "        if (number != null) {\n            this.dialableNumber = PhoneNumberUtil.normalizeDiallableCharsOnly(number);\n\n            if (this.dialableNumber.isEmpty()) {\n                this.dialableNumber = \"\";\n            } else {\n                if (!isSpecialFormat(dialableNumber)) {\n                    // Number needs normalization:\n                    // international prefix is added by the lib even if it's not valid in the number plan.\n                    this.isNormalizingTried = true;\n                    this.semiNormalizedNumber = PhoneLibWrapper.parseNumber(dialableNumber, regionCode);\n                }\n            }\n        }\n    }\n\n    /**\n     * If PhoneLib has been used to parse the given number into semiNormalizedNumber.\n     *\n     * @return {@link PhoneLibWrapper#isNormalizingTried}\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */", "    public boolean isNormalizingTried() {\n        return isNormalizingTried;\n    }\n\n    /**\n     * Using PhoneLib short number utility if it identifies the given number as a short number, which would not need a NAC.\n     * <p>\n     * This is a fallback for {@link PhoneLibWrapper#isShortNumber(NumberPlan)}, when we do not have an own number plan information.\n     * </p>\n     * @return if PhoneLib identifies given number as a short number\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#isShortNumber(NumberPlan)\n     */", "    public boolean isShortNumber() {\n        return shortNumberUtil.isPossibleShortNumber(this.getSemiNormalizedNumber());\n    }\n\n    /**\n     * Using own {@link NumberPlan} to identify if the given number is a short number, which would not need a NAC.\n     * <p>\n     * If no number plan is given, {@link PhoneLibWrapper#isShortNumber} is used as fallback.\n     * </p>\n     * @param numberplan the number plan we identified to be used for a check\n     * @return if number plan or as fallback PhoneLib identifies given number as a short number\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */", "    public boolean isShortNumber(NumberPlan numberplan) {\n        if (numberplan == null) {\n            return this.isShortNumber();\n        }\n        return numberplan.isMatchingShortNumber(this.getDialableNumber());\n    }\n\n    /**\n     * If we have a plain national number based on regions number plan and potential NAC logic.\n     * <p>\n     * For a number plan without NAC logic, it will always return false!\n     * </p>\n     * @return if given number could have CC and NAC, but does not have any of them.\n     */", "    public boolean hasNoCountryCodeNorNationalAccessCode() {\n        // if given number has no NAC and no CC, it equals national phone number (without NAC).\n        if (! Objects.equals(dialableNumber, this.getNationalPhoneNumberWithoutNationalAccessCode())) {\n            return false;\n        }\n        // checking the regions number plan, if a NAC logic can be applied - if not there would be no option of having a NAC or not.\n        return hasRegionNationalAccessCode();\n    }\n\n    /**\n     * Using PhoneLib to get a E164 formatted representation of the given number\n     * <p>\n     * This is a straight invocation, so no compensation of some inaccuracy is done here.\n     * </p>\n     * @return E164 format of the given phone number\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */", "    public String getE164Formatted() {\n        return phoneUtil.format(this.semiNormalizedNumber, PhoneNumberUtil.PhoneNumberFormat.E164);\n    }\n\n    /**\n     * If we know the given region for the given number {@link PhoneLibWrapper#hasRegionNationalAccessCode()}, this method checks if the given number does not start with a NAC nor a CC,\n     * so we could permanently add a default NDC and NAC to the given number and for this new value the method directly return a E164 formatted representation.\n     * @param nationalAccessCode the NAC to be added e.g. for Germany it would be \"0\"\n     * @param defaultNationalDestinationCode the NDC to be added depending on the use telephone line origination.\n     * @return if possible a E164 formatted representation or just the diallable representation of the given number.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     */", "    public String extendNumberByDefaultAreaCodeAndCountryCode(String nationalAccessCode, String defaultNationalDestinationCode) {\n        String nationalPhoneNumberWithoutNationalAccessCode = this.getNationalPhoneNumberWithoutNationalAccessCode();\n        //if the dialableNumber is same as the national Number, Without NationalPrefix, then there is no NDC, so it needs to be added.\n        if (Objects.equals(dialableNumber, nationalPhoneNumberWithoutNationalAccessCode)) {\n\n            String extendedNumber = nationalAccessCode + defaultNationalDestinationCode + nationalPhoneNumberWithoutNationalAccessCode;\n\n            try {\n                this.semiNormalizedNumber = phoneUtil.parse(extendedNumber, regionCode);\n                // after area code has been added, we can add the country code by the lib:\n                return getE164Formatted();\n            } catch (NumberParseException e) {\n                LOGGER.warn(\"could not parse extended number: {}\", extendedNumber);\n                LOGGER.debug(\"{}\", e.getMessage());\n                return dialableNumber;\n            }\n        } else {\n            //it seems we have nationalnumber with national prefix, so we could add country code:\n            return getE164Formatted();\n        }\n    }\n\n    /**\n     * Some Special dial-able characters make a number either not necessary to be normalized (\"+\" is already normalized) or can't be normalized (\"*\" control codes)\n     * @param value phone number representation\n     * @return if phone number starts with special characters which makes normalization unable / not necessary\n     */\n    static boolean isSpecialFormat(String value) {\n        //+: Number is already in \"+\" ... International Format:\n        //*: Number is internal and cannot be normalized", "        if (value == null || value.length()==0) {\n            return false;\n        }\n        return (\"+\".equals(value.substring(0, 1))) || (\"*\".equals(value.substring(0, 1)));\n    }\n\n    /**\n     * Use PhoneLib to parse a number for a regions code. If any exception occurs, they are logged and null is returned.\n     * @param number the phone number to be parsed\n     * @param regionCode ISO2 code for the regions number plan used for parsing the number\n     * @return either the parsed {@link Phonenumber.PhoneNumber} or null\n     */\n    private static Phonenumber.PhoneNumber parseNumber(String number, String regionCode) {", "        try {\n            return phoneUtil.parse(number, regionCode);\n            // international prefix is added by the lib even if it's not valid in the number plan.\n        } catch (NumberParseException e) {\n            LOGGER.warn(\"could not parse normalize number: {}\", number);\n            LOGGER.debug(\"{}\", e.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * The National Access Code used before the National Destination Code in the given region from PhoneLib\n     * @return NAC of given {@link PhoneLibWrapper#regionCode}\n     */", "    public String getNationalAccessCode() {\n        if (metadata == null) {\n            return null;\n        }\n        return metadata.getNationalPrefix();\n    }\n\n    /**\n     * From PhoneLib, if a National Access Code is used before the National Destination Code in the given region\n     * @return if given {@link PhoneLibWrapper#regionCode} is using NAC\n     */", "    public boolean hasRegionNationalAccessCode() {\n        return metadata != null && metadata.hasNationalPrefix();\n    }\n\n    /**\n     * Since we need the PhoneMetadta for fixing calculation of some number normalization,\n     * we need to break encapsulation via reflection, because that data is private to phoneUtil\n     * and Google rejected suggestion to make it public, because they did not see our need in correcting normalization.\n     * @return {@link Phonemetadata.PhoneMetadata} of {@link PhoneLibWrapper#regionCode}\n     */\n    private Phonemetadata.PhoneMetadata getMetadataForRegion() {", "        try {\n            Method m = phoneUtil.getClass().getDeclaredMethod(\"getMetadataForRegion\", String.class);\n            // violating encupsulation is intended by this method, so no need for SONAR code smell warning here\n            m.setAccessible(true); //NOSONAR\n            return (Phonemetadata.PhoneMetadata) m.invoke(phoneUtil, regionCode);\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while accessing getMetadataForRegion on PhoneNumberUtil via Reflection.\");\n            LOGGER.debug(\"{}\", e.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Using PhoneLib to get the national number from the given number\n     *\n     * @return national number without NAC, but any other leading zero.\n     *\n     * @see PhoneLibWrapper#PhoneLibWrapper(String, String)\n     * @see PhoneLibWrapper#getSemiNormalizedNumber()\n     * @see PhoneLibWrapper#nationalPhoneNumberWithoutNationalPrefix(Phonenumber.PhoneNumber)\n     */\n    private String getNationalPhoneNumberWithoutNationalAccessCode() {\n        return PhoneLibWrapper.nationalPhoneNumberWithoutNationalPrefix(this.semiNormalizedNumber);\n    }\n\n    /**\n     * Using PhoneLib to get the national number from a parsed phone number with leading zeros, if those are not representing a National Access Code.\n     * <p/>\n     * This is necessary, because PhoneLib is storing the national number as a long, so leading \"0\" Digits as part of it are stored in other attributes.\n     * @param phoneNumber A PhoneLib parsed phone number\n     * @return national number part without NationalPrefix (aka NAC) but any other leading zero.\n     */\n    private static String nationalPhoneNumberWithoutNationalPrefix(Phonenumber.PhoneNumber phoneNumber) {", "        if (phoneNumber==null) {\n            return null;\n        }\n        StringBuilder nationalNumber = new StringBuilder(Long.toString(phoneNumber.getNationalNumber()));\n        // if-clause necessary, because getNumberOfLeadingZeros is always 1 for a possible trunc code and special 0 in Italy\n        if (phoneNumber.hasNumberOfLeadingZeros() || phoneNumber.hasItalianLeadingZero())\n            for (int i = 0; i < phoneNumber.getNumberOfLeadingZeros(); i++) {\n                nationalNumber.insert(0, \"0\");\n            }\n        return nationalNumber.toString();\n    }\n\n    /**\n     * Using PhoneLib to get the Country Calling Code for a region code\n     * <p>\n     * e.g. \"DE\" is \"49\"\n     * </p>\n     * @param regionCode ISO2 code of a region\n     * @return country calling code of the region or 0 if regionCode is invalid.\n     */", "    public static int getCountryCodeForRegion(String regionCode) {\n        return phoneUtil.getCountryCodeForRegion(regionCode);\n    }\n\n    /**\n     * Using PhoneLib to get the region code for a Country Calling Code\n     * <p>\n     * e.g. \"49\" is \"DE\"\n     * </p>\n     * @param countryCode only digits without IDP\n     * @return regionCode or {@link PhoneLibWrapper#UNKNOWN_REGIONCODE} if countryCode is invalid.\n     */", "    public static String getRegionCodeForCountryCode(String countryCode) {\n        try {\n            return phoneUtil.getRegionCodeForCountryCode(Integer.parseInt(countryCode));\n        } catch (Exception e) {\n            LOGGER.info(\"Error while parsing Country Code: {}\", countryCode);\n            LOGGER.debug(\"{}\", e.getMessage());\n            return PhoneLibWrapper.UNKNOWN_REGIONCODE;\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/numberplans/constants/DeFixedLineNumberPlan.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.numberplans.constants;\n\n", "\n\nimport java.util.Map;\n\nimport de.telekom.phonenumbernormalizer.numberplans.NumberPlan;\n\n/**\n *  Definition see Chapter 8.1 in <a href=\"https://www.bundesnetzagentur.de/SharedDocs/Downloads/DE/Sachgebiete/Telekommunikation/Unternehmen_Institutionen/Nummerierung/Nummerierungskonzept/Nummerierungskonzept2011pdf.pdf?__blob=publicationFile\">BNetzA German Number Plan</a>\n *\n */\npublic class DeFixedLineNumberPlan extends NumberPlan {\n\n    /**\n     * Constant for German Country Calling Code\n     */\n    private static final String COUNTRY_CODE = \"49\";\n\n    /**\n     * Constant for German short numbers in fixed-line\n     */\n    private static final Map<String, Integer> SHORT_NUMBER_CODES = Map.of(\n            \"110\", 3,\n            \"112\", 3,\n            \"115\", 3,\n            \"116\", 6,\n            \"1180\", 6,\n            \"118\", 5  // This covers  1181 - 1189 since 1180 is longer prefix and has its own value.\n    );\n\n\n    @Override\n    protected Map<String, Integer> getShortNumberCodes() {\n        return SHORT_NUMBER_CODES;\n    }\n", " *\n */\npublic class DeFixedLineNumberPlan extends NumberPlan {\n\n    /**\n     * Constant for German Country Calling Code\n     */\n    private static final String COUNTRY_CODE = \"49\";\n\n    /**\n     * Constant for German short numbers in fixed-line\n     */\n    private static final Map<String, Integer> SHORT_NUMBER_CODES = Map.of(\n            \"110\", 3,\n            \"112\", 3,\n            \"115\", 3,\n            \"116\", 6,\n            \"1180\", 6,\n            \"118\", 5  // This covers  1181 - 1189 since 1180 is longer prefix and has its own value.\n    );\n\n\n    @Override\n    protected Map<String, Integer> getShortNumberCodes() {\n        return SHORT_NUMBER_CODES;\n    }\n", "    public static String getCountryCode() {\n        return COUNTRY_CODE;\n    }\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/dto/DeviceContextDto.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.dto;\n\n", "\n\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.experimental.SuperBuilder;\n\n/**", "\n/**\n * This is an aggregation of attributes which define the context of a device in a telephony use case to\n * enable normalization of its telephone number even when optional NDC is not used.\n */\n@ApiModel(description = \"The context of a call about the used line and its relation in a number plan.\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@SuperBuilder\npublic class DeviceContextDto implements DeviceContext {\n\n    /**\n     * The line-type the device is using. Default is DeviceContextLineType.UNKNOWN\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    @ApiModelProperty(value = \"Type of the devices line used. \", example = DeviceContextLineType.FIXEDLINE_VALUE, allowableValues = DeviceContextLineType.FIXEDLINE_VALUE + \", \"\n                                                                                                                                  + DeviceContextLineType.MOBILE_VALUE + \", \"\n                                                                                                                                  + DeviceContextLineType.UNKNOWN_VALUE)\n    private DeviceContextLineType lineType = DeviceContextLineType.UNKNOWN;\n\n    /**\n     * The Country (Calling) Code of the countries number plan, where the device is originated. Also known as Landesvorwahl.\n     * Without international dialing prefix nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p/>\n     * E.G. \"49\" for Germany\n     *\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    @ApiModelProperty(value = \"Country Calling Code without leading 00 nor +; if not present its unknown\", example = \"49\")\n    private String countryCode = DeviceContext.UNKNOWN_VALUE;\n\n    /**\n     * The National Destination Code (NDC) of the countries number plan, where the device is originated. Also known as AreaCode, ONKZ or (Orts-)Vorwahl.\n     * Without National Access Code (NAC) nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p/>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     *\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    @ApiModelProperty(value = \"National Destination Code without leading 0 nor other trunc codes; if not present its unknown\", example = \"228\")\n    private String nationalDestinationCode = DeviceContext.UNKNOWN_VALUE;\n\n}\n", "@AllArgsConstructor\n@SuperBuilder\npublic class DeviceContextDto implements DeviceContext {\n\n    /**\n     * The line-type the device is using. Default is DeviceContextLineType.UNKNOWN\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    @ApiModelProperty(value = \"Type of the devices line used. \", example = DeviceContextLineType.FIXEDLINE_VALUE, allowableValues = DeviceContextLineType.FIXEDLINE_VALUE + \", \"\n                                                                                                                                  + DeviceContextLineType.MOBILE_VALUE + \", \"\n                                                                                                                                  + DeviceContextLineType.UNKNOWN_VALUE)\n    private DeviceContextLineType lineType = DeviceContextLineType.UNKNOWN;\n\n    /**\n     * The Country (Calling) Code of the countries number plan, where the device is originated. Also known as Landesvorwahl.\n     * Without international dialing prefix nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p/>\n     * E.G. \"49\" for Germany\n     *\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    @ApiModelProperty(value = \"Country Calling Code without leading 00 nor +; if not present its unknown\", example = \"49\")\n    private String countryCode = DeviceContext.UNKNOWN_VALUE;\n\n    /**\n     * The National Destination Code (NDC) of the countries number plan, where the device is originated. Also known as AreaCode, ONKZ or (Orts-)Vorwahl.\n     * Without National Access Code (NAC) nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p/>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     *\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    @ApiModelProperty(value = \"National Destination Code without leading 0 nor other trunc codes; if not present its unknown\", example = \"228\")\n    private String nationalDestinationCode = DeviceContext.UNKNOWN_VALUE;\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/dto/DeviceContext.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.dto;\n\n", "\n\n/**\n * This is an aggregation of attributes which define the context of a device in a telephony use case to\n * enable normalization of its telephone number even when optional NDC is not used.\n *\n * @see DeviceContextLineType\n */\npublic interface DeviceContext {\n\n    /**\n     * Indicates the value to be hold in an attribute is not known.\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#setCountryCode(String)\n     * @see DeviceContext#getNationalDestinationCode()\n     * @see DeviceContext#setNationalDestinationCode(String)\n     */\n    String UNKNOWN_VALUE = \"unknown\";\n\n    /**\n     * Getter for the line-type the device is using\n     *\n     * @return the line-type the telephony device is using\n     *\n     * @see DeviceContext#setLineType(DeviceContextLineType)\n     */\n    DeviceContextLineType getLineType();\n\n    /**\n     * Setter for the line-type the device is using\n     *\n     * @param lineType the line-type the telephony device is using\n     *\n     * @see DeviceContext#getLineType()\n     */\n    void setLineType(DeviceContextLineType lineType);\n\n    /**\n     * Getter for the Country (Calling) Code of the countries number plan, where the device is originated.\n     * Without international dialing prefix nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"49\" for Germany\n     * </p>\n     * @return either a string containing one to three digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    String getCountryCode();\n\n    /**\n     * Setter for the Country (Calling) Code of the countries number plan, where the device is originated.\n     * Without international deailing prefix nor trunc code. If not known it should be set to DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"49\" for Germany\n     * </p>\n     * @param countryCode either a string containing one to three digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    void setCountryCode(String countryCode);\n\n    /**\n     * Getter for the National Destination Code (NDC) of the countries number plan, where the device is originated.\n     * Without National Access Code (NAC) nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     * </p>\n     * @return either a string containing a variable amount of digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#setNationalDestinationCode(String)\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    String getNationalDestinationCode();\n\n    /**\n     * Setter for the National Destination Code (NDC) of the countries number plan, where the device is originated.\n     * Without National Access Code (NAC) nor trunc code. If not known it should be set to DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     * </p>\n     * @param nationalDestinationCode either a string containing a variable amount of digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    void setNationalDestinationCode(String nationalDestinationCode);\n\n}\n", "public interface DeviceContext {\n\n    /**\n     * Indicates the value to be hold in an attribute is not known.\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#setCountryCode(String)\n     * @see DeviceContext#getNationalDestinationCode()\n     * @see DeviceContext#setNationalDestinationCode(String)\n     */\n    String UNKNOWN_VALUE = \"unknown\";\n\n    /**\n     * Getter for the line-type the device is using\n     *\n     * @return the line-type the telephony device is using\n     *\n     * @see DeviceContext#setLineType(DeviceContextLineType)\n     */\n    DeviceContextLineType getLineType();\n\n    /**\n     * Setter for the line-type the device is using\n     *\n     * @param lineType the line-type the telephony device is using\n     *\n     * @see DeviceContext#getLineType()\n     */\n    void setLineType(DeviceContextLineType lineType);\n\n    /**\n     * Getter for the Country (Calling) Code of the countries number plan, where the device is originated.\n     * Without international dialing prefix nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"49\" for Germany\n     * </p>\n     * @return either a string containing one to three digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    String getCountryCode();\n\n    /**\n     * Setter for the Country (Calling) Code of the countries number plan, where the device is originated.\n     * Without international deailing prefix nor trunc code. If not known it should be set to DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"49\" for Germany\n     * </p>\n     * @param countryCode either a string containing one to three digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    void setCountryCode(String countryCode);\n\n    /**\n     * Getter for the National Destination Code (NDC) of the countries number plan, where the device is originated.\n     * Without National Access Code (NAC) nor trunc code. If not known or not set, it should return DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     * </p>\n     * @return either a string containing a variable amount of digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#setNationalDestinationCode(String)\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    String getNationalDestinationCode();\n\n    /**\n     * Setter for the National Destination Code (NDC) of the countries number plan, where the device is originated.\n     * Without National Access Code (NAC) nor trunc code. If not known it should be set to DeviceContext.UNKNOWN_VALUE.\n     * <p>\n     * E.G. \"228\" for Bonn in Germany where the Deutsche Telekom Headquarter is located\n     * </p>\n     * @param nationalDestinationCode either a string containing a variable amount of digits representing a country calling code or \"unknown\"\n     *\n     * @see DeviceContext#getCountryCode()\n     * @see DeviceContext#UNKNOWN_VALUE\n     */\n    void setNationalDestinationCode(String nationalDestinationCode);\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/dto/DeviceContextMapper.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.dto;\n\nimport org.apache.commons.lang3.StringUtils;", "\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Objects;\n\n/**\n * Helper class providing some static methods for setting up a DeviceContext instance with the correct value for unknown value if an attribute is not provided\n */\npublic class DeviceContextMapper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeviceContextMapper.class);\n\n    /**\n     * Since the class only provides some static methods, it mustn't be instantiated.\n     * The initializer will always throw an IllegalStateException\n     *\n     * @see IllegalStateException\n     */\n    private DeviceContextMapper() {\n        LOGGER.warn(\"DeviceContextMapper is a utility class and can't be initialised!\");\n        throw new IllegalStateException(\"DeviceContextMapper is a Utility class\");\n    }\n\n    /**\n     * This method takes a line-type and if its Null, returns DeviceContextLineType.UNKNOWN\n     * @param lineType the line-type used in the DeviceContext\n     * @return a valid {@link DeviceContextLineType} enum value - at least DeviceContextLineType.UNKNOWN\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private static DeviceContextLineType normalizeType(DeviceContextLineType lineType) {\n        return Objects.requireNonNullElse(lineType, DeviceContextLineType.UNKNOWN);\n    }\n\n    /**\n     * This method takes a country calling code. If that is empty, longer than three digits or contains non digit characters, it returns DeviceContext.UNKNOWN_VALUE\n     * <p/>\n     * There is no deep check if the CC is really assigned by the ITU!\n     *\n     * @param countryCode the country calling code used in the DeviceContext\n     * @return a valid country calling code value - at least DeviceContext.UNKNOWN_VALUE\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private static String normalizeCountryCode(String countryCode) {", " * Helper class providing some static methods for setting up a DeviceContext instance with the correct value for unknown value if an attribute is not provided\n */\npublic class DeviceContextMapper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeviceContextMapper.class);\n\n    /**\n     * Since the class only provides some static methods, it mustn't be instantiated.\n     * The initializer will always throw an IllegalStateException\n     *\n     * @see IllegalStateException\n     */\n    private DeviceContextMapper() {\n        LOGGER.warn(\"DeviceContextMapper is a utility class and can't be initialised!\");\n        throw new IllegalStateException(\"DeviceContextMapper is a Utility class\");\n    }\n\n    /**\n     * This method takes a line-type and if its Null, returns DeviceContextLineType.UNKNOWN\n     * @param lineType the line-type used in the DeviceContext\n     * @return a valid {@link DeviceContextLineType} enum value - at least DeviceContextLineType.UNKNOWN\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private static DeviceContextLineType normalizeType(DeviceContextLineType lineType) {\n        return Objects.requireNonNullElse(lineType, DeviceContextLineType.UNKNOWN);\n    }\n\n    /**\n     * This method takes a country calling code. If that is empty, longer than three digits or contains non digit characters, it returns DeviceContext.UNKNOWN_VALUE\n     * <p/>\n     * There is no deep check if the CC is really assigned by the ITU!\n     *\n     * @param countryCode the country calling code used in the DeviceContext\n     * @return a valid country calling code value - at least DeviceContext.UNKNOWN_VALUE\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private static String normalizeCountryCode(String countryCode) {", "         if (StringUtils.isEmpty(countryCode)) {\n            return DeviceContext.UNKNOWN_VALUE;\n        } else if (StringUtils.isNumeric(countryCode)) {\n             if (countryCode.length()>3) {\n                 LOGGER.debug(\"Country Code has more than three digits: {}\", countryCode);\n                 return DeviceContext.UNKNOWN_VALUE;\n             }\n            // this is a valid country code which could be returned\n            return countryCode;\n        } else {\n            // if a non digit character is included this might be ok, if the whole value matches UNKNOWN_VALUE", "            if (! DeviceContext.UNKNOWN_VALUE.equalsIgnoreCase(countryCode) ) {\n              LOGGER.debug(\"Country Code does not contain only digits: {}\", countryCode);\n            }\n            return DeviceContext.UNKNOWN_VALUE;\n        }\n    }\n\n    /**\n     * This method takes a national destination code. If that is empty or contains non digit characters, it returns DeviceContext.UNKNOWN_VALUE\n     * <p/>\n     * There is no deep check if the NDC is assigned in the given CC number plan.\n     *\n     * @param nationalDestinationCode the national destination code used in the DeviceContext\n     * @return a valid national destination code value - at least DeviceContext.UNKNOWN_VALUE\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */\n    private static String normalizeNationalDestinationCode(String nationalDestinationCode) {\n        // DeviceContext.UNKNOWN_VALUE.equalsIgnoreCase(nationalDestinationCode) does not need to be checked, since it includes non digits which are covered by the regex.", "        if (StringUtils.isEmpty(nationalDestinationCode)) {\n            return DeviceContext.UNKNOWN_VALUE;\n        } else if (StringUtils.isNumeric(nationalDestinationCode)) {\n            return nationalDestinationCode;\n        } else {\n            LOGGER.debug(\"National Destination Code does not contain only digits: {}\", nationalDestinationCode);\n            return DeviceContext.UNKNOWN_VALUE;\n        }\n    }\n\n    /**\n     * This method creates a new DeviceContext object and copies the attributes of the given DeviceContext with a defined state.\n     *\n     * @param  context the object containing the parameters to be normalized.\n     * @return {@link DeviceContext} new Object and copies of the parameters with a defined state.\n     */", "    public static DeviceContext normalized(DeviceContext context) {\n        DeviceContext result = new DeviceContextDto();\n        if (context==null) {\n            result.setLineType(DeviceContextLineType.UNKNOWN);\n            result.setCountryCode(DeviceContext.UNKNOWN_VALUE);\n            result.setNationalDestinationCode(DeviceContext.UNKNOWN_VALUE);\n        } else {\n            result.setLineType(normalizeType(context.getLineType()));\n            result.setCountryCode(normalizeCountryCode(context.getCountryCode()));\n            result.setNationalDestinationCode(normalizeNationalDestinationCode(context.getNationalDestinationCode()));\n        }\n        return result;\n    }\n\n}\n"]}
{"filename": "src/main/java/de/telekom/phonenumbernormalizer/dto/DeviceContextLineType.java", "chunked_list": ["/*\n * Copyright \u00a9 2023 Deutsche Telekom AG (opensource@telekom.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage de.telekom.phonenumbernormalizer.dto;\n\n", "\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonValue;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n", "import java.util.Locale;\n\n/**\n * The enum values define the line-type in the context of a device involved in the call\n * <p>\n * Currently supported values are for fixed-line, mobile and unknown (also for anything else).\n * </p>\n * @see DeviceContextLineType#FIXEDLINE\n * @see DeviceContextLineType#MOBILE\n * @see DeviceContextLineType#UNKNOWN", " * @see DeviceContextLineType#MOBILE\n * @see DeviceContextLineType#UNKNOWN\n */\npublic enum DeviceContextLineType {\n\n    /**\n     * If the device from the user is a fixed-line device - like a smart speaker with a DECT connection over a DECT base on a fixed-line access\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     */\n    @JsonProperty(DeviceContextLineType.FIXEDLINE_VALUE)\n    FIXEDLINE(DeviceContextLineType.FIXEDLINE_VALUE),\n\n    /**\n     * If the device from the user is a mobile device - like a smart speaker with a HFP connection over a cell-phone\n     *\n     * @see DeviceContextLineType#MOBILE_VALUE\n     */\n    @JsonProperty(DeviceContextLineType.MOBILE_VALUE)\n    MOBILE(DeviceContextLineType.MOBILE_VALUE),\n\n    /**\n     *  If the device from the user is none of any other defined value or not known.\n     *\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     */\n    @JsonProperty(DeviceContextLineType.UNKNOWN_VALUE)\n    UNKNOWN(DeviceContextLineType.UNKNOWN_VALUE);\n\n    /**\n     * Value used to represent the FIXEDLINE enum value in a JSON\n     *\n     * @see DeviceContextLineType#FIXEDLINE\n     */", "    public static final String FIXEDLINE_VALUE = \"fixline\";\n\n    /**\n     * Value used to represent the MOBILE enum value in a JSON\n     *\n     * @see DeviceContextLineType#MOBILE\n     */\n    public static final String MOBILE_VALUE = \"mobile\";\n\n    /**\n     * Value used to represent the UNKNOWN enum value in a JSON\n     *\n     * @see DeviceContextLineType#UNKNOWN\n     */", "    public static final String UNKNOWN_VALUE = \"unknown\";\n\n    /**\n     * Besides the official representation FIXEDLINE_VALUE for the enum value FIXEDLINE\n     * this additional strings are supported by decoding from String.\n     *\n     * @see DeviceContextLineType#FIXEDLINE\n     * @see DeviceContextLineType#of(String)\n     */\n    private static final List<String> SYNONYM_LIST_FIXEDLINE_VALUES = Arrays.asList(\n            FIXEDLINE_VALUE.toUpperCase(Locale.ROOT),\n            \"FIXEDLINE\",\n            \"FIXED-LINE\",\n            \"LANDLINE\",\n            \"FESTNETZ\"\n    );\n\n    /**\n     * Besides the official representation MOBILE_VALUE for the enum value MOBILE\n     * this additional strings are supported by decoding from String.\n     *\n     * @see DeviceContextLineType#MOBILE\n     * @see DeviceContextLineType#of(String)\n     */\n    private static final List<String> SYNONYM_LIST_MOBILE_VALUES = Arrays.asList(\n            MOBILE_VALUE.toUpperCase(Locale.ROOT),\n            \"MOBIL\",\n            \"CELL\",\n            \"CELLULAR\",\n            \"MOBILFUNK\"\n    );\n\n    /**\n     * Storing the String representation for an enum value\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     * @see DeviceContextLineType#MOBILE_VALUE\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     * @see DeviceContextLineType#toValue()\n     */\n    private final String value;\n\n    /**\n     * Initializer to store the String representation for an enum value\n     *\n     * @param value string representing the enum value\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     * @see DeviceContextLineType#MOBILE_VALUE\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     */\n    DeviceContextLineType(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Parse a string representation to line-type\n     *\n     * @param value device context type as String to be parsed into line-type\n     * @return {@link DeviceContextLineType}\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     * @see DeviceContextLineType#SYNONYM_LIST_FIXEDLINE_VALUES\n     * @see DeviceContextLineType#MOBILE_VALUE\n     * @see DeviceContextLineType#SYNONYM_LIST_MOBILE_VALUES\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     */\n    @JsonCreator", "    public static DeviceContextLineType of(String value) {\n        if (value == null) {\n            return UNKNOWN;\n        }\n        String valueToSearch = value.toUpperCase(Locale.ROOT);\n\n        if (SYNONYM_LIST_FIXEDLINE_VALUES.contains(valueToSearch)) {\n            return FIXEDLINE;\n        }\n        if (SYNONYM_LIST_MOBILE_VALUES.contains(valueToSearch)) {\n            return MOBILE;\n        }\n       return UNKNOWN;\n    }\n\n    /**\n     * Return the string representation of a line-type enum value\n     * @return line-type string representation\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     * @see DeviceContextLineType#MOBILE_VALUE\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     */\n    @JsonValue", "        if (SYNONYM_LIST_MOBILE_VALUES.contains(valueToSearch)) {\n            return MOBILE;\n        }\n       return UNKNOWN;\n    }\n\n    /**\n     * Return the string representation of a line-type enum value\n     * @return line-type string representation\n     *\n     * @see DeviceContextLineType#FIXEDLINE_VALUE\n     * @see DeviceContextLineType#MOBILE_VALUE\n     * @see DeviceContextLineType#UNKNOWN_VALUE\n     */\n    @JsonValue", "    public String toValue(){\n        return value;\n    }\n}\n"]}
