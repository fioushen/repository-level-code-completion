{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/util/TextureSizeLookup.java", "chunked_list": ["package io.wispforest.lavendermd.util;\n\nimport it.unimi.dsi.fastutil.ints.Int2ObjectMap;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.util.Identifier;\nimport org.jetbrains.annotations.ApiStatus;\nimport org.jetbrains.annotations.Nullable;\n\npublic class TextureSizeLookup {\n\n    private static final Int2ObjectMap<Size> TEXTURE_SIZES = new Int2ObjectOpenHashMap<>();\n\n    public static @Nullable Size sizeOf(Identifier texture) {\n        return TEXTURE_SIZES.get(MinecraftClient.getInstance().getTextureManager().getTexture(texture).getGlId());\n    }\n\n    @ApiStatus.Internal", "\npublic class TextureSizeLookup {\n\n    private static final Int2ObjectMap<Size> TEXTURE_SIZES = new Int2ObjectOpenHashMap<>();\n\n    public static @Nullable Size sizeOf(Identifier texture) {\n        return TEXTURE_SIZES.get(MinecraftClient.getInstance().getTextureManager().getTexture(texture).getGlId());\n    }\n\n    @ApiStatus.Internal\n    public static void _registerTextureSize(int textureId, int width, int height) {\n        TEXTURE_SIZES.put(textureId, new Size(width, height));\n    }\n", "    public static void _registerTextureSize(int textureId, int width, int height) {\n        TEXTURE_SIZES.put(textureId, new Size(width, height));\n    }\n\n    public record Size(int width, int height) {}\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/compiler/OwoUICompiler.java", "chunked_list": ["package io.wispforest.lavendermd.compiler;\n\nimport io.wispforest.lavendermd.util.TextBuilder;\nimport io.wispforest.lavendermd.util.TextureSizeLookup;\nimport io.wispforest.owo.ui.component.BoxComponent;\nimport io.wispforest.owo.ui.component.Components;\nimport io.wispforest.owo.ui.component.LabelComponent;\nimport io.wispforest.owo.ui.container.Containers;\nimport io.wispforest.owo.ui.container.FlowLayout;\nimport io.wispforest.owo.ui.core.*;", "import io.wispforest.owo.ui.container.FlowLayout;\nimport io.wispforest.owo.ui.core.*;\nimport net.minecraft.text.MutableText;\nimport net.minecraft.text.Style;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\nimport net.minecraft.util.Identifier;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;", "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.OptionalInt;\nimport java.util.function.UnaryOperator;\n\n/**\n * A secondary default compiler implementation which generates rich, formatted\n * and structured output containing images and other arbitrary UI elements\n * by compiling to an owo-ui component tree\n */\npublic class OwoUICompiler implements MarkdownCompiler<ParentComponent> {\n\n    protected final Deque<FlowLayout> components = new ArrayDeque<>();\n    protected final TextBuilder textBuilder = new TextBuilder();\n\n    public OwoUICompiler() {\n        this.components.push(Containers.verticalFlow(Sizing.content(), Sizing.content()));\n    }\n\n    @Override", " * by compiling to an owo-ui component tree\n */\npublic class OwoUICompiler implements MarkdownCompiler<ParentComponent> {\n\n    protected final Deque<FlowLayout> components = new ArrayDeque<>();\n    protected final TextBuilder textBuilder = new TextBuilder();\n\n    public OwoUICompiler() {\n        this.components.push(Containers.verticalFlow(Sizing.content(), Sizing.content()));\n    }\n\n    @Override", "    public void visitText(String text) {\n        this.textBuilder.append(Text.literal(text));\n    }\n\n    @Override\n    public void visitStyle(UnaryOperator<Style> style) {\n        this.textBuilder.pushStyle(style);\n    }\n\n    @Override\n    public void visitStyleEnd() {\n        this.textBuilder.popStyle();\n    }\n\n    @Override", "    public void visitStyleEnd() {\n        this.textBuilder.popStyle();\n    }\n\n    @Override\n    public void visitBlockQuote() {\n        this.textBuilder.pushStyle(style -> style.withFormatting(Formatting.GRAY));\n\n        var quotation = Containers.verticalFlow(Sizing.content(), Sizing.content());\n        quotation.padding(Insets.of(5, 5, 7, 5)).surface((context, component) -> {\n            context.fill(component.x(), component.y() + 3, component.x() + 2, component.y() + component.height() - 3, 0xFF777777);\n        });\n\n        this.push(quotation);\n    }\n\n    @Override", "    public void visitBlockQuoteEnd() {\n        this.textBuilder.popStyle();\n        this.pop();\n    }\n\n    @Override\n    public void visitHorizontalRule() {\n        this.append(new BoxComponent(Sizing.fill(100), Sizing.fixed(2)).color(Color.ofRgb(0x777777)).fill(true));\n    }\n\n    @Override", "    public void visitImage(Identifier image, String description, boolean fit) {\n        if (fit) {\n            this.append(Containers.stack(Sizing.fill(100), Sizing.content())\n                    .child(Components.texture(image, 0, 0, 256, 256, 256, 256).blend(true).tooltip(Text.literal(description)).sizing(Sizing.fixed(100)))\n                    .horizontalAlignment(HorizontalAlignment.CENTER));\n        } else {\n            var textureSize = TextureSizeLookup.sizeOf(image);\n            if (textureSize == null) textureSize = new TextureSizeLookup.Size(64, 64);\n\n            this.append(Components.texture(image, 0, 0, textureSize.width(), textureSize.height(), textureSize.width(), textureSize.height()).blend(true).tooltip(Text.literal(description)));\n        }\n    }\n\n    @Override", "    public void visitListItem(OptionalInt ordinal) {\n        var element = Containers.horizontalFlow(Sizing.content(), Sizing.content());\n        element.child(this.makeLabel(Text.literal(ordinal.isPresent() ? \" \" + ordinal.getAsInt() + \". \" : \" \u2022 \").formatted(Formatting.GRAY)).margins(Insets.left(-11))).margins(Insets.vertical(1));\n        element.padding(Insets.left(11)).allowOverflow(true);\n\n        var container = Containers.verticalFlow(Sizing.content(), Sizing.content());\n        element.child(container);\n\n        this.push(element, container);\n    }\n\n    @Override", "    public void visitListItemEnd() {\n        this.pop();\n    }\n\n    /**\n     * Append {@code component} to this compiler's result\n     */\n    public void visitComponent(Component component) {\n        this.append(component);\n    }\n\n    protected void append(Component component) {\n        this.flushText();\n        this.components.peek().child(component);\n    }\n\n    protected void push(FlowLayout component) {\n        this.push(component, component);\n    }\n\n    protected void push(Component element, FlowLayout contentPanel) {\n        this.append(element);\n        this.components.push(contentPanel);\n    }\n\n    protected void pop() {\n        this.flushText();\n        this.components.pop();\n    }\n\n    protected LabelComponent makeLabel(MutableText text) {\n        return Components.label(text);\n    }\n\n    protected void flushText() {", "        if (this.textBuilder.empty()) return;\n        this.components.peek().child(this.makeLabel(this.textBuilder.build()).horizontalSizing(Sizing.fill(100)));\n    }\n\n    @Override\n    public ParentComponent compile() {\n        this.flushText();\n        return this.components.getLast();\n    }\n\n    @Override", "    public String name() {\n        return \"lavender_builtin_owo_ui\";\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/mixin/TextureUtilMixin.java", "chunked_list": ["package io.wispforest.lavendermd.mixin;\n\nimport com.mojang.blaze3d.platform.TextureUtil;\nimport io.wispforest.lavendermd.util.TextureSizeLookup;\nimport net.minecraft.client.texture.NativeImage;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(TextureUtil.class)\npublic class TextureUtilMixin {\n\n    @Inject(method = \"prepareImage(Lnet/minecraft/client/texture/NativeImage$InternalFormat;IIII)V\", at = @At(value = \"INVOKE\", target = \"Lcom/mojang/blaze3d/platform/TextureUtil;bind(I)V\"))\n    private static void captureTextureSize(NativeImage.InternalFormat internalFormat, int id, int maxLevel, int width, int height, CallbackInfo ci) {\n        TextureSizeLookup._registerTextureSize(id, width, height);\n    }\n\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/feature/ItemStackFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport com.mojang.brigadier.StringReader;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.owo.ui.component.Components;", "import io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.owo.ui.component.Components;\nimport net.minecraft.command.argument.ItemStringReader;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.registry.Registries;\n\npublic class ItemStackFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"item_stacks\";\n    }\n\n    @Override", "    public String name() {\n        return \"item_stacks\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return compiler instanceof OwoUICompiler;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            if (!nibbler.tryConsume(\"<item;\")) return false;\n\n            var itemStackString = nibbler.consumeUntil('>');\n            if (itemStackString == null) return false;\n\n            try {\n                var result = ItemStringReader.item(Registries.ITEM.getReadOnlyWrapper(), new StringReader(itemStackString));\n\n                var stack = result.item().value().getDefaultStack();\n                stack.setNbt(result.nbt());\n\n                tokens.add(new ItemStackToken(itemStackString, stack));\n                return true;\n            } catch (CommandSyntaxException e) {\n                return false;\n            }\n        }, '<');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, stackToken, tokens) -> new ItemStackNode(stackToken.stack),\n                (token, tokens) -> token instanceof ItemStackToken itemStack ? itemStack : null\n        );\n    }\n\n    private static class ItemStackToken extends Lexer.Token {\n\n        public final ItemStack stack;\n\n        public ItemStackToken(String content, ItemStack stack) {\n            super(content);\n            this.stack = stack;\n        }\n    }\n\n    private static class ItemStackNode extends Parser.Node {\n\n        private final ItemStack stack;\n\n        public ItemStackNode(ItemStack stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            ((OwoUICompiler) compiler).visitComponent(Components.item(this.stack).setTooltipFromStack(true));\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n", "        public final ItemStack stack;\n\n        public ItemStackToken(String content, ItemStack stack) {\n            super(content);\n            this.stack = stack;\n        }\n    }\n\n    private static class ItemStackNode extends Parser.Node {\n\n        private final ItemStack stack;\n\n        public ItemStackNode(ItemStack stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            ((OwoUICompiler) compiler).visitComponent(Components.item(this.stack).setTooltipFromStack(true));\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/feature/OwoUITemplateFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport com.mojang.logging.LogUtils;\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.lavendermd.util.StringNibbler;\nimport io.wispforest.owo.ui.component.Components;", "import io.wispforest.lavendermd.util.StringNibbler;\nimport io.wispforest.owo.ui.component.Components;\nimport io.wispforest.owo.ui.container.Containers;\nimport io.wispforest.owo.ui.core.Component;\nimport io.wispforest.owo.ui.core.Insets;\nimport io.wispforest.owo.ui.core.Sizing;\nimport io.wispforest.owo.ui.core.Surface;\nimport io.wispforest.owo.ui.parsing.IncompatibleUIModelException;\nimport io.wispforest.owo.ui.parsing.UIModelLoader;\nimport io.wispforest.owo.ui.parsing.UIModelParsingException;", "import io.wispforest.owo.ui.parsing.UIModelLoader;\nimport io.wispforest.owo.ui.parsing.UIModelParsingException;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Identifier;\nimport org.slf4j.Logger;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class OwoUITemplateFeature implements MarkdownFeature {\n\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    private final TemplateProvider templateSource;\n\n    public OwoUITemplateFeature(TemplateProvider templateProvider) {\n        this.templateSource = templateProvider;\n    }\n\n    public OwoUITemplateFeature() {\n        this(new TemplateProvider() {\n            @Override\n            public <C extends Component> C template(Identifier model, Class<C> expectedClass, String templateName, Map<String, String> templateParams) {\n                var uiModel = UIModelLoader.get(model);", "\npublic class OwoUITemplateFeature implements MarkdownFeature {\n\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    private final TemplateProvider templateSource;\n\n    public OwoUITemplateFeature(TemplateProvider templateProvider) {\n        this.templateSource = templateProvider;\n    }\n\n    public OwoUITemplateFeature() {\n        this(new TemplateProvider() {\n            @Override\n            public <C extends Component> C template(Identifier model, Class<C> expectedClass, String templateName, Map<String, String> templateParams) {\n                var uiModel = UIModelLoader.get(model);", "                if (uiModel == null) {\n                    throw new UIModelParsingException(\"No UI model with id '\" + model + \" is currently loaded\");\n                }\n\n                return uiModel.expandTemplate(expectedClass, templateName, templateParams);\n            }\n        });\n    }\n\n    @Override\n    public String name() {\n        return \"owo_ui_templates\";\n    }\n\n    @Override", "    public String name() {\n        return \"owo_ui_templates\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return compiler instanceof OwoUICompiler;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            if (!nibbler.tryConsume('|')) return false;\n\n            var templateLocation = nibbler.consumeUntil('|');\n            if (templateLocation == null) return false;\n\n            var splitLocation = templateLocation.split(\"@\");\n            if (splitLocation.length != 2) return false;\n\n            var modelId = Identifier.tryParse(splitLocation[1]);", "            if (splitLocation.length != 2) return false;\n\n            var modelId = Identifier.tryParse(splitLocation[1]);\n            if (modelId == null || !UIModelLoader.allLoadedModels().contains(modelId)) return false;\n\n            String templateParams = \"\";\n            if (!nibbler.tryConsume('>')) {\n                templateParams = nibbler.consumeUntil('|');\n                if (templateParams == null || !nibbler.tryConsume('>')) return false;\n            } else {\n                nibbler.skip();\n            }\n\n            tokens.add(new TemplateToken(modelId, splitLocation[0], templateParams));\n            return true;\n        }, '<');\n    }\n\n    @Override", "                if (templateParams == null || !nibbler.tryConsume('>')) return false;\n            } else {\n                nibbler.skip();\n            }\n\n            tokens.add(new TemplateToken(modelId, splitLocation[0], templateParams));\n            return true;\n        }, '<');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, templateToken, tokens) -> new TemplateNode(templateToken.modelId, templateToken.templateName, templateToken.params),\n                (token, tokens) -> token instanceof TemplateToken template ? template : null\n        );\n    }\n\n    private static class TemplateToken extends Lexer.Token {\n\n        public final Identifier modelId;\n        public final String templateName;", "        public final Identifier modelId;\n        public final String templateName;\n        public final String params;\n\n        public TemplateToken(Identifier modelId, String templateName, String params) {\n            super(\"<|\" + modelId + \"|\" + params + \"|>\");\n            this.modelId = modelId;\n            this.templateName = templateName;\n            this.params = params;\n        }\n\n        @Override", "        public boolean isBoundary() {\n            return true;\n        }\n    }\n\n    private class TemplateNode extends Parser.Node {\n\n        private final Identifier modelId;\n        private final String templateName;\n        private final String params;\n\n        public TemplateNode(Identifier modelId, String templateName, String params) {\n            this.modelId = modelId;\n            this.templateName = templateName;\n            this.params = params;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {", "            try {\n                var paramReader = new StringNibbler(params);\n                var builtParams = new HashMap<String, String>();\n\n                while (paramReader.hasNext()) {\n                    var paramName = paramReader.consumeUntil('=');\n                    var paramValue = paramReader.consumeEscapedString(',', true);\n                    paramReader.skip();\n\n                    builtParams.put(paramName, paramValue);\n                }\n\n                ((OwoUICompiler) compiler).visitComponent(OwoUITemplateFeature.this.templateSource.template(modelId, Component.class, this.templateName, builtParams));\n            } catch (UIModelParsingException | IncompatibleUIModelException e) {\n                LOGGER.warn(\"Failed to build owo-ui template markdown element\", e);\n                ((OwoUICompiler) compiler).visitComponent(\n                        Containers.verticalFlow(Sizing.fill(100), Sizing.content())\n                                .child(Components.label(Text.literal(e.getMessage())).horizontalSizing(Sizing.fill(100)))\n                                .padding(Insets.of(10))\n                                .surface(Surface.flat(0x77A00000).and(Surface.outline(0x77FF0000)))\n                );\n            }\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n\n    @FunctionalInterface", "    public interface TemplateProvider {\n        <C extends Component> C template(Identifier model, Class<C> expectedClass, String templateName, Map<String, String> templateParams);\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/feature/BlockStateFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.owo.ui.component.Components;\nimport io.wispforest.owo.ui.container.Containers;", "import io.wispforest.owo.ui.component.Components;\nimport io.wispforest.owo.ui.container.Containers;\nimport io.wispforest.owo.ui.core.HorizontalAlignment;\nimport io.wispforest.owo.ui.core.Sizing;\nimport net.minecraft.command.argument.BlockArgumentParser;\nimport net.minecraft.registry.Registries;\n\npublic class BlockStateFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"block_states\";\n    }\n\n    @Override", "    public String name() {\n        return \"block_states\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return compiler instanceof OwoUICompiler;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            if (!nibbler.tryConsume(\"<block;\")) return false;\n\n            var blockStateString = nibbler.consumeUntil('>');\n            if (blockStateString == null) return false;\n\n            try {\n                tokens.add(new BlockStateToken(\n                        blockStateString,\n                        BlockArgumentParser.block(Registries.BLOCK.getReadOnlyWrapper(), blockStateString, true)\n                ));\n                return true;\n            } catch (CommandSyntaxException e) {\n                return false;\n            }\n        }, '<');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, stateToken, tokens) -> new BlockStateNode(stateToken.state),\n                (token, tokens) -> token instanceof BlockStateToken blockState ? blockState : null\n        );\n    }\n\n    private static class BlockStateToken extends Lexer.Token {\n\n        public final BlockArgumentParser.BlockResult state;\n\n        public BlockStateToken(String content, BlockArgumentParser.BlockResult state) {\n            super(content);\n            this.state = state;\n        }\n    }\n\n    private static class BlockStateNode extends Parser.Node {\n\n        private final BlockArgumentParser.BlockResult state;\n\n        public BlockStateNode(BlockArgumentParser.BlockResult state) {\n            this.state = state;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            ((OwoUICompiler) compiler).visitComponent(\n                    Containers.stack(Sizing.fill(100), Sizing.content())\n                            .child(Components.block(this.state.blockState(), this.state.nbt()).sizing(Sizing.fixed(48)))\n                            .horizontalAlignment(HorizontalAlignment.CENTER)\n            );\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n", "        public final BlockArgumentParser.BlockResult state;\n\n        public BlockStateToken(String content, BlockArgumentParser.BlockResult state) {\n            super(content);\n            this.state = state;\n        }\n    }\n\n    private static class BlockStateNode extends Parser.Node {\n\n        private final BlockArgumentParser.BlockResult state;\n\n        public BlockStateNode(BlockArgumentParser.BlockResult state) {\n            this.state = state;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            ((OwoUICompiler) compiler).visitComponent(\n                    Containers.stack(Sizing.fill(100), Sizing.content())\n                            .child(Components.block(this.state.blockState(), this.state.nbt()).sizing(Sizing.fixed(48)))\n                            .horizontalAlignment(HorizontalAlignment.CENTER)\n            );\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/main/java/io/wispforest/lavendermd/feature/EntityFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport com.mojang.brigadier.StringReader;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.owo.ui.component.Components;", "import io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.owo.ui.component.Components;\nimport io.wispforest.owo.ui.core.Sizing;\nimport net.minecraft.entity.EntityType;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.nbt.StringNbtReader;\nimport net.minecraft.registry.Registries;\nimport net.minecraft.util.Identifier;\nimport org.jetbrains.annotations.Nullable;\n\npublic class EntityFeature implements MarkdownFeature {\n\n    @Override", "import org.jetbrains.annotations.Nullable;\n\npublic class EntityFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"entities\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return compiler instanceof OwoUICompiler;\n    }\n\n    @Override", "    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return compiler instanceof OwoUICompiler;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            if (!nibbler.tryConsume(\"<entity;\")) return false;\n\n            var entityString = nibbler.consumeUntil('>');\n            if (entityString == null) return false;\n", "            if (entityString == null) return false;\n\n            try {\n                NbtCompound nbt = null;\n\n                int nbtIndex = entityString.indexOf('{');\n                if (nbtIndex != -1) {\n\n                    nbt = new StringNbtReader(new StringReader(entityString.substring(nbtIndex))).parseCompound();\n                    entityString = entityString.substring(0, nbtIndex);\n                }\n\n                var entityType = Registries.ENTITY_TYPE.getOrEmpty(new Identifier(entityString)).orElseThrow();\n                tokens.add(new EntityToken(entityString, entityType, nbt));\n                return true;\n            } catch (CommandSyntaxException e) {\n                return false;\n            }\n        }, '<');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, entityToken, tokens) -> new EntityNode(entityToken.type, entityToken.nbt),\n                (token, tokens) -> token instanceof EntityToken entity ? entity : null\n        );\n    }\n\n    private static class EntityToken extends Lexer.Token {\n\n        public final EntityType<?> type;\n        public final @Nullable NbtCompound nbt;\n\n        public EntityToken(String content, EntityType<?> type, @Nullable NbtCompound nbt) {\n            super(content);\n            this.type = type;\n            this.nbt = nbt;\n        }\n    }\n\n    private static class EntityNode extends Parser.Node {\n", "        public final EntityType<?> type;\n        public final @Nullable NbtCompound nbt;\n\n        public EntityToken(String content, EntityType<?> type, @Nullable NbtCompound nbt) {\n            super(content);\n            this.type = type;\n            this.nbt = nbt;\n        }\n    }\n\n    private static class EntityNode extends Parser.Node {\n", "        public final EntityType<?> type;\n        public final @Nullable NbtCompound nbt;\n\n        public EntityNode(EntityType<?> type, @Nullable NbtCompound nbt) {\n            this.type = type;\n            this.nbt = nbt;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            ((OwoUICompiler) compiler).visitComponent(Components.entity(Sizing.fixed(32), this.type, this.nbt).scaleToFit(true));\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/testmod/java/io/wispforest/lavendermdtest/EditMdScreen.java", "chunked_list": ["package io.wispforest.lavendermdtest;\n\nimport io.wispforest.lavendermd.MarkdownProcessor;\nimport io.wispforest.lavendermd.compiler.OwoUICompiler;\nimport io.wispforest.lavendermd.feature.BlockStateFeature;\nimport io.wispforest.lavendermd.feature.EntityFeature;\nimport io.wispforest.lavendermd.feature.ItemStackFeature;\nimport io.wispforest.lavendermd.feature.OwoUITemplateFeature;\nimport io.wispforest.lavendermd.feature.ImageFeature;\nimport io.wispforest.owo.ui.base.BaseUIModelScreen;", "import io.wispforest.lavendermd.feature.ImageFeature;\nimport io.wispforest.owo.ui.base.BaseUIModelScreen;\nimport io.wispforest.owo.ui.component.LabelComponent;\nimport io.wispforest.owo.ui.component.TextAreaComponent;\nimport io.wispforest.owo.ui.container.FlowLayout;\nimport io.wispforest.owo.ui.util.CommandOpenedScreen;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Identifier;\n\nimport java.io.PrintWriter;", "\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\npublic class EditMdScreen extends BaseUIModelScreen<FlowLayout> implements CommandOpenedScreen {\n\n    public EditMdScreen() {\n        super(FlowLayout.class, new Identifier(\"lavender-md-test\", \"edit-md\"));\n    }\n\n    @Override\n    protected void build(FlowLayout rootComponent) {\n        var output = rootComponent.childById(LabelComponent.class, \"output\");\n\n        var anchor = rootComponent.childById(FlowLayout.class, \"output-anchor\");\n        rootComponent.childById(TextAreaComponent.class, \"input\").onChanged().subscribe(value -> {", "            try {\n                anchor.<FlowLayout>configure(layout -> {\n                    var processor = MarkdownProcessor.richText(0).copyWith(OwoUICompiler::new).copyWith(new ImageFeature(), new BlockStateFeature(), new ItemStackFeature(), new EntityFeature(), new OwoUITemplateFeature());\n\n                    layout.clearChildren();\n                    layout.child(processor.process(value));\n                });\n\n                output.text(MarkdownProcessor.richText(40).process(value));\n            } catch (Exception e) {\n                var trace = new StringWriter();\n                var traceWriter = new PrintWriter(trace);\n                e.printStackTrace(traceWriter);\n\n                output.text(Text.literal(trace.toString()));\n            }\n        });\n    }\n}\n"]}
{"filename": "owo-ui-extension/src/testmod/java/io/wispforest/lavendermdtest/LavenderMdTest.java", "chunked_list": ["package io.wispforest.lavendermdtest;\n\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport io.wispforest.lavendermd.MarkdownProcessor;\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.fabric.api.client.command.v2.ClientCommandRegistrationCallback;\nimport net.minecraft.client.MinecraftClient;\n\nimport static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.argument;\nimport static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.literal;", "import static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.argument;\nimport static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.literal;\n\npublic class LavenderMdTest implements ClientModInitializer {\n    @Override\n    public void onInitializeClient() {\n        ClientCommandRegistrationCallback.EVENT.register((dispatcher, registryAccess) -> {\n            dispatcher.register(literal(\"parse-md\").then(argument(\"md\", StringArgumentType.greedyString()).executes(context -> {\n                context.getSource().sendFeedback(MarkdownProcessor.text().process(StringArgumentType.getString(context, \"md\")));\n                return 0;\n            })));\n\n            dispatcher.register(literal(\"edit-md\").executes(context -> {\n                MinecraftClient.getInstance().setScreen(new EditMdScreen());\n                return 0;\n            }));\n        });\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/MarkdownFeature.java", "chunked_list": ["package io.wispforest.lavendermd;\n\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.util.ListNibbler;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.function.BiFunction;\n\n/**\n * A Markdown feature implements a set of tokens and AST nodes", "/**\n * A Markdown feature implements a set of tokens and AST nodes\n * for parsing & generating certain Markdown syntax\n */\npublic interface MarkdownFeature {\n\n    /**\n     * @return A name for this feature, to be used in logging messages\n     */\n    String name();\n\n    /**\n     * Return {@code true} if this feature knows how to invoke {@code compiler}.\n     * <p>\n     * All nodes created by this feature must assume that the compiler they are\n     * invoked on has passed the check in this method. Notably - if this method does\n     * a type-check, all compilers used on this feature's nodes are guaranteed\n     * to be of said type\n     */\n    boolean supportsCompiler(MarkdownCompiler<?> compiler);\n\n    /**\n     * Add this feature's set of tokens to {@code registrar}\n     */\n    void registerTokens(TokenRegistrar registrar);\n\n    /**\n     * Add this feature's set of nodes to {@code registrar}\n     */\n    void registerNodes(NodeRegistrar registrar);\n\n    @FunctionalInterface\n    interface TokenRegistrar {\n        /**\n         * Register {@code lexer} to be invoked when {@code trigger}\n         * is encountered while lexing the Markdown input\n         */\n        void registerToken(Lexer.LexFunction lexer, char trigger);\n\n        /**\n         * Register {@code lexer} to be invoked when any of\n         * {@code triggers} is encountered while lexing the Markdown input\n         */\n        default void registerToken(Lexer.LexFunction lexer, char... triggers) {", "            for (char trigger : triggers) {\n                this.registerToken(lexer, trigger);\n            }\n        }\n    }\n\n    @FunctionalInterface\n    interface NodeRegistrar {\n        /**\n         * Register {@code parser} to be invoked when {@code trigger} matches and\n         * returns a token of type {@code T} from the incoming stream\n         */\n        <T extends Lexer.Token> void registerNode(Parser.ParseFunction<T> parser, BiFunction<Lexer.Token, ListNibbler<Lexer.Token>, @Nullable T> trigger);\n    }\n\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/Lexer.java", "chunked_list": ["package io.wispforest.lavendermd;\n\nimport io.wispforest.lavendermd.util.StringNibbler;\nimport it.unimi.dsi.fastutil.chars.Char2ObjectLinkedOpenHashMap;\nimport it.unimi.dsi.fastutil.chars.Char2ObjectMap;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Supplier;\n\npublic class Lexer implements MarkdownFeature.TokenRegistrar {\n\n    private final Char2ObjectMap<List<LexFunction>> lexFunctions = new Char2ObjectLinkedOpenHashMap<>();\n\n    public Lexer() {\n        // newlines\n        this.registerToken((nibbler, tokens) -> {\n            var newlines = nibbler.consumeUntilEndOr(c -> c != '\\n');", "import java.util.function.Supplier;\n\npublic class Lexer implements MarkdownFeature.TokenRegistrar {\n\n    private final Char2ObjectMap<List<LexFunction>> lexFunctions = new Char2ObjectLinkedOpenHashMap<>();\n\n    public Lexer() {\n        // newlines\n        this.registerToken((nibbler, tokens) -> {\n            var newlines = nibbler.consumeUntilEndOr(c -> c != '\\n');\n            if (newlines.length() > 1) {\n                tokens.add(new NewlineToken(\"\\n\".repeat(newlines.length() - 1), true));\n            } else {\n                tokens.add(new NewlineToken(\" \", false));\n            }\n\n            return true;\n        }, '\\n');\n\n        // token escapes\n        this.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            var escaped = nibbler.next();", "            if (newlines.length() > 1) {\n                tokens.add(new NewlineToken(\"\\n\".repeat(newlines.length() - 1), true));\n            } else {\n                tokens.add(new NewlineToken(\" \", false));\n            }\n\n            return true;\n        }, '\\n');\n\n        // token escapes\n        this.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            var escaped = nibbler.next();", "            if (escaped == null || !this.lexFunctions.containsKey(escaped.charValue())) return false;\n\n            if (escaped == '\\n') {\n                tokens.add(new NewlineToken(\"\\n\", false));\n            } else {\n                appendText(tokens, escaped);\n            }\n\n            return true;\n        }, '\\\\');\n    }\n\n    @Override", "    public void registerToken(LexFunction lexer, char trigger) {\n        this.lexFunctions.computeIfAbsent(trigger, character -> new ArrayList<>()).add(0, lexer);\n    }\n\n    /**\n     * A lex-function is responsible for consuming a string of characters\n     * in {@code nibbler} and appending the corresponding token(s) to {@code tokens}\n     */\n    @FunctionalInterface\n    public interface LexFunction {\n        boolean lex(StringNibbler nibbler, List<Token> tokens);\n    }\n\n    public List<Token> lex(String input) {\n        var tokens = new ArrayList<Token>();\n        var nibbler = new StringNibbler(input.strip());\n", "    public interface LexFunction {\n        boolean lex(StringNibbler nibbler, List<Token> tokens);\n    }\n\n    public List<Token> lex(String input) {\n        var tokens = new ArrayList<Token>();\n        var nibbler = new StringNibbler(input.strip());\n\n        while (nibbler.hasNext()) {\n            char current = nibbler.peek();\n            if (this.lexFunctions.containsKey(current)) {\n\n                boolean matched = false;", "        while (nibbler.hasNext()) {\n            char current = nibbler.peek();\n            if (this.lexFunctions.containsKey(current)) {\n\n                boolean matched = false;\n                for (var function : this.lexFunctions.get(current)) {\n                    if (!nibbler.tryMatch($ -> function.lex(nibbler, tokens))) continue;\n\n                    matched = true;\n                    break;\n                }\n", "                if (!matched) {\n                    nibbler.skip();\n                    appendText(tokens, String.valueOf(current));\n                }\n            } else {\n                appendText(tokens, nibbler.consumeUntilEndOr(this.lexFunctions.keySet()::contains));\n            }\n        }\n\n        return tokens;\n    }\n\n    private static void appendText(List<Token> tokens, String text) {", "        if (!tokens.isEmpty() && tokens.get(tokens.size() - 1) instanceof TextToken textToken) {\n            textToken.append(text);\n        } else {\n            tokens.add(new TextToken(text));\n        }\n    }\n\n    private static void appendText(List<Token> tokens, char text) {\n        if (!tokens.isEmpty() && tokens.get(tokens.size() - 1) instanceof TextToken textToken) {\n            textToken.append(text);\n        } else {\n            tokens.add(new TextToken(String.valueOf(text)));\n        }\n    }\n\n    // --- basic tokens required for simple text lexing ---\n", "        if (!tokens.isEmpty() && tokens.get(tokens.size() - 1) instanceof TextToken textToken) {\n            textToken.append(text);\n        } else {\n            tokens.add(new TextToken(String.valueOf(text)));\n        }\n    }\n\n    // --- basic tokens required for simple text lexing ---\n\n    public abstract static class Token {\n        protected final String content;\n\n        protected Token(String content) {\n            this.content = content;\n        }\n", "    public abstract static class Token {\n        protected final String content;\n\n        protected Token(String content) {\n            this.content = content;\n        }\n\n        public String content() {\n            return this.content;\n        }\n", "        public boolean isBoundary() {\n            return false;\n        }\n\n        public static LexFunction lexFromChar(Supplier<Token> factory) {\n            return (nibbler, tokens) -> {\n                nibbler.skip();\n                tokens.add(factory.get());\n\n                return true;\n            };\n        }\n    }\n", "    public static final class TextToken extends Token {\n\n        private final StringBuilder contentBuilder;\n\n        private String contentCache = \"\";\n        private boolean dirty = true;\n\n        public TextToken(String content) {\n            super(\"\");\n            this.contentBuilder = new StringBuilder(content);\n        }\n", "        public void append(String content) {\n            this.contentBuilder.append(content);\n            this.dirty = true;\n        }\n\n        public void append(char content) {\n            this.contentBuilder.append(content);\n            this.dirty = true;\n        }\n\n        @Override", "        public String content() {\n            if (this.dirty) {\n                this.contentCache = this.contentBuilder.toString();\n                this.dirty = false;\n            }\n\n            return this.contentCache;\n        }\n    }\n\n    public static final class NewlineToken extends Token {\n\n        private final boolean isBoundary;\n\n        public NewlineToken(String content, boolean isBoundary) {\n            super(content);\n            this.isBoundary = isBoundary;\n        }\n\n        @Override", "    public static final class NewlineToken extends Token {\n\n        private final boolean isBoundary;\n\n        public NewlineToken(String content, boolean isBoundary) {\n            super(content);\n            this.isBoundary = isBoundary;\n        }\n\n        @Override\n        public boolean isBoundary() {\n            return this.isBoundary;\n        }\n    }\n}\n", "        public boolean isBoundary() {\n            return this.isBoundary;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/MarkdownProcessor.java", "chunked_list": ["package io.wispforest.lavendermd;\n\nimport com.google.common.collect.ImmutableList;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.compiler.TextCompiler;\nimport io.wispforest.lavendermd.feature.*;\nimport net.minecraft.text.Text;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;", "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.function.Supplier;\n\n/**\n * A Markdown-processor models the pipeline required to lex, parse and compile\n * some Markdown input into a result of type {@code R}. For this purpose, it employs\n * a set of {@link MarkdownFeature}s installed into a {@link Lexer} and {@link Parser},", " * some Markdown input into a result of type {@code R}. For this purpose, it employs\n * a set of {@link MarkdownFeature}s installed into a {@link Lexer} and {@link Parser},\n * the resulting AST of which it compiles using a {@link MarkdownCompiler}.\n * <p>\n * To create a processor, either use one of the default factories and optionally customize\n * them using the provided copyWith functions, or invoke the constructor and supply\n * the desired compiler factory and feature-set\n */\npublic class MarkdownProcessor<R> {\n\n    private final Supplier<MarkdownCompiler<R>> compilerFactory;\n\n    private final List<MarkdownFeature> features;\n\n    private final Lexer lexer;\n    private final Parser parser;\n\n    public MarkdownProcessor(Supplier<MarkdownCompiler<R>> compilerFactory, MarkdownFeature... features) {\n        this(compilerFactory, Arrays.asList(features));\n    }\n\n    public MarkdownProcessor(Supplier<MarkdownCompiler<R>> compilerFactory, List<MarkdownFeature> features) {\n        this.compilerFactory = compilerFactory;\n        this.features = ImmutableList.copyOf(features);\n\n        var testCompiler = this.compilerFactory.get();", "public class MarkdownProcessor<R> {\n\n    private final Supplier<MarkdownCompiler<R>> compilerFactory;\n\n    private final List<MarkdownFeature> features;\n\n    private final Lexer lexer;\n    private final Parser parser;\n\n    public MarkdownProcessor(Supplier<MarkdownCompiler<R>> compilerFactory, MarkdownFeature... features) {\n        this(compilerFactory, Arrays.asList(features));\n    }\n\n    public MarkdownProcessor(Supplier<MarkdownCompiler<R>> compilerFactory, List<MarkdownFeature> features) {\n        this.compilerFactory = compilerFactory;\n        this.features = ImmutableList.copyOf(features);\n\n        var testCompiler = this.compilerFactory.get();", "        for (var feature : this.features) {\n            if (!feature.supportsCompiler(testCompiler)) {\n                throw new IllegalStateException(\"Feature '\" + feature.name() + \"' is incompatible with compiler '\" + testCompiler.name() + \"'\");\n            }\n        }\n\n        this.lexer = new Lexer();\n        this.parser = new Parser();\n\n        for (var extension : features) {\n            extension.registerTokens(this.lexer);\n            extension.registerNodes(this.parser);\n        }\n    }\n\n    public Collection<MarkdownFeature> installedFeatures() {\n        return this.features;\n    }\n", "        for (var extension : features) {\n            extension.registerTokens(this.lexer);\n            extension.registerNodes(this.parser);\n        }\n    }\n\n    public Collection<MarkdownFeature> installedFeatures() {\n        return this.features;\n    }\n\n    public boolean hasFeature(Class<?> featureClass) {", "    public boolean hasFeature(Class<?> featureClass) {\n        for (var extension : this.features) {\n            if (featureClass.isInstance(extension)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public R process(String markdown) {\n        var compiler = this.compilerFactory.get();\n\n        this.parser.parse(this.lexer.lex(markdown)).visit(compiler);\n        return compiler.compile();\n    }\n\n    // --- copy constructors ---\n\n    /**\n     * Create a copy of this processor with {@code features} added\n     * to the copy's feature-set\n     */\n    public MarkdownProcessor<R> copyWith(MarkdownFeature... features) {\n        var newFeatures = new ArrayList<>(this.features);", "    public R process(String markdown) {\n        var compiler = this.compilerFactory.get();\n\n        this.parser.parse(this.lexer.lex(markdown)).visit(compiler);\n        return compiler.compile();\n    }\n\n    // --- copy constructors ---\n\n    /**\n     * Create a copy of this processor with {@code features} added\n     * to the copy's feature-set\n     */\n    public MarkdownProcessor<R> copyWith(MarkdownFeature... features) {\n        var newFeatures = new ArrayList<>(this.features);", "        for (var feature : features) {\n            if (this.hasFeature(feature.getClass())) continue;\n            newFeatures.add(feature);\n        }\n\n        return new MarkdownProcessor<>(this.compilerFactory, newFeatures);\n    }\n\n    /**\n     * Create a copy of this processor with its compiler factory\n     * replaced by {@code compilerFactory}\n     */\n    public <R2> MarkdownProcessor<R2> copyWith(Supplier<MarkdownCompiler<R2>> compilerFactory) {\n        return new MarkdownProcessor<>(compilerFactory, this.features);\n    }\n\n    // --- default factories ---\n\n    /**\n     * Create a new Markdown-processor with support for basic text formatting, that is:\n     * <ul>\n     *     <li>Bold & Italic Emphasis</li>\n     *     <li>Discord-like underscore and strikethrough formatting</li>\n     *     <li>Colors using <pre>{&lt;color name&gt;|#RRGGBB}content here{}</pre> syntax</li>\n     * </ul>\n     */", "    public static MarkdownProcessor<Text> text() {\n        return new MarkdownProcessor<>(TextCompiler::new, new BasicFormattingFeature(false), new ColorFeature());\n    }\n\n    /**\n     * Create a new Markdown-processor with support for rich text formatting, that is:\n     * <ul>\n     *     <li>Bold & Italic Emphasis</li>\n     *     <li>Discord-like underscore and strikethrough formatting</li>\n     *     <li>Horizontal Rules</li>\n     *     <li>Colors using <pre>{&lt;color name&gt;|#RRGGBB}content here{}</pre> syntax</li>\n     *     <li>Hyperlinks</li>\n     *     <li>Ordered & unordered lists</li>\n     *     <li>Block quotes</li>\n     * </ul>\n     */", "    public static MarkdownProcessor<Text> richText(int assumedOutputWidth) {\n        return new MarkdownProcessor<>(() -> new TextCompiler(assumedOutputWidth), new BasicFormattingFeature(), new ColorFeature(), new LinkFeature(), new ListFeature(), new BlockQuoteFeature());\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/Parser.java", "chunked_list": ["package io.wispforest.lavendermd;\n\nimport io.wispforest.lavendermd.Lexer.NewlineToken;\nimport io.wispforest.lavendermd.Lexer.TextToken;\nimport io.wispforest.lavendermd.Lexer.Token;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.util.ListNibbler;\nimport net.minecraft.text.Style;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;", "import org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;", "import java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\npublic class Parser implements MarkdownFeature.NodeRegistrar {\n\n    private final Map<BiFunction<Token, ListNibbler<Token>, ?>, ParseFunction<?>> parseFunctions = new HashMap<>();\n\n    public Parser() {\n        this.registerNode((parser, text, tokens) -> {\n            var content = text.content();\n            if (tokens.peek(-2) == null || tokens.peek(-2) instanceof NewlineToken) {\n                content = content.stripLeading();\n            }\n", "            if (tokens.peek(-2) == null || tokens.peek(-2) instanceof NewlineToken) {\n                content = content.stripLeading();\n            }\n\n            if (tokens.peek() instanceof NewlineToken newline && !newline.isBoundary()) {\n                content = content.stripTrailing();\n            }\n\n            return new TextNode(content);\n        }, (token, tokens) -> token instanceof TextToken text ? text : null);\n    }\n\n    @Override\n    public <T extends Token> void registerNode(ParseFunction<T> parser, BiFunction<Token, ListNibbler<Token>, @Nullable T> trigger) {\n        this.parseFunctions.put(trigger, parser);\n    }\n\n    /**\n     * A parse-function is responsible for consuming a sequence of tokens\n     * from {@code tokens} and parsing child nodes using {@code parser}\n     * to generate the node indicated by the matched {@code trigger} token\n     *\n     * @param <T> The type of token this parse-function consumes\n     */\n    @FunctionalInterface", "    public interface ParseFunction<T extends Token> {\n        Node parse(Parser parser, T trigger, ListNibbler<Token> tokens);\n    }\n\n    public Node parse(List<Token> tokens) {\n        var tokenNibbler = new ListNibbler<>(tokens);\n\n        var node = Node.empty();\n        while (tokenNibbler.hasElements()) {\n            node.addChild(parseNode(tokenNibbler));\n        }\n\n        return node;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private @NotNull Node parseNode(ListNibbler<Token> tokens) {\n        var token = tokens.nibble();\n", "        while (tokenNibbler.hasElements()) {\n            node.addChild(parseNode(tokenNibbler));\n        }\n\n        return node;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private @NotNull Node parseNode(ListNibbler<Token> tokens) {\n        var token = tokens.nibble();\n", "        for (var function : this.parseFunctions.entrySet()) {\n            var first = function.getKey().apply(token, tokens);\n            if (first == null) continue;\n\n            return ((ParseFunction) function.getValue()).parse(this, token, tokens);\n        }\n\n        if (token != null) {\n            return new TextNode(token.content());\n        }\n\n        return Node.empty();\n    }\n", "    public Node parseUntil(ListNibbler<Token> tokens, Class<? extends Token> until) {\n        return this.parseUntil(tokens, token -> token.isBoundary() || until.isInstance(token), token -> false);\n    }\n\n    public Node parseUntil(ListNibbler<Token> tokens, Predicate<Token> until, Predicate<Token> skip) {\n        var node = this.parseNode(tokens);\n        while (tokens.hasElements()) {\n            var next = tokens.peek();\n\n            if (skip.test(next)) {\n                tokens.nibble();\n                continue;\n            }\n", "            if (skip.test(next)) {\n                tokens.nibble();\n                continue;\n            }\n\n            if (until.test(next)) break;\n\n            node.addChild(this.parseNode(tokens));\n        }\n\n        return node;\n    }\n", "    public abstract static class Node {\n\n        protected final List<Node> children = new ArrayList<>();\n\n        public Node addChild(Node child) {\n            this.children.add(child);\n            return this;\n        }\n\n        public void visit(MarkdownCompiler<?> compiler) {\n            this.visitStart(compiler);", "        public void visit(MarkdownCompiler<?> compiler) {\n            this.visitStart(compiler);\n            for (var child : this.children) {\n                child.visit(compiler);\n            }\n            this.visitEnd(compiler);\n        }\n\n        protected abstract void visitStart(MarkdownCompiler<?> compiler);\n\n        protected abstract void visitEnd(MarkdownCompiler<?> compiler);\n", "        public static Node empty() {\n            return new Node() {\n                @Override\n                protected void visitStart(MarkdownCompiler<?> compiler) {\n                }\n\n                @Override\n                protected void visitEnd(MarkdownCompiler<?> compiler) {\n                }\n            };\n        }\n    }\n", "    public static final class TextNode extends Node {\n        private final String content;\n\n        public TextNode(String content) {\n            this.content = content;\n        }\n\n        @Override\n        public void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitText(this.content);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n        }\n    }\n", "        public void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitText(this.content);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n        }\n    }\n\n    public static class FormattingNode extends Node {\n        private final UnaryOperator<Style> formatting;\n\n        public FormattingNode(UnaryOperator<Style> formatting) {\n            this.formatting = formatting;\n        }\n\n        @Override", "    public static class FormattingNode extends Node {\n        private final UnaryOperator<Style> formatting;\n\n        public FormattingNode(UnaryOperator<Style> formatting) {\n            this.formatting = formatting;\n        }\n\n        @Override\n        public void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitStyle(this::applyStyle);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitStyleEnd();\n        }\n\n        protected Style applyStyle(Style style) {\n            return this.formatting.apply(style);\n        }\n    }\n\n}\n", "        public void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitStyle(this::applyStyle);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitStyleEnd();\n        }\n\n        protected Style applyStyle(Style style) {\n            return this.formatting.apply(style);\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/util/TextBuilder.java", "chunked_list": ["package io.wispforest.lavendermd.util;\n\nimport net.minecraft.text.MutableText;\nimport net.minecraft.text.Style;\nimport net.minecraft.text.Text;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.function.UnaryOperator;\n", "import java.util.function.UnaryOperator;\n\n/**\n * A utility for building a Minecraft {@link Text} component\n * from a hierarchical style structure and text\n */\npublic class TextBuilder {\n\n    private final Deque<Style> styles;\n\n    private MutableText text = Text.empty();\n    private boolean empty = true;\n\n    public TextBuilder() {\n        this.styles = new ArrayDeque<>();\n        this.styles.push(Style.EMPTY);\n    }\n\n    /**\n     * Append {@code text} to this builder's result\n     */", "    public void append(MutableText text) {\n        this.text.append(text.styled(style -> style.withParent(this.styles.peek())));\n        this.empty = false;\n    }\n\n    /**\n     * Push {@code style} onto this builder's stack\n     */\n    public void pushStyle(UnaryOperator<Style> style) {\n        this.styles.push(style.apply(this.styles.peek()));\n    }\n\n    /**\n     * Pop the current style from this builder's stack\n     */", "    public void pushStyle(UnaryOperator<Style> style) {\n        this.styles.push(style.apply(this.styles.peek()));\n    }\n\n    /**\n     * Pop the current style from this builder's stack\n     */\n    public void popStyle() {\n        this.styles.pop();\n    }\n\n    /**\n     * Return this builder's current result and clear\n     * all internal state, ready to build a fresh text\n     */", "    public MutableText build() {\n        var result = this.text;\n        if (result.getString().equals(\"\\n\")) {\n            result = Text.literal(\" \");\n        }\n\n        this.text = Text.empty();\n        this.empty = true;\n\n        return result;\n    }\n\n    /**\n     * @return {@code true} if this builder is in an empty state - that is,\n     * either it is new or cleared by a call to {@link #build()}\n     */", "    public boolean empty() {\n        return this.empty;\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/util/ListNibbler.java", "chunked_list": ["package io.wispforest.lavendermd.util;\n\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/**\n * nom nom\n * <p>\n * Consumes a list element-by-element with\n * a client-mutable element pointer", " * Consumes a list element-by-element with\n * a client-mutable element pointer\n */\npublic class ListNibbler<T> {\n\n    private final List<T> delegate;\n    private int pointer = 0;\n\n    public ListNibbler(List<T> delegate) {\n        this.delegate = delegate;\n    }\n\n    /**\n     * @return The next element of this nibbler's underlying\n     * list, or {@code null} if the list is exhausted\n     */", "    public T nibble() {\n        return this.pointer < this.delegate.size()\n                ? this.delegate.get(this.pointer++)\n                : null;\n    }\n\n    /**\n     * Skip forward by {@code elements} in this nibbler's underlying list\n     */\n    public void skip(int elements) {\n        this.pointer += elements;", "    public void skip(int elements) {\n        this.pointer += elements;\n        if (this.pointer > this.delegate.size()) throw new NoSuchElementException();\n    }\n\n    /**\n     * Shorthand of {@link #peek(int)} with {@code 0} for {@code offset}\n     */\n    public T peek() {\n        return this.peek(0);\n    }\n\n    /**\n     * @return The element at this nibbler's element pointer + {@code offset},\n     * or {@code null} if that index is outside the nibbler's underlying list\n     */", "    public T peek() {\n        return this.peek(0);\n    }\n\n    /**\n     * @return The element at this nibbler's element pointer + {@code offset},\n     * or {@code null} if that index is outside the nibbler's underlying list\n     */\n    public T peek(int offset) {\n        int index = this.pointer + offset;\n        return index >= 0 && index < this.delegate.size()\n                ? this.delegate.get(index)\n                : null;\n    }\n\n    /**\n     * @return {@code true} if this nibbler has more elements to consume\n     */", "    public T peek(int offset) {\n        int index = this.pointer + offset;\n        return index >= 0 && index < this.delegate.size()\n                ? this.delegate.get(index)\n                : null;\n    }\n\n    /**\n     * @return {@code true} if this nibbler has more elements to consume\n     */\n    public boolean hasElements() {\n        return this.pointer < this.delegate.size();\n    }\n\n    /**\n     * @return The element pointer of this nibbler\n     */", "    public boolean hasElements() {\n        return this.pointer < this.delegate.size();\n    }\n\n    /**\n     * @return The element pointer of this nibbler\n     */\n    public int pointer() {\n        return this.pointer;\n    }\n\n    /**\n     * Set the element pointer of this nibbler\n     * to {@code pointer}, without any validation\n     */", "    public void setPointer(int pointer) {\n        this.pointer = pointer;\n    }\n\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/util/StringNibbler.java", "chunked_list": ["package io.wispforest.lavendermd.util;\n\nimport net.minecraft.util.function.CharPredicate;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.function.Predicate;\n\n/**\n * String-analog of {@link ListNibbler} with many added functions\n * for testing for and consuming individual characters or substrings", " * String-analog of {@link ListNibbler} with many added functions\n * for testing for and consuming individual characters or substrings\n * <p>\n * Very useful for lexing strings, essentially a more advanced version of\n * Brigadier's {@link com.mojang.brigadier.StringReader}\n */\npublic class StringNibbler {\n\n    public final String string;\n    private int cursor;\n\n    public StringNibbler(String string) {\n        this.string = string;\n    }\n", "    public final String string;\n    private int cursor;\n\n    public StringNibbler(String string) {\n        this.string = string;\n    }\n\n    public int cursor() {\n        return this.cursor;\n    }\n\n    /**\n     * @return The character at this nibbler's cursor\n     * in the underlying string\n     */", "    public char peek() {\n        return this.string.charAt(this.cursor);\n    }\n\n    /**\n     * Shorthand of {@link #skip(int)} with {@link 1} for {@code count}\n     */\n    public void skip() {\n        this.skip(1);\n    }\n\n    /**\n     * Skip {@code count} characters forward in this nibbler's\n     * underlying string\n     */", "    public void skip(int count) {\n        this.cursor += count;\n    }\n\n    /**\n     * Consume the character at this nibbler's cursor\n     * in the underlying string (or {@code null} if there are\n     * no more characters to consume\n     */\n    public @Nullable Character next() {\n        return this.cursor < this.string.length() ? this.string.charAt(this.cursor++) : null;\n    }\n\n    /**\n     * @return The substring of this nibbler's underlying string\n     * which has already been consumed\n     */", "    public String consumed() {\n        return this.string.substring(0, this.cursor);\n    }\n\n    /**\n     * @return {@code true} if this nibbler has more characters to consume\n     */\n    public boolean hasNext() {\n        return this.cursor < this.string.length();\n    }\n\n    /**\n     * @return The character at this nibbler's cursor + {@code offset}\n     * in the underlying string, or {@code null} if that index is out of range\n     */\n    public @Nullable Character peekOffset(int offset) {\n        int charIndex = this.cursor + offset;\n        return charIndex >= 0 && charIndex < this.string.length() ? this.string.charAt(charIndex) : null;\n    }\n\n    /**\n     * Consume a substring until {@code terminator}, skipping terminators escaped\n     * by a backslash ({@code \\}). If no {@code terminator} is found, return {@code null} if\n     * {@code allowUnterminated} is false, the consumed substring otherwise\n     */\n    public @Nullable String consumeEscapedString(char terminator, boolean allowUnterminated) {\n        var read = new StringBuilder();", "        while (this.hasNext()) {\n            char next = this.next();\n            if (next == '\\\\' && this.expect(0, terminator)) {\n                this.skip();\n                read.append(terminator);\n            } else if (next == terminator) {\n                return read.toString();\n            } else {\n                read.append(next);\n            }\n        }\n\n        return allowUnterminated ? read.toString() : null;\n    }\n\n    /**\n     * Shorthand of {@link #consumeUntil(char, boolean)} with {@code true} for {@code skipDelimiter}\n     */\n    public @Nullable String consumeUntil(char delimiter) {\n        return this.consumeUntil(delimiter, true);\n    }\n\n    /**\n     * Consume a substring until {@code delimiter}. If no {@code delimiter}\n     * is encountered, return {@code null}. If {@code skipDelimiter} is true, place\n     * the cursor on the character immediately following the delimiter\n     */\n    public @Nullable String consumeUntil(char delimiter, boolean skipDelimiter) {\n        var read = new StringBuilder();", "        if (this.tryMatch($ -> {\n            while (this.hasNext()) {\n                if (this.peek() == delimiter) {\n                    if (skipDelimiter) this.skip();\n                    return true;\n                }\n\n                read.append(this.next());\n            }\n\n            return false;\n        })) {\n            return read.toString();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Consume a substring up to but not including the first character\n     * matched by {@code until}. If no such character is encountered, return\n     * the entire rest of the underlying string\n     */", "    public String consumeUntilEndOr(CharPredicate until) {\n        var read = new StringBuilder();\n        while (this.hasNext() && !until.test(this.peek())) {\n            read.append(this.next());\n        }\n\n        return read.toString();\n    }\n\n    /**\n     * Return {@code true} if the character at this nibbler's\n     * cursor + {@code offset} is equal to {@code expect}. Return {@code false}\n     * if the character is not matched or that index is out of range\n     */", "    public boolean expect(int offset, char expect) {\n        int charIndex = this.cursor + offset;\n        return charIndex >= 0 && charIndex < this.string.length() && this.string.charAt(charIndex) == expect;\n    }\n\n    /**\n     * Return {@code true} and advance the cursor if the character at\n     * this nibbler's cursor if equal to {@code consume}\n     */\n    public boolean tryConsume(char consume) {\n        return tryMatch($ -> {\n            var next = next();\n            return next != null && next == consume;\n        });\n    }\n\n    /**\n     * Return {@code true} and consume if the substring {@code consume}\n     * is found to begin at this nibbler's cursor\n     */", "    public boolean tryConsume(char consume) {\n        return tryMatch($ -> {\n            var next = next();\n            return next != null && next == consume;\n        });\n    }\n\n    /**\n     * Return {@code true} and consume if the substring {@code consume}\n     * is found to begin at this nibbler's cursor\n     */", "    public boolean tryConsume(String consume) {\n        return this.tryMatch(stringNibbler -> {\n            for (int i = 0; i < consume.length(); i++) {\n                var next = this.next();\n                if (next == null || next != consume.charAt(i)) return false;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Return {@code true} if {@code matcher} returns {@code true} when invoked\n     * on this nibbler instance. Otherwise, return {@code false} and revert\n     * the nibbler's cursor to its position before calling {@code matcher}\n     */", "    public boolean tryMatch(Predicate<StringNibbler> matcher) {\n        int cursorPos = this.cursor;\n        if (!matcher.test(this)) {\n            this.cursor = cursorPos;\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/compiler/TextCompiler.java", "chunked_list": ["package io.wispforest.lavendermd.compiler;\n\nimport io.wispforest.lavendermd.util.TextBuilder;\nimport net.minecraft.text.MutableText;\nimport net.minecraft.text.Style;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\nimport net.minecraft.util.Identifier;\n\nimport java.util.OptionalInt;", "\nimport java.util.OptionalInt;\nimport java.util.function.UnaryOperator;\n\n/**\n * lavender-md's default compiler implementation which compiles to a\n * single Minecraft {@link Text} component - depending on the input\n * AST it might contain multiple lines\n */\npublic class TextCompiler implements MarkdownCompiler<Text> {\n\n    private final TextBuilder builder = new TextBuilder();\n    private final int assumedOutputWidth;\n\n    private int quoteDepth = 0;\n    private int listDepth = 0;\n\n    public TextCompiler() {\n        this(50);\n    }\n\n    public TextCompiler(int assumedOutputWidth) {\n        this.assumedOutputWidth = assumedOutputWidth;\n    }\n\n    @Override", " */\npublic class TextCompiler implements MarkdownCompiler<Text> {\n\n    private final TextBuilder builder = new TextBuilder();\n    private final int assumedOutputWidth;\n\n    private int quoteDepth = 0;\n    private int listDepth = 0;\n\n    public TextCompiler() {\n        this(50);\n    }\n\n    public TextCompiler(int assumedOutputWidth) {\n        this.assumedOutputWidth = assumedOutputWidth;\n    }\n\n    @Override", "    public void visitText(String text) {\n        if (this.quoteDepth != 0 && text.contains(\"\\n\")) {\n            if (text.equals(\"\\n\")) {\n                this.builder.append(this.quoteMarker());\n            } else {\n                for (var line : text.split(\"\\n\")) {\n                    this.builder.append(this.quoteMarker().append(Text.literal(line)));\n                }\n            }\n        } else if (this.listDepth != 0 && text.contains(\"\\n\")) {\n            if (text.equals(\"\\n\")) {\n                this.builder.append(Text.literal(\"\\n   \" + \"  \".repeat(this.listDepth - 1)));\n            } else {\n                var lines = text.split(\"\\n\");", "        } else if (this.listDepth != 0 && text.contains(\"\\n\")) {\n            if (text.equals(\"\\n\")) {\n                this.builder.append(Text.literal(\"\\n   \" + \"  \".repeat(this.listDepth - 1)));\n            } else {\n                var lines = text.split(\"\\n\");\n                for (int i = 0; i < lines.length; i++) {\n                    this.builder.append(Text.literal((i > 0 ? \"\\n   \" : \"   \") + \"  \".repeat(this.listDepth - 1)).append(Text.literal(lines[i])));\n                }\n            }\n        } else {\n            this.builder.append(Text.literal(text));\n        }\n    }\n\n    @Override", "    public void visitStyle(UnaryOperator<Style> style) {\n        this.builder.pushStyle(style);\n    }\n\n    @Override\n    public void visitStyleEnd() {\n        this.builder.popStyle();\n    }\n\n    @Override\n    public void visitBlockQuote() {\n        this.quoteDepth++;\n        this.builder.append(this.quoteMarker());\n        this.builder.pushStyle(style -> style.withColor(Formatting.GRAY).withItalic(true));\n    }\n\n    @Override", "    public void visitBlockQuote() {\n        this.quoteDepth++;\n        this.builder.append(this.quoteMarker());\n        this.builder.pushStyle(style -> style.withColor(Formatting.GRAY).withItalic(true));\n    }\n\n    @Override\n    public void visitBlockQuoteEnd() {\n        this.builder.popStyle();\n        this.quoteDepth--;\n", "        if (this.quoteDepth > 0) {\n            this.builder.append(this.quoteMarker());\n        } else {\n            this.builder.append(Text.literal(\"\\n\"));\n        }\n    }\n\n    private MutableText quoteMarker() {\n        return Text.literal(\"\\n >\" + \">\".repeat(this.quoteDepth) + \" \").formatted(Formatting.DARK_GRAY);\n    }\n\n    @Override", "    public void visitHorizontalRule() {\n        this.builder.append(Text.literal(\"-\".repeat(this.assumedOutputWidth)).formatted(Formatting.DARK_GRAY));\n    }\n\n    @Override\n    public void visitImage(Identifier image, String description, boolean fit) {\n        this.builder.append(Text.literal(\"[\" + description + \"]\").formatted(Formatting.YELLOW));\n    }\n\n    @Override\n    public void visitListItem(OptionalInt ordinal) {\n        var listPrefix = ordinal.isPresent() ? \" \" + ordinal.getAsInt() + \". \" : \" \u2022 \";\n", "    public void visitListItem(OptionalInt ordinal) {\n        var listPrefix = ordinal.isPresent() ? \" \" + ordinal.getAsInt() + \". \" : \" \u2022 \";\n\n        if (this.listDepth > 0) {\n            this.builder.append(Text.literal(\"\\n\" + \"   \".repeat(this.listDepth) + listPrefix));\n        } else {\n            this.builder.append(Text.literal(listPrefix));\n        }\n\n        this.listDepth++;\n    }\n\n    @Override", "    public void visitListItemEnd() {\n        this.listDepth--;\n\n        if (this.listDepth > 0) {\n            this.builder.append(Text.literal(\"   \".repeat(this.listDepth)));\n        } else {\n            this.builder.append(Text.literal(\"\\n\"));\n        }\n    }\n\n    @Override", "    public Text compile() {\n        return this.builder.build();\n    }\n\n    @Override\n    public String name() {\n        return \"lavender_builtin_text\";\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/compiler/MarkdownCompiler.java", "chunked_list": ["package io.wispforest.lavendermd.compiler;\n\nimport net.minecraft.text.Style;\nimport net.minecraft.util.Identifier;\n\nimport java.util.OptionalInt;\nimport java.util.function.UnaryOperator;\n\n/**\n * All functions defined on this interface are required for supporting", "/**\n * All functions defined on this interface are required for supporting\n * every default Markdown feature implemented in lavender-md. A compiler\n * accepts these commands while visiting an AST and compiles into a result\n * type specific to each compiler implementation.\n * <p>\n * Compilers are stateful objects which build their result object internally\n * while visiting the AST and must be re-created for each new result to be\n * generated\n *", " * generated\n *\n * @param <R> The result type of this specific compiler implementation\n * @see io.wispforest.lavendermd.util.TextBuilder\n */\npublic interface MarkdownCompiler<R> {\n\n    /**\n     * Append {@code text} to this compiler's result, using\n     * the current style as dictated by {@link #visitStyle(UnaryOperator)}\n     * and {@link #visitStyleEnd()}\n     */\n    void visitText(String text);\n\n    /**\n     * Push {@code style} onto this compiler's stack\n     */\n    void visitStyle(UnaryOperator<Style> style);\n\n    /**\n     * Pop the current style from this compiler's stack\n     */\n    void visitStyleEnd();\n\n    /**\n     * Begin a new level of block quote\n     */\n    void visitBlockQuote();\n\n    /**\n     * End the current level of block quote\n     */\n    void visitBlockQuoteEnd();\n\n    /**\n     * Append a horizontal rule to this compiler's result\n     */\n    void visitHorizontalRule();\n\n    /**\n     * Append {@code image} into this compiler's result, using\n     * {@code description} as alt-text, stretching the image to the\n     * width of the compiler's result if {@code fit} is {@code true}\n     */\n    void visitImage(Identifier image, String description, boolean fit);\n\n    /**\n     * Begin a new list item, potentially nesting inside a\n     * previous one\n     */\n    void visitListItem(OptionalInt ordinal);\n\n    /**\n     * End the current list item\n     */\n    void visitListItemEnd();\n\n    /**\n     * @return This compiler's result - the state of this compiler\n     * and the result of calling this function again is not defined\n     */\n    R compile();\n\n    /**\n     * @return A name for this compiler, to be used in logging messages\n     */\n    String name();\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/LinkFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport net.minecraft.text.ClickEvent;\nimport net.minecraft.text.HoverEvent;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;", "import net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\nimport org.jetbrains.annotations.NotNull;\n\npublic class LinkFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"links\";\n    }\n\n    @Override", "    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken(Lexer.Token.lexFromChar(OpenLinkToken::new), '[');\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            if (!nibbler.tryConsume('(')) return false;\n\n            var link = nibbler.consumeUntil(')');", "            if (!nibbler.tryConsume('(')) return false;\n\n            var link = nibbler.consumeUntil(')');\n            if (link == null) return false;\n\n            tokens.add(new CloseLinkToken(link));\n            return true;\n        }, ']');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode((parser, left, tokens) -> {\n            int pointer = tokens.pointer();\n            var content = parser.parseUntil(tokens, CloseLinkToken.class);\n\n            if (tokens.peek() instanceof CloseLinkToken right) {\n                tokens.nibble();\n                return new Parser.FormattingNode(style -> style.withClickEvent(\n                        new ClickEvent(ClickEvent.Action.OPEN_URL, right.link)\n                ).withHoverEvent(\n                        new HoverEvent(HoverEvent.Action.SHOW_TEXT, Text.literal(right.link))\n                ).withColor(Formatting.BLUE)).addChild(content);\n            } else {\n                tokens.setPointer(pointer);\n                return new Parser.TextNode(left.content());\n            }\n        }, (token, tokens) -> token instanceof OpenLinkToken link ? link : null);\n    }\n\n    // --- tokens ---\n\n    private static final class OpenLinkToken extends Lexer.Token {\n        public OpenLinkToken() {\n            super(\"[\");\n        }\n    }\n\n    private static final class CloseLinkToken extends Lexer.Token {\n\n        public final @NotNull String link;\n\n        public CloseLinkToken(@NotNull String link) {\n            super(\"](\" + link + \")\");\n            this.link = link;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/BlockQuoteFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\n\npublic class BlockQuoteFeature implements MarkdownFeature {\n    @Override\n    public String name() {\n        return \"block_quotes\";\n    }\n\n    @Override", "    public String name() {\n        return \"block_quotes\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            var brackets = nibbler.consumeUntilEndOr(c -> c != '>');", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            var brackets = nibbler.consumeUntilEndOr(c -> c != '>');\n            if (!nibbler.tryConsume(' ')) return false;\n\n            tokens.add(new QuotationToken(brackets.length()));\n            return true;\n        }, '>');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, current, tokens) -> new QuotationNode().addChild(parser.parseUntil(tokens, $ -> $.isBoundary() && (!($ instanceof QuotationToken) || ((QuotationToken) $).depth < current.depth), $ -> $ instanceof QuotationToken quote && quote.depth == current.depth)),\n                (token, tokens) -> token instanceof QuotationToken current && (tokens.peek(-2) == null || tokens.peek(-2) instanceof Lexer.NewlineToken) ? current : null\n        );\n    }\n\n    // --- token ---\n\n    private static final class QuotationToken extends Lexer.Token {\n", "        public final int depth;\n\n        public QuotationToken(int depth) {\n            super(\">\".repeat(depth) + \" \");\n            this.depth = depth;\n        }\n\n        @Override\n        public boolean isBoundary() {\n            return true;\n        }\n    }\n\n    // --- node ---\n\n    private static class QuotationNode extends Parser.Node {\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitBlockQuote();\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitBlockQuoteEnd();\n        }\n    }\n}\n", "        public boolean isBoundary() {\n            return true;\n        }\n    }\n\n    // --- node ---\n\n    private static class QuotationNode extends Parser.Node {\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitBlockQuote();\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitBlockQuoteEnd();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/ColorFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport com.google.common.collect.ImmutableMap;\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport net.minecraft.text.Style;\nimport net.minecraft.util.Formatting;\nimport org.jetbrains.annotations.NotNull;", "import net.minecraft.util.Formatting;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Stream;\n\npublic class ColorFeature implements MarkdownFeature {\n\n    private static final Map<String, Formatting> FORMATTING_COLORS = Stream.of(Formatting.values())\n            .filter(Formatting::isColor)\n            .collect(ImmutableMap.toImmutableMap(formatting -> formatting.getName().toLowerCase(Locale.ROOT), Function.identity()));\n\n    @Override", "\npublic class ColorFeature implements MarkdownFeature {\n\n    private static final Map<String, Formatting> FORMATTING_COLORS = Stream.of(Formatting.values())\n            .filter(Formatting::isColor)\n            .collect(ImmutableMap.toImmutableMap(formatting -> formatting.getName().toLowerCase(Locale.ROOT), Function.identity()));\n\n    @Override\n    public String name() {\n        return \"colors\";\n    }\n\n    @Override", "    public String name() {\n        return \"colors\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            if (!nibbler.hasNext()) return false;\n\n            if (nibbler.peek() == '}') {\n                nibbler.skip();\n                tokens.add(new CloseColorToken());\n            } else {\n                if (nibbler.peek() == '#') {\n                    nibbler.skip();\n\n                    var color = nibbler.consumeUntil('}');", "                if (nibbler.peek() == '#') {\n                    nibbler.skip();\n\n                    var color = nibbler.consumeUntil('}');\n                    if (color == null) return false;\n\n                    if (!color.matches(\"[0-9a-fA-F]{6}\")) return false;\n                    tokens.add(new OpenColorToken(\"{#\" + color + \"}\", style -> style.withColor(Integer.parseInt(color, 16))));\n                } else {\n                    var color = nibbler.consumeUntil('}');\n                    if (color == null) return false;\n", "                    if (color == null) return false;\n\n                    if (!FORMATTING_COLORS.containsKey(color)) return false;\n                    tokens.add(new OpenColorToken(\"{\" + color + \"}\", style -> style.withFormatting(FORMATTING_COLORS.get(color))));\n                }\n            }\n\n            return true;\n        }, '{');\n\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode((parser, left, tokens) -> {\n            int pointer = tokens.pointer();\n            var content = parser.parseUntil(tokens, CloseColorToken.class);\n\n            if (tokens.peek() instanceof CloseColorToken) {\n                tokens.nibble();\n                return new Parser.FormattingNode(left.style).addChild(content);\n            } else {\n                tokens.setPointer(pointer);\n                return new Parser.TextNode(left.content());\n            }\n        }, (token, tokens) -> token instanceof OpenColorToken color ? color : null);\n    }\n\n    // --- tokens ---\n\n    private static final class OpenColorToken extends Lexer.Token {\n\n        public final @NotNull UnaryOperator<Style> style;\n\n        public OpenColorToken(String content, @NotNull UnaryOperator<Style> style) {\n            super(content);\n            this.style = style;\n        }\n    }\n\n    private static final class CloseColorToken extends Lexer.Token {\n        private CloseColorToken() {\n            super(\"{}\");\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/KeybindFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.option.KeyBinding;\nimport net.minecraft.client.resource.language.I18n;\nimport net.minecraft.text.HoverEvent;", "import net.minecraft.client.resource.language.I18n;\nimport net.minecraft.text.HoverEvent;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport java.util.Arrays;\n\npublic class KeybindFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"keybindings\";\n    }\n\n    @Override", "    public String name() {\n        return \"keybindings\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            if (!nibbler.tryConsume(\"<keybind;\")) return false;\n\n            var keybindKey = nibbler.consumeUntil('>');\n            if (keybindKey == null) return false;\n\n            var binding = Arrays.stream(MinecraftClient.getInstance().options.allKeys).filter($ -> $.getTranslationKey().equals(keybindKey)).findAny();\n            if (binding.isEmpty()) return false;\n\n            tokens.add(new KeybindToken(keybindKey, binding.get()));\n            return true;\n        }, '<');\n    }\n\n    @Override", "            if (binding.isEmpty()) return false;\n\n            tokens.add(new KeybindToken(keybindKey, binding.get()));\n            return true;\n        }, '<');\n    }\n\n    @Override\n    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, keybindToken, tokens) -> new KeybindNode(keybindToken.binding),\n                (token, tokens) -> token instanceof KeybindToken keybind ? keybind : null\n        );\n    }\n\n    private static class KeybindToken extends Lexer.Token {\n", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, keybindToken, tokens) -> new KeybindNode(keybindToken.binding),\n                (token, tokens) -> token instanceof KeybindToken keybind ? keybind : null\n        );\n    }\n\n    private static class KeybindToken extends Lexer.Token {\n\n        public final KeyBinding binding;\n\n        public KeybindToken(String content, KeyBinding binding) {\n            super(content);\n            this.binding = binding;\n        }\n    }\n\n    private static class KeybindNode extends Parser.Node {\n\n        private final KeyBinding binding;\n\n        public KeybindNode(KeyBinding binding) {\n            this.binding = binding;\n        }\n\n        @Override", "        public final KeyBinding binding;\n\n        public KeybindToken(String content, KeyBinding binding) {\n            super(content);\n            this.binding = binding;\n        }\n    }\n\n    private static class KeybindNode extends Parser.Node {\n\n        private final KeyBinding binding;\n\n        public KeybindNode(KeyBinding binding) {\n            this.binding = binding;\n        }\n\n        @Override", "        public void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitStyle(style -> style.withColor(Formatting.GOLD).withHoverEvent(\n                    new HoverEvent(HoverEvent.Action.SHOW_TEXT, Text.translatable(\n                            \"text.lavender.keybind_tooltip\",\n                            Text.translatable(this.binding.getCategory()),\n                            Text.translatable(this.binding.getTranslationKey())\n                    ))\n            ));\n            compiler.visitText(I18n.translate(this.binding.getBoundKeyTranslationKey()));\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitStyleEnd();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/ListFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport io.wispforest.lavendermd.util.StringNibbler;\n\nimport java.util.OptionalInt;\n\npublic class ListFeature implements MarkdownFeature {\n    @Override", "import java.util.OptionalInt;\n\npublic class ListFeature implements MarkdownFeature {\n    @Override\n    public String name() {\n        return \"lists\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override", "    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        // unordered\n        registrar.registerToken((nibbler, tokens) -> {\n            int whitespace = whitespaceSinceLineBreak(nibbler);\n            if (whitespace < 0) return false;\n\n            nibbler.skip();", "            if (whitespace < 0) return false;\n\n            nibbler.skip();\n            if (!nibbler.tryConsume(' ')) return false;\n\n            tokens.add(new ListToken(whitespace, OptionalInt.empty()));\n            return true;\n        }, '-');\n\n        // ordered\n        registrar.registerToken((nibbler, tokens) -> {\n            int whitespace = whitespaceSinceLineBreak(nibbler);", "            if (whitespace < 0) return false;\n\n            var ordinal = nibbler.consumeUntilEndOr(c -> c < '0' || c > '9');\n            if (!ordinal.matches(\"[0-9]+\") || !nibbler.tryConsume(\". \")) {\n                return false;\n            }\n\n            tokens.add(new ListToken(whitespace, OptionalInt.of(Integer.parseInt(ordinal))));\n            return true;\n        }, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, current, tokens) -> new ListNode(current.ordinal).addChild(parser.parseUntil(tokens, $ -> $.isBoundary() && !($ instanceof ListToken list && list.depth > current.depth), $ -> false)),\n                (token, tokens) -> token instanceof ListToken list ? list : null\n        );\n    }\n\n    private static int whitespaceSinceLineBreak(StringNibbler nibbler) {\n        int offset = 1;\n        int whitespace = 0;\n", "        while (nibbler.cursor() - offset >= 0) {\n            //noinspection DataFlowIssue\n            char current = nibbler.peekOffset(-offset);\n            if (current == '\\n') return whitespace;\n\n            if (Character.isWhitespace(current)) {\n                whitespace++;\n            } else {\n                return -1;\n            }\n\n            offset++;\n        }\n\n        return whitespace;\n    }\n\n    // --- token ---\n\n    private static final class ListToken extends Lexer.Token {\n", "        public final int depth;\n        public final OptionalInt ordinal;\n\n        public ListToken(int depth, OptionalInt ordinal) {\n            super(\"- \");\n            this.depth = depth;\n            this.ordinal = ordinal;\n        }\n\n        @Override\n        public boolean isBoundary() {\n            return true;\n        }\n    }\n\n    // --- node ---\n\n    private static class ListNode extends Parser.Node {\n\n        private final OptionalInt ordinal;\n\n        public ListNode(OptionalInt ordinal) {\n            this.ordinal = ordinal;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitListItem(this.ordinal);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitListItemEnd();\n        }\n    }\n}\n", "        public boolean isBoundary() {\n            return true;\n        }\n    }\n\n    // --- node ---\n\n    private static class ListNode extends Parser.Node {\n\n        private final OptionalInt ordinal;\n\n        public ListNode(OptionalInt ordinal) {\n            this.ordinal = ordinal;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitListItem(this.ordinal);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {\n            compiler.visitListItemEnd();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/BasicFormattingFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport net.minecraft.text.Style;\n\nimport java.util.function.UnaryOperator;\n\npublic class BasicFormattingFeature implements MarkdownFeature {\n\n    private final boolean enableHorizontalRule;\n\n    public BasicFormattingFeature(boolean enableHorizontalRule) {\n        this.enableHorizontalRule = enableHorizontalRule;\n    }\n\n    public BasicFormattingFeature() {\n        this(true);\n    }\n\n    @Override", "import java.util.function.UnaryOperator;\n\npublic class BasicFormattingFeature implements MarkdownFeature {\n\n    private final boolean enableHorizontalRule;\n\n    public BasicFormattingFeature(boolean enableHorizontalRule) {\n        this.enableHorizontalRule = enableHorizontalRule;\n    }\n\n    public BasicFormattingFeature() {\n        this(true);\n    }\n\n    @Override", "    public String name() {\n        return \"basic_formatting\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken(Lexer.Token.lexFromChar(TildeToken::new), '~');\n        registrar.registerToken(Lexer.Token.lexFromChar(UnderscoreToken::new), '_');\n\n        registrar.registerToken((nibbler, tokens) -> {\n            int starCount = nibbler.consumeUntilEndOr(c -> c != '*').length();\n\n            boolean leftAdjacent = !nibbler.expect(-starCount - 1, ' ');\n            boolean rightAdjacent = !nibbler.expect(0, ' ');\n", "    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken(Lexer.Token.lexFromChar(TildeToken::new), '~');\n        registrar.registerToken(Lexer.Token.lexFromChar(UnderscoreToken::new), '_');\n\n        registrar.registerToken((nibbler, tokens) -> {\n            int starCount = nibbler.consumeUntilEndOr(c -> c != '*').length();\n\n            boolean leftAdjacent = !nibbler.expect(-starCount - 1, ' ');\n            boolean rightAdjacent = !nibbler.expect(0, ' ');\n\n            if (starCount > 3 || !(rightAdjacent || leftAdjacent)) {\n                return false;\n            }\n", "            if (starCount > 3 || !(rightAdjacent || leftAdjacent)) {\n                return false;\n            }\n\n            for (int i = 0; i < starCount; i++) {\n                tokens.add(new StarToken(\"*\", leftAdjacent, rightAdjacent));\n            }\n            return true;\n        }, '*');\n\n        if (this.enableHorizontalRule) {\n            registrar.registerToken((nibbler, tokens) -> {", "        if (this.enableHorizontalRule) {\n            registrar.registerToken((nibbler, tokens) -> {\n                if (!nibbler.expect(-1, '\\n') || !nibbler.expect(-2, '\\n')) return false;\n\n                var dashes = nibbler.consumeUntilEndOr(c -> c != '-');\n                if (dashes.length() != 3 || !nibbler.expect(0, '\\n') || !nibbler.expect(1, '\\n')) {\n                    return false;\n                }\n\n                tokens.add(new HorizontalRuleToken());\n                return true;\n            }, '-');\n        }\n    }\n\n    @Override", "    public void registerNodes(NodeRegistrar registrar) {\n        this.registerDoubleTokenFormatting(registrar, TildeToken.class, style -> style.withStrikethrough(true));\n        this.registerDoubleTokenFormatting(registrar, UnderscoreToken.class, style -> style.withUnderline(true));\n\n        registrar.registerNode((parser, left, tokens) -> {\n            int pointer = tokens.pointer();\n            var content = parser.parseUntil(tokens, StarToken.class);\n\n            if (tokens.peek() instanceof StarToken right && right.leftAdjacent) {\n                tokens.nibble();\n", "            if (tokens.peek() instanceof StarToken right && right.leftAdjacent) {\n                tokens.nibble();\n\n                if (content instanceof StarNode star) {\n                    if (star.canIncrementStarCount()) {\n                        return star.incrementStarCount();\n                    } else {\n                        return new Parser.TextNode(\"*\").addChild(content).addChild(new Parser.TextNode(\"*\"));\n                    }\n                } else {\n                    return new StarNode().addChild(content);\n                }\n            } else {\n                tokens.setPointer(pointer);\n                return new Parser.TextNode(left.content());\n            }\n        }, (token, tokens) -> token instanceof StarToken star && star.rightAdjacent ? star : null);\n", "        if (this.enableHorizontalRule) {\n            registrar.registerNode(\n                    (parser, rule, tokens) -> new HorizontalRuleNode(),\n                    (token, tokens) -> token instanceof HorizontalRuleToken rule ? rule : null\n            );\n        }\n    }\n\n    private <T extends Lexer.Token> void registerDoubleTokenFormatting(NodeRegistrar registrar, Class<T> tokenClass, UnaryOperator<Style> formatting) {\n        registrar.registerNode((parser, left1, tokens) -> {\n            var left2 = tokens.nibble();\n\n            int pointer = tokens.pointer();\n            var content = parser.parseUntil(tokens, tokenClass);\n", "            if (tokenClass.isInstance(tokens.peek()) && tokenClass.isInstance(tokens.peek(1))) {\n                tokens.skip(2);\n                return new Parser.FormattingNode(formatting).addChild(content);\n            } else {\n                tokens.setPointer(pointer);\n                return new Parser.TextNode(left1.content() + left2.content());\n            }\n        }, (token, tokens) -> tokenClass.isInstance(token) && tokenClass.isInstance(tokens.peek()) ? tokenClass.cast(token) : null);\n    }\n\n    // --- tokens ---\n\n    private static final class StarToken extends Lexer.Token {\n", "        public final boolean leftAdjacent, rightAdjacent;\n\n        public StarToken(String content, boolean leftAdjacent, boolean rightAdjacent) {\n            super(content);\n            this.leftAdjacent = leftAdjacent;\n            this.rightAdjacent = rightAdjacent;\n        }\n    }\n\n    private static final class TildeToken extends Lexer.Token {\n        public TildeToken() {\n            super(\"~\");\n        }\n    }\n\n    private static final class UnderscoreToken extends Lexer.Token {\n        public UnderscoreToken() {\n            super(\"_\");\n        }\n    }\n\n    private static final class HorizontalRuleToken extends Lexer.Token {\n        public HorizontalRuleToken() {\n            super(\"---\");\n        }\n    }\n\n    // --- nodes ---\n\n    private static class StarNode extends Parser.FormattingNode {\n\n        private int starCount = 1;\n\n        public StarNode() {\n            super(style -> style);\n        }\n\n        @Override\n        protected Style applyStyle(Style style) {\n            return style.withItalic(this.starCount % 2 == 1 ? true : null).withBold(this.starCount > 1 ? true : null);\n        }\n", "        public StarNode incrementStarCount() {\n            this.starCount++;\n            return this;\n        }\n\n        public boolean canIncrementStarCount() {\n            return this.starCount < 3;\n        }\n    }\n\n    private static class HorizontalRuleNode extends Parser.Node {\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitHorizontalRule();\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n"]}
{"filename": "src/main/java/io/wispforest/lavendermd/feature/ImageFeature.java", "chunked_list": ["package io.wispforest.lavendermd.feature;\n\nimport io.wispforest.lavendermd.Lexer;\nimport io.wispforest.lavendermd.MarkdownFeature;\nimport io.wispforest.lavendermd.Parser;\nimport io.wispforest.lavendermd.compiler.MarkdownCompiler;\nimport net.minecraft.util.Identifier;\n\npublic class ImageFeature implements MarkdownFeature {\n\n    @Override", "public class ImageFeature implements MarkdownFeature {\n\n    @Override\n    public String name() {\n        return \"images\";\n    }\n\n    @Override\n    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override", "    public boolean supportsCompiler(MarkdownCompiler<?> compiler) {\n        return true;\n    }\n\n    @Override\n    public void registerTokens(TokenRegistrar registrar) {\n        registrar.registerToken((nibbler, tokens) -> {\n            nibbler.skip();\n            if (!nibbler.tryConsume('[')) return false;\n\n            var description = nibbler.consumeUntil(']');", "            if (!nibbler.tryConsume('[')) return false;\n\n            var description = nibbler.consumeUntil(']');\n            if (description == null || !nibbler.tryConsume('(')) return false;\n\n            var identifier = nibbler.consumeUntil(')');\n            if (identifier == null) return false;\n\n            boolean fit = identifier.endsWith(\",fit\");\n            if (fit) identifier = identifier.substring(0, identifier.length() - 4);\n            if (Identifier.tryParse(identifier) == null) return false;\n\n            tokens.add(new ImageToken(description, identifier, fit));\n            return true;\n        }, '!');\n\n    }\n\n    @Override", "            if (fit) identifier = identifier.substring(0, identifier.length() - 4);\n            if (Identifier.tryParse(identifier) == null) return false;\n\n            tokens.add(new ImageToken(description, identifier, fit));\n            return true;\n        }, '!');\n\n    }\n\n    @Override\n    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, image, tokens) -> new ImageNode(image.identifier, image.description, image.fit),\n                (token, tokens) -> token instanceof ImageToken image ? image : null\n        );\n    }\n\n    // --- token ---\n\n    private static final class ImageToken extends Lexer.Token {\n", "    public void registerNodes(NodeRegistrar registrar) {\n        registrar.registerNode(\n                (parser, image, tokens) -> new ImageNode(image.identifier, image.description, image.fit),\n                (token, tokens) -> token instanceof ImageToken image ? image : null\n        );\n    }\n\n    // --- token ---\n\n    private static final class ImageToken extends Lexer.Token {\n", "        public final String description, identifier;\n        public final boolean fit;\n\n        public ImageToken(String description, String identifier, boolean fit) {\n            super(\"![\" + description + \"](\" + identifier + \")\");\n            this.description = description;\n            this.identifier = identifier;\n            this.fit = fit;\n        }\n    }\n\n    // --- node ---\n\n    private static class ImageNode extends Parser.Node {\n\n        private final String identifier, description;\n        private final boolean fit;\n\n        public ImageNode(String identifier, String description, boolean fit) {\n            this.identifier = identifier;\n            this.description = description;\n            this.fit = fit;\n        }\n\n        @Override\n        protected void visitStart(MarkdownCompiler<?> compiler) {\n            compiler.visitImage(new Identifier(this.identifier), this.description, this.fit);\n        }\n\n        @Override\n        protected void visitEnd(MarkdownCompiler<?> compiler) {}\n    }\n}\n"]}
