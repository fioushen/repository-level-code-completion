{"filename": "src/test/java/com/github/germanosin/kafka/leader/LeaderClientExecutorTest.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport static org.awaitility.Awaitility.await;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.github.germanosin.kafka.leader.tasks.DefaultLeaderTasksManager;\nimport com.github.germanosin.kafka.leader.tasks.Task;\nimport com.github.germanosin.kafka.leader.tasks.TaskAssignment;\nimport java.time.Duration;\nimport java.util.Map;", "import java.time.Duration;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicLong;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.junit.ClassRule;\nimport org.junit.Test;", "import org.junit.ClassRule;\nimport org.junit.Test;\nimport org.testcontainers.containers.KafkaContainer;\nimport org.testcontainers.containers.Network;\nimport org.testcontainers.containers.wait.strategy.Wait;\nimport org.testcontainers.utility.DockerImageName;\n\n@Slf4j\npublic class LeaderClientExecutorTest {\n  @ClassRule\n  public static final KafkaContainer kafka = new KafkaContainer(\n      DockerImageName.parse(\"confluentinc/cp-kafka:7.2.0\")\n  )\n      .withNetworkAliases(\"kafka\")\n      .withNetwork(Network.newNetwork())\n      .waitingFor(Wait.forListeningPort());\n\n  private final Map<Integer, Boolean> exception = new ConcurrentHashMap<>();\n\n  @Test", "public class LeaderClientExecutorTest {\n  @ClassRule\n  public static final KafkaContainer kafka = new KafkaContainer(\n      DockerImageName.parse(\"confluentinc/cp-kafka:7.2.0\")\n  )\n      .withNetworkAliases(\"kafka\")\n      .withNetwork(Network.newNetwork())\n      .waitingFor(Wait.forListeningPort());\n\n  private final Map<Integer, Boolean> exception = new ConcurrentHashMap<>();\n\n  @Test", "  public void testLeaderMultipleTasks() throws LeaderTimeoutException, LeaderException {\n    AtomicLong inc1 = new AtomicLong(0);\n    AtomicLong inc2 = new AtomicLong(0);\n    AtomicLong inc3 = new AtomicLong(0);\n    AtomicLong inc4 = new AtomicLong(0);\n\n    String consumer = String.format(\"consumer-%s\", UUID.randomUUID());\n\n    KafkaLeaderProperties properties =\n        KafkaLeaderProperties.builder()\n            .consumerConfigs(configs())\n            .groupId(consumer)\n            .initTimeout(Duration.ofSeconds(30))\n            .build();\n\n    AssignmentManager<TaskAssignment, HostMemberIdentity> taskManager1 =\n        new DefaultLeaderTasksManager<>(\n            Map.of(\"task1\", run(inc1, 1), \"task2\", run(inc2, 2))\n        );\n\n    AssignmentManager<TaskAssignment, HostMemberIdentity> taskManager2 =\n        new DefaultLeaderTasksManager<>(\n            Map.of(\"task1\", run(inc3, 3), \"task2\", run(inc4, 4))\n        );\n\n    JsonLeaderProtocol<TaskAssignment, HostMemberIdentity> protocol =\n        new JsonLeaderProtocol<>(new ObjectMapper(), HostMemberIdentity.class,\n            TaskAssignment.class);\n\n    final KafkaLeaderElector<TaskAssignment, HostMemberIdentity> leader1 = new KafkaLeaderElector<>(\n        taskManager1,\n        protocol,\n        properties,\n        HostMemberIdentity.builder()\n            .host(\"host1\")\n            .build()\n    );\n    final KafkaLeaderElector<TaskAssignment, HostMemberIdentity> leader2 = new KafkaLeaderElector<>(\n        taskManager2,\n        protocol,\n        properties,\n        HostMemberIdentity.builder()\n            .host(\"host2\")\n            .build()\n    );\n\n    leader1.init();\n    leader2.init();\n\n    leader1.await();\n    leader2.await();\n\n\n    await().atMost(30, TimeUnit.SECONDS)\n        .until(() -> inc1.get() > 0 || inc3.get() > 0);\n\n    await().atMost(30, TimeUnit.SECONDS)\n        .until(() -> inc2.get() > 0 || inc4.get() > 0);\n\n    boolean firstStarted = inc1.get() > 0;\n\n    AtomicLong check1;\n    AtomicLong check2;\n    KafkaLeaderElector<TaskAssignment, HostMemberIdentity> working;\n    KafkaLeaderElector<TaskAssignment, HostMemberIdentity> closing;\n", "    if (firstStarted) {\n      closing = leader1;\n      working = leader2;\n      check1 = inc3;\n      check2 = inc4;\n\n    } else {\n      closing = leader2;\n      working = leader1;\n      check1 = inc1;\n      check2 = inc2;\n    }\n\n    final long prev1Value = check1.get();\n    final long prev2Value = check2.get();\n\n    closing.close();\n\n    await().atMost(30, TimeUnit.SECONDS)\n        .until(() -> check1.get() > prev1Value && check2.get() > prev2Value);\n\n    working.close();\n\n  }\n\n  @Test", "  public void testLeader() throws LeaderTimeoutException, LeaderException {\n    AtomicLong inc = new AtomicLong(0);\n    AtomicLong inc2 = new AtomicLong(0);\n    String consumer = String.format(\"consumer-%s\", UUID.randomUUID());\n\n    KafkaLeaderProperties properties =\n        KafkaLeaderProperties.builder()\n            .consumerConfigs(configs())\n            .groupId(consumer)\n            .initTimeout(Duration.ofSeconds(30))\n            .build();\n\n    JsonLeaderProtocol<TaskAssignment, HostMemberIdentity> protocol =\n        new JsonLeaderProtocol<>(new ObjectMapper(), HostMemberIdentity.class,\n            TaskAssignment.class);\n\n    final KafkaLeaderElector<TaskAssignment, HostMemberIdentity> leader1 = new KafkaLeaderElector<>(\n        wrap(run(inc, 1)),\n        protocol,\n        properties,\n        HostMemberIdentity.builder()\n            .host(\"host1\")\n            .build()\n    );\n    final KafkaLeaderElector<TaskAssignment, HostMemberIdentity> leader2 = new KafkaLeaderElector<>(\n        wrap(run(inc2, 2)),\n        protocol,\n        properties,\n        HostMemberIdentity.builder()\n            .host(\"host2\")\n            .build()\n    );\n\n    leader1.init();\n    leader2.init();\n\n    leader1.await();\n    leader2.await();\n\n\n    await().atMost(30, TimeUnit.SECONDS)\n        .until(() -> inc.get() > 0 || inc2.get() > 0);\n\n    log.info(\"INC-1: {}\", inc.get());\n    log.info(\"INC-2: {}\", inc2.get());\n\n    boolean firstInc = inc.get() > 0;\n", "    if (firstInc) {\n      final long inc2Value = inc2.get();\n      exception.put(1, true);\n\n      await().atMost(60, TimeUnit.SECONDS)\n          .until(() -> leader1.getRestarts() > 0);\n\n      leader1.close();\n\n      await().atMost(60, TimeUnit.SECONDS)\n          .until(() -> inc2.get() > inc2Value);\n\n      leader2.close();\n    } else {\n      final long incValue = inc.get();\n      exception.put(2, true);\n\n      await().atMost(30, TimeUnit.SECONDS)\n          .until(() -> leader2.getRestarts() > 0);\n\n      leader2.close();\n\n      await().atMost(30, TimeUnit.SECONDS)\n          .until(() -> inc.get() > incValue);\n\n      leader1.close();\n    }\n  }\n\n  public AssignmentManager<TaskAssignment, HostMemberIdentity> wrap(Task task) {\n    return new DefaultLeaderTasksManager<>(\n        Map.of(\n            \"default\", task\n        )\n    );\n  }\n", "  public Task run(AtomicLong inc, int n) {\n    return new Task() {\n\n      private volatile boolean inited = false;\n\n      @Override\n      public void close() {\n      }\n\n      @Override\n      public boolean isAlive() {\n        return true;\n      }\n\n      @Override", "      public boolean isAlive() {\n        return true;\n      }\n\n      @Override\n      public boolean isStarted() {\n        return inited;\n      }\n\n      @Override\n      public void run() {\n        this.inited = true;\n        log.info(\"Started inc: {}\", n);", "      public void run() {\n        this.inited = true;\n        log.info(\"Started inc: {}\", n);\n        try {\n          while (!Thread.currentThread().isInterrupted()) {\n            inc.incrementAndGet();\n            Thread.sleep(100);\n            if (exception.get(n) != null && exception.get(n)) {\n              throw new RuntimeException(\"Test\");\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        } finally {\n          log.info(\"Ended inc {}\", n);\n        }\n      }\n    };\n  }\n\n  private Map<String, Object> configs() {\n    return Map.of(\n        ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()\n    );\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/Assignment.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\npublic interface Assignment {\n  int getVersion();\n\n  short getError();\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/KafkaLeaderElector.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.net.InetSocketAddress;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport lombok.SneakyThrows;", "import java.util.concurrent.atomic.AtomicReference;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.clients.ApiVersions;\nimport org.apache.kafka.clients.ClientUtils;\nimport org.apache.kafka.clients.CommonClientConfigs;\nimport org.apache.kafka.clients.Metadata;\nimport org.apache.kafka.clients.NetworkClient;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient;", "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.apache.kafka.common.internals.ClusterResourceListeners;\nimport org.apache.kafka.common.metrics.Metrics;\nimport org.apache.kafka.common.network.ChannelBuilder;\nimport org.apache.kafka.common.network.Selector;\nimport org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.Time;", "import org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.Time;\nimport org.apache.kafka.common.utils.Timer;\n\n\n@Slf4j\npublic class KafkaLeaderElector<A extends Assignment, M extends MemberIdentity>\n    implements LeaderElector {\n\n  private static final AtomicInteger BD_CLIENT_ID_SEQUENCE = new AtomicInteger(1);\n  private static final String METRIC_GRP_PREFIX = \"kafka.betdev\";\n\n  private static final Duration REBALANCE_TIMEOUT = Duration.ofMinutes(5);\n  private static final Duration SESSION_TIMEOUT = Duration.ofSeconds(10);\n  private static final Duration HEARTBEAT_INTERVAL = Duration.ofSeconds(3);\n\n  private final ConsumerNetworkClient client;\n  private final Long retryBackoffMs;\n  private final KafkaLeaderProperties properties;\n  private final Metrics metrics;\n  private final AtomicBoolean stopped = new AtomicBoolean(false);\n  private final AtomicInteger restarts = new AtomicInteger(0);\n  private final AssignmentManager<A, M> assignmentManager;\n  private final M identity;\n  private final LeaderProtocol<A, M> leaderProtocol;\n  private final LogContext logContext;\n  private final Time time;\n  private final Thread pollingThread;\n  private final Duration rebalanceTimeout;\n  private final Duration sessionTimeout;\n  private final Duration heartbeatInterval;\n\n  public KafkaLeaderElector(\n      AssignmentManager<A, M> assignmentManager,\n      LeaderProtocol<A, M> leaderProtocol,\n      KafkaLeaderProperties properties,\n      M identity\n  ) {\n    this(assignmentManager, properties, leaderProtocol, identity,\n        REBALANCE_TIMEOUT, SESSION_TIMEOUT, HEARTBEAT_INTERVAL);\n  }\n\n  public KafkaLeaderElector(\n      AssignmentManager<A, M> assignmentManager,\n      KafkaLeaderProperties properties,\n      LeaderProtocol<A, M> leaderProtocol,\n      M identity,\n      Duration rebalanceTimeout,\n      Duration sessionTimeout,\n      Duration heartbeatInterval\n  ) {\n    this.properties = properties;\n    this.assignmentManager = assignmentManager;\n    this.identity = identity;\n\n    final String clientId =\n        \"bd-\" + identity.getId() + \"-\" + BD_CLIENT_ID_SEQUENCE.getAndIncrement();\n    this.metrics = new Metrics();\n    this.leaderProtocol = leaderProtocol;\n    this.rebalanceTimeout = rebalanceTimeout;\n    this.sessionTimeout = sessionTimeout;\n    this.heartbeatInterval = heartbeatInterval;\n\n    final ConsumerConfig clientConfig = properties.getConsumerConfig();\n\n    this.time = Time.SYSTEM;\n\n    this.logContext = new LogContext(\n        \"[clientId=\" + clientId + \", groupId=\" + properties.getGroupId() + \"] \"\n    );\n\n    this.retryBackoffMs = clientConfig.getLong(CommonClientConfigs.RETRY_BACKOFF_MS_CONFIG);\n\n    Metadata metadata = new Metadata(\n        this.retryBackoffMs,\n        clientConfig.getLong(CommonClientConfigs.METADATA_MAX_AGE_CONFIG),\n        this.logContext,\n        new ClusterResourceListeners()\n    );\n\n    List<String> bootstrapServers = clientConfig.getList(\n        ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG\n    );\n\n    List<InetSocketAddress> addresses = ClientUtils.parseAndValidateAddresses(\n        bootstrapServers,\n        clientConfig.getString(CommonClientConfigs.CLIENT_DNS_LOOKUP_CONFIG)\n    );\n\n    metadata.bootstrap(addresses);\n\n    ChannelBuilder channelBuilder = ClientUtils.createChannelBuilder(\n        clientConfig,\n        time, this.logContext\n    );\n\n    long maxIdleMs = clientConfig.getLong(CommonClientConfigs.CONNECTIONS_MAX_IDLE_MS_CONFIG);\n    NetworkClient netClient = new NetworkClient(\n        new Selector(\n            maxIdleMs,\n            metrics,\n            time,\n            METRIC_GRP_PREFIX,\n            channelBuilder,\n            this.logContext\n        ),\n        metadata,\n        clientId,\n        100, // a fixed large enough value will suffice\n        clientConfig.getLong(CommonClientConfigs.RECONNECT_BACKOFF_MS_CONFIG),\n        clientConfig.getLong(CommonClientConfigs.RECONNECT_BACKOFF_MAX_MS_CONFIG),\n        clientConfig.getInt(CommonClientConfigs.SEND_BUFFER_CONFIG),\n        clientConfig.getInt(CommonClientConfigs.RECEIVE_BUFFER_CONFIG),\n        clientConfig.getInt(CommonClientConfigs.REQUEST_TIMEOUT_MS_CONFIG),\n        clientConfig.getLong(CommonClientConfigs.SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG),\n        clientConfig.getLong(CommonClientConfigs.SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG),\n        this.time,\n        true,\n        new ApiVersions(),\n        logContext\n    );\n\n    this.client = new ConsumerNetworkClient(\n        this.logContext,\n        netClient,\n        metadata,\n        time,\n        retryBackoffMs,\n        clientConfig.getInt(CommonClientConfigs.REQUEST_TIMEOUT_MS_CONFIG),\n        Integer.MAX_VALUE\n    );\n\n    this.pollingThread = new Thread(null, this::poller, \"LeaderPoller-\" + clientId);\n\n    log.debug(\"Group member created\");\n  }\n\n  private LeaderCoordinator<A, M> createCoordinator() {\n    return new LeaderCoordinator<>(\n        this.logContext,\n        this.client,\n        this.properties.getGroupId(),\n        rebalanceTimeout,\n        sessionTimeout,\n        heartbeatInterval,\n        new Metrics(),\n        METRIC_GRP_PREFIX,\n        this.time,\n        this.retryBackoffMs,\n        this.identity,\n        assignmentManager,\n        this.leaderProtocol\n    );\n  }\n\n\n  @Override", "  public void init() {\n    log.debug(\"Initializing group member\");\n    pollingThread.start();\n  }\n\n  private void poller() {\n    try {\n      while (!stopped.get()) {\n        try (LeaderCoordinator<A, M> coordinator = createCoordinator()) {\n          while (!stopped.get()) {\n            coordinator.poll(500);\n            Timer timer = Time.SYSTEM.timer(this.rebalanceTimeout.toMillis());", "          while (!stopped.get()) {\n            coordinator.poll(500);\n            Timer timer = Time.SYSTEM.timer(this.rebalanceTimeout.toMillis());\n            if (!assignmentManager.isInitialisation() && !this.stopped.get()) {\n              if (!assignmentManager.isAlive(timer)) {\n                this.assignmentManager.onRevoked(timer);\n                this.restarts.incrementAndGet();\n                log.warn(\"Leader election restarts.\");\n                break;\n              }\n            }\n          }\n        }\n      }\n    } catch (WakeupException e) {\n      // Skip wakeup exception\n    } catch (Throwable t) {\n      log.error(\"Unexpected exception in group processing thread\", t);\n    }\n  }\n", "  public void await() throws LeaderTimeoutException, LeaderException {\n    try {\n      if (!assignmentManager.await(properties.getInitTimeout())) {\n        throw new LeaderTimeoutException(\"Timed out waiting for join group to complete\");\n      }\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new LeaderException(\"Interrupted while waiting for join group to complete\", e);\n    }\n\n    log.debug(\"Group member initialized and joined group\");\n\n  }\n\n  @Override\n  @SneakyThrows", "  public void close() {\n    if (stopped.get()) {\n      return;\n    }\n    stop();\n  }\n\n  private void stop() throws InterruptedException {\n    log.trace(\"Stopping the schema registry group member.\");\n\n    // Interrupt any outstanding poll calls", "    if (client != null) {\n      client.wakeup();\n    }\n\n    try {\n      assignmentManager.close();\n    } catch (Exception e) {\n      log.error(\"Error on task-manager close\", e);\n    }\n\n    this.stopped.set(true);\n    pollingThread.interrupt();\n    Instant start = Instant.now();", "    while (\n        pollingThread.isAlive()\n            && (Instant.now().toEpochMilli() - start.toEpochMilli()) < 30 * 1000) {\n      Thread.sleep(100);\n    }\n\n    // Do final cleanup\n    AtomicReference<Throwable> firstException = new AtomicReference<>();\n    closeQuietly(metrics, \"consumer metrics\", firstException);\n    closeQuietly(client, \"consumer network client\", firstException);\n", "    if (firstException.get() != null) {\n      throw new KafkaException(\n          \"Failed to stop the group member\",\n          firstException.get()\n      );\n    } else {\n      log.debug(\"The Group member has stopped.\");\n    }\n  }\n\n  private static void closeQuietly(AutoCloseable closeable,\n                                   String name,\n                                   AtomicReference<Throwable> firstException\n  ) {", "    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Throwable t) {\n        firstException.compareAndSet(null, t);\n        log.error(\"Failed to close {} with type {}\", name, closeable.getClass().getName(), t);\n      }\n    }\n  }\n\n  public int getRestarts() {\n    return this.restarts.get();\n  }\n}\n", "  public int getRestarts() {\n    return this.restarts.get();\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/LeaderException.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\npublic class LeaderException extends RuntimeException {\n  public LeaderException(String message, Throwable e) {\n    super(message, e);\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/MemberIdentity.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\npublic interface MemberIdentity {\n\n  String getId();\n\n  boolean getLeaderEligibility();\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/LeaderCoordinator.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.io.Closeable;\nimport java.nio.ByteBuffer;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.clients.GroupRebalanceConfig;\nimport org.apache.kafka.clients.consumer.internals.AbstractCoordinator;\nimport org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient;\nimport org.apache.kafka.common.message.JoinGroupRequestData;\nimport org.apache.kafka.common.message.JoinGroupResponseData;\nimport org.apache.kafka.common.metrics.Metrics;", "import org.apache.kafka.common.message.JoinGroupResponseData;\nimport org.apache.kafka.common.metrics.Metrics;\nimport org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.Time;\nimport org.apache.kafka.common.utils.Timer;\n\n@Slf4j\npublic class LeaderCoordinator<A extends Assignment, M extends MemberIdentity>\n    extends AbstractCoordinator implements Closeable {\n\n  public static final String BD_SUBPROTOCOL_V0 = \"v0\";\n\n  private final M identity;\n  private final Metrics metrics;\n  private A assignmentSnapshot;\n  private final AssignmentManager<A, M> assignmentManager;\n  private final LeaderProtocol<A, M> leaderProtocol;\n\n  public LeaderCoordinator(\n      LogContext logContext,\n      ConsumerNetworkClient client,\n      String groupId,\n      Duration rebalanceTimeout,\n      Duration sessionTimeout,\n      Duration heartbeatInterval,\n      Metrics metrics,\n      String metricGrpPrefix,\n      Time time,\n      long retryBackoffMs,\n      M identity,\n      AssignmentManager<A, M> assignmentManager,\n      LeaderProtocol<A, M> leaderProtocol\n  ) {\n    super(\n        new GroupRebalanceConfig(\n            (int) sessionTimeout.toMillis(),\n            (int) rebalanceTimeout.toMillis(),\n            (int) heartbeatInterval.toMillis(),\n            groupId,\n            Optional.empty(),\n            retryBackoffMs,\n            true\n        ),\n        logContext,\n        client,\n        metrics,\n        metricGrpPrefix,\n        time\n    );\n    this.identity = identity;\n    this.assignmentSnapshot = null;\n    this.assignmentManager = assignmentManager;\n    this.leaderProtocol = leaderProtocol;\n    this.metrics = metrics;\n  }\n\n  @Override\n  protected String protocolType() {\n    return \"bd\";\n  }\n", "  public static final String BD_SUBPROTOCOL_V0 = \"v0\";\n\n  private final M identity;\n  private final Metrics metrics;\n  private A assignmentSnapshot;\n  private final AssignmentManager<A, M> assignmentManager;\n  private final LeaderProtocol<A, M> leaderProtocol;\n\n  public LeaderCoordinator(\n      LogContext logContext,\n      ConsumerNetworkClient client,\n      String groupId,\n      Duration rebalanceTimeout,\n      Duration sessionTimeout,\n      Duration heartbeatInterval,\n      Metrics metrics,\n      String metricGrpPrefix,\n      Time time,\n      long retryBackoffMs,\n      M identity,\n      AssignmentManager<A, M> assignmentManager,\n      LeaderProtocol<A, M> leaderProtocol\n  ) {\n    super(\n        new GroupRebalanceConfig(\n            (int) sessionTimeout.toMillis(),\n            (int) rebalanceTimeout.toMillis(),\n            (int) heartbeatInterval.toMillis(),\n            groupId,\n            Optional.empty(),\n            retryBackoffMs,\n            true\n        ),\n        logContext,\n        client,\n        metrics,\n        metricGrpPrefix,\n        time\n    );\n    this.identity = identity;\n    this.assignmentSnapshot = null;\n    this.assignmentManager = assignmentManager;\n    this.leaderProtocol = leaderProtocol;\n    this.metrics = metrics;\n  }\n\n  @Override\n  protected String protocolType() {\n    return \"bd\";\n  }\n", "  public void poll(long timeout) {\n    // poll for io until the timeout expires\n    final long start = time.milliseconds();\n    long now = start;\n    long remaining;\n\n    do {\n      if (coordinatorUnknown()) {\n        ensureCoordinatorReady(time.timer(Long.MAX_VALUE));\n        now = time.milliseconds();\n      }\n", "      if (rejoinNeededOrPending()) {\n        ensureActiveGroup();\n        now = time.milliseconds();\n      }\n\n      pollHeartbeat(now);\n\n      long elapsed = now - start;\n      remaining = timeout - elapsed;\n\n      // Note that because the network client is shared with the background heartbeat thread,\n      // we do not want to block in poll longer than the time to the next heartbeat.\n      client.poll(time.timer(Math.min(Math.max(0, remaining), timeToNextHeartbeat(now))));\n\n      elapsed = time.milliseconds() - start;\n      remaining = timeout - elapsed;", "    } while (remaining > 0);\n  }\n\n  @Override\n  protected JoinGroupRequestData.JoinGroupRequestProtocolCollection metadata() {\n    ByteBuffer metadata = leaderProtocol.serializeMetadata(identity);\n    return new JoinGroupRequestData.JoinGroupRequestProtocolCollection(\n        Collections.singletonList(new JoinGroupRequestData.JoinGroupRequestProtocol()\n            .setName(BD_SUBPROTOCOL_V0)\n            .setMetadata(metadata.array())).iterator());\n  }\n\n  @Override\n  protected void onJoinComplete(int generation, String memberId, String protocol,\n                                ByteBuffer memberAssignment) {\n    assignmentSnapshot = leaderProtocol.deserializeAssignment(memberAssignment);\n    assignmentManager.onAssigned(assignmentSnapshot, generation);\n  }\n\n\n  @Override\n  protected boolean onJoinPrepare(Timer timer, int generation, String memberId) {\n    log.debug(\"Revoking previous assignment {}\", assignmentSnapshot);", "    if (assignmentSnapshot != null) {\n      assignmentManager.onRevoked(timer);\n    }\n    return true;\n  }\n\n  @Override\n  protected Map<String, ByteBuffer> onLeaderElected(\n      String leaderId, String protocol,\n      List<JoinGroupResponseData.JoinGroupResponseMember> allMemberMetadata,\n      boolean skipAssignment\n  ) {\n    log.debug(\"Performing assignment\");\n\n    List<M> members = new ArrayList<>(allMemberMetadata.size());\n    Map<String, String> memberIds = new HashMap<>();\n", "    for (JoinGroupResponseData.JoinGroupResponseMember entry : allMemberMetadata) {\n      M identity = leaderProtocol.deserializeMetadata(entry.metadata());\n      members.add(identity);\n      memberIds.put(identity.getId(), entry.memberId());\n    }\n\n    Map<M, A> assignments = assignmentManager.assign(members);\n\n    Map<String, ByteBuffer> groupAssignment = new HashMap<>();\n\n    for (Map.Entry<M, A> entry : assignments.entrySet()) {\n      String memberId = memberIds.get(entry.getKey().getId());\n      groupAssignment.put(\n          memberId,\n          leaderProtocol.serializeAssignment(entry.getValue())\n      );\n    }\n\n    log.info(\n        \"assignments: {}\", assignments\n    );\n\n    return groupAssignment;\n  }\n\n  @Override\n  protected void close(Timer timer) {\n    super.close(timer);\n    this.metrics.close();\n  }\n}\n", "    for (Map.Entry<M, A> entry : assignments.entrySet()) {\n      String memberId = memberIds.get(entry.getKey().getId());\n      groupAssignment.put(\n          memberId,\n          leaderProtocol.serializeAssignment(entry.getValue())\n      );\n    }\n\n    log.info(\n        \"assignments: {}\", assignments\n    );\n\n    return groupAssignment;\n  }\n\n  @Override\n  protected void close(Timer timer) {\n    super.close(timer);\n    this.metrics.close();\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/LeaderTimeoutException.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\npublic class LeaderTimeoutException extends Exception {\n  public LeaderTimeoutException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/LeaderElector.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.io.Closeable;\n\npublic interface LeaderElector extends Closeable {\n  void init();\n\n  void await() throws LeaderTimeoutException;\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/KafkaLeaderProperties.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport lombok.Builder;\nimport lombok.Data;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.serialization.ByteArrayDeserializer;\n", "import org.apache.kafka.common.serialization.ByteArrayDeserializer;\n\n@Data\n@Builder\npublic class KafkaLeaderProperties {\n  private final String groupId;\n  private final Map<String, Object> consumerConfigs;\n  private final Duration initTimeout;\n\n  public ConsumerConfig getConsumerConfig() {\n    Map<String, Object> configs = new HashMap<>(consumerConfigs);\n    configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n        ByteArrayDeserializer.class\n    );\n    configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n        ByteArrayDeserializer.class\n    );\n    return new ConsumerConfig(configs);\n  }\n}\n", "  public ConsumerConfig getConsumerConfig() {\n    Map<String, Object> configs = new HashMap<>(consumerConfigs);\n    configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n        ByteArrayDeserializer.class\n    );\n    configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n        ByteArrayDeserializer.class\n    );\n    return new ConsumerConfig(configs);\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/AssignmentManager.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.kafka.common.utils.Timer;\n\npublic interface AssignmentManager<A extends Assignment, M extends MemberIdentity>\n    extends AutoCloseable {\n\n  /**\n   * Invoked when a new assignment is created by joining the group. This is\n   * invoked for both successful and unsuccessful assignments.\n   */\n  void onAssigned(A assignment, int generation);\n\n  /**\n   * Invoked when a rebalance operation starts, revoking leadership.\n   */\n  void onRevoked(Timer timer);\n\n  Map<M, A> assign(List<M> identities);\n\n  boolean isInitialisation();\n\n  boolean isAlive(Timer timer);\n\n  boolean await(Duration timeout) throws LeaderTimeoutException, InterruptedException;\n\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/JsonLeaderProtocol.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.nio.ByteBuffer;\nimport lombok.SneakyThrows;\n\npublic class JsonLeaderProtocol<A extends Assignment, M extends MemberIdentity>\n    implements LeaderProtocol<A, M> {\n  private final ObjectMapper mapper;\n  private final Class<M> identityClass;\n\n  private final Class<A> assignmentClass;\n\n  public JsonLeaderProtocol(ObjectMapper mapper,\n                            Class<M> identityClass,\n                            Class<A> assignmentClass) {\n    this.mapper = mapper;\n    this.identityClass = identityClass;\n    this.assignmentClass = assignmentClass;\n  }\n\n  @Override\n  @SneakyThrows", "  public ByteBuffer serializeMetadata(M identity) {\n    return ByteBuffer.wrap(\n        mapper.writeValueAsBytes(identity)\n    );\n  }\n\n  @Override\n  @SneakyThrows\n  public M deserializeMetadata(byte[] buffer) {\n    return mapper.readValue(buffer, this.identityClass);\n  }\n\n  @SneakyThrows", "  public M deserializeMetadata(byte[] buffer) {\n    return mapper.readValue(buffer, this.identityClass);\n  }\n\n  @SneakyThrows\n  public ByteBuffer serializeAssignment(Assignment assignment) {\n    return ByteBuffer.wrap(\n        mapper.writeValueAsBytes(assignment)\n    );\n  }\n\n  @SneakyThrows", "  public A deserializeAssignment(ByteBuffer buffer) {\n    byte[] jsonBytes = new byte[buffer.remaining()];\n    buffer.get(jsonBytes);\n    return mapper.readValue(jsonBytes, this.assignmentClass);\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/HostMemberIdentityGenerator.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.util.Collections;\nimport java.util.Enumeration;\n\npublic class HostMemberIdentityGenerator {\n", "\npublic class HostMemberIdentityGenerator {\n\n  public static HostMemberIdentity generate() {\n    return generate(\"127.0.0.1\");\n  }\n\n  public static HostMemberIdentity generate(String defaultAddress) {\n    return HostMemberIdentity.builder()\n        .host(host(defaultAddress))\n        .build();\n  }\n\n  private static String host(String defaultAddress) {\n    String ipv6 = null;\n", "    try {\n      final Enumeration<NetworkInterface> interfaces =\n          NetworkInterface.getNetworkInterfaces();\n      for (NetworkInterface networkInterface : Collections.list(interfaces)) {\n        if (!networkInterface.isLoopback()) {\n          final Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();\n          for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n            if (inetAddress instanceof Inet6Address) {\n              ipv6 = inetAddress.getHostAddress();\n            } else if (inetAddress instanceof Inet4Address) {\n              return inetAddress.getHostAddress();\n            }\n          }\n        }\n      }\n\n      return ipv6 !=  null ? ipv6 : defaultAddress;\n\n    } catch (Exception e) {\n      throw new RuntimeException(\"Ip address not found\", e);\n    }\n  }\n}\n", "            } else if (inetAddress instanceof Inet4Address) {\n              return inetAddress.getHostAddress();\n            }\n          }\n        }\n      }\n\n      return ipv6 !=  null ? ipv6 : defaultAddress;\n\n    } catch (Exception e) {\n      throw new RuntimeException(\"Ip address not found\", e);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/HostMemberIdentity.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@Builder", "@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class HostMemberIdentity implements MemberIdentity {\n  @Builder.Default\n  private Integer version = 0;\n  private String host;\n  @Builder.Default\n  private boolean leaderEligibility = true;\n\n  @JsonIgnore", "  public String getId() {\n    return host;\n  }\n\n  @Override\n  public boolean getLeaderEligibility() {\n    return leaderEligibility;\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/LeaderProtocol.java", "chunked_list": ["package com.github.germanosin.kafka.leader;\n\nimport java.nio.ByteBuffer;\n\npublic interface LeaderProtocol<A extends Assignment, M extends MemberIdentity> {\n  ByteBuffer serializeAssignment(A assignment);\n\n  A deserializeAssignment(ByteBuffer buffer);\n\n  ByteBuffer serializeMetadata(M identity);\n\n  M deserializeMetadata(byte[] buffer);\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/tasks/TaskAssignment.java", "chunked_list": ["package com.github.germanosin.kafka.leader.tasks;\n\nimport com.github.germanosin.kafka.leader.Assignment;\nimport com.github.germanosin.kafka.leader.MemberIdentity;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n", "import lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder(toBuilder = true)\npublic class TaskAssignment implements Assignment {\n  public static final int CURRENT_VERSION = 1;\n  public static final short NO_ERROR = 0;\n  public static final short DUPLICATE_URLS = 1;\n\n  private int version;\n  private short error;\n  private List<String> tasks;\n}\n", "  public static final short NO_ERROR = 0;\n  public static final short DUPLICATE_URLS = 1;\n\n  private int version;\n  private short error;\n  private List<String> tasks;\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/tasks/DefaultLeaderTasksManager.java", "chunked_list": ["package com.github.germanosin.kafka.leader.tasks;\n\nimport static com.github.germanosin.kafka.leader.tasks.TaskAssignment.CURRENT_VERSION;\nimport static com.github.germanosin.kafka.leader.tasks.TaskAssignment.NO_ERROR;\n\nimport com.github.germanosin.kafka.leader.AssignmentManager;\nimport com.github.germanosin.kafka.leader.LeaderTimeoutException;\nimport com.github.germanosin.kafka.leader.MemberIdentity;\nimport java.io.IOException;\nimport java.time.Duration;", "import java.io.IOException;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;", "import java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.kafka.common.utils.Time;\nimport org.apache.kafka.common.utils.Timer;", "import org.apache.kafka.common.utils.Time;\nimport org.apache.kafka.common.utils.Timer;\n\n@Slf4j\npublic class DefaultLeaderTasksManager<M extends MemberIdentity>\n    implements AssignmentManager<TaskAssignment, M> {\n  private final Map<String, ? extends Task> tasks;\n  private final CloseableExecutorService executor =\n      new CloseableExecutorService(Executors.newCachedThreadPool());\n  private final Map<String, Future<?>> ownTasks = new HashMap<>();\n  private final Consumer<DefaultLeaderTasksManager<?>> terminationFunction;\n\n  private final AtomicBoolean initialisation = new AtomicBoolean(true);\n\n  private final CountDownLatch joinedLatch = new CountDownLatch(1);\n\n  private static void systemExit(DefaultLeaderTasksManager<?> manager) {\n    log.error(\"Abnormal process termination\");\n    System.exit(1);\n  }\n\n  public DefaultLeaderTasksManager(Map<String, ? extends Task> tasks) {\n    this(tasks, DefaultLeaderTasksManager::systemExit);\n  }\n\n  public DefaultLeaderTasksManager(Map<String, ? extends Task> tasks,\n                                   Consumer<DefaultLeaderTasksManager<?>> terminationFunction) {\n    this.tasks = tasks;\n    this.terminationFunction = terminationFunction;\n  }\n\n  @Override\n  public Map<M, TaskAssignment> assign(List<M> identities) {\n    Map<M, List<String>> result = new HashMap<>();\n\n    Iterator<String> iterator = this.tasks.keySet().iterator();\n\n    int i = 0;", "    while (iterator.hasNext()) {\n      String task = iterator.next();\n      M member = identities.get(i++ % identities.size());\n      List<String> memberTasks = result.computeIfAbsent(member, (m) -> new ArrayList<>());\n      memberTasks.add(task);\n    }\n\n    TaskAssignment build = TaskAssignment.builder()\n        .version(CURRENT_VERSION)\n        .error(NO_ERROR)\n        .build();\n\n    return identities.stream().collect(\n        Collectors.toMap(\n            e -> e,\n            e -> build.toBuilder()\n                .tasks(result.containsKey(e) ? result.get(e) : List.of())\n                .build()\n        )\n    );\n  }\n\n  @Override", "  public boolean isInitialisation() {\n    return initialisation.get();\n  }\n\n  @Override\n  public void onAssigned(TaskAssignment assignment, int generation) {\n    if (assignment.getTasks() != null) {\n      for (String task : assignment.getTasks()) {\n        Task runnable = this.tasks.get(task);\n        Future<?> future = this.executor.submit(runnable);\n        this.ownTasks.put(task, future);\n      }\n    }\n    joinedLatch.countDown();\n    initialisation.set(false);\n  }\n\n  @Override", "  public void onRevoked(Timer timer) {\n    initialisation.set(true);\n    shutdownAll(timer);\n  }\n\n  private void shutdownAll(Timer timer) {\n    if (!this.ownTasks.isEmpty()) {\n      ownTasks.forEach((k, v) -> v.cancel(true));\n\n      for (Map.Entry<String, Future<?>> entry : ownTasks.entrySet()) {\n        closeTask(entry.getKey(), false, timer);\n      }\n\n      this.ownTasks.clear();\n    }\n  }\n\n  @Override", "      for (Map.Entry<String, Future<?>> entry : ownTasks.entrySet()) {\n        closeTask(entry.getKey(), false, timer);\n      }\n\n      this.ownTasks.clear();\n    }\n  }\n\n  @Override\n  public boolean await(Duration timeout) throws LeaderTimeoutException, InterruptedException {\n    return joinedLatch.await(timeout.toMillis(), TimeUnit.MILLISECONDS);\n  }\n\n  @Override", "  public boolean await(Duration timeout) throws LeaderTimeoutException, InterruptedException {\n    return joinedLatch.await(timeout.toMillis(), TimeUnit.MILLISECONDS);\n  }\n\n  @Override\n  public boolean isAlive(Timer timer) {\n    for (Map.Entry<String, Future<?>> ownTask : ownTasks.entrySet()) {\n      Future<?> future = ownTask.getValue();\n      Task runnable = tasks.get(ownTask.getKey());\n      if (runnable.isStarted()) {\n        if (!future.isDone() && !runnable.isAlive()) {\n          final String taskName = ownTask.getKey();\n          closeTask(taskName, true, timer);\n          submitTask(taskName);\n          log.warn(\"task {} was successfully restarted!\", taskName);\n        }\n      }\n    }\n\n    return ownTasks.values().stream().noneMatch(Future::isDone);\n  }\n\n  private void submitTask(String task) {\n    Task runnable = this.tasks.get(task);\n    Future<?> future = this.executor.submit(runnable);\n    log.info(\"New runnable task {} was submitted.\", task);\n    this.ownTasks.put(task, future);\n  }\n\n  private void closeTask(String task, boolean cancel, Timer timer) {\n    Future<?> future = ownTasks.get(task);", "      if (runnable.isStarted()) {\n        if (!future.isDone() && !runnable.isAlive()) {\n          final String taskName = ownTask.getKey();\n          closeTask(taskName, true, timer);\n          submitTask(taskName);\n          log.warn(\"task {} was successfully restarted!\", taskName);\n        }\n      }\n    }\n\n    return ownTasks.values().stream().noneMatch(Future::isDone);\n  }\n\n  private void submitTask(String task) {\n    Task runnable = this.tasks.get(task);\n    Future<?> future = this.executor.submit(runnable);\n    log.info(\"New runnable task {} was submitted.\", task);\n    this.ownTasks.put(task, future);\n  }\n\n  private void closeTask(String task, boolean cancel, Timer timer) {\n    Future<?> future = ownTasks.get(task);", "    if (cancel) {\n      future.cancel(true);\n    }\n    long remainingMs = timer.remainingMs();\n    try {\n      log.info(\"awaiting task {} to finish...\", task);\n      future.get(remainingMs, TimeUnit.MILLISECONDS);\n    } catch (TimeoutException timeoutException) {\n      log.error(\"Error on waiting task {}, took longer than {}\", task, remainingMs);\n      this.terminationFunction.accept(this);\n    } catch (Throwable e) {\n      log.info(\"Error on task {} finishing...\", task, e);\n    }\n    Task runnable = tasks.get(task);", "    try {\n      runnable.close();\n    } catch (Exception ex) {\n      log.error(\"Exception during revoke \", ex);\n    }\n  }\n\n  @Override\n  public void close() throws IOException {\n    shutdownAll(Time.SYSTEM.timer(Duration.ofMinutes(2)));\n    executor.shutdown();", "  public void close() throws IOException {\n    shutdownAll(Time.SYSTEM.timer(Duration.ofMinutes(2)));\n    executor.shutdown();\n    try {\n      executor.awaitTermination(30, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new RuntimeException(\n          \"Interrupted waiting for group processing thread to exit\",\n          e\n      );\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/tasks/CloseableExecutorService.java", "chunked_list": ["package com.github.germanosin.kafka.leader.tasks;\n\nimport java.io.Closeable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;", "import java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.RunnableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class CloseableExecutorService implements Closeable {\n  private final Set<Future<?>> futures = Collections.newSetFromMap(new ConcurrentHashMap<>());\n  private final ExecutorService executorService;\n  private final boolean shutdownOnClose;\n  protected final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n\n  public CloseableExecutorService(ExecutorService executorService) {\n    this(executorService, false);\n  }\n\n  public CloseableExecutorService(ExecutorService executorService, boolean shutdownOnClose) {\n    this.executorService = executorService;\n    this.shutdownOnClose = shutdownOnClose;\n  }\n", "public class CloseableExecutorService implements Closeable {\n  private final Set<Future<?>> futures = Collections.newSetFromMap(new ConcurrentHashMap<>());\n  private final ExecutorService executorService;\n  private final boolean shutdownOnClose;\n  protected final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n\n  public CloseableExecutorService(ExecutorService executorService) {\n    this(executorService, false);\n  }\n\n  public CloseableExecutorService(ExecutorService executorService, boolean shutdownOnClose) {\n    this.executorService = executorService;\n    this.shutdownOnClose = shutdownOnClose;\n  }\n", "  public void awaitTermination(int timeout, TimeUnit unit) throws InterruptedException {\n    this.executorService.awaitTermination(timeout, unit);\n  }\n\n  protected class InternalFutureTask<T> extends FutureTask<T> {\n    private final RunnableFuture<T> task;\n\n    InternalFutureTask(RunnableFuture<T> task) {\n      super(task, null);\n      this.task = task;\n      futures.add(task);\n    }\n\n    protected void done() {\n      futures.remove(task);\n    }\n  }\n\n  /**\n   * Closes any tasks currently in progress.\n   */\n  @Override", "  public void close() {\n    isOpen.set(false);\n    Iterator<Future<?>> iterator = futures.iterator();\n    while (iterator.hasNext()) {\n      Future<?> future = iterator.next();\n      iterator.remove();\n      if (!future.isDone() && !future.isCancelled() && !future.cancel(true)) {\n        log.warn(\"Could not cancel {}\", future);\n      }\n    }\n    if (shutdownOnClose) {\n      executorService.shutdownNow();\n    }\n  }\n\n  /**\n   * Submits a Runnable task for execution and returns a Future\n   * representing that task.  Upon completion, this task may be\n   * taken or polled.\n   *\n   * @param task the task to submit\n   * @return a future to watch the task\n   */\n  public Future<?> submit(Runnable task) {\n    InternalFutureTask<Void> futureTask =\n        new InternalFutureTask<Void>(new FutureTask<Void>(task, null));\n    executorService.execute(futureTask);\n    return futureTask;\n  }\n", "    if (shutdownOnClose) {\n      executorService.shutdownNow();\n    }\n  }\n\n  /**\n   * Submits a Runnable task for execution and returns a Future\n   * representing that task.  Upon completion, this task may be\n   * taken or polled.\n   *\n   * @param task the task to submit\n   * @return a future to watch the task\n   */\n  public Future<?> submit(Runnable task) {\n    InternalFutureTask<Void> futureTask =\n        new InternalFutureTask<Void>(new FutureTask<Void>(task, null));\n    executorService.execute(futureTask);\n    return futureTask;\n  }\n", "  public void shutdown() {\n    this.executorService.shutdown();\n  }\n\n}\n"]}
{"filename": "src/main/java/com/github/germanosin/kafka/leader/tasks/Task.java", "chunked_list": ["package com.github.germanosin.kafka.leader.tasks;\n\npublic interface Task extends Runnable, AutoCloseable {\n  boolean isAlive();\n\n  boolean isStarted();\n}\n"]}
