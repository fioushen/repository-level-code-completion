{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/JaxrsRateLimiterTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.notNullValue;\n\nimport jakarta.enterprise.context.RequestScoped;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\n", "import jakarta.ws.rs.Path;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;", "import io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class JaxrsRateLimiterTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addAsResource(new StringAsset(\"quarkus.rate-limiter.buckets.group1.limits[0].permitted-uses: 1\\n\" +\n                            \"quarkus.rate-limiter.buckets.group1.limits[0].period: 1S\"), \"application.properties\"));\n\n    @Test", "    public void status429IsReturnedIfQuotaIsExceeded() {\n\n        given()\n                .when()\n                .get(\"/test\")\n                .then()\n                .statusCode(200)\n                .body(is(\"LIMITED\"));\n\n        given()\n                .when().get(\"/test\")\n                .then()\n                .statusCode(429)\n                .header(\"Retry-After\", is(notNullValue()));\n\n    }\n\n    @RequestScoped\n    @Path(\"/test\")", "    public static class RateLimitedMethods {\n\n        @GET\n        @RateLimited(bucket = \"group1\", identityResolver = IpResolver.class)\n        public String limitedByIp() {\n            return \"LIMITED\";\n        }\n\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/MissingConfigTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport jakarta.enterprise.context.ApplicationScoped;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;", "import org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class MissingConfigTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setExpectedException(IllegalStateException.class)\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class));\n\n    @Test", "    public void shouldNeverBeReached() {\n        fail();\n    }\n\n    @ApplicationScoped\n    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"group1\")\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n    }\n}\n", "        public String limited() {\n            return \"LIMITED\";\n        }\n\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/RateLimiterTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.context.ContextNotActiveException;\nimport jakarta.inject.Inject;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;", "import org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkiverse.bucket4j.runtime.RateLimitException;\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;", "import io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class RateLimiterTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addClass(RateLimitedClass.class)\n                    .addAsResource(\n                            new StringAsset(\"quarkus.rate-limiter.buckets.annotated-method.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-method.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-class.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-class.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.shared: false\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.shared-method.shared: true\\n\" +\n                                    \"quarkus.rate-limiter.buckets.shared-method.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.shared-method.limits[0].period: 1S\\n\"),\n                            \"application.properties\"));\n\n    @Inject\n    RateLimitedMethods methods;\n    @Inject\n    RateLimitedClass clazz;\n\n    @Test", "    public void rateLimitExceptionIsThrownIfQuotaIsExceededForLevelMethodAnnotation() {\n        methods.limited();\n        RateLimitException rateLimitException = Assertions.assertThrows(RateLimitException.class, () -> methods.limited());\n        assertThat(rateLimitException.getWaitTimeInMilliSeconds())\n                .isBetween(800L, 1000L);\n    }\n\n    @Test\n    public void quotaIsIsolatedIfSharingIsDisabled() {\n        methods.isolated();\n        Assertions.assertDoesNotThrow(() -> methods.isolated(\"param\"));\n    }\n\n    @Test", "    public void quotaIsIsolatedIfSharingIsDisabled() {\n        methods.isolated();\n        Assertions.assertDoesNotThrow(() -> methods.isolated(\"param\"));\n    }\n\n    @Test\n    public void quotaIsSharedIfSharingIsEnabled() {\n        methods.shared();\n        Assertions.assertThrows(RateLimitException.class, () -> methods.otherShared());\n    }\n\n    @Test", "    public void rateLimitExceptionIsThrownIfQuotaIsExceededForClassMethodAnnotation() {\n        clazz.limited();\n        RateLimitException rateLimitException = Assertions.assertThrows(RateLimitException.class, () -> clazz.limited());\n        assertThat(rateLimitException.getWaitTimeInMilliSeconds())\n                .isBetween(800L, 1000L);\n    }\n\n    @Test\n    public void contextNotActiveExceptionIsThrownIfIpResolverIsUsedOutsideRequestContext() {\n        Assertions.assertThrows(ContextNotActiveException.class, () -> methods.limitedByIp());\n    }\n\n    @ApplicationScoped", "    public void contextNotActiveExceptionIsThrownIfIpResolverIsUsedOutsideRequestContext() {\n        Assertions.assertThrows(ContextNotActiveException.class, () -> methods.limitedByIp());\n    }\n\n    @ApplicationScoped\n    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"annotated-method\")\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"isolated-method\")", "        public String limited() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"isolated-method\")\n        public String isolated() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"isolated-method\")\n        public String isolated(String param) {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"shared-method\")", "        public String isolated(String param) {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"shared-method\")\n        public String shared() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"shared-method\")\n        public String otherShared() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"annotated-method\", identityResolver = IpResolver.class)", "        public String otherShared() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"annotated-method\", identityResolver = IpResolver.class)\n        public String limitedByIp() {\n            return \"LIMITED\";\n        }\n\n    }\n\n    @ApplicationScoped\n    @RateLimited(bucket = \"annotated-class\")", "    public static class RateLimitedClass {\n        public String limited() {\n            return \"LIMITED\";\n        }\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/Bucket4jDevModeTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkus.test.QuarkusDevModeTest;\n\npublic class Bucket4jDevModeTest {\n\n    // Start hot reload (DevMode) test with your extension loaded\n    @RegisterExtension\n    static final QuarkusDevModeTest devModeTest = new QuarkusDevModeTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class));\n\n    @Test", "import io.quarkus.test.QuarkusDevModeTest;\n\npublic class Bucket4jDevModeTest {\n\n    // Start hot reload (DevMode) test with your extension loaded\n    @RegisterExtension\n    static final QuarkusDevModeTest devModeTest = new QuarkusDevModeTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class));\n\n    @Test\n    public void writeYourOwnDevModeTest() {\n        // Write your dev mode tests here - see the testing extension guide https://quarkus.io/guides/writing-extensions#testing-hot-reload for more information\n        Assertions.assertTrue(true, \"Add dev mode assertions to \" + getClass().getName());\n    }\n}\n", "    public void writeYourOwnDevModeTest() {\n        // Write your dev mode tests here - see the testing extension guide https://quarkus.io/guides/writing-extensions#testing-hot-reload for more information\n        Assertions.assertTrue(true, \"Add dev mode assertions to \" + getClass().getName());\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/BucketPodsTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;", "import org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.github.bucket4j.BucketConfiguration;\nimport io.quarkiverse.bucket4j.runtime.BucketPod;\nimport io.quarkiverse.bucket4j.runtime.BucketPodStorage;\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver;", "import io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class BucketPodsTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addClass(RateLimitedClass.class)\n                    .addAsResource(new StringAsset(\n                            \"quarkus.rate-limiter.buckets.annotated-method.shared: true\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-method.limits[0].permitted-uses: 10\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-method.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-method.limits[1].permitted-uses: 100\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-method.limits[1].period: 5M\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-class.shared: true\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-class.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.annotated-class.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.shared: false\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.isolated-method.limits[0].period: 1S\\n\"),\n                            \"application.properties\"));\n\n    @Inject\n    BucketPodStorage storage;\n\n    @Test", "    public void podIsCorrectlyCreatedForAnnotatedMethods() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedMethods.class.getMethod(\"limited\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getId()).isEqualTo(\"annotated-method\");\n        BucketConfiguration configuration = pod.getConfiguration();\n        assertThat(configuration.getBandwidths())\n                .hasSize(2);\n        assertThat(configuration.getBandwidths()[0].getCapacity())\n                .isEqualTo(10L);\n        assertThat(configuration.getBandwidths()[0].getRefillPeriodNanos())\n                .isEqualTo(1000_000_000L);\n        assertThat(configuration.getBandwidths()[1].getCapacity())\n                .isEqualTo(100L);\n        assertThat(configuration.getBandwidths()[1].getRefillPeriodNanos())\n                .isEqualTo(300_000_000_000L);\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(ConstantResolver.class);\n    }\n\n    @Test", "    public void podIsCorrectlyCreatedForIsolatedMethods() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedMethods.class.getMethod(\"isolatedMethod\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getId()).isEqualTo(\"isolated-method-1867211146\");\n    }\n\n    @Test\n    public void podIsCorrectlyCreatedForAnnotatedClass() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedClass.class.getMethod(\"limited\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getId()).isEqualTo(\"annotated-class\");\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(ConstantResolver.class);\n        pod = storage.getBucketPod(RateLimitedClass.class.getMethod(\"limitedAnnotated\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getId()).isEqualTo(\"annotated-method\");\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(ConstantResolver.class);\n    }\n\n    @ApplicationScoped", "    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"annotated-method\")\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"isolated-method\")\n        public String isolatedMethod() {\n            return \"LIMITED\";\n        }\n\n    }\n\n    @ApplicationScoped\n    @RateLimited(bucket = \"annotated-class\")", "        public String isolatedMethod() {\n            return \"LIMITED\";\n        }\n\n    }\n\n    @ApplicationScoped\n    @RateLimited(bucket = \"annotated-class\")\n    public static class RateLimitedClass {\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"annotated-method\")", "    public static class RateLimitedClass {\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"annotated-method\")\n        public String limitedAnnotated() {\n            return \"LIMITED\";\n        }\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/DisabledRateLimiterTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;", "import org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class DisabledRateLimiterTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addAsResource(new StringAsset(\n                            \"quarkus.rate-limiter.enabled: false\\n\" +\n                                    \"quarkus.rate-limiter.buckets.group1.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.group1.limits[0].period: 1S\"),\n                            \"application.properties\"));\n\n    @Inject\n    RateLimitedMethods methods;\n\n    @Test", "public class DisabledRateLimiterTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addAsResource(new StringAsset(\n                            \"quarkus.rate-limiter.enabled: false\\n\" +\n                                    \"quarkus.rate-limiter.buckets.group1.limits[0].permitted-uses: 1\\n\" +\n                                    \"quarkus.rate-limiter.buckets.group1.limits[0].period: 1S\"),\n                            \"application.properties\"));\n\n    @Inject\n    RateLimitedMethods methods;\n\n    @Test", "    public void rateLimitExceptionIsNotThrownIfRateLimiterIsDisabled() {\n        methods.limited();\n        assertThat(methods.limited()).isEqualTo(\"LIMITED\");\n    }\n\n    @ApplicationScoped\n    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"group1\")\n        public String limited() {\n            return \"LIMITED\";\n        }\n\n    }\n}\n", "        public String limited() {\n            return \"LIMITED\";\n        }\n\n    }\n}\n"]}
{"filename": "deployment/src/test/java/io/quarkiverse/bucket4j/test/IdentityResolverTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.test;\n\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\n\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;", "import org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport io.quarkiverse.bucket4j.runtime.BucketPod;\nimport io.quarkiverse.bucket4j.runtime.BucketPodStorage;\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;", "import io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\nimport io.quarkus.test.QuarkusUnitTest;\n\npublic class IdentityResolverTest {\n\n    // Start unit test with your extension loaded\n    @RegisterExtension\n    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()\n            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n                    .addClass(TestIdentityResolver.class)\n                    .addClass(RateLimitedMethods.class)\n                    .addAsResource(new StringAsset(\n                            \"quarkus.rate-limiter.buckets.by-annotation.limits[0].permitted-uses: 10\\n\" +\n                                    \"quarkus.rate-limiter.buckets.by-annotation.limits[0].period: 1S\\n\" +\n                                    \"quarkus.rate-limiter.buckets.by-config.identity-resolver: io.quarkiverse.bucket4j.test.IdentityResolverTest$TestIdentityResolver\\n\"\n                                    +\n                                    \"quarkus.rate-limiter.buckets.by-config.limits[0].permitted-uses: 10\\n\" +\n                                    \"quarkus.rate-limiter.buckets.by-config.limits[0].period: 1S\\n\"),\n                            \"application.properties\"));\n\n    @Inject\n    BucketPodStorage storage;\n\n    @Test", "    public void identityResolverCanBeConfiguredViaAnnotation() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedMethods.class.getMethod(\"byAnnotation\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(TestIdentityResolver.class);\n    }\n\n    @Test\n    public void identityResolverCanBeConfiguredViaConfig() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedMethods.class.getMethod(\"byConfig\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(TestIdentityResolver.class);\n    }\n\n    @Singleton", "    public void identityResolverCanBeConfiguredViaConfig() throws NoSuchMethodException {\n        BucketPod pod = storage.getBucketPod(RateLimitedMethods.class.getMethod(\"byConfig\"));\n        assertThat(pod).isNotNull();\n        assertThat(pod.getIdentityResolver())\n                .isNotNull()\n                .isOfAnyClassIn(TestIdentityResolver.class);\n    }\n\n    @Singleton\n    public static class TestIdentityResolver implements IdentityResolver {\n\n        @Override", "    public static class TestIdentityResolver implements IdentityResolver {\n\n        @Override\n        public String getIdentityKey() {\n            return \"TEST\";\n        }\n    }\n\n    @ApplicationScoped\n    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"by-annotation\", identityResolver = TestIdentityResolver.class)", "    public static class RateLimitedMethods {\n\n        @RateLimited(bucket = \"by-annotation\", identityResolver = TestIdentityResolver.class)\n        public String byAnnotation() {\n            return \"LIMITED\";\n        }\n\n        @RateLimited(bucket = \"by-config\")\n        public String byConfig() {\n            return \"LIMITED\";\n        }\n    }\n\n}\n", "        public String byConfig() {\n            return \"LIMITED\";\n        }\n    }\n\n}\n"]}
{"filename": "deployment/src/main/java/io/quarkiverse/bucket4j/deployment/Bucket4jProcessor.java", "chunked_list": ["package io.quarkiverse.bucket4j.deployment;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.ws.rs.Priorities;\n\nimport org.jboss.jandex.AnnotationInstance;", "\nimport org.jboss.jandex.AnnotationInstance;\nimport org.jboss.jandex.AnnotationTarget;\nimport org.jboss.jandex.AnnotationValue;\nimport org.jboss.jandex.DotName;\nimport org.jboss.jandex.MethodInfo;\n\nimport io.quarkiverse.bucket4j.runtime.BucketPodStorage;\nimport io.quarkiverse.bucket4j.runtime.BucketPodStorageRecorder;\nimport io.quarkiverse.bucket4j.runtime.DefaultProxyManagerProducer;", "import io.quarkiverse.bucket4j.runtime.BucketPodStorageRecorder;\nimport io.quarkiverse.bucket4j.runtime.DefaultProxyManagerProducer;\nimport io.quarkiverse.bucket4j.runtime.MethodDescription;\nimport io.quarkiverse.bucket4j.runtime.RateLimitException;\nimport io.quarkiverse.bucket4j.runtime.RateLimitExceptionMapper;\nimport io.quarkiverse.bucket4j.runtime.RateLimited;\nimport io.quarkiverse.bucket4j.runtime.RateLimitedInterceptor;\nimport io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;", "import io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\nimport io.quarkiverse.bucket4j.runtime.resolver.IpResolver;\nimport io.quarkus.arc.deployment.AdditionalBeanBuildItem;\nimport io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;\nimport io.quarkus.arc.deployment.SyntheticBeanBuildItem;\nimport io.quarkus.arc.deployment.UnremovableBeanBuildItem;\nimport io.quarkus.deployment.Capabilities;\nimport io.quarkus.deployment.Capability;\nimport io.quarkus.deployment.annotations.BuildProducer;\nimport io.quarkus.deployment.annotations.BuildStep;", "import io.quarkus.deployment.annotations.BuildProducer;\nimport io.quarkus.deployment.annotations.BuildStep;\nimport io.quarkus.deployment.annotations.ExecutionTime;\nimport io.quarkus.deployment.annotations.Record;\nimport io.quarkus.deployment.builditem.FeatureBuildItem;\nimport io.quarkus.resteasy.common.spi.ResteasyJaxrsProviderBuildItem;\nimport io.quarkus.resteasy.reactive.spi.ExceptionMapperBuildItem;\n\nclass Bucket4jProcessor {\n\n    public static final DotName RATE_LIMITED_INTERCEPTOR = DotName.createSimple(RateLimitedInterceptor.class.getName());", "class Bucket4jProcessor {\n\n    public static final DotName RATE_LIMITED_INTERCEPTOR = DotName.createSimple(RateLimitedInterceptor.class.getName());\n    public static final DotName RATE_LIMITED = DotName.createSimple(RateLimited.class.getName());\n    public static final DotName IDENTITY_RESOLVER = DotName.createSimple(IdentityResolver.class.getName());\n\n    private static final String FEATURE = \"bucket4j\";\n\n    @BuildStep\n    FeatureBuildItem feature() {\n        return new FeatureBuildItem(FEATURE);\n    }\n\n    @BuildStep\n    AdditionalBeanBuildItem caffeineProxyManager() {\n        return AdditionalBeanBuildItem.unremovableOf(DefaultProxyManagerProducer.class);\n    }\n\n    @BuildStep\n    AdditionalBeanBuildItem interceptorBinding() {\n        return AdditionalBeanBuildItem.unremovableOf(RateLimitedInterceptor.class);\n    }\n\n    @BuildStep\n    AdditionalBeanBuildItem constantResolver() {\n        return AdditionalBeanBuildItem.unremovableOf(ConstantResolver.class);\n    }\n\n    @BuildStep\n    void exceptionMapper(BuildProducer<ResteasyJaxrsProviderBuildItem> resteasyJaxrsProviderBuildItemBuildProducer,\n            BuildProducer<ExceptionMapperBuildItem> exceptionMapperBuildItemBuildProducer) {\n\n        resteasyJaxrsProviderBuildItemBuildProducer\n                .produce(new ResteasyJaxrsProviderBuildItem(RateLimitExceptionMapper.class.getName()));\n        exceptionMapperBuildItemBuildProducer\n                .produce(new ExceptionMapperBuildItem(RateLimitExceptionMapper.class.getName(),\n                        RateLimitException.class.getName(), Priorities.USER + 100, false));\n\n    }\n\n    @BuildStep\n    void ipResolver(Capabilities capabilities, BuildProducer<AdditionalBeanBuildItem> additionalBeans) {", "        if (capabilities.isPresent(Capability.VERTX_HTTP)) {\n            additionalBeans.produce(AdditionalBeanBuildItem.unremovableOf(IpResolver.class));\n        }\n    }\n\n    @BuildStep\n    UnremovableBeanBuildItem unremovableIdentityResolvers() {\n        return UnremovableBeanBuildItem.beanTypes(IDENTITY_RESOLVER);\n    }\n\n    @BuildStep\n    @Record(ExecutionTime.STATIC_INIT)\n    void gatherRateLimitCheck(BeanArchiveIndexBuildItem beanArchiveBuildItem,\n            BuildProducer<SyntheticBeanBuildItem> syntheticBeans,\n            BucketPodStorageRecorder recorder) {\n\n        Collection<AnnotationInstance> instances = beanArchiveBuildItem.getIndex().getAnnotations(RATE_LIMITED);\n", "        for (AnnotationInstance instance : instances) {\n            AnnotationTarget target = instance.target();\n            if (target.kind() == AnnotationTarget.Kind.METHOD) {\n                MethodInfo methodInfo = target.asMethod();\n                recorder.registerMethod(createDescription(methodInfo),\n                        instance.value(\"bucket\").asString(), getIdentityResolver(instance));\n            }\n        }\n\n        for (AnnotationInstance instance : instances) {\n            AnnotationTarget target = instance.target();", "        for (AnnotationInstance instance : instances) {\n            AnnotationTarget target = instance.target();\n            if (target.kind() == AnnotationTarget.Kind.CLASS && !RATE_LIMITED_INTERCEPTOR.equals(target.asClass().name())) {\n                List<MethodInfo> methods = target.asClass().methods();\n                for (MethodInfo methodInfo : methods) {\n                    recorder.registerMethod(createDescription(methodInfo),\n                            instance.value(\"bucket\").asString(), getIdentityResolver(instance));\n                }\n            }\n        }\n\n        syntheticBeans.produce(\n                SyntheticBeanBuildItem.configure(BucketPodStorage.class)\n                        .scope(ApplicationScoped.class)\n                        .unremovable()\n                        .runtimeValue(recorder.create())\n                        .done());\n    }\n\n    private Optional<String> getIdentityResolver(AnnotationInstance instance) {\n        return Optional.ofNullable(instance.value(\"identityResolver\")).map(AnnotationValue::asString);\n    }\n\n    private MethodDescription createDescription(MethodInfo method) {\n        String[] params = new String[method.parametersCount()];", "        for (int i = 0; i < method.parametersCount(); ++i) {\n            params[i] = method.parameterType(i).name().toString();\n        }\n        return new MethodDescription(method.declaringClass().name().toString(), method.name(), params);\n    }\n\n}\n"]}
{"filename": "deployment/src/main/java/io/quarkiverse/bucket4j/deployment/devui/Bucket4jDevUIProcessor.java", "chunked_list": ["package io.quarkiverse.bucket4j.deployment.devui;\n\nimport java.util.Objects;\n\nimport io.github.bucket4j.BucketConfiguration;\nimport io.quarkus.deployment.IsDevelopment;\nimport io.quarkus.deployment.annotations.BuildProducer;\nimport io.quarkus.deployment.annotations.BuildStep;\nimport io.quarkus.devui.spi.page.CardPageBuildItem;\nimport io.quarkus.devui.spi.page.Page;", "import io.quarkus.devui.spi.page.CardPageBuildItem;\nimport io.quarkus.devui.spi.page.Page;\nimport io.quarkus.devui.spi.page.PageBuilder;\n\n/**\n * Dev UI card for displaying important details such as the Bucket4J library version.\n */\npublic class Bucket4jDevUIProcessor {\n\n    @BuildStep(onlyIf = IsDevelopment.class)\n    void createVersion(BuildProducer<CardPageBuildItem> cardPageBuildItemBuildProducer) {\n        final CardPageBuildItem card = new CardPageBuildItem();\n\n        final PageBuilder versionPage = Page.externalPageBuilder(\"Version\")\n                .icon(\"font-awesome-solid:bucket\")\n                .url(\"https://bucket4j.com/\")\n                .doNotEmbed()\n                .staticLabel(Objects.toString(BucketConfiguration.class.getPackage().getImplementationVersion(), \"8.2.0\"));\n        card.addPage(versionPage);\n\n        card.setCustomCard(\"qwc-bucket4j-card.js\");\n\n        cardPageBuildItemBuildProducer.produce(card);\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/MethodDescription.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Objects;\n\npublic class MethodDescription {\n    private final String className;\n    private final String methodName;\n    private final String[] parameterTypes;\n\n    private final int hashCode;\n\n    public MethodDescription(String className, String methodName, String[] parameterTypes) {\n        this.className = className;\n        this.methodName = methodName;\n        this.parameterTypes = parameterTypes;\n\n        this.hashCode = createHashCode();\n    }\n\n    private int createHashCode() {\n        int result = Objects.hash(className, methodName);\n        result = 31 * result + Arrays.hashCode(parameterTypes);\n        return result;\n    }\n", "    public String getClassName() {\n        return className;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public String[] getParameterTypes() {\n        return parameterTypes;\n    }\n\n    @Override", "    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        MethodDescription that = (MethodDescription) o;\n        return className.equals(that.className) &&\n                methodName.equals(that.methodName) &&\n                Arrays.equals(parameterTypes, that.parameterTypes);\n    }\n\n    @Override", "    public int hashCode() {\n        return hashCode;\n    }\n\n    public static MethodDescription ofMethod(Method method) {\n        return new MethodDescription(method.getDeclaringClass().getName(), method.getName(),\n                typesAsStrings(method.getParameterTypes()));\n    }\n\n    public static String[] typesAsStrings(Class<?>[] parameterTypes) {\n        String[] result = new String[parameterTypes.length];", "    public static String[] typesAsStrings(Class<?>[] parameterTypes) {\n        String[] result = new String[parameterTypes.length];\n        for (int i = 0; i < parameterTypes.length; i++) {\n            result[i] = parameterTypes[i].getName();\n        }\n        return result;\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/BucketPod.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport jakarta.enterprise.inject.spi.CDI;\n\nimport io.github.bucket4j.Bucket;\nimport io.github.bucket4j.BucketConfiguration;\nimport io.github.bucket4j.distributed.proxy.ProxyManager;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\n\npublic class BucketPod {\n\n    private final String id;\n    private final Class<? extends IdentityResolver> identityResolver;\n\n    public BucketPod(String id, BucketConfiguration configuration, Class<? extends IdentityResolver> identityResolver) {\n        this.id = id;\n        this.configuration = configuration;\n        this.identityResolver = identityResolver;\n    }\n\n    final BucketConfiguration configuration;\n", "\npublic class BucketPod {\n\n    private final String id;\n    private final Class<? extends IdentityResolver> identityResolver;\n\n    public BucketPod(String id, BucketConfiguration configuration, Class<? extends IdentityResolver> identityResolver) {\n        this.id = id;\n        this.configuration = configuration;\n        this.identityResolver = identityResolver;\n    }\n\n    final BucketConfiguration configuration;\n", "    public String getId() {\n        return this.id;\n    }\n\n    public BucketConfiguration getConfiguration() {\n        return this.configuration;\n    }\n\n    public IdentityResolver getIdentityResolver() {\n        return CDI.current().select(identityResolver).get();\n    }\n", "    public IdentityResolver getIdentityResolver() {\n        return CDI.current().select(identityResolver).get();\n    }\n\n    public Bucket getBucket(ProxyManager<String> proxyManager) {\n        return proxyManager.builder().build(getId() + \"_\" + getIdentityResolver().getIdentityKey(), getConfiguration());\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimitException.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\npublic class RateLimitException extends RuntimeException {\n\n    private final long waitTimeInMilliSeconds;\n\n    RateLimitException(long waitTimeInMilliSeconds) {\n        this.waitTimeInMilliSeconds = waitTimeInMilliSeconds;\n    }\n\n    public long getWaitTimeInMilliSeconds() {\n        return waitTimeInMilliSeconds;\n    }\n\n    /**\n     * Does not fill in the stack trace for this exception\n     * for performance reasons.\n     *\n     * @return this instance\n     * @see java.lang.Throwable#fillInStackTrace()\n     */\n    @Override", "    public long getWaitTimeInMilliSeconds() {\n        return waitTimeInMilliSeconds;\n    }\n\n    /**\n     * Does not fill in the stack trace for this exception\n     * for performance reasons.\n     *\n     * @return this instance\n     * @see java.lang.Throwable#fillInStackTrace()\n     */\n    @Override", "    public Throwable fillInStackTrace() {\n        return this;\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimitedInterceptor.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport jakarta.annotation.Priority;\nimport jakarta.inject.Inject;\nimport jakarta.interceptor.AroundInvoke;\nimport jakarta.interceptor.Interceptor;\nimport jakarta.interceptor.InvocationContext;\n\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n", "import org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport io.github.bucket4j.Bucket;\nimport io.github.bucket4j.ConsumptionProbe;\nimport io.github.bucket4j.distributed.proxy.ProxyManager;\n\n@RateLimited\n@Interceptor\n@Priority(Interceptor.Priority.LIBRARY_BEFORE)\npublic class RateLimitedInterceptor {\n\n    @Inject\n    BucketPodStorage bucketPodStorage;\n\n    @Inject\n    ProxyManager<String> proxyManager;\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.enabled\")\n    boolean enabled;\n\n    @AroundInvoke\n    Object around(InvocationContext context) throws Throwable {", "@Priority(Interceptor.Priority.LIBRARY_BEFORE)\npublic class RateLimitedInterceptor {\n\n    @Inject\n    BucketPodStorage bucketPodStorage;\n\n    @Inject\n    ProxyManager<String> proxyManager;\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.enabled\")\n    boolean enabled;\n\n    @AroundInvoke\n    Object around(InvocationContext context) throws Throwable {", "        if (!enabled) {\n            return context.proceed();\n        }\n        Bucket bucket = bucketPodStorage.getBucketPod(context.getMethod()).getBucket(proxyManager);\n        ConsumptionProbe consumptionProbe = bucket.tryConsumeAndReturnRemaining(1);\n        if (consumptionProbe.isConsumed()) {\n            return context.proceed();\n        }\n        throw new RateLimitException(consumptionProbe.getNanosToWaitForRefill() / 1000_000L);\n    }\n\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimiterRuntimeConfig.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.time.Duration;\n\nimport io.quarkus.runtime.annotations.ConfigPhase;\nimport io.quarkus.runtime.annotations.ConfigRoot;\nimport io.quarkus.runtime.configuration.DurationConverter;\nimport io.smallrye.config.ConfigMapping;\nimport io.smallrye.config.WithConverter;\nimport io.smallrye.config.WithDefault;", "import io.smallrye.config.WithConverter;\nimport io.smallrye.config.WithDefault;\n\n@ConfigMapping(prefix = \"quarkus.rate-limiter\")\n@ConfigRoot(phase = ConfigPhase.RUN_TIME)\npublic interface RateLimiterRuntimeConfig {\n\n    /**\n     * rate limiter will be completely disabled if false\n     */\n    @WithDefault(\"true\")\n    boolean enabled();\n\n    /**\n     * Maximum number of entries in the underlying cache\n     */\n    @WithDefault(\"1000\")\n    int maxSize();\n\n    /**\n     * Duration during which the bucket is kept after last refill if untouched\n     */\n    @WithDefault(\"1H\")\n    @WithConverter(DurationConverter.class)\n    Duration keepAfterRefill();\n\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimitExceptionMapper.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.ext.ExceptionMapper;\nimport jakarta.ws.rs.ext.Provider;\n\n@Provider\npublic class RateLimitExceptionMapper implements ExceptionMapper<RateLimitException> {\n\n    @Override\n    public Response toResponse(RateLimitException e) {\n        return Response.status(Response.Status.TOO_MANY_REQUESTS)\n                .header(\"Retry-After\", e.getWaitTimeInMilliSeconds() / 1000)\n                .build();\n    }\n}\n", "    public Response toResponse(RateLimitException e) {\n        return Response.status(Response.Status.TOO_MANY_REQUESTS)\n                .header(\"Retry-After\", e.getWaitTimeInMilliSeconds() / 1000)\n                .build();\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimiterConfig.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\n\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\nimport io.quarkus.runtime.annotations.ConfigDocMapKey;\nimport io.quarkus.runtime.annotations.ConfigGroup;\nimport io.quarkus.runtime.annotations.ConfigPhase;", "import io.quarkus.runtime.annotations.ConfigGroup;\nimport io.quarkus.runtime.annotations.ConfigPhase;\nimport io.quarkus.runtime.annotations.ConfigRoot;\nimport io.quarkus.runtime.configuration.DurationConverter;\nimport io.smallrye.config.ConfigMapping;\nimport io.smallrye.config.WithConverter;\nimport io.smallrye.config.WithDefault;\n\n@ConfigMapping(prefix = \"quarkus.rate-limiter\")\n@ConfigRoot(phase = ConfigPhase.BUILD_AND_RUN_TIME_FIXED)\npublic interface RateLimiterConfig {\n\n    /**\n     * represent a group of limit applied to a method\n     * identified by the bucket id\n     */\n    @ConfigDocMapKey(\"bucket-id\")\n    Map<String, Bucket> buckets();\n\n    /**\n     * represent one single bucket\n     */\n    @ConfigGroup\n    interface Bucket {\n\n        /**\n         * Identity resolver allow to segment the population.\n         * Each resolved identity key will have its own quota.\n         * this must be a valid CDI bean implementing IdentityResolver.\n         */\n        @WithDefault(\"io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver\")\n        String identityResolver();\n\n        /**\n         * limits enforced for this bucket\n         */\n        List<Limit> limits();\n\n        /**\n         * If true, permitted uses are shared for all methods using the same bucket id.\n         * If false, each method has its own quota.\n         */\n        @WithDefault(\"false\")\n        Boolean shared();\n    }\n\n    /**\n     * represent one single limit\n     */\n    @ConfigGroup\n    interface Limit {\n\n        /**\n         * Number of usage per period\n         */\n        int permittedUses();\n\n        /**\n         * evaluation period\n         */\n        @WithConverter(DurationConverter.class)\n        Duration period();\n    }\n}\n", "@ConfigMapping(prefix = \"quarkus.rate-limiter\")\n@ConfigRoot(phase = ConfigPhase.BUILD_AND_RUN_TIME_FIXED)\npublic interface RateLimiterConfig {\n\n    /**\n     * represent a group of limit applied to a method\n     * identified by the bucket id\n     */\n    @ConfigDocMapKey(\"bucket-id\")\n    Map<String, Bucket> buckets();\n\n    /**\n     * represent one single bucket\n     */\n    @ConfigGroup\n    interface Bucket {\n\n        /**\n         * Identity resolver allow to segment the population.\n         * Each resolved identity key will have its own quota.\n         * this must be a valid CDI bean implementing IdentityResolver.\n         */\n        @WithDefault(\"io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver\")\n        String identityResolver();\n\n        /**\n         * limits enforced for this bucket\n         */\n        List<Limit> limits();\n\n        /**\n         * If true, permitted uses are shared for all methods using the same bucket id.\n         * If false, each method has its own quota.\n         */\n        @WithDefault(\"false\")\n        Boolean shared();\n    }\n\n    /**\n     * represent one single limit\n     */\n    @ConfigGroup\n    interface Limit {\n\n        /**\n         * Number of usage per period\n         */\n        int permittedUses();\n\n        /**\n         * evaluation period\n         */\n        @WithConverter(DurationConverter.class)\n        Duration period();\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/DefaultProxyManagerProducer.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.time.Duration;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.inject.Produces;\n\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport com.github.benmanes.caffeine.cache.Caffeine;", "\nimport com.github.benmanes.caffeine.cache.Caffeine;\n\nimport io.github.bucket4j.caffeine.CaffeineProxyManager;\nimport io.github.bucket4j.distributed.proxy.ProxyManager;\nimport io.github.bucket4j.distributed.remote.RemoteBucketState;\nimport io.quarkus.arc.DefaultBean;\n\npublic class DefaultProxyManagerProducer {\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.max-size\")\n    int maxSize;\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.keep-after-refill\")\n    Duration keepAfterRefill;\n\n    @Produces\n    @DefaultBean\n    @ApplicationScoped\n    ProxyManager<String> proxyManager() {\n        Caffeine<String, RemoteBucketState> builder = (Caffeine) Caffeine.newBuilder().maximumSize(maxSize);\n        return new CaffeineProxyManager<>(builder, keepAfterRefill);\n    }\n}\n", "public class DefaultProxyManagerProducer {\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.max-size\")\n    int maxSize;\n\n    @ConfigProperty(name = \"quarkus.rate-limiter.keep-after-refill\")\n    Duration keepAfterRefill;\n\n    @Produces\n    @DefaultBean\n    @ApplicationScoped\n    ProxyManager<String> proxyManager() {\n        Caffeine<String, RemoteBucketState> builder = (Caffeine) Caffeine.newBuilder().maximumSize(maxSize);\n        return new CaffeineProxyManager<>(builder, keepAfterRefill);\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/BucketPodStorageRecorder.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport io.github.bucket4j.Bandwidth;\nimport io.github.bucket4j.BucketConfiguration;\nimport io.github.bucket4j.ConfigurationBuilder;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;", "import io.github.bucket4j.ConfigurationBuilder;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\nimport io.quarkus.runtime.RuntimeValue;\nimport io.quarkus.runtime.annotations.Recorder;\n\n@Recorder\npublic class BucketPodStorageRecorder {\n\n    private final RateLimiterConfig config;\n    Map<MethodDescription, BucketPod> pods = new HashMap<>();\n\n    public BucketPodStorageRecorder(RateLimiterConfig config) {\n        this.config = config;\n    }\n\n    private BucketPod getBucketPod(MethodDescription methodDescription, String key,\n            Optional<String> identityResolverClassName) {\n        RateLimiterConfig.Bucket bucketConfig = config.buckets().get(key);", "        if (bucketConfig == null) {\n            throw new IllegalStateException(\"missing limits config for \" + key);\n        }\n\n        ConfigurationBuilder builder = BucketConfiguration.builder();\n        for (RateLimiterConfig.Limit limit : bucketConfig.limits()) {\n            builder.addLimit(Bandwidth.simple(limit.permittedUses(), limit.period()));\n        }\n        String id = bucketConfig.shared() ? key : key + methodDescription.hashCode();\n        try {\n            return new BucketPod(id, builder.build(),\n                    (Class<? extends IdentityResolver>) Thread.currentThread().getContextClassLoader()\n                            .loadClass(identityResolverClassName.orElse(bucketConfig.identityResolver())));\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e);\n        }\n\n    }\n", "        try {\n            return new BucketPod(id, builder.build(),\n                    (Class<? extends IdentityResolver>) Thread.currentThread().getContextClassLoader()\n                            .loadClass(identityResolverClassName.orElse(bucketConfig.identityResolver())));\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e);\n        }\n\n    }\n\n    public void registerMethod(MethodDescription description,\n            String key, Optional<String> identityResolverClassName) {\n        pods.putIfAbsent(description, getBucketPod(description, key, identityResolverClassName));\n    }\n\n    public RuntimeValue<BucketPodStorage> create() {\n        return new RuntimeValue<>(methodDescription -> pods.get(methodDescription));\n    }\n}\n", "    public void registerMethod(MethodDescription description,\n            String key, Optional<String> identityResolverClassName) {\n        pods.putIfAbsent(description, getBucketPod(description, key, identityResolverClassName));\n    }\n\n    public RuntimeValue<BucketPodStorage> create() {\n        return new RuntimeValue<>(methodDescription -> pods.get(methodDescription));\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/BucketPodStorage.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport java.lang.reflect.Method;\n\npublic interface BucketPodStorage {\n\n    default BucketPod getBucketPod(Method method) {\n        return getBucketPod(MethodDescription.ofMethod(method));\n    }\n\n    BucketPod getBucketPod(MethodDescription methodDescription);\n\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/RateLimited.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport jakarta.enterprise.util.Nonbinding;", "\nimport jakarta.enterprise.util.Nonbinding;\nimport jakarta.interceptor.InterceptorBinding;\n\nimport io.quarkiverse.bucket4j.runtime.resolver.ConstantResolver;\nimport io.quarkiverse.bucket4j.runtime.resolver.IdentityResolver;\n\n@InterceptorBinding\n@Target({ METHOD, TYPE })\n@Retention(RUNTIME)", "@Target({ METHOD, TYPE })\n@Retention(RUNTIME)\npublic @interface RateLimited {\n\n    String DEFAULT_BUCKET = \"io.quarkiverse.bucket4j.runtime.RateLimited<DEFAULT>\";\n\n    /**\n     * This is the bucket identity for this method.\n     * A configuration key that hold the limits for this bucket must exist\n     * If multiple methods share the same bucket, the number of permitted uses", "     * A configuration key that hold the limits for this bucket must exist\n     * If multiple methods share the same bucket, the number of permitted uses\n     * is shared among all them\n     */\n    @Nonbinding\n    String bucket() default DEFAULT_BUCKET;\n\n    /**\n     * Identity resolver allow to segment the population.\n     * Each resolved identity key will have its own quota.", "     * Identity resolver allow to segment the population.\n     * Each resolved identity key will have its own quota.\n     * There are two provided strategies you can use:\n     * ConstantResolver, disable the segmentation completely\n     * IpResolver, segment by source Ip address\n     * Or you can implement a custom resolver, which must be a valid CDI bean\n     */\n    @Nonbinding\n    Class<? extends IdentityResolver> identityResolver() default ConstantResolver.class;\n", "    Class<? extends IdentityResolver> identityResolver() default ConstantResolver.class;\n\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/resolver/IdentityResolver.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime.resolver;\n\n/**\n * Identity resolver enable rate limit segmentation,\n * one distinct bucket will be created for each key\n */\npublic interface IdentityResolver {\n\n    String getIdentityKey();\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/resolver/IpResolver.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime.resolver;\n\nimport jakarta.enterprise.context.RequestScoped;\nimport jakarta.inject.Inject;\n\nimport io.vertx.ext.web.RoutingContext;\n\n/**\n * Using this resolver will enable rate limit segmentation by IP\n * For a given endpoint, each IP will have its own bucket", " * Using this resolver will enable rate limit segmentation by IP\n * For a given endpoint, each IP will have its own bucket\n * Vertx Http must be present in the project in order to use this\n */\n@RequestScoped\npublic class IpResolver implements IdentityResolver {\n    @Inject\n    RoutingContext context;\n\n    @Override\n    public String getIdentityKey() {\n        return context.request().remoteAddress().host();\n    }\n}\n", "    public String getIdentityKey() {\n        return context.request().remoteAddress().host();\n    }\n}\n"]}
{"filename": "runtime/src/main/java/io/quarkiverse/bucket4j/runtime/resolver/ConstantResolver.java", "chunked_list": ["package io.quarkiverse.bucket4j.runtime.resolver;\n\nimport jakarta.inject.Singleton;\n\n/**\n * Using this resolver will disable completely the rate limiting segmentation\n * For a given rate limited method, all requests will use the same bucket\n */\n@Singleton\npublic class ConstantResolver implements IdentityResolver {\n    private static final String KEY = \"io.quarkiverse.bucket4j.runtime.resolver.CONSTANT\";\n\n    @Override", "@Singleton\npublic class ConstantResolver implements IdentityResolver {\n    private static final String KEY = \"io.quarkiverse.bucket4j.runtime.resolver.CONSTANT\";\n\n    @Override\n    public String getIdentityKey() {\n        return KEY;\n    }\n}\n"]}
{"filename": "integration-tests/src/test/java/io/quarkiverse/bucket4j/it/Bucket4jResourceTest.java", "chunked_list": ["package io.quarkiverse.bucket4j.it;\n\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.Matchers.is;\n\nimport org.junit.jupiter.api.Test;\n\nimport io.quarkus.test.junit.QuarkusTest;\n\n@QuarkusTest\npublic class Bucket4jResourceTest {\n\n    @Test", "\n@QuarkusTest\npublic class Bucket4jResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n                .when().get(\"/bucket4j\")\n                .then()\n                .statusCode(200)\n                .body(is(\"Hello bucket4j\"));\n    }\n}\n"]}
{"filename": "integration-tests/src/test/java/io/quarkiverse/bucket4j/it/Bucket4jResourceIT.java", "chunked_list": ["package io.quarkiverse.bucket4j.it;\n\nimport io.quarkus.test.junit.QuarkusIntegrationTest;\n\n@QuarkusIntegrationTest\npublic class Bucket4jResourceIT extends Bucket4jResourceTest {\n}\n"]}
{"filename": "integration-tests/src/main/java/io/quarkiverse/bucket4j/it/Bucket4jResource.java", "chunked_list": ["/*\n* Licensed to the Apache Software Foundation (ASF) under one or more\n* contributor license agreements.  See the NOTICE file distributed with\n* this work for additional information regarding copyright ownership.\n* The ASF licenses this file to You under the Apache License, Version 2.0\n* (the \"License\"); you may not use this file except in compliance with\n* the License.  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*", "*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\npackage io.quarkiverse.bucket4j.it;\n", "package io.quarkiverse.bucket4j.it;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\n\n@Path(\"/bucket4j\")\n@ApplicationScoped\npublic class Bucket4jResource {\n    // add some rest methods here\n\n    @GET", "public class Bucket4jResource {\n    // add some rest methods here\n\n    @GET\n    public String hello() {\n        return \"Hello bucket4j\";\n    }\n}\n"]}
