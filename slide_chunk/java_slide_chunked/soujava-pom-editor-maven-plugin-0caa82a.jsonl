{"filename": "src/test/java/br/org/soujava/pomeditor/InvalidGroupIdArtifactIdArgs.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor;", "\npackage br.org.soujava.pomeditor;\n\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.ArgumentsProvider;\n\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.params.provider.Arguments.arguments;", "\nimport static org.junit.jupiter.params.provider.Arguments.arguments;\n\npublic class InvalidGroupIdArtifactIdArgs implements ArgumentsProvider {\n\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n        return Stream.of(\n                arguments(\n                        null, // groupId,\n                        null // artifactId,\n                ),\n                arguments(\n                        null, // groupId,\n                        \"artifactId\" // artifactId,\n                ),\n                arguments(\n                        \"groupId\", // groupId,\n                        null // artifactId,\n                ),\n                arguments(\n                        \"\", // groupId,\n                        \"\" // artifactId,\n                ),\n                arguments(\n                        \"\", // groupId,\n                        \"artifactId\" // artifactId,\n                ),\n                arguments(\n                        \"groupId\", // groupId,\n                        \"\" // artifactId,\n                )\n        );\n    }\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/CheckSum.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage br.org.soujava.pomeditor;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * Component to be used to get M5 checksum data from files", "/**\n * Component to be used to get M5 checksum data from files\n */\npublic interface CheckSum {\n\n    /**\n     * Return the MD5 checksum from given a file\n     * @param file file to be used in the MD5 calculation\n     * @return a string with the MD5 checksum\n     * @throws IOException {@see Files.readAllBytes(Path)}\n     * @throws NoSuchAlgorithmException {@see MessageDigest.getInstance(String)}\n     */\n    static String checksum(Path file) throws IOException, NoSuchAlgorithmException {\n        byte[] data = Files.readAllBytes(file);\n        byte[] hash = MessageDigest.getInstance(\"MD5\").digest(data);\n        String checksum = new BigInteger(1, hash).toString(16);\n        return checksum;\n    }\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/ValidDependenciesArgs.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor;", "\npackage br.org.soujava.pomeditor;\n\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.ArgumentsProvider;\n\nimport java.util.UUID;\nimport java.util.stream.Stream;\n", "import java.util.stream.Stream;\n\nimport static org.junit.jupiter.params.provider.Arguments.arguments;\n\npublic class ValidDependenciesArgs implements ArgumentsProvider {\n\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n        return Stream.of(\n                arguments(\n                        UUID.randomUUID().toString(), // groupId\n                        UUID.randomUUID().toString(), // artifactId\n                        UUID.randomUUID().toString(), // version\n                        null // artifactId,\n                ),\n                arguments(\n                        null, // groupId,\n                        \"artifactId\" // artifactId,\n                ),\n                arguments(\n                        \"groupId\", // groupId,\n                        null // artifactId,\n                ),\n                arguments(\n                        \"\", // groupId,\n                        \"\" // artifactId,\n                ),\n                arguments(\n                        \"\", // groupId,\n                        \"artifactId\" // artifactId,\n                ),\n                arguments(\n                        \"groupId\", // groupId,\n                        \"\" // artifactId,\n                )\n        );\n    }\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/mojo/CommitMojoTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;", "import org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.atLeast;\nimport static org.mockito.Mockito.atLeastOnce;", "import static org.mockito.Mockito.atLeast;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.verify;\n\n@ExtendWith(MockitoExtension.class)\nclass CommitMojoTest {\n\n    @Mock\n    Log log;\n", "    Log log;\n\n    @Mock\n    Consumer<Path> commitFunction;\n\n    @Test\n    void execute() throws MojoExecutionException, MojoFailureException {\n        var mojo = new CommitMojo();\n        mojo.setLog(log);\n        mojo.commitFunction = this.commitFunction;", "        mojo.setLog(log);\n        mojo.commitFunction = this.commitFunction;\n        mojo.execute();\n        verify(log, atLeast(2)).info(anyString());\n        verify(commitFunction, atLeastOnce()).accept(any(Path.class));\n    }\n}"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/mojo/GreetingMojoTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport br.org.soujava.pomeditor.mojo.GreetingMojo;\nimport org.apache.maven.plugin.logging.Log;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.Mock;", "import org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.verify;\n\n@ExtendWith(MockitoExtension.class)\nclass GreetingMojoTest {", "@ExtendWith(MockitoExtension.class)\nclass GreetingMojoTest {\n\n    @Mock\n    Log logger;\n\n    @Captor\n    ArgumentCaptor<String> output;\n\n    @Test", "\n    @Test\n    void shouldExecuteWithNoErrors() {\n        GreetingMojo mojo = newMojo();\n        mojo.username = \"Max\";\n        mojo.execute();\n        verify(logger, atLeastOnce()).info(output.capture());\n        assertEquals(\"Hi, Max!\", output.getValue());\n    }\n", "    }\n\n    private GreetingMojo newMojo() {\n        GreetingMojo mojo = new GreetingMojo();\n        mojo.setLog(logger);\n        return mojo;\n    }\n\n}", "}"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/mojo/RollbackMojoTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;", "import org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.atLeast;\nimport static org.mockito.Mockito.verify;", "import static org.mockito.Mockito.atLeast;\nimport static org.mockito.Mockito.verify;\n\n@ExtendWith(MockitoExtension.class)\nclass RollbackMojoTest {\n\n    @Mock\n    Log log;\n\n    @Mock", "\n    @Mock\n    Consumer<Path> rollbackFunction;\n\n    @Test\n    void execute() throws MojoExecutionException, MojoFailureException {\n        var mojo = new RollbackMojo();\n        mojo.setLog(log);\n        mojo.rollbackFunction = this.rollbackFunction;\n        mojo.execute();", "        mojo.rollbackFunction = this.rollbackFunction;\n        mojo.execute();\n        verify(log,atLeast(2)).info(anyString());\n        verify(rollbackFunction, atLeast(1)).accept(any(Path.class));\n    }\n}"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/mojo/AddDependencyMojoTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\n\nimport br.org.soujava.pomeditor.InvalidGroupIdArtifactIdArgs;\nimport br.org.soujava.pomeditor.api.Dependency;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.junit.jupiter.api.AfterEach;", "import org.apache.maven.plugin.logging.Log;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ArgumentsSource;\nimport org.mockito.ArgumentCaptor;", "import org.junit.jupiter.params.provider.ArgumentsSource;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;", "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;", "import java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;", "import static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\n@ExtendWith(MockitoExtension.class)\nclass AddDependencyMojoTest {\n\n    @Mock\n    BiConsumer<Path, Dependency> addDependencyCommand;\n\n    @Mock", "\n    @Mock\n    Log log;\n\n    @Mock\n    Function<Path, Boolean> backupFunction;\n\n    @Mock\n    Consumer<Path> rollbackFunction;\n", "    Consumer<Path> rollbackFunction;\n\n    @Captor\n    ArgumentCaptor<Path> targetPom;\n    @Captor\n    ArgumentCaptor<Dependency> dependencyToBeAdded;\n\n    Path tempDir;\n    Path pom;\n", "    Path pom;\n\n    @DisplayName(\"should return error when\")\n    @ParameterizedTest(name = \"groupId={0}, artifactId={1}\")\n    @ArgumentsSource(InvalidGroupIdArtifactIdArgs.class)\n    void shouldReturnErrorsForInvalidRequiredParameters(final String groupId,\n                                                        final String artifactId) {\n        Assertions.assertThrows(MojoExecutionException.class, () -> {\n            AddDependencyMojo mojo = newMojo();\n            mojo.gav = Arrays.stream(new String[]{groupId, artifactId})", "            AddDependencyMojo mojo = newMojo();\n            mojo.gav = Arrays.stream(new String[]{groupId, artifactId})\n                    .filter(Objects::nonNull)\n                    .collect(Collectors.joining(\":\"));\n            mojo.execute();\n        });\n\n        verify(backupFunction, never()).apply(any());\n        verify(rollbackFunction, never()).accept(any());\n    }", "        verify(rollbackFunction, never()).accept(any());\n    }\n\n    @Test\n    void shouldAddDependencyProperly() throws MojoExecutionException, MojoFailureException {\n\n        //Given\n        String expectedGroupId = \"groupId\";\n        String expectedArtifactId = \"artifactId\";\n        String expectedVersion = \"222\";", "        String expectedArtifactId = \"artifactId\";\n        String expectedVersion = \"222\";\n\n        AddDependencyMojo mojo = newMojo();\n        mojo.gav = expectedGroupId + \":\" + expectedArtifactId + \":\" + expectedVersion;\n        mojo.type = \"jar\";\n        mojo.classifier = \"classified\";\n        mojo.scope = \"compile\";\n\n", "\n\n        //When\n        mojo.execute();\n\n        //Then\n        verify(addDependencyCommand, atLeastOnce()).accept(targetPom.capture(), dependencyToBeAdded.capture());\n        verify(backupFunction, atLeastOnce()).apply(any(Path.class));\n        verify(rollbackFunction, never()).accept(any());\n        verify(log, atLeastOnce()).info(anyString());", "        verify(rollbackFunction, never()).accept(any());\n        verify(log, atLeastOnce()).info(anyString());\n\n        var addDependency = this.dependencyToBeAdded.getValue();\n        assertThat(targetPom.getValue()).isEqualTo(Path.of(mojo.pom));\n        assertThat(addDependency.getGroupId()).isEqualTo(expectedGroupId);\n        assertThat(addDependency.getArtifactId()).isEqualTo(expectedArtifactId);\n        assertThat(addDependency.getVersion()).isEqualTo(expectedVersion);\n        assertThat(addDependency.getType()).isEqualTo(mojo.type);\n        assertThat(addDependency.getClassifier()).isEqualTo(mojo.classifier);", "        assertThat(addDependency.getType()).isEqualTo(mojo.type);\n        assertThat(addDependency.getClassifier()).isEqualTo(mojo.classifier);\n        assertThat(addDependency.getScope()).isEqualTo(mojo.scope);\n\n    }\n\n    private AddDependencyMojo newMojo() {\n        AddDependencyMojo mojo = new AddDependencyMojo();\n        mojo.pom = this.pom.toString();\n        mojo.setLog(log);", "        mojo.pom = this.pom.toString();\n        mojo.setLog(log);\n        mojo.backupFunction = backupFunction;\n        mojo.rollbackFunction = rollbackFunction;\n        mojo.addDependencyCommand =\n                (path, dep) -> addDependencyCommand.accept(path, dep);\n        return mojo;\n    }\n\n", "\n\n    @BeforeEach\n    void createTempDirAndPom() throws IOException {\n        this.tempDir = Files.createTempDirectory(null);\n        this.log = mock(Log.class);\n        this.pom = newDummyPom();\n    }\n\n    private Path newDummyPom() throws IOException {", "\n    private Path newDummyPom() throws IOException {\n        Path pom = Files.createTempFile(tempDir, \"pom\", \".xml\");\n        Files.copy(Path.of(\"pom.xml\"), pom, StandardCopyOption.REPLACE_EXISTING);\n        return pom;\n    }\n\n    @AfterEach\n    void destroyTempDir() {\n        Optional.ofNullable(tempDir).ifPresent(tempDir -> delete(tempDir.toFile()));", "    void destroyTempDir() {\n        Optional.ofNullable(tempDir).ifPresent(tempDir -> delete(tempDir.toFile()));\n    }\n\n    void delete(File file) {\n        if (file.isDirectory()) {\n            Arrays.stream(file.listFiles()).forEach(this::delete);\n        }\n        file.delete();\n    }\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/it/RollbackMojoIT.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage br.org.soujava.pomeditor.it;\n", "package br.org.soujava.pomeditor.it;\n\nimport com.soebes.itf.jupiter.extension.MavenGoal;\nimport com.soebes.itf.jupiter.extension.MavenJupiterExtension;\nimport com.soebes.itf.jupiter.extension.MavenTest;\nimport com.soebes.itf.jupiter.maven.MavenExecutionResult;\nimport com.soebes.itf.jupiter.maven.MavenProjectResult;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;", "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport static br.org.soujava.pomeditor.CheckSum.checksum;\nimport static com.soebes.itf.extension.assertj.MavenExecutionResultAssert.assertThat;\n\n@MavenJupiterExtension", "\n@MavenJupiterExtension\n@MavenGoal(\"${project.groupId}:${project.artifactId}:${project.version}:rollback\")\nclass RollbackMojoIT {\n\n    String expectedChecksum;\n\n    @BeforeEach\n    void beforeEach(MavenProjectResult project) throws Exception {\n        Path backupPom = project.getTargetProjectDirectory().resolve(\"pom.xml.backup\");", "    void beforeEach(MavenProjectResult project) throws Exception {\n        Path backupPom = project.getTargetProjectDirectory().resolve(\"pom.xml.backup\");\n        expectedChecksum = checksum(backupPom);\n    }\n\n\n    @MavenTest\n    @DisplayName(\"reverting the changes - it will remove the backup file\")\n    void project_with_backup(MavenExecutionResult result) throws Exception {\n        assertThat(result).isSuccessful();", "    void project_with_backup(MavenExecutionResult result) throws Exception {\n        assertThat(result).isSuccessful();\n        Path baseDirectory = result.getMavenProjectResult().getTargetProjectDirectory();\n        Path pom = Path.of(baseDirectory.toString(), \"pom.xml\");\n        Path backupPom = Paths.get(baseDirectory.toString(), \"pom.xml.backup\");\n        Assertions.assertThat(backupPom).doesNotExist();\n        Assertions.assertThat(checksum(pom)).isEqualTo(expectedChecksum);\n    }\n}\n", "}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/it/AddDependencyMojoIT.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage br.org.soujava.pomeditor.it;\n", "package br.org.soujava.pomeditor.it;\n\nimport com.soebes.itf.jupiter.extension.MavenGoal;\nimport com.soebes.itf.jupiter.extension.MavenJupiterExtension;\nimport com.soebes.itf.jupiter.extension.MavenTest;\nimport com.soebes.itf.jupiter.extension.SystemProperty;\nimport com.soebes.itf.jupiter.maven.MavenExecutionResult;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.DisplayName;\nimport org.w3c.dom.Document;", "import org.junit.jupiter.api.DisplayName;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;", "import javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;", "import java.util.List;\nimport java.util.stream.Collectors;\n\nimport static com.soebes.itf.extension.assertj.MavenExecutionResultAssert.assertThat;\n\n@MavenJupiterExtension\n@MavenGoal(\"${project.groupId}:${project.artifactId}:${project.version}:add-dep\")\n@SystemProperty(value = \"gav\", content = AddDependencyMojoIT.orgJunitJupiterGav)\npublic class AddDependencyMojoIT {\n\n    static final String orgJunitJupiterGroupId = \"org.junit.jupiter\";\n    static final String junitJupiterArtifactId = \"junit-jupiter\";\n    static final String version5_9_0 = \"5.9.0\";\n    static final String orgJunitJupiterGav = orgJunitJupiterGroupId + \":\" + junitJupiterArtifactId + \":\" + version5_9_0;\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM without dependencies\")\n    void no_dependencies_declarated(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM with other dependencies\")\n    void with_other_dependencies(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already\")\n    void has_dependency_already(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already but with version higher\")\n    void has_dependency_but_with_version_higher(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already but with version higher\")\n    void has_dependency_but_with_version_lower(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    private static void shouldAddDependency(MavenExecutionResult result) throws XPathExpressionException {\n        assertThat(result)\n                .isSuccessful();\n        Path baseDir = result.getMavenProjectResult().getTargetProjectDirectory();\n        shouldHaveGeneratedBackFile(baseDir);\n        shouldAddDependency(baseDir, orgJunitJupiterGroupId, junitJupiterArtifactId, version5_9_0);\n    }\n\n    private static void shouldHaveGeneratedBackFile(Path baseDir) {\n        Path backup = Path.of(baseDir.toString(), \"pom.xml.backup\");\n        Assertions.assertThat(backup).exists();\n    }\n\n    private static void shouldAddDependency(Path baseDir, String groupId, String artifactId, String version) throws XPathExpressionException {\n\n        Path pom = Path.of(baseDir.toString(), \"pom.xml\");\n\n        Document doc = getDoc(pom);\n\n        String expression = xmlPathToGetDependencies(groupId, artifactId, version);\n\n        NodeList dependencies = findByXPath(doc, expression);\n\n        Assertions.assertThat(dependencies.getLength()).isEqualTo(1);\n    }\n\n\n    static final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n    static {", "public class AddDependencyMojoIT {\n\n    static final String orgJunitJupiterGroupId = \"org.junit.jupiter\";\n    static final String junitJupiterArtifactId = \"junit-jupiter\";\n    static final String version5_9_0 = \"5.9.0\";\n    static final String orgJunitJupiterGav = orgJunitJupiterGroupId + \":\" + junitJupiterArtifactId + \":\" + version5_9_0;\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM without dependencies\")\n    void no_dependencies_declarated(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM with other dependencies\")\n    void with_other_dependencies(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already\")\n    void has_dependency_already(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already but with version higher\")\n    void has_dependency_but_with_version_higher(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    @MavenTest\n    @DisplayName(\"adding given a dependency into a POM that has the dependency already but with version higher\")\n    void has_dependency_but_with_version_lower(MavenExecutionResult result) throws Exception {\n        shouldAddDependency(result);\n    }\n\n    private static void shouldAddDependency(MavenExecutionResult result) throws XPathExpressionException {\n        assertThat(result)\n                .isSuccessful();\n        Path baseDir = result.getMavenProjectResult().getTargetProjectDirectory();\n        shouldHaveGeneratedBackFile(baseDir);\n        shouldAddDependency(baseDir, orgJunitJupiterGroupId, junitJupiterArtifactId, version5_9_0);\n    }\n\n    private static void shouldHaveGeneratedBackFile(Path baseDir) {\n        Path backup = Path.of(baseDir.toString(), \"pom.xml.backup\");\n        Assertions.assertThat(backup).exists();\n    }\n\n    private static void shouldAddDependency(Path baseDir, String groupId, String artifactId, String version) throws XPathExpressionException {\n\n        Path pom = Path.of(baseDir.toString(), \"pom.xml\");\n\n        Document doc = getDoc(pom);\n\n        String expression = xmlPathToGetDependencies(groupId, artifactId, version);\n\n        NodeList dependencies = findByXPath(doc, expression);\n\n        Assertions.assertThat(dependencies.getLength()).isEqualTo(1);\n    }\n\n\n    static final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n    static {", "        try {\n            // optional, but recommended\n            // process XML securely, avoid attacks like XML External Entities (XXE)\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setIgnoringComments(false);\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static Document getDoc(Path path) {\n        // parse XML file", "        try {\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            return db.parse(path.toFile());\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (SAXException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static String xmlPathToGetDependencies(String groupId, String artifactId, String version) {\n        StringBuilder xpathExpression = new StringBuilder(\"/project/dependencies/dependency\");\n        List<String> attributes = new ArrayList<>();", "        if (groupId != null)\n            attributes.add(\"groupId=\\\"\" + groupId + \"\\\"\");\n        if (artifactId != null)\n            attributes.add(\"artifactId=\\\"\" + artifactId + \"\\\"\");\n        if (version != null)\n            attributes.add(\"version=\\\"\" + version + \"\\\"\");\n        if (!attributes.isEmpty()) {\n            xpathExpression.append(\"[\");\n            xpathExpression.append(attributes.stream().collect(Collectors.joining(\" and \")));\n            xpathExpression.append(\"]\");\n        }\n        return xpathExpression.toString();\n    }\n\n    private static NodeList findByXPath(Document doc, String xpathExpression) throws XPathExpressionException {\n        XPath xPath = XPathFactory.newInstance().newXPath();\n        NodeList dependencies = (NodeList) xPath.compile(xpathExpression).evaluate(doc, XPathConstants.NODESET);\n        return dependencies;\n    }\n\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/it/CommitMojoIT.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage br.org.soujava.pomeditor.it;\n", "package br.org.soujava.pomeditor.it;\n\nimport com.soebes.itf.jupiter.extension.MavenGoal;\nimport com.soebes.itf.jupiter.extension.MavenJupiterExtension;\nimport com.soebes.itf.jupiter.extension.MavenTest;\nimport com.soebes.itf.jupiter.maven.MavenExecutionResult;\nimport com.soebes.itf.jupiter.maven.MavenProjectResult;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;", "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport static br.org.soujava.pomeditor.CheckSum.checksum;\nimport static com.soebes.itf.extension.assertj.MavenExecutionResultAssert.assertThat;\n\n@MavenJupiterExtension", "\n@MavenJupiterExtension\n@MavenGoal(\"${project.groupId}:${project.artifactId}:${project.version}:commit\")\nclass CommitMojoIT {\n\n    String expectedChecksum;\n\n    @BeforeEach\n    void beforeEach(MavenProjectResult project) throws Exception {\n        Path pom = project.getTargetProjectDirectory().resolve(\"pom.xml\");", "    void beforeEach(MavenProjectResult project) throws Exception {\n        Path pom = project.getTargetProjectDirectory().resolve(\"pom.xml\");\n        expectedChecksum = checksum(pom);\n    }\n\n\n    @MavenTest\n    @DisplayName(\"committing the changes - it will remove the backup file\")\n    void project_with_backup(MavenExecutionResult result) throws Exception {\n        assertThat(result).isSuccessful();", "    void project_with_backup(MavenExecutionResult result) throws Exception {\n        assertThat(result).isSuccessful();\n        Path baseDirectory = result.getMavenProjectResult().getTargetProjectDirectory();\n        Path pom = Path.of(baseDirectory.toString(), \"pom.xml\");\n        Path backupPom = Paths.get(baseDirectory.toString(), \"pom.xml.backup\");\n        Assertions.assertThat(backupPom).doesNotExist();\n        Assertions.assertThat(checksum(pom)).isEqualTo(expectedChecksum);\n    }\n}\n", "}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/it/GreetingMojoIT.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage br.org.soujava.pomeditor.it;\n", "package br.org.soujava.pomeditor.it;\n\nimport com.soebes.itf.jupiter.extension.MavenGoal;\nimport com.soebes.itf.jupiter.extension.MavenJupiterExtension;\nimport com.soebes.itf.jupiter.extension.MavenTest;\nimport com.soebes.itf.jupiter.extension.SystemProperty;\nimport com.soebes.itf.jupiter.maven.MavenExecutionResult;\n\nimport static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;\n", "import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;\n\n@MavenJupiterExtension\nclass GreetingMojoIT {\n\n    @MavenTest\n    @MavenGoal(\"${project.groupId}:${project.artifactId}:${project.version}:hello\")\n    @SystemProperty(value = \"username\", content = \"Max\")\n    void hello(MavenExecutionResult result) {\n        assertThat(result)", "    void hello(MavenExecutionResult result) {\n        assertThat(result)\n                .isSuccessful()\n                .out()\n                .info().contains(\"Hi, Max!\");\n    }\n\n}\n", ""]}
{"filename": "src/test/java/br/org/soujava/pomeditor/api/PomCommitTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.security.NoSuchAlgorithmException;\n\nimport static br.org.soujava.pomeditor.CheckSum.checksum;", "\nimport static br.org.soujava.pomeditor.CheckSum.checksum;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass PomCommitTest extends BaseTest {\n\n    @Test", "\n    @Test\n    void shouldCommit() throws IOException, NoSuchAlgorithmException {\n\n        Path backup = newDummyBackup(pom);\n\n        String expectedCheckSum = checksum(pom);\n        assertNotEquals(expectedCheckSum, checksum(backup));\n\n        PomCommit.execute(pom);", "\n        PomCommit.execute(pom);\n\n        assertTrue(pom.toFile().exists());\n        assertFalse(backup.toFile().exists());\n\n        assertEquals(expectedCheckSum, checksum(pom));\n\n    }\n", "    }\n\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/api/BaseTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;", "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.UUID;\n\npublic abstract class BaseTest {\n\n    protected Path pom;\n    protected Path tempDir;\n\n    PomChange.PomChangeBuilder newPomChangeBuilder() {\n        return PomChange.builder()\n                .withLogger((string)->{})\n                .withPom(pom);\n    }\n\n    // utility methods\n\n    void modifyPomRandomly() throws IOException {\n        modifyPom(UUID.randomUUID().toString());\n    }\n\n    void modifyPom(String data) throws IOException {\n        Files.writeString(pom, data, StandardOpenOption.TRUNCATE_EXISTING);\n    }\n\n    Path newDummyPom() throws IOException {\n        Path pom = Files.createTempFile(tempDir, \"pom\", \".xml\");\n        Files.writeString(pom, UUID.randomUUID().toString(), StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);\n        return pom;\n    }\n\n    Path newDummyBackup(Path pom) throws IOException {\n        Path backupFile = PomChange.backupFileOf(pom);\n        Files.writeString(backupFile, UUID.randomUUID().toString(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);\n        return backupFile;\n    }\n\n    @BeforeEach\n    void createTempDirAndPom() throws IOException {\n        this.tempDir = Files.createTempDirectory(null);\n        this.pom = newDummyPom();\n    }\n\n    @AfterEach\n    void destroyTempDir() {\n        Optional.ofNullable(tempDir).ifPresent(tempDir -> delete(tempDir.toFile()));\n    }\n\n\n    void delete(File file) {", "        if (file.isDirectory()) {\n            Arrays.stream(file.listFiles()).forEach(this::delete);\n        }\n        file.delete();\n    }\n\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/api/PomRollbackTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.security.NoSuchAlgorithmException;\n\nimport static br.org.soujava.pomeditor.CheckSum.checksum;", "\nimport static br.org.soujava.pomeditor.CheckSum.checksum;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass PomRollbackTest extends BaseTest{\n\n    @Test", "\n    @Test\n    void shouldRollback() throws IOException, NoSuchAlgorithmException {\n\n        Path pom = newDummyPom();\n        Path backup = newDummyBackup(pom);\n\n        String expectedCheckSum = checksum(backup);\n        assertNotEquals(expectedCheckSum, checksum(pom));\n", "        assertNotEquals(expectedCheckSum, checksum(pom));\n\n        PomRollback.execute(pom);\n\n        assertTrue(pom.toFile().exists());\n        assertFalse(backup.toFile().exists());\n\n        assertEquals(expectedCheckSum, checksum(pom));\n\n    }", "\n    }\n\n}\n"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/api/PomChangeTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.security.NoSuchAlgorithmException;", "import java.nio.file.Path;\nimport java.security.NoSuchAlgorithmException;\n\nimport static br.org.soujava.pomeditor.CheckSum.checksum;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n", "import static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass PomChangeTest extends BaseTest {\n\n    @Nested\n    class WhenBackFileDoesNotExists {\n\n        Path backupPom;\n\n        @BeforeEach", "\n        @BeforeEach\n        void setup() throws IOException {\n            createTempDirAndPom();\n            this.backupPom = PomChange.backupFileOf(pom);\n            if (this.backupPom.toFile().exists())\n                this.backupPom.toFile().delete();\n        }\n\n        @Test\n        void shouldCreateBackup() throws Throwable {\n            var expectedCheckSum = checksum(pom);\n\n            newPomChangeBuilder().build()\n                    .execute(() -> {\n                        // do something here\n                    });\n            assertTrue(backupPom.toFile().exists());\n            assertEquals(expectedCheckSum, checksum(backupPom));\n        }\n\n        @Test\n        void shouldRollbackOnErrors() throws IOException, NoSuchAlgorithmException {\n            var expectedCheckSum = checksum(pom);\n\n            assertThrows(Throwable.class, () -> {\n                newPomChangeBuilder()\n                        .build().execute(() -> {\n                            modifyPomRandomly();\n                            throw new RuntimeException(\"forced error\");\n                        });\n            });\n            assertFalse(backupPom.toFile().exists());\n            assertEquals(expectedCheckSum, checksum(pom));\n        }\n    }\n\n\n    @Nested\n    class WhenBackFileAlreadyExists {\n\n        Path backupPom;\n\n        @BeforeEach\n        void setup() throws IOException {\n            createTempDirAndPom();\n            backupPom = newDummyBackup(pom);\n        }\n\n        @Test\n        void shouldNotCreateBackup() throws Throwable {\n\n            var expectedCheckSum = checksum(backupPom);\n\n            newPomChangeBuilder()\n                    .build()\n                    .execute(() -> {\n                        modifyPomRandomly();\n                    });\n\n            assertNotEquals(checksum(pom), checksum(backupPom));\n            assertEquals(expectedCheckSum, checksum(backupPom));\n        }\n\n        @Test\n        void shouldNotRollbackOnErrors() throws IOException, NoSuchAlgorithmException {\n            var expectedCheckSum = checksum(pom);\n\n            assertThrows(Throwable.class, () -> {\n                newPomChangeBuilder()\n                        .build().execute(() -> {\n                            modifyPomRandomly();\n                            throw new RuntimeException(\"forced error\");\n                        });\n            });\n\n            assertTrue(backupPom.toFile().exists());\n            assertNotEquals(expectedCheckSum, checksum(pom));\n        }\n\n    }\n\n\n}"]}
{"filename": "src/test/java/br/org/soujava/pomeditor/api/DependencyTest.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport br.org.soujava.pomeditor.InvalidGroupIdArtifactIdArgs;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ArgumentsSource;\n\nimport java.util.Arrays;", "\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nclass DependencyTest {\n\n    @DisplayName(\"should return error when\")\n    @ParameterizedTest(name = \"groupId={0}, artifactId={1}\")\n    @ArgumentsSource(InvalidGroupIdArtifactIdArgs.class)", "    @ParameterizedTest(name = \"groupId={0}, artifactId={1}\")\n    @ArgumentsSource(InvalidGroupIdArtifactIdArgs.class)\n    void shouldReturnErrors (final String groupId, final String artifactId) {\n        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n            var gav = Arrays.stream(new String[]{groupId, artifactId})\n                    .filter(Objects::nonNull)\n                    .collect(Collectors.joining(\":\"));\n            Dependency.ofGav(gav).build();\n        });\n", "        });\n\n        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n            Dependency.builder()\n                    .withGroupId(groupId)\n                    .withArtifactId(artifactId).build();\n        });\n    }\n\n", "\n\n    @DisplayName(\"should return error when\")\n    @ParameterizedTest(name = \"groupId={0}, artifactId={1}\")\n    @ArgumentsSource(InvalidGroupIdArtifactIdArgs.class)\n    void shouldReturnErrorsForInvalidRequiredParameters(final String groupId,\n                                                        final String artifactId) {\n        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n            var gav = Arrays.stream(new String[]{groupId, artifactId})\n                    .filter(Objects::nonNull)", "            var gav = Arrays.stream(new String[]{groupId, artifactId})\n                    .filter(Objects::nonNull)\n                    .collect(Collectors.joining(\":\"));\n            Dependency.ofGav(gav).build();\n        });\n\n        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n            Dependency.builder()\n                    .withGroupId(groupId)\n                    .withArtifactId(artifactId).build();", "                    .withGroupId(groupId)\n                    .withArtifactId(artifactId).build();\n        });\n    }\n\n}"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/mojo/GreetingMojo.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\n/**\n * Says \"Hi\" to the output\n */", " * Says \"Hi\" to the output\n */\n@Mojo(name = \"hello\")\npublic class GreetingMojo extends AbstractMojo {\n\n    @Parameter(property = \"username\")\n    String username;\n\n    @Override\n    public void execute() {\n\n        getLog().info(String.format(\"Hi, %s!\", username));\n\n    }\n}\n", "    public void execute() {\n\n        getLog().info(String.format(\"Hi, %s!\", username));\n\n    }\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/mojo/AddDependencyMojo.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport br.org.soujava.pomeditor.api.AddDependency;\nimport br.org.soujava.pomeditor.api.Dependency;\nimport br.org.soujava.pomeditor.api.PomChange;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Mojo;", "import org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;", "import java.util.function.Consumer;\nimport java.util.function.Function;\n\n/**\n * Mojo responsible to add a given dependency to a target POM\n * if such dependency is not declared\n * or the given dependency's version is greater than the existent at target POM\n */\n@Mojo(name = \"add-dep\")\npublic class AddDependencyMojo extends AbstractMojo {\n\n    @Parameter(property = \"gav\")\n    String gav;\n    @Parameter(property = \"type\")\n    String type;\n    @Parameter(property = \"classifier\")\n    String classifier;\n    @Parameter(property = \"scope\")\n    String scope;\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    BiConsumer<Path, Dependency> addDependencyCommand;\n\n    Function<Path, Boolean> backupFunction;\n\n    Consumer<Path> rollbackFunction;\n\n\n    @Override", "@Mojo(name = \"add-dep\")\npublic class AddDependencyMojo extends AbstractMojo {\n\n    @Parameter(property = \"gav\")\n    String gav;\n    @Parameter(property = \"type\")\n    String type;\n    @Parameter(property = \"classifier\")\n    String classifier;\n    @Parameter(property = \"scope\")\n    String scope;\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    BiConsumer<Path, Dependency> addDependencyCommand;\n\n    Function<Path, Boolean> backupFunction;\n\n    Consumer<Path> rollbackFunction;\n\n\n    @Override", "    public void execute() throws MojoExecutionException, MojoFailureException {\n\n        Path pomFile = Paths.get(pom);\n        Dependency dependency = buildDependency();\n        try {\n            getLog().info(String.format(\"trying to add the dependency: %s to the \\\"%s\\\" file...\", dependency, pomFile));\n\n            change(pomFile).execute(() -> dependencyCommand().accept(pomFile, dependency));\n\n            getLog().info(String.format(\"added the dependency: %s to the \\\"%s\\\" file.\", dependency, pomFile));\n        } catch (Throwable ex) {\n            throw new MojoFailureException(String.format(\"cannot add the dependency: %s to the \\\"%s\\\" file: %s\",\n                    dependency,\n                    pomFile,\n                    ex.getMessage()), ex);\n        }\n    }\n\n    private BiConsumer<Path, Dependency> dependencyCommand() {\n        return Optional\n                .ofNullable(this.addDependencyCommand)\n                .orElse(AddDependency::execute);\n    }\n\n    private PomChange change(Path pomFile) {\n        return PomChange\n                .builder()\n                .withLogger(getLog()::info)\n                .withPom(pomFile)\n                .withBackupFunction(backupFunction)\n                .withRollbackFunction(rollbackFunction)\n                .build();\n    }\n\n    private Dependency buildDependency() throws MojoExecutionException {", "        try {\n            return Dependency\n                    .ofGav(gav)\n                    .withType(type)\n                    .withClassifier(classifier)\n                    .withScope(scope)\n                    .build();\n        } catch (RuntimeException ex) {\n            throw new MojoExecutionException(ex.getMessage(), ex);\n        }\n    }\n\n\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/mojo/CommitMojo.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport br.org.soujava.pomeditor.api.PomCommit;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n", "import org.apache.maven.plugins.annotations.Parameter;\n\nimport java.nio.file.Path;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\n/**\n * Mojo responsible for committing the POM changes and removing the backup POM file\n */\n@Mojo(name = \"commit\")\npublic class CommitMojo extends AbstractMojo {\n\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    Consumer<Path> commitFunction;\n\n    @Override", " */\n@Mojo(name = \"commit\")\npublic class CommitMojo extends AbstractMojo {\n\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    Consumer<Path> commitFunction;\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        Path targetPom = Path.of(this.pom);", "    public void execute() throws MojoExecutionException, MojoFailureException {\n        Path targetPom = Path.of(this.pom);\n        try {\n            getLog().info(String.format(\"trying to commit the changes of the \\\"%s\\\" file...\", targetPom));\n            Optional.ofNullable(commitFunction)\n                    .orElse(PomCommit::execute)\n                    .accept(targetPom);\n            getLog().info(\"changes has been committed\");\n        } catch (RuntimeException ex) {\n            throw new MojoFailureException(\n                    String.format(\"cannot commit the file \\\"%s\\\": %s\", targetPom.toString(), ex.getMessage()),\n                    ex\n            );\n        }\n    }\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/mojo/RollbackMojo.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.mojo;", "\npackage br.org.soujava.pomeditor.mojo;\n\nimport br.org.soujava.pomeditor.api.PomRollback;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\n", "import org.apache.maven.plugins.annotations.Parameter;\n\nimport java.nio.file.Path;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\n/**\n * Restore the target POM file with the backup POM file\n */\n@Mojo(name = \"rollback\")\npublic class RollbackMojo extends AbstractMojo {\n\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    Consumer<Path> rollbackFunction;\n\n    @Override", " */\n@Mojo(name = \"rollback\")\npublic class RollbackMojo extends AbstractMojo {\n\n    @Parameter(property = \"pom\", defaultValue = \"pom.xml\")\n    String pom = \"pom.xml\";\n\n    Consumer<Path> rollbackFunction;\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        Path targetPom = Path.of(this.pom);", "    public void execute() throws MojoExecutionException, MojoFailureException {\n        Path targetPom = Path.of(this.pom);\n        try {\n            getLog().info(String.format(\"trying to revert the \\\"%s\\\" file...\", targetPom));\n            Optional.ofNullable(rollbackFunction)\n                    .orElse(PomRollback::execute)\n                    .accept(targetPom);\n            getLog().info(String.format(\"\\\"%s\\\" file has been recovered. Backup file was deleted successfully.\", targetPom));\n        } catch (RuntimeException ex) {\n            throw new MojoFailureException(\n                    String.format(\"cannot recover the \\\"%s\\\" file: %s\", targetPom,ex.getMessage()), ex);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/api/PomChange.java", "chunked_list": ["/*\n * Copyright 2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage br.org.soujava.pomeditor.api;\n", "package br.org.soujava.pomeditor.api;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n", "import java.util.function.Function;\n\n/**\n * Component responsible for POM changes with backup support\n */\npublic final class PomChange {\n\n    public static Path backupFileOf(Path pom) {\n        Objects.requireNonNull(pom, \"pom cannot be null\");\n        return Path.of(pom.toString() + \".backup\");\n    }\n\n    private final Path pom;\n    private final Consumer<String> logger;\n    private final Function<Path, Boolean> backupFunction;\n    private final Consumer<Path> rollbackFunction;\n\n    private PomChange(Path pom,\n                      Consumer<String> logger,\n                      Function<Path, Boolean> backupFunction,\n                      Consumer<Path> rollbackFunction) {\n        Objects.requireNonNull(pom, \"pom cannot be null\");\n        this.pom = pom;\n        this.logger = Optional.ofNullable(logger).orElse(System.out::println);\n        this.backupFunction = Optional.ofNullable(backupFunction).orElse(this::backup);\n        this.rollbackFunction = Optional.ofNullable(rollbackFunction).orElse(PomRollback::execute);\n    }\n", "    public static PomChangeBuilder builder() {\n        return new PomChangeBuilder();\n    }\n\n    public static class PomChangeBuilder {\n\n        private Path pom;\n        private Consumer<String> logger = System.out::println;\n        private Function<Path, Boolean> backupFunction;\n        private Consumer<Path> rollbackFunction;\n", "        public PomChangeBuilder withLogger(Consumer<String> logger) {\n            this.logger = logger;\n            return this;\n        }\n\n        public PomChangeBuilder withPom(Path pom) {\n            this.pom = pom;\n            return this;\n        }\n\n        public PomChangeBuilder withBackupFunction(Function<Path, Boolean> backupFunction) {\n            this.backupFunction = backupFunction;\n            return this;\n        }\n", "        public PomChangeBuilder withBackupFunction(Function<Path, Boolean> backupFunction) {\n            this.backupFunction = backupFunction;\n            return this;\n        }\n\n        public PomChangeBuilder withRollbackFunction(Consumer<Path> rollbackFunction) {\n            this.rollbackFunction = rollbackFunction;\n            return this;\n        }\n\n        public PomChange build() {\n            return new PomChange(this.pom, this.logger, this.backupFunction, this.rollbackFunction);\n        }\n\n    }\n\n    @FunctionalInterface", "        public PomChange build() {\n            return new PomChange(this.pom, this.logger, this.backupFunction, this.rollbackFunction);\n        }\n\n    }\n\n    @FunctionalInterface\n    public static interface Executable {\n        void execute() throws Throwable;\n    }\n", "    public void execute(Executable executable) throws Throwable {\n        boolean createdBackupFile = false;\n        try {\n            createdBackupFile = createBackupFileIfNeeded();\n            executable.execute();\n        } catch (Throwable ex) {\n            rollback(createdBackupFile);\n            throw ex;\n        }\n    }\n\n    private boolean createBackupFileIfNeeded() {\n        return Optional.ofNullable(this.backupFunction.apply(this.pom))\n                .orElse(Boolean.FALSE);\n    }\n\n    private void rollback(boolean isBackupOwner) {", "        if (isBackupOwner) {\n            this.rollbackFunction.accept(this.pom);\n        }\n    }\n\n    private Boolean backup(Path pom) {\n        Path backupFile = backupFileOf(pom);\n        if (!backupFile.toFile().exists()) {\n            try {\n                Files.copy(pom, backupFile);\n                logger.accept(String.format(\"Backup for '%s' created: '%s'\",\n                        pom.toAbsolutePath(),\n                        backupFile.toAbsolutePath()));\n                return true;\n            } catch (IOException e) {\n                throw new RuntimeException(\"failure during backup process:\" + e.getMessage(), e);\n            }\n        }\n        return false;\n    }\n\n}\n", "            try {\n                Files.copy(pom, backupFile);\n                logger.accept(String.format(\"Backup for '%s' created: '%s'\",\n                        pom.toAbsolutePath(),\n                        backupFile.toAbsolutePath()));\n                return true;\n            } catch (IOException e) {\n                throw new RuntimeException(\"failure during backup process:\" + e.getMessage(), e);\n            }\n        }\n        return false;\n    }\n\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/api/Dependency.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n/**\n * Represents a dependency to be added\n */\npublic final class Dependency {\n\n    /**\n     * Returns a {@link DependencyBuilder} instance\n     * @return a {@link DependencyBuilder}\n     */", " * Represents a dependency to be added\n */\npublic final class Dependency {\n\n    /**\n     * Returns a {@link DependencyBuilder} instance\n     * @return a {@link DependencyBuilder}\n     */\n    public static DependencyBuilder builder() {\n        return new DependencyBuilder();\n    }\n\n    /**\n     * Returns a {@link DependencyBuilder} based on a GAV - groupId:artifactId:version - parameter\n     * @return a {@link DependencyBuilder}\n     */", "    public static DependencyBuilder builder() {\n        return new DependencyBuilder();\n    }\n\n    /**\n     * Returns a {@link DependencyBuilder} based on a GAV - groupId:artifactId:version - parameter\n     * @return a {@link DependencyBuilder}\n     */\n    public static DependencyBuilder ofGav(String gav) {\n        DependencyBuilder builder = builder();\n        var gavValues = Arrays.stream(gav.split(\":\"))\n                .filter(Objects::nonNull)\n                .filter(item -> !item.isBlank())\n                .map(String::trim)\n                .collect(Collectors.toList());", "    public static DependencyBuilder ofGav(String gav) {\n        DependencyBuilder builder = builder();\n        var gavValues = Arrays.stream(gav.split(\":\"))\n                .filter(Objects::nonNull)\n                .filter(item -> !item.isBlank())\n                .map(String::trim)\n                .collect(Collectors.toList());\n        if (gavValues.size() >= 1)\n            builder.withGroupId(gavValues.get(0));\n        if (gavValues.size() >= 2)\n            builder.withArtifactId(gavValues.get(1));", "        if (gavValues.size() >= 2)\n            builder.withArtifactId(gavValues.get(1));\n        if (gavValues.size() >= 3)\n            builder.withVersion(gavValues.get(2));\n        return builder;\n    }\n\n    /**\n     * Dependency builder\n     */\n    public static class DependencyBuilder {\n\n        private String groupId;\n        private String artifactId;\n        private String version;\n        private String type;\n        private String classifier;\n        private String scope;\n\n        /**\n         * @param groupId groupId\n         * @return the same {@link DependencyBuilder} instance\n         */", "    public static class DependencyBuilder {\n\n        private String groupId;\n        private String artifactId;\n        private String version;\n        private String type;\n        private String classifier;\n        private String scope;\n\n        /**\n         * @param groupId groupId\n         * @return the same {@link DependencyBuilder} instance\n         */", "        public DependencyBuilder withGroupId(String groupId) {\n            this.groupId = groupId;\n            return this;\n        }\n\n        /**\n         * @param artifactId artifactId\n         * @return the same {@link DependencyBuilder} instance\n         */\n        public DependencyBuilder withArtifactId(String artifactId) {\n            this.artifactId = artifactId;\n            return this;\n        }\n\n        /**\n         * @param version version\n         * @return the same {@link DependencyBuilder} instance\n         */", "        public DependencyBuilder withArtifactId(String artifactId) {\n            this.artifactId = artifactId;\n            return this;\n        }\n\n        /**\n         * @param version version\n         * @return the same {@link DependencyBuilder} instance\n         */\n        public DependencyBuilder withVersion(String version) {\n            this.version = version;\n            return this;\n        }\n\n        /**\n         * @param type type\n         * @return the same {@link DependencyBuilder} instance\n         */", "        public DependencyBuilder withVersion(String version) {\n            this.version = version;\n            return this;\n        }\n\n        /**\n         * @param type type\n         * @return the same {@link DependencyBuilder} instance\n         */\n        public DependencyBuilder withType(String type) {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * @param classifier classifier\n         * @return the same {@link DependencyBuilder} instance\n         */", "        public DependencyBuilder withType(String type) {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * @param classifier classifier\n         * @return the same {@link DependencyBuilder} instance\n         */\n        public DependencyBuilder withClassifier(String classifier) {\n            this.classifier = classifier;\n            return this;\n        }\n\n        /**\n         * @param scope scope\n         * @return the same {@link DependencyBuilder} instance\n         */", "        public DependencyBuilder withClassifier(String classifier) {\n            this.classifier = classifier;\n            return this;\n        }\n\n        /**\n         * @param scope scope\n         * @return the same {@link DependencyBuilder} instance\n         */\n        public DependencyBuilder withScope(String scope) {\n            this.scope = scope;\n            return this;\n        }\n\n        /**\n         * @return a {@link Dependency} instance\n         */", "        public DependencyBuilder withScope(String scope) {\n            this.scope = scope;\n            return this;\n        }\n\n        /**\n         * @return a {@link Dependency} instance\n         */\n        public Dependency build() {\n            return new Dependency(groupId, artifactId, version, type, classifier, scope);\n        }\n    }\n\n    private final String groupId;\n    private final String artifactId;\n    private final String version;\n    private final String type;\n    private final String classifier;\n    private final String scope;\n\n    private Dependency(String groupId, String artifactId, String version, String type, String classifier, String scope) {", "        public Dependency build() {\n            return new Dependency(groupId, artifactId, version, type, classifier, scope);\n        }\n    }\n\n    private final String groupId;\n    private final String artifactId;\n    private final String version;\n    private final String type;\n    private final String classifier;\n    private final String scope;\n\n    private Dependency(String groupId, String artifactId, String version, String type, String classifier, String scope) {", "        if (groupId == null || groupId.isBlank())\n            throw new IllegalArgumentException(\"groupId must be provided\");\n\n        if (artifactId == null || artifactId.isBlank())\n            throw new IllegalArgumentException(\"artifactId must be provided\");\n\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n        this.type = type;\n        this.classifier = classifier;\n        this.scope = scope;\n    }\n\n    /**\n     * @return the groupId\n     */", "    public String getGroupId() {\n        return groupId;\n    }\n\n    /**\n     * @return artifactId\n     */\n    public String getArtifactId() {\n        return artifactId;\n    }\n\n    /**\n     * @return version\n     */", "    public String getVersion() {\n        return version;\n    }\n\n    /**\n     * @return type\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * @return classifier\n     */", "    public String getClassifier() {\n        return classifier;\n    }\n\n    /**\n     * @return scope\n     */\n    public String getScope() {\n        return scope;\n    }\n\n    @Override", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Dependency that = (Dependency) o;\n        return Objects.equals(groupId, that.groupId)\n                && Objects.equals(artifactId, that.artifactId)\n                && Objects.equals(version, that.version)\n                && Objects.equals(type, that.type)\n                && Objects.equals(classifier, that.classifier)\n                && Objects.equals(scope, that.scope);\n    }\n\n    @Override", "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        sb.append(\"groupId='\" + groupId + '\\'');\n        sb.append(\", artifactId='\" + artifactId + '\\'');\n        if (version != null)\n            sb.append(\", version='\" + version + '\\'');\n        if (type != null)\n            sb.append(\", type='\" + type + '\\'');\n        if (classifier != null)\n            sb.append(\", classifier='\" + classifier + '\\'');", "        if (classifier != null)\n            sb.append(\", classifier='\" + classifier + '\\'');\n        if (scope != null)\n            sb.append(\", scope='\" + scope + '\\'');\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(groupId, artifactId, version, type, classifier, scope);\n    }\n}\n", "    public int hashCode() {\n        return Objects.hash(groupId, artifactId, version, type, classifier, scope);\n    }\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/api/PomRollback.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Objects;\n\n/**", "\n/**\n * Service component responsible for the rollback logic\n */\npublic interface PomRollback {\n\n    /**\n     * Recovers the backup POM file replacing the given POM file\n     * @param pom target POM file\n     * @throws RuntimeException on any issue occurs during the rollback processing\n     */", "    public static void execute(Path pom) {\n        Objects.requireNonNull(pom, \"pom cannot be null\");\n        Path backupFile = PomChange.backupFileOf(pom);\n        if (backupFile.toFile().exists()) {\n            try {\n                Files.copy(backupFile, pom, StandardCopyOption.REPLACE_EXISTING);\n                backupFile.toFile().delete();\n            } catch (IOException e) {\n                throw new RuntimeException(\"error during rollback process: \" + e.getMessage(), e);\n            }\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/api/PomCommit.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage br.org.soujava.pomeditor.api;\n", "package br.org.soujava.pomeditor.api;\n\nimport java.nio.file.Path;\nimport java.util.Objects;\n\n/**\n * Service component responsible for the commit logic\n */\npublic interface PomCommit {\n\n    /**\n     * Confirms the changes of a given POM and deletes the backup POM file\n     *\n     * @param pom the target POM file\n     * @throws RuntimeException on any issue occurs during the rollback processing\n     */", "public interface PomCommit {\n\n    /**\n     * Confirms the changes of a given POM and deletes the backup POM file\n     *\n     * @param pom the target POM file\n     * @throws RuntimeException on any issue occurs during the rollback processing\n     */\n    public static void execute(final Path pom) {\n        Objects.requireNonNull(pom, \"pom cannot be null\");\n        Path backupFile = PomChange.backupFileOf(pom);", "    public static void execute(final Path pom) {\n        Objects.requireNonNull(pom, \"pom cannot be null\");\n        Path backupFile = PomChange.backupFileOf(pom);\n        if (backupFile.toFile().exists()) {\n            backupFile.toFile().delete();\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/br/org/soujava/pomeditor/api/AddDependency.java", "chunked_list": ["/*\n * Copyright 2023  the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage br.org.soujava.pomeditor.api;", "\npackage br.org.soujava.pomeditor.api;\n\nimport org.l2x6.pom.tuner.PomTransformer;\nimport org.l2x6.pom.tuner.model.Gavtcs;\n\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Optional;", "import java.util.List;\nimport java.util.Optional;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Collectors;\n\n/**\n * Command responsible for adding a dependency to a given pom\n */\npublic interface AddDependency {\n\n\n    /**\n     * Add a dependency informed by the {@link Dependency} instance into the target POM xml\n     *\n     * @param pom        it's the target POM xml\n     * @param dependency it's an {@link Dependency} instance\n     */\n    static void execute(Path pom, Dependency dependency) {\n        new PomTransformer(\n                pom,\n                StandardCharsets.UTF_8,\n                PomTransformer.SimpleElementWhitespace.AUTODETECT_PREFER_SPACE)\n                .transform(addOrUpdateDependencyIfNeeded(dependency));\n    }\n\n    private static PomTransformer.Transformation addOrUpdateDependencyIfNeeded(Dependency dependencyToBeAdded) {\n        return (document, context) -> {\n\n            Gavtcs dependency = toGavtcs(dependencyToBeAdded);\n\n            List<PomTransformer.NodeGavtcs> dependencies = context.getDependencies()\n                    .stream()\n                    .filter(nodeGavtcs -> nodeGavtcs.getGroupId().equals(dependency.getGroupId()))\n                    .filter(nodeGavtcs -> nodeGavtcs.getArtifactId().equals(dependency.getArtifactId()))\n                    .collect(Collectors.toList());\n\n            dependencies.stream().forEach(\n                    nodeGavtcs -> {\n\n                        BiConsumer<String, String> setValue = nodeChanger(nodeGavtcs);\n                        setValue.accept(\"version\", dependency.getVersion());\n                        setValue.accept(\"type\", dependency.getType());\n                        setValue.accept(\"classifier\", dependency.getClassifier());\n                        setValue.accept(\"scope\", dependency.getScope());\n\n                    });\n", "public interface AddDependency {\n\n\n    /**\n     * Add a dependency informed by the {@link Dependency} instance into the target POM xml\n     *\n     * @param pom        it's the target POM xml\n     * @param dependency it's an {@link Dependency} instance\n     */\n    static void execute(Path pom, Dependency dependency) {\n        new PomTransformer(\n                pom,\n                StandardCharsets.UTF_8,\n                PomTransformer.SimpleElementWhitespace.AUTODETECT_PREFER_SPACE)\n                .transform(addOrUpdateDependencyIfNeeded(dependency));\n    }\n\n    private static PomTransformer.Transformation addOrUpdateDependencyIfNeeded(Dependency dependencyToBeAdded) {\n        return (document, context) -> {\n\n            Gavtcs dependency = toGavtcs(dependencyToBeAdded);\n\n            List<PomTransformer.NodeGavtcs> dependencies = context.getDependencies()\n                    .stream()\n                    .filter(nodeGavtcs -> nodeGavtcs.getGroupId().equals(dependency.getGroupId()))\n                    .filter(nodeGavtcs -> nodeGavtcs.getArtifactId().equals(dependency.getArtifactId()))\n                    .collect(Collectors.toList());\n\n            dependencies.stream().forEach(\n                    nodeGavtcs -> {\n\n                        BiConsumer<String, String> setValue = nodeChanger(nodeGavtcs);\n                        setValue.accept(\"version\", dependency.getVersion());\n                        setValue.accept(\"type\", dependency.getType());\n                        setValue.accept(\"classifier\", dependency.getClassifier());\n                        setValue.accept(\"scope\", dependency.getScope());\n\n                    });\n", "            if (dependencies.isEmpty()) {\n                context.addDependencyIfNeeded(dependency, Gavtcs.scopeAndTypeFirstComparator());\n            }\n        };\n    }\n\n    private static Gavtcs toGavtcs(Dependency dependency) {\n        return new Gavtcs(\n                dependency.getGroupId(),\n                dependency.getArtifactId(),\n                dependency.getVersion(),\n                dependency.getType(),\n                dependency.getClassifier(),\n                dependency.getScope()\n        );\n    }\n\n    private static BiConsumer<String, String> nodeChanger(PomTransformer.NodeGavtcs nodeGavtcs) {\n        final PomTransformer.ContainerElement node = nodeGavtcs.getNode();\n\n        return (name, value) -> {\n            Optional<PomTransformer.ContainerElement> targetNode = node.childElementsStream()\n                    .filter(ch -> name.equals(ch.getNode().getLocalName()))\n                    .findFirst();", "            if (!targetNode.isPresent() && value == null) {\n                /* nothing to do */\n            } else if (!targetNode.isPresent()) {\n                node.addChildTextElement(name, value);\n            } else if (value == null) {\n                targetNode.get().remove(true, true);\n            } else {\n                targetNode.get().getNode().setTextContent(value);\n            }\n        };\n    }\n}\n"]}
