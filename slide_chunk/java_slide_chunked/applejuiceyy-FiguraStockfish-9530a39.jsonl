{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/StringReader.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\nimport org.jetbrains.annotations.Contract;\n\nimport java.util.ArrayList;\n\npublic class StringReader {\n    String string;\n    int pos = 0;\n    int consuming = 0;\n    ArrayList<String> expected = new ArrayList<>();\n\n    public StringReader(String str) {\n        string = str;\n    }\n", "    public String getRest() {\n        return string.substring(pos);\n    }\n\n    public int getPos() {\n        return pos;\n    }\n\n    public void setPos(int p) {\n        pos = p;\n    }\n", "    public void setPos(int p) {\n        pos = p;\n    }\n\n    public int find(String seq) {\n        return string.indexOf(seq, pos);\n    }\n\n    public boolean canRead(int length) {\n        return string.length() > pos + length - 1;\n    }\n", "    public boolean canRead(int length) {\n        return string.length() > pos + length - 1;\n    }\n\n    public boolean canRead() {\n        return canRead(1);\n    }\n\n    public int length() {\n        return string.length();\n    }\n", "    public int length() {\n        return string.length();\n    }\n\n    public boolean expect(String seq) {\n        String cutout = peek(seq.length());\n        expected.add(seq);\n        return cutout.equals(seq);\n    }\n\n    public void assert_(String seq) {", "    public void assert_(String seq) {\n        if (!expect(seq)) {\n            raise();\n        }\n        accept();\n    }\n\n    public void accept() {\n        pos += consuming;\n        consuming = 0;\n        expected.clear();\n    }\n", "    public String peek(int length) {\n        consuming = length;\n        return string.substring(pos, Math.min(length + pos, string.length()));\n    }\n\n    public void hint(String what) {\n        expected.add(what);\n    }\n\n    @Contract(\"->fail\")\n    public void raise() {\n        StringBuilder builder = new StringBuilder();\n        int maxsize = 0;\n\n        builder.append(\"Expected \");\n", "    public void raise() {\n        StringBuilder builder = new StringBuilder();\n        int maxsize = 0;\n\n        builder.append(\"Expected \");\n\n        for (int i = 0; i < expected.size(); i++) {\n            maxsize = Math.max(expected.get(i).length(), maxsize);\n            builder.append('\"');\n            builder.append(expected.get(i));\n            builder.append('\"');\n", "            if (i < expected.size() - 1) {\n                builder.append(\", \");\n            }\n        }\n\n        builder.append(\"... Got \");\n        String peek = peek(Math.max(maxsize, 10));\n        if (peek.length() == 0) {\n            builder.append(\"EOF\");\n        }\n        else {\n            builder.append(peek);\n            builder.append(\"... (\");\n            builder.append(string.length() - getPos());\n            builder.append(\" remaining)\");\n        }\n\n        builder.append(\" (string \\\"\");\n        builder.append(string);\n        builder.append(\"\\\")\");\n\n        throw new StockfishError.CommandSyntaxError(builder.toString());\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/Main.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.SearchResults;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.AnalysisTask;\n\nimport java.sql.Time;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // miscellaneous testing code\n        StockfishInstance inst = StockfishInstance.bind(\"./run/stockfish.exe\").get();\n        inst.setFEN(\"startpos\");\n        AnalysisTask r = inst.calculate()\n                .onUpdate(System.out::println);\n\n        CompletableFuture<SearchResults> f = r.start(\"\");\n\n        Thread.sleep(1000);\n\n        r.stop();\n\n        SearchResults results = f.get();\n\n        inst.close();\n    }\n}\n", "\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // miscellaneous testing code\n        StockfishInstance inst = StockfishInstance.bind(\"./run/stockfish.exe\").get();\n        inst.setFEN(\"startpos\");\n        AnalysisTask r = inst.calculate()\n                .onUpdate(System.out::println);\n\n        CompletableFuture<SearchResults> f = r.start(\"\");\n\n        Thread.sleep(1000);\n\n        r.stop();\n\n        SearchResults results = f.get();\n\n        inst.close();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/StockfishInstance.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.EngineInfo;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.AnalysisTask;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.ReadyProcessor;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.StockfishProcessor;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.UCICommandProcessor;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\n\nimport java.io.*;", "\nimport java.io.*;\nimport java.lang.ref.PhantomReference;\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class StockfishInstance {\n    static final ReferenceQueue<Object> refq = new ReferenceQueue<>();\n\n    private final Process process;\n    private final BufferedReader reader;\n    private final OutputStreamWriter writer;\n", "    public EngineInfo info = null;\n\n    static {\n        new Thread(() -> {\n            while(true) {\n                Cleaner<?> ref;\n                try {\n                    ref = (Cleaner<?>) refq.remove();\n                } catch (InterruptedException ignored) {\n                    continue;\n                }\n                ref.cleanup();\n            }\n        }, \"Stockfish Instance Cleaner\").start();\n    }\n\n    private StockfishInstance(Process process, BufferedReader reader, OutputStreamWriter writer) {\n        this.process = process;\n        this.reader = reader;\n        this.writer = writer;\n\n        new Cleaner<>(this, process::destroy);\n    }\n\n    static public CompletableFuture<StockfishInstance> bind(String cmd) {\n        return CompletableFuture.supplyAsync(() -> {\n            ProcessBuilder pb = new ProcessBuilder(cmd);\n", "            try {\n                Process process = pb.start();\n                Thread.sleep(100);\n                InputStream stream = process.getInputStream();\n                while(stream.available() > 0) stream.skip(1);\n\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n                OutputStreamWriter writer = new OutputStreamWriter(process.getOutputStream());\n                StockfishInstance si = new StockfishInstance(process, reader, writer);\n\n                try {\n                    si.info = si.getInfo().get(3000, TimeUnit.MILLISECONDS);\n                }\n                catch (TimeoutException exc) {\n                    process.destroy();\n                    throw new RuntimeException(\"Program is not UCI or Timeout\");\n                }\n                si.newGameHint().get();\n                return si;\n            } catch (ExecutionException e) {", "                try {\n                    si.info = si.getInfo().get(3000, TimeUnit.MILLISECONDS);\n                }\n                catch (TimeoutException exc) {\n                    process.destroy();\n                    throw new RuntimeException(\"Program is not UCI or Timeout\");\n                }\n                si.newGameHint().get();\n                return si;\n            } catch (ExecutionException e) {\n                if (e.getCause() instanceof StockfishError v) {\n                    throw v;\n                }\n                e.printStackTrace();\n                return null;\n            } catch (IOException | InterruptedException e) {\n                throw new StockfishError.ProcessExitedError();\n            }\n        });\n    }\n\n    public <T> CompletableFuture<T> command(String command, StockfishProcessor<T> processor) {\n        return CompletableFuture.supplyAsync(() -> {\n            synchronized (this) {", "                if (e.getCause() instanceof StockfishError v) {\n                    throw v;\n                }\n                e.printStackTrace();\n                return null;\n            } catch (IOException | InterruptedException e) {\n                throw new StockfishError.ProcessExitedError();\n            }\n        });\n    }\n\n    public <T> CompletableFuture<T> command(String command, StockfishProcessor<T> processor) {\n        return CompletableFuture.supplyAsync(() -> {\n            synchronized (this) {", "                try {\n                    writer.write(command);\n                    writer.write(\"\\n\");\n                    if (processor.shouldSendReadyOk()) {\n                        writer.write(\"isready\");\n                        writer.write(\"\\n\");\n                    }\n                    writer.flush();\n                } catch (IOException exception) {\n                    close();\n                    throw new StockfishError.ProcessExitedError();\n                }\n", "                while (true) {\n                    String line;\n                    try {\n                        line = reader.readLine();\n                    } catch (IOException e) {\n                        throw new StockfishError.ProcessExitedError();\n                    }\n                    if (line == null) {\n                        throw new StockfishError.ProcessExitedError();\n                    }\n                    if (line.length() != 0 && !processor.feed(new StringReader(line))) {\n                        return processor.build();\n                    }\n                }\n            }\n        });\n    }\n\n    public CompletableFuture<EngineInfo> getInfo() {\n        return command(\"uci\", new UCICommandProcessor());\n    }\n\n    public CompletableFuture<Void> setFEN(String fen, String moves) {\n        return command(String.format(\"position fen %s moves %s\", fen, moves), ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> setFEN(String fen) {\n        return command(String.format(\"position fen %s\", fen), ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> newGameHint() {\n        return command(\"ucinewgame\", ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> setOption(String name, String value) {\n        return command(String.format(\"setoption name %s value %s\", name, value), ReadyProcessor.INSTANCE);\n    }\n", "                    if (line.length() != 0 && !processor.feed(new StringReader(line))) {\n                        return processor.build();\n                    }\n                }\n            }\n        });\n    }\n\n    public CompletableFuture<EngineInfo> getInfo() {\n        return command(\"uci\", new UCICommandProcessor());\n    }\n\n    public CompletableFuture<Void> setFEN(String fen, String moves) {\n        return command(String.format(\"position fen %s moves %s\", fen, moves), ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> setFEN(String fen) {\n        return command(String.format(\"position fen %s\", fen), ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> newGameHint() {\n        return command(\"ucinewgame\", ReadyProcessor.INSTANCE);\n    }\n\n    public CompletableFuture<Void> setOption(String name, String value) {\n        return command(String.format(\"setoption name %s value %s\", name, value), ReadyProcessor.INSTANCE);\n    }\n", "    public AnalysisTask calculate() {\n        return new AnalysisTask(writer, this::command);\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n    static class Cleaner<O> extends PhantomReference<O> {\n        private final Runnable after;\n\n        public Cleaner(O referent, Runnable after) {\n            super(referent, refq);\n            this.after = after;\n        }\n", "        public void cleanup() {\n            this.after.run();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/data/PartialSearchInfo.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.data;\n\npublic record PartialSearchInfo(int depth, int nodes, String pv, String scoreCP, String scoreMate) {\n\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/data/SearchResults.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.data;\n\nimport org.jetbrains.annotations.Nullable;\n\npublic record SearchResults(String bestMove, @Nullable String ponder) {\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/data/EngineInfo.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.data;\n\nimport java.util.HashMap;\n\npublic record EngineInfo(String name, String author, HashMap<String, OptionEntry> options) {\n    public record OptionEntry(String type, String defaultValue, String min, String max) { }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/StringNode.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic class StringNode extends Node<StringNode>{\n    private final boolean canBeEmpty;\n\n    public StringNode(boolean canBeEmpty) {\n        super(StringParser::new);\n        this.canBeEmpty = canBeEmpty;\n    }\n\n    static class StringParser extends Node.NodeParser<StringNode> {\n        StringBuilder string = new StringBuilder();\n        String finished = null;\n\n        public StringParser(ParsingContext context, StringNode literalNode) {\n            super(context, literalNode);\n        }\n\n        @Override\n        boolean test(StringReader reader) {", "            if (node.canBeEmpty) {\n                return true;\n            }\n            reader.hint(\"not EOF\");\n            return reader.canRead();\n        }\n\n        @Override\n        void finish() {\n            finished = string.toString();\n            super.finish();\n        }\n\n        @Override", "        public void parse(StringReader reader) {\n            int p;\n            if (!reader.canRead()) {\n                finish();\n                return;\n            }\n            if (!string.isEmpty()) {\n                string.append(' ');\n            }\n            if((p = reader.find(\" \")) == -1) {\n                string.append(reader.getRest());\n                reader.setPos(reader.length());\n            }\n            else {\n                string.append(reader.peek(p - reader.getPos()));\n                reader.accept();\n                reader.peek(1);\n                reader.accept();\n            }\n        }\n\n        @Override", "            if((p = reader.find(\" \")) == -1) {\n                string.append(reader.getRest());\n                reader.setPos(reader.length());\n            }\n            else {\n                string.append(reader.peek(p - reader.getPos()));\n                reader.accept();\n                reader.peek(1);\n                reader.accept();\n            }\n        }\n\n        @Override", "        public String getParsed() {\n            return isFinished() ? finished : null;\n        }\n\n        @Override\n        public String representation() {\n            return \"[string]\";\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/ParsingContext.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\nimport org.luaj.vm2.ast.Str;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class ParsingContext {\n    public final StringReader reader;\n    private final HashMap<Node<?>, Node.NodeParser<?>> content = new HashMap<>();\n    ArrayList<Node<?>> stack = new ArrayList<>();\n    Holder<?> root;\n\n    public ParsingContext(StringReader reader, Holder<?> root) {\n        this.reader = reader;\n        this.root = root;\n    }\n", "public class ParsingContext {\n    public final StringReader reader;\n    private final HashMap<Node<?>, Node.NodeParser<?>> content = new HashMap<>();\n    ArrayList<Node<?>> stack = new ArrayList<>();\n    Holder<?> root;\n\n    public ParsingContext(StringReader reader, Holder<?> root) {\n        this.reader = reader;\n        this.root = root;\n    }\n", "    public boolean findCandidate() {\n        Holder<?> current = stack.isEmpty() ? root : stack.get(stack.size() - 1);\n\n        for (Node<?> child : current.children()) {\n            Node.NodeParser<?> parser = getParser(child);\n\n            if (!parser.isFinished() && parser.available() && parser.test(reader)) {\n                if (current instanceof Node<?> node) {\n                    getParser(node).finish();\n                }\n\n                stack.add(child);\n                return true;\n            }\n        }\n", "        if (current instanceof Node<?> node && !getParser(node).mustConsumeChildren()) {\n            // don't use the current one\n            for (int i = stack.size() - 2; i >= -1; i--) {\n                Holder<?> parent = i >= 0 ? stack.get(i) : root;\n\n                for (Node<?> child : parent.children()) {\n                    if (child != stack.get(i + 1)) {\n                        Node.NodeParser<?> parser = getParser(child);\n\n                        if (!parser.isFinished() && parser.available() && parser.test(reader)) {\n                            trimStack(i + 1);\n                            stack.add(child);\n                            return true;\n                        }\n                    }\n                }\n            }\n        }", "                        if (!parser.isFinished() && parser.available() && parser.test(reader)) {\n                            trimStack(i + 1);\n                            stack.add(child);\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        if (current instanceof Node<?> node) {\n            Node.NodeParser<?> parser = getParser(node);\n", "        if (current instanceof Node<?> node) {\n            Node.NodeParser<?> parser = getParser(node);\n\n            if (!parser.isFinished() && parser.test(reader)) {\n                return true;\n            }\n\n            parser.finish();\n        }\n\n        if (current instanceof Node<?> node && getParser(node).mustConsumeChildren()) {\n            reader.raise();\n        }\n\n        return false;\n    }\n\n    private void parseCandidate() {\n        Node.NodeParser<?> parser = getParser(stack.get(stack.size() - 1));\n        parser.parsing();\n        parser.parse(reader);\n    }\n", "        if (current instanceof Node<?> node && getParser(node).mustConsumeChildren()) {\n            reader.raise();\n        }\n\n        return false;\n    }\n\n    private void parseCandidate() {\n        Node.NodeParser<?> parser = getParser(stack.get(stack.size() - 1));\n        parser.parsing();\n        parser.parse(reader);\n    }\n", "    public void parse() {\n        while (findCandidate()) {\n            parseCandidate();\n        }\n    }\n\n    private void trimStack(int to) {\n        while(to < stack.size()) {\n            getParser(stack.get(stack.size() - 1)).finish();\n            stack.remove(stack.size() - 1);\n        }\n    }\n\n    public  <S extends Node<S>> Node.NodeParser<S> getParser(Node<S> node) {", "        if (!content.containsKey(node)) {\n            content.put(node, node.buildParser(this));\n        }\n\n        //noinspection unchecked\n        return (Node.NodeParser<S>) content.get(node);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/LiteralNode.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic class LiteralNode extends Node<LiteralNode> {\n    private final String name;\n\n    public LiteralNode(String name) {\n        super(LiteralParser::new);\n        this.name = name;\n    }\n\n    static class LiteralParser extends NodeParser<LiteralNode> {\n        public LiteralParser(ParsingContext context, LiteralNode literalNode) {\n            super(context, literalNode);\n        }\n\n        @Override\n        boolean test(StringReader reader) {\n            return reader.expect(node.name) && (!reader.canRead(node.name.length() + 1) || reader.expect(node.name + \" \"));\n        }\n\n        @Override", "        public void parse(StringReader reader) {\n            reader.assert_(node.name);\n            if (reader.canRead()) {\n                reader.assert_(\" \");\n            }\n            finish();\n        }\n\n        @Override\n        public String getParsed() {\n            return node.name;\n        }\n\n        @Override", "        public String getParsed() {\n            return node.name;\n        }\n\n        @Override\n        public String representation() {\n            return String.format(\"\\\"%s\\\"\", node.name);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/GreedyString.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic class GreedyString extends Node<GreedyString> {\n    public GreedyString() {\n        super(GreedyString.GreedyStringParser::new);\n    }\n\n    static class GreedyStringParser extends NodeParser<GreedyString> {\n        String collected;\n\n        public GreedyStringParser(ParsingContext context, GreedyString literalNode) {\n            super(context, literalNode);\n        }\n\n        @Override\n        boolean test(StringReader reader) {\n            return true;\n        }\n\n        @Override", "        public void parse(StringReader reader) {\n            collected = reader.getRest();\n            reader.setPos(reader.length());\n            finish();\n        }\n\n        @Override\n        public String getParsed() {\n            return collected;\n        }\n\n        @Override", "        public String representation() {\n            return \"[greedy]\";\n        }\n    }\n}"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/IntegerNode.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic class IntegerNode extends Node<IntegerNode> {\n    public IntegerNode() {\n        super(IntegerNode.IntegerParser::new);\n    }\n\n    static class IntegerParser extends NodeParser<IntegerNode> {\n        String parsed;\n        public IntegerParser(ParsingContext context, IntegerNode literalNode) {\n            super(context, literalNode);\n        }\n\n        String tryParse(StringReader reader) {\n            int p = reader.find(\" \");\n            String next;", "            if (p == -1) {\n                next = reader.getRest();\n            }\n            else {\n                next = reader.peek(p - reader.getPos());\n            }\n\n            if (next.matches(\"^-?[0-9]+$\")) {\n                return next;\n            }\n            reader.hint(\"An Integer\");\n            return null;\n        }\n\n        @Override\n        boolean test(StringReader reader) {\n            return tryParse(reader) != null;\n        }\n\n        @Override", "        public void parse(StringReader reader) {\n            parsed = tryParse(reader);\n            if (parsed != null) {\n                reader.accept();\n            }\n            if (reader.canRead()) {\n                reader.assert_(\" \");\n            }\n            finish();\n        }\n\n        @Override", "        public String getParsed() {\n            return parsed;\n        }\n\n        @Override\n        public String representation() {\n            return \"[integer]\";\n        }\n    }\n}"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/Restrictions.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport java.util.function.Predicate;\n\npublic class Restrictions {\n    private Restrictions() {}\n\n    static Predicate<ParsingContext> exclusive(Node<?> other) {\n        return context -> !context.getParser(other).wasParsing();\n    }\n\n", "    public static void mutuallyExclusive(Node<?> one, Node<?> other) {\n        one.restrict(exclusive(other));\n        other.restrict(exclusive(one));\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/Node.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\nimport org.apache.logging.log4j.util.BiConsumer;\nimport org.jetbrains.annotations.Contract;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiFunction;", "import java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic abstract class Node<S extends Node<S>> extends Holder<S> {\n    private final BiFunction<ParsingContext, S, NodeParser<S>> builder;\n    final List<Predicate<ParsingContext>> restrictions = new ArrayList<>(0);\n    final List<BiConsumer<String, ParsingContext>> completions = new ArrayList<>(0);\n    final List<Consumer<String>> scompletions = new ArrayList<>(0);\n    boolean mustConsumeChildren = false;\n\n    protected Node(BiFunction<ParsingContext, S, NodeParser<S>> builder) {\n        this.builder = builder;\n    }\n", "    public S restrict(Predicate<ParsingContext> restriction) {\n        restrictions.add(restriction);\n        return getThis();\n    }\n\n    public S complete(BiConsumer<String, ParsingContext> consumer) {\n        completions.add(consumer);\n        return getThis();\n    }\n\n    public S complete(Consumer<String> consumer) {\n        scompletions.add(consumer);\n        return getThis();\n    }\n", "    public S complete(Consumer<String> consumer) {\n        scompletions.add(consumer);\n        return getThis();\n    }\n\n    public S mustConsumeChild() {\n        mustConsumeChildren = true;\n        return getThis();\n    }\n\n    NodeParser<S> buildParser(ParsingContext context) {\n        return builder.apply(context, getThis());\n    }\n\n    @Contract(\"_ -> new\")\n    public static @NotNull LiteralNode literal(String name) {\n        return new LiteralNode(name);\n    }\n\n    @Contract(\" -> new\")\n    public static @NotNull Holder<?> root() {\n        return new Holder<>();\n    }\n\n    @Contract(\" -> new\")\n    public static @NotNull StringNode string() {\n        return new StringNode(false);\n    }\n\n    @Contract(\" -> new\")\n    public static @NotNull StringNode emptyString() {\n        return new StringNode(true);\n    }\n\n    @Contract(\" -> new\")\n    public static @NotNull GreedyString greedyString() {\n        return new GreedyString();\n    }\n\n    @Contract(\" -> new\")\n    public static @NotNull IntegerNode integer() {\n        return new IntegerNode();\n    }\n", "    public static abstract class NodeParser<S extends Node<S>> {\n        protected final ParsingContext context;\n        protected final S node;\n\n        private boolean finished = false;\n        private boolean parsing = false;\n\n        public NodeParser(ParsingContext context, S literalNode) {\n            this.context = context;\n            this.node = literalNode;\n        }\n\n        void finish() {\n            finished = true;\n            callCompletionHook();\n        }\n        void parsing() {\n            parsing = true;\n        }\n", "        public boolean isFinished() {\n            return finished;\n        }\n\n        boolean wasParsing() {\n            return parsing;\n        }\n\n        boolean mustConsumeChildren() {\n            return node.mustConsumeChildren;\n        }\n\n        void callCompletionHook() {\n            String parse = getParsed();", "            for (BiConsumer<String, ParsingContext> completion : node.completions) {\n                completion.accept(parse, context);\n            }\n            for (Consumer<String> scompletion : node.scompletions) {\n                scompletion.accept(parse);\n            }\n        }\n\n        boolean available() {\n            for (Predicate<ParsingContext> completion : node.restrictions) {\n                if (!completion.test(context)) {\n                    return false;\n                };\n            }\n            return true;\n        }\n\n        @Contract(pure = true)\n        abstract boolean test(StringReader reader);", "            for (Predicate<ParsingContext> completion : node.restrictions) {\n                if (!completion.test(context)) {\n                    return false;\n                };\n            }\n            return true;\n        }\n\n        @Contract(pure = true)\n        abstract boolean test(StringReader reader);\n        abstract public void parse(StringReader reader);", "        abstract public void parse(StringReader reader);\n        abstract public String getParsed();\n        abstract public String representation();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/StockfishError.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\npublic class StockfishError extends Error {\n    public StockfishError(String format) {\n        super(format);\n    }\n\n    public static class CommandSyntaxError extends StockfishError {\n        public CommandSyntaxError(String format) {\n            super(format);\n        }\n    }", "    public static class ProcessExitedError extends StockfishError {\n        public ProcessExitedError() {\n            super(\"Process Exited\");\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/tree/Holder.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.tree;\n\nimport org.jetbrains.annotations.Contract;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Holder<S extends Holder<S>> {\n    private final ArrayList<Node<?>> children = new ArrayList<>();\n\n    @Contract(\"_->this\")", "public class Holder<S extends Holder<S>> {\n    private final ArrayList<Node<?>> children = new ArrayList<>();\n\n    @Contract(\"_->this\")\n    public S with(Node<?> n) {\n        children.add(n);\n        return getThis();\n    }\n\n    public S getThis() {\n        //noinspection unchecked\n        return (S) this;\n    }\n\n    List<Node<?>> children() {\n        return Collections.unmodifiableList(children);\n    }\n}\n", "    public S getThis() {\n        //noinspection unchecked\n        return (S) this;\n    }\n\n    List<Node<?>> children() {\n        return Collections.unmodifiableList(children);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/processor/UCICommandProcessor.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.processor;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.EngineInfo;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.*;\n\nimport java.util.HashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class UCICommandProcessor implements StockfishProcessor<EngineInfo> {\n    String collectedName;\n    String collectedAuthor;\n\n    HashMap<String, EngineInfo.OptionEntry> options = new HashMap<>();\n\n    @Override", "\npublic class UCICommandProcessor implements StockfishProcessor<EngineInfo> {\n    String collectedName;\n    String collectedAuthor;\n\n    HashMap<String, EngineInfo.OptionEntry> options = new HashMap<>();\n\n    @Override\n    public boolean shouldSendReadyOk() {\n        return false;\n    }\n\n    @Override", "    public boolean shouldSendReadyOk() {\n        return false;\n    }\n\n    @Override\n    public boolean feed(StringReader line) {\n        if (line.expect(\"uciok\")) {\n            return false;\n        }\n\n        LiteralNode nameNode;\n        LiteralNode authorNode;\n        LiteralNode optionNode;\n\n        AtomicReference<String> optionName = new AtomicReference<>();\n        AtomicReference<String> optionType = new AtomicReference<>();\n        AtomicReference<String> defaultValue = new AtomicReference<>();\n        AtomicReference<String> maxValue = new AtomicReference<>();\n        AtomicReference<String> minValue = new AtomicReference<>();\n\n\n        Holder<?> idTree = Node.root()", "                .with(Node.literal(\"id\")\n                        .mustConsumeChild()\n                        .with(nameNode = Node.literal(\"name\")\n                                .mustConsumeChild()\n                                .with(Node.string().complete(s -> collectedName = s))\n                                .restrict(c -> collectedName == null)\n                        )\n                        .with(authorNode = Node.literal(\"author\")\n                                .mustConsumeChild()\n                                .with(Node.string().complete(s -> collectedAuthor = s))\n                                .restrict(c -> collectedAuthor == null)\n                        )\n                )", "                                .with(Node.string().complete(s -> collectedAuthor = s))\n                                .restrict(c -> collectedAuthor == null)\n                        )\n                )\n                .with(\n                        optionNode = Node.literal(\"option\")\n                                .restrict(c -> collectedName != null && collectedAuthor != null)\n                                .with(\n                                        Node.literal(\"name\")\n                                                .mustConsumeChild()\n                                                .with(Node.string().complete(optionName::set))\n                                )", "                                                .with(Node.string().complete(optionName::set))\n                                )\n                                .with(\n                                        Node.literal(\"type\")\n                                                .mustConsumeChild()\n                                                .with(Node.literal(\"check\").complete(optionType::set))\n                                                .with(Node.literal(\"spin\").complete(optionType::set))\n                                                .with(Node.literal(\"combo\").complete(optionType::set))\n                                                .with(Node.literal(\"button\").complete(optionType::set))\n                                                .with(Node.literal(\"string\").complete(optionType::set))\n                                )", "                                                .with(Node.literal(\"button\").complete(optionType::set))\n                                                .with(Node.literal(\"string\").complete(optionType::set))\n                                )\n                                .with(Node.literal(\"default\").mustConsumeChild().with(Node.emptyString().complete(defaultValue::set)))\n                                .with(Node.literal(\"min\").mustConsumeChild().with(Node.string().complete(minValue::set)))\n                                .with(Node.literal(\"max\").mustConsumeChild().with(Node.string().complete(maxValue::set)))\n                                .with(Node.literal(\"var\").mustConsumeChild().with(Node.string()))\n                );\n\n        Restrictions.mutuallyExclusive(nameNode, authorNode);\n\n        ParsingContext ctx = new ParsingContext(line, idTree);\n\n        ctx.parse();\n", "        if (ctx.getParser(optionNode).isFinished()) {\n            if (optionName.get() == null) {\n                throw new RuntimeException();\n            }\n            if (optionType.get() == null) {\n                throw new RuntimeException();\n            }\n\n            options.put(\n                    optionName.get(),\n                    new EngineInfo.OptionEntry(\n                            optionType.get(),\n                            defaultValue.get(),\n                            minValue.get(),\n                            maxValue.get()\n                    )\n            );\n        }\n\n\n        return true;\n    }\n\n    @Override", "    public EngineInfo build() {\n        return new EngineInfo(collectedName, collectedAuthor, options);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/processor/StockfishProcessor.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.processor;\n\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic interface StockfishProcessor<T> {\n    boolean shouldSendReadyOk();\n    boolean feed(StringReader reader);\n    T build();\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/processor/ReadyProcessor.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.processor;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\n\npublic class ReadyProcessor implements StockfishProcessor<Void> {\n    public static final ReadyProcessor INSTANCE = new ReadyProcessor();\n\n    @Override\n    public boolean shouldSendReadyOk() {\n        return true;\n    }\n\n    @Override", "    public boolean shouldSendReadyOk() {\n        return true;\n    }\n\n    @Override\n    public boolean feed(StringReader reader) {\n        return !reader.expect(\"readyok\");\n    }\n\n    @Override\n    public Void build() {\n        return null;\n    }\n}\n", "    public Void build() {\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/stockfish/processor/AnalysisTask.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.stockfish.processor;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.StringReader;\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.PartialSearchInfo;\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.SearchResults;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.Holder;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.Node;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.ParsingContext;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\nimport org.jetbrains.annotations.Contract;", "import com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\nimport org.jetbrains.annotations.Contract;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;", "import java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\n\npublic class AnalysisTask implements StockfishProcessor<SearchResults> {\n    private final OutputStreamWriter writer;\n    private CompletableFuture<SearchResults> results = null;\n    private List<Consumer<PartialSearchInfo>> infoSubs = new ArrayList<>();\n    private String collectedBestMove;\n    private String collectedPonder;\n    private BiFunction<String, StockfishProcessor<SearchResults>, CompletableFuture<SearchResults>> command;\n\n    public AnalysisTask(OutputStreamWriter writer, BiFunction<String, StockfishProcessor<SearchResults>, CompletableFuture<SearchResults>> command) {\n        this.writer = writer;\n        this.command = command;\n    }\n\n    @Override", "    public boolean shouldSendReadyOk() {\n        return false;\n    }\n\n    @Override\n    public boolean feed(StringReader reader) {\n        AtomicReference<String> bestMove = new AtomicReference<>();\n        AtomicReference<String> ponderMove = new AtomicReference<>();\n\n        AtomicReference<String> depth = new AtomicReference<>();\n        AtomicReference<String> seldepth = new AtomicReference<>();\n        AtomicReference<String> time = new AtomicReference<>();\n        AtomicReference<String> nodes = new AtomicReference<>();\n        AtomicReference<String> pv = new AtomicReference<>();\n        AtomicReference<String> multipv = new AtomicReference<>();\n        AtomicReference<String> scoreCP = new AtomicReference<>();\n        AtomicReference<String> scoreMate = new AtomicReference<>();\n        AtomicReference<String> hashfull = new AtomicReference<>();\n        AtomicReference<String> nps = new AtomicReference<>();\n        AtomicReference<String> tbhits = new AtomicReference<>();\n        AtomicReference<String> cpuload = new AtomicReference<>();\n\n        Holder<?> root = Node.root()", "                .with(\n                        Node.literal(\"bestmove\")\n                                .mustConsumeChild()\n                                .with(\n                                        Node.string()\n                                                .complete(bestMove::set)\n                                                .with(Node.literal(\"ponder\")\n                                                        .mustConsumeChild()\n                                                        .with(Node.string().complete(ponderMove::set))\n                                                )\n                                )\n                )", "                                                        .with(Node.string().complete(ponderMove::set))\n                                                )\n                                )\n                )\n                .with(\n                        Node.literal(\"info\")\n                                .mustConsumeChild()\n                                .with(Node.literal(\"depth\").mustConsumeChild()\n                                        .with(Node.integer().complete(depth::set))\n                                )\n                                .with(Node.literal(\"seldepth\").mustConsumeChild()", "                                        .with(Node.integer().complete(depth::set))\n                                )\n                                .with(Node.literal(\"seldepth\").mustConsumeChild()\n                                        .with(Node.integer().complete(seldepth::set))\n                                )\n                                .with(Node.literal(\"time\").mustConsumeChild()\n                                        .with(Node.integer().complete(time::set))\n                                )\n                                .with(Node.literal(\"nodes\").mustConsumeChild()\n                                        .with(Node.integer().complete(nodes::set))\n                                )", "                                .with(Node.literal(\"nodes\").mustConsumeChild()\n                                        .with(Node.integer().complete(nodes::set))\n                                )\n                                .with(Node.literal(\"pv\").mustConsumeChild()\n                                        .with(Node.string().complete(pv::set))\n                                )\n                                .with(Node.literal(\"multipv\").mustConsumeChild()\n                                        .with(Node.integer().complete(multipv::set))\n                                )\n                                .with(Node.literal(\"score\").mustConsumeChild()\n                                        .with(\n                                                Node.literal(\"cp\").mustConsumeChild()", "                                .with(Node.literal(\"score\").mustConsumeChild()\n                                        .with(\n                                                Node.literal(\"cp\").mustConsumeChild()\n                                                        .with(Node.integer().complete(scoreCP::set))\n                                        )\n                                        .with(\n                                                Node.literal(\"mate\").mustConsumeChild()\n                                                        .with(Node.integer().complete(scoreMate::set))\n                                        )\n                                        .with(Node.literal(\"lowerbound\"))\n                                        .with(Node.literal(\"upperbound\"))\n                                )", "                                        .with(Node.literal(\"lowerbound\"))\n                                        .with(Node.literal(\"upperbound\"))\n                                )\n                                .with(Node.literal(\"hashfull\").mustConsumeChild()\n                                        .with(Node.integer().complete(hashfull::set))\n                                )\n                                .with(Node.literal(\"nps\").mustConsumeChild()\n                                        .with(Node.integer().complete(nps::set))\n                                )\n                                .with(Node.literal(\"tbhits\").mustConsumeChild()\n                                        .with(Node.integer().complete(tbhits::set))\n                                )", "                                .with(Node.literal(\"tbhits\").mustConsumeChild()\n                                        .with(Node.integer().complete(tbhits::set))\n                                )\n                                .with(Node.literal(\"cpuload\").mustConsumeChild()\n                                        .with(Node.integer().complete(cpuload::set))\n                                )\n                                .with(Node.literal(\"string\").mustConsumeChild()\n                                        .with(Node.greedyString())\n                                )\n                );\n\n        ParsingContext ctx = new ParsingContext(reader, root);\n\n        ctx.parse();\n", "        if (bestMove.get() == null) {\n            if (pv.get() != null) {\n                PartialSearchInfo info = new PartialSearchInfo(\n                        Integer.parseInt(depth.get()),\n                        Integer.parseInt(nodes.get()),\n                        pv.get(), scoreCP.get(), scoreMate.get());\n                for (Consumer<PartialSearchInfo> infoSub : infoSubs) {\n                    infoSub.accept(info);\n                }\n            }\n        }\n        else {\n            collectedBestMove = bestMove.get();\n            collectedPonder = ponderMove.get();\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override", "    public SearchResults build() {\n        return new SearchResults(collectedBestMove, collectedPonder);\n    }\n\n    @Contract(\"_->this\")\n    public AnalysisTask onUpdate(Consumer<PartialSearchInfo> info) {\n        infoSubs.add(info);\n        return this;\n    }\n\n    public void stop() {", "    public void stop() {\n        try {\n            writer.write(\"stop\\n\");\n            writer.flush();\n        } catch (IOException e) {\n            throw new StockfishError.ProcessExitedError();\n        }\n    }\n\n    public CompletableFuture<SearchResults> start(String cmd) {\n        if (results == null) {\n            results = command.apply(\"go \" + cmd, this);\n        }\n        return results;\n    }\n}\n", "        if (results == null) {\n            results = command.apply(\"go \" + cmd, this);\n        }\n        return results;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/CompletableFutureWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client;\n\nimport net.minecraft.client.MinecraftClient;\nimport org.jetbrains.annotations.Contract;\nimport org.luaj.vm2.LuaFunction;\nimport org.luaj.vm2.Varargs;\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.util.ArrayList;\nimport java.util.concurrent.CompletableFuture;", "import java.util.ArrayList;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Function;\n\n@LuaWhitelist\npublic class CompletableFutureWrapper<T, R> {\n    private final CompletableFuture<T> wrapped;\n    private final Function<T, R> wrapper;\n    private final Bridger b;\n    public ArrayList<LuaFunction> subs = new ArrayList<>();\n\n    public CompletableFutureWrapper(CompletableFuture<T> wrapped, Function<T, R> wrapper, Bridger b) {\n        this.wrapped = wrapped;\n        this.wrapper = wrapper;\n        this.b = b;\n    }\n\n    @LuaWhitelist\n    @Contract(\"_->this\")\n    public CompletableFutureWrapper<T, R> andThen(LuaFunction func) {\n        wrapped.whenComplete((e, v) -> {", "            if (v == null) {\n                MinecraftClient.getInstance().execute(() -> b.eventFunction().call(func, wrapper.apply(e)));\n            }\n        });\n        return this;\n    }\n\n    @LuaWhitelist\n    @Contract(\"_->this\")\n    public CompletableFutureWrapper<T, R> onException(LuaFunction func) {\n        wrapped.whenComplete((e, v) -> {", "            if (v != null) {\n                MinecraftClient.getInstance().execute(() -> b.eventFunction().call(func, v.getLocalizedMessage()));\n            }\n        });\n        return this;\n    }\n\n    @LuaWhitelist\n    public boolean completed() {\n        return wrapped.isDone();\n    }\n}\n", "    public boolean completed() {\n        return wrapped.isDone();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/FiguraEntrypoint.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client;\n\nimport com.github.applejuiceyy.figurastockfish.client.wrap.*;\nimport org.moon.figura.avatar.Avatar;\n\nimport org.moon.figura.entries.FiguraAPI;\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.util.Collection;\nimport java.util.Collections;", "import java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n@LuaWhitelist\npublic class FiguraEntrypoint implements FiguraAPI {\n    @Override\n    public FiguraAPI build(Avatar avatar) {\n        return new StockfishAPI(\n                new Bridger(\n                        o -> avatar.luaRuntime.typeManager.javaToLua(o),\n                        (c, o) -> avatar.run(c, avatar.tick, o),\n                        () -> avatar.isHost\n                )\n        );\n    }\n\n    @Override", "    public String getName() {\n        return \"stockfish\";\n    }\n\n    @Override\n    public Collection<Class<?>> getWhitelistedClasses() {\n        return List.of(StockfishAPI.class, CompletableFutureWrapper.class,\n\n                AnalysisTaskWrapper.class, EngineInfoWrapper.class, OptionEntryWrapper.class,\n                SearchInfoWrapper.class, SearchResultsWrapper.class, StockfishWrapper.class\n        );\n    }\n\n    @Override\n    public Collection<Class<?>> getDocsClasses() {\n        return Collections.emptyList();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/StockfishAPI.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client;\n\nimport com.github.applejuiceyy.figurastockfish.client.wrap.StockfishWrapper;\nimport com.github.applejuiceyy.figurastockfish.stockfish.StockfishInstance;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\nimport net.fabricmc.loader.api.FabricLoader;\nimport org.moon.figura.avatar.Avatar;\n\nimport org.moon.figura.entries.FiguraAPI;\nimport org.moon.figura.lua.LuaWhitelist;", "import org.moon.figura.entries.FiguraAPI;\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.CompletableFuture;\n\n@LuaWhitelist\npublic class StockfishAPI implements FiguraAPI {\n    private final Bridger b;\n\n    @Override", "@LuaWhitelist\npublic class StockfishAPI implements FiguraAPI {\n    private final Bridger b;\n\n    @Override\n    public FiguraAPI build(Avatar avatar) {\n        return null;\n    }\n\n    @Override\n    public String getName() {\n        return null;\n    }\n\n    @Override\n    public Collection<Class<?>> getWhitelistedClasses() {\n        return null;\n    }\n\n    @Override\n    public Collection<Class<?>> getDocsClasses() {\n        return Collections.emptyList();\n    }\n\n\n    StockfishAPI(Bridger b) {\n        this.b = b;\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<StockfishInstance, StockfishWrapper> newEngine() {\n        CompletableFuture<StockfishInstance> future;\n", "    public String getName() {\n        return null;\n    }\n\n    @Override\n    public Collection<Class<?>> getWhitelistedClasses() {\n        return null;\n    }\n\n    @Override\n    public Collection<Class<?>> getDocsClasses() {\n        return Collections.emptyList();\n    }\n\n\n    StockfishAPI(Bridger b) {\n        this.b = b;\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<StockfishInstance, StockfishWrapper> newEngine() {\n        CompletableFuture<StockfishInstance> future;\n", "        if (b.isHost().get()) {\n            future = StockfishInstance.bind(FabricLoader.getInstance().getGameDir().resolve(FiguraStockfishClient.path.value).toString());\n        }\n        else {\n            future = CompletableFuture.failedFuture(new StockfishError(\"Not host\"));\n        }\n\n        return new CompletableFutureWrapper<>(future, e -> new StockfishWrapper(e, b), b);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/FiguraStockfishClient.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client;\n\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.minecraft.text.Text;\nimport org.moon.figura.config.ConfigType;\nimport org.moon.figura.config.Configs;\nimport org.moon.figura.utils.FiguraText;\n", "import org.moon.figura.utils.FiguraText;\n\n@Environment(EnvType.CLIENT)\npublic class FiguraStockfishClient implements ClientModInitializer {\n    static ConfigType.StringConfig path;\n    @Override\n    public void onInitializeClient() {\n        try {\n            Class.forName(\"org.moon.figura.config.Configs\", true, this.getClass().getClassLoader());\n        } catch (ClassNotFoundException ignore) { /* shouldn't happen */ }\n\n        ConfigType.Category category = new ConfigType.Category(\"Figura Stockfish\"){{\n            this.name = Text.translatable(\"figurastockfish.config.category\");\n            this.tooltip = Text.translatable(\"figurastockfish.config.category.tooltip\");\n        }};\n\n        String os = System.getProperty(\"os.name\");\n        String dpath = os.toLowerCase().contains(\"windows\") ? \"stockfish.exe\" : \"stockfish\";\n        path = new ConfigType.StringConfig(\"Path\", category, dpath){{\n            this.name = Text.translatable(\"figurastockfish.config.path\");\n            this.tooltip = Text.translatable(\"figurastockfish.config.path.tooltip\");\n        }};\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/Bridger.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client;\n\nimport org.luaj.vm2.LuaFunction;\nimport org.luaj.vm2.Varargs;\n\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic record Bridger(Function<Object, Varargs> j2l, IndirectCall<LuaFunction> eventFunction, Supplier<Boolean> isHost) {\n    @FunctionalInterface", "\npublic record Bridger(Function<Object, Varargs> j2l, IndirectCall<LuaFunction> eventFunction, Supplier<Boolean> isHost) {\n    @FunctionalInterface\n    public interface IndirectCall<T> {\n        void call(T call, Object... v);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/OptionEntryWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.EngineInfo;\nimport org.moon.figura.lua.LuaWhitelist;\n\n@LuaWhitelist\npublic class OptionEntryWrapper {\n    private final EngineInfo.OptionEntry o;\n\n    public String getType() {\n        return o.type();\n    }\n", "    public String getType() {\n        return o.type();\n    }\n\n    public String getDefaultValue() {\n        return o.defaultValue();\n    }\n\n    public String getMin() {\n        return o.min();\n    }\n", "    public String getMin() {\n        return o.min();\n    }\n\n    public String getMax() {\n        return o.max();\n    }\n\n    public OptionEntryWrapper(EngineInfo.OptionEntry o) {\n        this.o = o;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/EngineInfoWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.client.Bridger;\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.EngineInfo;\nimport org.luaj.vm2.LuaTable;\nimport org.luaj.vm2.LuaValue;\nimport org.luaj.vm2.Varargs;\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.util.function.Function;", "\nimport java.util.function.Function;\n\n@LuaWhitelist\npublic class EngineInfoWrapper {\n    private final EngineInfo info;\n    private final Bridger b;\n\n    public EngineInfoWrapper(EngineInfo info, Bridger b) {\n        this.info = info;\n        this.b = b;\n    }\n\n    @LuaWhitelist", "    public String getName() {\n        return info.name();\n    }\n\n    @LuaWhitelist\n    public String getAuthors() {\n        return info.author();\n    }\n\n    @LuaWhitelist\n    public LuaTable getOptions() {\n        LuaTable table = new LuaTable();\n        info.options().forEach((s, o) -> table.set(LuaValue.valueOf(s), b.j2l().apply(new OptionEntryWrapper(o)).arg1()));\n        return table;\n    }\n}\n", "    public LuaTable getOptions() {\n        LuaTable table = new LuaTable();\n        info.options().forEach((s, o) -> table.set(LuaValue.valueOf(s), b.j2l().apply(new OptionEntryWrapper(o)).arg1()));\n        return table;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/SearchResultsWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.SearchResults;\nimport org.moon.figura.lua.LuaWhitelist;\n\n@LuaWhitelist\npublic class SearchResultsWrapper {\n    private final SearchResults searchResults;\n\n    public SearchResultsWrapper(SearchResults searchResults) {\n        this.searchResults = searchResults;\n    }\n\n    @LuaWhitelist", "    public String getBestMove() {\n        return searchResults.bestMove();\n    }\n\n    @LuaWhitelist\n    public String getPonder() {\n        return searchResults.ponder();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/StockfishWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.client.Bridger;\nimport com.github.applejuiceyy.figurastockfish.client.CompletableFutureWrapper;\nimport com.github.applejuiceyy.figurastockfish.stockfish.StockfishInstance;\n\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.util.function.Function;\n", "import java.util.function.Function;\n\n@LuaWhitelist\npublic class StockfishWrapper {\n    private final StockfishInstance inst;\n    private final Bridger b;\n    public StockfishWrapper(StockfishInstance inst, Bridger b) {\n        this.inst = inst;\n        this.b = b;\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<Void, Void> setFEN(String fen) {\n        return new CompletableFutureWrapper<>(inst.setFEN(fen), Function.identity(), b);\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<Void, Void> setFEN(String fen, String moves) {\n        return new CompletableFutureWrapper<>(inst.setFEN(fen, moves), Function.identity(), b);\n    }\n\n    @LuaWhitelist", "    public EngineInfoWrapper getInfo() {\n        return new EngineInfoWrapper(this.inst.info, b);\n    }\n\n    @LuaWhitelist\n    public AnalysisTaskWrapper calculate() {\n        return new AnalysisTaskWrapper(inst.calculate(), b);\n    }\n\n    @LuaWhitelist\n    public void setLevel(int level) {\n        inst.setOption(\"Skill Level\", String.valueOf(level));\n    }\n\n    @LuaWhitelist", "    public void setLevel(int level) {\n        inst.setOption(\"Skill Level\", String.valueOf(level));\n    }\n\n    @LuaWhitelist\n    public void close() {\n        inst.close();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/SearchInfoWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.PartialSearchInfo;\nimport org.moon.figura.lua.LuaWhitelist;\n\n@LuaWhitelist\npublic class SearchInfoWrapper {\n    private final PartialSearchInfo e;\n\n    @LuaWhitelist\n    public int getDepth() {\n        return e.depth();\n    }\n\n    @LuaWhitelist", "    public int getDepth() {\n        return e.depth();\n    }\n\n    @LuaWhitelist\n    public int getNodes() {\n        return e.nodes();\n    }\n\n    @LuaWhitelist\n    public String getPv() {\n        return e.pv();\n    }\n\n    @LuaWhitelist", "    public String getPv() {\n        return e.pv();\n    }\n\n    @LuaWhitelist\n    public String getScoreCP() {\n        return e.scoreCP();\n    }\n\n    @LuaWhitelist\n    public String getScoreMate() {\n        return e.scoreMate();\n    }\n\n    public SearchInfoWrapper(PartialSearchInfo e) {\n        this.e = e;\n    }\n}\n", "    public String getScoreMate() {\n        return e.scoreMate();\n    }\n\n    public SearchInfoWrapper(PartialSearchInfo e) {\n        this.e = e;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/applejuiceyy/figurastockfish/client/wrap/AnalysisTaskWrapper.java", "chunked_list": ["package com.github.applejuiceyy.figurastockfish.client.wrap;\n\nimport com.github.applejuiceyy.figurastockfish.client.Bridger;\nimport com.github.applejuiceyy.figurastockfish.client.CompletableFutureWrapper;\nimport com.github.applejuiceyy.figurastockfish.stockfish.data.SearchResults;\nimport com.github.applejuiceyy.figurastockfish.stockfish.processor.AnalysisTask;\nimport com.github.applejuiceyy.figurastockfish.stockfish.tree.StockfishError;\nimport net.minecraft.client.MinecraftClient;\nimport org.luaj.vm2.LuaFunction;\nimport org.luaj.vm2.LuaValue;", "import org.luaj.vm2.LuaFunction;\nimport org.luaj.vm2.LuaValue;\nimport org.luaj.vm2.Varargs;\nimport org.moon.figura.lua.LuaWhitelist;\n\nimport java.util.function.Function;\n\n@LuaWhitelist\npublic class AnalysisTaskWrapper {\n    private final AnalysisTask wrapped;\n    private final Bridger b;\n\n    AnalysisTaskWrapper(AnalysisTask wrapped, Bridger b) {\n        this.wrapped = wrapped;\n        this.b = b;\n    }\n\n    @LuaWhitelist", "public class AnalysisTaskWrapper {\n    private final AnalysisTask wrapped;\n    private final Bridger b;\n\n    AnalysisTaskWrapper(AnalysisTask wrapped, Bridger b) {\n        this.wrapped = wrapped;\n        this.b = b;\n    }\n\n    @LuaWhitelist\n    public AnalysisTaskWrapper onUpdate(LuaFunction value) {\n        wrapped.onUpdate(\n                e -> MinecraftClient.getInstance().execute(() -> {\n                    b.eventFunction().call(value, new SearchInfoWrapper(e));\n                })\n        );\n        return this;\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<SearchResults, SearchResultsWrapper> start(String cmd) {\n        return new CompletableFutureWrapper<>(\n                this.wrapped.start(cmd),\n                SearchResultsWrapper::new,\n                b\n        );\n    }\n\n    @LuaWhitelist", "    public AnalysisTaskWrapper onUpdate(LuaFunction value) {\n        wrapped.onUpdate(\n                e -> MinecraftClient.getInstance().execute(() -> {\n                    b.eventFunction().call(value, new SearchInfoWrapper(e));\n                })\n        );\n        return this;\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<SearchResults, SearchResultsWrapper> start(String cmd) {\n        return new CompletableFutureWrapper<>(\n                this.wrapped.start(cmd),\n                SearchResultsWrapper::new,\n                b\n        );\n    }\n\n    @LuaWhitelist", "    public Varargs stop() {\n        try {\n            wrapped.stop();\n            return LuaValue.TRUE;\n        }\n        catch (StockfishError e) {\n            return LuaValue.varargsOf(LuaValue.FALSE, LuaValue.valueOf(e.getLocalizedMessage()));\n        }\n    }\n}\n"]}
