{"filename": "src/main/java/com/github/yunabraska/githubworkflow/listeners/ListenerService.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.listeners;\n\nimport com.intellij.openapi.Disposable;\nimport com.intellij.openapi.application.ApplicationManager;\nimport com.intellij.openapi.components.Service;\nimport com.intellij.openapi.project.Project;\n\n@Service\npublic final class ListenerService implements Disposable {\n    @Override\n    public void dispose() {\n    }\n", "public final class ListenerService implements Disposable {\n    @Override\n    public void dispose() {\n    }\n\n    public static ListenerService getInstance() {\n        return ApplicationManager.getApplication().getService(ListenerService.class);\n    }\n\n    public static ListenerService getInstance(final Project project) {\n        return project.getService(ListenerService.class);\n    }\n}\n", "    public static ListenerService getInstance(final Project project) {\n        return project.getService(ListenerService.class);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/listeners/FileChangeListener.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.listeners;\n\nimport com.intellij.openapi.editor.event.DocumentEvent;\nimport com.intellij.openapi.editor.event.DocumentListener;\nimport com.intellij.openapi.fileEditor.FileDocumentManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.util.Alarm;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.nio.file.Paths;", "\nimport java.nio.file.Paths;\nimport java.util.Optional;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isWorkflowPath;\nimport static com.github.yunabraska.githubworkflow.listeners.ApplicationStartup.asyncInitWorkflowFile;\nimport static com.intellij.openapi.util.io.NioFiles.toPath;\n\npublic class FileChangeListener implements DocumentListener {\n\n    private static final int DEBOUNCE_DELAY_MS = 1000;\n    private final Project project;\n    private final Alarm alarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n\n    public FileChangeListener(final Project project) {\n        this.project = project;\n    }\n\n    @Override", "public class FileChangeListener implements DocumentListener {\n\n    private static final int DEBOUNCE_DELAY_MS = 1000;\n    private final Project project;\n    private final Alarm alarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n\n    public FileChangeListener(final Project project) {\n        this.project = project;\n    }\n\n    @Override", "    public void documentChanged(@NotNull final DocumentEvent event) {\n        Optional.of(event.getDocument())\n                .map(document -> FileDocumentManager.getInstance().getFile(document))\n                .ifPresent(virtualFile -> {\n                    if (isWorkflowPath(toPath(virtualFile.getPath()))) {\n                        alarm.cancelAllRequests();\n                        alarm.addRequest(() -> {\n                            if (!project.isDisposed()) {\n                                asyncInitWorkflowFile(project, virtualFile);\n                            }\n                        }, DEBOUNCE_DELAY_MS);\n                    }\n                });\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/listeners/ApplicationStartup.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.listeners;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.github.yunabraska.githubworkflow.model.WorkflowContext;\nimport com.github.yunabraska.githubworkflow.model.YamlElement;\nimport com.github.yunabraska.githubworkflow.model.YamlElementHelper;\nimport com.intellij.openapi.Disposable;\nimport com.intellij.openapi.actionSystem.ex.ActionManagerEx;\nimport com.intellij.openapi.application.ApplicationManager;\nimport com.intellij.openapi.editor.EditorFactory;", "import com.intellij.openapi.application.ApplicationManager;\nimport com.intellij.openapi.editor.EditorFactory;\nimport com.intellij.openapi.fileEditor.FileEditorManager;\nimport com.intellij.openapi.fileEditor.FileEditorManagerListener;\nimport com.intellij.openapi.progress.ProgressIndicator;\nimport com.intellij.openapi.progress.Task;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.startup.ProjectActivity;\nimport com.intellij.openapi.util.Disposer;\nimport com.intellij.openapi.vfs.VirtualFile;", "import com.intellij.openapi.util.Disposer;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiManager;\nimport kotlin.Unit;\nimport kotlin.coroutines.Continuation;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.jetbrains.yaml.psi.YAMLFile;\n", "import org.jetbrains.yaml.psi.YAMLFile;\n\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static com.intellij.openapi.util.io.NioFiles.toPath;\n\n\npublic class ApplicationStartup implements ProjectActivity {\n\n    @Nullable\n    @Override", "\npublic class ApplicationStartup implements ProjectActivity {\n\n    @Nullable\n    @Override\n    public Object execute(@NotNull final Project project, @NotNull final Continuation<? super Unit> continuation) {\n        final Disposable listenerDisposable = Disposer.newDisposable();\n        Disposer.register(ListenerService.getInstance(project), listenerDisposable);\n\n        // ON TYPING (with delay)\n        EditorFactory.getInstance().getEventMulticaster().addDocumentListener(new FileChangeListener(project), listenerDisposable);\n\n        // SWITCH TABS\n        project.getMessageBus().connect(listenerDisposable).subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileFocusListener(project));\n\n        // AFTER STARTUP\n        final FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);", "        for (final VirtualFile openedFile : fileEditorManager.getOpenFiles()) {\n            asyncInitWorkflowFile(project, openedFile);\n        }\n\n        Disposer.register(ListenerService.getInstance(project), () -> unregisterAction(project));\n        return null;\n    }\n\n    private void unregisterAction(final Project project) {\n        final ActionManagerEx actionManager = ActionManagerEx.getInstanceEx();\n        for (final String oldId : actionManager.getActionIdList(\"GHWP_\" + project.getLocationHash())) {\n            actionManager.unregisterAction(oldId);\n        }\n    }\n\n", "        for (final String oldId : actionManager.getActionIdList(\"GHWP_\" + project.getLocationHash())) {\n            actionManager.unregisterAction(oldId);\n        }\n    }\n\n\n    public static void asyncInitWorkflowFile(final Project project, final VirtualFile virtualFile) {\n        if (virtualFile != null && (GitHubWorkflowUtils.isWorkflowPath(toPath(virtualFile.getPath())))) {\n\n            // READ CONTEXT\n            final AtomicReference<WorkflowContext> context = readContext(project, virtualFile);\n\n            // ASYNC HTTP CONTEXT", "            if (context.get() != null) {\n                downloadWorkflows(project, context.get());\n            }\n        }\n    }\n\n    @NotNull\n    private static AtomicReference<WorkflowContext> readContext(final Project project, final VirtualFile virtualFile) {\n        final AtomicReference<WorkflowContext> context = new AtomicReference<>(null);\n        ApplicationManager.getApplication().runReadAction(() -> Optional.of(PsiManager.getInstance(project))\n                .map(psiManager -> psiManager.findFile(virtualFile))\n                .filter(YAMLFile.class::isInstance)\n                .map(PsiElement::getChildren)\n                .map(children -> children.length > 0 ? children[0] : null)\n                .map(YamlElementHelper::yamlOf)\n                .map(YamlElement::context)\n                .ifPresent(context::set));\n        return context;\n    }\n\n    private static void downloadWorkflows(final Project project, final WorkflowContext context) {\n        context.actions().values().forEach(action -> new Task.Backgroundable(project, \"Resolving \" + (action.isAction() ? \"action\" : \"workflow\") + action.slug(), false) {\n            @Override", "            public void run(@NotNull final ProgressIndicator indicator) {\n                indicator.setFraction(0.3);\n                indicator.setText(\"Resolving \" + (action.isAction() ? \"action\" : \"workflow\") + action.slug());\n                action.resolve(project);\n                indicator.setText(\"Done resolving \" + (action.isAction() ? \"action\" : \"workflow\") + action.slug());\n                indicator.setFraction(0.8);\n            }\n        }.queue());\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/listeners/FileFocusListener.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.listeners;\n\nimport com.intellij.openapi.fileEditor.FileEditorManagerEvent;\nimport com.intellij.openapi.fileEditor.FileEditorManagerListener;\nimport com.intellij.openapi.project.Project;\nimport org.jetbrains.annotations.NotNull;\n\nimport static com.github.yunabraska.githubworkflow.listeners.ApplicationStartup.asyncInitWorkflowFile;\n\npublic class FileFocusListener implements FileEditorManagerListener {\n\n    private final Project project;\n\n    public FileFocusListener(final Project project) {\n        this.project = project;\n    }\n\n    @Override", "\npublic class FileFocusListener implements FileEditorManagerListener {\n\n    private final Project project;\n\n    public FileFocusListener(final Project project) {\n        this.project = project;\n    }\n\n    @Override\n    public void selectionChanged(@NotNull final FileEditorManagerEvent event) {\n        asyncInitWorkflowFile(project, event.getNewFile());\n    }\n\n}\n\n", "    public void selectionChanged(@NotNull final FileEditorManagerEvent event) {\n        asyncInitWorkflowFile(project, event.getNewFile());\n    }\n\n}\n\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/config/GitHubWorkflowConfig.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.config;\n\nimport com.github.yunabraska.githubworkflow.model.GitHubAction;\nimport com.github.yunabraska.githubworkflow.model.WorkflowContext;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;", "import java.util.function.Supplier;\nimport java.util.regex.Pattern;\n\n@SuppressWarnings(\"java:S2386\")\npublic class GitHubWorkflowConfig {\n\n    public static final Pattern PATTERN_GITHUB_OUTPUT = Pattern.compile(\"echo\\\\s+\\\"(.*?)=(.*?)\\\"\\\\s*>>\\\\s*\\\"?\\\\$\\\\{?GITHUB_OUTPUT\\\\}?\\\"?\");\n    public static final Pattern PATTERN_GITHUB_ENV = Pattern.compile(\"echo\\\\s+\\\"(.*?)=(.*?)\\\"\\\\s*>>\\\\s*\\\"?\\\\$\\\\{?GITHUB_ENV\\\\}?\\\"?\");\n    public static final long CACHE_ONE_DAY = 24L * 60 * 60 * 1000;\n    public static final long CACHE_TEN_MINUTES = 600000;\n    public static final String FIELD_ON = \"on\";", "    public static final long CACHE_ONE_DAY = 24L * 60 * 60 * 1000;\n    public static final long CACHE_TEN_MINUTES = 600000;\n    public static final String FIELD_ON = \"on\";\n    public static final String FIELD_ENVS = \"env\";\n    public static final String FIELD_RUN = \"run\";\n    public static final String FIELD_JOBS = \"jobs\";\n    public static final String FIELD_VARS = \"vars\";\n    public static final String FIELD_WITH = \"with\";\n    public static final String FIELD_USES = \"uses\";\n    public static final String FIELD_NEEDS = \"needs\";\n    public static final String FIELD_STEPS = \"steps\";", "    public static final String FIELD_USES = \"uses\";\n    public static final String FIELD_NEEDS = \"needs\";\n    public static final String FIELD_STEPS = \"steps\";\n    public static final String FIELD_RUNNER = \"runner\";\n    public static final String FIELD_GITHUB = \"github\";\n    public static final String FIELD_DEFAULT = \"${{}}\";\n    public static final String FIELD_INPUTS = \"inputs\";\n    public static final String FIELD_OUTPUTS = \"outputs\";\n    public static final String FIELD_SECRETS = \"secrets\";\n    public static final Map<String, Supplier<Map<String, String>>> DEFAULT_VALUE_MAP = initProcessorMap();\n    public static final Map<String, GitHubAction> ACTION_CACHE = new ConcurrentHashMap<>();", "    public static final String FIELD_SECRETS = \"secrets\";\n    public static final Map<String, Supplier<Map<String, String>>> DEFAULT_VALUE_MAP = initProcessorMap();\n    public static final Map<String, GitHubAction> ACTION_CACHE = new ConcurrentHashMap<>();\n    public static final Map<String, WorkflowContext> WORKFLOW_CACHE = new ConcurrentHashMap<>();\n\n    private static Map<String, Supplier<Map<String, String>>> initProcessorMap() {\n        final Map<String, Supplier<Map<String, String>>> result = new HashMap<>();\n        result.put(FIELD_GITHUB, GitHubWorkflowConfig::getGitHubContextEnvs);\n        result.put(FIELD_ENVS, GitHubWorkflowConfig::getGitHubEnvs);\n        result.put(FIELD_RUNNER, GitHubWorkflowConfig::getRunnerItems);\n        result.put(FIELD_DEFAULT, GitHubWorkflowConfig::getCaretBracketItems);\n        return result;\n    }\n\n    private static HashMap<String, String> getRunnerItems() {\n        final HashMap<String, String> result = new HashMap<>();\n        result.put(\"name\", \"The name of the runner executing the job.\");\n        result.put(\"os\", \"The operating system of the runner executing the job. Possible values are Linux, Windows, or macOS.\");\n        result.put(\"arch\", \"The architecture of the runner executing the job. Possible values are X86, X64, ARM, or ARM64.\");\n        result.put(\"temp\", \"The path to a temporary directory on the runner. This directory is emptied at the beginning and end of each job. Note that files will not be removed if the runner's user account does not have permission to delete them.\");\n        result.put(\"tool_cache\", \"he path to the directory containing preinstalled tools for GitHub-hosted runners. For more information, see \\\"About GitHub-hosted runners\\\".\");\n        result.put(\"debug\", \"The path to the directory containing preinstalled tools for GitHub-hosted runners. For more information, see \\\"About GitHub-hosted runners\\\".\");\n        return result;\n    }\n\n    private static HashMap<String, String> getCaretBracketItems() {\n        final HashMap<String, String> result = new HashMap<>();\n        result.put(FIELD_INPUTS, \"Workflow inputs e.g. from workflow_dispatch, workflow_call\");\n        result.put(FIELD_SECRETS, \"Workflow secrets\");\n        result.put(FIELD_JOBS, \"Workflow jobs\");\n        result.put(FIELD_STEPS, \"steps with 'id' of the current job\");\n        result.put(FIELD_ENVS, \"Environment variables from jobs amd steps\");\n        result.put(FIELD_VARS, \"The vars context contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows\");\n        result.put(FIELD_NEEDS, \"Identifies any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails, all jobs that need it are skipped unless the jobs use a conditional statement that causes the job to continue.\");\n        result.put(FIELD_GITHUB, \"Information about the workflow run and the event that triggered the run. You can also read most of the github context data in environment variables. For more information about environment variables\");\n        return result;\n    }\n\n    //TODO: autogenerate this\n    //https://docs.github.com/en/actions/learn-github-actions/contexts#github-context\n    private static HashMap<String, String> getGitHubContextEnvs() {\n        final HashMap<String, String> result = new HashMap<>();\n        result.put(\"action\", \"The name of the action currently running, or the id of a step. GitHub removes special characters, and uses the name __run when the current step runs a script without an id. If you use the same action more than once in the same job, the name will include a suffix with the sequence number with underscore before it. For example, the first script you run will have the name __run, and the second script will be named __run_2. Similarly, the second invocation of actions/checkout will be actionscheckout2.\");\n        result.put(\"action_path\", \"The path where an action is located. This property is only supported in composite actions. You can use this path to access files located in the same repository as the action, for example by changing directories to the path:  cd ${{ github.action_path }} .\");\n        result.put(\"action_ref\", \"For a step executing an action, this is the ref of the action being executed. For example, v2.\");\n        result.put(\"action_repository\", \"For a step executing an action, this is the owner and repository name of the action. For example, actions/checkout.\");\n        result.put(\"action_status\", \"For a composite action, the current result of the composite action.\");\n        result.put(\"actor\", \"The username of the user that triggered the initial workflow run. If the workflow run is a re-run, this value may differ from github.triggering_actor. Any workflow re-runs will use the privileges of github.actor, even if the actor initiating the re-run (github.triggering_actor) has different privileges.\");\n        result.put(\"actor_id\", \"The account ID of the person or app that triggered the initial workflow run. For example, 1234567. Note that this is different from the actor username.\");\n        result.put(\"api_url\", \"The URL of the GitHub REST API.\");\n        result.put(\"base_ref\", \"The base_ref or target branch of the pull request in a workflow run. This property is only available when the event that triggers a workflow run is either pull_request or pull_request_target.\");\n        result.put(\"env\", \"Path on the runner to the file that sets environment variables from workflow commands. This file is unique to the current step and is a different file for each step in a job. For more information, see \\\"Workflow commands for GitHub Actions.\\\"\");\n        result.put(\"event\", \"The full event webhook payload. You can access individual properties of the event using this context. This object is identical to the webhook payload of the event that triggered the workflow run, and is different for each event. The webhooks for each GitHub Actions event is linked in \\\"Events that trigger workflows.\\\" For example, for a workflow run triggered by the push event, this object contains the contents of the push webhook payload.\");\n        result.put(\"event_name\", \"The name of the event that triggered the workflow run.\");\n        result.put(\"event_path\", \"The path to the file on the runner that contains the full event webhook payload.\");\n        result.put(\"graphql_url\", \"The URL of the GitHub GraphQL API.\");\n        result.put(\"head_ref\", \"The head_ref or source branch of the pull request in a workflow run. This property is only available when the event that triggers a workflow run is either pull_request or pull_request_target.\");\n        result.put(\"job\", \"The job_id of the current job. \\nNote: This context property is set by the Actions runner, and is only available within the execution steps of a job. Otherwise, the value of this property will be null.\");\n        result.put(\"job_workflow_sha\", \"For jobs using a reusable workflow, the commit SHA for the reusable workflow file.\");\n        result.put(\"path\", \"Path on the runner to the file that sets system PATH variables from workflow commands. This file is unique to the current step and is a different file for each step in a job. For more information, see \\\"Workflow commands for GitHub Actions.\\\"\");\n        result.put(\"ref\", \"The fully-formed ref of the branch or tag that triggered the workflow run. For workflows triggered by push, this is the branch or tag ref that was pushed. For workflows triggered by pull_request, this is the pull request merge branch. For workflows triggered by release, this is the release tag created. For other triggers, this is the branch or tag ref that triggered the workflow run. This is only set if a branch or tag is available for the event type. The ref given is fully-formed, meaning that for branches the format is refs/heads/<branch_name>, for pull requests it is refs/pull/<pr_number>/merge, and for tags it is refs/tags/<tag_name>. For example, refs/heads/feature-branch-1.\");\n        result.put(\"ref_name\", \"The short ref name of the branch or tag that triggered the workflow run. This value matches the branch or tag name shown on GitHub. For example, feature-branch-1.\");\n        result.put(\"ref_protected\", \"true if branch protections are configured for the ref that triggered the workflow run.\");\n        result.put(\"ref_type\", \"The type of ref that triggered the workflow run. Valid values are branch or tag.\");\n        result.put(\"repository\", \"The owner and repository name. For example, octocat/Hello-World.\");\n        result.put(\"repository_id\", \"The ID of the repository. For example, 123456789. Note that this is different from the repository name.\");\n        result.put(\"repository_owner\", \"The repository owner's username. For example, octocat.\");\n        result.put(\"repository_owner_id\", \"The repository owner's account ID. For example, 1234567. Note that this is different from the owner's name.\");\n        result.put(\"repositoryUrl\", \"The Git URL to the repository. For example, git://github.com/octocat/hello-world.git.\");\n        result.put(\"retention_days\", \"The number of days that workflow run logs and artifacts are kept.\");\n        result.put(\"run_id\", \"A unique number for each workflow run within a repository. This number does not change if you re-run the workflow run.\");\n        result.put(\"run_number\", \"A unique number for each run of a particular workflow in a repository. This number begins at 1 for the workflow's first run, and increments with each new run. This number does not change if you re-run the workflow run.\");\n        result.put(\"run_attempt\", \"A unique number for each attempt of a particular workflow run in a repository. This number begins at 1 for the workflow run's first attempt, and increments with each re-run.\");\n        result.put(\"secret_source\", \"The source of a secret used in a workflow. Possible values are None, Actions, Dependabot, or Codespaces.\");\n        result.put(\"server_url\", \"The URL of the GitHub server. For example: https://github.com.\");\n        result.put(\"sha\", \"The commit SHA that triggered the workflow. The value of this commit SHA depends on the event that triggered the workflow. For more information, see \\\"Events that trigger workflows.\\\" For example, ffac537e6cbbf934b08745a378932722df287a53.\");\n        result.put(\"token\", \"A token to authenticate on behalf of the GitHub App installed on your repository. This is functionally equivalent to the GITHUB_TOKEN secret. For more information, see \\\"Automatic token authentication.\\\" \\nNote: This context property is set by the Actions runner, and is only available within the execution steps of a job. Otherwise, the value of this property will be null.\");\n        result.put(\"triggering_actor\", \"The username of the user that initiated the workflow run. If the workflow run is a re-run, this value may differ from github.actor. Any workflow re-runs will use the privileges of github.actor, even if the actor initiating the re-run (github.triggering_actor) has different privileges.\");\n        result.put(\"workflow\", \"The name of the workflow. If the workflow file doesn't specify a name, the value of this property is the full path of the workflow file in the repository.\");\n        result.put(\"workflow_ref\", \"The ref path to the workflow. For example, octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch.\");\n        result.put(\"workflow_sha\", \"The commit SHA for the workflow file.\");\n        result.put(\"workspace\", \"The default working directory on the runner for steps, and the default location of your repository when using the checkout action.\");\n        return result;\n    }\n\n    //TODO: autogenerate this\n    //https://docs.github.com/en/actions/learn-github-actions/variables#using-the-vars-context-to-access-configuration-variable-values\n    private static HashMap<String, String> getGitHubEnvs() {\n        final HashMap<String, String> result = new HashMap<>();\n        result.put(\"CI\", \"Always set to true.\");\n        result.put(\"GITHUB_ACTION\", \"The name of the action currently running, or the id of a step. For example, for an action, __repo-owner_name-of-action-repo.\\n\\nGitHub removes special characters, and uses the name __run when the current step runs a script without an id. If you use the same script or action more than once in the same job, the name will include a suffix that consists of the sequence number preceded by an underscore. For example, the first script you run will have the name __run, and the second script will be named __run_2. Similarly, the second invocation of actions/checkout will be actionscheckout2.\");\n        result.put(\"GITHUB_ACTION_PATH\", \"The path where an action is located. This property is only supported in composite actions. You can use this path to access files located in the same repository as the action. For example, /home/runner/work/_actions/repo-owner/name-of-action-repo/v1.\");\n        result.put(\"GITHUB_ACTION_REPOSITORY\", \"For a step executing an action, this is the owner and repository name of the action. For example, actions/checkout.\");\n        result.put(\"GITHUB_ACTIONS\", \"Always set to true when GitHub Actions is running the workflow. You can use this variable to differentiate when tests are being run locally or by GitHub Actions.\");\n        result.put(\"GITHUB_ACTOR\", \"The name of the person or app that initiated the workflow. For example, octocat.\");\n        result.put(\"GITHUB_ACTOR_ID\", \"The account ID of the person or app that triggered the initial workflow run. For example, 1234567. Note that this is different from the actor username.\");\n        result.put(\"GITHUB_API_URL\", \"Returns the API URL. For example: https://api.github.com.\");\n        result.put(\"GITHUB_BASE_REF\", \"The name of the base ref or target branch of the pull request in a workflow run. This is only set when the event that triggers a workflow run is either pull_request or pull_request_target. For example, main.\");\n        result.put(\"GITHUB_ENV\", \"The path on the runner to the file that sets variables from workflow commands. This file is unique to the current step and changes for each step in a job. For example, /home/runner/work/_temp/_runner_file_commands/set_env_87406d6e-4979-4d42-98e1-3dab1f48b13a. For more information, see \\\"Workflow commands for GitHub Actions.\\\"\");\n        result.put(\"GITHUB_EVENT_NAME\", \"The name of the event that triggered the workflow. For example, workflow_dispatch.\");\n        result.put(\"GITHUB_EVENT_PATH\", \"The path to the file on the runner that contains the full event webhook payload. For example, /github/workflow/event.json.\");\n        result.put(\"GITHUB_GRAPHQL_URL\", \"Returns the GraphQL API URL. For example: https://api.github.com/graphql\");\n        result.put(\"GITHUB_HEAD_REF\", \"The head ref or source branch of the pull request in a workflow run. This property is only set when the event that triggers a workflow run is either pull_request or pull_request_target. For example, feature-branch-1.\");\n        result.put(\"GITHUB_JOB\", \"The job_id of the current job. For example, greeting_job.\");\n        result.put(\"GITHUB_PATH\", \"The path on the runner to the file that sets system PATH variables from workflow commands. This file is unique to the current step and changes for each step in a job. For example, /home/runner/work/_temp/_runner_file_commands/add_path_899b9445-ad4a-400c-aa89-249f18632cf5. For more information, see \\\"Workflow commands for GitHub Actions.\\\"\");\n        result.put(\"GITHUB_REF\", \"The fully-formed ref of the branch or tag that triggered the workflow run. For workflows triggered by push, this is the branch or tag ref that was pushed. For workflows triggered by pull_request, this is the pull request merge branch. For workflows triggered by release, this is the release tag created. For other triggers, this is the branch or tag ref that triggered the workflow run. This is only set if a branch or tag is available for the event type. The ref given is fully-formed, meaning that for branches the format is refs/heads/<branch_name>, for pull requests it is refs/pull/<pr_number>/merge, and for tags it is refs/tags/<tag_name>. For example, refs/heads/feature-branch-1.\");\n        result.put(\"GITHUB_REF_NAME\", \"The short ref name of the branch or tag that triggered the workflow run. This value matches the branch or tag name shown on GitHub. For example, feature-branch-1.\");\n        result.put(\"GITHUB_REF_PROTECTED\", \"true if branch protections are configured for the ref that triggered the workflow run.\");\n        result.put(\"GITHUB_REF_TYPE\", \"The type of ref that triggered the workflow run. Valid values are branch or tag.\");\n        result.put(\"GITHUB_REPOSITORY\", \"The owner and repository name. For example, octocat/Hello-World.\");\n        result.put(\"GITHUB_REPOSITORY_ID\", \"The ID of the repository. For example, 123456789. Note that this is different from the repository name.\");\n        result.put(\"GITHUB_REPOSITORY_OWNER\", \"The repository owner's account ID. For example, 1234567. Note that this is different from the owner's name.\");\n        result.put(\"GITHUB_RETENTION_DAYS\", \"The number of days that workflow run logs and artifacts are kept. For example, 90.\");\n        result.put(\"GITHUB_RUN_ATTEMPT\", \"A unique number for each attempt of a particular workflow run in a repository. This number begins at 1 for the workflow run's first attempt, and increments with each re-run. For example, 3.\");\n        result.put(\"GITHUB_RUN_ID\", \"A unique number for each workflow run within a repository. This number does not change if you re-run the workflow run. For example, 1658821493.\");\n        result.put(\"GITHUB_RUN_NUMBER\", \"A unique number for each run of a particular workflow in a repository. This number begins at 1 for the workflow's first run, and increments with each new run. This number does not change if you re-run the workflow run. For example, 3.\");\n        result.put(\"GITHUB_SERVER_URL\", \"The URL of the GitHub server. For example: https://github.com.\");\n        result.put(\"GITHUB_SHA\", \"The commit SHA that triggered the workflow. The value of this commit SHA depends on the event that triggered the workflow. For more information, see \\\"Events that trigger workflows.\\\" For example, ffac537e6cbbf934b08745a378932722df287a53.\");\n        result.put(\"GITHUB_STEP_SUMMARY\", \"The path on the runner to the file that contains job summaries from workflow commands. This file is unique to the current step and changes for each step in a job. For example, /home/runner/_layout/_work/_temp/_runner_file_commands/step_summary_1cb22d7f-5663-41a8-9ffc-13472605c76c. For more information, see \\\"Workflow commands for GitHub Actions.\\\"\");\n        result.put(\"GITHUB_WORKFLOW\", \"The name of the workflow. For example, My test workflow. If the workflow file doesn't specify a name, the value of this variable is the full path of the workflow file in the repository.\");\n        result.put(\"GITHUB_WORKFLOW_REF\", \"The ref path to the workflow. For example, octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch.\");\n        result.put(\"GITHUB_WORKFLOW_SHA\", \"The commit SHA for the workflow file.\");\n        result.put(\"GITHUB_WORKSPACE\", \"The default working directory on the runner for steps, and the default location of your repository when using the checkout action. For example, /home/runner/work/my-repo-name/my-repo-name.\");\n        result.put(\"RUNNER_ARCH\", \"The architecture of the runner executing the job. Possible values are X86, X64, ARM, or ARM64.\");\n        result.put(\"RUNNER_DEBUG\", \"This is set only if debug logging is enabled, and always has the value of 1. It can be useful as an indicator to enable additional debugging or verbose logging in your own job steps.\");\n        result.put(\"RUNNER_NAME\", \"The name of the runner executing the job. For example, Hosted Agent\");\n        result.put(\"RUNNER_OS\", \"The operating system of the runner executing the job. Possible values are Linux, Windows, or macOS. For example, Windows\");\n        result.put(\"RUNNER_TEMP\", \"The path to a temporary directory on the runner. This directory is emptied at the beginning and end of each job. Note that files will not be removed if the runner's user account does not have permission to delete them. For example, D:\\\\a\\\\_temp\");\n        result.put(\"RUNNER_TOOL_CACHE\", \"The path to the directory containing preinstalled tools for GitHub-hosted runners. For more information, see \\\"About GitHub-hosted runners\\\". For example, C:\\\\hostedtoolcache\\\\windows\");\n        return result;\n    }\n\n    private GitHubWorkflowConfig() {\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/config/NodeIcon.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.config;\n\nimport com.intellij.icons.AllIcons;\n\nimport javax.swing.*;\n\npublic enum NodeIcon {\n    //https://jetbrains.design/intellij/resources/icons_list/\n    //ORDINAL == PRIORITY\n    ICON_NODE(AllIcons.Nodes.Interface),\n    ICON_NEEDS(AllIcons.Nodes.Related),\n    ICON_ENV(AllIcons.Nodes.Constant),\n    ICON_RUNNER(AllIcons.Nodes.Variable),\n    ICON_STEP(AllIcons.Nodes.Class),\n    ICON_JOB(AllIcons.Nodes.Class),\n    ICON_OUTPUT(AllIcons.Nodes.Variable),\n    ICON_INPUT(AllIcons.Nodes.Parameter),\n    ICON_SECRET_WORKFLOW(AllIcons.Nodes.Static),\n    ICON_ENV_ROOT(AllIcons.Nodes.Constant),\n    ICON_ENV_JOB(AllIcons.Nodes.Parameter),\n    ICON_ENV_STEP(AllIcons.Nodes.Parameter),\n    ICON_TEXT_VARIABLE(AllIcons.Nodes.Gvariable),\n    ;\n\n    final Icon icon;\n\n    NodeIcon(final Icon icon) {\n        this.icon = icon;\n    }\n", "    public Icon icon() {\n        return icon;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/YamlElementHelper.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.psi.impl.source.tree.LeafPsiElement;\nimport com.intellij.psi.impl.source.tree.PsiErrorElementImpl;\nimport org.jetbrains.yaml.YAMLLanguage;\nimport org.jetbrains.yaml.psi.YAMLCompoundValue;\nimport org.jetbrains.yaml.psi.YAMLDocument;", "import org.jetbrains.yaml.psi.YAMLCompoundValue;\nimport org.jetbrains.yaml.psi.YAMLDocument;\nimport org.jetbrains.yaml.psi.YAMLFile;\nimport org.jetbrains.yaml.psi.YAMLKeyValue;\nimport org.jetbrains.yaml.psi.YAMLMapping;\nimport org.jetbrains.yaml.psi.YAMLQuotedText;\nimport org.jetbrains.yaml.psi.YAMLScalar;\nimport org.jetbrains.yaml.psi.YAMLSequence;\nimport org.jetbrains.yaml.psi.YAMLSequenceItem;\nimport org.jetbrains.yaml.psi.impl.YAMLBlockScalarImpl;", "import org.jetbrains.yaml.psi.YAMLSequenceItem;\nimport org.jetbrains.yaml.psi.impl.YAMLBlockScalarImpl;\nimport org.jetbrains.yaml.psi.impl.YAMLPlainTextImpl;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Consumer;", "import java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.model.WorkflowContext.WORKFLOW_CONTEXT_MAP;\nimport static java.util.Optional.ofNullable;\n\npublic class YamlElementHelper {\n\n    private YamlElementHelper() {\n    }\n", "    public static PsiElement getYamlRoot(final PsiElement element) {\n        if (element == null || element instanceof YAMLDocument || element instanceof YAMLFile || element.getParent() == null) {\n            return element;\n        } else {\n            return getYamlRoot(element.getParent());\n        }\n    }\n\n    @SuppressWarnings(\"java:S2637\")\n    public static String getPath(final PsiElement element) {\n        return ofNullable(element).map(YamlElementHelper::getVirtualFile).map(VirtualFile::getPath).orElse(null);\n    }\n", "    public static String getPath(final PsiElement element) {\n        return ofNullable(element).map(YamlElementHelper::getVirtualFile).map(VirtualFile::getPath).orElse(null);\n    }\n\n    public static VirtualFile getVirtualFile(final PsiElement element) {\n        return ofNullable(getPsiFile(element)).map(yamlFile -> Optional.of(yamlFile.getOriginalFile()).map(PsiFile::getVirtualFile).orElseGet(yamlFile::getVirtualFile)).orElse(null);\n    }\n\n    public static YAMLFile getPsiFile(final PsiElement element) {\n        if (element == null) {\n            return null;", "    public static YAMLFile getPsiFile(final PsiElement element) {\n        if (element == null) {\n            return null;\n        } else if (element instanceof final YAMLFile yamlFile) {\n            return yamlFile;\n        } else {\n            return getPsiFile(element.getParent());\n        }\n    }\n\n    public static YamlElement yamlOf(final PsiElement element) {\n        final PsiElement rootPsiElement = getYamlRoot(element);\n        final YamlElement rootYamlElement = ofNullable(rootPsiElement).map(root -> yamlOf(createRootElement(element), root)).orElse(null);\n        ofNullable(rootYamlElement)\n                .map(yamlElement -> rootPsiElement)\n                .map(YamlElementHelper::getPsiFile)\n                .map(yamlFile -> Optional.of(yamlFile.getOriginalFile()).map(PsiFile::getVirtualFile).orElseGet(yamlFile::getVirtualFile))\n                .map(VirtualFile::getPath)\n                .ifPresent(patString -> WORKFLOW_CONTEXT_MAP.put(patString, rootYamlElement.context().init()));\n        return rootYamlElement;\n    }\n", "    public static YamlElement yamlOf(final PsiElement element) {\n        final PsiElement rootPsiElement = getYamlRoot(element);\n        final YamlElement rootYamlElement = ofNullable(rootPsiElement).map(root -> yamlOf(createRootElement(element), root)).orElse(null);\n        ofNullable(rootYamlElement)\n                .map(yamlElement -> rootPsiElement)\n                .map(YamlElementHelper::getPsiFile)\n                .map(yamlFile -> Optional.of(yamlFile.getOriginalFile()).map(PsiFile::getVirtualFile).orElseGet(yamlFile::getVirtualFile))\n                .map(VirtualFile::getPath)\n                .ifPresent(patString -> WORKFLOW_CONTEXT_MAP.put(patString, rootYamlElement.context().init()));\n        return rootYamlElement;\n    }\n", "    public static YamlElement yamlOf(final YamlElement parent, final PsiElement element) {\n        if (element instanceof YAMLFile || element instanceof YAMLDocument) {\n            return addChildren(parent, element.getChildren());\n        } else if (element instanceof YAMLMapping) {\n            return addChildren(parent, element.getChildren());\n        } else if (element instanceof final YAMLKeyValue yamlKeyValue) {\n            return createElement(parent, yamlKeyValue);\n        } else if (element instanceof final YAMLSequenceItem yamlSequenceItem) {\n            return addChildren(parent, yamlSequenceItem);\n        } else if (element instanceof final YAMLSequence yamlSequence) {\n            return addChildren(parent, yamlSequence);", "        } else if (element instanceof final YAMLSequence yamlSequence) {\n            return addChildren(parent, yamlSequence);\n        } else if (element instanceof YAMLQuotedText || element instanceof YAMLPlainTextImpl) {\n            return createElement(parent, (YAMLScalar) element);\n        } else if (element instanceof final YAMLBlockScalarImpl yamlBlockScalarImpl) {\n            return addChildren(parent, yamlBlockScalarImpl);\n        } else if (element instanceof YAMLCompoundValue\n                || element instanceof PsiErrorElementImpl\n                || element instanceof LeafPsiElement\n        ) {\n            //IGNORE\n            return parent;\n        } else {\n            throw new NotImplementedException(\"You have detected a new element which i did not recognise [\" + element.getClass().getSimpleName() + \"]\");\n        }\n    }\n\n    private static YamlElement addChildren(final YamlElement parent, final YAMLSequence element) {\n        Arrays.stream(element.getChildren()).map(child -> yamlOf(parent, child)).forEach(addToParent(parent));\n        return parent;\n    }\n\n    private static YamlElement addChildren(final YamlElement parent, final YAMLSequenceItem element) {\n        final YamlElement listItem = new YamlElement(\n                element.getTextRange().getStartOffset(),\n                element.getTextRange().getEndOffset(),\n                null,\n                null,\n                parent,\n                new ArrayList<>()\n        );\n        Arrays.stream(element.getChildren()).map(child -> yamlOf(listItem, child)).forEach(addToParent(listItem));\n        addToParent(parent).accept(listItem);\n        return parent;\n    }\n\n    private static YamlElement createRootElement(final PsiElement element) {\n        return addChildren(new YamlElement(\n                -1,\n                -1,\n                null,\n                element.getText(),\n                null,\n                new ArrayList<>()\n        ), element.getChildren());\n    }\n\n    private static YamlElement createElement(final YamlElement parent, final YAMLKeyValue element) {\n        return addChildren(new YamlElement(\n                element.getTextOffset(),\n                element.getTextOffset() + element.getKeyText().length(),\n                element.getKeyText(),\n                null,\n                parent,\n                new ArrayList<>()\n        ), element.getChildren());\n    }\n\n    //ATTENTION: \"YAMLScalar\" is nearly everything. Use with care\n    private static YamlElement createElement(final YamlElement parent, final YAMLScalar element) {\n        return addChildren(new YamlElement(\n                element.getTextRange().getStartOffset(),\n                element.getTextRange().getEndOffset(),\n                null,\n                element.getText(),\n                parent,\n                new ArrayList<>()\n        ), element.getChildren());\n    }\n\n    private static YamlElement addChildren(final YamlElement parent, final PsiElement[] children) {", "        if (children != null && parent != null) {\n            parent.children().addAll(Arrays.stream(children)\n                    .filter(child -> child.getLanguage().isKindOf(YAMLLanguage.INSTANCE))\n                    .map(child -> yamlOf(parent, child))\n                    .filter(Objects::nonNull)\n                    .filter(e -> !e.equals(parent))\n                    .toList());\n        }\n        return parent;\n    }\n\n    private static YamlElement addChildren(final YamlElement parent, final YAMLBlockScalarImpl element) {", "        if (parent != null) {\n            element.getContentRanges().stream().map(textRange -> new YamlElement(\n                    element.getTextRange().getStartOffset() + textRange.getStartOffset(),\n                    element.getTextRange().getStartOffset() + textRange.getEndOffset(),\n                    null,\n                    element.getText().substring(textRange.getStartOffset(), textRange.getEndOffset()),\n                    parent,\n                    null\n            )).forEach(addToParent(parent));\n        }\n        return parent;\n    }\n", "    public static List<YamlElement> filterNodesRecursive(final YamlElement currentNode, final Predicate<YamlElement> filter, final List<YamlElement> resultNodes) {\n        if (filter.test(currentNode)) {\n            resultNodes.add(currentNode);\n        }\n        for (final YamlElement child : currentNode.children) {\n            filterNodesRecursive(child, filter, resultNodes);\n        }\n        return resultNodes;\n    }\n\n    private static Consumer<YamlElement> addToParent(final YamlElement parent) {\n        return child -> ofNullable(parent)\n                .filter(p -> child != null)\n                .filter(p -> child != p)\n                .filter(p -> !p.children().contains(child))\n                .ifPresent(p -> p.children().add(child));\n    }\n", "    public static boolean hasText(final String str) {\n        return (str != null && !str.isEmpty() && containsText(str));\n    }\n\n    private static boolean containsText(final CharSequence str) {\n        final int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n", "    public static String removeQuotes(final String result) {\n        return removeBrackets(result, '\"', '\\'');\n    }\n\n    public static String removeBrackets(final String text, final char... chars) {\n        if (text != null && text.length() > 1) {\n            for (final char c : chars) {\n                if (text.charAt(0) == c && text.charAt(text.length() - 1) == (c == '[' ? ']' : validateRoundBracket(c))) {\n                    return text.substring(1, text.length() - 1);\n                }\n            }\n        }\n        return text;\n    }\n\n    private static char validateRoundBracket(final char c) {\n        return c == '(' ? ')' : c;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/CompletionItem.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.github.yunabraska.githubworkflow.config.NodeIcon;\nimport com.intellij.codeInsight.lookup.LookupElement;\nimport com.intellij.openapi.project.Project;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;", "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;", "import java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.getDescription;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.orEmpty;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.DEFAULT_VALUE_MAP;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ENVS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_NEEDS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ON;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;", "import static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ON;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_SECRETS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_STEPS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_USES;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.*;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.hasText;\nimport static java.util.Optional.ofNullable;\n\npublic class CompletionItem {\n\n    private final String key;\n    private final String text;\n    private final NodeIcon icon;\n\n    public CompletionItem(final String key, final String text, final NodeIcon icon) {\n        this.key = key;\n        this.text = text;\n        this.icon = icon != null ? icon : NodeIcon.ICON_NODE;\n    }\n", "\npublic class CompletionItem {\n\n    private final String key;\n    private final String text;\n    private final NodeIcon icon;\n\n    public CompletionItem(final String key, final String text, final NodeIcon icon) {\n        this.key = key;\n        this.text = text;\n        this.icon = icon != null ? icon : NodeIcon.ICON_NODE;\n    }\n", "    public String key() {\n        return key;\n    }\n\n    public LookupElement toLookupElement() {\n        return GitHubWorkflowUtils.toLookupElement(icon, Character.MIN_VALUE, key, text);\n    }\n\n    public static List<CompletionItem> listSteps(final YamlElement position) {\n        //StepList position == step?    list previous steps in current job\n        //StepList position == outputs? list all      steps in current job\n        final int stepOffset = position.findParentStep().map(YamlElement::startIndexAbs).orElse(-1);\n        return position.findParentJob()\n                .map(YamlElement::listSteps)\n                .map(steps -> steps.stream()\n                        .filter(step -> hasText(step.id()))\n                        .filter(step -> stepOffset == -1 || step.startIndexAbs() < stepOffset)\n                        .collect(Collectors.toMap(step -> ofNullable(step.id()).orElseGet(() -> \"step_\" + step.childIndex()), YamlElement::usesOrName, (existing, replacement) -> existing))\n                )\n                .map(map -> completionItemsOf(map, ICON_STEP))\n                .orElseGet(ArrayList::new);\n    }\n", "    public static List<CompletionItem> listSteps(final YamlElement position) {\n        //StepList position == step?    list previous steps in current job\n        //StepList position == outputs? list all      steps in current job\n        final int stepOffset = position.findParentStep().map(YamlElement::startIndexAbs).orElse(-1);\n        return position.findParentJob()\n                .map(YamlElement::listSteps)\n                .map(steps -> steps.stream()\n                        .filter(step -> hasText(step.id()))\n                        .filter(step -> stepOffset == -1 || step.startIndexAbs() < stepOffset)\n                        .collect(Collectors.toMap(step -> ofNullable(step.id()).orElseGet(() -> \"step_\" + step.childIndex()), YamlElement::usesOrName, (existing, replacement) -> existing))\n                )\n                .map(map -> completionItemsOf(map, ICON_STEP))\n                .orElseGet(ArrayList::new);\n    }\n", "    public static List<CompletionItem> listStepOutputs(final Project project, final YamlElement position, final int cursorAbs, final String stepId) {\n        return position\n                .findParentJob()\n                .flatMap(job -> job.child(FIELD_STEPS))\n                .flatMap(steps -> steps.childId(stepId))\n                //ALL STEPS IF [job.job_id.outputs.key:value] else only steps before current step [job.job_id.steps:*]\n                .filter(step -> position.findParentOutput().isPresent() || step.endIndexAbs() < cursorAbs)\n                .map(step -> {\n                    //STEP OUTPUTS FROM USES [ACTION/WORKFLOW]\n                    final List<CompletionItem> result = ofNullable(step.uses()).map(GitHubAction::getGitHubAction).map(action -> action.outputs(project)).map(map -> completionItemsOf(map, ICON_OUTPUT)).orElseGet(ArrayList::new);\n                    //STEP OUTPUTS FROM TEXT\n                    position.context().runOutputs().values().stream()\n                            .filter(run -> stepId != null && run.findParentStep().filter(parent -> stepId.equals(parent.id())).isPresent())\n                            .map(run -> completionItemOf(run.key(), run.textOrChildTextNoQuotes(), ICON_TEXT_VARIABLE))\n                            .forEach(result::add);\n                    return result;\n                }).orElseGet(ArrayList::new);\n    }\n", "    public static List<CompletionItem> listJobs(final YamlElement position) {\n        //JobList is only valid in Workflow outputs\n        //TODO: cut \"uses\" to a smaller size like \"workflow@tag\"\n        return position\n                .findParentOutput()\n                .map(YamlElement::findParentOn)\n                .map(on -> position.context().jobs().values().stream().collect(Collectors.toMap(YamlElement::key, job -> ofNullable(job.usesOrName()).orElse(\"job_\" + job.childIndex()), (existing, replacement) -> existing)))\n                .map(map -> completionItemsOf(map, ICON_JOB))\n                .orElseGet(ArrayList::new);\n    }\n", "    public static List<CompletionItem> listJobOutputs(final Project project, final YamlElement position, final String jobId) {\n        final List<CompletionItem> result = new ArrayList<>();\n        final Optional<YamlElement> jobNode = position.context().jobs().values().stream().filter(job -> jobId != null && jobId.equals(job.key())).findFirst();\n\n        //JOB OUTPUTS\n        jobNode.flatMap(job -> job.child(FIELD_OUTPUTS).map(YamlElement::children))\n                .ifPresent(outputs -> outputs.stream().filter(hasKey()).map(output -> completionItemOf(output.key(), output.textOrChildTextNoQuotes(), ICON_OUTPUT)).forEach(result::add));\n\n\n        //JOB USES OUTPUTS\n        jobNode.flatMap(job -> job.child(FIELD_USES).map(YamlElement::textOrChildTextNoQuotes))\n                .map(GitHubAction::getGitHubAction)\n                .map(action -> action.outputs(project))\n                .map(childList -> completionItemsOf(childList, ICON_OUTPUT))\n                .ifPresent(result::addAll);\n        return result;\n    }\n", "    public static List<CompletionItem> listNeeds(final YamlElement position) {\n        final Integer positionJob = position.findParentJob().map(YamlElement::startIndexAbs).orElse(-1);\n        return position.context().jobs().values()\n                .stream()\n                .filter(hasKey())\n                .filter(job -> job.startIndexAbs() < positionJob)\n                .map(job -> completionItemOf(job.key(), ofNullable(job.usesOrName()).orElse(\"job_\" + job.childIndex()), ICON_NEEDS))\n                .collect(Collectors.toCollection(ArrayList::new));\n    }\n\n    public static List<CompletionItem> listJobNeeds(final YamlElement position) {\n        final Integer positionJob = position.findParentJob().map(YamlElement::startIndexAbs).orElse(-1);\n        final List<String> validJobs = position.context().jobs().values()\n                .stream()\n                .filter(hasKey())\n                .filter(job -> job.startIndexAbs() < positionJob)\n                .map(YamlElement::key)\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return position.findParentJob()\n                .flatMap(job -> job.child(FIELD_NEEDS))\n                .map(needs -> Stream.of(new String[]{ofNullable(needs.textNoQuotes()).orElse(\"\")}, needs.children().stream().map(YamlElement::textOrChildTextNoQuotes).toArray(String[]::new))\n                        .flatMap(Arrays::stream)\n                        .filter(YamlElementHelper::hasText)\n                        .filter(validJobs::contains)\n                        .map(need -> completionItemOf(need, \"\", ICON_NEEDS))\n                        .collect(Collectors.toCollection(ArrayList::new))\n                )\n                .orElse(new ArrayList<>());\n    }\n", "    public static List<CompletionItem> listJobNeeds(final YamlElement position) {\n        final Integer positionJob = position.findParentJob().map(YamlElement::startIndexAbs).orElse(-1);\n        final List<String> validJobs = position.context().jobs().values()\n                .stream()\n                .filter(hasKey())\n                .filter(job -> job.startIndexAbs() < positionJob)\n                .map(YamlElement::key)\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return position.findParentJob()\n                .flatMap(job -> job.child(FIELD_NEEDS))\n                .map(needs -> Stream.of(new String[]{ofNullable(needs.textNoQuotes()).orElse(\"\")}, needs.children().stream().map(YamlElement::textOrChildTextNoQuotes).toArray(String[]::new))\n                        .flatMap(Arrays::stream)\n                        .filter(YamlElementHelper::hasText)\n                        .filter(validJobs::contains)\n                        .map(need -> completionItemOf(need, \"\", ICON_NEEDS))\n                        .collect(Collectors.toCollection(ArrayList::new))\n                )\n                .orElse(new ArrayList<>());\n    }\n", "    public static List<CompletionItem> listInputs(final YamlElement position) {\n        final Map<String, String> result = new HashMap<>();\n        position.context().inputs().values().stream()\n                .filter(hasKey())\n                .forEach(input -> {\n                    final String description = getDescription(input);\n                    final String previousDescription = result.computeIfAbsent(input.key(), value -> description);\n                    if (previousDescription.length() < description.length()) {\n                        result.put(input.key(), description);\n                    }\n                });\n        return completionItemsOf(result, ICON_INPUT);\n    }\n", "    public static List<CompletionItem> listSecrets(final YamlElement position) {\n        //FIXME is this valid? JOB SECRETS\n//        result.addAll(part.get()\n//                .getCurrentNode()\n//                .toWorkflowFile()\n//                .getParentJob(full.get())\n//                .flatMap(job -> job.children().stream().filter(node -> node.hasName(FIELD_SECRETS)).findFirst())\n//                .map(envs -> completionItemsOf(envs.children(), ICON_SECRET_JOB))\n//                .orElse(new ArrayList<>()));\n\n        //WORKFLOW SECRETS\n        return position.context().root()\n                .child(FIELD_ON)\n                .map(on -> on.findChildNodes(secrets -> FIELD_SECRETS.equals(secrets.key())))\n                .map(secrets -> secrets.stream().flatMap(secret -> secret.children().stream()).filter(hasKey()).collect(Collectors.toMap(YamlElement::key, GitHubWorkflowUtils::getDescription, (existing, replacement) -> existing)))\n                .map(map -> completionItemsOf(map, ICON_SECRET_WORKFLOW))\n                .orElseGet(ArrayList::new);\n    }\n", "    public static List<CompletionItem> listEnvs(final YamlElement position, final int cursorAbs) {\n        //CURRENT STEP TEXT ENVS [jobs.job_id.steps.step_id.run:key=value]\n        final List<CompletionItem> result = new ArrayList<>(completionItemsOf(position.context().runEnvs().values().stream()\n                        .filter(env -> env.startIndexAbs() < cursorAbs && env.endIndexAbs() < cursorAbs)\n                        .collect(Collectors.toMap(YamlElement::key, YamlElement::textOrChildTextNoQuotes, (existing, replacement) -> existing))\n                , ICON_TEXT_VARIABLE));\n\n        //CURRENT STEP ENVS [step.env.env_key:env_value]\n        position\n                .findParentStep()\n                .flatMap(step -> step.child(FIELD_ENVS))\n                .map(YamlElement::children)\n                .map(toMapWithKeyAndText())\n                .map(map -> completionItemsOf(map, ICON_ENV_STEP))\n                .ifPresent(result::addAll);\n\n        //CURRENT JOB ENVS [jobs.job_id.envs.env_id:env_value]\n        position\n                .findParentJob()\n                .flatMap(step -> step.child(FIELD_ENVS))\n                .map(YamlElement::children)\n                .map(toMapWithKeyAndText())\n                .map(map -> completionItemsOf(map, ICON_ENV_JOB))\n                .ifPresent(result::addAll);\n\n        //WORKFLOW ENVS\n        position.context().root()\n                .child(FIELD_ENVS)\n                .map(YamlElement::children)\n                .map(toMapWithKeyAndText())\n                .map(map -> completionItemsOf(map, ICON_ENV_ROOT))\n                .ifPresent(result::addAll);\n\n        //DEFAULT ENVS\n        result.addAll(completionItemsOf(DEFAULT_VALUE_MAP.get(FIELD_ENVS).get(), ICON_ENV));\n\n        return result;\n    }\n\n    private static Function<List<YamlElement>, Map<String, String>> toMapWithKeyAndText() {\n        return elements -> elements.stream()\n                .filter(hasKey())\n                .filter(hasTextOrChildText())\n                .collect(Collectors.toMap(YamlElement::key, YamlElement::textOrChildTextNoQuotes, (existing, replacement) -> existing));\n    }\n\n    private static Predicate<YamlElement> hasKey() {\n        return element -> element != null && hasText(element.key());\n    }\n\n    private static Predicate<YamlElement> hasTextOrChildText() {\n        return element -> element != null && hasText(element.textOrChildTextNoQuotes());\n    }\n", "    public static List<CompletionItem> completionItemsOf(final Map<String, String> map, final NodeIcon icon) {\n        return map == null ? new ArrayList<>() : map.entrySet().stream()\n                .map(item -> completionItemOf(item.getKey(), item.getValue(), icon))\n                .filter(Objects::nonNull)\n                .collect(Collectors.toCollection(ArrayList::new));\n    }\n\n    public static CompletionItem completionItemOf(final String key, final String text, final NodeIcon icon) {\n        return key == null ? null : new CompletionItem(key, orEmpty(text), icon);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/WorkflowContext.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\n\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;", "import java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ENVS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_INPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_JOBS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_NEEDS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;", "import static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_NEEDS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_RUN;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_SECRETS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_STEPS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_USES;\nimport static java.util.Comparator.comparingInt;\nimport static java.util.Optional.ofNullable;\n\n@SuppressWarnings({\"unused\", \"java:S2386\"})\npublic class WorkflowContext {\n", "\n@SuppressWarnings({\"unused\", \"java:S2386\"})\npublic class WorkflowContext {\n\n    public static final Map<String, WorkflowContext> WORKFLOW_CONTEXT_MAP = new ConcurrentHashMap<>();\n    protected final AtomicInteger cursorAbs = new AtomicInteger(-1);\n    protected final AtomicReference<YamlElement> root = new AtomicReference<>(null);\n    protected final Map<String, YamlElement> jobs = new HashMap<>();\n    protected final Map<String, YamlElement> needs = new HashMap<>();\n    protected final Map<String, YamlElement> steps = new HashMap<>();\n    protected final Map<String, YamlElement> inputs = new HashMap<>();\n    protected final Map<String, YamlElement> envs = new HashMap<>();\n    protected final Map<String, YamlElement> runEnvs = new HashMap<>();\n    protected final Map<String, YamlElement> runOutputs = new HashMap<>();\n    protected final Map<String, YamlElement> secrets = new HashMap<>();\n    protected final Map<String, YamlElement> vars = new HashMap<>();\n    protected final Map<String, YamlElement> outputs = new HashMap<>();\n    protected final Map<String, GitHubAction> actions = new HashMap<>();\n\n    public WorkflowContext(final YamlElement root) {\n        this.root.set(root);\n    }\n\n    public Optional<YamlElement> getClosestElement(final int offset) {\n        return Optional.of(offset)\n                .filter(o -> o != -1)\n                .flatMap(cursorIndexAbs -> root().allElements()\n                        .filter(element -> element.startIndexAbs() <= offset && element.endIndexAbs() >= offset)\n                        .min(comparingInt(element -> getDistanceToIndex(element, offset))))\n                .or(() -> getLastElement(offset));\n    }\n\n    public Optional<YamlElement> getLastElement(final int offset) {\n        return Optional.of(offset)\n                .filter(o -> o != -1)\n                .flatMap(o -> root().allElements()\n                        .filter(element -> element.startIndexAbs() >= offset)\n                        .min(Comparator.comparingInt(YamlElement::startIndexAbs)));\n    }\n", "    public YamlElement root() {\n        return root.get();\n    }\n\n    public Map<String, YamlElement> jobs() {\n        return jobs;\n    }\n\n    public Map<String, YamlElement> needs() {\n        return needs;\n    }\n\n    public Map<String, YamlElement> steps() {\n        return steps;\n    }\n\n    public Map<String, YamlElement> inputs() {\n        return inputs;\n    }\n\n    public Map<String, YamlElement> envs() {\n        return envs;\n    }\n\n    public Map<String, YamlElement> secrets() {\n        return secrets;\n    }\n\n    public Map<String, YamlElement> vars() {\n        return vars;\n    }\n\n    public Map<String, YamlElement> outputs() {\n        return outputs;\n    }\n\n    public Map<String, YamlElement> runEnvs() {\n        return runEnvs;\n    }\n\n    public Map<String, YamlElement> runOutputs() {\n        return runOutputs;\n    }\n\n    public Map<String, GitHubAction> actions() {\n        return actions;\n    }\n", "    public WorkflowContext init() {\n        final YamlElement top = this.root.get();\n        if (top != null) {\n            Optional.of(top).ifPresent(r -> r.allElements().filter(Objects::nonNull).forEach(e -> {\n                switch (ofNullable(e.key()).orElse(\"#\")) {\n                    case FIELD_ENVS -> e.children().forEach(item -> envs.put(item.path(), item));\n                    case FIELD_STEPS -> e.children().forEach(item -> steps.put(item.path(), item));\n                    case FIELD_JOBS ->\n                        //if position is trigger node \"ON\" list all jobs\n                        //if position is needs\n                        //list job only when it has an output OR\n                            e.children().stream().filter(item -> item.key() != null).forEach(item -> jobs.put(item.path(), item));\n                    case FIELD_INPUTS ->\n                            e.children().stream().filter(child -> child.key() != null).forEach(child -> inputs.put(child.path(), child));\n                    case FIELD_OUTPUTS ->\n                            e.children().stream().filter(child -> child.key() != null).forEach(child -> outputs.put(child.path(), child));\n                    case FIELD_SECRETS ->\n                            e.children().stream().filter(child -> child.key() != null).forEach(child -> secrets.put(child.path(), child));\n                    case FIELD_NEEDS -> {\n                        //String\n                        ofNullable(e.childTextNoQuotes()).ifPresent(n -> needs.put(e.path() + \"/\" + e.childTextNoQuotes(), e));\n                        //Array[String]\n                        e.children().forEach(n -> needs.put(e.path() + \"/\" + n.childTextNoQuotes(), n));\n                    }\n                    case FIELD_RUN -> e.findParentStep().ifPresent(step -> e.children().forEach(line -> {\n                        parseEnvs(step, line);\n                        parseOutputs(step, line);\n                    }));\n                    case FIELD_USES -> {\n                        final String uses = e.childTextNoQuotes();\n                        //TODO: resolve TAGS & Branches\n                        actions.put(e.path() + \"/\" + uses, GitHubAction.getGitHubAction(uses));\n                    }\n                    default -> {\n                        // ignored\n                    }\n                }\n            }));\n        }\n        return this;\n    }\n\n    private static int getDistanceToIndex(final YamlElement element, final int targetIndex) {\n        return (targetIndex - element.startIndexAbs) + (element.endIndexAbs - targetIndex);\n    }\n\n    private void parseOutputs(final YamlElement step, final YamlElement line) {\n        ofNullable(line.text()).map(GitHubWorkflowUtils::toGithubOutputs).ifPresent(outputMap -> outputMap.entrySet().stream().map(output -> createElement(step, line, output)).forEach(output -> this.runOutputs.put(output.path(), output)));\n    }\n\n    private void parseEnvs(final YamlElement step, final YamlElement line) {\n        ofNullable(line.text()).map(GitHubWorkflowUtils::toGithubEnvs).ifPresent(envsMap -> envsMap.entrySet().stream().map(env -> createElement(step, line, env)).forEach(env -> this.runEnvs.put(env.path(), env)));\n    }\n\n    private YamlElement createElement(final YamlElement step, final YamlElement line, final Map.Entry<String, String> kv) {\n        return new YamlElement(\n                line.startIndexAbs(),\n                line.endIndexAbs(),\n                kv.getKey(),\n                kv.getValue(),\n                step,\n                null\n        );\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/NotImplementedException.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\npublic class NotImplementedException extends RuntimeException {\n    public NotImplementedException(final String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/YamlElement.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\nimport com.intellij.openapi.util.TextRange;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;", "import java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_JOBS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_NEEDS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ON;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;", "import static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ON;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_STEPS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_USES;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_WITH;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.filterNodesRecursive;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.removeQuotes;\nimport static java.util.Optional.ofNullable;\n\n@SuppressWarnings({\"SameReturnValue\", \"unused\"})\npublic class YamlElement {\n\n    protected final int startIndexAbs;\n    protected final int endIndexAbs;\n    protected final String key;\n    protected final String text;\n    protected final YamlElement parent;\n    protected final List<YamlElement> children;\n    protected final WorkflowContext context;", "\n@SuppressWarnings({\"SameReturnValue\", \"unused\"})\npublic class YamlElement {\n\n    protected final int startIndexAbs;\n    protected final int endIndexAbs;\n    protected final String key;\n    protected final String text;\n    protected final YamlElement parent;\n    protected final List<YamlElement> children;\n    protected final WorkflowContext context;", "    public static final String CURSOR_STRING = \"IntellijIdeaRulezzz\";\n\n    public YamlElement(\n            final int startIndexAbs,\n            final int endIndexAbs,\n            final String key,\n            final String text,\n            final YamlElement parent,\n            final List<YamlElement> children) {\n        this.startIndexAbs = startIndexAbs;\n        this.endIndexAbs = endIndexAbs;\n        this.key = key;\n        this.text = text;\n        this.parent = parent;\n        this.children = children != null ? children : Collections.emptyList();\n        this.context = parent == null ? new WorkflowContext(this) : null;\n    }\n", "    public YamlElement parent() {\n        return parent;\n    }\n\n    public List<YamlElement> children() {\n        return children;\n    }\n\n    public int startIndexAbs() {\n        return startIndexAbs;\n    }\n", "    public int startIndexAbs() {\n        return startIndexAbs;\n    }\n\n    public int endIndexAbs() {\n        return endIndexAbs;\n    }\n\n    public int startIndexRel() {\n        return 0;\n    }\n", "    public int startIndexRel() {\n        return 0;\n    }\n\n    public int endIndexRel() {\n        return endIndexAbs - startIndexAbs;\n    }\n\n    public String text() {\n        return text;\n    }\n", "    public String text() {\n        return text;\n    }\n\n    public String textNoQuotes() {\n        return removeQuotes(text);\n    }\n\n    public String textOrChildText() {\n        return ofNullable(text()).orElseGet(this::childText);\n    }\n", "    public String textOrChildText() {\n        return ofNullable(text()).orElseGet(this::childText);\n    }\n\n    public String textOrChildTextNoQuotes() {\n        return ofNullable(textNoQuotes()).orElseGet(this::childTextNoQuotes);\n    }\n\n    public TextRange textRange() {\n        return startIndexAbs > -1 && endIndexAbs >= startIndexAbs ? new TextRange(startIndexAbs(), endIndexAbs()) : null;\n    }\n", "    public TextRange textRange() {\n        return startIndexAbs > -1 && endIndexAbs >= startIndexAbs ? new TextRange(startIndexAbs(), endIndexAbs()) : null;\n    }\n\n    public String key() {\n        return key;\n    }\n\n    public String id() {\n        return this.child(\"id\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n", "    public String id() {\n        return this.child(\"id\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public String name() {\n        return this.child(\"name\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public String uses() {\n        return this.child(FIELD_USES).map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n", "    public String uses() {\n        return this.child(FIELD_USES).map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public String path() {\n        return ofNullable(parent).map(YamlElement::path).map(p -> p + \"/\").orElse(\"\") + this.keyOrIdOrName();\n    }\n\n    public String keyOrIdOrName() {\n        return ofNullable(ofNullable(this.key()).orElseGet(this::id)).orElseGet(this::name);\n    }\n", "    public String keyOrIdOrName() {\n        return ofNullable(ofNullable(this.key()).orElseGet(this::id)).orElseGet(this::name);\n    }\n\n    public String type() {\n        return this.child(\"type\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public String description() {\n        return ofNullable(this.child(\"description\").orElseGet(() -> this.child(\"desc\").orElse(null))).map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n", "    public String description() {\n        return ofNullable(this.child(\"description\").orElseGet(() -> this.child(\"desc\").orElse(null))).map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public boolean required() {\n        return child(\"required\").map(YamlElement::childTextNoQuotes).map(Boolean::parseBoolean).orElse(false);\n    }\n\n    public String childDefault() {\n        return child(\"default\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n", "    public String childDefault() {\n        return child(\"default\").map(YamlElement::childTextNoQuotes).orElse(null);\n    }\n\n    public int childIndex() {\n        return parent == null ? -1 : this.parent().children().indexOf(this);\n    }\n\n\n    public WorkflowContext context() {\n        return root().context;\n    }\n", "    public WorkflowContext context() {\n        return root().context;\n    }\n\n    public YamlElement root() {\n        YamlElement current = this;\n        while (current.parent() != null) {\n            current = current.parent();\n        }\n        return current;\n    }\n\n    public Stream<YamlElement> allElements() {\n        return Stream.concat(Stream.of(this), children().stream().flatMap(YamlElement::allElements));\n    }\n", "    public String childText() {\n        return children.isEmpty() ? null : children.iterator().next().text();\n    }\n\n    public String childTextNoQuotes() {\n        return removeQuotes(childText());\n    }\n\n    public List<YamlElement> findChildNodes(final Predicate<YamlElement> filter) {\n        return filterNodesRecursive(this, filter, new ArrayList<>());\n    }\n\n    public Optional<YamlElement> child(final String key) {\n        return this.children().stream().filter(child -> key != null && child.key() != null && key.equalsIgnoreCase(child.key())).findFirst();\n    }\n\n    public Optional<YamlElement> childId(final String id) {\n        return this.children().stream().filter(child -> id != null && child.id() != null && id.equalsIgnoreCase(child.id())).findFirst();\n    }\n\n    public Optional<YamlElement> child(final Predicate<YamlElement> filter) {\n        return this.children().stream().filter(filter).findFirst();\n    }\n\n    public Optional<YamlElement> findParent(final String key) {\n        return findParent(p -> key.equalsIgnoreCase(p.key()));\n    }\n\n    public Optional<YamlElement> findParent(final Predicate<YamlElement> filter) {\n        final boolean result = parent != null && filter.test(parent);\n        return result || parent == null ? ofNullable(parent) : parent.findParent(filter);\n    }\n\n    //GITHUB SPECIFIC FILTERS", "    public String usesOrName() {\n        return ofNullable(this.uses()).orElseGet(this::name);\n    }\n\n    public Optional<YamlElement> findParentJob() {\n        return findParent(job -> ofNullable(job.parent()).map(YamlElement::key).filter(FIELD_JOBS::equals).isPresent());\n    }\n\n    public Optional<YamlElement> findParentStep() {\n        return findParent(job -> ofNullable(job.parent()).map(YamlElement::key).filter(FIELD_STEPS::equals).isPresent());\n    }\n\n\n    public Optional<YamlElement> findParentOutput() {\n        return findParent(outputs -> FIELD_OUTPUTS.equals(outputs.key()));\n    }\n\n    public Optional<YamlElement> findParentWith() {\n        return findParent(outputs -> FIELD_WITH.equals(outputs.key()));\n    }\n\n    public Optional<YamlElement> findParentOn() {\n        return findParent(outputs -> FIELD_ON.equals(outputs.key()));\n    }\n\n    public List<YamlElement> listSteps() {\n        return findChildNodes(step -> ofNullable(step.parent()).map(YamlElement::key).filter(FIELD_STEPS::equals).isPresent());\n    }\n\n    public Set<String> needItems() {\n        final Set<String> result = new HashSet<>();", "        if (FIELD_NEEDS.equals(key())) {\n            ofNullable(textOrChildTextNoQuotes()).ifPresent(result::add);\n            children.stream().map(YamlElement::textOrChildTextNoQuotes).filter(Objects::nonNull).forEach(result::add);\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return this.getClass().getSimpleName()\n                + \"{\"\n                + \"key='\" + keyOrIdOrName() + '\\''\n                + \", text='\" + textNoQuotes() + '\\''\n                + \", children=\" + children().size()\n                + '}';\n    }\n}\n", "    public String toString() {\n        return this.getClass().getSimpleName()\n                + \"{\"\n                + \"key='\" + keyOrIdOrName() + '\\''\n                + \", text='\" + textNoQuotes() + '\\''\n                + \", children=\" + children().size()\n                + '}';\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/model/GitHubAction.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.model;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.application.ApplicationManager;\nimport com.intellij.openapi.diagnostic.Logger;\nimport com.intellij.openapi.fileTypes.FileTypeManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.project.ProjectUtil;\nimport com.intellij.psi.PsiFileFactory;\nimport com.intellij.psi.PsiManager;", "import com.intellij.psi.PsiFileFactory;\nimport com.intellij.psi.PsiManager;\nimport org.jetbrains.yaml.psi.YAMLFile;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;", "import java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.cachePath;", "\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.cachePath;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadAction;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.ACTION_CACHE;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.CACHE_ONE_DAY;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.CACHE_TEN_MINUTES;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_INPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_ON;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.WORKFLOW_CACHE;", "import static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.FIELD_OUTPUTS;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.WORKFLOW_CACHE;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.hasText;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.yamlOf;\nimport static java.util.Optional.ofNullable;\n\n@SuppressWarnings(\"unused\")\npublic class GitHubAction {\n\n    private final Map<String, String> inputs = new ConcurrentHashMap<>();\n    private final Map<String, String> outputs = new ConcurrentHashMap<>();\n    private final AtomicLong expiration = new AtomicLong(0);\n    //TODO: get Tags for autocompletion\n    private final List<String> tags = new CopyOnWriteArrayList<>();\n    private final AtomicReference<String> ref = new AtomicReference<>(null);\n    private final AtomicReference<String> slug = new AtomicReference<>(null);\n    private final AtomicReference<String> sub = new AtomicReference<>(\"\");\n    private final AtomicReference<String> actionName = new AtomicReference<>(null);\n    private final AtomicReference<String> downloadUrl = new AtomicReference<>(null);\n    private final AtomicReference<String> uses = new AtomicReference<>(null);\n    private final AtomicBoolean isAvailable = new AtomicBoolean(false);\n    private final AtomicBoolean isAction = new AtomicBoolean(false);\n    private final AtomicBoolean isLocal = new AtomicBoolean(false);\n    private static final Logger LOG = Logger.getInstance(GitHubAction.class);\n", "    public static GitHubAction getGitHubAction(final String uses) {\n        try {\n            final String cleanedUses = uses == null ? null : uses.replace(\"IntellijIdeaRulezzz \", \"\").trim();\n            GitHubAction gitHubAction = ACTION_CACHE.getOrDefault(uses, null);\n            if (gitHubAction == null || gitHubAction.expiration() < System.currentTimeMillis()) {\n                ofNullable(gitHubAction).ifPresent(GitHubAction::deleteFile);\n                gitHubAction = new GitHubAction(cleanedUses);\n                ACTION_CACHE.put(uses, gitHubAction);\n            }\n            return gitHubAction;\n        } catch (final Exception e) {\n            return new GitHubAction(null);\n        }\n    }\n\n    public Map<String, String> inputs(final Project project) {", "        if (isLocal.get()) {\n            return extractLocalParameters(project, downloadUrl.get(), FIELD_INPUTS);\n        }\n        return inputs;\n    }\n\n    public Map<String, String> outputs(final Project project) {\n        if (isLocal.get()) {\n            return extractLocalParameters(project, downloadUrl.get(), FIELD_OUTPUTS);\n        }\n        return outputs;\n    }\n", "    public long expiration() {\n        return expiration.get();\n    }\n\n    public List<String> tags() {\n        return tags;\n    }\n\n    public String ref() {\n        return ref.get();\n    }\n", "    public String ref() {\n        return ref.get();\n    }\n\n    public String slug() {\n        return slug.get();\n    }\n\n    public String actionName() {\n        return actionName.get();\n    }\n", "    public String actionName() {\n        return actionName.get();\n    }\n\n    public String sub() {\n        return sub.get();\n    }\n\n    public boolean isAvailable() {\n        return isAvailable.get();\n    }\n", "    public boolean isAvailable() {\n        return isAvailable.get();\n    }\n\n    public boolean isAction() {\n        return isAction.get();\n    }\n\n    public String uses() {\n        return uses.get();\n    }\n", "    public String uses() {\n        return uses.get();\n    }\n\n    public String toUrl() {\n        return isAction.get() ? toActionYamlUrl() : toWorkflowYamlUrl();\n    }\n\n    public String toRawUrl() {\n        return isAction.get() ? toRawActionYamlUrl() : toRawWorkflowYamlUrl();\n    }\n", "    public String toRawUrl() {\n        return isAction.get() ? toRawActionYamlUrl() : toRawWorkflowYamlUrl();\n    }\n\n    public String marketplaceUrl() {\n        return (\"https://github.com/marketplace/\" + slug.get());\n    }\n\n    private String toActionYamlUrl() {\n        return (ref.get() != null && slug.get() != null && sub.get() != null) ? \"https://github.com/\" + slug.get() + \"/blob/\" + ref.get() + sub.get() + \"/action.yml\" : null;\n    }\n\n    private String toRawActionYamlUrl() {\n        return (ref.get() != null && slug.get() != null && sub.get() != null) ? \"https://raw.githubusercontent.com/\" + slug.get() + \"/\" + ref.get() + sub.get() + \"/action.yml\" : null;\n    }\n\n    private String toWorkflowYamlUrl() {\n        return (ref.get() != null && slug.get() != null) ? \"https://github.com/\" + slug.get() + \"/blob/\" + ref.get() + \"/.github/workflows/\" + actionName : null;\n    }\n\n    private String toRawWorkflowYamlUrl() {\n        return (ref.get() != null && slug.get() != null) ? \"https://raw.githubusercontent.com/\" + slug.get() + \"/\" + ref.get() + \"/.github/workflows/\" + actionName : null;\n    }\n\n    private String toGitHubUrl() {\n        return (slug.get() != null && ref.get() != null) ? \"https://github.com/\" + slug.get() + \"/tree\" + ref.get() : null;\n    }\n\n    private GitHubAction(final String uses) {", "        if (uses != null) {\n            final int tagIndex = uses.indexOf(\"@\");\n            final int userNameIndex = uses.indexOf(\"/\");\n            final int repoNameIndex = uses.indexOf(\"/\", userNameIndex + 1);\n            this.uses.set(uses);\n            isLocal.set(tagIndex == -1);\n            ref.set(tagIndex != -1 ? uses.substring(tagIndex + 1) : null);\n            isAction.set(isLocal.get() || (!uses.contains(\".yaml\") && !uses.contains(\".yml\") && !uses.contains(\".action.y\")));\n            if (tagIndex != -1 && userNameIndex < tagIndex) {\n                slug.set(uses.substring(0, repoNameIndex > 0 ? repoNameIndex : tagIndex));\n                if (!isAction.get()) {\n                    actionName.set(uses.substring(uses.lastIndexOf(\"/\") + 1, tagIndex));\n                } else {\n                    sub.set(repoNameIndex < tagIndex && repoNameIndex > 0 ? \"/\" + uses.substring(repoNameIndex + 1, tagIndex) : \"\");\n                    actionName.set(uses.substring(userNameIndex + 1, tagIndex));\n                }\n            } else {\n                actionName.set(uses);\n            }\n            downloadUrl.set(isLocal.get() ? uses + \"/action.yml\" : toRawUrl());\n        }\n    }\n", "            if (tagIndex != -1 && userNameIndex < tagIndex) {\n                slug.set(uses.substring(0, repoNameIndex > 0 ? repoNameIndex : tagIndex));\n                if (!isAction.get()) {\n                    actionName.set(uses.substring(uses.lastIndexOf(\"/\") + 1, tagIndex));\n                } else {\n                    sub.set(repoNameIndex < tagIndex && repoNameIndex > 0 ? \"/\" + uses.substring(repoNameIndex + 1, tagIndex) : \"\");\n                    actionName.set(uses.substring(userNameIndex + 1, tagIndex));\n                }\n            } else {\n                actionName.set(uses);\n            }\n            downloadUrl.set(isLocal.get() ? uses + \"/action.yml\" : toRawUrl());\n        }\n    }\n", "    public void resolve(final Project project) {\n        if (!isAvailable.get()) {\n            setActionParameters(project, downloadUrl.get());\n        }\n    }\n\n    public void deleteCache() {\n        isAvailable.set(false);\n        WORKFLOW_CACHE.remove(workFlowCacheId());\n        deleteFile();\n    }\n\n    private void deleteFile() {\n        Optional.of(cachePath(this)).filter(Files::exists).ifPresent(path -> {", "            try {\n                Files.deleteIfExists(path);\n            } catch (final IOException ignored) {\n                // ignored\n            }\n        });\n    }\n\n    private void setActionParameters(final Project project, final String downloadUrl) {\n        try {\n            if (isLocal.get()) {\n                isAvailable.set(ofNullable(project)\n                        .map(ProjectUtil::guessProjectDir)\n                        .map(dir -> dir.findFileByRelativePath(downloadUrl))\n                        .isPresent());\n                expiration.set(System.currentTimeMillis() + CACHE_TEN_MINUTES);\n                WORKFLOW_CACHE.put(workFlowCacheId(), new WorkflowContext(null));\n            } else {\n                extractActionParameters(project, downloadAction(downloadUrl, this));\n            }\n        } catch (final Exception e) {\n            LOG.warn(\"Failed to set parameters [\" + this.uses.get() + \"]\", e);\n            isAvailable.set(false);\n            expiration.set(System.currentTimeMillis() + CACHE_TEN_MINUTES);\n        }\n    }\n\n    private void extractActionParameters(final Project project, final String content) {\n        isAvailable.set(hasText(content));\n        expiration.set(System.currentTimeMillis() + (hasText(content) ? CACHE_ONE_DAY : CACHE_TEN_MINUTES));\n        final WorkflowContext context = contextOf(project, workFlowCacheId(), content);\n        inputs.putAll(getActionParameters(context, FIELD_INPUTS, isAction.get()));\n        outputs.putAll(getActionParameters(context, FIELD_OUTPUTS, isAction.get()));\n    }\n\n    private Map<String, String> extractLocalParameters(final Project project, final String path, final String nodeKey) {\n        final AtomicReference<Map<String, String>> result = new AtomicReference<>(new HashMap<>());\n        ApplicationManager.getApplication().runReadAction(() -> ofNullable(project)\n                .map(ProjectUtil::guessProjectDir)\n                .map(dir -> dir.findFileByRelativePath(path))\n                .map(file -> PsiManager.getInstance(project).findFile(file))\n                .filter(YAMLFile.class::isInstance)\n//                    .map(PsiElement::getChildren)\n//                    .map(children -> children.length > 0 ? children[0] : null)\n                .map(YamlElementHelper::yamlOf)\n                .map(YamlElement::context)\n                .map(context -> getActionParameters(context, nodeKey, isAction.get()))\n                .ifPresent(result::set));\n        return result.get();\n    }\n\n    private String workFlowCacheId() {\n        return actionName() + \"_\" + ref();\n    }\n\n    private Map<String, String> getActionParameters(final WorkflowContext context, final String nodeKey, final boolean action) {\n        return context.root()\n                .findChildNodes(child ->\n                        (ofNullable(child.parent()).filter(parent -> nodeKey.equals(parent.key())).isPresent())\n                                && (action || ofNullable(child.parent()).map(YamlElement::parent).map(YamlElement::parent).filter(parent -> FIELD_ON.equals(parent.key())).isPresent())\n                )\n                .stream()\n                .filter(child -> hasText(child.keyOrIdOrName()))\n                .collect(Collectors.toMap(YamlElement::keyOrIdOrName, GitHubWorkflowUtils::getDescription, (existing, replacement) -> existing));\n    }\n\n    private WorkflowContext contextOf(final Project project, final String key, final String text) {\n        // READ CONTEXT\n        final AtomicReference<WorkflowContext> contextRef = new AtomicReference<>();\n        ApplicationManager.getApplication().runReadAction(() -> {", "        try {\n            if (isLocal.get()) {\n                isAvailable.set(ofNullable(project)\n                        .map(ProjectUtil::guessProjectDir)\n                        .map(dir -> dir.findFileByRelativePath(downloadUrl))\n                        .isPresent());\n                expiration.set(System.currentTimeMillis() + CACHE_TEN_MINUTES);\n                WORKFLOW_CACHE.put(workFlowCacheId(), new WorkflowContext(null));\n            } else {\n                extractActionParameters(project, downloadAction(downloadUrl, this));\n            }\n        } catch (final Exception e) {\n            LOG.warn(\"Failed to set parameters [\" + this.uses.get() + \"]\", e);\n            isAvailable.set(false);\n            expiration.set(System.currentTimeMillis() + CACHE_TEN_MINUTES);\n        }\n    }\n\n    private void extractActionParameters(final Project project, final String content) {\n        isAvailable.set(hasText(content));\n        expiration.set(System.currentTimeMillis() + (hasText(content) ? CACHE_ONE_DAY : CACHE_TEN_MINUTES));\n        final WorkflowContext context = contextOf(project, workFlowCacheId(), content);\n        inputs.putAll(getActionParameters(context, FIELD_INPUTS, isAction.get()));\n        outputs.putAll(getActionParameters(context, FIELD_OUTPUTS, isAction.get()));\n    }\n\n    private Map<String, String> extractLocalParameters(final Project project, final String path, final String nodeKey) {\n        final AtomicReference<Map<String, String>> result = new AtomicReference<>(new HashMap<>());\n        ApplicationManager.getApplication().runReadAction(() -> ofNullable(project)\n                .map(ProjectUtil::guessProjectDir)\n                .map(dir -> dir.findFileByRelativePath(path))\n                .map(file -> PsiManager.getInstance(project).findFile(file))\n                .filter(YAMLFile.class::isInstance)\n//                    .map(PsiElement::getChildren)\n//                    .map(children -> children.length > 0 ? children[0] : null)\n                .map(YamlElementHelper::yamlOf)\n                .map(YamlElement::context)\n                .map(context -> getActionParameters(context, nodeKey, isAction.get()))\n                .ifPresent(result::set));\n        return result.get();\n    }\n\n    private String workFlowCacheId() {\n        return actionName() + \"_\" + ref();\n    }\n\n    private Map<String, String> getActionParameters(final WorkflowContext context, final String nodeKey, final boolean action) {\n        return context.root()\n                .findChildNodes(child ->\n                        (ofNullable(child.parent()).filter(parent -> nodeKey.equals(parent.key())).isPresent())\n                                && (action || ofNullable(child.parent()).map(YamlElement::parent).map(YamlElement::parent).filter(parent -> FIELD_ON.equals(parent.key())).isPresent())\n                )\n                .stream()\n                .filter(child -> hasText(child.keyOrIdOrName()))\n                .collect(Collectors.toMap(YamlElement::keyOrIdOrName, GitHubWorkflowUtils::getDescription, (existing, replacement) -> existing));\n    }\n\n    private WorkflowContext contextOf(final Project project, final String key, final String text) {\n        // READ CONTEXT\n        final AtomicReference<WorkflowContext> contextRef = new AtomicReference<>();\n        ApplicationManager.getApplication().runReadAction(() -> {", "            try {\n                final WorkflowContext context = yamlOf(PsiFileFactory.getInstance(project).createFileFromText(key, FileTypeManager.getInstance().getFileTypeByExtension(\"yaml\"), text)).context();\n                contextRef.set(context);\n            } catch (final Exception e) {\n                final WorkflowContext defaultValue = new YamlElement(-1, -1, null, null, null, null).context().init();\n                contextRef.set(key == null ? defaultValue : WORKFLOW_CACHE.getOrDefault(key, defaultValue));\n            }\n        });\n\n        final WorkflowContext context = contextRef.get();\n        if (context != null && key != null) {\n            WORKFLOW_CACHE.put(key, context);\n        }\n\n        return context;\n    }\n\n}\n", "        if (context != null && key != null) {\n            WORKFLOW_CACHE.put(key, context);\n        }\n\n        return context;\n    }\n\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/highlights/HighlightAnnotator.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.highlights;\n\nimport com.github.yunabraska.githubworkflow.model.CompletionItem;\nimport com.github.yunabraska.githubworkflow.model.GitHubAction;\nimport com.github.yunabraska.githubworkflow.model.WorkflowContext;\nimport com.github.yunabraska.githubworkflow.model.YamlElement;\nimport com.github.yunabraska.githubworkflow.quickfixes.ClearWorkflowCacheAction;\nimport com.github.yunabraska.githubworkflow.quickfixes.OpenSettingsIntentionAction;\nimport com.github.yunabraska.githubworkflow.quickfixes.OpenUrlIntentionAction;\nimport com.github.yunabraska.githubworkflow.quickfixes.ReplaceTextIntentionAction;", "import com.github.yunabraska.githubworkflow.quickfixes.OpenUrlIntentionAction;\nimport com.github.yunabraska.githubworkflow.quickfixes.ReplaceTextIntentionAction;\nimport com.intellij.codeInsight.intention.IntentionAction;\nimport com.intellij.codeInspection.ProblemHighlightType;\nimport com.intellij.lang.annotation.AnnotationBuilder;\nimport com.intellij.lang.annotation.AnnotationHolder;\nimport com.intellij.lang.annotation.Annotator;\nimport com.intellij.lang.annotation.HighlightSeverity;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.util.TextRange;", "import com.intellij.openapi.project.Project;\nimport com.intellij.openapi.util.TextRange;\nimport com.intellij.psi.PsiElement;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.yaml.YAMLLanguage;\nimport org.jetbrains.yaml.psi.YAMLKeyValue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;", "import java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n", "import java.util.regex.Pattern;\n\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.*;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listEnvs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listInputs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listJobOutputs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listJobs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listSecrets;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listStepOutputs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listSteps;", "import static com.github.yunabraska.githubworkflow.model.CompletionItem.listStepOutputs;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.listSteps;\nimport static com.github.yunabraska.githubworkflow.model.WorkflowContext.WORKFLOW_CONTEXT_MAP;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.getPath;\nimport static java.util.Optional.ofNullable;\n\npublic class HighlightAnnotator implements Annotator {\n\n    //    public static final Pattern CARET_BRACKET_ITEM_PATTERN = Pattern.compile(\"\\\\b(\\\\w++(?:\\\\.\\\\w++)++)\\\\b\");\n    public static final Pattern CARET_BRACKET_ITEM_PATTERN = Pattern.compile(\"[\\\\s|\\\\t^{]\\\\b(\\\\w++(?:\\\\.\\\\w++)++)[\\\\s|\\\\t$}]\");\n\n    @Override", "    //    public static final Pattern CARET_BRACKET_ITEM_PATTERN = Pattern.compile(\"\\\\b(\\\\w++(?:\\\\.\\\\w++)++)\\\\b\");\n    public static final Pattern CARET_BRACKET_ITEM_PATTERN = Pattern.compile(\"[\\\\s|\\\\t^{]\\\\b(\\\\w++(?:\\\\.\\\\w++)++)[\\\\s|\\\\t$}]\");\n\n    @Override\n    public void annotate(@NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder) {\n        final Project project = ofNullable(psiElement.getContainingFile()).map(PsiElement::getProject).orElse(null);\n        if (psiElement.getLanguage() instanceof YAMLLanguage) {\n            ofNullable(WORKFLOW_CONTEXT_MAP.get(getPath(psiElement))).map(WorkflowContext::root).map(root -> toYamlElement(psiElement, root)).ifPresent(element -> {\n                if (FIELD_USES.equals(element.key())) {\n                    ofNullable(element.childTextNoQuotes()).map(GitHubAction::getGitHubAction).filter(GitHubAction::isAvailable).ifPresent(gitHubAction -> {\n                        final String browserText = \"Open in Browser [\" + gitHubAction.slug() + \"]\";\n                        final String marketplaceText = \"Open in Marketplace [\" + gitHubAction.slug() + \"]\";\n                        final List<IntentionAction> quickFixes = gitHubAction.isAction()\n                                ? Arrays.asList(new OpenUrlIntentionAction(gitHubAction.marketplaceUrl(), marketplaceText), new OpenUrlIntentionAction(gitHubAction.toUrl(), browserText))\n                                : List.of(new OpenUrlIntentionAction(gitHubAction.toUrl(), browserText));\n                        create(\n                                psiElement,\n                                holder,\n                                HighlightSeverity.INFORMATION,\n                                ProblemHighlightType.INFORMATION,\n                                quickFixes,\n                                psiElement.getTextRange(),\n                                browserText\n                        );\n                    });\n                }\n                //VALIDATE ACTION INPUTS", "                if (FIELD_USES.equals(element.key())) {\n                    ofNullable(element.childTextNoQuotes()).map(GitHubAction::getGitHubAction).filter(GitHubAction::isAvailable).ifPresent(gitHubAction -> {\n                        final String browserText = \"Open in Browser [\" + gitHubAction.slug() + \"]\";\n                        final String marketplaceText = \"Open in Marketplace [\" + gitHubAction.slug() + \"]\";\n                        final List<IntentionAction> quickFixes = gitHubAction.isAction()\n                                ? Arrays.asList(new OpenUrlIntentionAction(gitHubAction.marketplaceUrl(), marketplaceText), new OpenUrlIntentionAction(gitHubAction.toUrl(), browserText))\n                                : List.of(new OpenUrlIntentionAction(gitHubAction.toUrl(), browserText));\n                        create(\n                                psiElement,\n                                holder,\n                                HighlightSeverity.INFORMATION,\n                                ProblemHighlightType.INFORMATION,\n                                quickFixes,\n                                psiElement.getTextRange(),\n                                browserText\n                        );\n                    });\n                }\n                //VALIDATE ACTION INPUTS", "                if (element.key() != null && ofNullable(element.parent()).map(YamlElement::key).filter(FIELD_WITH::equals).isPresent()) {\n                    element.findParentStep().map(YamlElement::uses).map(GitHubAction::getGitHubAction).map(action -> action.inputs(ofNullable(psiElement.getContainingFile()).map(PsiElement::getProject).orElse(null))).map(Map::keySet).ifPresent(inputs -> {\n                        if (!inputs.contains(element.key())) {\n                            create(\n                                    psiElement,\n                                    holder,\n                                    HighlightSeverity.ERROR,\n                                    ProblemHighlightType.GENERIC_ERROR,\n                                    List.of(new ReplaceTextIntentionAction(psiElement.getTextRange(), element.key(), true)),\n                                    psiElement.getTextRange(),\n                                    \"Invalid [\" + element.key() + \"]\"\n                            );\n                        }\n                    });\n                }", "                if (element.findParent(FIELD_USES).isPresent()) {\n                    ofNullable(ACTION_CACHE.get(element.textOrChildText())).ifPresent(action -> create(\n                            psiElement,\n                            holder,\n                            action.isAvailable() ? HighlightSeverity.INFORMATION : HighlightSeverity.WEAK_WARNING,\n                            action.isAvailable() ? ProblemHighlightType.INFORMATION : ProblemHighlightType.WEAK_WARNING,\n                            List.of(action.isAvailable() ? new ClearWorkflowCacheAction(action) : new OpenSettingsIntentionAction(p -> action.deleteCache())),\n                            element.textRange(),\n                            action.isAvailable() ? \"Clear item cache [\" + action.slug() + \"]\" : \"Unresolved [\" + ofNullable(action.slug()).orElseGet(action::uses) + \"]\"\n                    ));\n                } else if (element.parent() != null && (FIELD_RUN.equals(element.parent().key())\n                        || \"if\".equals(element.parent().key())\n                        || \"name\".equals(element.parent().key())\n                        || (\"value\".equals(element.parent().key()) && element.findParentOutput().isPresent())\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_WITH.equals(element.parent().parent().key()))\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_ENVS.equals(element.parent().parent().key()))\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_OUTPUTS.equals(element.parent().parent().key()))\n                )) {\n                    //TODO: Find solution for undetected items with only one '.' e.g. [inputs.]\n                    //  MAYBE: regex needs to have '${{ }}', only 'if' content is different\n                    processBracketItems(project, psiElement, holder, element);", "                } else if (element.parent() != null && (FIELD_RUN.equals(element.parent().key())\n                        || \"if\".equals(element.parent().key())\n                        || \"name\".equals(element.parent().key())\n                        || (\"value\".equals(element.parent().key()) && element.findParentOutput().isPresent())\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_WITH.equals(element.parent().parent().key()))\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_ENVS.equals(element.parent().parent().key()))\n                        || (element.parent() != null && element.parent().parent() != null && FIELD_OUTPUTS.equals(element.parent().parent().key()))\n                )) {\n                    //TODO: Find solution for undetected items with only one '.' e.g. [inputs.]\n                    //  MAYBE: regex needs to have '${{ }}', only 'if' content is different\n                    processBracketItems(project, psiElement, holder, element);", "                } else if (FIELD_NEEDS.equals(element.key())) {\n                    element.findParentJob().ifPresent(job -> {\n                        final List<String> jobs = element.context().jobs().values().stream().filter(j -> j.startIndexAbs() < job.startIndexAbs()).map(YamlElement::key).toList();\n                        element.children().forEach(jobChild -> {\n                            final String jobId = jobChild.textOrChildTextNoQuotes().trim();\n                            final TextRange range = new TextRange(jobChild.startIndexAbs(), jobChild.startIndexAbs() + jobId.length());\n                            if (!jobs.contains(jobId)) {\n                                //INVALID JOB_ID\n                                create(\n                                        psiElement,\n                                        holder,\n                                        HighlightSeverity.ERROR,\n                                        ProblemHighlightType.GENERIC_ERROR,\n                                        jobs.stream().map(need -> new ReplaceTextIntentionAction(range, need, false)).map(ia -> (IntentionAction) ia).toList(),\n                                        range,\n                                        \"Invalid [\" + jobId + \"] - needs to be a valid jobId from previous jobs\"\n                                );\n                            } else {\n                                //UNUSED JOB_ID", "                                if (job.allElements().noneMatch(child -> child.text() != null && child.text().contains(FIELD_NEEDS + \".\" + jobId + \".\"))) {\n                                    create(\n                                            psiElement,\n                                            holder,\n                                            HighlightSeverity.INFORMATION,\n                                            ProblemHighlightType.INFORMATION,\n                                            List.of(new ReplaceTextIntentionAction(range, jobId, true)),\n                                            range,\n                                            \"Unused [\" + jobId + \"]\"\n                                    );\n                                }\n                            }\n                        });\n                    });", "                } else if (FIELD_OUTPUTS.equals(element.key())) {\n                    //CHECK FOR UNUSED JOB OUTPUTS\n                    element.findParentJob().map(YamlElement::key).ifPresent(jobId -> {\n                        final List<String> usedOutputs = element.context().outputs().values().stream()\n                                .filter(output -> output.findParentOn().isPresent())\n                                .map(output -> output.child(\"value\").orElse(null))\n                                .filter(Objects::nonNull)\n                                .map(YamlElement::textOrChildText)\n                                .flatMap(value -> {\n                                    final List<String[]> result = new ArrayList<>();\n                                    final Matcher matcher = CARET_BRACKET_ITEM_PATTERN.matcher(value);", "                                    while (matcher.find()) {\n                                        result.add(matcher.group().split(\"\\\\.\"));\n                                    }\n                                    return result.stream();\n                                })\n                                .filter(parts -> parts.length == 4)\n                                .filter(parts -> FIELD_JOBS.equals(parts[0]))\n                                .filter(parts -> jobId.equals(parts[1]))\n                                .filter(parts -> FIELD_OUTPUTS.equals(parts[2]))\n                                .map(parts -> parts[3])\n                                .toList();\n                        element.children().stream().filter(output -> output.key() != null).filter(output -> !usedOutputs.contains(output.key())).forEach(unusedOutput -> {\n                            final TextRange range = new TextRange(unusedOutput.startIndexAbs(), unusedOutput.children().stream().mapToInt(YamlElement::endIndexAbs).max().orElseGet(unusedOutput::endIndexAbs));\n                            create(\n                                    psiElement,\n                                    holder,\n                                    HighlightSeverity.WEAK_WARNING,\n                                    ProblemHighlightType.LIKE_UNUSED_SYMBOL,\n                                    List.of(new ReplaceTextIntentionAction(range, unusedOutput.key(), true)),\n                                    range,\n                                    \"Unused [\" + unusedOutput.key() + \"]\"\n                            );\n                        });\n                    });\n                }\n            });\n        }\n    }\n\n    private static void processBracketItems(final Project project, @NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder, final YamlElement element) {\n        final Matcher matcher = CARET_BRACKET_ITEM_PATTERN.matcher(psiElement.getText());", "        while (matcher.find()) {\n            final String[] parts = Arrays.stream(matcher.group().split(\"\\\\.\"))\n                    .map(s -> s.replace(\"{\", \"\"))\n                    .map(s -> s.replace(\"}\", \"\"))\n                    .map(String::trim)\n                    .toArray(String[]::new);\n            final String scope = parts[0];\n            switch (scope) {\n                case FIELD_INPUTS ->\n                        ifEnoughItems(holder, psiElement, parts, 2, 2, inputId -> isDefinedItem0(psiElement, holder, matcher, inputId, listInputs(element).stream().map(CompletionItem::key).toList()));\n                case FIELD_SECRETS -> ifEnoughItems(holder, psiElement, parts, 2, 2, secretId -> {\n                    final List<String> secrets = listSecrets(element).stream().map(CompletionItem::key).toList();", "                    if (!secrets.contains(secretId)) {\n                        final TextRange textRange = simpleTextRange(psiElement, matcher, secretId);\n                        create(\n                                psiElement,\n                                holder,\n                                HighlightSeverity.WEAK_WARNING,\n                                ProblemHighlightType.WEAK_WARNING,\n                                secrets.stream().map(output -> new ReplaceTextIntentionAction(textRange, output, false)).map(ia -> (IntentionAction) ia).toList(),\n                                textRange,\n                                \"Undefined [\" + secretId + \"] - it might be provided at runtime\"\n                        );\n                    }\n                });\n                case FIELD_ENVS ->\n                        ifEnoughItems(holder, psiElement, parts, 2, -1, envId -> isDefinedItem0(psiElement, holder, matcher, envId, listEnvs(element, element.startIndexAbs()).stream().map(CompletionItem::key).toList()));\n                case FIELD_GITHUB ->\n                        ifEnoughItems(holder, psiElement, parts, 2, -1, envId -> isDefinedItem0(psiElement, holder, matcher, envId, new ArrayList<>(DEFAULT_VALUE_MAP.get(FIELD_GITHUB).get().keySet())));\n                case FIELD_RUNNER ->\n                        ifEnoughItems(holder, psiElement, parts, 2, 2, runnerId -> isDefinedItem0(psiElement, holder, matcher, runnerId, new ArrayList<>(DEFAULT_VALUE_MAP.get(FIELD_RUNNER).get().keySet())));\n                case FIELD_STEPS -> ifEnoughItems(holder, psiElement, parts, 4, 4, stepId -> {\n                    final List<String> steps = listSteps(element).stream().map(CompletionItem::key).toList();", "                    if (isDefinedItem0(psiElement, holder, matcher, stepId, steps) && isField2Valid(psiElement, holder, matcher, parts[2])) {\n                        final List<String> outputs = listStepOutputs(project, element, element.startIndexAbs(), stepId).stream().map(CompletionItem::key).toList();\n                        isValidItem3(psiElement, holder, matcher, parts[3], outputs);\n\n                    }\n                });\n                case FIELD_JOBS ->\n                    // TODO: CHECK OUTPUTS FOR JOBS && NEEDS && STEPS e.g. [ if (!FIELD_OUTPUTS.equals(parts[2])) ]\n                        ifEnoughItems(holder, psiElement, parts, 4, 4, jobId -> {\n                            final List<String> jobs = listJobs(element).stream().map(CompletionItem::key).toList();\n                            //noinspection DuplicatedCode", "                            if (isDefinedItem0(psiElement, holder, matcher, jobId, jobs) && isField2Valid(psiElement, holder, matcher, parts[2])) {\n                                final List<String> outputs = listJobOutputs(project, element, jobId).stream().map(CompletionItem::key).toList();\n                                isValidItem3(psiElement, holder, matcher, parts[3], outputs);\n                            }\n                        });\n                case FIELD_NEEDS ->\n                        ifEnoughItems(holder, psiElement, parts, 4, 4, jobId -> element.findParentJob().flatMap(job -> job.child(FIELD_NEEDS)).ifPresent(needElement -> {\n                            final Set<String> needs = needElement.needItems();\n                            //noinspection DuplicatedCode\n                            if (isDefinedItem0(psiElement, holder, matcher, jobId, needs) && isField2Valid(psiElement, holder, matcher, parts[2])) {\n                                final List<String> outputs = listJobOutputs(project, element, jobId).stream().map(CompletionItem::key).toList();\n                                isValidItem3(psiElement, holder, matcher, parts[3], outputs);\n                            }\n                        }));\n                default -> {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n    private static boolean isField2Valid(@NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder, final Matcher matcher, final String itemId) {", "                            if (isDefinedItem0(psiElement, holder, matcher, jobId, needs) && isField2Valid(psiElement, holder, matcher, parts[2])) {\n                                final List<String> outputs = listJobOutputs(project, element, jobId).stream().map(CompletionItem::key).toList();\n                                isValidItem3(psiElement, holder, matcher, parts[3], outputs);\n                            }\n                        }));\n                default -> {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n    private static boolean isField2Valid(@NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder, final Matcher matcher, final String itemId) {", "        if (!FIELD_OUTPUTS.equals(itemId)) {\n            final TextRange textRange = simpleTextRange(psiElement, matcher, itemId);\n            create(\n                    psiElement,\n                    holder,\n                    HighlightSeverity.ERROR,\n                    ProblemHighlightType.GENERIC_ERROR,\n                    List.of(new ReplaceTextIntentionAction(textRange, FIELD_OUTPUTS, false)),\n                    textRange,\n                    \"Invalid [\" + itemId + \"]\"\n            );\n            return false;\n        }\n        return true;\n    }\n\n    private static void isValidItem3(@NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder, final Matcher matcher, final String itemId, final List<String> outputs) {", "        if (!outputs.contains(itemId)) {\n            final TextRange textRange = simpleTextRange(psiElement, matcher, itemId);\n            create(\n                    psiElement,\n                    holder,\n                    HighlightSeverity.ERROR,\n                    ProblemHighlightType.GENERIC_ERROR,\n                    outputs.stream().map(output -> new ReplaceTextIntentionAction(textRange, output, false)).map(ia -> (IntentionAction) ia).toList(),\n                    textRange,\n                    \"Undefined [\" + itemId + \"]\"\n            );\n        }\n    }\n\n    private static boolean isDefinedItem0(@NotNull final PsiElement psiElement, @NotNull final AnnotationHolder holder, final Matcher matcher, final String itemId, final Collection<String> items) {", "        if (!items.contains(itemId)) {\n            final TextRange textRange = simpleTextRange(psiElement, matcher, itemId);\n            create(\n                    psiElement,\n                    holder,\n                    HighlightSeverity.ERROR,\n                    ProblemHighlightType.GENERIC_ERROR,\n                    items.stream().map(output -> new ReplaceTextIntentionAction(textRange, output, false)).map(ia -> (IntentionAction) ia).toList(),\n                    textRange,\n                    \"Undefined [\" + itemId + \"]\"\n            );\n            return false;\n        }\n        return true;\n    }\n\n    private static YamlElement toYamlElement(final PsiElement psiElement, final YamlElement root) {\n        return psiElement instanceof final YAMLKeyValue kvPSI && kvPSI.getKey() != null && kvPSI.getKey().getTextRange() != null\n                ? root.allElements()\n                .filter(element -> element.startIndexAbs() > -1 && element.startIndexAbs() <= kvPSI.getKey().getTextRange().getStartOffset())\n                .filter(element -> element.endIndexAbs() > -1 && element.endIndexAbs() >= kvPSI.getKey().getTextRange().getEndOffset())\n                .filter(element -> element.textNoQuotes() != null && !element.textNoQuotes().isEmpty() && !element.textNoQuotes().isBlank())\n                .findFirst()\n                .orElseGet(() -> root.context().getClosestElement(psiElement.getTextOffset()).orElse(null))\n                : root.allElements()\n                .filter(element -> element.startIndexAbs() > -1 && element.startIndexAbs() <= psiElement.getTextRange().getStartOffset())\n                .filter(element -> element.endIndexAbs() > -1 && element.endIndexAbs() >= psiElement.getTextRange().getEndOffset())\n                .filter(element -> element.textNoQuotes() != null && !element.textNoQuotes().isEmpty() && !element.textNoQuotes().isBlank())\n                .findFirst()\n                .orElseGet(() -> root.context().getClosestElement(psiElement.getTextOffset()).orElse(null));\n    }\n\n    private static TextRange simpleTextRange(@NotNull final PsiElement psiElement, final Matcher matcher, final String itemId) {\n        final int start = psiElement.getTextRange().getStartOffset() + psiElement.getText().indexOf(itemId, matcher.start(0));\n        return new TextRange(start, start + itemId.length());\n    }\n\n    private static TextRange fixRange(final PsiElement psiElement, final TextRange range) {", "        if (range != null) {\n            final int newStart = Math.max(psiElement.getTextRange().getStartOffset(), range.getStartOffset());\n            final int newEnd = Math.min(psiElement.getTextRange().getEndOffset(), range.getEndOffset());\n            return newStart >= newEnd ? null : new TextRange(newStart, newEnd);\n        }\n        return null;\n    }\n\n    private static void ifEnoughItems(\n            final AnnotationHolder holder,\n            final PsiElement psiElement,\n            final String[] parts,\n            final int min,\n            final int max,\n            final Consumer<String> then\n    ) {", "        if (parts.length < min || parts.length < 2) {\n            final String unfinishedStatement = String.join(\".\", parts);\n            final int startOffset = psiElement.getTextRange().getStartOffset() + psiElement.getText().indexOf(unfinishedStatement);\n            final TextRange textRange = new TextRange(startOffset, startOffset + unfinishedStatement.length());\n            create(\n                    psiElement,\n                    holder,\n                    HighlightSeverity.ERROR,\n                    ProblemHighlightType.GENERIC_ERROR,\n                    null,\n                    textRange,\n                    \"Incomplete statement [\" + unfinishedStatement + \"]\"\n            );", "        } else if (max != -1 && parts.length > max) {\n            final String fullStatement = String.join(\".\", parts);\n            final String longPart = \".\" + String.join(\".\", (Arrays.copyOfRange(parts, max, parts.length)));\n            final int statementStartIndex = psiElement.getText().indexOf(fullStatement);\n            final int startOffset = psiElement.getTextRange().getStartOffset() + statementStartIndex + fullStatement.lastIndexOf(longPart);\n            final TextRange textRange = new TextRange(startOffset, startOffset + longPart.length());\n            create(\n                    psiElement,\n                    holder,\n                    HighlightSeverity.ERROR,\n                    ProblemHighlightType.GENERIC_ERROR,\n                    List.of(new ReplaceTextIntentionAction(textRange, longPart, true)),\n                    textRange,\n                    \"Not valid here [\" + longPart + \"]\"\n            );\n        } else {\n            then.accept(parts[1]);\n        }\n    }\n\n    @SuppressWarnings({\"DataFlowIssue\", \"ResultOfMethodCallIgnored\"})", "    public static void create(final PsiElement psiElement, final AnnotationHolder holder, final HighlightSeverity level, final ProblemHighlightType type, final Collection<IntentionAction> quickFixes, final TextRange range, final String message) {\n        final TextRange textRange = fixRange(psiElement, range);\n        if (textRange != null) {\n            final AnnotationBuilder annotation = holder.newAnnotation(level, message);\n            final AnnotationBuilder silentAnnotation = holder.newSilentAnnotation(level);\n            ofNullable(textRange).ifPresent(annotation::range);\n            ofNullable(type).ifPresent(annotation::highlightType);\n            ofNullable(message).ifPresent(annotation::tooltip);\n            ofNullable(quickFixes).ifPresent(q -> q.forEach(annotation::withFix));\n\n            ofNullable(textRange).ifPresent(silentAnnotation::range);\n            ofNullable(quickFixes).ifPresent(q -> q.forEach(silentAnnotation::withFix));\n\n            annotation.create();\n            silentAnnotation.create();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/quickfixes/OpenSettingsIntentionAction.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.quickfixes;\n\nimport com.intellij.codeInsight.intention.IntentionAction;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.options.ShowSettingsUtil;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.util.IncorrectOperationException;\nimport org.jetbrains.annotations.NotNull;\n", "import org.jetbrains.annotations.NotNull;\n\nimport java.util.function.Consumer;\n\nimport static java.util.Optional.ofNullable;\n\npublic class OpenSettingsIntentionAction implements IntentionAction {\n\n    private final Consumer<Project> execute;\n\n    public OpenSettingsIntentionAction(final Consumer<Project> execute) {\n        this.execute = execute;\n    }\n\n    @NotNull\n    @Override", "    public String getText() {\n        return \"Add gitHub account\";\n    }\n\n    @NotNull\n    @Override\n    public String getFamilyName() {\n        return \"AddGitHubAccount\";\n    }\n\n    @Override", "    public boolean isAvailable(@NotNull final Project project, final Editor editor, final PsiFile file) {\n        return true;\n    }\n\n    @Override\n    public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n        ShowSettingsUtil.getInstance().showSettingsDialog(project, \"GitHub\");\n        ofNullable(execute).ifPresent(projectConsumer -> projectConsumer.accept(project));\n    }\n\n    @Override", "    public boolean startInWriteAction() {\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/quickfixes/OpenUrlIntentionAction.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.quickfixes;\n\nimport com.intellij.codeInsight.intention.IntentionAction;\nimport com.intellij.ide.BrowserUtil;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.psi.PsiFile;\nimport org.jetbrains.annotations.NotNull;\n\npublic class OpenUrlIntentionAction implements IntentionAction {\n    private final String url;\n    private final String text;\n\n    public OpenUrlIntentionAction(final String url, final String text) {\n        this.url = url;\n        this.text = text;\n    }\n\n    @NotNull\n    @Override", "\npublic class OpenUrlIntentionAction implements IntentionAction {\n    private final String url;\n    private final String text;\n\n    public OpenUrlIntentionAction(final String url, final String text) {\n        this.url = url;\n        this.text = text;\n    }\n\n    @NotNull\n    @Override", "    public String getText() {\n        return text;\n    }\n\n    @NotNull\n    @Override\n    public String getFamilyName() {\n        return \"Open URL\";\n    }\n\n    @Override", "    public boolean isAvailable(@NotNull final Project project, final Editor editor, final PsiFile file) {\n        return true;\n    }\n\n    @Override\n    public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) {\n        BrowserUtil.browse(url);\n    }\n\n    @Override\n    public boolean startInWriteAction() {\n        return false;\n    }\n}\n", "    public boolean startInWriteAction() {\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/quickfixes/ReplaceTextIntentionAction.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.quickfixes;\n\nimport com.intellij.codeInsight.intention.IntentionAction;\nimport com.intellij.openapi.command.WriteCommandAction;\nimport com.intellij.openapi.editor.Document;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.util.TextRange;\nimport com.intellij.psi.PsiDocumentManager;\nimport com.intellij.psi.PsiElement;", "import com.intellij.psi.PsiDocumentManager;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.util.IncorrectOperationException;\nimport org.jetbrains.annotations.NotNull;\n\npublic class ReplaceTextIntentionAction implements IntentionAction {\n    private final boolean delete;\n    private final String newText;\n    private final TextRange textRange;\n\n    public ReplaceTextIntentionAction(final TextRange textRange, final String newText, final boolean delete) {\n        this.delete = delete;\n        this.newText = newText;\n        this.textRange = textRange;\n    }\n\n    @NotNull\n    @Override", "    public String getText() {\n        return (delete ? \"Delete \" : \"Replace with \") + newText;\n    }\n\n    @NotNull\n    @Override\n    public String getFamilyName() {\n        return \"ReplaceText\";\n    }\n\n    @Override", "    public boolean isAvailable(@NotNull final Project project, final Editor editor, final PsiFile file) {\n        return true;\n    }\n\n    @Override\n    public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n        final PsiElement element = file.findElementAt(editor.getCaretModel().getOffset());\n        if (element != null) {\n            final Document document = PsiDocumentManager.getInstance(project).getDocument(element.getContainingFile());\n            if (document != null) {\n                WriteCommandAction.runWriteCommandAction(project, () -> document.replaceString(textRange.getStartOffset(), textRange.getEndOffset(), delete ? \"\" : newText));\n            }\n        }\n    }\n\n    @Override", "            if (document != null) {\n                WriteCommandAction.runWriteCommandAction(project, () -> document.replaceString(textRange.getStartOffset(), textRange.getEndOffset(), delete ? \"\" : newText));\n            }\n        }\n    }\n\n    @Override\n    public boolean startInWriteAction() {\n        return false;\n    }\n}\n\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/quickfixes/GhwPluginErrorReportSubmitter.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.quickfixes;\n\nimport com.intellij.ide.BrowserUtil;\nimport com.intellij.ide.plugins.IdeaPluginDescriptor;\nimport com.intellij.ide.plugins.PluginManagerCore;\nimport com.intellij.openapi.application.ApplicationInfo;\nimport com.intellij.openapi.diagnostic.ErrorReportSubmitter;\nimport com.intellij.openapi.diagnostic.IdeaLoggingEvent;\nimport com.intellij.openapi.diagnostic.SubmittedReportInfo;\nimport com.intellij.openapi.util.SystemInfo;", "import com.intellij.openapi.diagnostic.SubmittedReportInfo;\nimport com.intellij.openapi.util.SystemInfo;\nimport com.intellij.openapi.util.text.StringUtil;\nimport com.intellij.util.Consumer;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.awt.*;\nimport java.net.URLEncoder;", "import java.awt.*;\nimport java.net.URLEncoder;\nimport java.util.Optional;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Optional.ofNullable;\n\nfinal class GhwPluginErrorReportSubmitter extends ErrorReportSubmitter {\n\n    @NonNls", "\n    @NonNls\n    private static final String REPORT_URL = \"https://github.com/YunaBraska/github-workflow-plugin/issues/new?labels=bug&template=---bug-report.md\";\n\n    @NotNull\n    @Override\n    public String getReportActionText() {\n        return \"Report Exception\";\n    }\n\n    @Override", "    public boolean submit(final IdeaLoggingEvent @NotNull [] events,\n                          @Nullable final String additionalInfo,\n                          @NotNull final Component parentComponent,\n                          @NotNull final Consumer<? super SubmittedReportInfo> consumer) {\n        final IdeaLoggingEvent event = events[0];\n        final String throwableText = event.getThrowableText();\n\n        final StringBuilder sb = new StringBuilder(REPORT_URL);\n\n        sb.append(URLEncoder.encode(StringUtil.splitByLines(throwableText)[0], UTF_8));\n        ofNullable(event.getThrowable())\n                .map(Throwable::getMessage)\n                .or(() -> Optional.of(throwableText).map(title -> StringUtil.splitByLines(title)[0]))\n                .map(title -> \"&title=\" + URLEncoder.encode(title, UTF_8))\n                .ifPresent(sb::append);\n\n        sb.append(\"&body=\");\n        sb.append(URLEncoder.encode(\"\\n\\n### Description\\n\", UTF_8));\n        sb.append(URLEncoder.encode(StringUtil.defaultIfEmpty(additionalInfo, \"\"), UTF_8));\n\n        sb.append(URLEncoder.encode(\"\\n\\n### Steps to Reproduce\\n\", UTF_8));\n        sb.append(URLEncoder.encode(\"Please provide code sample if applicable\", UTF_8));\n\n        sb.append(URLEncoder.encode(\"\\n\\n### Message\\n\", UTF_8));\n        sb.append(URLEncoder.encode(StringUtil.defaultIfEmpty(event.getMessage(), \"\"), UTF_8));\n\n        sb.append(URLEncoder.encode(\"\\n\\n### Runtime Information\\n\", UTF_8));\n        final IdeaPluginDescriptor descriptor = PluginManagerCore.getPlugin(getPluginDescriptor().getPluginId());\n        assert descriptor != null;\n        sb.append(URLEncoder.encode(\"Plugin version : \" + descriptor.getVersion() + \"\\n\", UTF_8));\n        sb.append(URLEncoder.encode(\"IDE: \" + ApplicationInfo.getInstance().getFullApplicationName() +\n                \" (\" + ApplicationInfo.getInstance().getBuild().asString() + \")\\n\", UTF_8));\n        sb.append(URLEncoder.encode(\"OS: \" + SystemInfo.getOsNameAndVersion(), UTF_8));\n\n        sb.append(URLEncoder.encode(\"\\n\\n### Stacktrace\\n\", UTF_8));\n        sb.append(URLEncoder.encode(\"```\\n\", UTF_8));\n        sb.append(URLEncoder.encode(throwableText, UTF_8));\n        sb.append(URLEncoder.encode(\"```\\n\", UTF_8));\n\n        BrowserUtil.browse(sb.toString());\n\n        consumer.consume(new SubmittedReportInfo(SubmittedReportInfo.SubmissionStatus.NEW_ISSUE));\n        return true;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/quickfixes/ClearWorkflowCacheAction.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.quickfixes;\n\nimport com.github.yunabraska.githubworkflow.model.GitHubAction;\nimport com.intellij.codeInsight.intention.IntentionAction;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.util.IncorrectOperationException;\nimport org.jetbrains.annotations.NotNull;\n\npublic class ClearWorkflowCacheAction implements IntentionAction {\n\n    private final GitHubAction action;\n\n    public ClearWorkflowCacheAction(final GitHubAction action) {\n        this.action = action;\n    }\n\n    @NotNull\n    @Override", "import org.jetbrains.annotations.NotNull;\n\npublic class ClearWorkflowCacheAction implements IntentionAction {\n\n    private final GitHubAction action;\n\n    public ClearWorkflowCacheAction(final GitHubAction action) {\n        this.action = action;\n    }\n\n    @NotNull\n    @Override", "    public String getText() {\n        return \"Clear item cache [\" + action.slug() + \"]\";\n    }\n\n    @NotNull\n    @Override\n    public String getFamilyName() {\n        return \"ClearGhaCacheItem\";\n    }\n\n    @Override", "    public boolean isAvailable(@NotNull final Project project, final Editor editor, final PsiFile file) {\n        return true;\n    }\n\n    @Override\n    public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n        action.deleteCache();\n    }\n\n    @Override\n    public boolean startInWriteAction() {\n        return false;\n    }\n}\n", "    public boolean startInWriteAction() {\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubDiscussionSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;", "import static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubDiscussionSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"discussion\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"DISCUSSION_TEMPLATE\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"DISCUSSION_TEMPLATE\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Discussion [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubIssueConfigSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubIssueConfigSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"issue-config\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override", "import static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubIssueConfigSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"issue-config\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"workflow-templates\")\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"config.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"config.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"workflow-templates\")\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"config.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"config.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Workflow Issue Template configuration [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubActionSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubActionSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"action\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override", "import static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubActionSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"action\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"action.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"action.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"action.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"action.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Action [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubSchemaProviderFactory.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Arrays;\nimport java.util.List;", "import java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@SuppressWarnings(\"java:S2386\")\npublic class GitHubSchemaProviderFactory implements JsonSchemaProviderFactory {\n\n    public static final Map<String, VirtualFile> GITHUB_SCHEMA_CACHE = new ConcurrentHashMap<>();\n    public static final List<JsonSchemaFileProvider> SCHEMA_FILE_PROVIDERS = Arrays.asList(\n            new DependabotSchemaProvider(),\n            new GitHubActionSchemaProvider(),\n            new GitHubFoundingSchemaProvider(),\n            new GitHubWorkflowSchemaProvider(),\n            new GitHubDiscussionSchemaProvider(),\n            new GitHubIssueFormsSchemaProvider(),\n            new GitHubIssueConfigSchemaProvider(),\n            new GitHubWorkflowTemplateSchemaProvider()\n    );\n\n    @NotNull\n    @Override\n    public List<JsonSchemaFileProvider> getProviders(@NotNull final Project project) {\n        return SCHEMA_FILE_PROVIDERS;\n    }\n}\n", "    public static final Map<String, VirtualFile> GITHUB_SCHEMA_CACHE = new ConcurrentHashMap<>();\n    public static final List<JsonSchemaFileProvider> SCHEMA_FILE_PROVIDERS = Arrays.asList(\n            new DependabotSchemaProvider(),\n            new GitHubActionSchemaProvider(),\n            new GitHubFoundingSchemaProvider(),\n            new GitHubWorkflowSchemaProvider(),\n            new GitHubDiscussionSchemaProvider(),\n            new GitHubIssueFormsSchemaProvider(),\n            new GitHubIssueConfigSchemaProvider(),\n            new GitHubWorkflowTemplateSchemaProvider()\n    );\n\n    @NotNull\n    @Override\n    public List<JsonSchemaFileProvider> getProviders(@NotNull final Project project) {\n        return SCHEMA_FILE_PROVIDERS;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubActionIconProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.intellij.icons.AllIcons;\nimport com.intellij.ide.IconProvider;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiFile;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport javax.swing.*;\n\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.SCHEMA_FILE_PROVIDERS;\n\npublic class GitHubActionIconProvider extends IconProvider {\n\n    @Nullable\n    @Override\n    public Icon getIcon(@NotNull final PsiElement element, final int flags) {", "    public Icon getIcon(@NotNull final PsiElement element, final int flags) {\n        if (element instanceof PsiFile) {\n            final VirtualFile file = ((PsiFile) element).getVirtualFile();\n            return SCHEMA_FILE_PROVIDERS.stream().anyMatch(schemaProvider -> schemaProvider.isAvailable(file))\n                    ? AllIcons.Vcs.Vendors.Github\n                    : null;\n        }\n        return null;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubFoundingSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubFoundingSchemaProvider implements JsonSchemaFileProvider {\n", "import static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubFoundingSchemaProvider implements JsonSchemaFileProvider {\n\n    public static final String NAME = \"funding\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"FUNDING.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"FUNDING.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"FUNDING.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"FUNDING.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Funding [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubIssueFormsSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;", "import static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubIssueFormsSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"issue-forms\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"ISSUE_TEMPLATE\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"ISSUE_TEMPLATE\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Issue Forms [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/DependabotSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class DependabotSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"dependabot\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/\" + NAME + \"-2.0\";\n\n    @Override", "import static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class DependabotSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"dependabot\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/\" + NAME + \"-2.0\";\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\".github\")\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"dependabot.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"dependabot.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 1\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\".github\")\n                && (path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"dependabot.yml\")\n                || path.getName(path.getNameCount() - 1).toString().equalsIgnoreCase(\"dependabot.yaml\"));\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"Dependabot [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubWorkflowTemplateSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;", "import static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isYamlFile;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubWorkflowTemplateSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"workflow-template-properties\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"workflow-templates\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isYamlFile)\n                .filter(validatePath()).isPresent();\n    }\n\n    public Predicate<Path> validatePath() {\n        return path -> path.getNameCount() > 2\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\")\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"workflow-templates\")\n                && isYamlFile(path);\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Workflow Template Properties [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/schema/GitHubWorkflowSchemaProvider.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.schema;\n\nimport com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider;\nimport com.jetbrains.jsonSchema.extension.SchemaType;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n", "import org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Paths;\nimport java.util.Optional;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.downloadSchema;\nimport static com.github.yunabraska.githubworkflow.schema.GitHubSchemaProviderFactory.GITHUB_SCHEMA_CACHE;\n\npublic class GitHubWorkflowSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"workflow\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override", "public class GitHubWorkflowSchemaProvider implements JsonSchemaFileProvider {\n\n    private static final String NAME = \"workflow\";\n    private static final String SCHEMA_URL = \"https://json.schemastore.org/github-\" + NAME;\n\n    @Override\n    public boolean isAvailable(@NotNull final VirtualFile file) {\n        return Optional.of(file).map(VirtualFile::getPath).map(Paths::get).filter(GitHubWorkflowUtils::isWorkflowPath).isPresent();\n    }\n\n    @NotNull\n    @Override", "    public String getName() {\n        return \"GitHub Workflow [Auto]\";\n    }\n\n\n    @Nullable\n    @Override\n    public VirtualFile getSchemaFile() {\n        return GITHUB_SCHEMA_CACHE.computeIfAbsent(SCHEMA_URL, key -> downloadSchema(SCHEMA_URL, NAME));\n    }\n\n    @NotNull\n    @Override", "    public SchemaType getSchemaType() {\n        return SchemaType.schema;\n    }\n\n    @Nullable\n    @NonNls\n    @Override\n    public String getRemoteSource() {\n        return SCHEMA_URL;\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/completion/AutoPopupInsertHandler.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.completion;\n\nimport com.intellij.codeInsight.AutoPopupController;\nimport com.intellij.codeInsight.completion.InsertHandler;\nimport com.intellij.codeInsight.completion.InsertionContext;\nimport com.intellij.codeInsight.lookup.LookupElement;\nimport com.intellij.openapi.editor.Document;\nimport org.jetbrains.annotations.NotNull;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isLineBreak;", "\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.isLineBreak;\n\npublic class AutoPopupInsertHandler<T extends LookupElement> implements InsertHandler<T> {\n    public static final AutoPopupInsertHandler<LookupElement> INSTANCE = new AutoPopupInsertHandler<>();\n\n    @Override\n    public void handleInsert(@NotNull final InsertionContext context, @NotNull final T item) {\n        AutoPopupController.getInstance(context.getProject()).autoPopupMemberLookup(context.getEditor(), null);\n    }\n", "    public static void addSuffix(final InsertionContext ctx, final LookupElement item, final char suffix) {\n        if (suffix != Character.MIN_VALUE) {\n            final String key = item.getLookupString();\n            final int startOffset = ctx.getStartOffset();\n            final Document document = ctx.getDocument();\n            final CharSequence documentChars = document.getCharsSequence();\n            final int tailOffset = ctx.getTailOffset();\n            final String toInsert = toInsertString(suffix, documentChars, tailOffset);\n\n            documentChars.subSequence(startOffset, startOffset + key.length());\n            document.replaceString(startOffset, getEndIndex(ctx, suffix, documentChars, tailOffset), key + toInsert);\n            ctx.getEditor().getCaretModel().moveToOffset(startOffset + (key + toInsert).length());\n", "            if (suffix == '.') {\n                AutoPopupInsertHandler.INSTANCE.handleInsert(ctx, item);\n            }\n        }\n    }\n\n    private static int getEndIndex(final InsertionContext ctx, final char suffix, final CharSequence documentChars, final int tailOffset) {\n        int result = tailOffset;\n        if (ctx.getCompletionChar() == '\\t') {\n            while (result < documentChars.length()\n                    && documentChars.charAt(result) != suffix\n                    && !isLineBreak(documentChars.charAt(result))\n            ) {\n                result++;\n            }", "        if (ctx.getCompletionChar() == '\\t') {\n            while (result < documentChars.length()\n                    && documentChars.charAt(result) != suffix\n                    && !isLineBreak(documentChars.charAt(result))\n            ) {\n                result++;\n            }\n            if (!isLineBreak(documentChars.charAt(result))) {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    @NotNull\n    private static String toInsertString(final char suffix, final CharSequence documentChars, final int tailOffset) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(suffix);\n        final boolean isNextChatSpace = tailOffset < documentChars.length() && documentChars.charAt(tailOffset + 1) == ' ';", "        if (suffix != '.' && !isNextChatSpace) {\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/completion/GitHubWorkflowUtils.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.completion;\n\nimport com.github.yunabraska.githubworkflow.config.NodeIcon;\nimport com.github.yunabraska.githubworkflow.model.GitHubAction;\nimport com.github.yunabraska.githubworkflow.model.YamlElement;\nimport com.intellij.codeInsight.completion.CompletionParameters;\nimport com.intellij.codeInsight.completion.CompletionResultSet;\nimport com.intellij.codeInsight.completion.PrioritizedLookupElement;\nimport com.intellij.codeInsight.lookup.LookupElement;\nimport com.intellij.codeInsight.lookup.LookupElementBuilder;", "import com.intellij.codeInsight.lookup.LookupElement;\nimport com.intellij.codeInsight.lookup.LookupElementBuilder;\nimport com.intellij.ide.impl.ProjectUtil;\nimport com.intellij.json.JsonFileType;\nimport com.intellij.openapi.application.ApplicationInfo;\nimport com.intellij.openapi.application.ApplicationManager;\nimport com.intellij.openapi.diagnostic.Logger;\nimport com.intellij.openapi.vfs.VfsUtil;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.FileViewProvider;", "import com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.FileViewProvider;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.testFramework.LightVirtualFile;\nimport com.intellij.util.io.HttpRequests;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.plugins.github.api.GithubApiRequest;\nimport org.jetbrains.plugins.github.api.GithubApiRequestExecutor;\nimport org.jetbrains.plugins.github.api.GithubApiResponse;", "import org.jetbrains.plugins.github.api.GithubApiRequestExecutor;\nimport org.jetbrains.plugins.github.api.GithubApiResponse;\nimport org.jetbrains.plugins.github.authentication.GHAccountsUtil;\nimport org.jetbrains.plugins.github.authentication.accounts.GithubAccount;\nimport org.jetbrains.plugins.github.util.GHCompatibilityUtil;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;", "import java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;", "import java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.Future;\nimport java.util.regex.Matcher;\n\nimport static com.github.yunabraska.githubworkflow.completion.AutoPopupInsertHandler.addSuffix;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.CACHE_ONE_DAY;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.PATTERN_GITHUB_ENV;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.PATTERN_GITHUB_OUTPUT;\nimport static java.util.Optional.ofNullable;", "import static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.PATTERN_GITHUB_OUTPUT;\nimport static java.util.Optional.ofNullable;\n\npublic class GitHubWorkflowUtils {\n\n    public static final Path TMP_DIR = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"ide_github_workflow_plugin\");\n    private static final Logger LOG = Logger.getInstance(GitHubWorkflowUtils.class);\n\n    public static Optional<String[]> getCaretBracketItem(final YamlElement element, final int offset, final String[] prefix) {\n        final String wholeText = element.text();\n        if (wholeText == null || offset - element.startIndexAbs() < 1) {\n            return Optional.empty();\n        }\n        final int cursorRel = offset - element.startIndexAbs();\n        final String offsetText = wholeText.substring(0, cursorRel);\n        final int bracketStart = offsetText.lastIndexOf(\"${{\");", "    public static Optional<String[]> getCaretBracketItem(final YamlElement element, final int offset, final String[] prefix) {\n        final String wholeText = element.text();\n        if (wholeText == null || offset - element.startIndexAbs() < 1) {\n            return Optional.empty();\n        }\n        final int cursorRel = offset - element.startIndexAbs();\n        final String offsetText = wholeText.substring(0, cursorRel);\n        final int bracketStart = offsetText.lastIndexOf(\"${{\");\n        if (cursorRel > 2 && isInBrackets(offsetText, bracketStart) || ofNullable(element.parent()).filter(parent -> \"if\".equals(parent.key())).isPresent()) {\n            return getCaretBracketItem(prefix, wholeText, cursorRel);\n        }\n        return Optional.empty();\n    }\n", "        if (cursorRel > 2 && isInBrackets(offsetText, bracketStart) || ofNullable(element.parent()).filter(parent -> \"if\".equals(parent.key())).isPresent()) {\n            return getCaretBracketItem(prefix, wholeText, cursorRel);\n        }\n        return Optional.empty();\n    }\n\n    public static Optional<String[]> getCaretBracketItem(final String[] prefix, final String wholeText, final int cursorRel) {\n        final char previousChar = cursorRel == 0 ? ' ' : wholeText.charAt(cursorRel - 1);\n        if (cursorRel > 1 && previousChar == '.') {\n            //NEXT ELEMENT\n            final int indexStart = getStartIndex(wholeText, cursorRel - 1);\n            final int indexEnd = getEndIndex(wholeText, cursorRel - 1, wholeText.length());\n            return Optional.of(wholeText.substring(indexStart, indexEnd + 1).split(\"\\\\.\"));", "        if (cursorRel > 1 && previousChar == '.') {\n            //NEXT ELEMENT\n            final int indexStart = getStartIndex(wholeText, cursorRel - 1);\n            final int indexEnd = getEndIndex(wholeText, cursorRel - 1, wholeText.length());\n            return Optional.of(wholeText.substring(indexStart, indexEnd + 1).split(\"\\\\.\"));\n        } else if (isNonValidNodeChar(previousChar)) {\n            //START ELEMENT\n            return Optional.of(prefix);\n        } else {\n            //MIDDLE ELEMENT\n            final int indexStart = cursorRel == 0 ? 0 : getStartIndex(wholeText, cursorRel - 1);\n            final String[] prefArray = wholeText.substring(indexStart, cursorRel).split(\"\\\\.\", -1);\n            prefix[0] = prefArray[prefArray.length - 1];\n            return Optional.of(wholeText.substring(indexStart, cursorRel - prefix[0].length()).split(\"\\\\.\"));\n        }\n    }\n\n    private static boolean isNonValidNodeChar(final char c) {\n        return !Character.isLetterOrDigit(c) && c != '_' && c != '-';\n    }\n", "    public static int getStartIndex(final CharSequence currentText, final int fromIndex) {\n        int result = fromIndex;\n        while (result > 0) {\n            final char c = currentText.charAt(result);\n            if (!Character.isLetterOrDigit(c) && c != '_' && c != '-' && c != '.') {\n                result = result != fromIndex ? result + 1 : result;\n                break;\n            }\n            result--;\n        }\n        return Math.min(result, fromIndex);\n    }\n", "    public static int getEndIndex(final CharSequence currentText, final int fromIndex, final int toIndex) {\n        int result = fromIndex;\n        final int endIndex = currentText.length();\n        while (result < endIndex && result < toIndex) {\n            if (isNonValidNodeChar(currentText.charAt(result))) {\n                break;\n            }\n            result++;\n        }\n        return result;\n    }\n", "    public static String getDefaultPrefix(final CompletionParameters parameters) {\n        final String wholeText = parameters.getOriginalFile().getText();\n        final int caretOffset = parameters.getOffset();\n        final int indexStart = getStartIndex(wholeText, caretOffset - 1);\n        return wholeText.substring(indexStart, caretOffset);\n    }\n\n\n    public static boolean isInBrackets(final String partString, final int bracketStart) {\n        return bracketStart != -1 && partString.lastIndexOf(\"}}\") <= bracketStart;\n    }\n", "    public static boolean isInBrackets(final String partString, final int bracketStart) {\n        return bracketStart != -1 && partString.lastIndexOf(\"}}\") <= bracketStart;\n    }\n\n    public static String orEmpty(final String text) {\n        return ofNullable(text).orElse(\"\");\n    }\n\n    public static String getDescription(final YamlElement n) {\n        return \"r[\" + n.required() + \"]\"\n                + ofNullable(n.childDefault()).map(def -> \" def[\" + def + \"]\").orElse(\"\")\n                + ofNullable(n.description()).map(desc -> \" \" + desc).orElse(\"\");\n    }\n", "    public static String getDescription(final YamlElement n) {\n        return \"r[\" + n.required() + \"]\"\n                + ofNullable(n.childDefault()).map(def -> \" def[\" + def + \"]\").orElse(\"\")\n                + ofNullable(n.description()).map(desc -> \" \" + desc).orElse(\"\");\n    }\n\n    public static Map<String, String> toGithubOutputs(final String text) {\n        final Map<String, String> variables = new HashMap<>();\n        if (text.contains(\"$GITHUB_OUTPUT\") || text.contains(\"${GITHUB_OUTPUT}\")) {\n            final Matcher matcher = PATTERN_GITHUB_OUTPUT.matcher(text);\n            while (matcher.find()) {", "        if (text.contains(\"$GITHUB_OUTPUT\") || text.contains(\"${GITHUB_OUTPUT}\")) {\n            final Matcher matcher = PATTERN_GITHUB_OUTPUT.matcher(text);\n            while (matcher.find()) {\n                if (matcher.groupCount() >= 2) {\n                    variables.put(matcher.group(1), matcher.group(2));\n                }\n            }\n        }\n        return variables;\n    }\n", "    public static Map<String, String> toGithubEnvs(final String text) {\n        final Map<String, String> variables = new HashMap<>();\n        if (text.contains(\"GITHUB_ENV\") || text.contains(\"${GITHUB_ENV}\")) {\n            final Matcher matcher = PATTERN_GITHUB_ENV.matcher(text);\n            while (matcher.find()) {\n                if (matcher.groupCount() >= 2) {\n                    variables.put(matcher.group(1), matcher.group(2));\n                }\n            }\n        }\n        return variables;\n    }\n", "    public static void addLookupElements(final CompletionResultSet resultSet, final Map<String, String> map, final NodeIcon icon, final char suffix) {\n        if (!map.isEmpty()) {\n            resultSet.addAllElements(toLookupElements(map, icon, suffix));\n        }\n    }\n\n    public static List<LookupElement> toLookupElements(final Map<String, String> map, final NodeIcon icon, final char suffix) {\n        return map.entrySet().stream().map(item -> toLookupElement(icon, suffix, item.getKey(), item.getValue())).toList();\n    }\n\n    public static LookupElement toLookupElement(final NodeIcon icon, final char suffix, final String key, final String text) {\n        final LookupElementBuilder result = LookupElementBuilder\n                .create(key)\n                .withIcon(icon.icon())\n                .withBoldness(icon != NodeIcon.ICON_ENV)\n                .withTypeText(text)\n                .withCaseSensitivity(false)\n                .withInsertHandler((ctx, item) -> addSuffix(ctx, item, suffix));\n        return PrioritizedLookupElement.withPriority(result, icon.ordinal() + 5d);\n    }\n\n    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")", "    public static LookupElement toLookupElement(final NodeIcon icon, final char suffix, final String key, final String text) {\n        final LookupElementBuilder result = LookupElementBuilder\n                .create(key)\n                .withIcon(icon.icon())\n                .withBoldness(icon != NodeIcon.ICON_ENV)\n                .withTypeText(text)\n                .withCaseSensitivity(false)\n                .withInsertHandler((ctx, item) -> addSuffix(ctx, item, suffix));\n        return PrioritizedLookupElement.withPriority(result, icon.ordinal() + 5d);\n    }\n\n    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")", "    public static boolean isLineBreak(final char c) {\n        return c == '\\n' || c == '\\r';\n    }\n\n    public static VirtualFile downloadSchema(final String url, final String name) {\n        try {\n            final Path path = TMP_DIR.resolve(name + \"_schema.json\");\n            final VirtualFile newVirtualFile = new LightVirtualFile(\"github_workflow_plugin_\" + path.getFileName().toString(), JsonFileType.INSTANCE, \"\");\n            //FIXME: how to use the intellij idea cache?\n            VfsUtil.saveText(newVirtualFile, downloadContent(url, path, CACHE_ONE_DAY * 30, false));\n            return newVirtualFile;\n        } catch (final Exception ignored) {\n            return null;\n        }\n    }\n", "    public static String downloadAction(final String url, final GitHubAction gitHubAction) {\n        return downloadContent(url, cachePath(gitHubAction), CACHE_ONE_DAY * 14, true);\n    }\n\n    @NotNull\n    public static Path cachePath(final GitHubAction gitHubAction) {\n        return TMP_DIR.resolve(\n                clearString(gitHubAction.actionName())\n                        + ofNullable(gitHubAction.slug()).map(GitHubWorkflowUtils::clearString).orElse(\"\")\n                        + ofNullable(gitHubAction.sub()).map(GitHubWorkflowUtils::clearString).orElse(\"\")\n                        + ofNullable(gitHubAction.ref()).map(GitHubWorkflowUtils::clearString).orElse(\"\")\n                        + ofNullable(gitHubAction.actionName()).map(GitHubWorkflowUtils::clearString).orElse(\"\")\n                        + \"_schema.json\"\n        );\n    }\n\n    private static String clearString(final String input) {\n        return input == null ? \"\" : \"_\" + input.replace(\"/\", \"_\").replace(\"\\\\\", \"_\");\n    }\n", "    public static String downloadFileFromGitHub(final String downloadUrl) {\n        return GHAccountsUtil.getAccounts().stream().map(account -> {\n            try {\n                return downloadFromGitHub(downloadUrl, account);\n            } catch (final Exception ignored) {\n                return null;\n            }\n        }).filter(Objects::nonNull).findFirst().orElse(null);\n    }\n\n    @SuppressWarnings(\"DataFlowIssue\")\n    private static String downloadFromGitHub(final String downloadUrl, final GithubAccount account) throws IOException {\n        final String token = GHCompatibilityUtil.getOrRequestToken(account, ProjectUtil.getActiveProject());\n        return GithubApiRequestExecutor.Factory.getInstance().create(token).execute(new GithubApiRequest.Get<>(downloadUrl) {\n            @SuppressWarnings(\"BlockingMethodInNonBlockingContext\")\n            @Override", "            public String extractResult(final @NotNull GithubApiResponse response) {\n                try {\n                    return response.handleBody(inputStream -> {\n                        try (final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream))) {\n                            final StringBuilder stringBuilder = new StringBuilder();\n                            String line;\n                            while ((line = bufferedReader.readLine()) != null) {\n                                stringBuilder.append(line).append(System.lineSeparator());\n                            }\n                            return stringBuilder.toString();\n                        }\n                    });\n                } catch (final IOException ignored) {\n                    return null;\n                }\n            }\n        });\n    }\n\n    @SuppressWarnings(\"BlockingMethodInNonBlockingContext\")\n    private static String downloadContent(final String url, final Path path, final long expirationTime, final boolean usingGithub) {", "        try {\n            if (Files.exists(path) && (expirationTime < 1 || Files.getLastModifiedTime(path).toMillis() > System.currentTimeMillis() - expirationTime)) {\n                LOG.info(\"Cache load [\" + path + \"] expires in [\" + (System.currentTimeMillis() - expirationTime) + \"ms]\");\n                return readFileAsync(path);\n            } else {\n                if (!Files.exists(path.getParent())) {\n                    Files.createDirectories(path.getParent());\n                }\n                final String content = Optional.of(usingGithub).filter(withGH -> withGH).map(withGH -> downloadFileFromGitHub(url)).orElseGet(() -> downloadContent(url));\n                Files.write(path, content.getBytes());\n                return content;\n            }\n        } catch (final Exception e) {\n            LOG.warn(\"Cache failed for [\" + url + \"] message [\" + (e instanceof NullPointerException ? null : e.getMessage()) + \"]\");\n            return \"\";\n        }\n    }\n\n\n    @SuppressWarnings(\"BlockingMethodInNonBlockingContext\")", "    public static String readFileAsync(final Path path) {\n        try (final BufferedReader reader = Files.newBufferedReader(path, Charset.defaultCharset())) {\n            final StringBuilder contentBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                contentBuilder.append(line).append(System.lineSeparator());\n            }\n            return contentBuilder.toString();\n        } catch (final IOException e) {\n            LOG.error(\"Failed to read file [\" + path + \"] message [\" + e.getMessage() + \"]\");\n            return \"\";\n        }\n    }\n\n\n    @SuppressWarnings({\"java:S2142\", \"BlockingMethodInNonBlockingContext\"})\n    private static String downloadContent(final String urlString) {\n        LOG.info(\"Download [\" + urlString + \"]\");", "        try {\n            final ApplicationInfo applicationInfo = ApplicationInfo.getInstance();\n            final Future<String> future = ApplicationManager.getApplication().executeOnPooledThread(() -> {\n                try {\n                    return HttpRequests\n                            .request(urlString)\n                            .gzip(true)\n                            .readTimeout(5000)\n                            .connectTimeout(5000)\n                            .userAgent(applicationInfo.getBuild().getProductCode() + \"/\" + applicationInfo.getFullVersion())\n                            .tuner(request -> request.setRequestProperty(\"Client-Name\", \"GitHub Workflow Plugin\"))\n                            .readString();\n                } catch (final Exception e) {\n                    return null;\n                }\n            });\n            return future.get();\n        } catch (final Exception e) {\n            LOG.warn(\"Execution failed for [\" + urlString + \"] message [\" + (e instanceof NullPointerException ? null : e.getMessage()) + \"]\");\n        }\n        return \"\";\n    }\n", "    public static Optional<Path> getWorkflowFile(final PsiElement psiElement) {\n        return Optional.ofNullable(psiElement)\n                .map(PsiElement::getContainingFile)\n                .map(PsiFile::getOriginalFile)\n                .map(PsiFile::getViewProvider)\n                .map(FileViewProvider::getVirtualFile)\n                .map(VirtualFile::getPath)\n                .map(Paths::get)\n                .filter(GitHubWorkflowUtils::isWorkflowPath);\n    }\n", "    public static boolean isWorkflowPath(final Path path) {\n        return path != null\n                && path.getNameCount() > 2\n                && isYamlFile(path)\n                && path.getName(path.getNameCount() - 2).toString().equalsIgnoreCase(\"workflows\")\n                && path.getName(path.getNameCount() - 3).toString().equalsIgnoreCase(\".github\");\n    }\n\n    public static boolean isYamlFile(final Path path) {\n        return path.getName(path.getNameCount() - 1).toString().toLowerCase().endsWith(\".yml\") || path.getName(path.getNameCount() - 1).toString().toLowerCase().endsWith(\".yaml\");\n    }\n\n    private GitHubWorkflowUtils() {\n\n    }\n}\n", "    public static boolean isYamlFile(final Path path) {\n        return path.getName(path.getNameCount() - 1).toString().toLowerCase().endsWith(\".yml\") || path.getName(path.getNameCount() - 1).toString().toLowerCase().endsWith(\".yaml\");\n    }\n\n    private GitHubWorkflowUtils() {\n\n    }\n}\n"]}
{"filename": "src/main/java/com/github/yunabraska/githubworkflow/completion/CodeCompletionService.java", "chunked_list": ["package com.github.yunabraska.githubworkflow.completion;\n\nimport com.github.yunabraska.githubworkflow.config.NodeIcon;\nimport com.github.yunabraska.githubworkflow.model.CompletionItem;\nimport com.github.yunabraska.githubworkflow.model.GitHubAction;\nimport com.github.yunabraska.githubworkflow.model.YamlElement;\nimport com.intellij.codeInsight.completion.CompletionContributor;\nimport com.intellij.codeInsight.completion.CompletionParameters;\nimport com.intellij.codeInsight.completion.CompletionProvider;\nimport com.intellij.codeInsight.completion.CompletionResultSet;", "import com.intellij.codeInsight.completion.CompletionProvider;\nimport com.intellij.codeInsight.completion.CompletionResultSet;\nimport com.intellij.codeInsight.completion.CompletionType;\nimport com.intellij.codeInsight.completion.impl.CamelHumpMatcher;\nimport com.intellij.codeInsight.lookup.LookupElement;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.patterns.PlatformPatterns;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.util.ProcessingContext;\nimport org.jetbrains.annotations.NotNull;", "import com.intellij.util.ProcessingContext;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Supplier;\n", "import java.util.function.Supplier;\n\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.addLookupElements;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.getCaretBracketItem;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.getDefaultPrefix;\nimport static com.github.yunabraska.githubworkflow.completion.GitHubWorkflowUtils.getWorkflowFile;\nimport static com.github.yunabraska.githubworkflow.config.GitHubWorkflowConfig.*;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_ENV;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_JOB;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_NODE;", "import static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_JOB;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_NODE;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_OUTPUT;\nimport static com.github.yunabraska.githubworkflow.config.NodeIcon.ICON_RUNNER;\nimport static com.github.yunabraska.githubworkflow.model.CompletionItem.*;\nimport static com.github.yunabraska.githubworkflow.model.YamlElementHelper.yamlOf;\nimport static java.util.Collections.singletonList;\nimport static java.util.Optional.ofNullable;\n\npublic class CodeCompletionService extends CompletionContributor {\n\n    public CodeCompletionService() {\n        extend(CompletionType.BASIC, PlatformPatterns.psiElement(), completionProvider());\n    }\n\n    @NotNull\n    private static CompletionProvider<CompletionParameters> completionProvider() {\n        return new CompletionProvider<>() {\n            @Override", "\npublic class CodeCompletionService extends CompletionContributor {\n\n    public CodeCompletionService() {\n        extend(CompletionType.BASIC, PlatformPatterns.psiElement(), completionProvider());\n    }\n\n    @NotNull\n    private static CompletionProvider<CompletionParameters> completionProvider() {\n        return new CompletionProvider<>() {\n            @Override", "            public void addCompletions(\n                    @NotNull final CompletionParameters parameters,\n                    @NotNull final ProcessingContext processingContext,\n                    @NotNull final CompletionResultSet resultSet\n            ) {\n                getWorkflowFile(parameters.getPosition()).map(path -> yamlOf(parameters.getPosition())).map(YamlElement::context).ifPresent(context -> {\n                    // Fixme: remove if EDT errors pops up\n                    final Project project = Optional.of(parameters.getOriginalFile()).map(PsiElement::getProject).orElse(null);\n                    context.actions().values().forEach(action -> action.resolve(parameters.getEditor().getProject()));\n                    final int offset = parameters.getOffset();\n                    final YamlElement position = context.getClosestElement(offset).orElse(new YamlElement(-1, -1, null, null, null, null));\n                    final String[] prefix = new String[]{\"\"};\n                    final Optional<String[]> caretBracketItem = Optional.of(position).filter(p -> p.startIndexAbs() > -1).map(pos -> getCaretBracketItem(pos, offset, prefix)).orElseGet(() -> Optional.of(prefix));\n                    caretBracketItem.ifPresent(cbi -> {\n                        final Map<Integer, List<CompletionItem>> completionResultMap = new HashMap<>();", "                        for (int i = 0; i < cbi.length; i++) {\n                            //DON'T AUTO COMPLETE WHEN PREVIOUS ITEM IS NOT VALID\n                            final List<CompletionItem> previousCompletions = ofNullable(completionResultMap.getOrDefault(i - 1, null)).orElseGet(ArrayList::new);\n                            final int index = i;\n                            if (i != 0 && (previousCompletions.isEmpty() || previousCompletions.stream().noneMatch(item -> item.key().equals(cbi[index])))) {\n                                return;\n                            } else {\n                                addCompletionItems(project, cbi, i, offset, position, completionResultMap);\n                            }\n                        }\n                        //ADD LOOKUP ELEMENTS\n                        ofNullable(completionResultMap.getOrDefault(cbi.length - 1, null))\n                                .map(CodeCompletionService::toLookupItems)\n                                .ifPresent(lookupElements -> addElementsWithPrefix(resultSet, prefix[0], lookupElements));\n                    });\n                    //ACTIONS && WORKFLOWS", "                    if (caretBracketItem.isEmpty()) {\n                        if (position.findParent(FIELD_NEEDS).isPresent()) {\n                            //[jobs.job_name.needs] list previous jobs\n                            Optional.of(listNeeds(position)).filter(cil -> !cil.isEmpty())\n                                    .map(CodeCompletionService::toLookupItems)\n                                    .ifPresent(lookupElements -> addElementsWithPrefix(resultSet, getDefaultPrefix(parameters), lookupElements));\n                        } else {\n                            //USES COMPLETION [jobs.job_id.steps.step_id:with]\n                            final Optional<Map<String, String>> withCompletion = position.findParentWith()\n                                    .map(YamlElement::parent)\n                                    .flatMap(step -> step.child(FIELD_USES))\n                                    .map(YamlElement::textOrChildTextNoQuotes)\n                                    .map(GitHubAction::getGitHubAction)\n                                    .map(action -> action.inputs(project));\n                            withCompletion.ifPresent(map -> addLookupElements(resultSet.withPrefixMatcher(getDefaultPrefix(parameters)), map, NodeIcon.ICON_INPUT, ':'));\n                        }\n                    }\n                });\n            }\n        };\n    }\n\n    private static void addElementsWithPrefix(final CompletionResultSet resultSet, final String prefix, final List<LookupElement> lookupElements) {\n        resultSet.withPrefixMatcher(new CamelHumpMatcher(prefix)).addAllElements(lookupElements);\n    }\n\n    private static void addCompletionItems(final Project project, final String[] cbi, final int i, final int offset, final YamlElement position, final Map<Integer, List<CompletionItem>> completionItemMap) {", "        if (i == 0) {\n            handleFirstItem(cbi, i, offset, position, completionItemMap);\n        } else if (i == 1) {\n            handleSecondItem(cbi, i, completionItemMap);\n        } else if (i == 2) {\n            handleThirdItem(project, cbi, i, offset, position, completionItemMap);\n        }\n    }\n\n    private static void handleThirdItem(final Project project, final String[] cbi, final int i, final int offset, final YamlElement position, final Map<Integer, List<CompletionItem>> completionItemMap) {\n        switch (cbi[0]) {\n            case FIELD_JOBS, FIELD_NEEDS -> completionItemMap.put(i, listJobOutputs(project, position, cbi[1]));\n            case FIELD_STEPS -> completionItemMap.put(i, listStepOutputs(project, position, offset, cbi[1]));\n            default -> {\n                // ignored\n            }\n        }\n    }\n\n    private static void handleSecondItem(final String[] cbi, final int i, final Map<Integer, List<CompletionItem>> completionItemMap) {\n        switch (cbi[0]) {\n            case FIELD_JOBS, FIELD_NEEDS, FIELD_STEPS ->\n                    completionItemMap.put(i, singletonList(completionItemOf(FIELD_OUTPUTS, \"\", ICON_OUTPUT)));\n            default -> {\n                // ignored\n            }\n        }\n    }\n\n    private static void handleFirstItem(final String[] cbi, final int i, final int offset, final YamlElement position, final Map<Integer, List<CompletionItem>> completionItemMap) {\n        switch (cbi[0]) {\n            case FIELD_STEPS -> completionItemMap.put(i, listSteps(position));\n            case FIELD_JOBS -> completionItemMap.put(i, listJobs(position));\n            case FIELD_ENVS -> completionItemMap.put(i, listEnvs(position, offset));\n            case FIELD_GITHUB ->\n                    completionItemMap.put(i, completionItemsOf(DEFAULT_VALUE_MAP.get(FIELD_GITHUB).get(), ICON_ENV));\n            case FIELD_RUNNER ->\n                    completionItemMap.put(i, completionItemsOf(DEFAULT_VALUE_MAP.get(FIELD_RUNNER).get(), ICON_RUNNER));\n            case FIELD_INPUTS -> completionItemMap.put(i, listInputs(position));\n            case FIELD_SECRETS -> completionItemMap.put(i, listSecrets(position));\n            case FIELD_NEEDS -> completionItemMap.put(i, listJobNeeds(position));\n            default -> {\n                //SHOW ONLY JOBS [on.workflow_call.outputs.key.value:xxx]", "                if (position.findParentOutput().map(YamlElement::findParentOn).isPresent()) {\n                    completionItemMap.put(i, singletonList(completionItemOf(FIELD_JOBS, DEFAULT_VALUE_MAP.get(FIELD_DEFAULT).get().get(FIELD_JOBS), ICON_JOB)));\n                } else if (position.findParent(\"runs-on\").isEmpty() && position.findParent(\"os\").isEmpty()) {\n                    //DEFAULT\n                    ofNullable(DEFAULT_VALUE_MAP.getOrDefault(FIELD_DEFAULT, null))\n                            .map(Supplier::get)\n                            .map(map -> {\n                                final Map<String, String> copyMap = new HashMap<>(map);\n                                //'JOBS' HAS ONLY ONE PLACE\n                                copyMap.remove(FIELD_JOBS);\n                                //IF NO 'NEEDS' IS DEFINED", "                                if (position.findParentJob().map(job -> job.child(FIELD_NEEDS)).isEmpty()) {\n                                    copyMap.remove(FIELD_NEEDS);\n                                }\n                                return copyMap;\n                            })\n                            .map(map -> completionItemsOf(map, ICON_NODE))\n                            .ifPresent(items -> completionItemMap.put(i, items));\n                }\n            }\n        }\n    }\n\n    @NotNull\n    private static List<LookupElement> toLookupItems(final List<CompletionItem> items) {\n        return items.stream().map(CompletionItem::toLookupElement).toList();\n    }\n}\n"]}
