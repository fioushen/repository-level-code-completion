{"filename": "Forge/src/main/java/me/frankv/staaaaaaaaaaaack/StxckForgeInitializer.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack;\n\nimport me.frankv.staaaaaaaaaaaack.config.StxckForgeClientConfig;\nimport me.frankv.staaaaaaaaaaaack.config.StxckForgeCommonConfig;\nimport net.minecraftforge.common.ForgeConfigSpec;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.event.entity.EntityJoinLevelEvent;\nimport net.minecraftforge.eventbus.api.EventPriority;\nimport net.minecraftforge.fml.ModLoadingContext;\nimport net.minecraftforge.fml.common.Mod;", "import net.minecraftforge.fml.ModLoadingContext;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.config.ModConfig;\nimport net.minecraftforge.registries.ForgeRegistries;\n\n\n@Mod(Staaaaaaaaaaaack.MODID)\npublic class StxckForgeInitializer {\n    public StxckForgeInitializer() {\n        var eventBus = MinecraftForge.EVENT_BUS;\n        eventBus.addListener(EventPriority.LOWEST, this::onEntityJoinLevel);\n\n        initConfigs();\n        replaceAreMergePredicate();\n        Staaaaaaaaaaaack.registriesFetcher = ForgeRegistries.ITEMS::getValue;\n    }\n\n    private void initConfigs() {\n        var clientConfig = new ForgeConfigSpec.Builder().configure(StxckForgeClientConfig::new);\n        ModLoadingContext.get().registerConfig(ModConfig.Type.CLIENT, clientConfig.getRight());\n        Staaaaaaaaaaaack.clientConfig = clientConfig.getLeft();\n\n        var commonConfig = new ForgeConfigSpec.Builder().configure(StxckForgeCommonConfig::new);\n        ModLoadingContext.get().registerConfig(ModConfig.Type.COMMON, commonConfig.getRight());\n        Staaaaaaaaaaaack.commonConfig = commonConfig.getLeft();\n    }\n\n    private void replaceAreMergePredicate() {\n        StxckUtil.areMergableReplacementPredicate = (a, b) -> {", "            if (!a.is(b.getItem())) {\n                return false;\n            } else if (a.hasTag() ^ b.hasTag()) {\n                return false;\n            } else if (!b.areCapsCompatible(a)) {\n                return false;\n            } else {\n                return !a.hasTag() || a.getTag().equals(b.getTag());\n            }\n        };\n    }\n\n    private void onEntityJoinLevel(EntityJoinLevelEvent event) {\n        EventHandler.onEntityCreate(event.getEntity(), () -> event.setCanceled(true));\n    }\n}\n"]}
{"filename": "Forge/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckForgeClientConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport net.minecraftforge.common.ForgeConfigSpec;\n\npublic class StxckForgeClientConfig implements StxckClientConfig {\n    private final ForgeConfigSpec.IntValue minItemCountRenderDistance;\n    private final ForgeConfigSpec.DoubleValue overlaySizeMultiplier;\n    private final ForgeConfigSpec.BooleanValue alwaysShowItemCount;\n\n\n    public StxckForgeClientConfig(ForgeConfigSpec.Builder builder) {\n        builder.push(\"Item count overlay\");\n\n        minItemCountRenderDistance = builder\n                .comment(\"The maximum distance between you and the drops to display its count.\")\n                .comment(\"Default: 8\")\n                .defineInRange(\"minItemCountRenderDistance\", 8, 0, 128);\n\n        overlaySizeMultiplier = builder\n                .comment(\"Default: 0.8\")\n                .defineInRange(\"overlaySizeMultiplier\", 0.8d, 0.1d, 2d);\n\n        alwaysShowItemCount = builder\n                .comment(\"Show item count overlay even if the item count is lower than default maximum stack size.\")\n                .comment(\"Default: false\")\n                .define(\"alwaysShowItemCount\", false);\n\n        builder.pop();\n    }\n\n    @Override", "    public int getMinItemCountRenderDistance() {\n        return minItemCountRenderDistance.get();\n    }\n\n    @Override\n    public double getOverlaySizeMultiplier() {\n        return overlaySizeMultiplier.get();\n    }\n\n    @Override\n    public boolean isAlwaysShowItemCount() {\n        return alwaysShowItemCount.get();\n    }\n}\n", "    public boolean isAlwaysShowItemCount() {\n        return alwaysShowItemCount.get();\n    }\n}\n"]}
{"filename": "Forge/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckForgeCommonConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport net.minecraftforge.common.ForgeConfigSpec;\n\nimport java.util.*;\n\npublic class StxckForgeCommonConfig implements StxckCommonConfig {\n    private final ForgeConfigSpec.DoubleValue maxMergeDistanceHorizontal;\n    private final ForgeConfigSpec.DoubleValue maxMergeDistanceVertical;\n    private final ForgeConfigSpec.IntValue maxSize;\n    private final ForgeConfigSpec.BooleanValue enableForUnstackableItem;\n    private final ForgeConfigSpec.ConfigValue<List<? extends String>> itemBlackList;\n\n\n    public StxckForgeCommonConfig(ForgeConfigSpec.Builder builder) {\n        builder.push(\"Item merge settings\");\n\n        maxMergeDistanceHorizontal = builder\n                .comment(\"The maximum horizontal block distance over which dropped items attempt to merge with each other.\")\n                .comment(\"Default: 1.25, Minecraft default: 0.5\")\n                .defineInRange(\"maxMergeDistanceHorizontal\", 1.25d, 0.5d, 10d);\n\n        maxMergeDistanceVertical = builder\n                .comment(\"The maximum vertical block distance over which dropped items attempt to merge with each other.\")\n                .comment(\"Default: 0.0, Minecraft default: 0.0\")\n                .defineInRange(\"maxMergeDistanceVertical\", 0d, 0d, 10d);\n\n        maxSize = builder\n                .comment(\"The maximum number of extra items that an item entity can hold.\")\n                .comment(String.format(\"Default: %d\", Integer.MAX_VALUE))\n                .defineInRange(\"maxSize\", Integer.MAX_VALUE, 1, Integer.MAX_VALUE);\n\n        enableForUnstackableItem = builder\n                .comment(\"Enable for merging non-stackable item.\")\n                .comment(\"Should be used with caution while playing with other mods.\")\n                .comment(\"Default: false\")\n                .define(\"enableForUnstackableItem\", false);\n\n        itemBlackList = builder\n                .comment(\"The list of items that should not exceed their original max stack size.\")\n                .comment(\"You can achieve the same feature by using the item tag \\\"#staaaaaaaaaaaack:blacklist\\\" as well.\")\n                .comment(\"e.g., [\\\"minecraft:diamond_block\\\", \\\"minecraft:coal\\\"]\")\n                .defineList(\"itemBlackList\", ArrayList::new, o -> o instanceof String);\n\n        builder.pop();\n    }\n    @Override", "    public double getMaxMergeDistanceHorizontal() {\n        return maxMergeDistanceHorizontal.get();\n    }\n\n    @Override\n    public double getMaxMergeDistanceVertical() {\n        return maxMergeDistanceVertical.get();\n    }\n\n    @Override\n    public int getMaxSize() {\n        return maxSize.get();\n    }\n\n    @Override", "    public int getMaxSize() {\n        return maxSize.get();\n    }\n\n    @Override\n    public boolean isEnableForUnstackableItem() {\n        return enableForUnstackableItem.get();\n    }\n\n    @Override\n    public List<? extends String> getItemBlackList() {\n        return itemBlackList.get();\n    }\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/StxckUtil.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack;\n\nimport me.frankv.staaaaaaaaaaaack.mixin.ItemEntityAccessor;\nimport me.frankv.staaaaaaaaaaaack.mixin.ItemStackAccessor;\nimport net.minecraft.network.syncher.EntityDataAccessor;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.EntityType;\nimport net.minecraft.world.entity.item.ItemEntity;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;", "import net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;\n\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.BiPredicate;\n\npublic class StxckUtil {\n    public static final String EXTRA_ITEM_COUNT_TAG = \"StxckExtraItemCount\";\n    private static EntityDataAccessor<Integer> DATA_EXTRA_ITEM_COUNT;\n", "    public static final String EXTRA_ITEM_COUNT_TAG = \"StxckExtraItemCount\";\n    private static EntityDataAccessor<Integer> DATA_EXTRA_ITEM_COUNT;\n\n    public static BiPredicate<ItemStack, ItemStack> areMergableReplacementPredicate;\n\n\n    public static void setDataExtraItemCount(EntityDataAccessor<Integer> entityDataAccessor) {\n        if (DATA_EXTRA_ITEM_COUNT != null) return;\n        DATA_EXTRA_ITEM_COUNT = entityDataAccessor;\n    }\n", "    public static void refillItemStack(ItemEntity entity) {\n        var extraItemCount = getExtraItemCount(entity);\n        if (extraItemCount <= 0) return ;\n\n        var stack = entity.getItem();\n        Optional.ofNullable(((ItemStackAccessor) (Object) stack).accessItem())\n                .map(Item::getMaxStackSize)\n                .ifPresent(maxSize -> {\n                    if (stack.getCount() == maxSize) return;\n                    var x = maxSize - stack.getCount();\n                    var refillCount = Math.min(x, extraItemCount);\n                    stack.grow(refillCount);\n                    setExtraItemCount(entity, extraItemCount - refillCount);\n                    entity.setItem(stack.copy());\n                });\n    }\n", "                    if (stack.getCount() == maxSize) return;\n                    var x = maxSize - stack.getCount();\n                    var refillCount = Math.min(x, extraItemCount);\n                    stack.grow(refillCount);\n                    setExtraItemCount(entity, extraItemCount - refillCount);\n                    entity.setItem(stack.copy());\n                });\n    }\n\n    public static boolean areMergable(ItemEntity itemEntity, ItemEntity itemEntity1) {\n        var maxExtraSize = Staaaaaaaaaaaack.commonConfig.getMaxSize();", "    public static boolean areMergable(ItemEntity itemEntity, ItemEntity itemEntity1) {\n        var maxExtraSize = Staaaaaaaaaaaack.commonConfig.getMaxSize();\n        if (maxExtraSize - getExtraItemCount(itemEntity) < getTotalCount(itemEntity1)\n                && maxExtraSize - getExtraItemCount(itemEntity1) < getTotalCount(itemEntity)\n        ) {\n            return false;\n        }\n\n        var itemStack = itemEntity.getItem();\n        var itemStack1 = itemEntity1.getItem();\n        if (areMergableReplacementPredicate != null) {\n            return areMergableReplacementPredicate.test(itemStack, itemStack1);\n        }\n", "        if (areMergableReplacementPredicate != null) {\n            return areMergableReplacementPredicate.test(itemStack, itemStack1);\n        }\n\n        if (!itemStack1.is(itemStack.getItem())) {\n            return false;\n        }\n        if (itemStack1.hasTag() ^ itemStack.hasTag()) {\n            return false;\n        }\n        return !itemStack1.hasTag() || Objects.equals(itemStack1.getTag(), itemStack.getTag());\n    }\n", "    public static void grow(ItemEntity entity, int count) {\n        setExtraItemCount(entity, getExtraItemCount(entity) + count);\n        refillItemStack(entity);\n    }\n\n    public static boolean isMergable(ItemEntity entity) {\n        var accessor = (ItemEntityAccessor) entity;\n        var pickupDelay = accessor.getPickupDelay();\n        var age = accessor.getAge();\n        return entity.isAlive() && pickupDelay != 32767 && age != -32768 && age < 6000;\n    }\n", "    public static Optional<String> getTotalCountForDisplay(ItemEntity entity) {\n        var total = getTotalCount(entity);\n        boolean alwaysShowItemCount = Staaaaaaaaaaaack.clientConfig.isAlwaysShowItemCount();\n\n        if (total >= 1_000_000_000) {\n            return Optional.of(String.format(\"%.3fB\", total/1_000_000_000f));\n        }\n        if (total >= 1_000_000) {\n            return Optional.of(String.format(\"%.2fM\", total/1_000_000f));\n        }\n        if (total >= 10_000) {\n            return Optional.of(String.format(\"%.1fK\", total/1_000f));\n        }", "        if (total >= 10_000) {\n            return Optional.of(String.format(\"%.1fK\", total/1_000f));\n        }\n        if (alwaysShowItemCount || total > entity.getItem().getMaxStackSize()) {\n            return Optional.of(String.valueOf(total));\n        }\n        return Optional.empty();\n    }\n\n    public static int getTotalCount(ItemEntity entity) {\n        return entity.getItem().getCount() + getExtraItemCount(entity);\n    }\n", "    public static int getTotalCount(ItemEntity entity) {\n        return entity.getItem().getCount() + getExtraItemCount(entity);\n    }\n\n    public static int getExtraItemCount(ItemEntity entity) {\n        return entity.getEntityData().get(DATA_EXTRA_ITEM_COUNT);\n    }\n\n    public static void setExtraItemCount(ItemEntity entity, int count) {\n        entity.getEntityData().set(DATA_EXTRA_ITEM_COUNT, count);\n    }\n", "    public static void setExtraItemCount(ItemEntity entity, int count) {\n        entity.getEntityData().set(DATA_EXTRA_ITEM_COUNT, count);\n    }\n\n    public static boolean tryRefillItemStackOnEntityRemove(Entity entity, Entity.RemovalReason reason) {\n        if (!entity.getType().equals(EntityType.ITEM) || !reason.equals(Entity.RemovalReason.DISCARDED)) return false;\n\n        var itemEntity = (ItemEntity) entity;\n        if (getExtraItemCount(itemEntity) <= 0) return false;\n\n        var copied = itemEntity.getItem().copy();\n        itemEntity.setItem(copied);\n        copied.setCount(0);\n        refillItemStack(itemEntity);\n        return true;\n    }\n", "        if (getExtraItemCount(itemEntity) <= 0) return false;\n\n        var copied = itemEntity.getItem().copy();\n        itemEntity.setItem(copied);\n        copied.setCount(0);\n        refillItemStack(itemEntity);\n        return true;\n    }\n\n    public static void tryToMerge(ItemEntity itemEntity, ItemEntity itemEntity1) {\n        if (Objects.equals(itemEntity.getOwner(), itemEntity1.getOwner())\n                && areMergable(itemEntity, itemEntity1)\n        ) {", "    public static void tryToMerge(ItemEntity itemEntity, ItemEntity itemEntity1) {\n        if (Objects.equals(itemEntity.getOwner(), itemEntity1.getOwner())\n                && areMergable(itemEntity, itemEntity1)\n        ) {\n            if (getTotalCount(itemEntity1) < getTotalCount(itemEntity)) {\n                merge(itemEntity, itemEntity1);\n            } else {\n                merge(itemEntity1, itemEntity);\n            }\n        }\n    }\n", "    public static void merge(ItemEntity consumer, ItemEntity supplier) {\n        var consumerAccessor = (ItemEntityAccessor) consumer;\n        var supplierAccessor = (ItemEntityAccessor) supplier;\n\n        consumerAccessor.setPickupDelay(Math.max(consumerAccessor.getPickupDelay(), supplierAccessor.getPickupDelay()));\n        consumerAccessor.setAge(Math.min(consumerAccessor.getAge(), supplierAccessor.getAge()));\n\n        grow(consumer, getTotalCount(supplier));\n\n        setExtraItemCount(supplier, 0);\n        supplier.setItem(ItemStack.EMPTY);\n        supplier.discard();\n    }\n", "    public static boolean isBlackListItem(ItemStack itemStack) {\n        if (!Staaaaaaaaaaaack.commonConfig.isEnableForUnstackableItem() && itemStack.getMaxStackSize() == 1) {\n            return true;\n        }\n\n        return itemStack.is(Staaaaaaaaaaaack.BLACK_LIST_TAG)\n                || Staaaaaaaaaaaack.getItemBlackList().contains(itemStack.getItem());\n    }\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/EventHandler.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack;\n\nimport me.frankv.staaaaaaaaaaaack.config.StxckCommonConfig;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.item.ItemEntity;\n\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.*;\n\npublic class EventHandler {\n    private static final StxckCommonConfig config = Staaaaaaaaaaaack.commonConfig;\n\n", "public class EventHandler {\n    private static final StxckCommonConfig config = Staaaaaaaaaaaack.commonConfig;\n\n\n    public static void onEntityCreate(Entity entity, Runnable eventCanceller) {\n        if (!(entity instanceof ItemEntity itemEntity && isMergable(itemEntity))\n                || isBlackListItem(itemEntity.getItem())) return;\n\n        var h = config.getMaxMergeDistanceHorizontal();\n        var v = config.getMaxMergeDistanceVertical();\n\n        var nearByEntities = itemEntity.level().getEntitiesOfClass(\n                ItemEntity.class,\n                itemEntity.getBoundingBox().inflate(h, Math.max(v, .5f), h),\n                (she) -> itemEntity != she && isMergable(she)\n        );\n", "        for(var nearByEntity : nearByEntities) {\n            tryToMerge(nearByEntity, itemEntity);\n            if (itemEntity.isRemoved()) {\n                eventCanceller.run();\n                break;\n            }\n        }\n    }\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/Staaaaaaaaaaaack.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack;\n\n\nimport me.frankv.staaaaaaaaaaaack.config.StxckClientConfig;\nimport me.frankv.staaaaaaaaaaaack.config.StxckCommonConfig;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.tags.TagKey;\nimport net.minecraft.world.item.Item;\n", "import net.minecraft.world.item.Item;\n\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class Staaaaaaaaaaaack {\n    public static final String MODID = \"staaaaaaaaaaaack\";\n\n    public static final TagKey<Item> BLACK_LIST_TAG = TagKey.create(Registries.ITEM, new ResourceLocation(MODID, \"blacklist\"));\n    private static Set<Item> itemBlackList;\n", "    public static final TagKey<Item> BLACK_LIST_TAG = TagKey.create(Registries.ITEM, new ResourceLocation(MODID, \"blacklist\"));\n    private static Set<Item> itemBlackList;\n\n    public static StxckCommonConfig commonConfig;\n    public static StxckClientConfig clientConfig;\n\n    public static Function<ResourceLocation, Item> registriesFetcher;\n\n\n    public static Set<Item> getItemBlackList() {\n        if (itemBlackList == null) {\n            itemBlackList = commonConfig.getItemBlackList().stream()\n                    .map(ResourceLocation::new)\n                    .map(registriesFetcher)\n                    .collect(Collectors.toUnmodifiableSet());\n        }\n        return itemBlackList;\n    }\n}\n", "    public static Set<Item> getItemBlackList() {\n        if (itemBlackList == null) {\n            itemBlackList = commonConfig.getItemBlackList().stream()\n                    .map(ResourceLocation::new)\n                    .map(registriesFetcher)\n                    .collect(Collectors.toUnmodifiableSet());\n        }\n        return itemBlackList;\n    }\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckCommonConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic interface StxckCommonConfig {\n    double getMaxMergeDistanceHorizontal();\n    double getMaxMergeDistanceVertical();\n    int getMaxSize();\n    boolean isEnableForUnstackableItem();\n    List<? extends String> getItemBlackList();\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckClientConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\npublic interface StxckClientConfig {\n    int getMinItemCountRenderDistance();\n    double getOverlaySizeMultiplier();\n    boolean isAlwaysShowItemCount();\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/client/ItemCountRenderer.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.client;\n\nimport com.mojang.blaze3d.vertex.PoseStack;\nimport me.frankv.staaaaaaaaaaaack.Staaaaaaaaaaaack;\nimport me.frankv.staaaaaaaaaaaack.mixin.client.EntityRenderDispatcherAccessor;\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.gui.Font;\nimport net.minecraft.client.renderer.MultiBufferSource;\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.world.entity.item.ItemEntity;", "import net.minecraft.network.chat.Component;\nimport net.minecraft.world.entity.item.ItemEntity;\n\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.getTotalCountForDisplay;\n\npublic class ItemCountRenderer {\n\n    public static void renderItemCount(\n            ItemEntity entity,\n            PoseStack poseStack,\n            MultiBufferSource bufferSource,\n            int light,\n            EntityRenderDispatcherAccessor entityRenderDispatcher\n    ) {\n        var player = Minecraft.getInstance().player;", "        if (player != null && player.isShiftKeyDown()) return;\n\n        getTotalCountForDisplay(entity).ifPresent(itemCount -> {\n            var scale = 0.025f * (float) Staaaaaaaaaaaack.clientConfig.getOverlaySizeMultiplier();\n            poseStack.pushPose();\n            poseStack.translate(0d, entity.getBbHeight() + 0.75f, 0d);\n            poseStack.mulPose(entityRenderDispatcher.getCameraOrientation());\n            poseStack.scale(-scale, -scale, scale);\n\n            var component = Component.literal(itemCount);\n            var matrix4f = poseStack.last().pose();\n            var f1 = Minecraft.getInstance().options.getBackgroundOpacity(0.25F);\n            var font = entityRenderDispatcher.getFont();\n            var j = (int)(f1 * 255f) << 24;\n            var f2 = (float)(-font.width(component) / 2);\n            font.drawInBatch(component, f2, 0, 553648127, false, matrix4f, bufferSource, Font.DisplayMode.NORMAL,  j, light);\n            font.drawInBatch(component, f2, 0, -1, false, matrix4f, bufferSource, Font.DisplayMode.NORMAL, 0, light);\n\n            poseStack.popPose();\n        });\n    }\n\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/ItemEntityAccessor.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin;\n\nimport net.minecraft.world.entity.item.ItemEntity;\nimport net.minecraft.world.item.ItemStack;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Mutable;\nimport org.spongepowered.asm.mixin.gen.Accessor;\nimport org.spongepowered.asm.mixin.gen.Invoker;\n\n@Mixin(ItemEntity.class)\npublic interface ItemEntityAccessor {\n    @Accessor\n    int getPickupDelay();\n\n    @Accessor @Mutable\n    void setPickupDelay(int pickupDelay);\n\n    @Accessor\n    int getAge();\n\n    @Accessor @Mutable\n    void setAge(int age);\n\n    @Invoker(\"merge\")\n    static void invokeMerge(ItemEntity itemEntity, ItemStack itemStack, ItemEntity itemEntity1, ItemStack itemStack1) {\n        throw new AssertionError();\n    }\n}\n", "\n@Mixin(ItemEntity.class)\npublic interface ItemEntityAccessor {\n    @Accessor\n    int getPickupDelay();\n\n    @Accessor @Mutable\n    void setPickupDelay(int pickupDelay);\n\n    @Accessor\n    int getAge();\n\n    @Accessor @Mutable\n    void setAge(int age);\n\n    @Invoker(\"merge\")\n    static void invokeMerge(ItemEntity itemEntity, ItemStack itemStack, ItemEntity itemEntity1, ItemStack itemStack1) {\n        throw new AssertionError();\n    }\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/ItemStackAccessor.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin;\n\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\n\n@Mixin(ItemStack.class)\npublic interface ItemStackAccessor {\n    @Accessor(\"item\")\n    Item accessItem();\n}\n", "public interface ItemStackAccessor {\n    @Accessor(\"item\")\n    Item accessItem();\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/ItemEntityMixin.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin;\n\nimport me.frankv.staaaaaaaaaaaack.Staaaaaaaaaaaack;\nimport net.minecraft.nbt.CompoundTag;\nimport net.minecraft.network.syncher.EntityDataAccessor;\nimport net.minecraft.network.syncher.EntityDataSerializers;\nimport net.minecraft.network.syncher.SynchedEntityData;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.EntityType;\nimport net.minecraft.world.entity.item.ItemEntity;", "import net.minecraft.world.entity.EntityType;\nimport net.minecraft.world.entity.item.ItemEntity;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.item.ItemStack;\nimport net.minecraft.world.item.Items;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.phys.AABB;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Unique;\nimport org.spongepowered.asm.mixin.injection.At;", "import org.spongepowered.asm.mixin.Unique;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.ModifyArg;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.*;", "\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.*;\n\n@ParametersAreNonnullByDefault\n@Mixin(ItemEntity.class)\npublic abstract class ItemEntityMixin extends Entity {\n    @Unique\n    private static final EntityDataAccessor<Integer> STXCK_DATA_EXTRA_ITEM_COUNT;\n\n    @Unique\n    private boolean discardedTick = false;\n\n\n    static {\n        STXCK_DATA_EXTRA_ITEM_COUNT = SynchedEntityData.defineId(ItemEntityMixin.class, EntityDataSerializers.INT);\n        setDataExtraItemCount(STXCK_DATA_EXTRA_ITEM_COUNT);\n    }\n\n    public ItemEntityMixin(EntityType<?> entityType, Level level) {\n        super(entityType, level);\n    }\n\n\n    @Inject(\n            method = \"<init>(Lnet/minecraft/world/entity/item/ItemEntity;)V\",\n            at = @At(\"RETURN\")\n    )\n    private void constructorSetExtraCountInject(ItemEntity itemEntity, CallbackInfo ci) {\n        setExtraItemCount(getThis(), getExtraItemCount(itemEntity));\n    }\n\n    @Inject(\n            method = \"<init>(Lnet/minecraft/world/level/Level;DDDLnet/minecraft/world/item/ItemStack;DDD)V\",\n            at = @At(\"RETURN\")\n    )\n    private void constructorSetExtraCountInject(CallbackInfo ci) {\n        setExtraItemCount(getThis(), 0);\n    }\n\n    @Inject(method = \"defineSynchedData\", at = @At(\"RETURN\"))\n    private void defineSynchedDataForExtraItemCount(CallbackInfo ci) {\n        getThis().getEntityData().define(STXCK_DATA_EXTRA_ITEM_COUNT, 0);\n    }\n\n    @Inject(\n            method = \"tick\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/world/entity/Entity;tick()V\",\n                    shift = At.Shift.AFTER\n            )\n    )\n    private void tickInject(CallbackInfo ci) {\n        discardedTick = false;\n        refillItemStack(getThis());\n    }\n\n    @Inject(method = \"isMergable\", at = @At(\"HEAD\"), cancellable = true)\n    private void replaceIsMergable(CallbackInfoReturnable<Boolean> cir) {\n        var self = getThis();\n        var itemStack = self.getItem();", "        if (isBlackListItem(itemStack)\n                || getExtraItemCount(self) >= Staaaaaaaaaaaack.commonConfig.getMaxSize()) return;\n        cir.setReturnValue(isMergable(getThis()));\n    }\n\n    @Inject(method = \"tryToMerge\", at = @At(\"HEAD\"), cancellable = true)\n    private void replaceTryToMerge(ItemEntity itemEntity1, CallbackInfo ci) {\n        var self = getThis();\n        if (isBlackListItem(self.getItem())) return;\n        tryToMerge(self, itemEntity1);\n        ci.cancel();\n    }\n\n    @ModifyArg(\n            method = \"mergeWithNeighbours\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/world/level/Level;getEntitiesOfClass(Ljava/lang/Class;Lnet/minecraft/world/phys/AABB;Ljava/util/function/Predicate;)Ljava/util/List;\"\n            ),\n            index = 1\n    )\n    private AABB mergeWithNeighbours(AABB uwu) {\n        var h = Staaaaaaaaaaaack.commonConfig.getMaxMergeDistanceHorizontal();\n        var v = Staaaaaaaaaaaack.commonConfig.getMaxMergeDistanceVertical();\n        return getThis().getBoundingBox().inflate(h, v, h);\n    }\n\n    @Inject(\n            method = \"addAdditionalSaveData\",\n            at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/world/item/ItemStack;isEmpty()Z\")\n    )\n    private void saveExtraItemCount(CompoundTag compoundTag, CallbackInfo ci) {\n        var extraCount = getExtraItemCount(getThis());", "        if (isBlackListItem(self.getItem())) return;\n        tryToMerge(self, itemEntity1);\n        ci.cancel();\n    }\n\n    @ModifyArg(\n            method = \"mergeWithNeighbours\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/world/level/Level;getEntitiesOfClass(Ljava/lang/Class;Lnet/minecraft/world/phys/AABB;Ljava/util/function/Predicate;)Ljava/util/List;\"\n            ),\n            index = 1\n    )\n    private AABB mergeWithNeighbours(AABB uwu) {\n        var h = Staaaaaaaaaaaack.commonConfig.getMaxMergeDistanceHorizontal();\n        var v = Staaaaaaaaaaaack.commonConfig.getMaxMergeDistanceVertical();\n        return getThis().getBoundingBox().inflate(h, v, h);\n    }\n\n    @Inject(\n            method = \"addAdditionalSaveData\",\n            at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/world/item/ItemStack;isEmpty()Z\")\n    )\n    private void saveExtraItemCount(CompoundTag compoundTag, CallbackInfo ci) {\n        var extraCount = getExtraItemCount(getThis());", "        if (extraCount > 0) {\n            compoundTag.putInt(EXTRA_ITEM_COUNT_TAG, extraCount);\n        }\n    }\n\n    @Inject(\n            method = \"readAdditionalSaveData\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/nbt/CompoundTag;getCompound(Ljava/lang/String;)Lnet/minecraft/nbt/CompoundTag;\"\n            )\n    )\n    private void readExtraItemCount(CompoundTag compoundTag, CallbackInfo ci) {", "        if (compoundTag.contains(EXTRA_ITEM_COUNT_TAG)) {\n            setExtraItemCount(getThis(), compoundTag.getInt(EXTRA_ITEM_COUNT_TAG));\n        }\n    }\n\n    @Inject(method = \"setItem\", at = @At(\"HEAD\"), cancellable = true)\n    private void handleSetEmpty(ItemStack item, CallbackInfo ci) {\n        if (discardedTick) {\n            ci.cancel();\n            return;\n        }", "        if (item != ItemStack.EMPTY && !item.is(Items.AIR)) return;\n        var self = getThis();\n        if (getExtraItemCount(self) <= 0) return;\n        var copied = self.getItem().copy();\n        if (!copied.isEmpty()) {\n            self.setItem(copied);\n            copied.setCount(0);\n        }\n        ci.cancel();\n    }\n\n    @Inject(method = \"playerTouch\", at = @At(\"RETURN\"))\n    private void syncItemOnPickup(Player player, CallbackInfo ci) {\n        var self = getThis();\n        var item = self.getItem();", "        if (!item.isEmpty()) {\n            self.setItem(item.copy());\n        }\n    }\n\n    @Override\n    public void remove(RemovalReason reason) {\n        if (tryRefillItemStackOnEntityRemove(getThis(), reason)) {\n            discardedTick = true;\n            unsetRemoved();\n            return;\n        }\n        super.remove(reason);\n    }\n\n    private ItemEntity getThis() {\n        return (ItemEntity) (Object) this;\n    }\n\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/client/LevelRendererMixin.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin.client;\n\nimport com.mojang.blaze3d.vertex.PoseStack;\nimport me.frankv.staaaaaaaaaaaack.client.ItemCountRenderer;\nimport me.frankv.staaaaaaaaaaaack.Staaaaaaaaaaaack;\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.renderer.LevelRenderer;\nimport net.minecraft.client.renderer.MultiBufferSource;\nimport net.minecraft.util.Mth;\nimport net.minecraft.world.entity.Entity;", "import net.minecraft.util.Mth;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.item.ItemEntity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n\n@Mixin(value = LevelRenderer.class)\npublic abstract class LevelRendererMixin {\n\n    @Inject(\n            method = \"renderEntity\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/client/renderer/entity/EntityRenderDispatcher;render(Lnet/minecraft/world/entity/Entity;DDDFFLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;I)V\"\n            )\n    )\n    private void renderItemCount(\n            Entity entity,\n            double x, double y, double z,\n            float partialTicks,\n            PoseStack poseStack,\n            MultiBufferSource bufferSource,\n            CallbackInfo ci\n    ) {\n        var entityRenderDispatcher = Minecraft.getInstance().getEntityRenderDispatcher();", "\n@Mixin(value = LevelRenderer.class)\npublic abstract class LevelRendererMixin {\n\n    @Inject(\n            method = \"renderEntity\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/client/renderer/entity/EntityRenderDispatcher;render(Lnet/minecraft/world/entity/Entity;DDDFFLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;I)V\"\n            )\n    )\n    private void renderItemCount(\n            Entity entity,\n            double x, double y, double z,\n            float partialTicks,\n            PoseStack poseStack,\n            MultiBufferSource bufferSource,\n            CallbackInfo ci\n    ) {\n        var entityRenderDispatcher = Minecraft.getInstance().getEntityRenderDispatcher();", "        if (entityRenderDispatcher.camera == null) return;\n        var accessor = (EntityRenderDispatcherAccessor) entityRenderDispatcher;\n        var maxDistance = Staaaaaaaaaaaack.clientConfig.getMinItemCountRenderDistance();\n        if (entityRenderDispatcher.distanceToSqr(entity) > maxDistance * maxDistance) return;\n        if (entity instanceof ItemEntity itemEntity) {\n            var offset = entityRenderDispatcher.getRenderer(entity).getRenderOffset(entity, partialTicks);\n            var light = entityRenderDispatcher.getPackedLightCoords(entity, partialTicks);\n            var nx = Mth.lerp(partialTicks, entity.xOld, entity.getX()) - x + offset.x();\n            var ny = Mth.lerp(partialTicks, entity.yOld, entity.getY()) - y + offset.y();\n            var nz = Mth.lerp(partialTicks, entity.zOld, entity.getZ()) - z + offset.z();\n\n            poseStack.pushPose();\n            poseStack.translate(nx, ny, nz);\n            ItemCountRenderer.renderItemCount(itemEntity, poseStack, bufferSource, light, accessor);\n            poseStack.popPose();\n        }\n    }\n\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/client/EntityRenderDispatcherAccessor.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin.client;\n\nimport net.minecraft.client.gui.Font;\nimport net.minecraft.client.renderer.entity.EntityRenderDispatcher;\nimport org.joml.Quaternionf;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\n\n@Mixin(EntityRenderDispatcher.class)\npublic interface EntityRenderDispatcherAccessor {\n    @Accessor(\"font\")\n    Font getFont();\n\n    @Accessor(\"cameraOrientation\")\n    Quaternionf getCameraOrientation();\n}\n", "@Mixin(EntityRenderDispatcher.class)\npublic interface EntityRenderDispatcherAccessor {\n    @Accessor(\"font\")\n    Font getFont();\n\n    @Accessor(\"cameraOrientation\")\n    Quaternionf getCameraOrientation();\n}\n"]}
{"filename": "Common/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/client/ClientPacketListenerMixin.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin.client;\n\nimport net.minecraft.client.multiplayer.ClientLevel;\nimport net.minecraft.client.multiplayer.ClientPacketListener;\nimport net.minecraft.world.entity.Entity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Redirect;\n\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.*;", "\nimport static me.frankv.staaaaaaaaaaaack.StxckUtil.*;\n\n@Mixin(ClientPacketListener.class)\npublic class ClientPacketListenerMixin {\n\n    @Redirect(\n            method = \"handleTakeItemEntity\",\n            at = @At(\n                    value = \"INVOKE\",\n                    target = \"Lnet/minecraft/client/multiplayer/ClientLevel;removeEntity(ILnet/minecraft/world/entity/Entity$RemovalReason;)V\",\n                    ordinal = 0\n            )\n    )\n    private void handleRemoveItemEntity(ClientLevel instance, int entityId, Entity.RemovalReason reason) {\n        var entity = getThis().getLevel().getEntity(entityId);", "        if (entity == null || tryRefillItemStackOnEntityRemove(entity, reason)) return;\n        getThis().getLevel().removeEntity(entityId, reason);\n    }\n\n    private ClientPacketListener getThis() {\n        return (ClientPacketListener) (Object) this;\n    }\n}\n"]}
{"filename": "Fabric/src/main/java/me/frankv/staaaaaaaaaaaack/StxckFabricInitializer.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack;\n\nimport me.frankv.staaaaaaaaaaaack.config.FiberUtils;\nimport me.frankv.staaaaaaaaaaaack.config.StxckFiberClientConfig;\nimport me.frankv.staaaaaaaaaaaack.config.StxckFiberCommonConfig;\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.api.ModInitializer;\nimport net.minecraft.core.registries.BuiltInRegistries;\n\npublic class StxckFabricInitializer implements ModInitializer, ClientModInitializer {\n\n    @Override", "\npublic class StxckFabricInitializer implements ModInitializer, ClientModInitializer {\n\n    @Override\n    public void onInitialize() {\n        var config = new StxckFiberCommonConfig();\n        FiberUtils.setup(config.getConfigTree(), StxckFiberCommonConfig.fileName);\n\n        Staaaaaaaaaaaack.commonConfig = config;\n        Staaaaaaaaaaaack.registriesFetcher = BuiltInRegistries.ITEM::get;\n    }\n\n    @Override", "    public void onInitializeClient() {\n        var config = new StxckFiberClientConfig();\n        Staaaaaaaaaaaack.clientConfig = config;\n        FiberUtils.setup(config.getConfigTree(), StxckFiberClientConfig.fileName);\n    }\n\n}\n"]}
{"filename": "Fabric/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckFiberCommonConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport io.github.fablabsmc.fablabs.api.fiber.v1.schema.type.derived.ConfigTypes;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.schema.type.derived.ListConfigType;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.tree.ConfigTree;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.tree.PropertyMirror;\nimport lombok.Getter;\nimport me.frankv.staaaaaaaaaaaack.Staaaaaaaaaaaack;\n\nimport java.util.List;", "\nimport java.util.List;\n\npublic class StxckFiberCommonConfig implements StxckCommonConfig {\n    public static final String fileName = Staaaaaaaaaaaack.MODID + \"-common.json5\";\n\n    private static final ListConfigType<List<String>, String> stringListConfigType = ConfigTypes.makeList(ConfigTypes.STRING);\n\n    @Getter\n    private final ConfigTree configTree;\n\n    private final PropertyMirror<Double> maxMergeDistanceHorizontal = PropertyMirror.create(ConfigTypes.DOUBLE);\n    private final PropertyMirror<Double> maxMergeDistanceVertical = PropertyMirror.create(ConfigTypes.DOUBLE);\n    private final PropertyMirror<Integer> maxSize = PropertyMirror.create(ConfigTypes.INTEGER);\n    private final PropertyMirror<Boolean> enableForUnstackableItem = PropertyMirror.create(ConfigTypes.BOOLEAN);\n    private final PropertyMirror<List<String>> itemBlackList = PropertyMirror.create(stringListConfigType);\n\n    public StxckFiberCommonConfig() {\n        var builder = ConfigTree.builder();\n        builder.beginValue(\"maxMergeDistanceHorizontal\", ConfigTypes.DOUBLE.withMaximum(10d).withMinimum(.5d), 1.25d)\n                .withComment(\"\"\"\n                        \n                        The maximum horizontal block distance over which dropped items attempt to merge with each other.\n                        Range: 0.5 ~ 10.0, Default: 1.25, Minecraft default: 0.5\n                        \"\"\")\n                .finishValue(maxMergeDistanceHorizontal::mirror);\n\n        builder.beginValue(\"maxMergeDistanceVertical\", ConfigTypes.DOUBLE.withMaximum(10d).withMinimum(0d), 0d)\n                .withComment(\"\"\"\n                        \n                        The minimum vertical block distance over which dropped items attempt to merge with each other.\n                        Range: 0.0 ~ 10.0, Default: 0.0, Minecraft default: 0.0\n                        \"\"\")\n                .finishValue(maxMergeDistanceVertical::mirror);\n\n        builder.beginValue(\"maxSize\", ConfigTypes.INTEGER.withMaximum(Integer.MAX_VALUE).withMinimum(1), Integer.MAX_VALUE)\n                .withComment(String.format(\"\"\"\n                        \n                        The maximum number of extra items that an item entity can hold.\n                        Range: 0 ~ %d, Default: %d\n                        \"\"\", Integer.MAX_VALUE, Integer.MAX_VALUE))\n                .finishValue(maxSize::mirror);\n\n        builder.beginValue(\"enableForUnstackableItem\", ConfigTypes.BOOLEAN, false)\n                .withComment(\"\"\"\n                        \n                        Enable for merging non-stackable item.\n                        Should be used with caution while playing with other mods.\n                        Default: false\n                        \"\"\")\n                .finishValue(enableForUnstackableItem::mirror);\n\n        builder.beginValue(\"itemBlackList\", stringListConfigType, List.of())\n                .withComment(\"\"\"\n                        \n                        The list of items that should not exceed their original max stack size.\n                        You can achieve the same feature by using the item tag \"#staaaaaaaaaaaack:blacklist\" as well.\n                        e.g., [\"minecraft:diamond_block\", \"minecraft:coal\"]\n                        \"\"\")\n                .finishValue(itemBlackList::mirror);\n\n        configTree = builder.build();\n    }\n\n    @Override", "    public double getMaxMergeDistanceHorizontal() {\n        return maxMergeDistanceHorizontal.getValue();\n    }\n\n    @Override\n    public double getMaxMergeDistanceVertical() {\n        return maxMergeDistanceVertical.getValue();\n    }\n\n    @Override\n    public int getMaxSize() {\n        return maxSize.getValue();\n    }\n\n    @Override", "    public int getMaxSize() {\n        return maxSize.getValue();\n    }\n\n    @Override\n    public boolean isEnableForUnstackableItem() {\n        return enableForUnstackableItem.getValue();\n    }\n\n    @Override\n    public List<? extends String> getItemBlackList() {\n        return itemBlackList.getValue();\n    }\n}\n"]}
{"filename": "Fabric/src/main/java/me/frankv/staaaaaaaaaaaack/config/FiberUtils.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport io.github.fablabsmc.fablabs.api.fiber.v1.exception.ValueDeserializationException;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.serialization.FiberSerialization;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.serialization.JanksonValueSerializer;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.tree.ConfigTree;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;", "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.nio.file.*;\n\n@Slf4j\npublic class FiberUtils {\n\n    private static void writeDefaultConfig(ConfigTree config, Path path, JanksonValueSerializer serializer) {\n        try (var outputStream = new BufferedOutputStream(Files.newOutputStream(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW))) {\n            FiberSerialization.serialize(config, outputStream, serializer);\n        } catch (FileAlreadyExistsException ignored) {} catch (IOException e) {\n            log.error(\"Error writing default config\", e);\n        }\n    }\n\n    private static void loadConfig(ConfigTree config, Path path, JanksonValueSerializer serializer) {\n        writeDefaultConfig(config, path, serializer);\n\n        try (var inputStream = new BufferedInputStream(Files.newInputStream(path, StandardOpenOption.READ, StandardOpenOption.CREATE))) {\n            FiberSerialization.deserialize(config, inputStream, serializer);\n        } catch (IOException | ValueDeserializationException e) {\n            log.error(\"Error loading config from {}\", path, e);\n        }\n    }\n", "    public static void setup(ConfigTree config, String fileName) {\n        try {\n            Files.createDirectory(Paths.get(\"config\"));\n        } catch (FileAlreadyExistsException ignored) {} catch (IOException e) {\n            log.warn(\"Failed to make config dir\", e);\n        }\n\n        var serializer = new JanksonValueSerializer(false);\n        loadConfig(config, Path.of(\"config\", fileName), serializer);\n    }\n}\n"]}
{"filename": "Fabric/src/main/java/me/frankv/staaaaaaaaaaaack/config/StxckFiberClientConfig.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.config;\n\nimport io.github.fablabsmc.fablabs.api.fiber.v1.schema.type.derived.ConfigTypes;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.tree.ConfigTree;\nimport io.github.fablabsmc.fablabs.api.fiber.v1.tree.PropertyMirror;\nimport lombok.Getter;\nimport me.frankv.staaaaaaaaaaaack.Staaaaaaaaaaaack;\n\n\npublic class StxckFiberClientConfig implements StxckClientConfig {\n    public static final String fileName = Staaaaaaaaaaaack.MODID + \"-client.json5\";\n\n    @Getter\n    private final ConfigTree configTree;\n\n    private final PropertyMirror<Integer> minItemCountRenderDistance = PropertyMirror.create(ConfigTypes.INTEGER);\n    private final PropertyMirror<Double> overlaySizeMultiplier = PropertyMirror.create(ConfigTypes.DOUBLE);\n    private final PropertyMirror<Boolean> alwaysShowItemCount = PropertyMirror.create(ConfigTypes.BOOLEAN);\n\n    public StxckFiberClientConfig() {\n        var builder = ConfigTree.builder();\n        builder.beginValue(\"minItemCountRenderDistance\", ConfigTypes.INTEGER.withMaximum(128).withMinimum(0), 8)\n                .withComment(\"\"\"\n                        \n                        The maximum distance between you and the drops to display its count.\n                        Range: 0 ~ 128, Default: 8\n                        \"\"\")\n                .finishValue(minItemCountRenderDistance::mirror);\n\n        builder.beginValue(\"overlaySizeMultiplier\", ConfigTypes.DOUBLE.withMaximum(2d).withMinimum(.1d), 0.8d)\n                .withComment(\"\"\"\n                        \n                        Range: 0.1 ~ 2.0, Default: 0.8\n                        \"\"\")\n                .finishValue(overlaySizeMultiplier::mirror);\n\n        builder.beginValue(\"alwaysShowItemCount\", ConfigTypes.BOOLEAN, false)\n                .withComment(\"\"\"\n                        \n                        Show item count overlay even if the item count is lower than default maximum stack size.\n                        Default: false\n                        \"\"\")\n                .finishValue(alwaysShowItemCount::mirror);\n\n        configTree = builder.build();\n    }\n\n    @Override", "\npublic class StxckFiberClientConfig implements StxckClientConfig {\n    public static final String fileName = Staaaaaaaaaaaack.MODID + \"-client.json5\";\n\n    @Getter\n    private final ConfigTree configTree;\n\n    private final PropertyMirror<Integer> minItemCountRenderDistance = PropertyMirror.create(ConfigTypes.INTEGER);\n    private final PropertyMirror<Double> overlaySizeMultiplier = PropertyMirror.create(ConfigTypes.DOUBLE);\n    private final PropertyMirror<Boolean> alwaysShowItemCount = PropertyMirror.create(ConfigTypes.BOOLEAN);\n\n    public StxckFiberClientConfig() {\n        var builder = ConfigTree.builder();\n        builder.beginValue(\"minItemCountRenderDistance\", ConfigTypes.INTEGER.withMaximum(128).withMinimum(0), 8)\n                .withComment(\"\"\"\n                        \n                        The maximum distance between you and the drops to display its count.\n                        Range: 0 ~ 128, Default: 8\n                        \"\"\")\n                .finishValue(minItemCountRenderDistance::mirror);\n\n        builder.beginValue(\"overlaySizeMultiplier\", ConfigTypes.DOUBLE.withMaximum(2d).withMinimum(.1d), 0.8d)\n                .withComment(\"\"\"\n                        \n                        Range: 0.1 ~ 2.0, Default: 0.8\n                        \"\"\")\n                .finishValue(overlaySizeMultiplier::mirror);\n\n        builder.beginValue(\"alwaysShowItemCount\", ConfigTypes.BOOLEAN, false)\n                .withComment(\"\"\"\n                        \n                        Show item count overlay even if the item count is lower than default maximum stack size.\n                        Default: false\n                        \"\"\")\n                .finishValue(alwaysShowItemCount::mirror);\n\n        configTree = builder.build();\n    }\n\n    @Override", "    public int getMinItemCountRenderDistance() {\n        return minItemCountRenderDistance.getValue();\n    }\n\n    @Override\n    public double getOverlaySizeMultiplier() {\n        return overlaySizeMultiplier.getValue();\n    }\n\n    @Override\n    public boolean isAlwaysShowItemCount() {\n        return alwaysShowItemCount.getValue();\n    }\n}\n", "    public boolean isAlwaysShowItemCount() {\n        return alwaysShowItemCount.getValue();\n    }\n}\n"]}
{"filename": "Fabric/src/main/java/me/frankv/staaaaaaaaaaaack/mixin/PersistentEntitySectionManagerMixin.java", "chunked_list": ["package me.frankv.staaaaaaaaaaaack.mixin;\n\nimport me.frankv.staaaaaaaaaaaack.EventHandler;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.level.entity.EntityAccess;\nimport net.minecraft.world.level.entity.PersistentEntitySectionManager;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;", "import org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(value = PersistentEntitySectionManager.class, priority = 9999)\npublic class PersistentEntitySectionManagerMixin<T extends EntityAccess> {\n\n    @Inject(method = \"addEntity\", at = @At(\"HEAD\"), cancellable = true)\n    private void hookAddEntity(T entityAccess, boolean bl, CallbackInfoReturnable<Boolean> cir) {\n        if (entityAccess instanceof Entity entity) {\n            EventHandler.onEntityCreate(entity, () -> cir.setReturnValue(false));\n        }\n    }\n\n}\n", "        if (entityAccess instanceof Entity entity) {\n            EventHandler.onEntityCreate(entity, () -> cir.setReturnValue(false));\n        }\n    }\n\n}\n"]}
