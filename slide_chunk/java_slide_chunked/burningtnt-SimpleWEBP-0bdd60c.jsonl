{"filename": "jfx/src/test/java/net/burningtnt/webp/SimpleWebpTest.java", "chunked_list": ["package net.burningtnt.webp;\n\nimport javafx.scene.image.Image;\nimport javafx.scene.image.PixelReader;\nimport net.burningtnt.webp.jfx.WEBPImageLoaderFactory;\nimport org.glavo.png.PNGType;\nimport org.glavo.png.PNGWriter;\nimport org.glavo.png.image.ArgbImageWrapper;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\n\npublic final class SimpleWebpTest {\n    private SimpleWebpTest() {\n    }\n", "\npublic final class SimpleWebpTest {\n    private SimpleWebpTest() {\n    }\n\n    public static final String[] inputs = new String[]{\n            \"bangbang93\",\n            \"bangbang93@2x\",\n            \"chest\",\n            \"chest@2x\",\n            \"chicken\",\n            \"chicken@2x\",\n            \"command\",\n            \"command@2x\",\n            \"craft_table\",\n            \"craft_table@2x\",\n            \"discord\",\n            \"discord@2x\",\n            \"fabric\",\n            \"fabric@2x\",\n            \"forge\",\n            \"forge@2x\",\n            \"furnace\",\n            \"furnace@2x\",\n            \"gamerteam\",\n            \"gamerteam@2x\",\n            \"github\",\n            \"github@2x\",\n            \"glavo\",\n            \"glavo@2x\",\n            \"grass\",\n            \"grass@2x\",\n            \"icon\",\n            \"icon@2x\",\n            \"icon@8x\",\n            \"kookapp\",\n            \"kookapp@2x\",\n            \"mcmod\",\n            \"mcmod@2x\",\n            \"quilt\",\n            \"quilt@2x\",\n            \"red_lnn\",\n            \"red_lnn@2x\",\n            \"yellow_fish\",\n            \"yellow_fish@2x\",\n            \"yushijinhun\",\n            \"yushijinhun@2x\"\n    };\n\n    private static String current = null;\n\n    @Test", "    public void main() throws IOException {\n        WEBPImageLoaderFactory.setupListener();\n\n        for (String input : inputs) {\n            current = input;\n\n            Image inputImage = new Image(Objects.requireNonNull(SimpleWebpTest.class.getResourceAsStream(String.format(\"/inputs/%s.webp\", current))));\n            Image desiresImage = new Image(Objects.requireNonNull(SimpleWebpTest.class.getResourceAsStream(String.format(\"/desires/%s.png\", current))));\n\n            Path output = Paths.get(\"build/tmp/test\", current + \".png\").toAbsolutePath();\n            Files.deleteIfExists(output);\n\n            new PNGWriter(Files.newOutputStream(output), PNGType.RGBA, PNGWriter.DEFAULT_COMPRESS_LEVEL).write(\n                    new ArgbImageWrapper<>(inputImage, (int) inputImage.getWidth(), (int) inputImage.getHeight()) {\n                        private final PixelReader pixelReader = inputImage.getPixelReader();\n\n                        @Override", "                        public int getArgb(int x, int y) {\n                            return pixelReader.getArgb(x, y);\n                        }\n                    }\n            );\n\n            assertEquals(inputImage, desiresImage);\n        }\n    }\n\n    private static void assertEquals(Image inputImage, Image desireImage) {\n        Assertions.assertEquals(inputImage.getWidth(), desireImage.getWidth());\n        Assertions.assertEquals(inputImage.getHeight(), desireImage.getHeight());\n\n        PixelReader inputReader = inputImage.getPixelReader();\n        PixelReader desireReader = inputImage.getPixelReader();\n", "        for (int y = 0; y < (int) inputImage.getHeight(); y++) {\n            for (int x = 0; x < (int) inputImage.getWidth(); x++) {\n                if (inputReader.getArgb(x, y) != desireReader.getArgb(x, y)) {\n                    Assertions.fail(String.format(\n                            \"[Test point #%s] Illegal pixel at [%d, %d], expected 0x%08x but found 0x%08x\", current, x, y,\n                            inputReader.getArgb(x, y), desireReader.getArgb(x, y)\n                    ));\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "jfx/src/main/java/net/burningtnt/webp/jfx/WEBPDescriptor.java", "chunked_list": ["package net.burningtnt.webp.jfx;\n\nimport com.sun.javafx.iio.common.ImageDescriptor;\n\npublic final class WEBPDescriptor extends ImageDescriptor {\n    private static final ImageDescriptor instance = new WEBPDescriptor();\n\n    private WEBPDescriptor() {\n        super(\"WEBP\", new String[]{\"webp\"}, new Signature[]{new Signature(\n                (byte) 'R', (byte) 'I', (byte) 'F', (byte) 'F'\n        )});\n    }\n", "    public static ImageDescriptor getInstance() {\n        return instance;\n    }\n}\n"]}
{"filename": "jfx/src/main/java/net/burningtnt/webp/jfx/WEBPImageLoader.java", "chunked_list": ["package net.burningtnt.webp.jfx;\n\nimport com.sun.javafx.iio.ImageFrame;\nimport com.sun.javafx.iio.ImageMetadata;\nimport com.sun.javafx.iio.ImageStorage;\nimport com.sun.javafx.iio.common.ImageLoaderImpl;\nimport net.burningtnt.webp.SimpleWEBPLoader;\nimport net.burningtnt.webp.utils.RGBABuffer;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\n\npublic class WEBPImageLoader extends ImageLoaderImpl {\n    private final InputStream inputStream;\n\n    public WEBPImageLoader(InputStream inputStream) {\n        super(WEBPDescriptor.getInstance());\n        this.inputStream = inputStream;\n    }\n\n    @Override", "    public void dispose() {\n    }\n\n    @Override\n    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {\n        RGBABuffer rgbaBuffer = SimpleWEBPLoader.decodeStreamByImageLoaders(this.inputStream);\n\n        return new ImageFrame(\n                ImageStorage.ImageType.RGBA,\n                ByteBuffer.wrap(rgbaBuffer.getRGBAData()),\n                rgbaBuffer.getWidth(), rgbaBuffer.getHeight(),\n                rgbaBuffer.getWidth() * 4, null,\n                new ImageMetadata(\n                        null, Boolean.FALSE, null, null, null, null, null,\n                        rgbaBuffer.getWidth(), rgbaBuffer.getHeight(),\n                        null, null, null\n                )\n        );\n    }\n}\n"]}
{"filename": "jfx/src/main/java/net/burningtnt/webp/jfx/WEBPImageLoaderFactory.java", "chunked_list": ["package net.burningtnt.webp.jfx;\n\nimport com.sun.javafx.iio.ImageFormatDescription;\nimport com.sun.javafx.iio.ImageLoader;\nimport com.sun.javafx.iio.ImageLoaderFactory;\nimport com.sun.javafx.iio.ImageStorage;\n\nimport java.io.InputStream;\n\npublic final class WEBPImageLoaderFactory implements ImageLoaderFactory {\n    private static final WEBPImageLoaderFactory instance = new WEBPImageLoaderFactory();\n\n    private WEBPImageLoaderFactory() {\n    }\n\n    @Override", "\npublic final class WEBPImageLoaderFactory implements ImageLoaderFactory {\n    private static final WEBPImageLoaderFactory instance = new WEBPImageLoaderFactory();\n\n    private WEBPImageLoaderFactory() {\n    }\n\n    @Override\n    public ImageFormatDescription getFormatDescription() {\n        return WEBPDescriptor.getInstance();\n    }\n\n    @Override", "    public ImageFormatDescription getFormatDescription() {\n        return WEBPDescriptor.getInstance();\n    }\n\n    @Override\n    public ImageLoader createImageLoader(InputStream input) {\n        return new WEBPImageLoader(input);\n    }\n\n    public static void setupListener() {\n        ImageStorage.addImageLoaderFactory(instance);\n    }\n}\n", "    public static void setupListener() {\n        ImageStorage.addImageLoaderFactory(instance);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/SimpleWEBPLoader.java", "chunked_list": ["package net.burningtnt.webp;\n\nimport net.burningtnt.webp.utils.RGBABuffer;\nimport net.burningtnt.webp.vp8l.VP8LDecoder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.EnumMap;\n\npublic enum SimpleWEBPLoader {\n    VP8L(VP8LDecoder::decodeStream);\n", "\npublic enum SimpleWEBPLoader {\n    VP8L(VP8LDecoder::decodeStream);\n\n    public static RGBABuffer decodeStreamByImageLoaders(InputStream inputStream) throws IOException {\n        EnumMap<SimpleWEBPLoader, IOException> errors = new EnumMap<>(SimpleWEBPLoader.class);\n\n        for (SimpleWEBPLoader simpleWebpLoader : values()) {\n            try {\n                return simpleWebpLoader.decodeStreamByCurrentImageLoader(inputStream);\n            } catch (IOException e) {\n                errors.put(simpleWebpLoader, e);\n            }\n        }\n\n        IOException e = new IOException(String.format(\"Fail to load image from %s because all the image loaders throw an IOException.\", inputStream));", "            try {\n                return simpleWebpLoader.decodeStreamByCurrentImageLoader(inputStream);\n            } catch (IOException e) {\n                errors.put(simpleWebpLoader, e);\n            }\n        }\n\n        IOException e = new IOException(String.format(\"Fail to load image from %s because all the image loaders throw an IOException.\", inputStream));\n        for (SimpleWEBPLoader simpleWebpLoader : values()) {\n            e.addSuppressed(new IOException(String.format(\"Image Loader %s throw an IOException\", simpleWebpLoader.name()), errors.get(simpleWebpLoader)));\n        }\n        throw e;\n    }\n\n    @FunctionalInterface\n    private interface LoadAction {\n        RGBABuffer load(InputStream inputStream) throws IOException;\n    }\n\n    private final LoadAction delegate;\n\n    SimpleWEBPLoader(LoadAction delegate) {\n        this.delegate = delegate;\n    }\n", "        for (SimpleWEBPLoader simpleWebpLoader : values()) {\n            e.addSuppressed(new IOException(String.format(\"Image Loader %s throw an IOException\", simpleWebpLoader.name()), errors.get(simpleWebpLoader)));\n        }\n        throw e;\n    }\n\n    @FunctionalInterface\n    private interface LoadAction {\n        RGBABuffer load(InputStream inputStream) throws IOException;\n    }\n\n    private final LoadAction delegate;\n\n    SimpleWEBPLoader(LoadAction delegate) {\n        this.delegate = delegate;\n    }\n", "    public RGBABuffer decodeStreamByCurrentImageLoader(InputStream inputStream) throws IOException {\n        return this.delegate.load(inputStream);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/utils/LSBBitInputStream.java", "chunked_list": ["package net.burningtnt.webp.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic final class LSBBitInputStream {\n    private final InputStream inputStream;\n    private int bitOffset = 64;\n    private long buffer;\n    private boolean used = false;\n\n    public LSBBitInputStream(InputStream inputStream) {\n        this.inputStream = inputStream;\n    }\n", "    public long readBits(int bits) throws IOException {\n        if (bits <= 56) {\n            if (!used) {\n                refillBuffer();\n                used = true;\n            }\n\n            long ret = (buffer >>> bitOffset) & ((1L << bits) - 1);\n\n            bitOffset += bits;\n", "            if (bitOffset >= 8) {\n                refillBuffer();\n            }\n\n            return ret;\n        } else {\n            long lower = readBits(56);\n            return (readBits(bits - 56) << (56)) | lower;\n        }\n    }\n", "    public long peekBits(int bits) throws IOException {\n        if (bits <= 56) {\n            return (buffer >>> bitOffset) & ((1L << bits) - 1);\n        } else {\n            throw new IOException(\"Cannot peek over 56 bits\");\n        }\n    }\n\n    public int readBit() throws IOException {\n        return (int) readBits(1);\n    }\n\n    private void refillBuffer() throws IOException {", "    public int readBit() throws IOException {\n        return (int) readBits(1);\n    }\n\n    private void refillBuffer() throws IOException {\n        for (; bitOffset >= 8; bitOffset -= 8) {\n            byte readByte = (byte) inputStream.read();\n            buffer = ((long) readByte << 56) | buffer >>> 8;\n        }\n    }\n}\n\n"]}
{"filename": "src/main/java/net/burningtnt/webp/utils/RGBABuffer.java", "chunked_list": ["package net.burningtnt.webp.utils;\n\npublic abstract class RGBABuffer {\n    protected final int x;\n    protected final int y;\n    protected final int w;\n    protected final int h;\n\n    protected RGBABuffer(int x, int y, int w, int h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n", "    public static RGBABuffer createAbsoluteImage(int w, int h) {\n        if (((long) w) * ((long) h) * 4L > Integer.MAX_VALUE) {\n            throw new IndexOutOfBoundsException(\"Image is too big.\");\n        }\n\n        return new AbsoluteRGBABuffer(0, 0, w, h);\n    }\n\n    public static RGBABuffer createRelativeImage(RGBABuffer parent, int x, int y, int w, int h) {\n        if (x < 0 || y < 0 || w < 0 || h < 0 || x > parent.w || y > parent.h || x + w > parent.w || y + h > parent.h) {\n            throw new IndexOutOfBoundsException(String.format(\"Child Image (%d, %d, %d, %d) is out of Parent Image (%d, %d)\", x, y, w, h, parent.w, parent.h));\n        }\n\n        return new RelativeRGBABuffer(x, y, w, h, parent);\n    }\n", "    public static RGBABuffer createRelativeImage(RGBABuffer parent, int x, int y, int w, int h) {\n        if (x < 0 || y < 0 || w < 0 || h < 0 || x > parent.w || y > parent.h || x + w > parent.w || y + h > parent.h) {\n            throw new IndexOutOfBoundsException(String.format(\"Child Image (%d, %d, %d, %d) is out of Parent Image (%d, %d)\", x, y, w, h, parent.w, parent.h));\n        }\n\n        return new RelativeRGBABuffer(x, y, w, h, parent);\n    }\n\n    public int getWidth() {\n        return this.w;\n    }\n", "    public int getWidth() {\n        return this.w;\n    }\n\n    public int getHeight() {\n        return this.h;\n    }\n\n    public abstract byte[] getRGBAData();\n\n    protected final void checkBound(int x, int y) {", "    public abstract byte[] getRGBAData();\n\n    protected final void checkBound(int x, int y) {\n        if (x < 0 || y < 0 || x >= this.w || y >= this.h) {\n            throw new IndexOutOfBoundsException(String.format(\"Pixel (%d, %d) is out of Image (%d, %d)\", x, y, this.w, this.h));\n        }\n    }\n\n    public abstract void getDataElements(int x, int y, byte[] rgba);\n\n    public abstract void setDataElements(int x, int y, byte[] rgba);\n", "    public abstract void getDataElements(int x, int y, byte[] rgba);\n\n    public abstract void setDataElements(int x, int y, byte[] rgba);\n\n    public abstract byte getSample(int x, int y, int sample) throws UnsupportedOperationException;\n\n    private static final class AbsoluteRGBABuffer extends RGBABuffer {\n        private final byte[] rgbaData;\n\n        public AbsoluteRGBABuffer(int x, int y, int w, int h) {\n            super(x, y, w, h);\n            rgbaData = new byte[w * h * 4];\n        }\n\n        @Override\n        public byte[] getRGBAData() {\n            return rgbaData;\n        }\n\n        @Override", "        public void getDataElements(int x, int y, byte[] rgba) {\n            checkBound(x, y);\n            System.arraycopy(this.rgbaData, this.w * y * 4 + x * 4, rgba, 0, 4);\n        }\n\n        @Override\n        public void setDataElements(int x, int y, byte[] rgba) {\n            checkBound(x, y);\n            System.arraycopy(rgba, 0, this.rgbaData, this.w * y * 4 + x * 4, 4);\n        }\n\n        @Override", "        public byte getSample(int x, int y, int sample) {\n            checkBound(x, y);\n            return this.rgbaData[this.w * y * 4 + x * 4 + sample];\n        }\n    }\n\n    private static final class RelativeRGBABuffer extends RGBABuffer {\n        private final RGBABuffer parent;\n\n        public RelativeRGBABuffer(int x, int y, int w, int h, RGBABuffer parent) {\n            super(x, y, w, h);\n            this.parent = parent;\n        }\n\n        @Override\n        public byte[] getRGBAData() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override", "        public void getDataElements(int x, int y, byte[] rgba) {\n            this.parent.getDataElements(x + this.x, y + this.y, rgba);\n        }\n\n        @Override\n        public void setDataElements(int x, int y, byte[] rgba) {\n            this.parent.setDataElements(x + this.x, y + this.y, rgba);\n        }\n\n        @Override\n        public byte getSample(int x, int y, int sample) {\n            return this.parent.getSample(x + this.x, y + this.y, sample);\n        }\n    }\n}\n", "        public byte getSample(int x, int y, int sample) {\n            return this.parent.getSample(x + this.x, y + this.y, sample);\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/VP8LDecoder.java", "chunked_list": ["/*\n * Copyright (c) 2017, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l;\n\nimport net.burningtnt.webp.utils.LSBBitInputStream;", "\nimport net.burningtnt.webp.utils.LSBBitInputStream;\nimport net.burningtnt.webp.utils.RGBABuffer;\nimport net.burningtnt.webp.vp8l.colorcache.ColorCache;\nimport net.burningtnt.webp.vp8l.huffman.HuffmanCodeGroup;\nimport net.burningtnt.webp.vp8l.huffman.HuffmanInfo;\nimport net.burningtnt.webp.vp8l.transform.*;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;", "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * VP8LDecoder.\n *", " * VP8LDecoder.\n *\n * @author <a href=\"mailto:harald.kuhr@gmail.com\">Harald Kuhr</a>\n * @author Simon Kammermeier\n */\npublic final class VP8LDecoder {\n    private static final int PREDICTOR_TRANSFORM = 0;\n    private static final int COLOR_TRANSFORM = 1;\n    private static final int SUBTRACT_GREEN_TRANSFORM = 2;\n    private static final int COLOR_INDEXING_TRANSFORM = 3;\n\n    /**\n     * Used for decoding backward references\n     * Upper 4Bits are y distance, lower 4 Bits are 8 minus x distance\n     */\n    private final static byte[] DISTANCES = {\n            0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,\n            0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,\n            0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,\n            0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,\n            0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,\n            0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,\n            0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,\n            0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,\n            0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,\n            0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,\n            0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,\n            0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70\n    };\n\n    private static final int RIFF_MAGIC = 'R' << 24 | 'I' << 16 | 'F' << 8 | 'F';\n    private static final int WEBP_MAGIC = 'W' << 24 | 'E' << 16 | 'B' << 8 | 'P';\n    private static final int CHUNK_VP8L = 'V' << 24 | 'P' << 16 | '8' << 8 | 'L';\n\n    private static final byte LOSSLESSS_SIG = 0x2f;\n\n    private final LSBBitInputStream lsbBitReader;\n\n    private VP8LDecoder(LSBBitInputStream imageInput) {\n        this.lsbBitReader = imageInput;\n    }\n", "    public static RGBABuffer decodeStream(InputStream inputStream) throws IOException {\n        DataInputStream dataInputStream = new DataInputStream(inputStream);\n        if (dataInputStream.readInt() != RIFF_MAGIC) {\n            throw new IOException(\"Invalid RIFF_MAGIC.\");\n        }\n\n        dataInputStream.readInt();\n\n        if (dataInputStream.readInt() != WEBP_MAGIC) {\n            throw new IOException(\"Invalid WEBP_MAGIC\");\n        }\n", "        if (dataInputStream.readInt() != WEBP_MAGIC) {\n            throw new IOException(\"Invalid WEBP_MAGIC\");\n        }\n\n        if (dataInputStream.readInt() != CHUNK_VP8L) {\n            throw new UnsupportedEncodingException(\"SimpleWEBP can only decode VP8L\");\n        }\n        dataInputStream.readInt();\n\n        if (dataInputStream.readByte() != LOSSLESSS_SIG) {\n            throw new IOException(\"Invalid LOSSLESS_SIG\");\n        }\n\n        LSBBitInputStream lsbBitInputStream = new LSBBitInputStream(inputStream);\n\n        int width = 1 + (int) lsbBitInputStream.readBits(14);\n        int height = 1 + (int) lsbBitInputStream.readBits(14);\n        lsbBitInputStream.readBit();\n", "        if (dataInputStream.readByte() != LOSSLESSS_SIG) {\n            throw new IOException(\"Invalid LOSSLESS_SIG\");\n        }\n\n        LSBBitInputStream lsbBitInputStream = new LSBBitInputStream(inputStream);\n\n        int width = 1 + (int) lsbBitInputStream.readBits(14);\n        int height = 1 + (int) lsbBitInputStream.readBits(14);\n        lsbBitInputStream.readBit();\n\n        if ((int) lsbBitInputStream.readBits(3) != 0) {\n            throw new IOException(\"Invalid Version.\");\n        }\n\n        RGBABuffer outputBuffer = RGBABuffer.createAbsoluteImage(width, height);\n\n        new VP8LDecoder(lsbBitInputStream).readVP8Lossless(outputBuffer, true, width, height);\n\n        return outputBuffer;\n    }\n\n    private void readVP8Lossless(final RGBABuffer raster, final boolean topLevel, int width, int height) throws IOException {\n        int xSize = width;\n\n        // Read transforms\n        ArrayList<Transform> transforms = new ArrayList<>();", "        if ((int) lsbBitInputStream.readBits(3) != 0) {\n            throw new IOException(\"Invalid Version.\");\n        }\n\n        RGBABuffer outputBuffer = RGBABuffer.createAbsoluteImage(width, height);\n\n        new VP8LDecoder(lsbBitInputStream).readVP8Lossless(outputBuffer, true, width, height);\n\n        return outputBuffer;\n    }\n\n    private void readVP8Lossless(final RGBABuffer raster, final boolean topLevel, int width, int height) throws IOException {\n        int xSize = width;\n\n        // Read transforms\n        ArrayList<Transform> transforms = new ArrayList<>();", "        while (topLevel && lsbBitReader.readBit() == 1) {\n            xSize = readTransform(xSize, height, transforms);\n        }\n\n        // Read color cache size\n        int colorCacheBits = 0;\n        if (lsbBitReader.readBit() == 1) {\n            colorCacheBits = (int) lsbBitReader.readBits(4);\n\n            if (colorCacheBits < 1 || colorCacheBits > 11) {\n                throw new IOException(\"Corrupt WebP stream, colorCacheBits < 1 || > 11: \" + colorCacheBits);\n            }\n        }\n\n        // Read Huffman codes\n        HuffmanInfo huffmanInfo = readHuffmanCodes(xSize, height, colorCacheBits, topLevel);\n\n        ColorCache colorCache = null;\n", "            if (colorCacheBits < 1 || colorCacheBits > 11) {\n                throw new IOException(\"Corrupt WebP stream, colorCacheBits < 1 || > 11: \" + colorCacheBits);\n            }\n        }\n\n        // Read Huffman codes\n        HuffmanInfo huffmanInfo = readHuffmanCodes(xSize, height, colorCacheBits, topLevel);\n\n        ColorCache colorCache = null;\n\n        if (colorCacheBits > 0) {\n            colorCache = new ColorCache(colorCacheBits);\n        }\n\n        RGBABuffer decodeRaster;", "        if (colorCacheBits > 0) {\n            colorCache = new ColorCache(colorCacheBits);\n        }\n\n        RGBABuffer decodeRaster;\n        if (topLevel) {\n            // If multiple indices packed into one pixel xSize is different from raster width\n            decodeRaster = RGBABuffer.createRelativeImage(raster, 0, 0, xSize, height);\n        } else {\n            // All recursive calls have Rasters of the correct sizes with origin (0, 0)\n            decodeRaster = raster;\n        }\n\n        // Use the Huffman trees to decode the LZ77 encoded data.\n        decodeImage(decodeRaster, huffmanInfo, colorCache);\n", "        for (Transform transform : transforms) {\n            transform.apply(raster);\n        }\n    }\n\n    private void decodeImage(RGBABuffer raster, HuffmanInfo huffmanInfo, ColorCache colorCache) throws IOException {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        int huffmanMask = huffmanInfo.metaCodeBits == 0 ? -1 : ((1 << huffmanInfo.metaCodeBits) - 1);\n        HuffmanCodeGroup curCodeGroup = huffmanInfo.huffmanGroups[0];\n\n        byte[] rgba = new byte[4];\n", "        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                if ((x & huffmanMask) == 0 && huffmanInfo.huffmanMetaCodes != null) {\n                    // Crossed border into new metaGroup\n                    // huffmanInfo.huffmanMetaCodes IntRaster\n                    int index = huffmanInfo.huffmanMetaCodes.getSample(x >> huffmanInfo.metaCodeBits, y >> huffmanInfo.metaCodeBits, 1);\n                    curCodeGroup = huffmanInfo.huffmanGroups[index];\n                }\n\n                short code = curCodeGroup.mainCode.readSymbol(lsbBitReader);\n", "                if (code < 256) { // Literal\n                    decodeLiteral(raster, colorCache, curCodeGroup, rgba, y, x, code);\n                } else if (code < 256 + 24) { // backward reference\n                    int length = decodeBwRef(raster, colorCache, width, curCodeGroup, rgba, code, x, y);\n\n                    // Decrement one because for loop already increments by one\n                    x--;\n                    y = y + ((x + length) / width);\n                    x = (x + length) % width;\n\n                    // Reset Huffman meta group", "                    if (y < height && x < width && huffmanInfo.huffmanMetaCodes != null) {\n                        int index = huffmanInfo.huffmanMetaCodes.getSample(x >> huffmanInfo.metaCodeBits, y >> huffmanInfo.metaCodeBits, 1);\n                        curCodeGroup = huffmanInfo.huffmanGroups[index];\n                    }\n                } else { // colorCache\n                    decodeCached(raster, colorCache, rgba, y, x, code);\n                }\n            }\n        }\n    }\n\n    private void decodeCached(RGBABuffer raster, ColorCache colorCache, byte[] rgba, int y, int x, short code) {\n        int argb = colorCache.lookup(code - 256 - 24);\n\n        rgba[0] = (byte) ((argb >> 16) & 0xff);\n        rgba[1] = (byte) ((argb >> 8) & 0xff);\n        rgba[2] = (byte) (argb & 0xff);\n        rgba[3] = (byte) (argb >>> 24);\n        raster.setDataElements(x, y, rgba);\n    }\n\n    private void decodeLiteral(RGBABuffer raster, ColorCache colorCache, HuffmanCodeGroup curCodeGroup, byte[] rgba, int y, int x, short code) throws IOException {\n        byte red = (byte) curCodeGroup.redCode.readSymbol(lsbBitReader);\n        byte blue = (byte) curCodeGroup.blueCode.readSymbol(lsbBitReader);\n        byte alpha = (byte) curCodeGroup.alphaCode.readSymbol(lsbBitReader);\n\n        rgba[0] = red;\n        rgba[1] = (byte) code;\n        rgba[2] = blue;\n        rgba[3] = alpha;\n        raster.setDataElements(x, y, rgba);\n", "        if (colorCache != null) {\n            colorCache.insert((alpha & 0xff) << 24 | (red & 0xff) << 16 | (code & 0xff) << 8 | (blue & 0xff));\n        }\n    }\n\n    private int decodeBwRef(RGBABuffer raster, ColorCache colorCache, int width, HuffmanCodeGroup curCodeGroup, byte[] rgba, short code, int x, int y) throws IOException {\n        int length = lz77decode(code - 256);\n\n        short distancePrefix = curCodeGroup.distanceCode.readSymbol(lsbBitReader);\n        int distanceCode = lz77decode(distancePrefix);\n\n        int xSrc, ySrc;\n", "        if (distanceCode > 120) {\n            // Linear distance\n            int distance = distanceCode - 120;\n            ySrc = y - (distance / width);\n            xSrc = x - (distance % width);\n        } else {\n            // See comment of distances array\n            xSrc = x - (8 - (DISTANCES[distanceCode - 1] & 0xf));\n            ySrc = y - (DISTANCES[distanceCode - 1] >> 4);\n        }\n", "        if (xSrc < 0) {\n            ySrc--;\n            xSrc += width;\n        } else if (xSrc >= width) {\n            xSrc -= width;\n            ySrc++;\n        }\n\n        for (int l = length; l > 0; x++, l--) {\n            // Check length and xSrc, ySrc not falling outside raster? (Should not occur if image is correct)\n            if (x == width) {\n                x = 0;\n                y++;\n            }\n            int x1 = xSrc++;\n            raster.getDataElements(x1, ySrc, rgba);\n            raster.setDataElements(x, y, rgba);\n", "        for (int l = length; l > 0; x++, l--) {\n            // Check length and xSrc, ySrc not falling outside raster? (Should not occur if image is correct)\n            if (x == width) {\n                x = 0;\n                y++;\n            }\n            int x1 = xSrc++;\n            raster.getDataElements(x1, ySrc, rgba);\n            raster.setDataElements(x, y, rgba);\n\n            if (xSrc == width) {\n                xSrc = 0;\n                ySrc++;\n            }", "            if (xSrc == width) {\n                xSrc = 0;\n                ySrc++;\n            }\n            if (colorCache != null) {\n                colorCache.insert((rgba[3] & 0xff) << 24 | (rgba[0] & 0xff) << 16 | (rgba[1] & 0xff) << 8 | (rgba[2] & 0xff));\n            }\n        }\n\n        return length;\n    }\n\n    private int lz77decode(int prefixCode) throws IOException {\n        // According to specification", "        if (prefixCode < 4) {\n            return prefixCode + 1;\n        } else {\n            int extraBits = (prefixCode - 2) >> 1;\n            int offset = (2 + (prefixCode & 1)) << extraBits;\n\n            return offset + (int) lsbBitReader.readBits(extraBits) + 1;\n        }\n    }\n\n    private int readTransform(int xSize, int ySize, List<Transform> transforms) throws IOException {\n        int transformType = (int) lsbBitReader.readBits(2);\n\n        switch (transformType) {\n            case PREDICTOR_TRANSFORM:\n                // Intentional Fallthrough\n            case COLOR_TRANSFORM: {\n                // The two first transforms contains the exact same data, can be combined\n\n                byte sizeBits = (byte) (lsbBitReader.readBits(3) + 2);\n\n                int blockWidth = subSampleSize(xSize, sizeBits);\n                int blockHeight = subSampleSize(ySize, sizeBits);\n                RGBABuffer raster =\n//                        Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, blockWidth, blockHeight, 4 * blockWidth, 4, new int[]{0, 1, 2, 3}, null);\n                        RGBABuffer.createAbsoluteImage(blockWidth, blockHeight);\n                readVP8Lossless(raster, false, blockWidth, blockHeight);\n\n                // Keep data as raster for convenient (x,y) indexing", "                if (transformType == PREDICTOR_TRANSFORM) {\n                    transforms.add(0, new PredictorTransform(raster, sizeBits));\n                } else {\n                    transforms.add(0, new ColorTransform(raster, sizeBits));\n                }\n\n                break;\n            }\n            case SUBTRACT_GREEN_TRANSFORM: {\n                // No data here\n                transforms.add(0, new SubtractGreenTransform());\n                break;\n            }\n            case COLOR_INDEXING_TRANSFORM: {\n                // 8 bit value for color table size\n                int colorTableSize = ((int) lsbBitReader.readBits(8)) + 1; // 1-256\n\n                // If the index is equal or larger than color_table_size,\n                // the argb color value should be set to 0x00000000\n                // We handle this by allocating a possibly larger buffer\n                int safeColorTableSize = colorTableSize > 16 ? 256 :\n                        colorTableSize > 4 ? 16 :\n                                colorTableSize > 2 ? 4 : 2;\n\n                byte[] colorTable = new byte[safeColorTableSize * 4];\n\n                // The color table can be obtained by reading an image,\n                // without the RIFF header, image size, and transforms,\n                // assuming a height of one pixel and a width of\n                // color_table_size. The color table is always\n                // subtraction-coded to reduce image entropy.\n                RGBABuffer colorTableRGBABuffer = RGBABuffer.createAbsoluteImage(colorTableSize, 1);\n                readVP8Lossless(\n//                        Raster.createInterleavedRaster(\n//                                new DataBufferByte(colorTable, colorTableSize * 4),\n//                                colorTableSize, 1, colorTableSize * 4, 4, new int[]{0, 1, 2, 3}, null),\n                        colorTableRGBABuffer,\n                        false, colorTableSize, 1);\n\n                byte[] colorTableRGBACopyBuffer = new byte[4];", "                for (int x = 0; x < colorTableSize; x++) {\n                    colorTableRGBABuffer.getDataElements(x, 0, colorTableRGBACopyBuffer);\n                    System.arraycopy(colorTableRGBACopyBuffer, 0, colorTable, x * 4, 4);\n                }\n\n                // resolve subtraction code\n                for (int i = 4; i < colorTable.length; i++) {\n                    colorTable[i] += colorTable[i - 4];\n                }\n\n                // The number of pixels packed into each green sample (byte)\n                byte widthBits = (byte) (colorTableSize > 16 ? 0 :\n                        colorTableSize > 4 ? 1 :\n                                colorTableSize > 2 ? 2 : 3);\n\n                xSize = subSampleSize(xSize, widthBits);\n\n                // The colors components are stored in ARGB order at 4*index, 4*index + 1, 4*index + 2, 4*index + 3\n                transforms.add(0, new ColorIndexingTransform(colorTable, widthBits));\n\n                break;\n            }\n            default:\n                throw new IOException(\"Invalid transformType: \" + transformType);\n        }\n\n        return xSize;\n    }\n\n    private HuffmanInfo readHuffmanCodes(int xSize, int ySize, int colorCacheBits, boolean readMetaCodes) throws IOException {\n        int huffmanGroupNum = 1;\n        int huffmanXSize;\n        int huffmanYSize;\n\n        int metaCodeBits = 0;\n\n        RGBABuffer huffmanMetaCodes = null;\n", "        if (readMetaCodes && lsbBitReader.readBit() == 1) {\n            // read in meta codes\n            metaCodeBits = (int) lsbBitReader.readBits(3) + 2;\n            huffmanXSize = subSampleSize(xSize, metaCodeBits);\n            huffmanYSize = subSampleSize(ySize, metaCodeBits);\n\n            // Raster with elements as BARG (only the RG components encode the meta group)\n            RGBABuffer packedRaster =\n//                    Raster.createPackedRaster(DataBuffer.TYPE_INT, huffmanXSize, huffmanYSize, new int[]{0x0000ff00, 0x000000ff, 0xff000000, 0x00ff0000}, null);\n                    RGBABuffer.createAbsoluteImage(huffmanXSize, huffmanYSize);\n            readVP8Lossless(packedRaster, false, huffmanXSize, huffmanYSize);\n\n            // Max metaGroup is number of meta groups\n            int maxCode = Integer.MIN_VALUE;", "            for (int x = 0; x < packedRaster.getWidth(); x++) {\n                for (int y = 0; y < packedRaster.getHeight(); y++) {\n                    maxCode = Math.max(maxCode, packedRaster.getSample(x, y, 1));\n                }\n            }\n            huffmanGroupNum = maxCode + 1;\n\n            // New Raster with just RG components exposed as single band\n            // allowing simple access of metaGroupIndex with x,y lookup\n            huffmanMetaCodes =\n//                    Raster.createPackedRaster(packedRaster.getDataBuffer(), huffmanXSize, huffmanYSize, huffmanXSize, new int[]{0xffff}, null);\n                    packedRaster;\n        }\n\n        HuffmanCodeGroup[] huffmanGroups = new HuffmanCodeGroup[huffmanGroupNum];\n", "        for (int i = 0; i < huffmanGroups.length; i++) {\n            huffmanGroups[i] = new HuffmanCodeGroup(lsbBitReader, colorCacheBits);\n        }\n\n        return new HuffmanInfo(huffmanMetaCodes, metaCodeBits, huffmanGroups);\n    }\n\n    private static int subSampleSize(final int size, final int samplingBits) {\n        return (size + (1 << samplingBits) - 1) >> samplingBits;\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/huffman/HuffmanCodeGroup.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.huffman;\n\nimport net.burningtnt.webp.utils.LSBBitInputStream;", "\nimport net.burningtnt.webp.utils.LSBBitInputStream;\n\nimport java.io.IOException;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class HuffmanCodeGroup {\n    /**\n     * Used for green, backward reference length and color cache\n     */", "public final class HuffmanCodeGroup {\n    /**\n     * Used for green, backward reference length and color cache\n     */\n    public final HuffmanTable mainCode;\n\n    public final HuffmanTable redCode;\n    public final HuffmanTable blueCode;\n    public final HuffmanTable alphaCode;\n    public final HuffmanTable distanceCode;\n\n    public HuffmanCodeGroup(LSBBitInputStream lsbBitReader, int colorCacheBits) throws IOException {\n        mainCode = new HuffmanTable(lsbBitReader, 256 + 24 + (colorCacheBits > 0 ? 1 << colorCacheBits : 0));\n        redCode = new HuffmanTable(lsbBitReader, 256);\n        blueCode = new HuffmanTable(lsbBitReader, 256);\n        alphaCode = new HuffmanTable(lsbBitReader, 256);\n        distanceCode = new HuffmanTable(lsbBitReader, 40);\n    }\n}\n", "    public final HuffmanTable alphaCode;\n    public final HuffmanTable distanceCode;\n\n    public HuffmanCodeGroup(LSBBitInputStream lsbBitReader, int colorCacheBits) throws IOException {\n        mainCode = new HuffmanTable(lsbBitReader, 256 + 24 + (colorCacheBits > 0 ? 1 << colorCacheBits : 0));\n        redCode = new HuffmanTable(lsbBitReader, 256);\n        blueCode = new HuffmanTable(lsbBitReader, 256);\n        alphaCode = new HuffmanTable(lsbBitReader, 256);\n        distanceCode = new HuffmanTable(lsbBitReader, 40);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/huffman/HuffmanTable.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.huffman;\n\nimport net.burningtnt.webp.utils.LSBBitInputStream;", "\nimport net.burningtnt.webp.utils.LSBBitInputStream;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Represents a single huffman tree as a table.", "/**\n * Represents a single huffman tree as a table.\n * <p>\n * Decoding a symbol just involves reading bits from the input stream and using that read value to index into the\n * lookup table.\n * <p>\n * Code length and the corresponding symbol are packed into one array element (int).\n * This is done to avoid the overhead and the fragmentation over the whole heap involved with creating objects\n * of a custom class. The upper 16 bits of each element are the code length and lower 16 bits are the symbol.\n * <p>", " * of a custom class. The upper 16 bits of each element are the code length and lower 16 bits are the symbol.\n * <p>\n * The max allowed code length by the WEBP specification is 15, therefore this would mean the table needs to have\n * 2^15 elements. To keep a reasonable memory usage, instead the lookup table only directly holds symbols with code\n * length up to {@code LEVEL1_BITS} (Currently 8 bits). For longer codes the lookup table stores a reference to a\n * second level lookup table. This reference consists of an element with length as the max length of the level 2\n * table and value as the index of the table in the list of level 2 tables.\n * <p>\n * Reading bits from the input is done in a least significant bit first way (LSB) way, therefore the prefix of the\n * read value of length i is the lowest i bits in inverse order.", " * Reading bits from the input is done in a least significant bit first way (LSB) way, therefore the prefix of the\n * read value of length i is the lowest i bits in inverse order.\n * The lookup table is directly indexed by the {@code LEVEL1_BITS} next bits read from the input (i.e. the bits\n * corresponding to next code are inverse suffix of the read value/index).\n * So for a code length of l all values with the lowest l bits the same need to decode to the same symbol\n * regardless of the {@code (LEVEL1_BITS - l)} higher bits. So the lookup table needs to have the entry of this symbol\n * repeated every 2^(l + 1) spots starting from the bitwise inverse of the code.\n *\n * @author Simon Kammermeier\n */\npublic final class HuffmanTable {\n    private static final int LEVEL1_BITS = 8;\n    /**\n     * Symbols of the L-code in the order they need to be read\n     */\n    private static final int[] L_CODE_ORDER = {17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    private final int[] level1 = new int[1 << LEVEL1_BITS];\n    private final List<int[]> level2 = new ArrayList<>();\n\n    /**\n     * Build a Huffman table by reading the encoded symbol lengths from the reader\n     *\n     * @param lsbBitReader the reader to read from\n     * @param alphabetSize the number of symbols in the alphabet to be decoded by this huffman table\n     * @throws IOException when reading produces an exception\n     */\n    public HuffmanTable(LSBBitInputStream lsbBitReader, int alphabetSize) throws IOException {\n        boolean simpleLengthCode = lsbBitReader.readBit() == 1;\n", " * @author Simon Kammermeier\n */\npublic final class HuffmanTable {\n    private static final int LEVEL1_BITS = 8;\n    /**\n     * Symbols of the L-code in the order they need to be read\n     */\n    private static final int[] L_CODE_ORDER = {17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    private final int[] level1 = new int[1 << LEVEL1_BITS];\n    private final List<int[]> level2 = new ArrayList<>();\n\n    /**\n     * Build a Huffman table by reading the encoded symbol lengths from the reader\n     *\n     * @param lsbBitReader the reader to read from\n     * @param alphabetSize the number of symbols in the alphabet to be decoded by this huffman table\n     * @throws IOException when reading produces an exception\n     */\n    public HuffmanTable(LSBBitInputStream lsbBitReader, int alphabetSize) throws IOException {\n        boolean simpleLengthCode = lsbBitReader.readBit() == 1;\n", "        if (simpleLengthCode) {\n            int symbolNum = lsbBitReader.readBit() + 1;\n            boolean first8Bits = lsbBitReader.readBit() == 1;\n            short symbol1 = (short) lsbBitReader.readBits(first8Bits ? 8 : 1);\n\n            if (symbolNum == 2) {\n                short symbol2 = (short) lsbBitReader.readBits(8);\n\n                for (int i = 0; i < (1 << LEVEL1_BITS); i += 2) {\n                    level1[i] = 1 << 16 | symbol1;\n                    level1[i + 1] = 1 << 16 | symbol2;\n                }\n            } else {\n                Arrays.fill(level1, symbol1);\n            }\n        } else {\n            // code lengths also huffman coded\n            // first read the \"first stage\" code lengths\n            // In the following this is called the L-Code (for length code)\n            int numLCodeLengths = (int) (lsbBitReader.readBits(4) + 4);\n            short[] lCodeLengths = new short[L_CODE_ORDER.length];\n            int numPosCodeLens = 0;\n", "                for (int i = 0; i < (1 << LEVEL1_BITS); i += 2) {\n                    level1[i] = 1 << 16 | symbol1;\n                    level1[i + 1] = 1 << 16 | symbol2;\n                }\n            } else {\n                Arrays.fill(level1, symbol1);\n            }\n        } else {\n            // code lengths also huffman coded\n            // first read the \"first stage\" code lengths\n            // In the following this is called the L-Code (for length code)\n            int numLCodeLengths = (int) (lsbBitReader.readBits(4) + 4);\n            short[] lCodeLengths = new short[L_CODE_ORDER.length];\n            int numPosCodeLens = 0;\n", "            for (int i = 0; i < numLCodeLengths; i++) {\n                short len = (short) lsbBitReader.readBits(3);\n                lCodeLengths[L_CODE_ORDER[i]] = len;\n\n                if (len > 0) {\n                    numPosCodeLens++;\n                }\n            }\n\n            // Use L-Code to read the actual code lengths\n            short[] codeLengths = readCodeLengths(lsbBitReader, lCodeLengths, alphabetSize, numPosCodeLens);\n\n            buildFromLengths(codeLengths);\n        }\n    }\n\n    /**\n     * Builds a Huffman table by using already given code lengths to generate the codes from\n     *\n     * @param codeLengths    the array specifying the bit length of the code for a symbol (i.e. {@code codeLengths[i]}\n     *                       is the bit length of the code for the symbol i)\n     * @param numPosCodeLens the number of positive (i.e. non-zero) codeLengths in the array (allows more efficient\n     *                       table generation)\n     */\n    private HuffmanTable(short[] codeLengths, int numPosCodeLens) {\n        buildFromLengths(codeLengths, numPosCodeLens);\n    }\n\n    // Helper methods to allow reusing in different constructors\n    private void buildFromLengths(short[] codeLengths) {\n        int numPosCodeLens = 0;\n", "        for (short codeLength : codeLengths) {\n            if (codeLength != 0) {\n                numPosCodeLens++;\n            }\n        }\n\n        buildFromLengths(codeLengths, numPosCodeLens);\n    }\n\n    private void buildFromLengths(short[] codeLengths, int numPosCodeLens) {\n        // Pack code length and corresponding symbols as described above\n        int[] lengthsAndSymbols = new int[numPosCodeLens];\n\n        int index = 0;", "        for (int i = 0; i < codeLengths.length; i++) {\n            if (codeLengths[i] != 0) {\n                lengthsAndSymbols[index++] = codeLengths[i] << 16 | i;\n            }\n        }\n\n        // Special case: Only 1 code value\n        if (numPosCodeLens == 1) {\n            // Length is 0 so mask to clear length bits\n            Arrays.fill(level1, lengthsAndSymbols[0] & 0xffff);\n        }\n\n        // Due to the layout of the elements this effectively first sorts by length and then symbol.\n        Arrays.sort(lengthsAndSymbols);\n\n        // The next code, in the bit order it would appear on the input stream, i.e. it is reversed.\n        // Only the lowest bits (corresponding to the bit length of the code) are considered.\n        // Example: code 0..010 (length 2) would appear as 0..001.\n        int code = 0;\n\n        // Used for level2 lookup\n        int rootEntry = -1;\n        int[] currentTable = null;\n", "        for (int i = 0; i < lengthsAndSymbols.length; i++) {\n            int lengthAndSymbol = lengthsAndSymbols[i];\n\n            int length = lengthAndSymbol >>> 16;\n\n            if (length <= LEVEL1_BITS) {\n                for (int j = code; j < level1.length; j += 1 << length) {\n                    level1[j] = lengthAndSymbol;\n                }\n            } else {\n                // Existing level2 table not fitting", "                if ((code & ((1 << LEVEL1_BITS) - 1)) != rootEntry) {\n                    // Figure out needed table size.\n                    // Start at current symbol and length.\n                    // Every symbol uses 1 slot at the current bit length.\n                    // Going up 1 bit in length multiplies the slots by 2.\n                    // No more open slots indicate the table size to be big enough.\n                    int maxLength = length;\n\n                    for (int j = i, openSlots = 1 << (length - LEVEL1_BITS);\n                         j < lengthsAndSymbols.length && openSlots > 0;\n                         j++, openSlots--) {\n\n                        int innerLength = lengthsAndSymbols[j] >>> 16;\n", "                    for (int j = i, openSlots = 1 << (length - LEVEL1_BITS);\n                         j < lengthsAndSymbols.length && openSlots > 0;\n                         j++, openSlots--) {\n\n                        int innerLength = lengthsAndSymbols[j] >>> 16;\n\n                        while (innerLength != maxLength) {\n                            maxLength++;\n                            openSlots <<= 1;\n                        }\n                    }\n\n                    int level2Size = maxLength - LEVEL1_BITS;\n\n                    currentTable = new int[1 << level2Size];\n                    rootEntry = code & ((1 << LEVEL1_BITS) - 1);\n                    level2.add(currentTable);\n\n                    // Set root table indirection\n                    level1[rootEntry] = (LEVEL1_BITS + level2Size) << 16 | (level2.size() - 1);\n                }\n\n                // Add to existing (or newly generated) 2nd level table", "                for (int j = (code >>> LEVEL1_BITS); j < currentTable.length; j += 1 << (length - LEVEL1_BITS)) {\n                    currentTable[j] = (length - LEVEL1_BITS) << 16 | (lengthAndSymbol & 0xffff);\n                }\n            }\n\n            code = nextCode(code, length);\n\n        }\n    }\n\n    /**\n     * Computes the next code\n     *\n     * @param code   the current code\n     * @param length the currently valid length\n     * @return {@code reverse(reverse(code, length) + 1, length)} where {@code reverse(a, b)} is the lowest b bits of\n     * a in inverted order\n     */\n    private int nextCode(int code, int length) {\n        int a = (~code) & ((1 << length) - 1);\n\n        // This will result in the highest 0-bit in the lower length bits of code set (by construction of a)\n        // I.e. the lowest 0-bit in the value code represents\n        int step = Integer.highestOneBit(a);\n\n        // In the represented value this clears the consecutive 1-bits starting at bit 0 and then sets the lowest 0 bit\n        // This corresponds to adding 1 to the value\n        return (code & (step - 1)) | step;\n    }\n\n    private static short[] readCodeLengths(LSBBitInputStream lsbBitReader, short[] aCodeLengths, int alphabetSize,\n                                           int numPosCodeLens) throws IOException {\n\n        HuffmanTable huffmanTable = new HuffmanTable(aCodeLengths, numPosCodeLens);\n\n        // Not sure where this comes from. Just adapted from the libwebp implementation\n        int codedSymbols;", "        if (lsbBitReader.readBit() == 1) {\n            int maxSymbolBitLength = (int) (2 + 2 * lsbBitReader.readBits(3));\n            codedSymbols = (int) (2 + lsbBitReader.readBits(maxSymbolBitLength));\n        } else {\n            codedSymbols = alphabetSize;\n        }\n\n        short[] codeLengths = new short[alphabetSize];\n\n        // Default code for repeating\n        short prevLength = 8;\n", "        for (int i = 0; i < alphabetSize && codedSymbols > 0; i++, codedSymbols--) {\n            short len = huffmanTable.readSymbol(lsbBitReader);\n\n            if (len < 16) { // Literal length\n                codeLengths[i] = len;\n                if (len != 0) {\n                    prevLength = len;\n                }\n            } else {\n                short repeatSymbol = 0;\n                int extraBits;\n                int repeatOffset;\n\n                switch (len) {\n                    case 16: // Repeat previous\n                        repeatSymbol = prevLength;\n                        extraBits = 2;\n                        repeatOffset = 3;\n                        break;\n                    case 17: // Repeat 0 short\n                        extraBits = 3;\n                        repeatOffset = 3;\n                        break;\n                    case 18: // Repeat 0 long\n                        extraBits = 7;\n                        repeatOffset = 11;\n                        break;\n                    default:\n                        throw new IOException(\"Huffman: Unreachable: Decoded Code Length > 18.\");\n                }\n\n                int repeatCount = (int) (lsbBitReader.readBits(extraBits) + repeatOffset);\n", "                if (i + repeatCount > alphabetSize) {\n                    throw new IOException(\n                            String.format(\n                                    \"Huffman: Code length repeat count overflows alphabet: Start index: %d, count: \" +\n                                            \"%d, alphabet size: %d\", i, repeatCount, alphabetSize)\n                    );\n                }\n\n                Arrays.fill(codeLengths, i, i + repeatCount, repeatSymbol);\n                i += repeatCount - 1;\n            }\n        }\n\n        return codeLengths;\n    }\n\n    /**\n     * Reads the next code symbol from the streaming and decode it using the Huffman table\n     *\n     * @param lsbBitReader the reader to read a symbol from (will be advanced accordingly)\n     * @return the decoded symbol\n     * @throws IOException when the reader throws one reading a symbol\n     */", "    public short readSymbol(LSBBitInputStream lsbBitReader) throws IOException {\n        int index = (int) lsbBitReader.peekBits(LEVEL1_BITS);\n        int lengthAndSymbol = level1[index];\n\n        int length = lengthAndSymbol >>> 16;\n\n        if (length > LEVEL1_BITS) {\n            // Lvl2 lookup\n            lsbBitReader.readBits(LEVEL1_BITS); // Consume bits of first level\n            int level2Index = (int) lsbBitReader.peekBits(length - LEVEL1_BITS); // Peek remaining required bits\n            lengthAndSymbol = level2.get(lengthAndSymbol & 0xffff)[level2Index];\n            length = lengthAndSymbol >>> 16;\n        }\n\n        lsbBitReader.readBits(length); // Consume bits\n\n        return (short) (lengthAndSymbol & 0xffff);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/huffman/HuffmanInfo.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.huffman;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class HuffmanInfo {\n    public final RGBABuffer huffmanMetaCodes; // Raster allows intuitive lookup by x and y\n\n    public final int metaCodeBits;\n", "    public final int metaCodeBits;\n\n    public final HuffmanCodeGroup[] huffmanGroups;\n\n    public HuffmanInfo(RGBABuffer huffmanMetaCodes, int metaCodeBits, HuffmanCodeGroup[] huffmanGroups) {\n        this.huffmanMetaCodes = huffmanMetaCodes;\n        this.metaCodeBits = metaCodeBits;\n        this.huffmanGroups = huffmanGroups;\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/colorcache/ColorCache.java", "chunked_list": ["/*\n * Copyright (c) 2017, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.colorcache;\n\n/**", "\n/**\n * ColorCache.\n *\n * @author <a href=\"mailto:harald.kuhr@gmail.com\">Harald Kuhr</a>\n */\npublic final class ColorCache {\n    private final int[] colors;   // Color entries\n    private final int hashShift;  // Hash shift: 32 - hashBits.\n\n    private static final long K_HASH_MUL = 0x1e35a7bdL;\n\n    public ColorCache(final int hashBits) {\n        assert hashBits > 0 : \"hasBits must > 0\";\n\n        int hashSize = 1 << hashBits;\n\n        colors = new int[hashSize];\n        hashShift = 32 - hashBits;\n    }\n", "    public int lookup(final int key) {\n        return colors[key];\n    }\n\n    public void insert(final int argb) {\n        colors[hashPix(argb, hashShift)] = argb;\n    }\n\n    private static int hashPix(final int argb, final int shift) {\n        return (int) (((argb * K_HASH_MUL) & 0xffffffffL) >> shift);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/transform/Transform.java", "chunked_list": ["/*\n * Copyright (c) 2017, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.transform;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * Transform.\n *\n * @author <a href=\"mailto:harald.kuhr@gmail.com\">Harald Kuhr</a>\n */\npublic interface Transform {\n    void apply(RGBABuffer raster);\n}\n", "public interface Transform {\n    void apply(RGBABuffer raster);\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/transform/SubtractGreenTransform.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.transform;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class SubtractGreenTransform implements Transform {\n    @Override\n    public void apply(RGBABuffer raster) {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        byte[] rgba = new byte[4];\n", "    public void apply(RGBABuffer raster) {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        byte[] rgba = new byte[4];\n\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                raster.getDataElements(x, y, rgba);\n                addGreenToBlueAndRed(rgba);\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n\n    private static void addGreenToBlueAndRed(byte[] rgb) {\n        rgb[0] = (byte) ((rgb[0] + rgb[1]) & 0xff);\n        rgb[2] = (byte) ((rgb[2] + rgb[1]) & 0xff);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/transform/PredictorTransform.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.transform;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class PredictorTransform implements Transform {\n    // Special rules:\n    // Top-left pixel of image is predicted BLACK\n    // Rest of top pixels is predicted L\n    // Rest of leftmost pixels are predicted T\n    // Rightmost pixels using TR, uses LEFTMOST pixel on SAME ROW (same distance as TR in memory!)\n\n    private static final int PREDICTOR_BLACK = 0; // 0xff000000 (represents solid black color in ARGB)\n    private static final int PREDICTOR_L = 1; // L\n    private static final int PREDICTOR_T = 2; // T\n    private static final int PREDICTOR_TR = 3; // TR\n    private static final int PREDICTOR_TL = 4; // TL\n    private static final int PREDICTOR_AVG_L_TR_T = 5; // Average2(Average2(L, TR), T)\n    private static final int PREDICTOR_AVG_L_TL = 6; // Average2(L, TL)\n    private static final int PREDICTOR_AVG_L_T = 7; // Average2(L, T)\n    private static final int PREDICTOR_AVG_TL_T = 8; // Average2(TL, T)\n    private static final int PREDICTOR_AVG_T_TR = 9; // Average2(T, TR)\n    private static final int PREDICTOR_AVG_L_TL_T_TR = 10; // Average2(Average2(L, TL), Average2(T, TR))\n    private static final int PREDICTOR_SELECT = 11; // Select(L, T, TL)\n    private static final int PREDICTOR_CLAMP_ADD_SUB_FULL = 12; // ClampAddSubtractFull(L, T, TL)\n    private static final int PREDICTOR_CLAMP_ADD_SUB_HALF = 13; // ClampAddSubtractHalf(Average2(L, T), TL)\n\n    private final RGBABuffer data;\n    private final byte bits;\n\n    public PredictorTransform(RGBABuffer raster, byte bits) {\n        this.data = raster;\n        this.bits = bits;\n    }\n\n    @Override", "    public void apply(RGBABuffer raster) {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        byte[] rgba = new byte[4];\n\n        // Handle top and left border separately\n\n        // (0,0) Black (0x000000ff) predict\n        raster.getDataElements(0, 0, rgba);\n        rgba[3] += 0xff;\n        raster.setDataElements(0, 0, rgba);\n\n        byte[] predictor = new byte[4];\n        byte[] predictor2 = new byte[4];\n        byte[] predictor3 = new byte[4];\n\n        // (x,0) L predict", "        for (int x = 1; x < width; x++) {\n            raster.getDataElements(x, 0, rgba);\n            raster.getDataElements(x - 1, 0, predictor);\n            addPixels(rgba, predictor);\n            raster.setDataElements(x, 0, rgba);\n        }\n\n        // (0,y) T predict\n        for (int y = 1; y < height; y++) {\n            raster.getDataElements(0, y, rgba);\n            raster.getDataElements(0, y - 1, predictor);\n            addPixels(rgba, predictor);\n            raster.setDataElements(0, y, rgba);\n        }\n", "        for (int y = 1; y < height; y++) {\n            raster.getDataElements(0, y, rgba);\n            raster.getDataElements(0, y - 1, predictor);\n            addPixels(rgba, predictor);\n            raster.setDataElements(0, y, rgba);\n        }\n\n        for (int y = 1; y < height; y++) {\n            for (int x = 1; x < width; x++) {\n                int transformType = data.getSample(x >> bits, y >> bits, 1);\n                raster.getDataElements(x, y, rgba);\n\n                int lX = x - 1; // x for left\n                int tY = y - 1; // y for top\n\n                // top right is not (x+1, tY) if last pixel in line instead (0, y)\n                int trX = x == width - 1 ? 0 : x + 1;\n                int trY = x == width - 1 ? y : tY;\n\n                switch (transformType) {\n                    case PREDICTOR_BLACK:\n                        rgba[3] += 0xff;\n                        break;\n                    case PREDICTOR_L:\n                        raster.getDataElements(lX, y, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_T:\n                        raster.getDataElements(x, tY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_TR:\n                        raster.getDataElements(trX, trY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_TL:\n                        raster.getDataElements(lX, tY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TR_T:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(trX, trY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_T:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_TL_T:\n                        raster.getDataElements(lX, tY, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_T_TR:\n                        raster.getDataElements(x, tY, predictor);\n                        raster.getDataElements(trX, trY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TL_T_TR:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(trX, trY, predictor3);\n                        average2(predictor2, predictor3);\n\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_SELECT:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n\n\n                        addPixels(rgba, select(predictor, predictor2, predictor3));\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_FULL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n                        clampAddSubtractFull(predictor, predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_HALF:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(lX, tY, predictor2);\n                        clampAddSubtractHalf(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n\n                }\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n\n    private static byte[] select(final byte[] l, final byte[] t, final byte[] tl) {\n        // l = left pixel, t = top pixel, tl = top left pixel.\n\n        // ARGB component estimates for prediction.\n\n        int pAlpha = addSubtractFull(l[3], t[3], tl[3]);\n        int pRed = addSubtractFull(l[0], t[0], tl[0]);\n        int pGreen = addSubtractFull(l[1], t[1], tl[1]);\n        int pBlue = addSubtractFull(l[2], t[2], tl[2]);\n\n        // Manhattan distances to estimates for left and top pixels.\n        int pL = manhattanDistance(l, pAlpha, pRed, pGreen, pBlue);\n        int pT = manhattanDistance(t, pAlpha, pRed, pGreen, pBlue);\n\n        // Return either left or top, the one closer to the prediction.\n        return pL < pT ? l : t;\n    }\n\n    private static int manhattanDistance(byte[] rgba, int pAlpha, int pRed, int pGreen, int pBlue) {\n        return Math.abs(pAlpha - (rgba[3] & 0xff)) + Math.abs(pRed - (rgba[0] & 0xff)) +\n                Math.abs(pGreen - (rgba[1] & 0xff)) + Math.abs(pBlue - (rgba[2] & 0xff));\n    }\n\n    private static void average2(final byte[] rgba1, final byte[] rgba2) {\n        rgba1[0] = (byte) (((rgba1[0] & 0xff) + (rgba2[0] & 0xff)) / 2);\n        rgba1[1] = (byte) (((rgba1[1] & 0xff) + (rgba2[1] & 0xff)) / 2);\n        rgba1[2] = (byte) (((rgba1[2] & 0xff) + (rgba2[2] & 0xff)) / 2);\n        rgba1[3] = (byte) (((rgba1[3] & 0xff) + (rgba2[3] & 0xff)) / 2);\n    }\n\n    // Clamp the input value between 0 and 255.\n    private static int clamp(final int a) {\n        return Math.max(0, Math.min(a, 255));\n    }\n\n    private static void clampAddSubtractFull(final byte[] a, final byte[] b, final byte[] c) {\n        a[0] = (byte) clamp(addSubtractFull(a[0], b[0], c[0]));\n        a[1] = (byte) clamp(addSubtractFull(a[1], b[1], c[1]));\n        a[2] = (byte) clamp(addSubtractFull(a[2], b[2], c[2]));\n        a[3] = (byte) clamp(addSubtractFull(a[3], b[3], c[3]));\n    }\n\n    private static void clampAddSubtractHalf(final byte[] a, final byte[] b) {\n        a[0] = (byte) clamp(addSubtractHalf(a[0], b[0]));\n        a[1] = (byte) clamp(addSubtractHalf(a[1], b[1]));\n        a[2] = (byte) clamp(addSubtractHalf(a[2], b[2]));\n        a[3] = (byte) clamp(addSubtractHalf(a[3], b[3]));\n    }\n\n    private static int addSubtractFull(byte a, byte b, byte c) {\n        return (a & 0xff) + (b & 0xff) - (c & 0xff);\n    }\n\n    private static int addSubtractHalf(byte a, byte b) {\n        return (a & 0xff) + ((a & 0xff) - (b & 0xff)) / 2;\n    }\n\n    private static void addPixels(byte[] rgba, byte[] predictor) {\n        rgba[0] += predictor[0];\n        rgba[1] += predictor[1];\n        rgba[2] += predictor[2];\n        rgba[3] += predictor[3];\n    }\n}\n", "            for (int x = 1; x < width; x++) {\n                int transformType = data.getSample(x >> bits, y >> bits, 1);\n                raster.getDataElements(x, y, rgba);\n\n                int lX = x - 1; // x for left\n                int tY = y - 1; // y for top\n\n                // top right is not (x+1, tY) if last pixel in line instead (0, y)\n                int trX = x == width - 1 ? 0 : x + 1;\n                int trY = x == width - 1 ? y : tY;\n\n                switch (transformType) {\n                    case PREDICTOR_BLACK:\n                        rgba[3] += 0xff;\n                        break;\n                    case PREDICTOR_L:\n                        raster.getDataElements(lX, y, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_T:\n                        raster.getDataElements(x, tY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_TR:\n                        raster.getDataElements(trX, trY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_TL:\n                        raster.getDataElements(lX, tY, predictor);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TR_T:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(trX, trY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_T:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_TL_T:\n                        raster.getDataElements(lX, tY, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_T_TR:\n                        raster.getDataElements(x, tY, predictor);\n                        raster.getDataElements(trX, trY, predictor2);\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TL_T_TR:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(trX, trY, predictor3);\n                        average2(predictor2, predictor3);\n\n                        average2(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_SELECT:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n\n\n                        addPixels(rgba, select(predictor, predictor2, predictor3));\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_FULL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n                        clampAddSubtractFull(predictor, predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_HALF:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n                        raster.getDataElements(lX, tY, predictor2);\n                        clampAddSubtractHalf(predictor, predictor2);\n\n                        addPixels(rgba, predictor);\n                        break;\n\n                }\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n\n    private static byte[] select(final byte[] l, final byte[] t, final byte[] tl) {\n        // l = left pixel, t = top pixel, tl = top left pixel.\n\n        // ARGB component estimates for prediction.\n\n        int pAlpha = addSubtractFull(l[3], t[3], tl[3]);\n        int pRed = addSubtractFull(l[0], t[0], tl[0]);\n        int pGreen = addSubtractFull(l[1], t[1], tl[1]);\n        int pBlue = addSubtractFull(l[2], t[2], tl[2]);\n\n        // Manhattan distances to estimates for left and top pixels.\n        int pL = manhattanDistance(l, pAlpha, pRed, pGreen, pBlue);\n        int pT = manhattanDistance(t, pAlpha, pRed, pGreen, pBlue);\n\n        // Return either left or top, the one closer to the prediction.\n        return pL < pT ? l : t;\n    }\n\n    private static int manhattanDistance(byte[] rgba, int pAlpha, int pRed, int pGreen, int pBlue) {\n        return Math.abs(pAlpha - (rgba[3] & 0xff)) + Math.abs(pRed - (rgba[0] & 0xff)) +\n                Math.abs(pGreen - (rgba[1] & 0xff)) + Math.abs(pBlue - (rgba[2] & 0xff));\n    }\n\n    private static void average2(final byte[] rgba1, final byte[] rgba2) {\n        rgba1[0] = (byte) (((rgba1[0] & 0xff) + (rgba2[0] & 0xff)) / 2);\n        rgba1[1] = (byte) (((rgba1[1] & 0xff) + (rgba2[1] & 0xff)) / 2);\n        rgba1[2] = (byte) (((rgba1[2] & 0xff) + (rgba2[2] & 0xff)) / 2);\n        rgba1[3] = (byte) (((rgba1[3] & 0xff) + (rgba2[3] & 0xff)) / 2);\n    }\n\n    // Clamp the input value between 0 and 255.\n    private static int clamp(final int a) {\n        return Math.max(0, Math.min(a, 255));\n    }\n\n    private static void clampAddSubtractFull(final byte[] a, final byte[] b, final byte[] c) {\n        a[0] = (byte) clamp(addSubtractFull(a[0], b[0], c[0]));\n        a[1] = (byte) clamp(addSubtractFull(a[1], b[1], c[1]));\n        a[2] = (byte) clamp(addSubtractFull(a[2], b[2], c[2]));\n        a[3] = (byte) clamp(addSubtractFull(a[3], b[3], c[3]));\n    }\n\n    private static void clampAddSubtractHalf(final byte[] a, final byte[] b) {\n        a[0] = (byte) clamp(addSubtractHalf(a[0], b[0]));\n        a[1] = (byte) clamp(addSubtractHalf(a[1], b[1]));\n        a[2] = (byte) clamp(addSubtractHalf(a[2], b[2]));\n        a[3] = (byte) clamp(addSubtractHalf(a[3], b[3]));\n    }\n\n    private static int addSubtractFull(byte a, byte b, byte c) {\n        return (a & 0xff) + (b & 0xff) - (c & 0xff);\n    }\n\n    private static int addSubtractHalf(byte a, byte b) {\n        return (a & 0xff) + ((a & 0xff) - (b & 0xff)) / 2;\n    }\n\n    private static void addPixels(byte[] rgba, byte[] predictor) {\n        rgba[0] += predictor[0];\n        rgba[1] += predictor[1];\n        rgba[2] += predictor[2];\n        rgba[3] += predictor[3];\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/transform/ColorTransform.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.transform;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class ColorTransform implements Transform {\n    private final RGBABuffer data;\n    private final byte bits;\n\n    public ColorTransform(RGBABuffer raster, byte bits) {\n        this.data = raster;\n        this.bits = bits;\n    }\n\n    @Override", "    public void apply(RGBABuffer raster) {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        byte[] rgba = new byte[4];\n\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                data.getDataElements(x >> bits, y >> bits, rgba);\n                int green_to_red = rgba[2];\n                int green_to_blue = rgba[1];\n                int red_to_blue = rgba[0];\n                raster.getDataElements(x, y, rgba);\n\n                int tmp_red = rgba[0];\n                int tmp_blue = rgba[2];\n\n                tmp_red += colorTransformDelta((byte) green_to_red, rgba[1]);\n                tmp_blue += colorTransformDelta((byte) green_to_blue, rgba[1]);\n                tmp_blue += colorTransformDelta((byte) red_to_blue, (byte) tmp_red); // Spec has red & 0xff\n\n                rgba[0] = (byte) (tmp_red & 0xff);\n                rgba[2] = (byte) (tmp_blue & 0xff);\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n\n    // A conversion from the 8-bit unsigned representation (uint8) to the 8-bit\n    // signed one (int8) is required before calling ColorTransformDelta(). It\n    // should be performed using 8-bit two's complement (that is: uint8 range\n    // [128-255] is mapped to the [-128, -1] range of its converted int8\n    // value).\n    private static byte colorTransformDelta(final byte t, final byte c) {\n        return (byte) ((t * c) >> 5);\n    }\n}\n"]}
{"filename": "src/main/java/net/burningtnt/webp/vp8l/transform/ColorIndexingTransform.java", "chunked_list": ["/*\n * Copyright (c) 2022, Harald Kuhr\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *", " *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *", " *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage net.burningtnt.webp.vp8l.transform;\n\nimport net.burningtnt.webp.utils.RGBABuffer;", "\nimport net.burningtnt.webp.utils.RGBABuffer;\n\n/**\n * @author Simon Kammermeier\n */\npublic final class ColorIndexingTransform implements Transform {\n    private final byte[] colorTable;\n    private final byte bits;\n\n    public ColorIndexingTransform(byte[] colorTable, byte bits) {\n        this.colorTable = colorTable;\n        this.bits = bits;\n    }\n\n    @Override", "    public void apply(RGBABuffer raster) {\n        int width = raster.getWidth();\n        int height = raster.getHeight();\n\n        byte[] rgba = new byte[4];\n\n        for (int y = 0; y < height; y++) {\n            // Reversed so no used elements are overridden (in case of packing)\n            for (int x = width - 1; x >= 0; x--) {\n                int componentSize = 8 >> bits;\n                int packed = 1 << bits;\n                int xC = x / packed;\n                int componentOffset = componentSize * (x % packed);\n\n                int sample = raster.getSample(xC, y, 1);\n\n                int index = sample >> componentOffset & ((1 << componentSize) - 1);\n\n                System.arraycopy(colorTable, index * 4, rgba, 0, 4);\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n}\n", "            for (int x = width - 1; x >= 0; x--) {\n                int componentSize = 8 >> bits;\n                int packed = 1 << bits;\n                int xC = x / packed;\n                int componentOffset = componentSize * (x % packed);\n\n                int sample = raster.getSample(xC, y, 1);\n\n                int index = sample >> componentOffset & ((1 << componentSize) - 1);\n\n                System.arraycopy(colorTable, index * 4, rgba, 0, 4);\n                raster.setDataElements(x, y, rgba);\n            }\n        }\n    }\n}\n"]}
