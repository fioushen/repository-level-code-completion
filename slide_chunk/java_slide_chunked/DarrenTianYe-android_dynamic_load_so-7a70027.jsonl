{"filename": "lib_sillyboy/src/test/java/com/example/lib_sillyboy/ExampleUnitTest.java", "chunked_list": ["package com.example.lib_sillyboy;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>", " *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() {\n        assertEquals(4, 2 + 2);\n    }\n}"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/DynamicSo.java", "chunked_list": ["package com.example.lib_sillyboy;\n\nimport android.content.Context;\n\nimport com.example.lib_sillyboy.elf.ElfParser;\nimport com.example.lib_sillyboy.tinker.TinkerLoadLibrary;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;", "import java.io.IOException;\nimport java.util.List;\n\n\npublic class DynamicSo {\n    public static void loadStaticSo(File soFIle, String path) {\n        try {\n            ElfParser parser = null;\n            final List<String> dependencies;\n            try {\n                parser = new ElfParser(soFIle);\n                dependencies = parser.parseNeededDependencies();\n            } finally {", "            try {\n                parser = new ElfParser(soFIle);\n                dependencies = parser.parseNeededDependencies();\n            } finally {\n                if (parser != null) {\n                    parser.close();\n                }\n            }\n            //\u5982\u679cnativecpp3->nativecpptwo->nativecpp \u5219\u5148\u52a0\u8f7d DynamicSo.loadStaticSo(nativecpptwo)\uff0c\u6b64\u65f6nativecpp\u4f5c\u4e3anativecpptwo\u7684\u76f4\u63a5\u4f9d\u8d56\u88ab\u52a0\u8f7d\u4e86\n            //\u4e0d\u80fd\u76f4\u63a5\u52a0\u8f7dnativecpp3\uff0c\u5bfc\u81f4\u52a0\u8f7d\u76f4\u63a5\u4f9d\u8d56nativetwo\u7684\u65f6\u5019nativecpp\u6ca1\u52a0\u8f7d\u5bfc\u81f4\u9519\u8bef\u3002 \u8fd9\u4e2a\u53ef\u4ee5\u4f18\u5316\uff0c\u6bd4\u5982\u9012\u5f52\n            for (final String dependency : dependencies) {\n", "            for (final String dependency : dependencies) {\n\n                try {\n                    File file = new File(path + dependency);\n                    if (file.exists()) {\n                        //\u9012\u5f52\u67e5\u627e\n                        loadStaticSo(file, path);\n                    } else {\n                        // so\u6587\u4ef6\u4e0d\u5b58\u5728\u8fd9\u4e2a\u6587\u4ef6\u5939\uff0c\u4ee3\u8868\u662fndk\u4e2d\u7684so\uff0c\u5982liblog.so\uff0c\u5219\u76f4\u63a5\u52a0\u8f7d\n                        // \u628a\u672c\u6765lib\u524d\u7f00\u548c.so\u540e\u7f00\u53bb\u6389\u5373\u53ef\n                        String dependencySo = dependency.substring(3, dependency.length() - 3);\n                        //\u5728application\u5df2\u7ecf\u6ce8\u5165\u4e86\u8def\u5f84DynamicSo.insertPathToNativeSystem(this,file) \u6240\u4ee5\u91c7\u7528\u7cfb\u7edf\u7684\u52a0\u8f7d\u5c31\u884c\n                        System.loadLibrary(dependencySo);\n                    }\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n            }\n        } catch (IOException ignored) {\n        }\n        // \u5148\u628a\u4f9d\u8d56\u9879\u52a0\u8f7d\u5b8c\uff0c\u518d\u52a0\u8f7d\u672c\u8eab\n        System.loadLibrary(soFIle.getName().substring(3, soFIle.getName().length() - 3));\n    }\n", "    public static void insertPathToNativeSystem(Context context,File file){\n        try {\n            TinkerLoadLibrary.installNativeLibraryPath(context.getClassLoader(), file);\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/tinker/ShareReflectUtil.java", "chunked_list": ["package com.example.lib_sillyboy.tinker;\n\nimport android.content.Context;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\npublic class ShareReflectUtil {\n\n    /**\n     * Locates a given field anywhere in the class inheritance hierarchy.\n     *\n     * @param instance an object to search the field into.\n     * @param name     field name\n     * @return a field object\n     * @throws NoSuchFieldException if the field cannot be located\n     */", "import java.util.Arrays;\n\npublic class ShareReflectUtil {\n\n    /**\n     * Locates a given field anywhere in the class inheritance hierarchy.\n     *\n     * @param instance an object to search the field into.\n     * @param name     field name\n     * @return a field object\n     * @throws NoSuchFieldException if the field cannot be located\n     */", "    public static Field findField(Object instance, String name) throws NoSuchFieldException {\n        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {\n            try {\n                Field field = clazz.getDeclaredField(name);\n\n                if (!field.isAccessible()) {\n                    field.setAccessible(true);\n                }\n\n                return field;\n            } catch (NoSuchFieldException e) {\n                // ignore and search next\n            }\n        }\n\n        throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + instance.getClass());\n    }\n", "    public static Field findField(Class<?> originClazz, String name) throws NoSuchFieldException {\n        for (Class<?> clazz = originClazz; clazz != null; clazz = clazz.getSuperclass()) {\n            try {\n                Field field = clazz.getDeclaredField(name);\n\n                if (!field.isAccessible()) {\n                    field.setAccessible(true);\n                }\n\n                return field;\n            } catch (NoSuchFieldException e) {\n                // ignore and search next\n            }\n        }\n\n        throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + originClazz);\n    }\n\n    /**\n     * Locates a given method anywhere in the class inheritance hierarchy.\n     *\n     * @param instance       an object to search the method into.\n     * @param name           method name\n     * @param parameterTypes method parameter types\n     * @return a method object\n     * @throws NoSuchMethodException if the method cannot be located\n     */", "    public static Method findMethod(Object instance, String name, Class<?>... parameterTypes)\n        throws NoSuchMethodException {\n        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {\n            try {\n                Method method = clazz.getDeclaredMethod(name, parameterTypes);\n\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n\n                return method;\n            } catch (NoSuchMethodException e) {\n                // ignore and search next\n            }\n        }\n\n        throw new NoSuchMethodException(\"Method \"\n            + name\n            + \" with parameters \"\n            + Arrays.asList(parameterTypes)\n            + \" not found in \" + instance.getClass());\n    }\n\n    /**\n     * Locates a given method anywhere in the class inheritance hierarchy.\n     *\n     * @param clazz          a class to search the method into.\n     * @param name           method name\n     * @param parameterTypes method parameter types\n     * @return a method object\n     * @throws NoSuchMethodException if the method cannot be located\n     */", "    public static Method findMethod(Class<?> clazz, String name, Class<?>... parameterTypes)\n            throws NoSuchMethodException {\n        for (; clazz != null; clazz = clazz.getSuperclass()) {\n            try {\n                Method method = clazz.getDeclaredMethod(name, parameterTypes);\n\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n\n                return method;\n            } catch (NoSuchMethodException e) {\n                // ignore and search next\n            }\n        }\n\n        throw new NoSuchMethodException(\"Method \"\n                + name\n                + \" with parameters \"\n                + Arrays.asList(parameterTypes)\n                + \" not found in \" + clazz);\n    }\n\n    /**\n     * Locates a given constructor anywhere in the class inheritance hierarchy.\n     *\n     * @param instance       an object to search the constructor into.\n     * @param parameterTypes constructor parameter types\n     * @return a constructor object\n     * @throws NoSuchMethodException if the constructor cannot be located\n     */", "    public static Constructor<?> findConstructor(Object instance, Class<?>... parameterTypes)\n            throws NoSuchMethodException {\n        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {\n            try {\n                Constructor<?> ctor = clazz.getDeclaredConstructor(parameterTypes);\n\n                if (!ctor.isAccessible()) {\n                    ctor.setAccessible(true);\n                }\n\n                return ctor;\n            } catch (NoSuchMethodException e) {\n                // ignore and search next\n            }\n        }\n\n        throw new NoSuchMethodException(\"Constructor\"\n                + \" with parameters \"\n                + Arrays.asList(parameterTypes)\n                + \" not found in \" + instance.getClass());\n    }\n\n    /**\n     * Replace the value of a field containing a non null array, by a new array containing the\n     * elements of the original array plus the elements of extraElements.\n     *\n     * @param instance      the instance whose field is to be modified.\n     * @param fieldName     the field to modify.\n     * @param extraElements elements to append at the end of the array.\n     */", "    public static void expandFieldArray(Object instance, String fieldName, Object[] extraElements)\n        throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {\n        Field jlrField = findField(instance, fieldName);\n\n        Object[] original = (Object[]) jlrField.get(instance);\n        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length);\n\n        // NOTE: changed to copy extraElements first, for patch load first\n\n        System.arraycopy(extraElements, 0, combined, 0, extraElements.length);\n        System.arraycopy(original, 0, combined, extraElements.length, original.length);\n\n        jlrField.set(instance, combined);\n    }\n\n    /**\n     * Replace the value of a field containing a non null array, by a new array containing the\n     * elements of the original array plus the elements of extraElements.\n     *\n     * @param instance      the instance whose field is to be modified.\n     * @param fieldName     the field to modify.\n     */", "    public static void reduceFieldArray(Object instance, String fieldName, int reduceSize)\n        throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {\n        if (reduceSize <= 0) {\n            return;\n        }\n\n        Field jlrField = findField(instance, fieldName);\n\n        Object[] original = (Object[]) jlrField.get(instance);\n        int finalLength = original.length - reduceSize;\n", "        if (finalLength <= 0) {\n            return;\n        }\n\n        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), finalLength);\n\n        System.arraycopy(original, reduceSize, combined, 0, finalLength);\n\n        jlrField.set(instance, combined);\n    }\n", "    public static Object getActivityThread(Context context,\n                                           Class<?> activityThread) {\n        try {\n            if (activityThread == null) {\n                activityThread = Class.forName(\"android.app.ActivityThread\");\n            }\n            Method m = activityThread.getMethod(\"currentActivityThread\");\n            m.setAccessible(true);\n            Object currentActivityThread = m.invoke(null);\n            if (currentActivityThread == null && context != null) {\n                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)\n                // the currentActivityThread was built on thread locals, so we'll need to try\n                // even harder\n                Field mLoadedApk = context.getClass().getField(\"mLoadedApk\");\n                mLoadedApk.setAccessible(true);\n                Object apk = mLoadedApk.get(context);\n                Field mActivityThreadField = apk.getClass().getDeclaredField(\"mActivityThread\");\n                mActivityThreadField.setAccessible(true);\n                currentActivityThread = mActivityThreadField.get(apk);\n            }\n            return currentActivityThread;\n        } catch (Throwable ignore) {\n            return null;\n        }\n    }\n\n    /**\n     * Handy method for fetching hidden integer constant value in system classes.\n     *\n     * @param clazz\n     * @param fieldName\n     * @return\n     */", "            if (currentActivityThread == null && context != null) {\n                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)\n                // the currentActivityThread was built on thread locals, so we'll need to try\n                // even harder\n                Field mLoadedApk = context.getClass().getField(\"mLoadedApk\");\n                mLoadedApk.setAccessible(true);\n                Object apk = mLoadedApk.get(context);\n                Field mActivityThreadField = apk.getClass().getDeclaredField(\"mActivityThread\");\n                mActivityThreadField.setAccessible(true);\n                currentActivityThread = mActivityThreadField.get(apk);\n            }\n            return currentActivityThread;\n        } catch (Throwable ignore) {\n            return null;\n        }\n    }\n\n    /**\n     * Handy method for fetching hidden integer constant value in system classes.\n     *\n     * @param clazz\n     * @param fieldName\n     * @return\n     */", "    public static int getValueOfStaticIntField(Class<?> clazz, String fieldName, int defVal) {\n        try {\n            final Field field = findField(clazz, fieldName);\n            return field.getInt(null);\n        } catch (Throwable thr) {\n            return defVal;\n        }\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/tinker/ShareTinkerLog.java", "chunked_list": ["package com.example.lib_sillyboy.tinker;\n\nimport android.os.Handler;\nimport android.os.Message;\nimport android.util.Log;\n\nimport java.lang.reflect.Constructor;\n\npublic class ShareTinkerLog {\n    private static final String TAG = \"Tinker.ShareTinkerLog\";\n", "public class ShareTinkerLog {\n    private static final String TAG = \"Tinker.ShareTinkerLog\";\n\n    public static final int FN_LOG_PRINT_STACKTRACE = 0xFA1;\n    public static final int FN_LOG_PRINT_PENDING_LOGS = 0xFA2;\n\n    private static final Handler[] tinkerLogInlineFenceRef = {null};\n\n    private static final TinkerLogImp debugLog = new TinkerLogImp() {\n\n        @Override", "        public void v(final String tag, final String format, final Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            Log.v(tag, log);\n        }\n\n        @Override\n        public void i(final String tag, final String format, final Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            Log.i(tag, log);\n\n        }\n\n        @Override", "        public void d(final String tag, final String format, final Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            Log.d(tag, log);\n        }\n\n        @Override\n        public void w(final String tag, final String format, final Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            Log.w(tag, log);\n        }\n\n        @Override", "        public void e(final String tag, final String format, final Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            Log.e(tag, log);\n        }\n\n        @Override\n        public void printErrStackTrace(String tag, Throwable tr, String format, Object... params) {\n            String log = (params == null || params.length == 0) ? format : String.format(format, params);\n            if (log == null) {\n                log = \"\";\n            }\n            log += \"  \" + Log.getStackTraceString(tr);\n            Log.e(tag, log);\n        }\n    };\n\n    private static final TinkerLogImp[] tinkerLogImpRef = {debugLog};\n\n    static {\n        synchronized (tinkerLogInlineFenceRef) {", "            if (log == null) {\n                log = \"\";\n            }\n            log += \"  \" + Log.getStackTraceString(tr);\n            Log.e(tag, log);\n        }\n    };\n\n    private static final TinkerLogImp[] tinkerLogImpRef = {debugLog};\n\n    static {\n        synchronized (tinkerLogInlineFenceRef) {", "            try {\n                final Class<?> clazz = Class.forName(\"com.tencent.tinker.lib.util.TinkerLogInlineFence\");\n                final Constructor<?> ctor = clazz.getDeclaredConstructor();\n                ctor.setAccessible(true);\n                tinkerLogInlineFenceRef[0] = (Handler) ctor.newInstance();\n            } catch (Throwable thr) {\n                Log.e(TAG, \"[-] Fail to create inline fence instance.\", thr);\n                tinkerLogInlineFenceRef[0] = null;\n            }\n        }\n    }\n\n    private static Handler getInlineFence() {\n        synchronized (tinkerLogInlineFenceRef) {\n            return tinkerLogInlineFenceRef[0];\n        }\n    }\n", "    public static TinkerLogImp getDefaultImpl() {\n        return debugLog;\n    }\n\n    public static void setTinkerLogImp(TinkerLogImp imp) {\n        synchronized (tinkerLogImpRef) {\n            tinkerLogImpRef[0] = imp;\n            if (imp != null && imp != debugLog) {\n                printPendingLogs();\n            }\n        }\n    }\n", "    public static TinkerLogImp getImpl() {\n        synchronized (tinkerLogImpRef) {\n            return tinkerLogImpRef[0];\n        }\n    }\n\n    public static void v(final String tag, final String fmt, final Object... values) {\n        printLog(Log.VERBOSE, tag, fmt, values);\n    }\n\n    public static void d(final String tag, final String fmt, final Object... values) {\n        printLog(Log.DEBUG, tag, fmt, values);\n    }\n", "    public static void d(final String tag, final String fmt, final Object... values) {\n        printLog(Log.DEBUG, tag, fmt, values);\n    }\n\n    public static void i(final String tag, final String fmt, final Object... values) {\n        printLog(Log.INFO, tag, fmt, values);\n    }\n\n    public static void w(final String tag, final String fmt, final Object... values) {\n        printLog(Log.WARN, tag, fmt, values);\n    }\n", "    public static void w(final String tag, final String fmt, final Object... values) {\n        printLog(Log.WARN, tag, fmt, values);\n    }\n\n    public static void e(final String tag, final String fmt, final Object... values) {\n        printLog(Log.ERROR, tag, fmt, values);\n    }\n\n    public static void printErrStackTrace(String tag, Throwable thr, final String format, final Object... values) {\n        printLog(tag, thr, format, values);\n    }\n", "    public static void printErrStackTrace(String tag, Throwable thr, final String format, final Object... values) {\n        printLog(tag, thr, format, values);\n    }\n\n    public static void printPendingLogs() {\n        final Handler inlineFence = getInlineFence();\n        if (inlineFence != null) {\n            final Message msg = Message.obtain(inlineFence, FN_LOG_PRINT_PENDING_LOGS);\n            inlineFence.handleMessage(msg);\n            msg.recycle();\n        }\n    }\n\n    private static void printLog(int priority, String tag, String fmt, Object... values) {\n        final long timestamp = System.currentTimeMillis();\n        final Object[] args = {priority, timestamp, tag, fmt, values};\n        final Handler inlineFence = getInlineFence();", "        if (inlineFence != null) {\n            final Message msg = Message.obtain(inlineFence, priority, args);\n            inlineFence.handleMessage(msg);\n            msg.recycle();\n        } else {\n            debugLog.e(tag, \"!! NO_LOG_IMPL !! Original Log: \" + fmt, values);\n        }\n    }\n\n    private static void printLog(String tag, Throwable thr, String fmt, Object... values) {\n        final long timestamp = System.currentTimeMillis();\n        final Object[] args = {FN_LOG_PRINT_STACKTRACE, timestamp, tag, thr, fmt, values};\n        final Handler inlineFence = getInlineFence();", "        if (inlineFence != null) {\n            final Message msg = Message.obtain(inlineFence, FN_LOG_PRINT_STACKTRACE, args);\n            inlineFence.handleMessage(msg);\n            msg.recycle();\n        } else {\n            debugLog.printErrStackTrace(tag, thr, \"!! NO_LOG_IMPL !! Original Log: \" + fmt, values);\n        }\n    }\n\n    public interface TinkerLogImp {\n\n        void v(final String tag, final String fmt, final Object... values);\n\n        void d(final String tag, final String fmt, final Object... values);\n\n        void i(final String tag, final String fmt, final Object... values);\n\n        void w(final String tag, final String fmt, final Object... values);\n\n        void e(final String tag, final String fmt, final Object... values);\n\n        void printErrStackTrace(String tag, Throwable tr, final String format, final Object... values);\n\n    }\n}", "    public interface TinkerLogImp {\n\n        void v(final String tag, final String fmt, final Object... values);\n\n        void d(final String tag, final String fmt, final Object... values);\n\n        void i(final String tag, final String fmt, final Object... values);\n\n        void w(final String tag, final String fmt, final Object... values);\n\n        void e(final String tag, final String fmt, final Object... values);\n\n        void printErrStackTrace(String tag, Throwable tr, final String format, final Object... values);\n\n    }\n}"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/tinker/TinkerLoadLibrary.java", "chunked_list": ["/*\n * Tencent is pleased to support the open source community by making Tinker available.\n *\n * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/BSD-3-Clause\n *", " * https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.lib_sillyboy.tinker;\n", "package com.example.lib_sillyboy.tinker;\n\nimport android.os.Build;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Iterator;", "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n\n\npublic class TinkerLoadLibrary {\n    private static final String TAG = \"Tinker.LoadLibrary\";\n\n    public static void installNativeLibraryPath(ClassLoader classLoader, File folder)\n            throws Throwable {", "    public static void installNativeLibraryPath(ClassLoader classLoader, File folder)\n            throws Throwable {\n        if (folder == null || !folder.exists()) {\n            ShareTinkerLog.e(TAG, \"installNativeLibraryPath, folder %s is illegal\", folder);\n            return;\n        }\n        // android o sdk_int 26\n        // for android o preview sdk_int 25\n        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)\n                || Build.VERSION.SDK_INT > 25) {\n            try {\n                V25.install(classLoader, folder);\n            } catch (Throwable throwable) {\n                // install fail, try to treat it as v23\n                // some preview N version may go here\n                ShareTinkerLog.e(TAG, \"installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23\",\n                        Build.VERSION.SDK_INT, throwable.getMessage());\n                V23.install(classLoader, folder);\n            }", "        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)\n                || Build.VERSION.SDK_INT > 25) {\n            try {\n                V25.install(classLoader, folder);\n            } catch (Throwable throwable) {\n                // install fail, try to treat it as v23\n                // some preview N version may go here\n                ShareTinkerLog.e(TAG, \"installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23\",\n                        Build.VERSION.SDK_INT, throwable.getMessage());\n                V23.install(classLoader, folder);\n            }", "        } else if (Build.VERSION.SDK_INT >= 23) {\n            try {\n                V23.install(classLoader, folder);\n            } catch (Throwable throwable) {\n                // install fail, try to treat it as v14\n                ShareTinkerLog.e(TAG, \"installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14\",\n                        Build.VERSION.SDK_INT, throwable.getMessage());\n\n                V14.install(classLoader, folder);\n            }\n        } else if (Build.VERSION.SDK_INT >= 14) {\n            V14.install(classLoader, folder);\n        } else {\n            V4.install(classLoader, folder);\n        }\n    }\n\n    private static final class V4 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            String addPath = folder.getPath();\n            Field pathField = ShareReflectUtil.findField(classLoader, \"libPath\");\n            final String origLibPaths = (String) pathField.get(classLoader);\n            final String[] origLibPathSplit = origLibPaths.split(\":\");\n            final StringBuilder newLibPaths = new StringBuilder(addPath);\n", "        } else if (Build.VERSION.SDK_INT >= 14) {\n            V14.install(classLoader, folder);\n        } else {\n            V4.install(classLoader, folder);\n        }\n    }\n\n    private static final class V4 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            String addPath = folder.getPath();\n            Field pathField = ShareReflectUtil.findField(classLoader, \"libPath\");\n            final String origLibPaths = (String) pathField.get(classLoader);\n            final String[] origLibPathSplit = origLibPaths.split(\":\");\n            final StringBuilder newLibPaths = new StringBuilder(addPath);\n", "            for (String origLibPath : origLibPathSplit) {\n                if (origLibPath == null || addPath.equals(origLibPath)) {\n                    continue;\n                }\n                newLibPaths.append(':').append(origLibPath);\n            }\n            pathField.set(classLoader, newLibPaths.toString());\n\n            final Field libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, \"libraryPathElements\");\n            final List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);\n            final Iterator<String> libPathElementIt = libraryPathElements.iterator();", "            while (libPathElementIt.hasNext()) {\n                final String libPath = libPathElementIt.next();\n                if (addPath.equals(libPath)) {\n                    libPathElementIt.remove();\n                    break;\n                }\n            }\n            libraryPathElements.add(0, addPath);\n            libraryPathElementsFiled.set(classLoader, libraryPathElements);\n        }\n    }\n\n    private static final class V14 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final Field nativeLibDirField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");\n            final File[] origNativeLibDirs = (File[]) nativeLibDirField.get(dexPathList);\n\n            final List<File> newNativeLibDirList = new ArrayList<>(origNativeLibDirs.length + 1);\n            newNativeLibDirList.add(folder);", "            for (File origNativeLibDir : origNativeLibDirs) {\n                if (!folder.equals(origNativeLibDir)) {\n                    newNativeLibDirList.add(origNativeLibDir);\n                }\n            }\n            nativeLibDirField.set(dexPathList, newNativeLibDirList.toArray(new File[0]));\n        }\n    }\n\n    private static final class V23 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");\n\n            List<File> origLibDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);", "            if (origLibDirs == null) {\n                origLibDirs = new ArrayList<>(2);\n            }\n            final Iterator<File> libDirIt = origLibDirs.iterator();\n            while (libDirIt.hasNext()) {\n                final File libDir = libDirIt.next();\n                if (folder.equals(libDir)) {\n                    libDirIt.remove();\n                    break;\n                }\n            }\n            origLibDirs.add(0, folder);\n\n            final Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"systemNativeLibraryDirectories\");\n            List<File> origSystemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);", "            if (origSystemLibDirs == null) {\n                origSystemLibDirs = new ArrayList<>(2);\n            }\n\n            final List<File> newLibDirs = new ArrayList<>(origLibDirs.size() + origSystemLibDirs.size() + 1);\n            newLibDirs.addAll(origLibDirs);\n            newLibDirs.addAll(origSystemLibDirs);\n\n            final Method makeElements = ShareReflectUtil.findMethod(dexPathList,\n                    \"makePathElements\", List.class, File.class, List.class);\n            final ArrayList<IOException> suppressedExceptions = new ArrayList<>();\n\n            final Object[] elements = (Object[]) makeElements.invoke(dexPathList, newLibDirs, null, suppressedExceptions);\n\n            final Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, \"nativeLibraryPathElements\");\n            nativeLibraryPathElements.set(dexPathList, elements);\n        }\n    }\n\n    private static final class V25 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");\n\n            List<File> origLibDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);", "            if (origLibDirs == null) {\n                origLibDirs = new ArrayList<>(2);\n            }\n            final Iterator<File> libDirIt = origLibDirs.iterator();\n            while (libDirIt.hasNext()) {\n                final File libDir = libDirIt.next();\n                if (folder.equals(libDir)) {\n                    libDirIt.remove();\n                    break;\n                }\n            }\n            origLibDirs.add(0, folder);\n\n            final Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"systemNativeLibraryDirectories\");\n            List<File> origSystemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);", "            if (origSystemLibDirs == null) {\n                origSystemLibDirs = new ArrayList<>(2);\n            }\n\n            final List<File> newLibDirs = new ArrayList<>(origLibDirs.size() + origSystemLibDirs.size() + 1);\n            newLibDirs.addAll(origLibDirs);\n            newLibDirs.addAll(origSystemLibDirs);\n\n            final Method makeElements = ShareReflectUtil.findMethod(dexPathList, \"makePathElements\", List.class);\n\n            final Object[] elements = (Object[]) makeElements.invoke(dexPathList, newLibDirs);\n\n            final Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, \"nativeLibraryPathElements\");\n            nativeLibraryPathElements.set(dexPathList, elements);\n        }\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Elf64Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Elf64Header extends Elf.Header {\n    private final ElfParser parser;\n\n    public Elf64Header(final boolean bigEndian, final ElfParser parser) throws IOException {\n        this.bigEndian = bigEndian;\n        this.parser = parser;\n\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        type = parser.readHalf(buffer, 0x10);\n        phoff = parser.readLong(buffer, 0x20);\n        shoff = parser.readLong(buffer, 0x28);\n        phentsize = parser.readHalf(buffer, 0x36);\n        phnum = parser.readHalf(buffer, 0x38);\n        shentsize = parser.readHalf(buffer, 0x3A);\n        shnum = parser.readHalf(buffer, 0x3C);\n        shstrndx = parser.readHalf(buffer, 0x3E);\n    }\n\n    @Override\n    public Elf.SectionHeader getSectionHeader(final int index) throws IOException {\n        return new Section64Header(parser, this, index);\n    }\n\n    @Override\n    public Elf.ProgramHeader getProgramHeader(final long index) throws IOException {\n        return new Program64Header(parser, this, index);\n    }\n\n    @Override\n    public Elf.DynamicStructure getDynamicStructure(final long baseOffset, final int index)\n            throws IOException {\n        return new Dynamic64Structure(parser, this, baseOffset, index);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Dynamic64Structure.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Dynamic64Structure extends Elf.DynamicStructure {\n    public Dynamic64Structure(final ElfParser parser, final Elf.Header header,\n                              long baseOffset, final int index) throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        baseOffset = baseOffset + (index * 16);\n        tag = parser.readLong(buffer, baseOffset);\n        val = parser.readLong(buffer, baseOffset + 0x8);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/ElfParser.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;", "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ElfParser implements Closeable, Elf {\n    private final int MAGIC = 0x464C457F;\n    private final FileChannel channel;\n\n    public ElfParser(File file) throws FileNotFoundException {", "public class ElfParser implements Closeable, Elf {\n    private final int MAGIC = 0x464C457F;\n    private final FileChannel channel;\n\n    public ElfParser(File file) throws FileNotFoundException {\n        if (file == null || !file.exists()) {\n            throw new IllegalArgumentException(\"File is null or does not exist\");\n        }\n\n        final FileInputStream inputStream = new FileInputStream(file);\n        this.channel = inputStream.getChannel();\n    }\n", "    public Header parseHeader() throws IOException {\n        channel.position(0L);\n\n        // Read in ELF identification to determine file class and endianness\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        if (readWord(buffer, 0) != MAGIC) {\n            throw new IllegalArgumentException(\"Invalid ELF Magic!\");\n        }\n\n        final short fileClass = readByte(buffer, 0x4);\n        final boolean bigEndian = (readByte(buffer, 0x5) == Header.ELFDATA2MSB);", "        if (fileClass == Header.ELFCLASS32) {\n            return new Elf32Header(bigEndian, this);\n        } else if (fileClass == Header.ELFCLASS64) {\n            return new Elf64Header(bigEndian, this);\n        }\n\n        throw new IllegalStateException(\"Invalid class type!\");\n    }\n\n    public List<String> parseNeededDependencies() throws IOException {\n        channel.position(0);\n        final List<String> dependencies = new ArrayList<String>();\n        final Header header = parseHeader();\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        long numProgramHeaderEntries = header.phnum;", "        if (numProgramHeaderEntries == 0xFFFF) {\n            /**\n             * Extended Numbering\n             *\n             * If the real number of program header table entries is larger than\n             * or equal to PN_XNUM(0xffff), it is set to sh_info field of the\n             * section header at index 0, and PN_XNUM is set to e_phnum\n             * field. Otherwise, the section header at index 0 is zero\n             * initialized, if it exists.\n             **/\n            final SectionHeader sectionHeader = header.getSectionHeader(0);\n            numProgramHeaderEntries = sectionHeader.info;\n        }\n\n        long dynamicSectionOff = 0;", "        for (long i = 0; i < numProgramHeaderEntries; ++i) {\n            final ProgramHeader programHeader = header.getProgramHeader(i);\n            if (programHeader.type == ProgramHeader.PT_DYNAMIC) {\n                dynamicSectionOff = programHeader.offset;\n                break;\n            }\n        }\n\n        if (dynamicSectionOff == 0) {\n            // No dynamic linking info, nothing to load\n            return Collections.unmodifiableList(dependencies);\n        }\n\n        int i = 0;\n        final List<Long> neededOffsets = new ArrayList<Long>();\n        long vStringTableOff = 0;\n        DynamicStructure dynStructure;\n        do {\n            dynStructure = header.getDynamicStructure(dynamicSectionOff, i);", "        if (dynamicSectionOff == 0) {\n            // No dynamic linking info, nothing to load\n            return Collections.unmodifiableList(dependencies);\n        }\n\n        int i = 0;\n        final List<Long> neededOffsets = new ArrayList<Long>();\n        long vStringTableOff = 0;\n        DynamicStructure dynStructure;\n        do {\n            dynStructure = header.getDynamicStructure(dynamicSectionOff, i);", "            if (dynStructure.tag == DynamicStructure.DT_NEEDED) {\n                neededOffsets.add(dynStructure.val);\n            } else if (dynStructure.tag == DynamicStructure.DT_STRTAB) {\n                vStringTableOff = dynStructure.val; // d_ptr union\n            }\n            ++i;\n        } while (dynStructure.tag != DynamicStructure.DT_NULL);\n\n        if (vStringTableOff == 0) {\n            throw new IllegalStateException(\"String table offset not found!\");\n        }\n\n        // Map to file offset\n        final long stringTableOff = offsetFromVma(header, numProgramHeaderEntries, vStringTableOff);", "        if (vStringTableOff == 0) {\n            throw new IllegalStateException(\"String table offset not found!\");\n        }\n\n        // Map to file offset\n        final long stringTableOff = offsetFromVma(header, numProgramHeaderEntries, vStringTableOff);\n        for (final Long strOff : neededOffsets) {\n            dependencies.add(readString(buffer, stringTableOff + strOff));\n        }\n\n        return dependencies;\n    }\n\n    private long offsetFromVma(final Header header, final long numEntries, final long vma)\n            throws IOException {", "        for (long i = 0; i < numEntries; ++i) {\n            final ProgramHeader programHeader = header.getProgramHeader(i);\n            if (programHeader.type == ProgramHeader.PT_LOAD) {\n                // Within memsz instead of filesz to be more tolerant\n                if (programHeader.vaddr <= vma\n                        && vma <= programHeader.vaddr + programHeader.memsz) {\n                    return vma - programHeader.vaddr + programHeader.offset;\n                }\n            }\n        }\n\n        throw new IllegalStateException(\"Could not map vma to file offset!\");\n    }\n\n    @Override", "    public void close() throws IOException {\n        this.channel.close();\n    }\n\n    protected String readString(final ByteBuffer buffer, long offset) throws IOException {\n        final StringBuilder builder = new StringBuilder();\n        short c;\n        while ((c = readByte(buffer, offset++)) != 0) {\n            builder.append((char) c);\n        }\n\n        return builder.toString();\n    }\n\n    protected long readLong(final ByteBuffer buffer, final long offset) throws IOException {\n        read(buffer, offset, 8);\n        return buffer.getLong();\n    }\n\n    protected long readWord(final ByteBuffer buffer, final long offset) throws IOException {\n        read(buffer, offset, 4);\n        return buffer.getInt() & 0xFFFFFFFFL;\n    }\n\n    protected int readHalf(final ByteBuffer buffer, final long offset) throws IOException {\n        read(buffer, offset, 2);\n        return buffer.getShort() & 0xFFFF;\n    }\n\n    protected short readByte(final ByteBuffer buffer, final long offset) throws IOException {\n        read(buffer, offset, 1);\n        return (short) (buffer.get() & 0xFF);\n    }\n\n    protected void read(final ByteBuffer buffer, long offset, final int length) throws IOException {\n        buffer.position(0);\n        buffer.limit(length);\n        long bytesRead = 0;", "        while (bytesRead < length) {\n            final int read = channel.read(buffer, offset + bytesRead);\n            if (read == -1) {\n                throw new EOFException();\n            }\n\n            bytesRead += read;\n        }\n        buffer.position(0);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Program64Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Program64Header extends Elf.ProgramHeader {\n    public Program64Header(final ElfParser parser, final Elf.Header header, final long index)\n            throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        final long baseOffset = header.phoff + (index * header.phentsize);\n        type = parser.readWord(buffer, baseOffset);\n        offset = parser.readLong(buffer, baseOffset + 0x8);\n        vaddr = parser.readLong(buffer, baseOffset + 0x10);\n        memsz = parser.readLong(buffer, baseOffset + 0x28);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Section32Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Section32Header extends Elf.SectionHeader {\n    public Section32Header(final ElfParser parser, final Elf.Header header, final int index)\n            throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        info = parser.readWord(buffer, header.shoff + (index * header.shentsize) + 0x1C);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Program32Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Program32Header extends Elf.ProgramHeader {\n    public Program32Header(final ElfParser parser, final Elf.Header header, final long index)\n            throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        final long baseOffset = header.phoff + (index * header.phentsize);\n        type = parser.readWord(buffer, baseOffset);\n        offset = parser.readWord(buffer, baseOffset + 0x4);\n        vaddr = parser.readWord(buffer, baseOffset + 0x8);\n        memsz = parser.readWord(buffer, baseOffset + 0x14);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Elf32Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Elf32Header extends Elf.Header {\n    private final ElfParser parser;\n\n    public Elf32Header(final boolean bigEndian, final ElfParser parser) throws IOException {\n        this.bigEndian = bigEndian;\n        this.parser = parser;\n\n        final ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        type = parser.readHalf(buffer, 0x10);\n        phoff = parser.readWord(buffer, 0x1C);\n        shoff = parser.readWord(buffer, 0x20);\n        phentsize = parser.readHalf(buffer, 0x2A);\n        phnum = parser.readHalf(buffer, 0x2C);\n        shentsize = parser.readHalf(buffer, 0x2E);\n        shnum = parser.readHalf(buffer, 0x30);\n        shstrndx = parser.readHalf(buffer, 0x32);\n    }\n\n    @Override\n    public Elf.SectionHeader getSectionHeader(final int index) throws IOException {\n        return new Section32Header(parser, this, index);\n    }\n\n    @Override\n    public Elf.ProgramHeader getProgramHeader(final long index) throws IOException {\n        return new Program32Header(parser, this, index);\n    }\n\n    @Override\n    public Elf.DynamicStructure getDynamicStructure(final long baseOffset, final int index)\n            throws IOException {\n        return new Dynamic32Structure(parser, this, baseOffset, index);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Section64Header.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\n", "\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Section64Header extends Elf.SectionHeader {\n    public Section64Header(final ElfParser parser, final Elf.Header header, final int index)\n            throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        info = parser.readWord(buffer, header.shoff + (index * header.shentsize) + 0x2C);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Elf.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\n\npublic interface Elf {\n    abstract class Header {\n        public static final int ELFCLASS32 = 1; // 32 Bit ELF\n        public static final int ELFCLASS64 = 2; // 64 Bit ELF\n        public static final int ELFDATA2MSB = 2; // Big Endian, 2s complement\n\n        public boolean bigEndian;\n        public int type;", "        public boolean bigEndian;\n        public int type;\n        public long phoff;\n        public long shoff;\n        public int phentsize;\n        public int phnum;\n        public int shentsize;\n        public int shnum;\n        public int shstrndx;\n\n        abstract public SectionHeader getSectionHeader(int index) throws IOException;", "        public int shstrndx;\n\n        abstract public SectionHeader getSectionHeader(int index) throws IOException;\n        abstract public ProgramHeader getProgramHeader(long index) throws IOException;\n        abstract public DynamicStructure getDynamicStructure(long baseOffset, int index)\n                throws IOException;\n    }\n\n    abstract class ProgramHeader {\n        public static final int PT_LOAD = 1; // Loadable segment\n        public static final int PT_DYNAMIC = 2; // Dynamic linking information\n", "        public static final int PT_LOAD = 1; // Loadable segment\n        public static final int PT_DYNAMIC = 2; // Dynamic linking information\n\n        public long type;\n        public long offset;\n        public long vaddr;\n        public long memsz;\n    }\n\n    abstract class SectionHeader {\n        public long info;\n    }\n\n    abstract class DynamicStructure {", "        public long info;\n    }\n\n    abstract class DynamicStructure {\n        public static final int DT_NULL = 0; // Marks end of structure list\n        public static final int DT_NEEDED = 1; // Needed library\n        public static final int DT_STRTAB = 5; // String table\n\n        public long tag;\n        public long val; // Union with d_ptr\n    }\n}\n", "        public long tag;\n        public long val; // Union with d_ptr\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/main/java/com/example/lib_sillyboy/elf/Dynamic32Structure.java", "chunked_list": ["/**\n * Copyright 2015 - 2016 KeepSafe Software, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.lib_sillyboy.elf;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Dynamic32Structure extends Elf.DynamicStructure {\n    public Dynamic32Structure(final ElfParser parser, final Elf.Header header,\n                              long baseOffset, final int index) throws IOException {\n        final ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(header.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n        baseOffset = baseOffset + (index * 8);\n        tag = parser.readWord(buffer, baseOffset);\n        val = parser.readWord(buffer, baseOffset + 0x4);\n    }\n}\n"]}
{"filename": "lib_sillyboy/src/androidTest/java/com/example/lib_sillyboy/ExampleInstrumentedTest.java", "chunked_list": ["package com.example.lib_sillyboy;\n\nimport android.content.Context;\n\nimport androidx.test.platform.app.InstrumentationRegistry;\nimport androidx.test.ext.junit.runners.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n", "import org.junit.runner.RunWith;\n\nimport static org.junit.Assert.*;\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test", " */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();\n        assertEquals(\"com.example.lib_sillyboy.test\", appContext.getPackageName());\n    }\n}"]}
{"filename": "app/src/test/java/com/example/nativecpp/ExampleUnitTest.java", "chunked_list": ["package com.example.nativecpp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>", " *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() {\n        assertEquals(4, 2 + 2);\n    }\n}"]}
{"filename": "app/src/main/java/com/example/nativecpp/CustomApplication.java", "chunked_list": ["package com.example.nativecpp;\n\nimport android.app.Application;\nimport android.util.Log;\n\n\nimport com.example.lib_sillyboy.DynamicSo;\n\nimport java.io.File;\n\npublic class CustomApplication extends Application {\n\n    @Override", "import java.io.File;\n\npublic class CustomApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //String absolutePath = getFilesDir().getAbsolutePath();\n\n        String tmpDir =\"/data/data/com.example.nativecpp/\";\n        Log.e(\"darren:\", \"file===:\"+ tmpDir);\n        // \u5728\u5408\u9002\u7684\u65f6\u5019\u5c06\u81ea\u5b9a\u4e49\u8def\u5f84\u63d2\u5165so\u68c0\u7d22\u8def\u5f84\n        DynamicSo.insertPathToNativeSystem(this,new File(tmpDir));\n        \n    }\n\n\n}\n"]}
{"filename": "app/src/main/java/com/example/nativecpp/MainActivity.java", "chunked_list": ["package com.example.nativecpp;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.TextView;\n\nimport com.example.lib_sillyboy.DynamicSo;", "\nimport com.example.lib_sillyboy.DynamicSo;\nimport com.example.nativecpp.databinding.ActivityMainBinding;\nimport com.example.lib_sillyboy.elf.ElfParser;\n\n\nimport java.io.File;\n\npublic class MainActivity extends AppCompatActivity {\n\n    // Used to load the 'nativecpptwo' library on application startup.\n    static {\n        //System.loadLibrary(\"nativecpptwo\");\n\n    }\n\n    private ActivityMainBinding binding;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        String path = \"/data/data/com.example.nativecpp/\";\n        File file = new File(path + \"libfingerCore.so\");\n        Log.e(\"darren:\", \"info===:\"+ file.exists()+\":\"+ file.canRead());\n\n        DynamicSo.loadStaticSo(file, path);\n        binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n\n        // Example of a call to a native method\n        TextView tv = binding.sampleText;\n\n        tv.setOnClickListener(new View.OnClickListener() {\n            @Override", "public class MainActivity extends AppCompatActivity {\n\n    // Used to load the 'nativecpptwo' library on application startup.\n    static {\n        //System.loadLibrary(\"nativecpptwo\");\n\n    }\n\n    private ActivityMainBinding binding;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        String path = \"/data/data/com.example.nativecpp/\";\n        File file = new File(path + \"libfingerCore.so\");\n        Log.e(\"darren:\", \"info===:\"+ file.exists()+\":\"+ file.canRead());\n\n        DynamicSo.loadStaticSo(file, path);\n        binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n\n        // Example of a call to a native method\n        TextView tv = binding.sampleText;\n\n        tv.setOnClickListener(new View.OnClickListener() {\n            @Override", "            public void onClick(View v) {\n                clickTest();\n\n            }\n        });\n    }\n\n    /**\n     * A native method that is implemented by the 'nativecpp' native library,\n     * which is packaged with this application.\n     */\n", "    public native void clickTest();\n}\n\n"]}
{"filename": "app/src/androidTest/java/com/example/nativecpp/ExampleInstrumentedTest.java", "chunked_list": ["package com.example.nativecpp;\n\nimport android.content.Context;\n\nimport androidx.test.platform.app.InstrumentationRegistry;\nimport androidx.test.ext.junit.runners.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n", "import org.junit.runner.RunWith;\n\nimport static org.junit.Assert.*;\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test", " */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();\n        assertEquals(\"com.example.nativecpp\", appContext.getPackageName());\n    }\n}"]}
