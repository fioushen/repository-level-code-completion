{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/MineGPTClientForge.java", "chunked_list": ["package team.teampotato.minegpt.forge;\n\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\n\nimport team.teampotato.minegpt.forge.command.ClientCommand;\nimport team.teampotato.minegpt.forge.command.ClientConfigCommand;\nimport team.teampotato.minegpt.forge.forged.api.ClientCommandRegistrationEvent;\n\npublic class MineGPTClientForge {\n    public static void onInitializeClient(FMLClientSetupEvent event) {\n        ClientCommandRegistrationEvent.EVENT.register(ClientCommand::registerCommand);\n        ClientCommandRegistrationEvent.EVENT.register(ClientConfigCommand::registerCommand);\n    }\n}\n", "public class MineGPTClientForge {\n    public static void onInitializeClient(FMLClientSetupEvent event) {\n        ClientCommandRegistrationEvent.EVENT.register(ClientCommand::registerCommand);\n        ClientCommandRegistrationEvent.EVENT.register(ClientConfigCommand::registerCommand);\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/MineGPTForge.java", "chunked_list": ["package team.teampotato.minegpt.forge;\n\nimport dev.architectury.platform.forge.EventBuses;\n\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\n\nimport team.teampotato.minegpt.MineGPT;", "\nimport team.teampotato.minegpt.MineGPT;\n\n@Mod(MineGPT.MOD_ID)\npublic class MineGPTForge {\n    public MineGPTForge() {\n        IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();\n        EventBuses.registerModEventBus(MineGPT.MOD_ID, modEventBus);\n\n        modEventBus.addListener(MineGPTForge::onInitialize);\n        modEventBus.addListener(MineGPTClientForge::onInitializeClient);\n    }\n", "    public static void onInitialize(FMLCommonSetupEvent event) {\n        MineGPT.init();\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/command/ClientCommand.java", "chunked_list": ["package team.teampotato.minegpt.forge.command;\n\nimport com.mojang.brigadier.CommandDispatcher;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;", "import net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;\n\nimport team.teampotato.minegpt.config.Config;\nimport team.teampotato.minegpt.forge.forged.api.ClientCommandManager;\nimport team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\nimport team.teampotato.minegpt.screen.PingScreen;\n\n@OnlyIn(Dist.CLIENT)\npublic class ClientCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n", "@OnlyIn(Dist.CLIENT)\npublic class ClientCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/command/ClientConfigCommand.java", "chunked_list": ["package team.teampotato.minegpt.forge.command;\n\nimport com.mojang.brigadier.CommandDispatcher;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;", "import net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;\n\nimport team.teampotato.minegpt.config.Config;\nimport team.teampotato.minegpt.forge.forged.api.ClientCommandManager;\nimport team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\nimport team.teampotato.minegpt.screen.PingScreen;\n\n@OnlyIn(Dist.CLIENT)\npublic class ClientConfigCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n", "@OnlyIn(Dist.CLIENT)\npublic class ClientConfigCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/api/ClientCommandManager.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.api;\n", "package team.teampotato.minegpt.forge.forged.api;\n\nimport com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.arguments.ArgumentType;\nimport com.mojang.brigadier.builder.LiteralArgumentBuilder;\nimport com.mojang.brigadier.builder.RequiredArgumentBuilder;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;\n", "import net.minecraftforge.api.distmarker.OnlyIn;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport team.teampotato.minegpt.forge.forged.impl.ClientCommandInternals;\n\n/**\n * Manages client-sided commands and provides some related helper methods.\n *\n * <p>Client-sided commands are fully executed on the client,", " *\n * <p>Client-sided commands are fully executed on the client,\n * so players can use them in both singleplayer and multiplayer.\n *\n * <p>Registrations can be done in handlers for {@link ClientCommandRegistrationEvent#EVENT}\n * (See example below.)\n *\n * <p>The commands are run on the client game thread by default.\n * Avoid doing any heavy calculations here as that can freeze the game's rendering.\n * For example, you can move heavy code to another thread.", " * Avoid doing any heavy calculations here as that can freeze the game's rendering.\n * For example, you can move heavy code to another thread.\n *\n * <p>This class also has alternatives to the server-side helper methods in\n * {@link net.minecraft.server.command.CommandManager}:\n * {@link #literal(String)} and {@link #argument(String, ArgumentType)}.\n *\n * <p>The precedence rules of client-sided and server-sided commands with the same name\n * are an implementation detail that is not guaranteed to remain the same in future versions.\n * The aim is to make commands from the server take precedence over client-sided commands", " * are an implementation detail that is not guaranteed to remain the same in future versions.\n * The aim is to make commands from the server take precedence over client-sided commands\n * in a future version of this API.\n *\n * <h2>Example command</h2>\n * <pre>\n * {@code\n * ClientCommandRegistrationCallback.EVENT.register((dispatcher, registryAccess) -> {\n * \t\tdispatcher.register(\n * \t\t\tClientCommandManager.literal(\"hello\").executes(context -> {", " * \t\tdispatcher.register(\n * \t\t\tClientCommandManager.literal(\"hello\").executes(context -> {\n * \t\t\t\tcontext.getSource().sendFeedback(Text.literal(\"Hello, world!\"));\n * \t\t\t\treturn 0;\n * \t\t\t})\n * \t\t);\n * });\n * }\n * </pre>\n */", " * </pre>\n */\n@OnlyIn(Dist.CLIENT)\npublic final class ClientCommandManager {\n    private ClientCommandManager() {\n    }\n\n    /**\n     * Gets the active command dispatcher that handles client command registration and execution.\n     *\n     * <p>May be null when not connected to a server (dedicated or integrated).</p>\n     *\n     * @return active dispatcher if present\n     */\n    public static @Nullable CommandDispatcher<FabricClientCommandSource> getActiveDispatcher() {\n        return ClientCommandInternals.getActiveDispatcher();\n    }\n\n    /**\n     * Creates a literal argument builder.\n     *\n     * @param name the literal name\n     * @return the created argument builder\n     */", "    public static LiteralArgumentBuilder<FabricClientCommandSource> literal(String name) {\n        return LiteralArgumentBuilder.literal(name);\n    }\n\n    /**\n     * Creates a required argument builder.\n     *\n     * @param name the name of the argument\n     * @param type the type of the argument\n     * @param <T>  the type of the parsed argument value\n     * @return the created argument builder\n     */\n    public static <T> RequiredArgumentBuilder<FabricClientCommandSource, T> argument(String name, ArgumentType<T> type) {\n        return RequiredArgumentBuilder.argument(name, type);\n    }\n}"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/api/FabricClientCommandSource.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.api;\n", "package team.teampotato.minegpt.forge.forged.api;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.world.ClientWorld;\nimport net.minecraft.command.CommandSource;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.math.Vec2f;\nimport net.minecraft.util.math.Vec3d;", "import net.minecraft.util.math.Vec2f;\nimport net.minecraft.util.math.Vec3d;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;\n\n/**\n * Extensions to {@link CommandSource} for client-sided commands.\n */\n@OnlyIn(Dist.CLIENT)\npublic interface FabricClientCommandSource extends CommandSource {\n    /**\n     * Sends a feedback message to the player.\n     *\n     * @param message the feedback message\n     */\n    void sendFeedback(Text message);\n\n    /**\n     * Sends an error message to the player.\n     *\n     * @param message the error message\n     */\n    void sendError(Text message);\n\n    /**\n     * Gets the client instance used to run the command.\n     *\n     * @return the client\n     */\n    MinecraftClient getClient();\n\n    /**\n     * Gets the player that used the command.\n     *\n     * @return the player\n     */\n    ClientPlayerEntity getPlayer();\n\n    /**\n     * Gets the entity that used the command.\n     *\n     * @return the entity\n     */\n    default Entity getEntity() {\n        return getPlayer();\n    }\n\n    /**\n     * Gets the position from where the command has been executed.\n     *\n     * @return the position\n     */\n    default Vec3d getPosition() {\n        return getPlayer().getPos();\n    }\n\n    /**\n     * Gets the rotation of the entity that used the command.\n     *\n     * @return the rotation\n     */\n    default Vec2f getRotation() {\n        return getPlayer().getRotationClient();\n    }\n\n    /**\n     * Gets the world where the player used the command.\n     *\n     * @return the world\n     */\n    ClientWorld getWorld();\n\n    /**\n     * Gets the meta property under {@code key} that was assigned to this source.\n     *\n     * <p>This method should return the same result for every call with the same {@code key}.\n     *\n     * @param key the meta key\n     * @return the meta\n     */\n    default Object getMeta(String key) {\n        return null;\n    }\n}\n", " */\n@OnlyIn(Dist.CLIENT)\npublic interface FabricClientCommandSource extends CommandSource {\n    /**\n     * Sends a feedback message to the player.\n     *\n     * @param message the feedback message\n     */\n    void sendFeedback(Text message);\n\n    /**\n     * Sends an error message to the player.\n     *\n     * @param message the error message\n     */\n    void sendError(Text message);\n\n    /**\n     * Gets the client instance used to run the command.\n     *\n     * @return the client\n     */\n    MinecraftClient getClient();\n\n    /**\n     * Gets the player that used the command.\n     *\n     * @return the player\n     */\n    ClientPlayerEntity getPlayer();\n\n    /**\n     * Gets the entity that used the command.\n     *\n     * @return the entity\n     */\n    default Entity getEntity() {\n        return getPlayer();\n    }\n\n    /**\n     * Gets the position from where the command has been executed.\n     *\n     * @return the position\n     */\n    default Vec3d getPosition() {\n        return getPlayer().getPos();\n    }\n\n    /**\n     * Gets the rotation of the entity that used the command.\n     *\n     * @return the rotation\n     */\n    default Vec2f getRotation() {\n        return getPlayer().getRotationClient();\n    }\n\n    /**\n     * Gets the world where the player used the command.\n     *\n     * @return the world\n     */\n    ClientWorld getWorld();\n\n    /**\n     * Gets the meta property under {@code key} that was assigned to this source.\n     *\n     * <p>This method should return the same result for every call with the same {@code key}.\n     *\n     * @param key the meta key\n     * @return the meta\n     */\n    default Object getMeta(String key) {\n        return null;\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/api/ClientCommandRegistrationEvent.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.api;\n", "package team.teampotato.minegpt.forge.forged.api;\n\nimport com.mojang.brigadier.CommandDispatcher;\n\nimport dev.architectury.event.Event;\nimport dev.architectury.event.EventFactory;\n\nimport net.minecraft.command.CommandRegistryAccess;\n\n/**", "\n/**\n * Callback for when client commands are registered to the dispatcher.\n *\n * <p>To register some commands, you would register an event listener and implement the callback.\n *\n * <p>See {@link ClientCommandManager} for more details and an example.\n */\npublic interface ClientCommandRegistrationEvent {\n    Event<ClientCommandRegistrationEvent> EVENT = EventFactory.createEventResult();\n\n    /**\n     * Called when registering client commands.\n     *\n     * @param dispatcher the command dispatcher to register commands to\n     * @param registryAccess object exposing access to the game's registries\n     */\n    void register(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registryAccess);\n}\n", "public interface ClientCommandRegistrationEvent {\n    Event<ClientCommandRegistrationEvent> EVENT = EventFactory.createEventResult();\n\n    /**\n     * Called when registering client commands.\n     *\n     * @param dispatcher the command dispatcher to register commands to\n     * @param registryAccess object exposing access to the game's registries\n     */\n    void register(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registryAccess);\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/mixin/ClientCommandSourceMixin.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.mixin;\n", "package team.teampotato.minegpt.forge.forged.mixin;\n\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.network.ClientCommandSource;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.world.ClientWorld;", "import net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.world.ClientWorld;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\n\n@Mixin(ClientCommandSource.class)\nabstract class ClientCommandSourceMixin implements FabricClientCommandSource {\n    @Shadow", "abstract class ClientCommandSourceMixin implements FabricClientCommandSource {\n    @Shadow\n    @Final\n    private MinecraftClient client;\n\n    @Override\n    public void sendFeedback(Text message) {\n        this.client.inGameHud.getChatHud().addMessage(message);\n        this.client.getNarratorManager().narrate(message);\n    }\n\n    @Override", "    public void sendError(Text message) {\n        sendFeedback(Text.literal(\"\").append(message).formatted(Formatting.RED));\n    }\n\n    @Override\n    public MinecraftClient getClient() {\n        return client;\n    }\n\n    @Override\n    public ClientPlayerEntity getPlayer() {\n        return client.player;\n    }\n\n    @Override", "    public ClientPlayerEntity getPlayer() {\n        return client.player;\n    }\n\n    @Override\n    public ClientWorld getWorld() {\n        return client.world;\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/mixin/ClientPlayerEntityMixin.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.mixin;\n", "package team.teampotato.minegpt.forge.forged.mixin;\n\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.text.Text;", "import net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.text.Text;\n\nimport team.teampotato.minegpt.forge.forged.impl.ClientCommandInternals;\n\n\n@Mixin(ClientPlayerEntity.class)\nabstract class ClientPlayerEntityMixin {\n    @Inject(method = \"sendCommand(Ljava/lang/String;)Z\", at = @At(\"HEAD\"), cancellable = true)\n    private void onSendCommand(String command, CallbackInfoReturnable<Boolean> cir) {\n        if (ClientCommandInternals.executeCommand(command)) {\n            cir.setReturnValue(true);\n        }\n    }\n\n    @Inject(method = \"sendCommand(Ljava/lang/String;Lnet/minecraft/text/Text;)V\", at = @At(\"HEAD\"), cancellable = true)\n    private void onSendCommand(String command, Text preview, CallbackInfo info) {", "    @Inject(method = \"sendCommand(Ljava/lang/String;)Z\", at = @At(\"HEAD\"), cancellable = true)\n    private void onSendCommand(String command, CallbackInfoReturnable<Boolean> cir) {\n        if (ClientCommandInternals.executeCommand(command)) {\n            cir.setReturnValue(true);\n        }\n    }\n\n    @Inject(method = \"sendCommand(Ljava/lang/String;Lnet/minecraft/text/Text;)V\", at = @At(\"HEAD\"), cancellable = true)\n    private void onSendCommand(String command, Text preview, CallbackInfo info) {\n        if (ClientCommandInternals.executeCommand(command)) {\n            info.cancel();\n        }\n    }\n}\n", "        if (ClientCommandInternals.executeCommand(command)) {\n            info.cancel();\n        }\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/mixin/HelpCommandAccessor.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.mixin;\n", "package team.teampotato.minegpt.forge.forged.mixin;\n\nimport com.mojang.brigadier.exceptions.SimpleCommandExceptionType;\n\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\n\nimport net.minecraft.server.command.HelpCommand;\n\n@Mixin(HelpCommand.class)\npublic interface HelpCommandAccessor {\n    @Accessor(\"FAILED_EXCEPTION\")\n    static SimpleCommandExceptionType getFailedException() {\n        throw new AssertionError(\"mixin\");\n    }\n}\n", "\n@Mixin(HelpCommand.class)\npublic interface HelpCommandAccessor {\n    @Accessor(\"FAILED_EXCEPTION\")\n    static SimpleCommandExceptionType getFailedException() {\n        throw new AssertionError(\"mixin\");\n    }\n}\n"]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/mixin/ClientPlayNetworkHandlerMixin.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.mixin;\n", "package team.teampotato.minegpt.forge.forged.mixin;\n\nimport com.mojang.brigadier.CommandDispatcher;\n\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;", "import org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\nimport net.minecraft.client.network.ClientCommandSource;\nimport net.minecraft.client.network.ClientPlayNetworkHandler;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.command.CommandSource;\nimport net.minecraft.network.packet.s2c.play.CommandTreeS2CPacket;\nimport net.minecraft.network.packet.s2c.play.GameJoinS2CPacket;\n", "import net.minecraft.network.packet.s2c.play.GameJoinS2CPacket;\n\nimport team.teampotato.minegpt.forge.forged.api.ClientCommandRegistrationEvent;\nimport team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\nimport team.teampotato.minegpt.forge.forged.impl.ClientCommandInternals;\n\n@Mixin(ClientPlayNetworkHandler.class)\nabstract class ClientPlayNetworkHandlerMixin {\n    @Shadow\n    private CommandDispatcher<CommandSource> commandDispatcher;", "    @Shadow\n    private CommandDispatcher<CommandSource> commandDispatcher;\n\n    @Shadow\n    @Final\n    private ClientCommandSource commandSource;\n\n    @Inject(method = \"onGameJoin\", at = @At(\"RETURN\"))\n    private void onGameJoin(GameJoinS2CPacket packet, CallbackInfo info) {\n        final CommandDispatcher<FabricClientCommandSource> dispatcher = new CommandDispatcher<>();", "    private void onGameJoin(GameJoinS2CPacket packet, CallbackInfo info) {\n        final CommandDispatcher<FabricClientCommandSource> dispatcher = new CommandDispatcher<>();\n        ClientCommandInternals.setActiveDispatcher(dispatcher);\n        ClientCommandRegistrationEvent.EVENT.invoker().register(dispatcher, new CommandRegistryAccess(packet.registryManager()));\n        ClientCommandInternals.finalizeInit();\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Inject(method = \"onCommandTree\", at = @At(\"RETURN\"))\n    private void onOnCommandTree(CommandTreeS2CPacket packet, CallbackInfo info) {", "    @Inject(method = \"onCommandTree\", at = @At(\"RETURN\"))\n    private void onOnCommandTree(CommandTreeS2CPacket packet, CallbackInfo info) {\n        // Add the commands to the vanilla dispatcher for completion.\n        // It's done here because both the server and the client commands have\n        // to be in the same dispatcher and completion results.\n        ClientCommandInternals.addCommands((CommandDispatcher) commandDispatcher, (FabricClientCommandSource) commandSource);\n    }\n}\n", ""]}
{"filename": "forge/src/main/java/team/teampotato/minegpt/forge/forged/impl/ClientCommandInternals.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage team.teampotato.minegpt.forge.forged.impl;\n", "package team.teampotato.minegpt.forge.forged.impl;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.common.collect.Iterables;\nimport com.mojang.brigadier.AmbiguityConsumer;\nimport com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.ParseResults;", "import com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.ParseResults;\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport com.mojang.brigadier.builder.ArgumentBuilder;\nimport com.mojang.brigadier.builder.LiteralArgumentBuilder;\nimport com.mojang.brigadier.context.CommandContext;\nimport com.mojang.brigadier.context.ParsedCommandNode;\nimport com.mojang.brigadier.exceptions.BuiltInExceptionProvider;\nimport com.mojang.brigadier.exceptions.CommandExceptionType;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;", "import com.mojang.brigadier.exceptions.CommandExceptionType;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport com.mojang.brigadier.tree.CommandNode;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.api.distmarker.OnlyIn;\n", "import net.minecraftforge.api.distmarker.OnlyIn;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandException;\nimport net.minecraft.text.Text;\nimport net.minecraft.text.Texts;\n\nimport team.teampotato.minegpt.forge.forged.api.ClientCommandManager;\nimport team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\nimport team.teampotato.minegpt.forge.forged.mixin.HelpCommandAccessor;", "import team.teampotato.minegpt.forge.forged.api.FabricClientCommandSource;\nimport team.teampotato.minegpt.forge.forged.mixin.HelpCommandAccessor;\n\n@OnlyIn(Dist.CLIENT)\npublic final class ClientCommandInternals {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ClientCommandInternals.class);\n    private static final String API_COMMAND_NAME = \"fabric-command-api-v2:client\";\n    private static final String SHORT_API_COMMAND_NAME = \"fcc\";\n    private static @Nullable CommandDispatcher<FabricClientCommandSource> activeDispatcher;\n\n    public static void setActiveDispatcher(@Nullable CommandDispatcher<FabricClientCommandSource> dispatcher) {\n        ClientCommandInternals.activeDispatcher = dispatcher;\n    }\n\n    public static @Nullable CommandDispatcher<FabricClientCommandSource> getActiveDispatcher() {\n        return activeDispatcher;\n    }\n\n    /**\n     * Executes a client-sided command. Callers should ensure that this is only called\n     * on slash-prefixed messages and the slash needs to be removed before calling.\n     * (This is the same requirement as {@code ClientPlayerEntity#sendCommand}.)\n     *\n     * @param command the command with slash removed\n     * @return true if the command should not be sent to the server, false otherwise\n     */", "    public static void setActiveDispatcher(@Nullable CommandDispatcher<FabricClientCommandSource> dispatcher) {\n        ClientCommandInternals.activeDispatcher = dispatcher;\n    }\n\n    public static @Nullable CommandDispatcher<FabricClientCommandSource> getActiveDispatcher() {\n        return activeDispatcher;\n    }\n\n    /**\n     * Executes a client-sided command. Callers should ensure that this is only called\n     * on slash-prefixed messages and the slash needs to be removed before calling.\n     * (This is the same requirement as {@code ClientPlayerEntity#sendCommand}.)\n     *\n     * @param command the command with slash removed\n     * @return true if the command should not be sent to the server, false otherwise\n     */", "    public static boolean executeCommand(String command) {\n        MinecraftClient client = MinecraftClient.getInstance();\n\n        // The interface is implemented on ClientCommandSource with a mixin.\n        // noinspection ConstantConditions\n        FabricClientCommandSource commandSource = (FabricClientCommandSource) client.getNetworkHandler().getCommandSource();\n\n        client.getProfiler().push(command);\n\n        try {\n            // TODO: Check for server commands before executing.\n            //   This requires parsing the command, checking if they match a server command\n            //   and then executing the command with the parse results.\n            activeDispatcher.execute(command, commandSource);\n            return true;\n        } catch (CommandSyntaxException e) {\n            boolean ignored = isIgnoredException(e.getType());\n", "        try {\n            // TODO: Check for server commands before executing.\n            //   This requires parsing the command, checking if they match a server command\n            //   and then executing the command with the parse results.\n            activeDispatcher.execute(command, commandSource);\n            return true;\n        } catch (CommandSyntaxException e) {\n            boolean ignored = isIgnoredException(e.getType());\n\n            if (ignored) {\n                LOGGER.debug(\"Syntax exception for client-sided command '{}'\", command, e);\n                return false;\n            }\n\n            LOGGER.warn(\"Syntax exception for client-sided command '{}'\", command, e);\n            commandSource.sendError(getErrorMessage(e));\n            return true;\n        } catch (CommandException e) {\n            LOGGER.warn(\"Error while executing client-sided command '{}'\", command, e);\n            commandSource.sendError(e.getTextMessage());\n            return true;\n        } catch (RuntimeException e) {\n            LOGGER.warn(\"Error while executing client-sided command '{}'\", command, e);\n            commandSource.sendError(Text.of(e.getMessage()));\n            return true;\n        } finally {\n            client.getProfiler().pop();\n        }\n    }\n\n    /**\n     * Tests whether a command syntax exception with the type\n     * should be ignored and the command sent to the server.\n     *\n     * @param type the exception type\n     * @return true if ignored, false otherwise\n     */\n    private static boolean isIgnoredException(CommandExceptionType type) {\n        BuiltInExceptionProvider builtins = CommandSyntaxException.BUILT_IN_EXCEPTIONS;\n\n        // Only ignore unknown commands and node parse exceptions.\n        // The argument-related dispatcher exceptions are not ignored because\n        // they will only happen if the user enters a correct command.\n        return type == builtins.dispatcherUnknownCommand() || type == builtins.dispatcherParseException();\n    }\n\n    // See ChatInputSuggestor.formatException. That cannot be used directly as it returns an OrderedText instead of a Text.\n    private static Text getErrorMessage(CommandSyntaxException e) {\n        Text message = Texts.toText(e.getRawMessage());\n        String context = e.getContext();\n\n        return context != null ? Text.translatable(\"command.context.parse_error\", message, context) : message;\n    }\n\n    /**\n     * Runs final initialization tasks such as {@link CommandDispatcher#findAmbiguities(AmbiguityConsumer)}\n     * on the command dispatcher. Also registers a {@code /fcc help} command if there are other commands present.\n     */", "            if (ignored) {\n                LOGGER.debug(\"Syntax exception for client-sided command '{}'\", command, e);\n                return false;\n            }\n\n            LOGGER.warn(\"Syntax exception for client-sided command '{}'\", command, e);\n            commandSource.sendError(getErrorMessage(e));\n            return true;\n        } catch (CommandException e) {\n            LOGGER.warn(\"Error while executing client-sided command '{}'\", command, e);\n            commandSource.sendError(e.getTextMessage());\n            return true;\n        } catch (RuntimeException e) {\n            LOGGER.warn(\"Error while executing client-sided command '{}'\", command, e);\n            commandSource.sendError(Text.of(e.getMessage()));\n            return true;\n        } finally {\n            client.getProfiler().pop();\n        }\n    }\n\n    /**\n     * Tests whether a command syntax exception with the type\n     * should be ignored and the command sent to the server.\n     *\n     * @param type the exception type\n     * @return true if ignored, false otherwise\n     */\n    private static boolean isIgnoredException(CommandExceptionType type) {\n        BuiltInExceptionProvider builtins = CommandSyntaxException.BUILT_IN_EXCEPTIONS;\n\n        // Only ignore unknown commands and node parse exceptions.\n        // The argument-related dispatcher exceptions are not ignored because\n        // they will only happen if the user enters a correct command.\n        return type == builtins.dispatcherUnknownCommand() || type == builtins.dispatcherParseException();\n    }\n\n    // See ChatInputSuggestor.formatException. That cannot be used directly as it returns an OrderedText instead of a Text.\n    private static Text getErrorMessage(CommandSyntaxException e) {\n        Text message = Texts.toText(e.getRawMessage());\n        String context = e.getContext();\n\n        return context != null ? Text.translatable(\"command.context.parse_error\", message, context) : message;\n    }\n\n    /**\n     * Runs final initialization tasks such as {@link CommandDispatcher#findAmbiguities(AmbiguityConsumer)}\n     * on the command dispatcher. Also registers a {@code /fcc help} command if there are other commands present.\n     */", "    public static void finalizeInit() {\n        if (!activeDispatcher.getRoot().getChildren().isEmpty()) {\n            // Register an API command if there are other commands;\n            // these helpers are not needed if there are no client commands\n            LiteralArgumentBuilder<FabricClientCommandSource> help = ClientCommandManager.literal(\"help\");\n            help.executes(ClientCommandInternals::executeRootHelp);\n            help.then(ClientCommandManager.argument(\"command\", StringArgumentType.greedyString()).executes(ClientCommandInternals::executeArgumentHelp));\n\n            CommandNode<FabricClientCommandSource> mainNode = activeDispatcher.register(ClientCommandManager.literal(API_COMMAND_NAME).then(help));\n            activeDispatcher.register(ClientCommandManager.literal(SHORT_API_COMMAND_NAME).redirect(mainNode));\n        }\n\n        // noinspection CodeBlock2Expr\n        activeDispatcher.findAmbiguities((parent, child, sibling, inputs) -> {\n            LOGGER.warn(\"Ambiguity between arguments {} and {} with inputs: {}\", activeDispatcher.getPath(child), activeDispatcher.getPath(sibling), inputs);\n        });\n    }\n\n    private static int executeRootHelp(CommandContext<FabricClientCommandSource> context) {\n        return executeHelp(activeDispatcher.getRoot(), context);\n    }\n\n    private static int executeArgumentHelp(CommandContext<FabricClientCommandSource> context) throws CommandSyntaxException {\n        ParseResults<FabricClientCommandSource> parseResults = activeDispatcher.parse(StringArgumentType.getString(context, \"command\"), context.getSource());\n        List<ParsedCommandNode<FabricClientCommandSource>> nodes = parseResults.getContext().getNodes();\n", "        if (nodes.isEmpty()) {\n            throw HelpCommandAccessor.getFailedException().create();\n        }\n\n        return executeHelp(Iterables.getLast(nodes).getNode(), context);\n    }\n\n    private static int executeHelp(CommandNode<FabricClientCommandSource> startNode, CommandContext<FabricClientCommandSource> context) {\n        Map<CommandNode<FabricClientCommandSource>, String> commands = activeDispatcher.getSmartUsage(startNode, context.getSource());\n\n        for (String command : commands.values()) {\n            context.getSource().sendFeedback(Text.literal(\"/\" + command));\n        }\n\n        return commands.size();\n    }\n", "        for (String command : commands.values()) {\n            context.getSource().sendFeedback(Text.literal(\"/\" + command));\n        }\n\n        return commands.size();\n    }\n\n    public static void addCommands(CommandDispatcher<FabricClientCommandSource> target, FabricClientCommandSource source) {\n        Map<CommandNode<FabricClientCommandSource>, CommandNode<FabricClientCommandSource>> originalToCopy = new HashMap<>();\n        originalToCopy.put(activeDispatcher.getRoot(), target.getRoot());\n        copyChildren(activeDispatcher.getRoot(), target.getRoot(), source, originalToCopy);\n    }\n\n    /**\n     * Copies the child commands from origin to target, filtered by {@code child.canUse(source)}.\n     * Mimics vanilla's CommandManager.makeTreeForSource.\n     *\n     * @param origin         the source command node\n     * @param target         the target command node\n     * @param source         the command source\n     * @param originalToCopy a mutable map from original command nodes to their copies, used for redirects;\n     *                       should contain a mapping from origin to target\n     */\n    private static void copyChildren(\n            CommandNode<FabricClientCommandSource> origin,\n            CommandNode<FabricClientCommandSource> target,\n            FabricClientCommandSource source,\n            Map<CommandNode<FabricClientCommandSource>, CommandNode<FabricClientCommandSource>> originalToCopy\n    ) {", "        for (CommandNode<FabricClientCommandSource> child : origin.getChildren()) {\n            if (!child.canUse(source)) continue;\n\n            ArgumentBuilder<FabricClientCommandSource, ?> builder = child.createBuilder();\n\n            // Reset the unnecessary non-completion stuff from the builder\n            builder.requires(s -> true); // This is checked with the if check above.\n\n            if (builder.getCommand() != null) {\n                builder.executes(context -> 0);\n            }\n\n            // Set up redirects", "            if (builder.getCommand() != null) {\n                builder.executes(context -> 0);\n            }\n\n            // Set up redirects\n            if (builder.getRedirect() != null) {\n                builder.redirect(originalToCopy.get(builder.getRedirect()));\n            }\n\n            CommandNode<FabricClientCommandSource> result = builder.build();\n            originalToCopy.put(child, result);\n            target.addChild(result);\n", "            if (!child.getChildren().isEmpty()) {\n                copyChildren(child, result, source, originalToCopy);\n            }\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/MineGPT.java", "chunked_list": ["package team.teampotato.minegpt;\n\nimport dev.architectury.event.events.common.CommandRegistrationEvent;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport team.teampotato.minegpt.command.ServerCommand;\nimport team.teampotato.minegpt.command.ServerConfigCommand;\nimport team.teampotato.minegpt.config.Config;", "import team.teampotato.minegpt.command.ServerConfigCommand;\nimport team.teampotato.minegpt.config.Config;\n\npublic class MineGPT {\n    public static final String MOD_ID = \"minegpt\";\n    public static final String MOD_NAME = \"MineGPT\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_NAME);\n\n    public static void init() {\n        Config.onInitialize();\n        CommandRegistrationEvent.EVENT.register(ServerCommand::registerCommand);\n        CommandRegistrationEvent.EVENT.register(ServerConfigCommand::registerCommand);\n    }\n}\n", "    public static void init() {\n        Config.onInitialize();\n        CommandRegistrationEvent.EVENT.register(ServerCommand::registerCommand);\n        CommandRegistrationEvent.EVENT.register(ServerConfigCommand::registerCommand);\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/MineGPTClient.java", "chunked_list": ["package team.teampotato.minegpt;\n\nimport team.teampotato.minegpt.screen.Ping;\n\npublic class MineGPTClient {\n    public static void clientInit() {\n        Ping.onInitializeClient();\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/config/Config.java", "chunked_list": ["package team.teampotato.minegpt.config;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonObject;\nimport team.teampotato.minegpt.MineGPT;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;", "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Locale;\n\npublic class Config {\n    public static String ENDPOINT = \"https://api.openai.com/v1/completions\";\n    public static String API_KEY = \"Your OpenAI API\";\n    public static String MODEL = \"text-davinci-003\";\n    public static String MAX_TOKENS = \"1024\";\n    public static String N = \"1\";", "    public static String MODEL = \"text-davinci-003\";\n    public static String MAX_TOKENS = \"1024\";\n    public static String N = \"1\";\n    public static final String JSON = \"MineGPT.json\";\n    public static int Ping = 10;\n    static Locale defaultLocale = Locale.getDefault();\n    static String language = defaultLocale.getLanguage();\n\n\n    public static void onInitialize() {\n        MineGPT.LOGGER.info(\"Your system language is: \" + language);\n        loadConfig();\n    }\n", "    public static void onInitialize() {\n        MineGPT.LOGGER.info(\"Your system language is: \" + language);\n        loadConfig();\n    }\n\n    public static void loadConfig() {\n        File configFolder = new File(\"config\" + File.separator + \"MineGPT\");\n        if (!configFolder.exists()) {\n            configFolder.mkdirs();\n        }\n\n        File configFile = new File(configFolder, JSON);", "        if (configFile.exists()) {\n            try (FileReader reader = new FileReader(configFile)) {\n                MineGPT.LOGGER.info(\"Loading configuration file...\");\n                JsonObject config = new Gson().fromJson(reader, JsonObject.class);\n                ENDPOINT = config.get(\"API_Link\").getAsString();\n                API_KEY = config.get(\"API_KEY\").getAsString();\n                MODEL = config.get(\"MODEL\").getAsString();\n                MAX_TOKENS = config.get(\"MAX_TOKENS\").getAsString();\n                N = config.get(\"N\").getAsString();\n                Ping = config.get(\"Ping\").getAsInt();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n                MineGPT.LOGGER.error(\"Failed to load configuration file!\" + e);\n            }\n        } else {", "            try {\n                MineGPT.LOGGER.info(\"Generating configuration file...\");\n                configFile.createNewFile();\n                JsonObject config = new JsonObject();\n                config.addProperty(\"API_Link\",\"https://api.openai.com/v1/completions\");\n                config.addProperty(\"API_KEY\", \"Your OpenAI API\");\n                config.addProperty(\"MODEL\", \"gpt-3.5-turbo\");\n                config.addProperty(\"MAX_TOKENS\",\"1024\");\n                config.addProperty(\"N\",\"1\");\n                config.addProperty(\"Ping\",10);\n\n\n                try (FileWriter writer = new FileWriter(configFile)) {\n                    writer.write(new GsonBuilder().setPrettyPrinting().create().toJson(config));\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                MineGPT.LOGGER.info(\"Error generating configuration file!\" + e);\n            }\n        }\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/command/ServerCommand.java", "chunked_list": ["package team.teampotato.minegpt.command;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.server.command.CommandManager;\nimport net.minecraft.server.command.ServerCommandSource;", "import net.minecraft.server.command.CommandManager;\nimport net.minecraft.server.command.ServerCommandSource;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\nimport org.json.JSONObject;\n\nimport team.teampotato.minegpt.MineGPT;\nimport team.teampotato.minegpt.config.Config;\n\nimport java.net.URI;", "\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\n\npublic class ServerCommand {", "import java.util.concurrent.CompletableFuture;\n\npublic class ServerCommand {\n    public static void registerCommand(CommandDispatcher<ServerCommandSource> dispatcher, CommandRegistryAccess registry, CommandManager.RegistrationEnvironment selection) {\n        if (selection.dedicated) {\n            dispatcher.register(CommandManager.literal(\"chatgpt\")\n                    .then(CommandManager.argument(\"message\", StringArgumentType.string())\n                            .executes(context -> {\n                                try {\n                                    String message = StringArgumentType.getString(context, \"message\");\n                                    String prompt = generatePrompt(message);\n                                    CompletableFuture<String> future = getChatGPTResponse(prompt);\n                                    future.thenAcceptAsync(response -> {\n                                        String playerName = Objects.requireNonNull(context.getSource().getPlayer()).getName().getString();\n\n                                        context.getSource().sendFeedback(Text.literal(\"[\" + playerName + \"] -> \").formatted(Formatting.GREEN)\n                                                .append(Text.literal(message).formatted(Formatting.AQUA)), false);\n                                        context.getSource().sendFeedback(Text.literal(\"[ChatGPT-\" + Config.MODEL + \"] -> \" + \"[\" + playerName + \"]\" + \": \").formatted(Formatting.GOLD)\n                                                .append(Text.literal(\"\\\"\" + response + \"\\\"\").formatted(Formatting.YELLOW)), false);\n\n                                    });\n                                    return 1;\n                                } catch (Exception e) {\n                                    e.printStackTrace();\n                                    return 0;\n                                }\n                            })\n                    )\n            );\n        }\n    }\n\n    private static String generatePrompt(String message) {\n        return URLEncoder.encode(message, StandardCharsets.UTF_8);\n    }\n    private static CompletableFuture<String> getChatGPTResponse(String message) {\n        return CompletableFuture.supplyAsync(() -> {\n            String prompt = \"User: \" + message + \"\\nChatGPT:\";\n            JSONObject requestData = new JSONObject()\n                    .put(\"model\", Config.MODEL)\n                    .put(\"prompt\", prompt)\n                    .put(\"max_tokens\", Integer.parseInt(Config.MAX_TOKENS))\n                    .put(\"n\", Integer.parseInt(Config.N))\n                    .put(\"stop\", \"\\n\");", "                                try {\n                                    String message = StringArgumentType.getString(context, \"message\");\n                                    String prompt = generatePrompt(message);\n                                    CompletableFuture<String> future = getChatGPTResponse(prompt);\n                                    future.thenAcceptAsync(response -> {\n                                        String playerName = Objects.requireNonNull(context.getSource().getPlayer()).getName().getString();\n\n                                        context.getSource().sendFeedback(Text.literal(\"[\" + playerName + \"] -> \").formatted(Formatting.GREEN)\n                                                .append(Text.literal(message).formatted(Formatting.AQUA)), false);\n                                        context.getSource().sendFeedback(Text.literal(\"[ChatGPT-\" + Config.MODEL + \"] -> \" + \"[\" + playerName + \"]\" + \": \").formatted(Formatting.GOLD)\n                                                .append(Text.literal(\"\\\"\" + response + \"\\\"\").formatted(Formatting.YELLOW)), false);\n\n                                    });\n                                    return 1;\n                                } catch (Exception e) {\n                                    e.printStackTrace();\n                                    return 0;\n                                }\n                            })\n                    )\n            );\n        }\n    }\n\n    private static String generatePrompt(String message) {\n        return URLEncoder.encode(message, StandardCharsets.UTF_8);\n    }\n    private static CompletableFuture<String> getChatGPTResponse(String message) {\n        return CompletableFuture.supplyAsync(() -> {\n            String prompt = \"User: \" + message + \"\\nChatGPT:\";\n            JSONObject requestData = new JSONObject()\n                    .put(\"model\", Config.MODEL)\n                    .put(\"prompt\", prompt)\n                    .put(\"max_tokens\", Integer.parseInt(Config.MAX_TOKENS))\n                    .put(\"n\", Integer.parseInt(Config.N))\n                    .put(\"stop\", \"\\n\");", "            try {\n                HttpClient client = HttpClient.newHttpClient();\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(Config.ENDPOINT))\n                        .header(\"Content-Type\", \"application/json\")\n                        .header(\"Authorization\", \"Bearer \" + Config.API_KEY)\n                        .POST(HttpRequest.BodyPublishers.ofString(requestData.toString()))\n                        .build();\n                HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n                JsonObject responseJson = JsonParser.parseString(response.body()).getAsJsonObject();\n                JsonArray choices = responseJson.getAsJsonArray(\"choices\");\n                MineGPT.LOGGER.info(\"Received response from ChatGPT API\" + response);\n", "                if (choices == null || choices.size() == 0) {\n                    return \"Failed to get a response from OpenAI API.\";\n                }\n                JsonArray choices2 = responseJson.getAsJsonArray(\"choices\");\n                JsonObject choice = choices2.get(0).getAsJsonObject();\n                //String responseText = choice.get(\"text\").getAsString().replaceAll(\"\\\"\", \"\").replaceAll(\"'\", \"\\\"\").trim();\n                String responseText = choice.get(\"text\").getAsString().trim();\n                MineGPT.LOGGER.info(\"Generated response: \" + responseText);\n                return responseText;\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                return \"An error occurred while processing the request.\";\n            }\n        });\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/command/ServerConfigCommand.java", "chunked_list": ["package team.teampotato.minegpt.command;\n\nimport com.mojang.brigadier.CommandDispatcher;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.server.command.CommandManager;\nimport net.minecraft.server.command.ServerCommandSource;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n", "import net.minecraft.util.Formatting;\n\nimport team.teampotato.minegpt.config.Config;\n\npublic class ServerConfigCommand {\n    public static void registerCommand(CommandDispatcher<ServerCommandSource> dispatcher, CommandRegistryAccess registry, CommandManager.RegistrationEnvironment selection) {\n        dispatcher.register(CommandManager.literal(\"mgpt\")\n                .then(CommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.1\").formatted(Formatting.GREEN),false);\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.2\").formatted(Formatting.GREEN),false);\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.3\").formatted(Formatting.GREEN),false);\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.4\").formatted(Formatting.GREEN),false);\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.5\").formatted(Formatting.GREEN),false);\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.help.6\").formatted(Formatting.GREEN),false);\n\n\n                            return 1;\n                        }))\n\n                .then(CommandManager.literal(\"config\"))\n                .then(CommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.server.command.reload\").formatted(Formatting.BLUE),false));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/screen/Ping.java", "chunked_list": ["package team.teampotato.minegpt.screen;\n\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport team.teampotato.minegpt.config.Config;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n@Environment(EnvType.CLIENT)\npublic class Ping {", "\n@Environment(EnvType.CLIENT)\npublic class Ping {\n    public static void onInitializeClient() {\n        ipDetection(Config.Ping);\n    }\n    public static boolean status = false;\n    public static boolean ipDetection(int timeout) {\n        try {\n            status = InetAddress.getByName(Config.ENDPOINT).isReachable(timeout);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return status;\n    }\n}\n", "        try {\n            status = InetAddress.getByName(Config.ENDPOINT).isReachable(timeout);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return status;\n    }\n}\n"]}
{"filename": "common/src/main/java/team/teampotato/minegpt/screen/PingScreen.java", "chunked_list": ["package team.teampotato.minegpt.screen;\n\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\n\nimport net.minecraft.client.gui.screen.Screen;\nimport net.minecraft.client.gui.widget.ButtonWidget;\nimport net.minecraft.client.util.math.MatrixStack;\nimport net.minecraft.text.Text;\n", "import net.minecraft.text.Text;\n\nimport team.teampotato.minegpt.config.Config;\n\n@Environment(EnvType.CLIENT)\npublic class PingScreen extends Screen {\n    public PingScreen() {\n        super(Text.literal(\"PingGUI\"));\n    }\n    @Override\n    protected void init() {\n        super.init();\n\n        // \u6dfb\u52a0\u4e24\u4e2a\u6309\u94ae\n        int buttonWidth = 100; //\u5bbd\u5ea6\n        int buttonHeight = 20; //\u9ad8\u5ea6\n        int centerX = (this.width) / 2;\n        int centerY = (this.height) / 2;\n        this.addCustomButton(new ButtonWidget(centerX, centerY, buttonWidth, buttonHeight, Text.translatable(\"MultiuniverseEonAdventureCore.Disk.SafeMode.YES\"), button -> {\n            assert this.client != null;\n            this.client.setScreen(null); // \u8fd4\u56de\n\n        }));\n    }\n    @Override", "    public void render(MatrixStack matrices, int mouseX, int mouseY, float delta) {\n        this.renderBackground(matrices);\n        super.render(matrices, mouseX, mouseY, delta);\n        Text text = Text.translatable(\"minegpt.gui.ping.title\", Config.ENDPOINT, Ping.status);\n        int textX = (this.width - this.textRenderer.getWidth(text)) / 2;\n        int textY = this.height / 4;\n        this.textRenderer.drawWithShadow(matrices, text, textX, textY, 0xFFFFFF);\n    }\n\n    public void addCustomButton(ButtonWidget button) {\n            this.addDrawableChild(button);\n        }\n}\n", "    public void addCustomButton(ButtonWidget button) {\n            this.addDrawableChild(button);\n        }\n}\n"]}
{"filename": "fabric/src/main/java/team/teampotato/minegpt/fabric/MineGPTClientFabric.java", "chunked_list": ["package team.teampotato.minegpt.fabric;\n\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.fabric.api.client.command.v2.ClientCommandRegistrationCallback;\n\nimport team.teampotato.minegpt.MineGPTClient;\nimport team.teampotato.minegpt.fabric.command.ClientCommand;\nimport team.teampotato.minegpt.fabric.command.ClientConfigCommand;\n\npublic class MineGPTClientFabric implements ClientModInitializer {\n    @Override", "\npublic class MineGPTClientFabric implements ClientModInitializer {\n    @Override\n    public void onInitializeClient() {\n        MineGPTClient.clientInit();\n        ClientCommandRegistrationCallback.EVENT.register(ClientCommand::registerCommand);\n        ClientCommandRegistrationCallback.EVENT.register(ClientConfigCommand::registerCommand);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/team/teampotato/minegpt/fabric/MineGPTFabric.java", "chunked_list": ["package team.teampotato.minegpt.fabric;\n\nimport team.teampotato.minegpt.MineGPT;\nimport net.fabricmc.api.ModInitializer;\n\npublic class MineGPTFabric implements ModInitializer {\n    @Override\n    public void onInitialize() {\n        MineGPT.init();\n\n    }\n}\n"]}
{"filename": "fabric/src/main/java/team/teampotato/minegpt/fabric/command/ClientCommand.java", "chunked_list": ["package team.teampotato.minegpt.fabric.command;\n\nimport com.mojang.brigadier.CommandDispatcher;\n\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.fabricmc.fabric.api.client.command.v2.ClientCommandManager;\nimport net.fabricmc.fabric.api.client.command.v2.FabricClientCommandSource;\n\nimport net.minecraft.client.MinecraftClient;", "\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\n\nimport team.teampotato.minegpt.config.Config;\nimport team.teampotato.minegpt.screen.PingScreen;\n\n@Environment(EnvType.CLIENT)\npublic class ClientCommand {", "\n@Environment(EnvType.CLIENT)\npublic class ClientCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n"]}
{"filename": "fabric/src/main/java/team/teampotato/minegpt/fabric/command/ClientConfigCommand.java", "chunked_list": ["package team.teampotato.minegpt.fabric.command;\n\nimport com.mojang.brigadier.CommandDispatcher;\n\nimport net.fabricmc.api.EnvType;\nimport net.fabricmc.api.Environment;\nimport net.fabricmc.fabric.api.client.command.v2.ClientCommandManager;\nimport net.fabricmc.fabric.api.client.command.v2.FabricClientCommandSource;\n\nimport net.minecraft.client.MinecraftClient;", "\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.command.CommandRegistryAccess;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.Formatting;\nimport team.teampotato.minegpt.config.Config;\nimport team.teampotato.minegpt.screen.PingScreen;\n\n@Environment(EnvType.CLIENT)\npublic class ClientConfigCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n", "@Environment(EnvType.CLIENT)\npublic class ClientConfigCommand {\n    public static void registerCommand(CommandDispatcher<FabricClientCommandSource> dispatcher, CommandRegistryAccess registry) {\n        dispatcher.register(ClientCommandManager.literal(\"mgpt\")\n                .then(ClientCommandManager.literal(\"help\")\n                        .executes(context -> {\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.1\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.2\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.3\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.4\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.5\").formatted(Formatting.GREEN));\n                            context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.help.6\").formatted(Formatting.GREEN));\n\n\n                            return 1;\n                        }))\n                .then(ClientCommandManager.literal(\"pingtest\")\n                        .executes(context -> {\n                            MinecraftClient.getInstance().execute(() -> {\n                                MinecraftClient.getInstance().setScreen(new PingScreen());\n                                context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.ping\").formatted(Formatting.BLUE));\n                            });\n                            return 1;\n                        }))\n\n                .then(ClientCommandManager.literal(\"config\"))\n                .then(ClientCommandManager.literal(\"reload\")\n                        .executes(context -> {\n                            Config.loadConfig();\n                            MinecraftClient.getInstance().execute(() -> context.getSource().sendFeedback(Text.translatable(\"minegpt.client.command.reload\").formatted(Formatting.BLUE)));\n                            return 1;\n                        }))\n\n        );\n    }\n}\n"]}
