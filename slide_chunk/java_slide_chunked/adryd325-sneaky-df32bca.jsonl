{"filename": "src/main/java/com/adryd/sneaky/Config.java", "chunked_list": ["package com.adryd.sneaky;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Locale;\nimport java.util.Properties;\n\npublic class Config {\n    public static final Config INSTANCE = new Config();\n    private static final File FILE = new File(Sneaky.CONFIG_DIR, \"config.properties\");\n\n    private static boolean asBoolean(String property, boolean defValue) {", "\npublic class Config {\n    public static final Config INSTANCE = new Config();\n    private static final File FILE = new File(Sneaky.CONFIG_DIR, \"config.properties\");\n\n    private static boolean asBoolean(String property, boolean defValue) {\n        if (property == null || property.isEmpty()) {\n            return defValue;\n        } else {\n            switch (property.toLowerCase(Locale.ROOT)) {\n                case \"true\":\n                    return true;\n                case \"false\":\n                    return false;\n                default:\n                    return defValue;\n            }\n        }\n    }\n\n    private static int asInteger(String property, int defValue) {", "        if (property == null || property.isEmpty()) {\n            return defValue;\n        } else {\n            try {\n                return Integer.parseInt(property);\n            } catch (NumberFormatException ignored) {\n                return defValue;\n            }\n        }\n    }\n\n    private boolean hideServerPingData = true;\n    private boolean onlyHidePlayerList = false;\n    private boolean dontLogClientDisconnects = false;\n    private boolean dontLogServerDisconnects = false;\n    private boolean rateLimitNewConnections = true;\n    private int newConnectionRateLimit = 5;\n    private boolean disableAllPingsUntilLogin = false;\n    private boolean disableLegacyQuery = true;\n    private boolean disableConnectionsForBannedIps = false;\n\n", "    public void loadFromFile() {\n        Properties properties = new Properties();\n\n        if (FILE.exists()) {\n            try (FileInputStream stream = new FileInputStream(FILE)) {\n                properties.load(stream);\n            } catch (IOException e) {\n                Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \"] Could not read config file '\" + FILE.getAbsolutePath() + \"' :\", e);\n            }\n        }\n\n        hideServerPingData = asBoolean((String) properties.computeIfAbsent(\"hide-server-ping-data\", (a) -> \"true\"), true);\n        onlyHidePlayerList = asBoolean((String) properties.computeIfAbsent(\"hide-player-list\", (a) -> \"false\"), false);\n        dontLogClientDisconnects = asBoolean((String) properties.computeIfAbsent(\"dont-log-unauthed-client-disconnects\", (a) -> \"false\"), false);\n        dontLogServerDisconnects = asBoolean((String) properties.computeIfAbsent(\"dont-log-unauthed-server-disconnects\", (a) -> \"false\"), false);\n        rateLimitNewConnections = asBoolean((String) properties.computeIfAbsent(\"rate-limit-new-connections\", (a) -> \"true\"), true);\n        newConnectionRateLimit = asInteger((String) properties.computeIfAbsent(\"new-connection-rate-limit\", (a) -> \"6\"), 6);\n        disableAllPingsUntilLogin = asBoolean((String) properties.computeIfAbsent(\"disable-query-until-login\", (a) -> \"false\"), false);\n        disableLegacyQuery = asBoolean((String) properties.computeIfAbsent(\"disable-legacy-query\", (a) -> \"true\"), true);\n        disableConnectionsForBannedIps = asBoolean((String) properties.computeIfAbsent(\"disable-connections-from-banned-ips\", (a) -> \"false\"), false);\n\n        try (FileOutputStream stream = new FileOutputStream(FILE)) {\n            properties.store(stream, \"Sneaky Server properties file\\n\" +\n                    \"Please read https://github.com/adryd325/sneaky for more information, Not every config option is straight forward\");\n        } catch (IOException e) {\n            Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \"] Could not write config '\" + FILE.getAbsolutePath() + \"'\", e);\n        }\n    }\n", "    public boolean getHideServerPingData() {\n        return hideServerPingData;\n    }\n\n    public boolean getOnlyHidePlayerList() {\n        return onlyHidePlayerList;\n    }\n\n    public boolean getDontLogClientDisconnects() {\n        return dontLogClientDisconnects;\n    }\n", "    public boolean getDontLogClientDisconnects() {\n        return dontLogClientDisconnects;\n    }\n\n    public boolean getDontLogServerDisconnects() {\n        return dontLogServerDisconnects;\n    }\n\n    public boolean getRateLimitNewConnections() {\n        return rateLimitNewConnections;\n    }\n", "    public boolean getRateLimitNewConnections() {\n        return rateLimitNewConnections;\n    }\n\n    public int getNewConnectionRateLimit() {\n        return newConnectionRateLimit;\n    }\n\n    public boolean getDisableAllPingsUntilLogin() {\n        return disableAllPingsUntilLogin;\n    }\n", "    public boolean getDisableAllPingsUntilLogin() {\n        return disableAllPingsUntilLogin;\n    }\n\n    public boolean getDisableLegacyQuery() {\n        return disableLegacyQuery;\n    }\n\n    public boolean getDisableConnectionsForBannedIps() {\n        return disableConnectionsForBannedIps;\n    }\n}\n", "    public boolean getDisableConnectionsForBannedIps() {\n        return disableConnectionsForBannedIps;\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/IPList.java", "chunked_list": ["package com.adryd.sneaky;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;", "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IPList {\n    public static final IPList INSTANCE = new IPList();\n    private static final File OLD_FILE = Paths.get(\"allowed-ping-ips.csv\", new String[0]).toFile();\n    private static final File FILE = new File(Sneaky.CONFIG_DIR, \"allowed-ping-ips.csv\");\n    private static final long THIRTY_DAYS_MS = 2592000000l;\n\n    private Map<String, Long> ipList;\n    private boolean loaded;\n\n    IPList() {\n        this.ipList = new HashMap<>();\n        this.loaded = false;\n    }\n", "    public void migrateConfig() {\n        if (OLD_FILE.exists() && !FILE.exists() && Sneaky.CONFIG_DIR.exists()) {\n            OLD_FILE.renameTo(FILE);\n        }\n    }\n\n    public void loadFromFile() {\n        try {\n            String data = Files.readString(FILE.toPath());\n            if (data == null) {\n                return;\n            }\n            String[] lines = data.split(\"\\n\");", "            if (data == null) {\n                return;\n            }\n            String[] lines = data.split(\"\\n\");\n            for (String line : lines) {\n                if (line.startsWith(\"#\")) {\n                    continue;\n                }\n                String[] split = line.split(\",\");\n                if (split.length == 2) {\n                    this.ipList.put(split[0], Long.parseLong(split[1]));\n                }\n            }\n        } catch (NoSuchFileException e) {\n            this.loaded = true;\n            this.saveToFile(true);\n        } catch (IOException e) {\n            Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \" ] Failed to read allowed IPs list:\", e);\n        } catch (NumberFormatException e) {\n            Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \" ] Failed to parse allowed IPs list:\", e);\n        }\n        this.loaded = true;\n    }\n", "                if (split.length == 2) {\n                    this.ipList.put(split[0], Long.parseLong(split[1]));\n                }\n            }\n        } catch (NoSuchFileException e) {\n            this.loaded = true;\n            this.saveToFile(true);\n        } catch (IOException e) {\n            Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \" ] Failed to read allowed IPs list:\", e);\n        } catch (NumberFormatException e) {\n            Sneaky.LOGGER.warn(\"[\" + Sneaky.MOD_ID + \" ] Failed to parse allowed IPs list:\", e);\n        }\n        this.loaded = true;\n    }\n", "    public void saveToFile(boolean newFile) {\n        // Prevent overwriting the file with nothing if we haven't loaded it yet\n        if (!this.loaded) {\n            return;\n        }\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"# This file contains allowed IP addresses and their last login date in miliseconds.\\n\");\n        builder.append(\"# Setting lastLoginDate to 0 makes an IP never expire.\\n\");\n        builder.append(\"#ipAddress,lastLoginMiliseconds\\n\");\n\n        if (newFile) {\n            // Allow localhost to ping\n            // https://github.com/itzg/docker-minecraft-server/issues/2312\n            builder.append(\"127.0.0.1,0\\n\");\n            builder.append(\"0:0:0:0:0:0:0:1%0,0\\n\");\n        }\n\n        long writeTime = System.currentTimeMillis();\n        this.ipList.forEach((ip, lastLogin) -> {", "        if (newFile) {\n            // Allow localhost to ping\n            // https://github.com/itzg/docker-minecraft-server/issues/2312\n            builder.append(\"127.0.0.1,0\\n\");\n            builder.append(\"0:0:0:0:0:0:0:1%0,0\\n\");\n        }\n\n        long writeTime = System.currentTimeMillis();\n        this.ipList.forEach((ip, lastLogin) -> {\n            if (lastLogin == 0 || writeTime - lastLogin < THIRTY_DAYS_MS) {\n                builder.append(ip);\n                builder.append(\",\");\n                builder.append(lastLogin);\n                builder.append(\"\\n\");\n            }\n        });", "            if (lastLogin == 0 || writeTime - lastLogin < THIRTY_DAYS_MS) {\n                builder.append(ip);\n                builder.append(\",\");\n                builder.append(lastLogin);\n                builder.append(\"\\n\");\n            }\n        });\n        try {\n            Files.writeString(FILE.toPath(), builder.toString());\n        } catch (IOException e) {\n            Sneaky.LOGGER.error(\"[\" + Sneaky.MOD_ID + \" ] Failed to save allowed IPs list:\", e);\n        }\n    }\n", "    public void addToIPList(SocketAddress address) {\n        this.ipList.put(Sneaky.stringifyAddress(address), System.currentTimeMillis());\n    }\n\n    public boolean canPing(SocketAddress address) {\n        String ip = Sneaky.stringifyAddress(address);\n        if (this.ipList.containsKey(ip)) {\n            if (System.currentTimeMillis() - this.ipList.get(ip) < THIRTY_DAYS_MS || this.ipList.get(ip) == 0) {\n                return true;\n            }\n            this.ipList.remove(ip);\n        }\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/Sneaky.java", "chunked_list": ["package com.adryd.sneaky;\n\nimport net.fabricmc.api.ModInitializer;\nimport net.fabricmc.loader.api.FabricLoader;\nimport net.fabricmc.loader.api.Version;\nimport net.fabricmc.loader.api.metadata.ModMetadata;\nimport net.minecraft.server.MinecraftServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.HashMap;\n\npublic class Sneaky implements ModInitializer {\n    public static final String MOD_ID = \"sneakyserver\";\n    public static final String MOD_NAME;", "public class Sneaky implements ModInitializer {\n    public static final String MOD_ID = \"sneakyserver\";\n    public static final String MOD_NAME;\n    public static final Version MOD_VERSION;\n    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);\n\n    private static final FabricLoader loader = FabricLoader.getInstance();\n    public static final File CONFIG_DIR = loader.getConfigDir().resolve(MOD_ID).toFile();\n\n    private static final HashMap<InetAddress, Integer> rateLimitMap = new HashMap<>();\n    private static long rateLimitUpdateSecond = System.currentTimeMillis();\n\n    private static MinecraftServer server;\n\n    static {\n        ModMetadata metadata = loader.getModContainer(MOD_ID).orElseThrow(RuntimeException::new).getMetadata();\n        MOD_NAME = metadata.getName();\n        MOD_VERSION = metadata.getVersion();\n    }\n\n    // ??????", "    public static void setMinecraftServer(MinecraftServer server1) {\n        server = server1;\n    }\n\n    public static String stringifyAddress(SocketAddress address) {\n        String string = ((InetSocketAddress) address).getAddress().getHostAddress();\n        if (string.startsWith(\"/\")) {\n            string = string.substring(1);\n        }\n        return string;\n    }", "    public static boolean checkAllowConnection(SocketAddress address) {\n        if (Config.INSTANCE.getDisableConnectionsForBannedIps() && server != null && server.getPlayerManager() != null && server.getPlayerManager().getIpBanList().isBanned(address)) {\n            return false;\n        }\n        if (!Config.INSTANCE.getRateLimitNewConnections()) return true;\n        long now = System.currentTimeMillis();\n        if (now - rateLimitUpdateSecond > 15000) {\n            rateLimitMap.clear();\n            rateLimitUpdateSecond = now;\n            rateLimitMap.put(((InetSocketAddress) address).getAddress(), 1);\n            return true;\n        }\n        InetAddress inetAddress = ((InetSocketAddress) address).getAddress();", "        if (rateLimitMap.containsKey(inetAddress)) {\n            int attempts = rateLimitMap.get(inetAddress);\n            attempts++;\n            rateLimitMap.replace(inetAddress, attempts);\n            return attempts < Config.INSTANCE.getNewConnectionRateLimit();\n        } else {\n            rateLimitMap.put(inetAddress, 1);\n            return true;\n        }\n    }\n\n    @Override", "    public void onInitialize() {\n        // This code runs as soon as Minecraft is in a mod-load-ready state.\n        // However, some things (like resources) may still be uninitialized.\n        // Proceed with mild caution.\n\n        if (!CONFIG_DIR.exists()) {\n            if (!CONFIG_DIR.mkdir()) {\n                LOGGER.error(\"[\" + MOD_ID + \" ] Could not create configuration directory: \" + CONFIG_DIR.getAbsolutePath());\n            }\n        }\n\n        IPList.INSTANCE.migrateConfig();\n        IPList.INSTANCE.loadFromFile();\n        Config.INSTANCE.loadFromFile();\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinMinecraftDedicatedServer.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\n\nimport com.adryd.sneaky.Sneaky;\nimport net.minecraft.server.MinecraftServer;\nimport net.minecraft.server.dedicated.MinecraftDedicatedServer;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;", "import org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(MinecraftDedicatedServer.class)\npublic class MixinMinecraftDedicatedServer {\n    @Inject(method = \"setupServer\", at = @At(\"TAIL\"))\n    private void setMcServer(CallbackInfoReturnable<Boolean> cir) {\n        Sneaky.setMinecraftServer((MinecraftServer) (Object) this);\n    }\n\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinServerLoginNetworkHandler.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Config;\nimport com.adryd.sneaky.IPList;\nimport com.mojang.authlib.GameProfile;\nimport net.minecraft.network.ClientConnection;\nimport net.minecraft.server.MinecraftServer;\nimport net.minecraft.server.network.ServerLoginNetworkHandler;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;", "import org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.Redirect;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(ServerLoginNetworkHandler.class)\nclass MixinServerLoginNetworkHandler {\n    @Shadow\n    @Final\n    private ClientConnection connection;\n\n    @Shadow\n    private @Nullable GameProfile profile;", "    @Shadow\n    private @Nullable GameProfile profile;\n\n    @Shadow\n    @Final\n    private MinecraftServer server;\n\n    @Inject(method = \"acceptPlayer\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/server/network/ServerLoginNetworkHandler;addToServer(Lnet/minecraft/server/network/ServerPlayerEntity;)V\", shift = At.Shift.AFTER))\n    private void atSuccessfulJoin(CallbackInfo ci) {\n        IPList.INSTANCE.addToIPList(this.connection.getAddress());", "    private void atSuccessfulJoin(CallbackInfo ci) {\n        IPList.INSTANCE.addToIPList(this.connection.getAddress());\n    }\n\n    @Inject(method = \"onDisconnected\", at = @At(\"HEAD\"), cancellable = true)\n    private void disableLogClientDisconnect(CallbackInfo ci) {\n        // Should get around the login spam from bots like shepan and such\n        // Prevents logging client disconnections from users before they have authenticated\n        if (Config.INSTANCE.getDontLogClientDisconnects()) {\n            if (this.profile == null || !this.profile.isComplete() && this.server.isOnlineMode()) {\n                ci.cancel();\n            }\n        }\n    }\n\n    @Redirect(method = \"disconnect\", at = @At(value = \"INVOKE\", target = \"Lorg/slf4j/Logger;info(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V\"))\n    private void disableLogServerDisconnect(Logger instance, String template, Object connectionInfo, Object reason) {\n        // I feel that this is a really gross way of doing this but oh well\n        // Same as the above mixins but doesn't log serverside disconnections", "        if (Config.INSTANCE.getDontLogClientDisconnects()) {\n            if (this.profile == null || !this.profile.isComplete() && this.server.isOnlineMode()) {\n                ci.cancel();\n            }\n        }\n    }\n\n    @Redirect(method = \"disconnect\", at = @At(value = \"INVOKE\", target = \"Lorg/slf4j/Logger;info(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V\"))\n    private void disableLogServerDisconnect(Logger instance, String template, Object connectionInfo, Object reason) {\n        // I feel that this is a really gross way of doing this but oh well\n        // Same as the above mixins but doesn't log serverside disconnections", "        if (Config.INSTANCE.getDontLogServerDisconnects()) {\n            if (this.profile == null || !this.profile.isComplete() && this.server.isOnlineMode()) {\n                instance.info(template, connectionInfo, reason);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinServerHandshakeNetworkHandler.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Config;\nimport com.adryd.sneaky.IPList;\nimport net.minecraft.network.ClientConnection;\nimport net.minecraft.network.packet.c2s.handshake.HandshakeC2SPacket;\nimport net.minecraft.server.network.ServerHandshakeNetworkHandler;\nimport net.minecraft.text.Text;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;", "import org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\nimport org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n\n@Mixin(ServerHandshakeNetworkHandler.class)\npublic class MixinServerHandshakeNetworkHandler {\n\n    @Shadow\n    @Final\n    private ClientConnection connection;\n\n    @Shadow\n    @Final\n    private static Text IGNORING_STATUS_REQUEST_MESSAGE;\n\n    @Inject(method = \"onHandshake\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/ClientConnection;setState(Lnet/minecraft/network/NetworkState;)V\", ordinal = 1), locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n    private void acceptsQuery(HandshakeC2SPacket packet, CallbackInfo ci) {", "@Mixin(ServerHandshakeNetworkHandler.class)\npublic class MixinServerHandshakeNetworkHandler {\n\n    @Shadow\n    @Final\n    private ClientConnection connection;\n\n    @Shadow\n    @Final\n    private static Text IGNORING_STATUS_REQUEST_MESSAGE;\n\n    @Inject(method = \"onHandshake\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/ClientConnection;setState(Lnet/minecraft/network/NetworkState;)V\", ordinal = 1), locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n    private void acceptsQuery(HandshakeC2SPacket packet, CallbackInfo ci) {", "        if (Config.INSTANCE.getDisableAllPingsUntilLogin() && !IPList.INSTANCE.canPing(this.connection.getAddress())) {\n            this.connection.disconnect(IGNORING_STATUS_REQUEST_MESSAGE);\n            ci.cancel();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinMinecraftServer.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.IPList;\nimport net.minecraft.server.MinecraftServer;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(MinecraftServer.class)\npublic class MixinMinecraftServer {\n    @Inject(method = \"save\", at = @At(\"HEAD\"))\n    private void saveIPListAutoSave(boolean suppressLogs, boolean flush, boolean force, CallbackInfoReturnable<Boolean> cir) {\n        IPList.INSTANCE.saveToFile(false);\n    }\n}\n", "\n@Mixin(MinecraftServer.class)\npublic class MixinMinecraftServer {\n    @Inject(method = \"save\", at = @At(\"HEAD\"))\n    private void saveIPListAutoSave(boolean suppressLogs, boolean flush, boolean force, CallbackInfoReturnable<Boolean> cir) {\n        IPList.INSTANCE.saveToFile(false);\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinServerQueryNetworkHandler.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Config;\nimport com.adryd.sneaky.IPList;\nimport net.minecraft.network.ClientConnection;\nimport net.minecraft.server.ServerMetadata;\nimport net.minecraft.server.network.ServerQueryNetworkHandler;\nimport net.minecraft.text.Text;\nimport org.spongepowered.asm.mixin.*;\nimport org.spongepowered.asm.mixin.injection.At;", "import org.spongepowered.asm.mixin.*;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Mixin(ServerQueryNetworkHandler.class)\npublic class MixinServerQueryNetworkHandler {\n\n    @Mutable\n    @Shadow\n    @Final\n    private ServerMetadata metadata;\n\n    @Unique\n    private ServerMetadata sneakyMetadata = new ServerMetadata(\n            Text.of(\"A Minecraft Server\"),\n            Optional.of(new ServerMetadata.Players(20, 0, List.of())),\n            Optional.of(ServerMetadata.Version.create()),\n            Optional.empty(),\n            true\n    );\n\n    @Inject(method = \"<init>\", at = @At(\"TAIL\"))\n    private void swapServerInfo(ServerMetadata metadata, ClientConnection connection, CallbackInfo ci) {", "@Mixin(ServerQueryNetworkHandler.class)\npublic class MixinServerQueryNetworkHandler {\n\n    @Mutable\n    @Shadow\n    @Final\n    private ServerMetadata metadata;\n\n    @Unique\n    private ServerMetadata sneakyMetadata = new ServerMetadata(\n            Text.of(\"A Minecraft Server\"),\n            Optional.of(new ServerMetadata.Players(20, 0, List.of())),\n            Optional.of(ServerMetadata.Version.create()),\n            Optional.empty(),\n            true\n    );\n\n    @Inject(method = \"<init>\", at = @At(\"TAIL\"))\n    private void swapServerInfo(ServerMetadata metadata, ClientConnection connection, CallbackInfo ci) {", "        if (!IPList.INSTANCE.canPing(connection.getAddress())) {\n            if (Config.INSTANCE.getHideServerPingData()) {\n                this.metadata = sneakyMetadata;\n            } else if (Config.INSTANCE.getOnlyHidePlayerList()) {\n                this.metadata = new ServerMetadata(\n                        this.metadata.description(),\n                        Optional.of(new ServerMetadata.Players(20, 0, List.of())),\n                        this.metadata.version(),\n                        this.metadata.favicon(),\n                        this.metadata.secureChatEnforced()\n                );\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinServerNetworkIoChannelInitialiser.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Sneaky;\nimport io.netty.channel.Channel;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(targets = {\"net.minecraft.server.ServerNetworkIo$1\"})\npublic class MixinServerNetworkIoChannelInitialiser {\n    @Inject(method = \"initChannel\", at = @At(\"HEAD\"), cancellable = true)\n    private void beforeAssignNetworkHandler(Channel channel, CallbackInfo ci) {", "\n@Mixin(targets = {\"net.minecraft.server.ServerNetworkIo$1\"})\npublic class MixinServerNetworkIoChannelInitialiser {\n    @Inject(method = \"initChannel\", at = @At(\"HEAD\"), cancellable = true)\n    private void beforeAssignNetworkHandler(Channel channel, CallbackInfo ci) {\n        if (!Sneaky.checkAllowConnection(channel.remoteAddress())) {\n            channel.close();\n            ci.cancel();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinServerLoginNetworkHandlerAuthThread.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Config;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n\n// Thank you katie for helping with this mixin", "\n// Thank you katie for helping with this mixin\n@Mixin(targets = {\"net.minecraft.server.network.ServerLoginNetworkHandler$1\"})\npublic class MixinServerLoginNetworkHandlerAuthThread {\n    @Inject(method = \"run\", at = @At(value = \"INVOKE\", target = \"Lorg/slf4j/Logger;error(Ljava/lang/String;Ljava/lang/Object;)V\"), cancellable = true)\n    private void beforeLogError(CallbackInfo ci) {\n        if (Config.INSTANCE.getDontLogServerDisconnects()) ci.cancel();\n    }\n}\n"]}
{"filename": "src/main/java/com/adryd/sneaky/mixin/MixinLegacyQueryHandler.java", "chunked_list": ["package com.adryd.sneaky.mixin;\n\nimport com.adryd.sneaky.Config;\nimport com.adryd.sneaky.IPList;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport net.minecraft.network.LegacyQueryHandler;\nimport net.minecraft.server.MinecraftServer;\nimport net.minecraft.server.ServerNetworkIo;", "import net.minecraft.server.MinecraftServer;\nimport net.minecraft.server.ServerNetworkIo;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.Unique;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.Redirect;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;", "import org.spongepowered.asm.mixin.injection.Redirect;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\nimport java.net.SocketAddress;\nimport java.util.Locale;\n\n@Mixin(LegacyQueryHandler.class)\npublic abstract class MixinLegacyQueryHandler extends ChannelInboundHandlerAdapter {\n    @Shadow\n    protected abstract void reply(ChannelHandlerContext ctx, ByteBuf buf);\n\n    @Shadow\n    protected abstract ByteBuf toBuffer(String s);\n\n    @Shadow\n    @Final\n    private ServerNetworkIo networkIo;\n\n    @Unique\n    private String get13PingData(SocketAddress addr) {\n        MinecraftServer server = this.networkIo.getServer();", "        if (Config.INSTANCE.getHideServerPingData() && !IPList.INSTANCE.canPing(addr)) {\n            return String.format(Locale.ROOT, \"%s\u00a7%d\u00a7%d\", \"A Minecraft Server\", 0, 20);\n        }\n        return String.format(Locale.ROOT, \"%s\u00a7%d\u00a7%d\", server.getServerMotd(), server.getCurrentPlayerCount(), server.getMaxPlayerCount());\n    }\n\n    @Unique\n    private String get14to16PingData(SocketAddress addr) {\n        MinecraftServer server = this.networkIo.getServer();\n        if (Config.INSTANCE.getHideServerPingData() && !IPList.INSTANCE.canPing(addr)) {\n            return String.format(Locale.ROOT, \"\u00a71\\u0000%d\\u0000%s\\u0000%s\\u0000%d\\u0000%d\", 127, server.getVersion(), \"A Minecraft Server\", 0, 20);\n        }\n        return String.format(Locale.ROOT, \"\u00a71\\u0000%d\\u0000%s\\u0000%s\\u0000%d\\u0000%d\", 127, server.getVersion(), server.getServerMotd(), server.getCurrentPlayerCount(), server.getMaxPlayerCount());\n    }\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lio/netty/channel/Channel;remoteAddress()Ljava/net/SocketAddress;\"), cancellable = true)\n    private void cancelLegacyPing(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {", "        if (Config.INSTANCE.getHideServerPingData() && !IPList.INSTANCE.canPing(addr)) {\n            return String.format(Locale.ROOT, \"\u00a71\\u0000%d\\u0000%s\\u0000%s\\u0000%d\\u0000%d\", 127, server.getVersion(), \"A Minecraft Server\", 0, 20);\n        }\n        return String.format(Locale.ROOT, \"\u00a71\\u0000%d\\u0000%s\\u0000%s\\u0000%d\\u0000%d\", 127, server.getVersion(), server.getServerMotd(), server.getCurrentPlayerCount(), server.getMaxPlayerCount());\n    }\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lio/netty/channel/Channel;remoteAddress()Ljava/net/SocketAddress;\"), cancellable = true)\n    private void cancelLegacyPing(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        if (Config.INSTANCE.getDisableLegacyQuery()) {\n            ctx.close();\n            ci.cancel();\n        }\n    }\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 0))\n    private void send13(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get13PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 1))\n    private void send1415(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get14to16PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 2))\n    private void send16(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get14to16PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Redirect(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\"))\n    private void noop(LegacyQueryHandler instance, ChannelHandlerContext ctx, ByteBuf buf) {\n    }\n}\n", "        if (Config.INSTANCE.getDisableLegacyQuery()) {\n            ctx.close();\n            ci.cancel();\n        }\n    }\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 0))\n    private void send13(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get13PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 1))\n    private void send1415(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get14to16PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Inject(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\", ordinal = 2))\n    private void send16(ChannelHandlerContext ctx, Object msg, CallbackInfo ci) {\n        String pingData = this.get14to16PingData(ctx.channel().remoteAddress());\n        this.reply(ctx, this.toBuffer(pingData));\n    }\n\n\n    @Redirect(method = \"channelRead\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/network/LegacyQueryHandler;reply(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;)V\"))\n    private void noop(LegacyQueryHandler instance, ChannelHandlerContext ctx, ByteBuf buf) {\n    }\n}\n"]}
