{"filename": "src/main/java/net/xenyria/eem/PlayingSessionInformation.java", "chunked_list": ["package net.xenyria.eem;\n\npublic class PlayingSessionInformation {\n\n    private static boolean onNetwork;\n    public static boolean isOnNetwork() { return onNetwork; }\n    public static void setOnNetwork(boolean onNetwork) { PlayingSessionInformation.onNetwork = onNetwork; }\n\n    private static EXenyriaServerType currentServerType = EXenyriaServerType.UNKNOWN;\n    public static EXenyriaServerType getCurrentServerType() { return currentServerType; }\n    public static void setCurrentServerType(EXenyriaServerType currentServerType) {\n        PlayingSessionInformation.currentServerType = currentServerType;\n    }\n\n    private static String serverInstanceId = \"\";", "    public static EXenyriaServerType getCurrentServerType() { return currentServerType; }\n    public static void setCurrentServerType(EXenyriaServerType currentServerType) {\n        PlayingSessionInformation.currentServerType = currentServerType;\n    }\n\n    private static String serverInstanceId = \"\";\n    public static String getServerInstanceId() { return serverInstanceId; }\n    public static void setServerInstanceId(String serverInstanceId) {\n        PlayingSessionInformation.serverInstanceId = serverInstanceId;\n    }\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/EXenyriaServerType.java", "chunked_list": ["package net.xenyria.eem;\n\npublic enum EXenyriaServerType {\n\n    HUB(\"hub-\"),\n    PAINTSQUAD(\"ps-\"),\n    RUSH(\"rush-\"),\n    UNKNOWN(\"\");\n\n    EXenyriaServerType(String idPrefix) {\n        this.idPrefix = idPrefix;\n    }\n\n    private final String idPrefix;", "    public static EXenyriaServerType determineServerType(String serverInstanceId) {\n        for(EXenyriaServerType type : values()) {\n            if(serverInstanceId.startsWith(type.idPrefix)) {\n                return type;\n            }\n        }\n        return UNKNOWN;\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/XenyriaExperienceEnhancementMod.java", "chunked_list": ["package net.xenyria.eem;\n\nimport net.xenyria.eem.discord.DiscordRichPresenceIntegration;\nimport net.fabricmc.api.ClientModInitializer;\nimport net.fabricmc.api.ModInitializer;\nimport net.xenyria.eem.utils.Keybinds;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class XenyriaExperienceEnhancementMod implements ClientModInitializer {\n\n\t// This logger is used to write text to the console and the log file.\n\t// It is considered best practice to use your mod id as the logger's name.\n\t// That way, it's clear which mod wrote info, warnings, and errors.", "\npublic class XenyriaExperienceEnhancementMod implements ClientModInitializer {\n\n\t// This logger is used to write text to the console and the log file.\n\t// It is considered best practice to use your mod id as the logger's name.\n\t// That way, it's clear which mod wrote info, warnings, and errors.\n\tpublic static final Logger LOGGER = LoggerFactory.getLogger(\"Xenyria/EEM\");\n\n\t@Override\n\tpublic void onInitializeClient() {\n\t\tLOGGER.info(\"Xenyria Mod has been initialized.\");", "\tpublic void onInitializeClient() {\n\t\tLOGGER.info(\"Xenyria Mod has been initialized.\");\n\t\ttry {\n\t\t\tLOGGER.info(\"Attempting to initialize Discord Integration...\");\n\t\t\tDiscordRichPresenceIntegration.createInstance();\n\t\t\tLOGGER.info(\"Discord Integration has been successfully initialized.\");\n\n\t\t\tLOGGER.info(\"Registering keybinds...\");\n\t\t\tKeybinds.register();\n\t\t\tLOGGER.info(\"Keybinds have been successfully registered.\");\n\t\t} catch (IllegalStateException exception) {\n\t\t\tLOGGER.error(\"Discord integration could not be initialized: \" + exception.getMessage());\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/utils/Keybinds.java", "chunked_list": ["package net.xenyria.eem.utils;\n\nimport net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;\nimport net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.option.KeyBinding;\nimport net.minecraft.client.util.InputUtil;\nimport net.xenyria.eem.PlayingSessionInformation;\nimport org.lwjgl.glfw.GLFW;\n\npublic class Keybinds {\n    private static final KeyBinding Achievements = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.achievements\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_K,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Ping = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.ping\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F8,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding MusicSettings = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.music_settings\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F7,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Settings = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.settings\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F6,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Stats = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.stats\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F4,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Lobby = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.lobby\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_UNKNOWN,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Hub = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.hub\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_UNKNOWN,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n", "import org.lwjgl.glfw.GLFW;\n\npublic class Keybinds {\n    private static final KeyBinding Achievements = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.achievements\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_K,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Ping = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.ping\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F8,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding MusicSettings = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.music_settings\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F7,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Settings = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.settings\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F6,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Stats = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.stats\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_F4,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Lobby = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.lobby\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_UNKNOWN,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n    private static final KeyBinding Hub = KeyBindingHelper.registerKeyBinding(new KeyBinding(\n            \"key.xenyria_eem.hub\",\n            InputUtil.Type.KEYSYM,\n            GLFW.GLFW_KEY_UNKNOWN,\n            \"key_category.xenyria_eem.xenyria\"\n    ));\n", "    public static void register() {\n        ClientTickEvents.END_CLIENT_TICK.register(client -> {\n            if(client.player == null) return;\n            registerCommandKeybind(client, Achievements, \"achievements\");\n            registerCommandKeybind(client, Ping, \"ping\");\n            registerCommandKeybind(client, MusicSettings, \"music\");\n            registerCommandKeybind(client, Settings, \"settings\");\n            registerCommandKeybind(client, Stats, \"stats\");\n            registerCommandKeybind(client, Lobby, \"lobby\");\n            registerCommandKeybind(client, Hub, \"hub\");\n        });\n    }\n\n    private static void registerCommandKeybind(MinecraftClient client, KeyBinding keybinding, String command) {\n        // Check if the user is on the server since you don't want to trigger certain macros on other servers", "        if(!PlayingSessionInformation.isOnNetwork()) { return; }\n        while (keybinding.wasPressed()) client.player.networkHandler.sendChatCommand(command);\n    }\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/config/screen/XenyriaConfigScreen.java", "chunked_list": ["package net.xenyria.eem.config.screen;\n\nimport com.terraformersmc.modmenu.api.ConfigScreenFactory;\nimport com.terraformersmc.modmenu.api.ModMenuApi;\n\npublic class XenyriaConfigScreen implements ModMenuApi {\n    @Override\n    public ConfigScreenFactory<?> getModConfigScreenFactory() {\n        return parent -> {\n            return XenyriaConfigManager.getConfigurationBuilder()\n                    .setParentScreen(parent).build();\n        };\n    }\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/config/screen/XenyriaConfig.java", "chunked_list": ["package net.xenyria.eem.config.screen;\n\nimport org.json.JSONObject;\n\npublic class XenyriaConfig {\n\n    public boolean enableDiscordRichPresence = true;\n    public boolean shareServerActivity = true;\n    public boolean improvedShootingDetectionForPaintSquad = true;\n    public boolean swimFormCameraForPaintSquad = true;\n", "    public boolean improvedShootingDetectionForPaintSquad = true;\n    public boolean swimFormCameraForPaintSquad = true;\n\n    public static XenyriaConfig load(JSONObject object) {\n        XenyriaConfig config = new XenyriaConfig();\n        if(object.has(\"discord\")) {\n            JSONObject settingsObject = object.getJSONObject(\"discord\");\n            config.enableDiscordRichPresence = settingsObject.getBoolean(\"rich_presence\");\n            config.shareServerActivity = settingsObject.getBoolean(\"share_server_activity\");\n        }\n        if(object.has(\"paintsquad\")) {\n            JSONObject settingsObject = object.getJSONObject(\"paintsquad\");\n            config.swimFormCameraForPaintSquad = settingsObject.getBoolean(\"swim_camera\");\n            config.improvedShootingDetectionForPaintSquad = settingsObject.getBoolean(\"improved_shooting\");\n        }\n        return config;\n    }\n", "        if(object.has(\"paintsquad\")) {\n            JSONObject settingsObject = object.getJSONObject(\"paintsquad\");\n            config.swimFormCameraForPaintSquad = settingsObject.getBoolean(\"swim_camera\");\n            config.improvedShootingDetectionForPaintSquad = settingsObject.getBoolean(\"improved_shooting\");\n        }\n        return config;\n    }\n\n    public JSONObject toJSON() {\n        JSONObject configObject = new JSONObject();\n\n        JSONObject discordObject = new JSONObject();\n        discordObject.put(\"rich_presence\", enableDiscordRichPresence);\n        discordObject.put(\"share_server_activity\", shareServerActivity);\n        configObject.put(\"discord\", discordObject);\n\n        JSONObject paintSquadObject = new JSONObject();\n        paintSquadObject.put(\"improved_shooting\", improvedShootingDetectionForPaintSquad);\n        paintSquadObject.put(\"swim_camera\", swimFormCameraForPaintSquad);\n        configObject.put(\"paintsquad\", paintSquadObject);\n\n        return configObject;\n    }\n\n}\n", "    public JSONObject toJSON() {\n        JSONObject configObject = new JSONObject();\n\n        JSONObject discordObject = new JSONObject();\n        discordObject.put(\"rich_presence\", enableDiscordRichPresence);\n        discordObject.put(\"share_server_activity\", shareServerActivity);\n        configObject.put(\"discord\", discordObject);\n\n        JSONObject paintSquadObject = new JSONObject();\n        paintSquadObject.put(\"improved_shooting\", improvedShootingDetectionForPaintSquad);\n        paintSquadObject.put(\"swim_camera\", swimFormCameraForPaintSquad);\n        configObject.put(\"paintsquad\", paintSquadObject);\n\n        return configObject;\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/config/screen/XenyriaConfigManager.java", "chunked_list": ["package net.xenyria.eem.config.screen;\n\nimport me.shedaniel.clothconfig2.api.ConfigBuilder;\nimport me.shedaniel.clothconfig2.api.ConfigCategory;\nimport net.minecraft.text.Text;\nimport net.xenyria.eem.networking.XenyriaServerPacket;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class XenyriaConfigManager {\n\n    public static final Logger LOGGER = LoggerFactory.getLogger(\"EEM/Settings\");\n\n    private static final File configFolder = new File(\"config/xenyria\");\n    private static final File configFile = new File(configFolder, \"xenyria_eem.config.json\");\n\n    private static XenyriaConfig config = new XenyriaConfig();", "public class XenyriaConfigManager {\n\n    public static final Logger LOGGER = LoggerFactory.getLogger(\"EEM/Settings\");\n\n    private static final File configFolder = new File(\"config/xenyria\");\n    private static final File configFile = new File(configFolder, \"xenyria_eem.config.json\");\n\n    private static XenyriaConfig config = new XenyriaConfig();\n    public static XenyriaConfig getConfig() { return config; }\n\n    public static void loadConfig() throws IOException, JSONException {", "    public static XenyriaConfig getConfig() { return config; }\n\n    public static void loadConfig() throws IOException, JSONException {\n        if(!configFile.exists()) {\n            // Use default config\n            config = new XenyriaConfig();\n        }\n\n        try(Scanner scanner = new Scanner(configFile)) {\n            StringBuilder jsonStringBuilder = new StringBuilder();\n            while (scanner.hasNextLine()) {\n                jsonStringBuilder.append(scanner.nextLine());\n            }\n            config = XenyriaConfig.load(new JSONObject(jsonStringBuilder.toString()));\n        }\n    }\n", "            while (scanner.hasNextLine()) {\n                jsonStringBuilder.append(scanner.nextLine());\n            }\n            config = XenyriaConfig.load(new JSONObject(jsonStringBuilder.toString()));\n        }\n    }\n\n    public static void saveConfig() throws IOException, IllegalStateException{\n        if (!configFolder.exists()) {\n            if(!configFolder.mkdirs()) {\n                throw new IOException(\"Couldn't create the folder for the config file for Xenyria EEM.\");\n            }\n        }\n", "        if (!configFolder.exists()) {\n            if(!configFolder.mkdirs()) {\n                throw new IOException(\"Couldn't create the folder for the config file for Xenyria EEM.\");\n            }\n        }\n\n        if(!configFile.exists()) {\n            try {\n                if(!configFile.createNewFile()) { throw new IOException(\"Config file couldn't be created.\"); }\n            } catch (IOException exception) {\n                throw new IOException(\"Couldn't save the config file for Xenyria EEM.\");\n            }\n        }\n\n        String configData = config.toJSON().toString(4);\n        try(FileWriter writer = new FileWriter(configFile)) {\n            writer.write(configData);\n        }\n", "                if(!configFile.createNewFile()) { throw new IOException(\"Config file couldn't be created.\"); }\n            } catch (IOException exception) {\n                throw new IOException(\"Couldn't save the config file for Xenyria EEM.\");\n            }\n        }\n\n        String configData = config.toJSON().toString(4);\n        try(FileWriter writer = new FileWriter(configFile)) {\n            writer.write(configData);\n        }\n", "        if(!configFolder.isDirectory()) {\n            throw new IllegalStateException(\"Config folder has to be a folder, not a file.\");\n        }\n\n        // Notify the server about config changes (e.g. resetting internal variables for PS's shooting detection)\n        var packet = new XenyriaServerPacket(XenyriaServerPacket.EPacketType.SETTINGS_CHANGED, new JSONObject());\n        packet.sendToServer();\n    }\n\n    public static ConfigBuilder getConfigurationBuilder() {\n\n        ConfigBuilder configBuilder = ConfigBuilder.create()\n                .setTitle(Text.translatable(\"config.xenyria.settings.title\"))\n                .setEditable(true)\n                .setTransparentBackground(true)\n                .setSavingRunnable(() -> {", "    public static ConfigBuilder getConfigurationBuilder() {\n\n        ConfigBuilder configBuilder = ConfigBuilder.create()\n                .setTitle(Text.translatable(\"config.xenyria.settings.title\"))\n                .setEditable(true)\n                .setTransparentBackground(true)\n                .setSavingRunnable(() -> {\n                    try {\n                        saveConfig();\n                    } catch (Exception e) {\n                        LOGGER.error(\"Couldn't save config: \" + e.getMessage());\n                    }\n                });\n\n        ConfigCategory discordCategory\n                = configBuilder.getOrCreateCategory(Text.translatable(\"config_category.xenyria_eem.discord.title\"));\n        discordCategory.addEntry(\n                configBuilder.entryBuilder()\n                        .startBooleanToggle(\n                                Text.translatable(\"config.xenyria_eem.discord.rp\"),\n                                config.enableDiscordRichPresence\n                        )\n                        .setDefaultValue(config.enableDiscordRichPresence)\n                        .setTooltip(Text.translatable(\"config.xenyria_eem.discord.rp.tooltip\"))\n                        .setSaveConsumer((newState) -> config.enableDiscordRichPresence = newState)\n                        .build()\n        );\n        discordCategory.addEntry(\n                configBuilder.entryBuilder()\n                        .startBooleanToggle(\n                                Text.translatable(\"config.xenyria_eem.discord.details\"),\n                                config.shareServerActivity\n                        )\n                        .setDefaultValue(config.shareServerActivity)\n                        .setTooltip(Text.translatable(\"config.xenyria_eem.discord.details.tooltip\"))\n                        .setSaveConsumer((newState) -> config.shareServerActivity = newState)\n                        .build()\n        );\n\n        ConfigCategory paintSquadCategory\n                = configBuilder.getOrCreateCategory(Text.translatable(\"config_category.xenyria_eem.paintsquad.title\"));\n        paintSquadCategory.addEntry(\n                configBuilder.entryBuilder()\n                        .startBooleanToggle(\n                                Text.translatable(\"config.xenyria_eem.paintsquad.swim_cam\"),\n                                config.swimFormCameraForPaintSquad\n                        )\n                        .setDefaultValue(config.swimFormCameraForPaintSquad)\n                        .setTooltip(Text.translatable(\"config.xenyria_eem.paintsquad.swim_cam.tooltip\"))\n                        .setSaveConsumer((newState) -> config.swimFormCameraForPaintSquad = newState)\n                        .build()\n        );\n        paintSquadCategory.addEntry(\n                configBuilder.entryBuilder()\n                        .startBooleanToggle(\n                                Text.translatable(\"config.xenyria_eem.paintsquad.shooting\"),\n                                config.improvedShootingDetectionForPaintSquad\n                        )\n                        .setDefaultValue(config.improvedShootingDetectionForPaintSquad)\n                        .setTooltip(Text.translatable(\"config.xenyria_eem.paintsquad.shooting.tooltip\"))\n                        .setSaveConsumer((newState) -> config.improvedShootingDetectionForPaintSquad = newState)\n                        .build()\n        );\n        return configBuilder;\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/discord/DiscordRichPresenceIntegration.java", "chunked_list": ["package net.xenyria.eem.discord;\n\nimport net.xenyria.eem.config.screen.XenyriaConfigManager;\nimport net.xenyria.eem.discord.activity.DefaultDiscordActivityAccess;\nimport net.xenyria.eem.discord.activity.IDiscordActivityAccess;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;", "\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class DiscordRichPresenceIntegration {\n\n    private static DiscordRichPresenceIntegration instance;\n    public static DiscordRichPresenceIntegration getInstance() { return instance; }\n    public static void createInstance() throws IllegalStateException {", "    public static DiscordRichPresenceIntegration getInstance() { return instance; }\n    public static void createInstance() throws IllegalStateException {\n        if(instance != null) return;\n        instance = new DiscordRichPresenceIntegration();\n    }\n\n    public static Logger LOGGER = LoggerFactory.getLogger(\"Xenyria/DiscordIntegration\");\n    // Delay in milliseconds until we assume that the connection to the server has been lost\n    public static final long TIMEOUT = 3000L;\n    // Delay in milliseconds for activity updates\n    public static final long UPDATE_INTERVAL = 500L;\n\n    // Constructor\n    private DiscordRichPresenceIntegration() throws IllegalStateException {\n        // Initialize the discord library\n        discordActivityAccess = new DefaultDiscordActivityAccess();\n        discordActivityAccess.initialize();\n        // Start the rich presence update loop\n        enterRichPresenceUpdateLoop();\n    }\n", "    public static final long TIMEOUT = 3000L;\n    // Delay in milliseconds for activity updates\n    public static final long UPDATE_INTERVAL = 500L;\n\n    // Constructor\n    private DiscordRichPresenceIntegration() throws IllegalStateException {\n        // Initialize the discord library\n        discordActivityAccess = new DefaultDiscordActivityAccess();\n        discordActivityAccess.initialize();\n        // Start the rich presence update loop\n        enterRichPresenceUpdateLoop();\n    }\n", "    public static JSONObject loadDefaultRichPresenceData() {\n        try(var stream = DiscordRichPresenceIntegration.class\n                .getResourceAsStream(\"/discord/anonymous_rich_presence.json\")) {\n            byte[] data = stream.readAllBytes();\n            String rawJson = new String(data, StandardCharsets.UTF_8);\n            return new JSONObject(rawJson);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to load default rich presence data: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Interface for accessing Discord's activity API\n     */\n    private final IDiscordActivityAccess discordActivityAccess;", "    public IDiscordActivityAccess getActivityAccess() {\n        return discordActivityAccess;\n    }\n\n    /**\n     * The last known rich presence state is stored here along with a timestamp.\n     * If we don't receive any new data in the last few seconds we'll automatically\n     * stop sending rich presence data to the API.\n     * **/\n    private static final Object lock = new Object();\n    private static JSONObject lastReceivedRichPresence;\n    private static long lastReceivedPacket = 0L;", "    public static void setLastReceivedRichPresence(JSONObject lastReceivedRichPresence) {\n        synchronized (lock) {\n            lastReceivedPacket = System.currentTimeMillis();\n            DiscordRichPresenceIntegration.lastReceivedRichPresence = lastReceivedRichPresence;\n        }\n    }\n\n    // The last application ID that was used to initialize the activity access.\n    private long lastApplicationID = -1L;\n\n    /**\n     * Starts a thread that passes data to the activity access\n     */", "    public void enterRichPresenceUpdateLoop() {\n        LOGGER.info(\"Entering rich presence update loop...\");\n\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n        LOGGER.info(\"Starting API task...\");\n        executor.scheduleAtFixedRate(() -> {\n            try {\n                JSONObject richPresenceData = null;\n                boolean isDataPresent = false;\n\n                // Lock so this#setLastReceivedRichPresence is blocked while we copy data\n                synchronized (lock) {", "                    if (lastReceivedRichPresence != null) {\n                        long deltaSinceLastPacket = System.currentTimeMillis() - lastReceivedPacket;\n                        if (deltaSinceLastPacket < TIMEOUT) {\n                            isDataPresent = true;\n                            richPresenceData = new JSONObject(lastReceivedRichPresence.toMap());\n                        }\n                    }\n                }\n\n                if (isDataPresent) {\n\n                    // Replace the received rich presence data with generic content\n                    // if the User doesn't want to share their activity on the server.", "                if (isDataPresent) {\n\n                    // Replace the received rich presence data with generic content\n                    // if the User doesn't want to share their activity on the server.\n                    if (!XenyriaConfigManager.getConfig().shareServerActivity) {\n                        richPresenceData = loadDefaultRichPresenceData();\n                    }\n\n                    long applicationId = richPresenceData.getLong(\"applicationId\");\n                    if (applicationId != lastApplicationID) {\n                        // Application ID has changed - Therefore we restart our activity access with a different ID\n                        lastApplicationID = applicationId;\n                        LOGGER.info(\"Switching application ID to \" + applicationId + \"...\");\n                        discordActivityAccess.stop();\n                        discordActivityAccess.start(applicationId);\n                        return;\n                    }\n\n                    // Pass rich presence data down to the Discord activity access\n                    var details = richPresenceData.getString(\"details\");\n                    var state = richPresenceData.getString(\"state\");\n                    var smallImageId = richPresenceData.getString(\"smallImageId\");\n                    var smallImageText = richPresenceData.getString(\"smallImageText\");\n                    var largeImageId = richPresenceData.getString(\"largeImageId\");\n                    var largeImageText = richPresenceData.getString(\"largeImageText\");\n                    var activityStart = richPresenceData.getLong(\"activityStart\");\n                    var activityEnd = richPresenceData.getLong(\"activityEnd\");\n\n                    discordActivityAccess.updateRichPresence(applicationId,\n                            details,\n                            state,\n                            activityStart,\n                            activityEnd,\n                            smallImageId,\n                            smallImageText,\n                            largeImageId,\n                            largeImageText);\n                } else {\n                    // The application ID has to be reset here so the core gets started up again once we receive data again\n                    lastApplicationID = 0;\n                    discordActivityAccess.stop();\n                }\n                // Run callbacks\n                discordActivityAccess.runCallbacks();\n            } catch (Exception e) {\n                LOGGER.error(\"An error occurred during the rich presence update loop\", e);\n            }\n        }, UPDATE_INTERVAL, UPDATE_INTERVAL, TimeUnit.MILLISECONDS);\n\n\n    }\n\n}\n", "                    if (applicationId != lastApplicationID) {\n                        // Application ID has changed - Therefore we restart our activity access with a different ID\n                        lastApplicationID = applicationId;\n                        LOGGER.info(\"Switching application ID to \" + applicationId + \"...\");\n                        discordActivityAccess.stop();\n                        discordActivityAccess.start(applicationId);\n                        return;\n                    }\n\n                    // Pass rich presence data down to the Discord activity access\n                    var details = richPresenceData.getString(\"details\");\n                    var state = richPresenceData.getString(\"state\");\n                    var smallImageId = richPresenceData.getString(\"smallImageId\");\n                    var smallImageText = richPresenceData.getString(\"smallImageText\");\n                    var largeImageId = richPresenceData.getString(\"largeImageId\");\n                    var largeImageText = richPresenceData.getString(\"largeImageText\");\n                    var activityStart = richPresenceData.getLong(\"activityStart\");\n                    var activityEnd = richPresenceData.getLong(\"activityEnd\");\n\n                    discordActivityAccess.updateRichPresence(applicationId,\n                            details,\n                            state,\n                            activityStart,\n                            activityEnd,\n                            smallImageId,\n                            smallImageText,\n                            largeImageId,\n                            largeImageText);\n                } else {\n                    // The application ID has to be reset here so the core gets started up again once we receive data again\n                    lastApplicationID = 0;\n                    discordActivityAccess.stop();\n                }\n                // Run callbacks\n                discordActivityAccess.runCallbacks();\n            } catch (Exception e) {\n                LOGGER.error(\"An error occurred during the rich presence update loop\", e);\n            }\n        }, UPDATE_INTERVAL, UPDATE_INTERVAL, TimeUnit.MILLISECONDS);\n\n\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/discord/DiscordUtil.java", "chunked_list": ["package net.xenyria.eem.discord;\n\nimport org.apache.commons.lang3.SystemUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.StandardCopyOption;", "import java.nio.file.Files;\nimport java.nio.file.StandardCopyOption;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class DiscordUtil {\n\n    public static final String SDK_VERSION = \"latest\";\n    public static final String SDK_DOWNLOAD_URL = \"https://dl-game-sdk.discordapp.net/\" + SDK_VERSION + \"/discord_game_sdk.zip\";\n\n    public static final String SEPARATOR_ZIP = \"/\";", "    public static final String SDK_DOWNLOAD_URL = \"https://dl-game-sdk.discordapp.net/\" + SDK_VERSION + \"/discord_game_sdk.zip\";\n\n    public static final String SEPARATOR_ZIP = \"/\";\n    public static final String SDK_FILE_NAME = \"discord_game_sdk\";\n\n    public static final String EXTENSION_LIB_WINDOWS = \"dll\";\n    public static final String EXTENSION_LIB_LINUX = \"so\";\n    public static final String EXTENSION_LIB_MAC = \"dylib\";\n\n    public static final String LIB_ARCH_X86_64 = \"x86_64\"; // 64 bit\n    public static final String LIB_ARCH_X86 = \"x86\"; // 32 bit", "    public static final String LIB_ARCH_X86_64 = \"x86_64\"; // 64 bit\n    public static final String LIB_ARCH_X86 = \"x86\"; // 32 bit\n    public static final String LIB_ARCH_ARM64 = \"aarch64\"; // 64 bit ARM\n\n    public static final String OS_ARCH_X86_64 = \"amd64\"; // 64 bit (os.arch)\n    public static final String OS_ARCH_X86_64_ALT = \"x86_64\"; // 64 bit (os.arch) - M1 with x86_64 emulation\n    public static final String OS_ARCH_X86 = \"x86\"; // 32 bit (os.arch)\n    public static final String OS_ARCH_ARM = \"aarch64\"; // 64 bit (os.arch) ARM\n\n    public static String getNativeSDKLibraryFileName() {\n        return getNativeSDKLibraryFileName(File.separator);\n    }\n", "    public static String getNativeSDKLibraryFileName() {\n        return getNativeSDKLibraryFileName(File.separator);\n    }\n\n    public static String getNativeSDKLibraryFileName(String separator) {\n        String extension = getNativeLibExtension();\n        String architecture = getSystemArchitecture();\n        if(SystemUtils.IS_OS_WINDOWS) {\n            return architecture + separator + SDK_FILE_NAME + \".\" + extension;\n        } else if(SystemUtils.IS_OS_LINUX) {\n            return architecture + separator + SDK_FILE_NAME + \".\" + extension;", "        } else if(SystemUtils.IS_OS_LINUX) {\n            return architecture + separator + SDK_FILE_NAME + \".\" + extension;\n        } else if(SystemUtils.IS_OS_MAC) {\n            return architecture + separator + SDK_FILE_NAME + \".\" + extension;\n        }\n        throw new RuntimeException(\"Unsupported operating system: '\" + architecture + \"'.\");\n    }\n\n    /**\n     * @return Returns the current system architecture\n     */", "    public static String getSystemArchitecture() {\n        String architecture = System.getProperty(\"os.arch\").toLowerCase();\n        if(architecture.equalsIgnoreCase(OS_ARCH_X86_64) || architecture.equalsIgnoreCase(OS_ARCH_X86_64_ALT)) {\n            return LIB_ARCH_X86_64;\n        } else if(architecture.equalsIgnoreCase(OS_ARCH_X86)) {\n            return LIB_ARCH_X86;\n        } else if(architecture.equalsIgnoreCase(OS_ARCH_ARM)) {\n            return LIB_ARCH_ARM64;\n        }\n        throw new RuntimeException(\"Unsupported operating system architecture: '\" + architecture + \"'.\");\n    }\n\n    /**\n     * @return Returns the file extension for the native lib based on the current OS\n     */", "    public static String getNativeLibExtension() {\n        if(SystemUtils.IS_OS_WINDOWS) {\n            return EXTENSION_LIB_WINDOWS;\n        } else if(SystemUtils.IS_OS_LINUX) {\n            return EXTENSION_LIB_LINUX;\n        } else if(SystemUtils.IS_OS_MAC) {\n            return EXTENSION_LIB_MAC;\n        }\n        throw new RuntimeException(\"Unsupported operating system.\");\n    }\n\n    /**\n     * Downloads and extracts the required native library from Discord's Game SDK\n     */", "    public static void downloadGameSDK(File output) throws IOException {\n        // Determine which file we'll need from the zip file\n        String targetFileName = \"lib/\"+getNativeSDKLibraryFileName(SEPARATOR_ZIP);\n        // Create a URL and open a connection\n        URL downloadURL = new URL(SDK_DOWNLOAD_URL);\n        HttpURLConnection connection = (HttpURLConnection) downloadURL.openConnection();\n\n        // Read the downlaaded zip file\n        try(ZipInputStream zipInputStream = new ZipInputStream(connection.getInputStream())) {\n            ZipEntry currentZipEntry;\n            while ((currentZipEntry = zipInputStream.getNextEntry()) != null) {\n                // Check if it's the file we are searching for...", "            while ((currentZipEntry = zipInputStream.getNextEntry()) != null) {\n                // Check if it's the file we are searching for...\n                try {\n                    if (currentZipEntry.getName().equals(targetFileName)) {\n                        if (!output.getParentFile().exists() && !output.getParentFile().mkdirs())\n                            throw new IOException(\"Folder could not be created.\");\n                        // Copy to the system disk\n                        Files.copy(zipInputStream, output.toPath(), StandardCopyOption.REPLACE_EXISTING);\n                        // Exit from the loop\n                        break;\n                    }\n                } finally {\n                    zipInputStream.closeEntry();\n                }\n            }\n        }\n\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/discord/activity/IDiscordActivityAccess.java", "chunked_list": ["package net.xenyria.eem.discord.activity;\n\npublic interface IDiscordActivityAccess {\n\n    void initialize() throws IllegalStateException;\n    void start(long applicationId);\n    void stop();\n    void updateRichPresence(\n            long applicationId,\n            String details,\n            String state,\n            long activityStart,\n            long activityEnd,\n            String smallImageId,\n            String smallImageText,\n            String largeImageId,\n            String largeImageText\n    );\n    void runCallbacks();\n\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/discord/activity/DefaultDiscordActivityAccess.java", "chunked_list": ["package net.xenyria.eem.discord.activity;\n\nimport de.jcm.discordgamesdk.Core;\nimport de.jcm.discordgamesdk.CreateParams;\nimport de.jcm.discordgamesdk.activity.Activity;\nimport de.jcm.discordgamesdk.activity.ActivityType;\nimport net.xenyria.eem.discord.DiscordUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.time.Instant;\n\npublic class DefaultDiscordActivityAccess implements IDiscordActivityAccess {\n\n    public static Logger LOGGER = LoggerFactory.getLogger(\"Xenyria/DiscordActivity\");\n    public static final File TEMP_DIRECTORY = new File(\"xenyria\" + File.separator + \"temp\");\n\n    @Override", "    public static Logger LOGGER = LoggerFactory.getLogger(\"Xenyria/DiscordActivity\");\n    public static final File TEMP_DIRECTORY = new File(\"xenyria\" + File.separator + \"temp\");\n\n    @Override\n    public void initialize() throws IllegalStateException {\n        LOGGER.info(\"Initializing Discord Game SDK for Rich Presence integration\");\n\n        // We're storing a copy of Discord's Game SDK in a temporary folder\n        // This folder has to exist in order for initialization to succeed\n        if(!TEMP_DIRECTORY.exists() && !TEMP_DIRECTORY.mkdirs()) {\n            throw new IllegalStateException(\"Couldn't create temporary directory\");\n        }\n\n        // Determine the name of the native lib we have to load based on the user's OS\n        String sdkFileName = DiscordUtil.getNativeSDKLibraryFileName();\n\n        File nativeLibraryFile = new File(TEMP_DIRECTORY, sdkFileName);", "        if(!TEMP_DIRECTORY.exists() && !TEMP_DIRECTORY.mkdirs()) {\n            throw new IllegalStateException(\"Couldn't create temporary directory\");\n        }\n\n        // Determine the name of the native lib we have to load based on the user's OS\n        String sdkFileName = DiscordUtil.getNativeSDKLibraryFileName();\n\n        File nativeLibraryFile = new File(TEMP_DIRECTORY, sdkFileName);\n        if(!nativeLibraryFile.exists()) {\n            try {\n                LOGGER.info(\"Downloading Discord's Game SDK... (Version \" + DiscordUtil.SDK_VERSION + \")\");\n                DiscordUtil.downloadGameSDK(nativeLibraryFile);", "        if(!nativeLibraryFile.exists()) {\n            try {\n                LOGGER.info(\"Downloading Discord's Game SDK... (Version \" + DiscordUtil.SDK_VERSION + \")\");\n                DiscordUtil.downloadGameSDK(nativeLibraryFile);\n                if(!nativeLibraryFile.exists()) {\n                    throw new FileNotFoundException(\"SDK has been downloaded but the required file couldn't be found.\");\n                }\n            } catch (IOException exception) {\n                LOGGER.error(\"Downloading the Discord Game SDK has failed: \" + exception.getMessage());\n            }\n        }\n        Core.init(nativeLibraryFile);\n    }\n\n    private Core coreInstance;\n    private CreateParams params;\n\n    @Override", "    public synchronized void start(long applicationId) {\n        // Destroy the existing core\n        if(coreInstance != null) stop();\n\n        // Initialize the core\n        params = new CreateParams();\n        try {\n            params.setClientID(applicationId);\n            params.setFlags(CreateParams.getDefaultFlags());\n            coreInstance = new Core(params);\n        } catch (Exception e) {", "            try {\n                if(params != null) {\n                    params.close();\n                    params = null;\n                }\n            } catch (Exception e1) {\n                LOGGER.error(\"Couldn't close create params, this is really bad and probably an issue with the underlying library: \"\n                        + e1.getMessage());\n            }\n            try {\n                if(coreInstance != null) {\n                    coreInstance.close();\n                    coreInstance = null;\n                }\n            } catch (Exception e1) {\n                LOGGER.error(\"Couldn't close core instance after initialization failed\"\n                        + e1.getMessage());\n            }\n        }\n    }\n\n    @Override", "            try {\n                if(coreInstance != null) {\n                    coreInstance.close();\n                    coreInstance = null;\n                }\n            } catch (Exception e1) {\n                LOGGER.error(\"Couldn't close core instance after initialization failed\"\n                        + e1.getMessage());\n            }\n        }\n    }\n\n    @Override", "    public synchronized void stop() {\n        // Clean up\n        if(coreInstance == null) return;\n        try {\n             coreInstance.close();\n        } catch (Exception e) {\n            LOGGER.error(\"Couldn't close core instance: \" + e.getMessage());\n        } finally {\n            coreInstance = null;\n        }\n", "        try {\n            params.close();\n        } catch (Exception e) {\n            LOGGER.error(\"Couldn't close create params: \" + e.getMessage());\n        } finally {\n            params = null;\n        }\n    }\n\n    @Override\n    public synchronized void updateRichPresence(long applicationId,\n                                                String details,\n                                                String state,\n                                                long activityStart,\n                                                long activityEnd,\n                                                String smallImageId,\n                                                String smallImageText,\n                                                String largeImageId,\n                                                String largeImageText) {", "    public synchronized void updateRichPresence(long applicationId,\n                                                String details,\n                                                String state,\n                                                long activityStart,\n                                                long activityEnd,\n                                                String smallImageId,\n                                                String smallImageText,\n                                                String largeImageId,\n                                                String largeImageText) {\n        if(coreInstance == null) return;\n        try(var activity = new Activity()) {\n            activity.setDetails(details);\n            activity.setState(state);\n            activity.timestamps().setStart(Instant.ofEpochMilli(activityStart));\n            activity.timestamps().setEnd(Instant.ofEpochMilli(activityEnd));\n            activity.assets().setSmallImage(smallImageId);\n            activity.assets().setSmallText(smallImageText);\n            activity.assets().setLargeImage(largeImageId);\n            activity.assets().setLargeText(largeImageText);\n            activity.setType(ActivityType.PLAYING);\n            coreInstance.activityManager().updateActivity(activity);\n        } catch (Exception e) {\n            LOGGER.error(\"Couldn't update activity: \" + e.getMessage());\n        }\n    }\n\n    @Override", "        if(coreInstance == null) return;\n        try(var activity = new Activity()) {\n            activity.setDetails(details);\n            activity.setState(state);\n            activity.timestamps().setStart(Instant.ofEpochMilli(activityStart));\n            activity.timestamps().setEnd(Instant.ofEpochMilli(activityEnd));\n            activity.assets().setSmallImage(smallImageId);\n            activity.assets().setSmallText(smallImageText);\n            activity.assets().setLargeImage(largeImageId);\n            activity.assets().setLargeText(largeImageText);\n            activity.setType(ActivityType.PLAYING);\n            coreInstance.activityManager().updateActivity(activity);\n        } catch (Exception e) {\n            LOGGER.error(\"Couldn't update activity: \" + e.getMessage());\n        }\n    }\n\n    @Override", "    public synchronized void runCallbacks() {\n        if(coreInstance == null) return;\n        try {\n            coreInstance.runCallbacks();\n        } catch (Exception e) {\n            LOGGER.error(\"Couldn't run callbacks: \" + e.getMessage());\n        }\n    }\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/networking/XenyriaServerPacket.java", "chunked_list": ["package net.xenyria.eem.networking;\n\nimport io.netty.buffer.Unpooled;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.network.PacketByteBuf;\nimport net.minecraft.network.packet.c2s.play.CustomPayloadC2SPacket;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.ByteArrayOutputStream;", "\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport static net.xenyria.eem.networking.PacketListener.LOGGER;\n\npublic class XenyriaServerPacket {\n\n    /** Packets are separated into different types/categories **/", "public class XenyriaServerPacket {\n\n    /** Packets are separated into different types/categories **/\n    public enum EPacketType {\n        RP, // Rich-Presence (Discord Integration)\n        PS_SHOOTING_STATE, // PaintSquad\n        HANDSHAKE_INIT, // Server Switch / Server Info Change (Sent by the server)\n        HANDSHAKE_RESPONSE, // Sent by the client, informs the server about the mod being active\n        DEBUG, // Debug Operation (printing client-side variables into the chat)\n        SETTINGS_CHANGED // Sent by the client when settings are changed\n    }\n\n    private final EPacketType packetType;", "    public EPacketType getPacketType() { return packetType; }\n\n    private final JSONObject data;\n    public JSONObject getData() { return data; }\n\n    public XenyriaServerPacket(EPacketType parsedPacketType, JSONObject data) {\n        this.packetType = parsedPacketType;\n        this.data = data;\n    }\n\n    /**\n     * Parses raw JSON into packet objects\n     */", "    public static XenyriaServerPacket parsePacket(String rawJson) {\n\n        JSONObject jsonData;\n        try {\n            jsonData = new JSONObject(rawJson);\n        } catch (JSONException exception) {\n            LOGGER.severe(\"Unable to parse packet from raw JSON: \" + rawJson);\n            return null;\n        }\n\n        if(!jsonData.has(\"type\")) {\n            LOGGER.severe(\"Malformed packet, missing type field.\");\n            return null;\n        }\n        EPacketType parsedPacketType;", "        if(!jsonData.has(\"type\")) {\n            LOGGER.severe(\"Malformed packet, missing type field.\");\n            return null;\n        }\n        EPacketType parsedPacketType;\n        try {\n            parsedPacketType = EPacketType.valueOf(jsonData.getString(\"type\").toUpperCase());\n        } catch (IllegalArgumentException exception) {\n            LOGGER.severe(\"Malformed packet, unknown type value: \" + jsonData.getString(\"type\"));\n            return null;\n        }\n", "        if(!jsonData.has(\"data\")) {\n            LOGGER.severe(\"Malformed packet, missing data field.\");\n            return null;\n        }\n\n        return new XenyriaServerPacket(parsedPacketType, jsonData.getJSONObject(\"data\"));\n\n    }\n\n\n    /** Attempt to send this packet to the currently connected server as a plugin message **/", "    public void sendToServer() {\n        var networkHandler = MinecraftClient.getInstance().getNetworkHandler();\n        if(networkHandler == null)\n            return; // Not connected\n\n        JSONObject assembledPacket = new JSONObject();\n        assembledPacket.put(\"type\", this.packetType.name());\n        assembledPacket.put(\"data\", this.data);\n\n        ByteArrayOutputStream rawPacketBytes = new ByteArrayOutputStream();\n        try {\n            DataOutputStream dataOutputStream = new DataOutputStream(rawPacketBytes);\n            byte[] jsonContent = assembledPacket.toString().getBytes(StandardCharsets.UTF_8);\n            // 4 bytes are used to store the length of the JSON object that follows\n            dataOutputStream.writeInt(jsonContent.length);\n            dataOutputStream.write(jsonContent, 0, jsonContent.length);\n        } catch (IOException e) {\n            LOGGER.severe(\"Couldn't convert packet into bytes: \" + e.getMessage());\n        }\n\n        // Send data to the server\n        CustomPayloadC2SPacket packet = new CustomPayloadC2SPacket(\n                PacketListener.ID, new PacketByteBuf(\n                        Unpooled.wrappedBuffer(rawPacketBytes.toByteArray()))\n        );\n        networkHandler.sendPacket(packet);\n    }\n\n}\n", "        try {\n            DataOutputStream dataOutputStream = new DataOutputStream(rawPacketBytes);\n            byte[] jsonContent = assembledPacket.toString().getBytes(StandardCharsets.UTF_8);\n            // 4 bytes are used to store the length of the JSON object that follows\n            dataOutputStream.writeInt(jsonContent.length);\n            dataOutputStream.write(jsonContent, 0, jsonContent.length);\n        } catch (IOException e) {\n            LOGGER.severe(\"Couldn't convert packet into bytes: \" + e.getMessage());\n        }\n\n        // Send data to the server\n        CustomPayloadC2SPacket packet = new CustomPayloadC2SPacket(\n                PacketListener.ID, new PacketByteBuf(\n                        Unpooled.wrappedBuffer(rawPacketBytes.toByteArray()))\n        );\n        networkHandler.sendPacket(packet);\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/networking/PacketListener.java", "chunked_list": ["package net.xenyria.eem.networking;\n\nimport net.xenyria.eem.discord.DiscordRichPresenceIntegration;\nimport net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;\nimport net.minecraft.util.Identifier;\nimport net.xenyria.eem.EXenyriaServerType;\nimport net.xenyria.eem.PlayingSessionInformation;\nimport net.xenyria.eem.config.screen.XenyriaConfigManager;\nimport org.json.JSONObject;\n", "import org.json.JSONObject;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.logging.Logger;\n\npublic class PacketListener {\n\n    public static Identifier ID;\n    public static Logger LOGGER = Logger.getLogger(\"Xenyria/PacketListener\");\n\n    public static void initialize() {\n        ID = Identifier.of(\"xenyria\", \"mod_communication\");", "    public static Logger LOGGER = Logger.getLogger(\"Xenyria/PacketListener\");\n\n    public static void initialize() {\n        ID = Identifier.of(\"xenyria\", \"mod_communication\");\n        if(ID == null) throw new IllegalStateException(\"Identifier could not be initialized.\");\n\n        LOGGER.info(\"Registering packet receiver for plugin messages...\");\n        ClientPlayNetworking.registerGlobalReceiver(\n                ID, (client, handler, buf, responseSender) -> {\n                    /*\n                     * Packets sent by the server consist of a 4-byte Integer\n                     * and a byte array that represents UTF-8 string data.\n                     */\n                    int bytesToRead = buf.readInt();\n                    // Allocate enough memory for reading the raw JSON string in the next step\n                    byte[] buffer = new byte[bytesToRead];\n                    buf.readBytes(buffer);\n                    // Create a UTF-8 string from the received data\n                    String rawJsonText = new String(buffer, StandardCharsets.UTF_8);\n\n                    // Try to parse the packet\n                    XenyriaServerPacket packet = XenyriaServerPacket.parsePacket(rawJsonText);", "                    if(packet == null) {\n                        LOGGER.warning(\"Unable to parse Xenyria packet with \" + bytesToRead + \" length.\");\n                        return;\n                    }\n\n                    // Do something with the received data\n                    if (packet.getPacketType() == XenyriaServerPacket.EPacketType.RP) {\n                        // If rich presence is disabled in the settings we ignore this packet\n                        if (!XenyriaConfigManager.getConfig().enableDiscordRichPresence) {\n                            return;\n                        }\n                        DiscordRichPresenceIntegration.setLastReceivedRichPresence(packet.getData());", "                        if (!XenyriaConfigManager.getConfig().enableDiscordRichPresence) {\n                            return;\n                        }\n                        DiscordRichPresenceIntegration.setLastReceivedRichPresence(packet.getData());\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.HANDSHAKE_INIT) {\n                        // Orion sends one mod handshake packet on login\n                        // This packet contains the current server ID\n                        String instanceId = packet.getData().getString(\"server_id\");\n                        PlayingSessionInformation.setServerInstanceId(instanceId);\n                        PlayingSessionInformation.setOnNetwork(true);\n                        PlayingSessionInformation.setCurrentServerType(\n                                EXenyriaServerType.determineServerType(instanceId)\n                        );\n\n                        // We respond back so that the server knows we're using XEEM\n                        XenyriaServerPacket responsePacket = new XenyriaServerPacket(\n                                XenyriaServerPacket.EPacketType.HANDSHAKE_RESPONSE,\n                                new JSONObject()\n                        );\n                        responsePacket.sendToServer();\n                        LOGGER.info(\"Successfully completed handshake with Orion\");", "                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.DEBUG) {\n                        LOGGER.info(\"Current network state: \" + PlayingSessionInformation.isOnNetwork());\n                        LOGGER.info(\"Current server type: \" + PlayingSessionInformation.getCurrentServerType());\n                        LOGGER.info(\"Current server id: \" + PlayingSessionInformation.getServerInstanceId());\n                    }\n                }\n        );\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/mixin/PaintSquadSwimFormMixin.java", "chunked_list": ["package net.xenyria.eem.mixin;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.option.Perspective;\nimport net.xenyria.eem.PlayingSessionInformation;\nimport net.xenyria.eem.config.screen.XenyriaConfigManager;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;", "import org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(MinecraftClient.class)\npublic class PaintSquadSwimFormMixin {\n\n    private static final String SWIM_FORM_DETECTION_NAME = \"\\u0001swim_form\";\n\n    @Inject(at = @At(\"HEAD\"), method = \"tick()V\")\n    private void tick(CallbackInfo info) {\n        // Check if this setting is enabled in the first place...", "        if(!PlayingSessionInformation.isOnNetwork()\n        || !XenyriaConfigManager.getConfig().swimFormCameraForPaintSquad) {\n            return;\n        }\n        // A player entity has to be present for this to work\n        var playerEntity = MinecraftClient.getInstance().player;\n        if(playerEntity == null) { return; }\n        // Grab the player's client options since those include the current camera perspective\n        var clientOptions = MinecraftClient.getInstance().options;\n        // Check if the player is currently in PaintSquad's swim form\n        boolean isSwimming = isInSwimForm();", "        if(wasSwimmingLastTick && !isSwimming) {\n            // Player was swimming last tick and now isn't swimming anymore\n            // We'll just switch back to first person\n            clientOptions.setPerspective(Perspective.FIRST_PERSON);\n        } else if(!wasSwimmingLastTick && isSwimming) {\n            // The player wasn't swimming in the last tick and now entered the swim form\n            // In this case we'll just switch into the\n            clientOptions.setPerspective(Perspective.THIRD_PERSON_BACK);\n        }\n        // Store the last swimming state for the next check\n        wasSwimmingLastTick = isSwimming;\n    }\n\n    private boolean wasSwimmingLastTick;\n    private boolean isInSwimForm() {\n        // A player entity has to be present for this to work\n        var playerEntity = MinecraftClient.getInstance().player;", "        if(playerEntity == null) { return false; }\n        if(playerEntity.getVehicle() == null) { return false; }\n\n        // Check the player's vehicle entity\n        var vehicle = playerEntity.getVehicle();\n        if(vehicle.getCustomName() == null) { return false; }\n\n        // Check for a specific string to be present for the check to trigger\n        String text = vehicle.getCustomName().getString();\n        return text.contains(SWIM_FORM_DETECTION_NAME);\n    }\n\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/mixin/InitMixin.java", "chunked_list": ["package net.xenyria.eem.mixin;\n\nimport net.xenyria.eem.networking.PacketListener;\nimport net.xenyria.eem.config.screen.XenyriaConfigManager;\nimport net.xenyria.eem.paintsquad.PaintSquadInputManager;\nimport net.minecraft.client.gui.screen.TitleScreen;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;", "import org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(TitleScreen.class)\npublic class InitMixin {\n\n    @Inject(at = @At(\"HEAD\"), method = \"init()V\")\n    private void init(CallbackInfo info) {\n        // Register the packet listener here for client-server communication\n        PacketListener.initialize();\n        // Load the configuration file", "        try {\n            XenyriaConfigManager.loadConfig();\n        } catch (Exception exception) {\n            XenyriaConfigManager.LOGGER.error(\"Failed to load XEEM's configuration file on start-up: \"\n                    + exception.getMessage());\n        }\n        // Register improved shooting detection for weapons in PaintSquad\n        PaintSquadInputManager.createInstance();\n    }\n}\n\n"]}
{"filename": "src/main/java/net/xenyria/eem/mixin/DisconnectMixin.java", "chunked_list": ["package net.xenyria.eem.mixin;\n\nimport net.minecraft.client.MinecraftClient;\nimport net.xenyria.eem.EXenyriaServerType;\nimport net.xenyria.eem.PlayingSessionInformation;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(MinecraftClient.class)\npublic class DisconnectMixin {\n\n    @Inject(at = @At(\"HEAD\"), method = \"disconnect(Lnet/minecraft/client/gui/screen/Screen;)V\")\n    public void handleDisconnect(CallbackInfo info) {\n\n        PlayingSessionInformation.setOnNetwork(false);\n        PlayingSessionInformation.setCurrentServerType(EXenyriaServerType.UNKNOWN);\n        PlayingSessionInformation.setServerInstanceId(\"\");\n    }\n}\n"]}
{"filename": "src/main/java/net/xenyria/eem/paintsquad/PaintSquadInputManager.java", "chunked_list": ["package net.xenyria.eem.paintsquad;\n\nimport net.xenyria.eem.config.screen.XenyriaConfigManager;\nimport net.xenyria.eem.networking.PacketListener;\nimport net.xenyria.eem.networking.XenyriaServerPacket;\nimport net.minecraft.client.MinecraftClient;\nimport org.json.JSONObject;\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;", "import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class PaintSquadInputManager {\n\n    private static PaintSquadInputManager instance;\n    public static PaintSquadInputManager getInstance() { return instance; }\n    public static void createInstance() {\n        if(instance != null) return;\n        instance = new PaintSquadInputManager();\n    }\n\n    private PaintSquadInputManager() {\n        startTask();\n    }\n\n    private void startTask() {\n        PacketListener.LOGGER.info(\"Starting PaintSquad input polling task...\");\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n        executor.scheduleAtFixedRate(new Runnable() {\n            private boolean isShooting;\n            @Override", "    public static void createInstance() {\n        if(instance != null) return;\n        instance = new PaintSquadInputManager();\n    }\n\n    private PaintSquadInputManager() {\n        startTask();\n    }\n\n    private void startTask() {\n        PacketListener.LOGGER.info(\"Starting PaintSquad input polling task...\");\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n        executor.scheduleAtFixedRate(new Runnable() {\n            private boolean isShooting;\n            @Override", "            public void run() {\n                // Check if this feature is enabled...\n                if(!XenyriaConfigManager.getConfig().improvedShootingDetectionForPaintSquad) {\n                    return;\n                }\n                // Check if the player is holding the right mouse button\n                boolean hasChanged = false;\n                boolean isPressingRightMouseButton =\n                        MinecraftClient.getInstance().options.useKey.isPressed();\n\n                // We only send state changes to the server (e.g. when the state switches from firing to not firing)\n                // So in this case we just check if the state has changed compared to the last check", "                if(isShooting != isPressingRightMouseButton) {\n                    hasChanged = true;\n                    isShooting = isPressingRightMouseButton;\n                }\n\n                // If a change has been detected we send a mod packet to the server\n                if(hasChanged) {\n                    JSONObject payload = new JSONObject();\n                    payload.put(\"shooting\", isShooting);\n                    XenyriaServerPacket packet = new XenyriaServerPacket(\n                            XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE, payload);\n                    packet.sendToServer();\n                }\n            }\n        }, 10, 10, TimeUnit.MILLISECONDS);\n    }\n\n}\n"]}
