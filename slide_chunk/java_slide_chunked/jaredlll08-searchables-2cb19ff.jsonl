{"filename": "forge/src/main/java/com/blamejared/searchables/SearchablesForge.java", "chunked_list": ["package com.blamejared.searchables;\n\nimport net.minecraftforge.fml.common.Mod;\n\n@Mod(\"searchables\")\npublic class SearchablesForge {\n    \n    public SearchablesForge() {\n    \n    }\n    \n}\n"]}
{"filename": "common/src/test/java/com/blamejared/searchables/TestConstants.java", "chunked_list": ["package com.blamejared.searchables;\n\nimport com.blamejared.searchables.api.SearchableComponent;\nimport com.blamejared.searchables.api.SearchableType;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class TestConstants {\n    \n    public static class Shapes {\n        ", "public class TestConstants {\n    \n    public static class Shapes {\n        \n        public static final Shape ZERO = new Shape(\"zero\", \"sq uare\", \"purple\");\n        public static final Shape ONE = new Shape(\"one\", \"sq'uare\", \"red\");\n        public static final Shape TWO = new Shape(\"two\", \"sq\\\"uare\", \"blue\");\n        public static final Shape THREE = new Shape(\"three\", \"sq`uare\", \"green\");\n        public static final Shape FOUR = new Shape(\"four\", \"square\", \"yellow\");\n        public static final Shape FIVE = new Shape(\"five\", \"circle\", \"red\");\n        public static final Shape SIX = new Shape(\"six\", \"circle\", \"blue\");", "        public static final Shape FOUR = new Shape(\"four\", \"square\", \"yellow\");\n        public static final Shape FIVE = new Shape(\"five\", \"circle\", \"red\");\n        public static final Shape SIX = new Shape(\"six\", \"circle\", \"blue\");\n        public static final Shape SEVEN = new Shape(\"seven\", \"circle\", \"green\");\n        public static final Shape EIGHT = new Shape(\"eight\", \"circle\", \"yellow\");\n        public static final Shape NINE = new Shape(\"nine\", \"triangle\", \"red\");\n        public static final Shape TEN = new Shape(\"ten\", \"triangle\", \"blue\");\n        public static final Shape ELEVEN = new Shape(\"eleven\", \"triangle\", \"green\");\n        public static final Shape TWELVE = new Shape(\"twelve\", \"triangle\", \"yellow\");\n        \n    }\n    ", "        public static final Shape TWELVE = new Shape(\"twelve\", \"triangle\", \"yellow\");\n        \n    }\n    \n    public static final List<Shape> SHAPES = List.of(\n            Shapes.ZERO,\n            Shapes.ONE,\n            Shapes.TWO,\n            Shapes.THREE,\n            Shapes.FOUR,\n            Shapes.FIVE,\n            Shapes.SIX,\n            Shapes.SEVEN,\n            Shapes.EIGHT,\n            Shapes.NINE,\n            Shapes.TEN,\n            Shapes.ELEVEN,\n            Shapes.TWELVE\n    );\n    ", "    public static final SearchableType<Shape> SHAPE = new SearchableType.Builder<Shape>()\n            .defaultComponent(SearchableComponent.create(\"name\", shape -> Optional.of(shape.name())))\n            .component(SearchableComponent.create(\"type\", shape -> Optional.of(shape.type())))\n            .component(SearchableComponent.create(\"colour\", shape -> Optional.of(shape.colour())))\n            .build();\n    \n    \n    public record Shape(String name, String type, String colour) {}\n    \n}\n"]}
{"filename": "common/src/test/java/com/blamejared/searchables/tests/SearchTest.java", "chunked_list": ["package com.blamejared.searchables.tests;\n\nimport com.blamejared.searchables.TestConstants;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.contains;\nimport static org.hamcrest.Matchers.empty;", "import static org.hamcrest.Matchers.contains;\nimport static org.hamcrest.Matchers.empty;\nimport static org.hamcrest.Matchers.hasSize;\n\npublic class SearchTest {\n    \n    @Test\n    public void testNoResultsDefaultSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"negative\");\n        assertThat(shapes, empty());\n    }\n    \n    @Test", "    public void testNoResultsComponentSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name:invalid\");\n        assertThat(shapes, empty());\n    }\n    \n    @Test\n    public void testNoResultsFullSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name:invalid type:square colour:blue\");\n        assertThat(shapes, empty());\n    }\n    \n    @Test", "    public void testDefaultSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"five\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.FIVE));\n    }\n    \n    @Test\n    public void testComponentSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:triangle\");\n        assertThat(shapes, hasSize(4));\n        assertThat(shapes, contains(TestConstants.Shapes.NINE, TestConstants.Shapes.TEN, TestConstants.Shapes.ELEVEN, TestConstants.Shapes.TWELVE));\n    }\n    \n    @Test", "    public void testComponentSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:triangle\");\n        assertThat(shapes, hasSize(4));\n        assertThat(shapes, contains(TestConstants.Shapes.NINE, TestConstants.Shapes.TEN, TestConstants.Shapes.ELEVEN, TestConstants.Shapes.TWELVE));\n    }\n    \n    @Test\n    public void testComponentStringSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:`sq'uare`\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.ONE));\n    }\n    \n    @Test", "    public void testComponentStringSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:`sq'uare`\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.ONE));\n    }\n    \n    @Test\n    public void testComponentStringWithSpaceSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:`sq \");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.ZERO));\n    }\n    \n    @Test", "    public void testComponentStringWithSpaceSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:`sq \");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.ZERO));\n    }\n    \n    @Test\n    public void testDefaultAndComponentSearchOrderOne() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"four type:square\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.FOUR));\n    }\n    \n    @Test", "    public void testDefaultAndComponentSearchOrderOne() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"four type:square\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.FOUR));\n    }\n    \n    @Test\n    public void testDefaultAndComponentSearchOrderTwo() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:square four\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.FOUR));\n    }\n    \n    \n    @Test", "    public void testDefaultAndComponentSearchOrderTwo() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"type:square four\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.FOUR));\n    }\n    \n    \n    @Test\n    public void testFullSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name:eight type:circle colour:yellow\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.EIGHT));\n    }\n    \n    @Test", "    public void testFullSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name:eight type:circle colour:yellow\");\n        assertThat(shapes, hasSize(1));\n        assertThat(shapes, contains(TestConstants.Shapes.EIGHT));\n    }\n    \n    @Test\n    public void testEmptySearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"\");\n        assertThat(shapes, contains(TestConstants.SHAPES.toArray(TestConstants.Shape[]::new)));\n    }\n    \n    @Test", "    public void testEmptySearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"\");\n        assertThat(shapes, contains(TestConstants.SHAPES.toArray(TestConstants.Shape[]::new)));\n    }\n    \n    @Test\n    public void testEmptyComponentSearch() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name:\");\n        assertThat(shapes, contains(TestConstants.SHAPES.toArray(TestConstants.Shape[]::new)));\n    }\n    \n    @Test", "    public void testOneEmptyComponentSearchOrderOne() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"colour:red name:\");\n        assertThat(shapes, contains(TestConstants.Shapes.ONE, TestConstants.Shapes.FIVE, TestConstants.Shapes.NINE));\n    }\n    \n    @Test\n    public void testOneEmptyComponentSearchOrderTwo() {\n        \n        List<TestConstants.Shape> shapes = TestConstants.SHAPE.filterEntries(TestConstants.SHAPES, \"name: colour:red\");\n        assertThat(shapes, contains(TestConstants.Shapes.ONE, TestConstants.Shapes.FIVE, TestConstants.Shapes.NINE));\n    }\n    \n}\n"]}
{"filename": "common/src/test/java/com/blamejared/searchables/tests/AutoCompleteTest.java", "chunked_list": ["package com.blamejared.searchables.tests;\n\nimport com.blamejared.searchables.TestConstants;\nimport com.blamejared.searchables.api.TokenRange;\nimport com.blamejared.searchables.api.autcomplete.CompletionSuggestion;\nimport com.blamejared.searchables.api.autcomplete.CompletionVisitor;\nimport com.blamejared.searchables.lang.StringSearcher;\nimport net.minecraft.network.chat.Component;\nimport org.junit.jupiter.api.Test;\n", "import org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.contains;\nimport static org.hamcrest.Matchers.empty;\nimport static org.hamcrest.Matchers.hasItems;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.hamcrest.Matchers.is;", "import static org.hamcrest.Matchers.hasSize;\nimport static org.hamcrest.Matchers.is;\n\npublic class AutoCompleteTest {\n    \n    @Test\n    public void testNoResults() {\n        \n        String search = \"invalid\";\n        int position = 2;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, empty());\n    }\n    \n    @Test", "    public void testType() {\n        \n        String search = \"typ\";\n        int position = 2;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(suggestion(\"type\", \"type\", \":\", 0, 3)));\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type:\"));\n    }\n    \n    @Test", "    public void testTerm() {\n        \n        String search = \"type:sq\";\n        int position = 6;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(5));\n        assertThat(suggestions, hasItems(\n                suggestion(\"type:square\", \"square\", \" \", 0, 7),\n                suggestion(\"type:'sq\\\"uare'\", \"'sq\\\"uare'\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq`uare\\\"\", \"\\\"sq`uare\\\"\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq'uare\\\"\", \"\\\"sq'uare\\\"\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq uare\\\"\", \"\\\"sq uare\\\"\", \" \", 0, 7)\n        ));\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type:\\\"sq uare\\\" \"));\n        assertThat(suggestions.get(1).replaceIn(search), is(\"type:'sq\\\"uare' \"));\n        assertThat(suggestions.get(2).replaceIn(search), is(\"type:\\\"sq'uare\\\" \"));\n        assertThat(suggestions.get(3).replaceIn(search), is(\"type:\\\"sq`uare\\\" \"));\n        assertThat(suggestions.get(4).replaceIn(search), is(\"type:square \"));\n        \n    }\n    \n    @Test", "    public void testTypeAtStart() {\n        \n        String search = \"typ name:one\";\n        int position = 2;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"type\", \"type\", \":\", 0, 3))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type: name:one\"));\n    }\n    \n    @Test", "    public void testTermAtStart() {\n        \n        String search = \"type:sq name:one\";\n        int position = 6;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(5));\n        assertThat(suggestions, hasItems(\n                suggestion(\"type:square\", \"square\", \" \", 0, 7),\n                suggestion(\"type:'sq\\\"uare'\", \"'sq\\\"uare'\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq`uare\\\"\", \"\\\"sq`uare\\\"\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq'uare\\\"\", \"\\\"sq'uare\\\"\", \" \", 0, 7),\n                suggestion(\"type:\\\"sq uare\\\"\", \"\\\"sq uare\\\"\", \" \", 0, 7)\n        ));\n        // Is the extra space actually correct?\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type:\\\"sq uare\\\"  name:one\"));\n        assertThat(suggestions.get(1).replaceIn(search), is(\"type:'sq\\\"uare'  name:one\"));\n        assertThat(suggestions.get(2).replaceIn(search), is(\"type:\\\"sq'uare\\\"  name:one\"));\n        assertThat(suggestions.get(3).replaceIn(search), is(\"type:\\\"sq`uare\\\"  name:one\"));\n        assertThat(suggestions.get(4).replaceIn(search), is(\"type:square  name:one\"));\n    }\n    \n    @Test", "    public void testTypeAtEnd() {\n        \n        String search = \"name:one typ\";\n        int position = 10;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"type\", \"type\", \":\", 9, 12))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"name:one type:\"));\n    }\n    \n    @Test", "    public void testTermAtEnd() {\n        \n        String search = \"name:one type:s\";\n        int position = 15;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(5));\n        assertThat(suggestions, hasItems(\n                suggestion(\"type:square\", \"square\", \" \", 9, 15),\n                suggestion(\"type:'sq\\\"uare'\", \"'sq\\\"uare'\", \" \", 9, 15),\n                suggestion(\"type:\\\"sq`uare\\\"\", \"\\\"sq`uare\\\"\", \" \", 9, 15),\n                suggestion(\"type:\\\"sq'uare\\\"\", \"\\\"sq'uare\\\"\", \" \", 9, 15),\n                suggestion(\"type:\\\"sq uare\\\"\", \"\\\"sq uare\\\"\", \" \", 9, 15)\n        ));\n        assertThat(suggestions.get(0).replaceIn(search), is(\"name:one type:\\\"sq uare\\\" \"));\n        assertThat(suggestions.get(1).replaceIn(search), is(\"name:one type:'sq\\\"uare' \"));\n        assertThat(suggestions.get(2).replaceIn(search), is(\"name:one type:\\\"sq'uare\\\" \"));\n        assertThat(suggestions.get(3).replaceIn(search), is(\"name:one type:\\\"sq`uare\\\" \"));\n        assertThat(suggestions.get(4).replaceIn(search), is(\"name:one type:square \"));\n    }\n    \n    @Test", "    public void testTermAtColon() {\n        \n        String search = \"name:\";\n        int position = 5;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(13));\n        assertThat(suggestions, hasItems(\n                suggestion(\"name:zero\", \"zero\", \" \", 0, 5),\n                suggestion(\"name:one\", \"one\", \" \", 0, 5),\n                suggestion(\"name:two\", \"two\", \" \", 0, 5),\n                suggestion(\"name:three\", \"three\", \" \", 0, 5),\n                suggestion(\"name:four\", \"four\", \" \", 0, 5),\n                suggestion(\"name:five\", \"five\", \" \", 0, 5),\n                suggestion(\"name:six\", \"six\", \" \", 0, 5),\n                suggestion(\"name:seven\", \"seven\", \" \", 0, 5),\n                suggestion(\"name:eight\", \"eight\", \" \", 0, 5),\n                suggestion(\"name:nine\", \"nine\", \" \", 0, 5),\n                suggestion(\"name:ten\", \"ten\", \" \", 0, 5),\n                suggestion(\"name:eleven\", \"eleven\", \" \", 0, 5),\n                suggestion(\"name:twelve\", \"twelve\", \" \", 0, 5)\n        ));\n    }\n    \n    \n    @Test", "    public void testTypeAtStartReplacingTerm() {\n        \n        String search = \"name:one type:square\";\n        int position = 2;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"name\", \"name\", \":\", 0, 8))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"name: type:square\"));\n    }\n    \n    @Test", "    public void testTypeAtEndReplacingTerm() {\n        \n        String search = \"name:one type:square\";\n        int position = 10;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"type\", \"type\", \":\", 9, 20))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"name:one type:\"));\n    }\n    \n    @Test", "    public void testTypeInMiddle() {\n        \n        String search = \"colour:red name: type:square\";\n        int position = 12;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"name\", \"name\", \":\", 11, 16))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"colour:red name: type:square\"));\n    }\n    \n    @Test", "    public void testTermInMiddle() {\n        \n        String search = \"colour:red name:o type:square\";\n        int position = 17;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"name:one\", \"one\", \" \", 11, 17))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"colour:red name:one  type:square\"));\n    }\n    \n    @Test", "    public void testTypeInMiddleReplacingTerm() {\n        \n        String search = \"colour:red name:one type:square\";\n        int position = 12;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(1));\n        assertThat(suggestions, contains(\n                suggestion(\"name\", \"name\", \":\", 11, 19))\n        );\n        assertThat(suggestions.get(0).replaceIn(search), is(\"colour:red name: type:square\"));\n    }\n    \n    @Test", "    public void testStringTerm() {\n        \n        String search = \"type:`sq\";\n        int position = 7;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(5));\n        assertThat(suggestions, hasItems(\n                suggestion(\"type:square\", \"square\", \" \", 0, 8),\n                suggestion(\"type:'sq\\\"uare'\", \"'sq\\\"uare'\", \" \", 0, 8),\n                suggestion(\"type:\\\"sq`uare\\\"\", \"\\\"sq`uare\\\"\", \" \", 0, 8),\n                suggestion(\"type:\\\"sq'uare\\\"\", \"\\\"sq'uare\\\"\", \" \", 0, 8),\n                suggestion(\"type:\\\"sq uare\\\"\", \"\\\"sq uare\\\"\", \" \", 0, 8)\n        ));\n        // Is the extra space actually correct?\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type:\\\"sq uare\\\" \"));\n        assertThat(suggestions.get(1).replaceIn(search), is(\"type:'sq\\\"uare' \"));\n        assertThat(suggestions.get(2).replaceIn(search), is(\"type:\\\"sq'uare\\\" \"));\n        assertThat(suggestions.get(3).replaceIn(search), is(\"type:\\\"sq`uare\\\" \"));\n        assertThat(suggestions.get(4).replaceIn(search), is(\"type:square \"));\n    }\n    \n    @Test", "    public void testStringsTerm() {\n        \n        String search = \"type:`\";\n        int position = 6;\n        \n        CompletionVisitor visitor = new CompletionVisitor();\n        StringSearcher.search(search, visitor);\n        TokenRange replacementRange = visitor.rangeAt(position);\n        List<CompletionSuggestion> suggestions = TestConstants.SHAPE.getSuggestionsFor(TestConstants.SHAPES, search, position, replacementRange);\n        assertThat(suggestions, hasSize(7));\n        assertThat(suggestions, hasItems(\n                suggestion(\"type:triangle\", \"triangle\", \" \", 0, 6),\n                suggestion(\"type:square\", \"square\", \" \", 0, 6),\n                suggestion(\"type:circle\", \"circle\", \" \", 0, 6),\n                suggestion(\"type:'sq\\\"uare'\", \"'sq\\\"uare'\", \" \", 0, 6),\n                suggestion(\"type:\\\"sq`uare\\\"\", \"\\\"sq`uare\\\"\", \" \", 0, 6),\n                suggestion(\"type:\\\"sq'uare\\\"\", \"\\\"sq'uare\\\"\", \" \", 0, 6),\n                suggestion(\"type:\\\"sq uare\\\"\", \"\\\"sq uare\\\"\", \" \", 0, 6)\n        ));\n        assertThat(suggestions.get(0).replaceIn(search), is(\"type:circle \"));\n        assertThat(suggestions.get(1).replaceIn(search), is(\"type:\\\"sq uare\\\" \"));\n        assertThat(suggestions.get(2).replaceIn(search), is(\"type:'sq\\\"uare' \"));\n        assertThat(suggestions.get(3).replaceIn(search), is(\"type:\\\"sq'uare\\\" \"));\n        assertThat(suggestions.get(4).replaceIn(search), is(\"type:\\\"sq`uare\\\" \"));\n        assertThat(suggestions.get(5).replaceIn(search), is(\"type:square \"));\n        assertThat(suggestions.get(6).replaceIn(search), is(\"type:triangle \"));\n    }\n    \n    \n    private CompletionSuggestion suggestion(String suggestion, String display, String suffix, int rangeStart, int rangeEnd) {\n        \n        return new CompletionSuggestion(suggestion, Component.literal(display), suffix, TokenRange.between(rangeStart, rangeEnd));\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/SLScanner.java", "chunked_list": ["package com.blamejared.searchables.lang;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SLScanner {\n    \n    private final String source;\n    private final List<Token> tokens = new ArrayList<>();\n    private int start = 0;\n    private int current = 0;\n    \n    public SLScanner(final String source) {\n        \n        this.source = source;\n    }\n    \n    public List<Token> scanTokens() {\n        ", "        while(!isAtEnd()) {\n            // We are at the beginning of the next lexeme.\n            start = current;\n            scanToken();\n        }\n        \n        tokens.add(new Token(TokenType.EOL, \"\", \"\", start, current));\n        return tokens;\n    }\n    \n    private void scanToken() {\n        \n        char c = advance();\n        switch(c) {\n            case ' ' -> space();\n            case ':' -> addToken(TokenType.COLON, \":\");\n            case '\"' -> string('\"');\n            case '\\'' -> string('\\'');\n            case '`' -> string('`');\n            default -> identifier();\n        }\n    }\n    \n    private void space() {\n        \n        addToken(TokenType.SPACE, \" \");\n    }\n    \n    private void string(final char quote) {\n        ", "        while(peek() != quote && !isAtEnd()) {\n            advance();\n        }\n        \n        if(isAtEnd()) {\n            String value = source.substring(start + 1, current);\n            // Trim the surrounding quotes.\n            addToken(TokenType.STRING, value);\n        } else {\n            // The closing \".\n            advance();\n            String value = source.substring(start + 1, current - 1);\n            // Trim the surrounding quotes.\n            addToken(TokenType.STRING, value);\n        }\n    }\n    \n    private void identifier() {\n        ", "        while(!isAtEnd() && peek() != ' ' && peek() != ':') {\n            advance();\n        }\n        String value = source.substring(start, current);\n        addToken(TokenType.IDENTIFIER, value);\n    }\n    \n    private char peek() {\n        \n        if(isAtEnd()) {\n            return '\\0';\n        }\n        return source.charAt(current);\n    }\n    \n    private char advance() {\n        \n        return source.charAt(current++);\n    }\n    \n    private void addToken(final TokenType type, final String literal) {\n        \n        String text = source.substring(start, current);\n        tokens.add(new Token(type, text, literal, start, current));\n    }\n    \n    private boolean isAtEnd() {\n        \n        return current >= source.length();\n    }\n    \n}\n", "        if(isAtEnd()) {\n            return '\\0';\n        }\n        return source.charAt(current);\n    }\n    \n    private char advance() {\n        \n        return source.charAt(current++);\n    }\n    \n    private void addToken(final TokenType type, final String literal) {\n        \n        String text = source.substring(start, current);\n        tokens.add(new Token(type, text, literal, start, current));\n    }\n    \n    private boolean isAtEnd() {\n        \n        return current >= source.length();\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.lang;\n\nimport net.minecraft.*;\n\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/StringSearcher.java", "chunked_list": ["package com.blamejared.searchables.lang;\n\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\nimport java.util.Optional;\n\npublic class StringSearcher {\n    \n    /**\n     * Parses the string and visits the given visitor.\n     *\n     * @param search  The string to search.\n     * @param visitor The visitor to visit.\n     *\n     * @return The optional result of the visitor.\n     */\n    public static <T> Optional<T> search(final String search, final Visitor<T> visitor) {\n        \n        SLParser slParser = new SLParser(new SLScanner(search).scanTokens());\n        return slParser.parse().map(expression -> expression.accept(visitor)).map(visitor::postVisit);\n    }\n    \n    /**\n     * Parses the string and visits the given visitor with context.\n     *\n     * @param search  The string to search.\n     * @param visitor The visitor to visit.\n     * @param context The extra context for the visitor.\n     *\n     * @return The optional result of the visitor.\n     */\n    public static <T, C> Optional<T> search(final String search, final ContextAwareVisitor<T, C> visitor, final C context) {\n        \n        SLParser slParser = new SLParser(new SLScanner(search).scanTokens());\n        return slParser.parse()\n                .map(expression -> expression.accept(visitor, context))\n                .map(t -> visitor.postVisit(t, context));\n    }\n    \n    /**\n     * Parses the string and returns and optional {@link Expression}\n     *\n     * @param search The string to search.\n     *\n     * @return The string as an optional {@link Expression}\n     */", "public class StringSearcher {\n    \n    /**\n     * Parses the string and visits the given visitor.\n     *\n     * @param search  The string to search.\n     * @param visitor The visitor to visit.\n     *\n     * @return The optional result of the visitor.\n     */\n    public static <T> Optional<T> search(final String search, final Visitor<T> visitor) {\n        \n        SLParser slParser = new SLParser(new SLScanner(search).scanTokens());\n        return slParser.parse().map(expression -> expression.accept(visitor)).map(visitor::postVisit);\n    }\n    \n    /**\n     * Parses the string and visits the given visitor with context.\n     *\n     * @param search  The string to search.\n     * @param visitor The visitor to visit.\n     * @param context The extra context for the visitor.\n     *\n     * @return The optional result of the visitor.\n     */\n    public static <T, C> Optional<T> search(final String search, final ContextAwareVisitor<T, C> visitor, final C context) {\n        \n        SLParser slParser = new SLParser(new SLScanner(search).scanTokens());\n        return slParser.parse()\n                .map(expression -> expression.accept(visitor, context))\n                .map(t -> visitor.postVisit(t, context));\n    }\n    \n    /**\n     * Parses the string and returns and optional {@link Expression}\n     *\n     * @param search The string to search.\n     *\n     * @return The string as an optional {@link Expression}\n     */", "    public static Optional<Expression> expression(final String search) {\n        \n        SLParser slParser = new SLParser(new SLScanner(search).scanTokens());\n        return slParser.parse();\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/TokenType.java", "chunked_list": ["package com.blamejared.searchables.lang;\n\npublic enum TokenType {\n    COLON, IDENTIFIER, STRING, SPACE, EOL\n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/Token.java", "chunked_list": ["package com.blamejared.searchables.lang;\n\n@SuppressWarnings(\"ClassCanBeRecord\")\npublic class Token {\n    \n    private final TokenType type;\n    private final String lexeme;\n    private final String literal;\n    \n    private final int start;\n    private final int end;\n    \n    public Token(final TokenType type, final String lexeme, final String literal, final int start, final int end) {\n        \n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override", "    public String toString() {\n        \n        return \"Token{\" +\n                \"type=\" + type +\n                \", lexeme='\" + lexeme + '\\'' +\n                \", literal='\" + literal + '\\'' +\n                \", start=\" + start +\n                \", end=\" + end +\n                '}';\n    }\n    ", "    public TokenType type() {\n        \n        return type;\n    }\n    \n    public String lexeme() {\n        \n        return lexeme;\n    }\n    \n    public int start() {\n        \n        return start;\n    }\n    ", "    public int start() {\n        \n        return start;\n    }\n    \n    public int end() {\n        \n        return end;\n    }\n    \n    public String literal() {\n        \n        return literal;\n    }\n    \n}\n", "    public String literal() {\n        \n        return literal;\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/SLParser.java", "chunked_list": ["package com.blamejared.searchables.lang;\n\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.type.ComponentExpression;\nimport com.blamejared.searchables.lang.expression.type.GroupingExpression;\nimport com.blamejared.searchables.lang.expression.type.LiteralExpression;\nimport com.blamejared.searchables.lang.expression.type.PairedExpression;\n\nimport java.util.List;\nimport java.util.Optional;", "import java.util.List;\nimport java.util.Optional;\n\npublic class SLParser {\n    \n    private final List<Token> tokens;\n    private int current = 0;\n    \n    public SLParser(final List<Token> tokens) {\n        \n        this.tokens = tokens;\n    }\n    \n    public Optional<Expression> parse() {\n        ", "        if(tokens.size() == 1 && check(TokenType.EOL)) {\n            return Optional.empty();\n        }\n        \n        return Optional.of(expression());\n    }\n    \n    private Expression expression() {\n        \n        return grouping();\n    }\n    \n    \n    private Expression grouping() {\n        \n        Expression expr = literal();\n        ", "        while(match(TokenType.SPACE)) {\n            Token operator = previous();\n            Expression right = literal();\n            \n            expr = operator.type() == TokenType.COLON ? new ComponentExpression(expr, operator, right) : new GroupingExpression(expr, operator, right);\n        }\n        return expr;\n    }\n    \n    private Expression literal() {\n        ", "        if(match(TokenType.COLON)) {\n            Token prevColon = previous();\n            if(match(TokenType.IDENTIFIER)) {\n                Token prevIdent = previous();\n                LiteralExpression first = new LiteralExpression(prevColon.literal(), prevColon.lexeme());\n                LiteralExpression second = new LiteralExpression(prevIdent.literal(), prevIdent.lexeme());\n                return new PairedExpression(first, second);\n            }\n        }\n        if(match(TokenType.IDENTIFIER)) {\n            Token previous = previous();", "        if(match(TokenType.IDENTIFIER)) {\n            Token previous = previous();\n            if(check(TokenType.COLON)) {\n                return new ComponentExpression(new LiteralExpression(previous.literal(), previous.lexeme()), advance(), literal());\n            }\n            return new LiteralExpression(previous.literal(), previous.lexeme());\n        }\n        \n        if(match(TokenType.STRING)) {\n            Token previous = previous();\n            return new LiteralExpression(previous.literal(), previous.lexeme());\n        }\n        \n        return new LiteralExpression(\"\", \"\");\n    }\n    \n    private boolean match(final TokenType... types) {\n        ", "        if(match(TokenType.STRING)) {\n            Token previous = previous();\n            return new LiteralExpression(previous.literal(), previous.lexeme());\n        }\n        \n        return new LiteralExpression(\"\", \"\");\n    }\n    \n    private boolean match(final TokenType... types) {\n        \n        for(TokenType type : types) {", "        for(TokenType type : types) {\n            if(check(type)) {\n                advance();\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean check(final TokenType type) {\n        ", "        if(isAtEnd()) {\n            return false;\n        }\n        return peek().type() == type;\n    }\n    \n    private Token advance() {\n        \n        if(!isAtEnd()) {\n            current++;\n        }\n        return previous();\n    }\n    \n    private boolean isAtEnd() {\n        \n        return peek().type() == TokenType.EOL;\n    }\n    \n    private Token peek() {\n        \n        return tokens.get(current);\n    }\n    \n    private Token previous() {\n        \n        return tokens.get(current - 1);\n    }\n    \n}\n", "        if(!isAtEnd()) {\n            current++;\n        }\n        return previous();\n    }\n    \n    private boolean isAtEnd() {\n        \n        return peek().type() == TokenType.EOL;\n    }\n    \n    private Token peek() {\n        \n        return tokens.get(current);\n    }\n    \n    private Token previous() {\n        \n        return tokens.get(current - 1);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/Expression.java", "chunked_list": ["package com.blamejared.searchables.lang.expression;\n\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\npublic abstract class Expression {\n    \n    public abstract <R> R accept(final Visitor<R> visitor);\n    \n    public abstract <R, C> R accept(final ContextAwareVisitor<R, C> visitor, final C context);\n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.lang.expression;\n\n\nimport net.minecraft.FieldsAreNonnullByDefault;\nimport net.minecraft.MethodsReturnNonnullByDefault;\n\nimport javax.annotation.ParametersAreNonnullByDefault;", "\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/type/ComponentExpression.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.type;\n\nimport com.blamejared.searchables.lang.Token;\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\npublic class ComponentExpression extends Expression {\n    \n    private final Expression left;\n    private final Token operator;\n    private final Expression right;\n    \n    public ComponentExpression(final Expression left, final Token operator, final Expression right) {\n        \n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    \n    @Override\n    public <R> R accept(final Visitor<R> visitor) {\n        \n        return visitor.visitComponent(this);\n    }\n    \n    @Override\n    public <R, C> R accept(final ContextAwareVisitor<R, C> visitor, final C context) {\n        \n        return visitor.visitComponent(this, context);\n    }\n    ", "    public Expression left() {\n        \n        return left;\n    }\n    \n    public Token operator() {\n        \n        return operator;\n    }\n    \n    public Expression right() {\n        \n        return right;\n    }\n    \n    @Override", "    public Expression right() {\n        \n        return right;\n    }\n    \n    @Override\n    public String toString() {\n        \n        return \"[%s%s%s]\".formatted(left, operator.literal(), right);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/type/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.lang.expression.type;\n\n\nimport net.minecraft.FieldsAreNonnullByDefault;\nimport net.minecraft.MethodsReturnNonnullByDefault;\n\nimport javax.annotation.ParametersAreNonnullByDefault;", "\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/type/GroupingExpression.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.type;\n\nimport com.blamejared.searchables.lang.Token;\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\npublic class GroupingExpression extends Expression {\n    \n    private final Expression left;\n    private final Token operator;\n    private final Expression right;\n    \n    public GroupingExpression(final Expression left, final Token operator, final Expression right) {\n        \n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    \n    @Override\n    public <R> R accept(final Visitor<R> visitor) {\n        \n        return visitor.visitGrouping(this);\n    }\n    \n    @Override\n    public <R, C> R accept(final ContextAwareVisitor<R, C> visitor, final C context) {\n        \n        return visitor.visitGrouping(this, context);\n    }\n    ", "    public Expression left() {\n        \n        return left;\n    }\n    \n    public Token operator() {\n        \n        return operator;\n    }\n    \n    public Expression right() {\n        \n        return right;\n    }\n    \n    \n    @Override", "    public Expression right() {\n        \n        return right;\n    }\n    \n    \n    @Override\n    public String toString() {\n        \n        return \"(%s%s%s)\".formatted(left, operator.literal(), right);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/type/PairedExpression.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.type;\n\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\npublic class PairedExpression extends Expression {\n    \n    private final Expression first;\n    private final Expression second;\n    \n    public PairedExpression(final Expression first, final Expression second) {\n        \n        this.first = first;\n        this.second = second;\n    }\n    ", "    public Expression first() {\n        \n        return first;\n    }\n    \n    public Expression second() {\n        \n        return second;\n    }\n    \n    @Override\n    public <R> R accept(final Visitor<R> visitor) {\n        \n        return visitor.visitPaired(this);\n    }\n    \n    @Override\n    public <R, C> R accept(final ContextAwareVisitor<R, C> visitor, final C context) {\n        \n        return visitor.visitPaired(this, context);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/type/LiteralExpression.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.type;\n\nimport com.blamejared.searchables.lang.expression.Expression;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\npublic class LiteralExpression extends Expression {\n    \n    private final String value;\n    private final String displayValue;\n    \n    public LiteralExpression(final String value, final String displayValue) {\n        \n        this.value = value;\n        this.displayValue = displayValue;\n    }\n    \n    @Override\n    public <R> R accept(final Visitor<R> visitor) {\n        \n        return visitor.visitLiteral(this);\n    }\n    \n    @Override\n    public <R, C> R accept(final ContextAwareVisitor<R, C> visitor, final C context) {\n        \n        return visitor.visitLiteral(this, context);\n    }\n    ", "    public String value() {\n        \n        return value;\n    }\n    \n    public String displayValue() {\n        \n        return displayValue;\n    }\n    \n    @Override", "    public String toString() {\n        \n        return value;\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/visitor/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.lang.expression.visitor;\n\n\nimport net.minecraft.FieldsAreNonnullByDefault;\nimport net.minecraft.MethodsReturnNonnullByDefault;\n\nimport javax.annotation.ParametersAreNonnullByDefault;", "\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/visitor/ContextAwareVisitor.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.visitor;\n\nimport com.blamejared.searchables.lang.expression.type.ComponentExpression;\nimport com.blamejared.searchables.lang.expression.type.GroupingExpression;\nimport com.blamejared.searchables.lang.expression.type.LiteralExpression;\nimport com.blamejared.searchables.lang.expression.type.PairedExpression;\n\npublic interface ContextAwareVisitor<R, C> {\n    \n    R visitGrouping(GroupingExpression expr, C context);\n    \n    R visitComponent(ComponentExpression expr, C context);\n    \n    R visitLiteral(LiteralExpression expr, C context);\n    \n    R visitPaired(PairedExpression expr, C context);\n    \n    default R postVisit(R obj, C context) {\n        \n        return obj;\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/lang/expression/visitor/Visitor.java", "chunked_list": ["package com.blamejared.searchables.lang.expression.visitor;\n\nimport com.blamejared.searchables.lang.expression.type.ComponentExpression;\nimport com.blamejared.searchables.lang.expression.type.GroupingExpression;\nimport com.blamejared.searchables.lang.expression.type.LiteralExpression;\nimport com.blamejared.searchables.lang.expression.type.PairedExpression;\n\npublic interface Visitor<R> {\n    \n    R visitGrouping(GroupingExpression expr);\n    \n    R visitComponent(ComponentExpression expr);\n    \n    R visitLiteral(LiteralExpression expr);\n    \n    R visitPaired(PairedExpression expr);\n    \n    default R postVisit(R obj) {\n        return obj;\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.api;\n\nimport net.minecraft.*;\n\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/SearchableType.java", "chunked_list": ["package com.blamejared.searchables.api;\n\nimport com.blamejared.searchables.api.autcomplete.CompletionSuggestion;\nimport com.blamejared.searchables.api.context.ContextVisitor;\nimport com.blamejared.searchables.api.context.SearchContext;\nimport com.blamejared.searchables.lang.StringSearcher;\nimport com.google.common.base.CharMatcher;\nimport com.google.common.collect.ImmutableMap;\nimport net.minecraft.network.chat.Component;\nimport org.apache.commons.lang3.StringUtils;", "import net.minecraft.network.chat.Component;\nimport org.apache.commons.lang3.StringUtils;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Predicate;", "import java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\npublic final class SearchableType<T> {\n    \n    private final Map<String, SearchableComponent<T>> components;\n    @Nullable\n    private final SearchableComponent<T> defaultComponent;\n    \n    private SearchableType(final Map<String, SearchableComponent<T>> components, @Nullable final SearchableComponent<T> defaultComponent) {\n        \n        this.components = components;\n        this.defaultComponent = defaultComponent;\n    }\n    \n    public Map<String, SearchableComponent<T>> components() {\n        \n        return components;\n    }\n    \n    public Optional<SearchableComponent<T>> component(final String key) {\n        \n        return Optional.ofNullable(components.get(key));\n    }\n    \n    public Optional<SearchableComponent<T>> defaultComponent() {\n        \n        return Optional.ofNullable(defaultComponent);\n    }\n    \n    public List<CompletionSuggestion> getSuggestionsFor(final List<T> entries, final String currentToken, final int position, final TokenRange replacementRange) {\n        \n        final TokenRange suggestionRange = replacementRange.rangeAtPosition(position);\n        final String suggestionFrom = suggestionRange.substring(currentToken, position);\n        final int suggestionIndex = replacementRange.rangeIndexAtPosition(position);\n        return switch(suggestionIndex) {\n            case 0 -> getSuggestionsForComponent(\n                    suggestionFrom,\n                    replacementRange.simplify());\n            case 1 -> getSuggestionsForTerm(\n                    entries,\n                    replacementRange.range(0).substring(currentToken),\n                    \"\",\n                    replacementRange.simplify());\n            case 2 -> getSuggestionsForTerm(\n                    entries,\n                    replacementRange.range(0).substring(currentToken),\n                    suggestionFrom,\n                    replacementRange.simplify());\n            default -> List.of();\n        };\n    }\n    \n    public List<CompletionSuggestion> getSuggestionsForComponent(final String componentName, final TokenRange replacementRange) {\n        \n        return this.components()\n                .keySet()\n                .stream()\n                .filter(s -> StringUtils.startsWithIgnoreCase(s, componentName))\n                .sorted(Comparator.naturalOrder())\n                .map(s -> new CompletionSuggestion(s, Component.literal(s), \":\", replacementRange))\n                .distinct()\n                .collect(Collectors.toList());\n    }\n    \n    public List<CompletionSuggestion> getSuggestionsForTerm(final List<T> entries, final String componentName, final String current, final TokenRange replacementRange) {\n        \n        final Function<T, Optional<String>> mapper = this.component(componentName)\n                .map(SearchableComponent::getToString)\n                .orElseGet(() -> t -> Optional.empty());\n        final boolean startsWithQuote = !current.isEmpty() && CharMatcher.anyOf(\"`'\\\"\").matches(current.charAt(0));\n        String termString = startsWithQuote ? current.substring(1) : current;\n        return entries.stream()\n                .map(mapper)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .filter(s -> StringUtils.startsWithIgnoreCase(s, termString))\n                .sorted(Comparator.naturalOrder())\n                .map(SearchablesConstants.QUOTE)\n                .map(s -> new CompletionSuggestion(componentName + \":\" + s, Component.literal(s), \" \", replacementRange))\n                .distinct()\n                .collect(Collectors.toList());\n        \n    }\n    \n    public List<T> filterEntries(final List<T> entries, final String search) {\n        \n        return filterEntries(entries, search, t -> true);\n    }\n    \n    public List<T> filterEntries(final List<T> entries, final String search, final Predicate<T> extraPredicate) {\n        \n        Optional<SearchContext<T>> context = StringSearcher.search(search, new ContextVisitor<>());\n        return entries.stream()\n                .filter(context.map(tSearchContext -> tSearchContext.createPredicate(this))\n                        .orElse(t -> true)\n                        .and(extraPredicate))\n                .toList();\n    }\n    ", "    public static class Builder<T> {\n        \n        private final ImmutableMap.Builder<String, SearchableComponent<T>> components;\n        \n        @Nullable\n        private SearchableComponent<T> defaultComponent;\n        \n        public Builder() {\n            \n            this.components = ImmutableMap.builder();\n            this.defaultComponent = null;\n        }\n        \n        public Builder<T> component(final SearchableComponent<T> component) {\n            \n            return component(component.key(), component);\n        }\n        \n        public Builder<T> component(final String key, final SearchableComponent<T> component) {\n            \n            components.put(key, component);\n            return this;\n        }\n        \n        public Builder<T> defaultComponent(final SearchableComponent<T> component) {\n            \n            return defaultComponent(component.key(), component);\n        }\n        \n        public Builder<T> defaultComponent(final String key, final SearchableComponent<T> component) {\n            ", "            if(defaultComponent != null) {\n                throw new IllegalStateException(\"Cannot mark multiple components as a default component!\");\n            }\n            components.put(key, component);\n            defaultComponent = component;\n            return this;\n        }\n        \n        public SearchableType<T> build() {\n            //TODO An event could be fired here to allow 3rd parties to add new components\n            return new SearchableType<>(components.buildOrThrow(), defaultComponent);\n        }\n        \n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/TokenRange.java", "chunked_list": ["package com.blamejared.searchables.api;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.*;\n\n/**\n * A range denoting the start and end of a Token, as well as any tokens inside that range.\n */\npublic final class TokenRange implements Comparable<TokenRange>, Iterable<TokenRange> {\n    ", " */\npublic final class TokenRange implements Comparable<TokenRange>, Iterable<TokenRange> {\n    \n    public static final TokenRange EMPTY = at(0);\n    \n    /**\n     * Creates a new {@link TokenRange} at the given position\n     *\n     * @param position The position of the token.\n     *\n     * @return a new {@link TokenRange} at the given position\n     */", "    public static TokenRange at(final int position) {\n        \n        return new TokenRange(position, position);\n    }\n    \n    /**\n     * Creates a new {@link TokenRange} with the given start and end.\n     *\n     * @param start The start of the range.\n     * @param end   The end of the range.\n     *\n     * @return A new {@link TokenRange} at the given start and end.\n     */", "    public static TokenRange between(final int start, final int end) {\n        \n        return new TokenRange(start, end);\n    }\n    \n    /**\n     * Creates a new {@link TokenRange} that covers both the first and second token.\n     *\n     * @param first  The first token to cover.\n     * @param second The second token to cover.\n     *\n     * @return A new {@link TokenRange} that covers both the first and second token.\n     */", "    public static TokenRange encompassing(final TokenRange first, final TokenRange second) {\n        \n        return new TokenRange(Math.min(first.start(), second.start()), Math.max(first.end(), second.end()));\n    }\n    \n    private final int start;\n    private final int end;\n    \n    private final SortedSet<TokenRange> subRanges;\n    \n    private TokenRange(final int start, final int end) {\n        \n        this.start = start;\n        this.end = end;\n        this.subRanges = new TreeSet<>();\n    }\n    \n    /**\n     * Adds a range as a subrange to this range.\n     *\n     * @param range The range to add.\n     */", "    public void addRange(final TokenRange range) {\n        \n        this.subRanges.add(range);\n    }\n    \n    /**\n     * Adds a collection of ranges as subranges to this range.\n     *\n     * @param ranges The ranges to add.\n     */\n    public void addRanges(final Collection<TokenRange> ranges) {\n        \n        this.subRanges.addAll(ranges);\n    }\n    \n    public Set<TokenRange> subRanges() {\n        \n        return subRanges;\n    }\n    \n    /**\n     * Gets the subrange at the given index.\n     *\n     * @param index The index to get.\n     *\n     * @return The range at the given index\n     *\n     * @throws IndexOutOfBoundsException if index is outside the bounds of subranges.\n     */", "    public void addRanges(final Collection<TokenRange> ranges) {\n        \n        this.subRanges.addAll(ranges);\n    }\n    \n    public Set<TokenRange> subRanges() {\n        \n        return subRanges;\n    }\n    \n    /**\n     * Gets the subrange at the given index.\n     *\n     * @param index The index to get.\n     *\n     * @return The range at the given index\n     *\n     * @throws IndexOutOfBoundsException if index is outside the bounds of subranges.\n     */", "    public TokenRange range(final int index) {\n        \n        return subRanges().stream().skip(index).findFirst().orElseThrow(IndexOutOfBoundsException::new);\n    }\n    \n    /**\n     * Gets the index of the range at the given position.\n     * If there are no sub ranges, this will return {@code 0}\n     *\n     * @param position The position to get.\n     *\n     * @return The index of the range at the given position, or 0 if\n     *\n     * @throws IndexOutOfBoundsException if the position is not within this range's bounds.\n     */", "    public int rangeIndexAtPosition(final int position) {\n        \n        if(!this.contains(position)) {\n            throw new IndexOutOfBoundsException();\n        }\n        int i = 0;\n        for(TokenRange subRange : subRanges()) {\n            if(!subRange.contains(position)) {\n                i++;\n                continue;\n            }\n            break;\n        }\n        return i;\n    }\n    ", "    public TokenRange rangeAtPosition(final int position) {\n        \n        //TODO if a range is empty, it may have issues getting, but I need a repro case to test and fix.\n        return subRanges.stream()\n                .filter(tokenRange -> tokenRange.contains(position))\n                .findFirst()\n                .orElse(this);\n    }\n    \n    /**\n     * Creates a new {@link TokenRange} at this range's start and end, without any subranges.\n     *\n     * @return\n     */", "    public TokenRange simplify() {\n        \n        return TokenRange.between(this.start(), this.end());\n    }\n    \n    \n    /**\n     * Checks if this range fully covers the other range.\n     *\n     * @param other The range to see if this range covers.\n     *\n     * @return true if this range covers the other range, false otherwise.\n     */", "    public boolean covers(final TokenRange other) {\n        \n        return this.start() <= other.start() && other.end() <= this.end();\n    }\n    \n    /**\n     * Checks if this range contains the given position.\n     *\n     * @param position The position to check.\n     *\n     * @return true if it contains, false otherwise.\n     */", "    public boolean contains(final int position) {\n        \n        return (this.start() <= position && position <= this.end());\n    }\n    \n    /**\n     * Performs a substring on the given string using this range's start and end.\n     *\n     * @param of The string to substring.\n     *\n     * @return The substring of the given string using this range's start and end.\n     */", "    public String substring(final String of) {\n        \n        return of.substring(this.start(), this.end());\n    }\n    \n    /**\n     * Performs a substring on the given string using this range's start and the given end.\n     *\n     * @param of  The string to substring.\n     * @param end The end position.\n     *\n     * @return The substring of the given string using this range's start and the given end.\n     */", "    public String substring(final String of, final int end) {\n        \n        return of.substring(this.start(), end);\n    }\n    \n    /**\n     * Deletes the content of the given string that this range covers.\n     *\n     * @param from The string to delete from.\n     *\n     * @return The string with the contents inside this range's position removed.\n     */", "    public String delete(final String from) {\n        \n        return new StringBuilder(from).delete(this.start(), this.end()).toString();\n    }\n    \n    /**\n     * Inserts the {@code toInsert} into the given string at this range's start position.\n     *\n     * @param to       The string to insert into.\n     * @param toInsert The string to insert.\n     *\n     * @return The given string with the insertion added at this range's start position.\n     */", "    public String insert(final String to, final String toInsert) {\n        \n        return new StringBuilder(to).insert(this.start(), toInsert).toString();\n    }\n    \n    /**\n     * Replaces the contents of the string at this range's positions with the given {@code toInsert}\n     *\n     * @param into     The string to insert into\n     * @param toInsert The string to insert.\n     *\n     * @return The given string with the insertion added at this range's position.\n     */", "    public String replace(final String into, final String toInsert) {\n        \n        return insert(delete(into), toInsert);\n    }\n    \n    /**\n     * Checks if this range is empty.\n     *\n     * @return true if empty, false otherwise.\n     */\n    public boolean isEmpty() {\n        \n        return this.start() == this.end();\n    }\n    \n    /**\n     * Gets the length of this range.\n     *\n     * @return the length of the range.\n     */", "    public boolean isEmpty() {\n        \n        return this.start() == this.end();\n    }\n    \n    /**\n     * Gets the length of this range.\n     *\n     * @return the length of the range.\n     */\n    public int length() {\n        \n        return this.end() - this.start();\n    }\n    ", "    public int length() {\n        \n        return this.end() - this.start();\n    }\n    \n    public int start() {\n        \n        return start;\n    }\n    \n    public int end() {\n        \n        return end;\n    }\n    \n    /**\n     * Creates a new range that fully covers the subranges starts and ends.\n     *\n     * @return a new range that fully covers the subranges starts and ends.\n     */", "    public int end() {\n        \n        return end;\n    }\n    \n    /**\n     * Creates a new range that fully covers the subranges starts and ends.\n     *\n     * @return a new range that fully covers the subranges starts and ends.\n     */\n    public TokenRange recalculate() {\n        ", "    public TokenRange recalculate() {\n        \n        if(this.subRanges().isEmpty()) {\n            return this;\n        }\n        int start = this.subRanges()\n                .stream()\n                .min(Comparator.comparing(TokenRange::end))\n                .map(TokenRange::start)\n                .orElse(this.start());\n        int end = this.subRanges()\n                .stream()\n                .max(Comparator.comparing(TokenRange::end))\n                .map(TokenRange::end)\n                .orElse(this.end());\n        ", "        if(start == this.start() && end == this.end()) {\n            return this;\n        }\n        \n        TokenRange newRange = TokenRange.between(start, end);\n        newRange.subRanges().addAll(this.subRanges());\n        return newRange;\n    }\n    \n    @Override\n    public boolean equals(final Object o) {\n        ", "    public boolean equals(final Object o) {\n        \n        if(this == o) {\n            return true;\n        }\n        if(o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        \n        TokenRange that = (TokenRange) o;\n        ", "        if(start != that.start) {\n            return false;\n        }\n        if(end != that.end) {\n            return false;\n        }\n        return Objects.equals(subRanges, that.subRanges);\n    }\n    \n    @Override\n    public int hashCode() {\n        \n        int result = start;\n        result = 31 * result + end;\n        result = 31 * result + subRanges.hashCode();\n        return result;\n    }\n    \n    @Override", "    public int hashCode() {\n        \n        int result = start;\n        result = 31 * result + end;\n        result = 31 * result + subRanges.hashCode();\n        return result;\n    }\n    \n    @Override\n    public String toString() {\n        \n        return \"TokenRange{\" +\n                \"start=\" + start +\n                \", end=\" + end +\n                \", subRanges=\" + subRanges +\n                '}';\n    }\n    \n    @Override", "    public String toString() {\n        \n        return \"TokenRange{\" +\n                \"start=\" + start +\n                \", end=\" + end +\n                \", subRanges=\" + subRanges +\n                '}';\n    }\n    \n    @Override\n    public int compareTo(@NotNull final TokenRange o) {\n        \n        return Integer.compare(this.start(), o.start());\n    }\n    \n    @NotNull\n    @Override\n    public Iterator<TokenRange> iterator() {\n        \n        return this.subRanges().iterator();\n    }\n    \n}\n", "    public int compareTo(@NotNull final TokenRange o) {\n        \n        return Integer.compare(this.start(), o.start());\n    }\n    \n    @NotNull\n    @Override\n    public Iterator<TokenRange> iterator() {\n        \n        return this.subRanges().iterator();\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/SearchablesConstants.java", "chunked_list": ["package com.blamejared.searchables.api;\n\nimport net.minecraft.Util;\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.resources.ResourceLocation;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\npublic class SearchablesConstants {\n    ", "import java.util.function.Predicate;\n\npublic class SearchablesConstants {\n    \n    public static final String MOD_ID = \"searchables\";\n    public static final String STRING_CHARACTERS = \"'\\\"`\";\n    \n    public static final Component COMPONENT_SEARCH = Component.translatable(\"options.search\");\n    \n    // A user can't search for a term that contains at-least one of each string character,\n    // as it will be impossible to tokenize as the engine doesn't have escaped quotes (yet), so lets filter them out.", "    public static final Predicate<String> VALID_SUGGESTION = s -> {\n        int quoteCount = 0;\n        for(int i = 0; i < SearchablesConstants.STRING_CHARACTERS.length(); i++) {\n            if(StringUtils.contains(s, SearchablesConstants.STRING_CHARACTERS.charAt(i))) {\n                quoteCount++;\n            }\n        }\n        return quoteCount < 3;\n    };\n    \n    // If a term contains a string character or a space, we should quote it for searchability.", "    public static final Function<String, String> QUOTE = Util.memoize(s -> {\n        if(StringUtils.containsNone(s, SearchablesConstants.STRING_CHARACTERS + \" \")) {\n            return s;\n        }\n        char quoteChar = '\"';\n        while(StringUtils.contains(s, quoteChar)) {\n            quoteChar = switch(quoteChar) {\n                case '\"' -> '\\'';\n                case '\\'' -> '`';\n                default ->\n                        throw new IllegalStateException(\"Unable to nicely wrap {\" + s + \"}! Make sure to filter Strings through 'SearchableComponent#VALID_SUGGESTION'!\");\n            };\n        }\n        return StringUtils.wrap(s, quoteChar);\n    });\n    ", "    public static ResourceLocation rl(final String path) {\n        \n        return new ResourceLocation(MOD_ID, path);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/SearchableComponent.java", "chunked_list": ["package com.blamejared.searchables.api;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Optional;\nimport java.util.StringJoiner;\nimport java.util.function.BiPredicate;\nimport java.util.function.Function;\n\n/**", "\n/**\n * A component of a {@link SearchableType<T>}.\n */\npublic class SearchableComponent<T> {\n    \n    private final String key;\n    \n    private final Function<T, Optional<String>> toString;\n    \n    private final BiPredicate<T, String> filter;\n    \n    private SearchableComponent(final String key, final Function<T, Optional<String>> toString, final BiPredicate<T, String> filter) {\n        \n        this.key = key;\n        this.toString = toString.andThen(s -> s.filter(SearchablesConstants.VALID_SUGGESTION));\n        this.filter = filter;\n    }\n    \n    /**\n     * Creates a component that will not show in auto-complete, but will still be able to be filtered\n     *\n     * @param key    The key for this term.\n     * @param filter a {@link BiPredicate} to filter the element ({@code T}) and the given search String\n     * @param <T>    The type of element that this {@link SearchableComponent<T>} handles.\n     *\n     * @return a new {@link SearchableComponent<T>} from the given values.\n     */\n    public static <T> SearchableComponent<T> create(final String key, final BiPredicate<T, String> filter) {\n        \n        return create(key, t -> Optional.empty(), filter);\n    }\n    \n    /**\n     * Creates a component from the given values.\n     *\n     * @param key      The key for this term.\n     * @param toString a {@link Function} to convert a given {@code T} to an {@link Optional<String>}, used to display the \"name\" of an element for auto-complete\n     * @param filter   a {@link BiPredicate} to filter the element ({@code T}) and the given search String\n     * @param <T>      The type of element that this {@link SearchableComponent<T>} handles.\n     *\n     * @return a new {@link SearchableComponent<T>} from the given values.\n     */\n    public static <T> SearchableComponent<T> create(final String key, final Function<T, Optional<String>> toString, final BiPredicate<T, String> filter) {\n        \n        return new SearchableComponent<>(key, toString, filter);\n    }\n    \n    /**\n     * Creates a component from the given values, that uses the {@code toString} function to filter based on if the name of the element contains the given search string (case-insensitive)\n     *\n     * @param key      The key for this term.\n     * @param toString a {@link Function} to convert a given {@code T} to an {@link Optional<String>}, used to display the \"name\" of an element for auto-complete and for filtering.\n     * @param <T>      The type of element that this {@link SearchableComponent<T>} handles.\n     *\n     * @return a new {@link SearchableComponent<T>} from the given values.\n     */\n    public static <T> SearchableComponent<T> create(final String key, final Function<T, Optional<String>> toString) {\n        \n        return new SearchableComponent<>(key, toString, (t, search) -> toString.apply(t)\n                .map(tStr -> StringUtils.containsIgnoreCase(tStr, search))\n                .orElse(false));\n    }\n    ", "    public String key() {\n        \n        return key;\n    }\n    \n    public BiPredicate<T, String> filter() {\n        \n        return filter;\n    }\n    \n    public Function<T, Optional<String>> getToString() {\n        \n        return toString;\n    }\n    \n    @Override", "    public String toString() {\n        \n        return new StringJoiner(\", \", SearchableComponent.class.getSimpleName() + \"[\", \"]\").add(\"key='\" + key + \"'\")\n                .toString();\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/ContextVisitor.java", "chunked_list": ["package com.blamejared.searchables.api.context;\n\nimport com.blamejared.searchables.lang.expression.type.*;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\n/**\n * Compiles a {@link SearchContext<T>}, which holds {@link SearchLiteral<T>}({@code \"orange\"}) and {@link SearchComponent<T>}({@code \"color:orange\"})\n */\npublic final class ContextVisitor<T> implements Visitor<SearchContext<T>> {\n    \n    private final SearchContext<T> context = new SearchContext<>();\n    \n    @Override\n    public SearchContext<T> visitGrouping(final GroupingExpression expr) {\n        \n        expr.left().accept(this);\n        expr.right().accept(this);\n        return context;\n    }\n    \n    @Override\n    public SearchContext<T> visitComponent(final ComponentExpression expr) {\n        ", "public final class ContextVisitor<T> implements Visitor<SearchContext<T>> {\n    \n    private final SearchContext<T> context = new SearchContext<>();\n    \n    @Override\n    public SearchContext<T> visitGrouping(final GroupingExpression expr) {\n        \n        expr.left().accept(this);\n        expr.right().accept(this);\n        return context;\n    }\n    \n    @Override\n    public SearchContext<T> visitComponent(final ComponentExpression expr) {\n        ", "        if(expr.left() instanceof LiteralExpression leftLit && expr.right() instanceof LiteralExpression rightLit) {\n            context.add(new SearchComponent<>(leftLit.value(), rightLit.value()));\n        } else {\n            //TODO Do we want to handle a case of 'first:second:third'?\n            //This *should* be an error case, but it can also be put into a component\n        }\n        return context;\n    }\n    \n    @Override\n    public SearchContext<T> visitLiteral(final LiteralExpression expr) {\n        \n        context.add(new SearchLiteral<>(expr.value()));\n        return context;\n    }\n    \n    @Override\n    public SearchContext<T> visitPaired(final PairedExpression expr) {\n        \n        expr.first().accept(this);\n        expr.second().accept(this);\n        return context;\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/SearchComponent.java", "chunked_list": ["\npackage com.blamejared.searchables.api.context;\n\nimport com.blamejared.searchables.api.SearchableComponent;\nimport com.blamejared.searchables.api.SearchableType;\n\nimport java.util.function.Predicate;\n\nrecord SearchComponent<T>(String key, String value) implements SearchPredicate<T> {\n    ", "record SearchComponent<T>(String key, String value) implements SearchPredicate<T> {\n    \n    @Override\n    public Predicate<T> predicateFrom(final SearchableType<T> type) {\n        \n        return type.component(key())\n                .map(SearchableComponent::filter)\n                .<Predicate<T>> map(filter -> t -> filter.test(t, value()))\n                .orElse(t -> true);\n    }", "                .orElse(t -> true);\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.api.context;\n\nimport net.minecraft.*;\n\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/SearchLiteral.java", "chunked_list": ["package com.blamejared.searchables.api.context;\n\nimport com.blamejared.searchables.api.SearchableComponent;\nimport com.blamejared.searchables.api.SearchableType;\n\nimport java.util.function.Predicate;\n\nrecord SearchLiteral<T>(String value) implements SearchPredicate<T> {\n    \n    @Override", "    \n    @Override\n    public Predicate<T> predicateFrom(final SearchableType<T> type) {\n        \n        return type.defaultComponent()\n                .map(SearchableComponent::filter)\n                .<Predicate<T>> map(filter -> t -> filter.test(t, value()))\n                .orElse(t -> true);\n    }\n    ", "    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/SearchContext.java", "chunked_list": ["package com.blamejared.searchables.api.context;\n\nimport com.blamejared.searchables.api.SearchableType;\n\nimport java.util.*;\nimport java.util.function.Predicate;\n\n/**\n * Holds {@link SearchPredicate<T>} to be reduced to a single {@link Predicate<T>} for use in filtering.\n */\npublic final class SearchContext<T> {\n    \n    private final List<SearchPredicate<T>> predicates;\n    \n    public SearchContext() {\n        \n        this.predicates = new ArrayList<>();\n    }\n    \n    public Predicate<T> createPredicate(final SearchableType<T> type) {\n        \n        return predicates.stream()\n                .map(tSearchPredicate -> tSearchPredicate.predicateFrom(type))\n                .reduce(t -> true, Predicate::and);\n    }\n    ", " * Holds {@link SearchPredicate<T>} to be reduced to a single {@link Predicate<T>} for use in filtering.\n */\npublic final class SearchContext<T> {\n    \n    private final List<SearchPredicate<T>> predicates;\n    \n    public SearchContext() {\n        \n        this.predicates = new ArrayList<>();\n    }\n    \n    public Predicate<T> createPredicate(final SearchableType<T> type) {\n        \n        return predicates.stream()\n                .map(tSearchPredicate -> tSearchPredicate.predicateFrom(type))\n                .reduce(t -> true, Predicate::and);\n    }\n    ", "    public void add(final SearchPredicate<T> literal) {\n        \n        this.predicates.add(literal);\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/context/SearchPredicate.java", "chunked_list": ["package com.blamejared.searchables.api.context;\n\nimport com.blamejared.searchables.api.SearchableType;\n\nimport java.util.function.Predicate;\n\ninterface SearchPredicate<T> {\n    \n    /**\n     * Create a predicate for the given {@link SearchableType<T>}", "    /**\n     * Create a predicate for the given {@link SearchableType<T>}\n     *\n     * @param type The type to search for\n     *\n     * @return A predicate that can be used to filter elements that the {@link SearchableType<T>} deals with.\n     */\n    Predicate<T> predicateFrom(final SearchableType<T> type);\n    \n}", "    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/formatter/FormattingVisitor.java", "chunked_list": ["package com.blamejared.searchables.api.formatter;\n\nimport com.blamejared.searchables.api.*;\nimport com.blamejared.searchables.lang.StringSearcher;\nimport com.blamejared.searchables.lang.expression.type.*;\nimport com.blamejared.searchables.lang.expression.visitor.ContextAwareVisitor;\nimport com.mojang.datafixers.util.Pair;\nimport net.minecraft.network.chat.Style;\nimport net.minecraft.util.FormattedCharSequence;\n", "import net.minecraft.util.FormattedCharSequence;\n\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * Applies style formatting for an {@link net.minecraft.client.gui.components.EditBox}, intended to be passed into {@link net.minecraft.client.gui.components.EditBox#setFormatter(BiFunction)}.\n */\npublic class FormattingVisitor implements ContextAwareVisitor<TokenRange, FormattingContext>, Consumer<String>, BiFunction<String, Integer, FormattedCharSequence> {\n    \n    private final SearchableType<?> type;\n    \n    private final List<Pair<TokenRange, Style>> tokens = new ArrayList<>();\n    private TokenRange lastRange = TokenRange.at(0);\n    \n    public FormattingVisitor(final SearchableType<?> type) {\n        \n        this.type = type;\n    }\n    \n    /**\n     * Resets this visitor to a state that allows it to run again.\n     */", "public class FormattingVisitor implements ContextAwareVisitor<TokenRange, FormattingContext>, Consumer<String>, BiFunction<String, Integer, FormattedCharSequence> {\n    \n    private final SearchableType<?> type;\n    \n    private final List<Pair<TokenRange, Style>> tokens = new ArrayList<>();\n    private TokenRange lastRange = TokenRange.at(0);\n    \n    public FormattingVisitor(final SearchableType<?> type) {\n        \n        this.type = type;\n    }\n    \n    /**\n     * Resets this visitor to a state that allows it to run again.\n     */", "    public void reset() {\n        \n        tokens.clear();\n        lastRange = TokenRange.at(0);\n    }\n    \n    public List<Pair<TokenRange, Style>> tokens() {\n        \n        return tokens;\n    }\n    \n    /**\n     * Gets the {@link Optional<Pair>} of {@link TokenRange} and {@link Style} at the given position.\n     *\n     * @param position The current cursor position.\n     *\n     * @return An {@link Optional<Pair>} of {@link TokenRange} and {@link Style} at the given position, or an empty optional if out of bounds.\n     */\n    public Optional<Pair<TokenRange, Style>> tokenAt(final int position) {\n        \n        return tokens.stream()\n                .filter(range -> range.getFirst().contains(position))\n                .findFirst();\n    }\n    \n    @Override", "    public TokenRange visitGrouping(final GroupingExpression expr, final FormattingContext context) {\n        \n        TokenRange leftRange = expr.left().accept(this, context);\n        tokens.add(Pair.of(getAndPushRange(), context.style()));\n        TokenRange rightRange = expr.right().accept(this, context);\n        return TokenRange.encompassing(leftRange, rightRange);\n    }\n    \n    @Override\n    public TokenRange visitComponent(final ComponentExpression expr, final FormattingContext context) {\n        \n        boolean valid = context.valid() && expr.left() instanceof LiteralExpression && expr.right() instanceof LiteralExpression;\n        TokenRange leftRange = expr.left().accept(this, FormattingContext.key(FormattingConstants.KEY, valid));\n        tokens.add(Pair.of(getAndPushRange(), context.style(valid)));\n        TokenRange rightRange = expr.right().accept(this, FormattingContext.literal(FormattingConstants.TERM, valid));\n        return TokenRange.encompassing(leftRange, rightRange);\n    }\n    \n    @Override", "    public TokenRange visitComponent(final ComponentExpression expr, final FormattingContext context) {\n        \n        boolean valid = context.valid() && expr.left() instanceof LiteralExpression && expr.right() instanceof LiteralExpression;\n        TokenRange leftRange = expr.left().accept(this, FormattingContext.key(FormattingConstants.KEY, valid));\n        tokens.add(Pair.of(getAndPushRange(), context.style(valid)));\n        TokenRange rightRange = expr.right().accept(this, FormattingContext.literal(FormattingConstants.TERM, valid));\n        return TokenRange.encompassing(leftRange, rightRange);\n    }\n    \n    @Override\n    public TokenRange visitLiteral(final LiteralExpression expr, final FormattingContext context) {\n        \n        Style style = context.style();", "    public TokenRange visitLiteral(final LiteralExpression expr, final FormattingContext context) {\n        \n        Style style = context.style();\n        if(!context.valid() || context.isKey() && !type.components().containsKey(expr.value())) {\n            style = FormattingConstants.INVALID;\n        }\n        TokenRange range = getAndPushRange(expr.displayValue().length());\n        tokens.add(Pair.of(range, style));\n        return range;\n    }\n    \n    @Override", "    public TokenRange visitPaired(final PairedExpression expr, final FormattingContext context) {\n        \n        TokenRange leftRange = expr.first().accept(this, context);\n        TokenRange rightRange = expr.second().accept(this, context);\n        return TokenRange.encompassing(leftRange, rightRange);\n    }\n    \n    private TokenRange getAndPushRange() {\n        \n        return getAndPushRange(1);\n    }\n    \n    private TokenRange getAndPushRange(final int end) {\n        \n        TokenRange oldRange = lastRange;\n        lastRange = TokenRange.between(lastRange.end(), lastRange.end() + end);\n        return TokenRange.between(oldRange.end(), oldRange.end() + end);\n    }\n    \n    @Override", "    public void accept(final String search) {\n        \n        reset();\n        StringSearcher.search(search, this, FormattingContext.empty());\n    }\n    \n    @Override\n    public FormattedCharSequence apply(final String currentString, final Integer offset) {\n        \n        List<FormattedCharSequence> sequences = new ArrayList<>();\n        int index = 0;", "        for(Pair<TokenRange, Style> token : tokens) {\n            TokenRange range = token.getFirst();\n            int subEnd = Math.max(range.start() - offset, 0);\n            if(subEnd >= currentString.length()) {\n                break;\n            }\n            \n            int subStart = Math.min(range.end() - offset, currentString.length());\n            if(subStart > 0) {\n                sequences.add(FormattedCharSequence.forward(currentString.substring(index, subEnd), token.getSecond()));\n                sequences.add(FormattedCharSequence.forward(currentString.substring(subEnd, subStart), token.getSecond()));\n                index = subStart;\n            }\n        }\n        sequences.add(FormattedCharSequence.forward(currentString.substring(index), Style.EMPTY));\n        \n        return FormattedCharSequence.composite(sequences);\n    }\n    \n    \n}\n", "            if(subStart > 0) {\n                sequences.add(FormattedCharSequence.forward(currentString.substring(index, subEnd), token.getSecond()));\n                sequences.add(FormattedCharSequence.forward(currentString.substring(subEnd, subStart), token.getSecond()));\n                index = subStart;\n            }\n        }\n        sequences.add(FormattedCharSequence.forward(currentString.substring(index), Style.EMPTY));\n        \n        return FormattedCharSequence.composite(sequences);\n    }\n    \n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/formatter/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.api.formatter;\n\nimport net.minecraft.*;\n\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/formatter/FormattingContext.java", "chunked_list": ["package com.blamejared.searchables.api.formatter;\n\nimport net.minecraft.network.chat.Style;\n\n/**\n * Extra context used by the {@link FormattingVisitor}.\n *\n * @param isKey Is the current expression a key\n * @param style The style to apply to the current expression\n * @param valid If the current expression is valid.", " * @param style The style to apply to the current expression\n * @param valid If the current expression is valid.\n */\npublic record FormattingContext(boolean isKey, Style style, boolean valid) {\n    \n    public static FormattingContext empty() {\n        \n        return new FormattingContext(false, Style.EMPTY, true);\n    }\n    \n    public static FormattingContext key(Style validStyle, boolean valid) {\n        \n        return new FormattingContext(true, valid ? validStyle : FormattingConstants.INVALID, valid);\n    }\n    ", "    public static FormattingContext key(Style validStyle, boolean valid) {\n        \n        return new FormattingContext(true, valid ? validStyle : FormattingConstants.INVALID, valid);\n    }\n    \n    public static FormattingContext literal(Style validStyle, boolean valid) {\n        \n        return new FormattingContext(false, valid ? validStyle : FormattingConstants.INVALID, valid);\n    }\n    \n    public Style style(boolean valid) {\n        \n        return valid ? style() : FormattingConstants.INVALID;\n    }\n    \n}", "    public Style style(boolean valid) {\n        \n        return valid ? style() : FormattingConstants.INVALID;\n    }\n    \n}"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/formatter/FormattingConstants.java", "chunked_list": ["package com.blamejared.searchables.api.formatter;\n\nimport net.minecraft.network.chat.Style;\n\nclass FormattingConstants {\n    \n    static final Style INVALID = Style.EMPTY.withColor(0xFF0000).withUnderlined(true);\n    static final Style KEY = Style.EMPTY.withColor(0x669BBC);\n    static final Style TERM = Style.EMPTY.withColor(0xEECC77);\n    ", "    static final Style TERM = Style.EMPTY.withColor(0xEECC77);\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/autcomplete/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.api.autcomplete;\n\nimport net.minecraft.*;\n\nimport javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/autcomplete/AutoCompletingEditBox.java", "chunked_list": ["package com.blamejared.searchables.api.autcomplete;\n\nimport com.blamejared.searchables.api.*;\nimport com.blamejared.searchables.api.formatter.FormattingVisitor;\nimport com.blamejared.searchables.mixin.AccessEditBox;\nimport net.minecraft.client.gui.Font;\nimport net.minecraft.client.gui.components.EditBox;\nimport net.minecraft.network.chat.Component;\nimport org.jetbrains.annotations.Nullable;\nimport org.lwjgl.glfw.GLFW;", "import org.jetbrains.annotations.Nullable;\nimport org.lwjgl.glfw.GLFW;\n\nimport java.util.*;\nimport java.util.function.*;\n\npublic class AutoCompletingEditBox<T> extends EditBox {\n    \n    private final FormattingVisitor formattingVisitor;\n    private final CompletionVisitor completionVisitor;\n    private final DelegatingConsumers<String> responders = new DelegatingConsumers<>();\n    private final AutoComplete<T> autoComplete;\n    \n    public AutoCompletingEditBox(Font font, int x, int y, int width, int height, Component message, SearchableType<T> type, Supplier<List<T>> entries) {\n        \n        this(font, x, y, width, height, null, message, type, entries);\n    }\n    \n    public AutoCompletingEditBox(Font font, int x, int y, int width, int height, @Nullable EditBox thisBox, Component message, SearchableType<T> type, Supplier<List<T>> entries) {\n        \n        super(font, x, y, width, height, thisBox, message);\n        this.setMaxLength(Integer.MAX_VALUE);\n        this.formattingVisitor = new FormattingVisitor(type);\n        this.completionVisitor = new CompletionVisitor();\n        this.autoComplete = new AutoComplete<>(type, this, entries, x, y + 2 + height, width, font.lineHeight + 2);\n        setHint(SearchablesConstants.COMPONENT_SEARCH);\n        this.setFormatter(this.formattingVisitor);\n        this.setResponder(this.responders);\n        addResponder(this.formattingVisitor);\n        addResponder(this.completionVisitor);\n        addResponder(this.autoComplete);\n    }\n    \n    @Override", "    public boolean mouseClicked(double xpos, double ypos, int button) {\n        \n        if(this.isFocused() && autoComplete.mouseClicked(xpos, ypos, button)) {\n            return true;\n        }\n        if((isMouseOver(xpos, ypos) || autoComplete().isMouseOver(xpos, ypos)) && button == GLFW.GLFW_MOUSE_BUTTON_2) {\n            this.setValue(\"\");\n            return true;\n        }\n        return super.mouseClicked(xpos, ypos, button);\n    }\n    \n    @Override", "    public boolean keyPressed(int key, int scancode, int mods) {\n        \n        switch(key) {\n            case (GLFW.GLFW_KEY_PAGE_DOWN) -> {\n                this.autoComplete.scrollDown(this.autoComplete().maxSuggestions());\n                return true;\n            }\n            case (GLFW.GLFW_KEY_DOWN) -> {\n                this.autoComplete().scrollDown();\n                return true;\n            }\n            case (GLFW.GLFW_KEY_PAGE_UP) -> {\n                this.autoComplete.scrollUp(this.autoComplete().maxSuggestions());\n                return true;\n            }\n            case (GLFW.GLFW_KEY_UP) -> {\n                this.autoComplete().scrollUp();\n                return true;\n            }\n            case (GLFW.GLFW_KEY_ENTER) -> {\n                this.autoComplete().insertSuggestion();\n                return true;\n            }\n        }\n        return super.keyPressed(key, scancode, mods);\n    }\n    \n    /**\n     * Deletes the characters as the given {@link TokenRange}.\n     *\n     * @param range The range to delete characters from\n     */", "    public void deleteChars(TokenRange range) {\n        \n        if(!this.getValue().isEmpty()) {\n            if(!range.isEmpty()) {\n                String newValue = range.delete(this.getValue());\n                if(this.getFilter().test(newValue)) {\n                    this.setValue(newValue);\n                    this.moveCursorTo(range.start());\n                }\n            }\n        }\n    }\n    \n    public Predicate<String> getFilter() {\n        \n        return ((AccessEditBox) this).searchables$getFilter();\n    }\n    \n    @Nullable\n    public Consumer<String> getResponder() {\n        \n        return ((AccessEditBox) this).searchables$getResponder();\n    }\n    \n    /**\n     * Should not be used, use {@link AutoCompletingEditBox#addResponder(Consumer)} instead\n     */\n    @SuppressWarnings(\"DeprecatedIsStillUsed\")\n    @Override\n    @Deprecated", "    public void setResponder(Consumer<String> responder) {\n        \n        if(this.getResponder() == null) {\n            super.setResponder(responders);\n        } else {\n            this.addResponder(responder);\n        }\n    }\n    \n    public void addResponder(Consumer<String> responder) {\n        \n        this.responders.addConsumer(responder);\n    }\n    ", "    public void addResponder(Consumer<String> responder) {\n        \n        this.responders.addConsumer(responder);\n    }\n    \n    public FormattingVisitor formattingVisitor() {\n        \n        return formattingVisitor;\n    }\n    \n    public CompletionVisitor completionVisitor() {\n        \n        return completionVisitor;\n    }\n    \n    public AutoComplete<T> autoComplete() {\n        \n        return autoComplete;\n    }\n    \n    private static class DelegatingConsumers<T> implements Consumer<T> {\n        \n        private final List<Consumer<T>> consumers = new ArrayList<>();\n        \n        @Override", "    public CompletionVisitor completionVisitor() {\n        \n        return completionVisitor;\n    }\n    \n    public AutoComplete<T> autoComplete() {\n        \n        return autoComplete;\n    }\n    \n    private static class DelegatingConsumers<T> implements Consumer<T> {\n        \n        private final List<Consumer<T>> consumers = new ArrayList<>();\n        \n        @Override", "        public void accept(T t) {\n            \n            consumers.forEach(tConsumer -> tConsumer.accept(t));\n        }\n        \n        public void addConsumer(Consumer<T> consumer) {\n            \n            this.consumers.add(consumer);\n        }\n        \n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/autcomplete/AutoComplete.java", "chunked_list": ["package com.blamejared.searchables.api.autcomplete;\n\nimport com.blamejared.searchables.api.SearchableType;\nimport com.blamejared.searchables.api.TokenRange;\nimport com.mojang.blaze3d.vertex.PoseStack;\nimport net.minecraft.ChatFormatting;\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.gui.GuiGraphics;\nimport net.minecraft.client.gui.components.AbstractWidget;\nimport net.minecraft.client.gui.narration.NarrationElementOutput;", "import net.minecraft.client.gui.components.AbstractWidget;\nimport net.minecraft.client.gui.narration.NarrationElementOutput;\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.util.Mth;\nimport org.joml.Vector2d;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;", "import java.util.function.Consumer;\nimport java.util.function.Supplier;\n\n/**\n * A small widget that displays current suggestions for an {@link AutoCompletingEditBox<T>}.\n *\n * @param <T> The type of element that is being searched for.\n */\npublic class AutoComplete<T> extends AbstractWidget implements Consumer<String> {\n    \n    private final SearchableType<T> type;\n    private final AutoCompletingEditBox<T> editBox;\n    private final Supplier<List<T>> entries;\n    private final int suggestionHeight;\n    private final int maxSuggestions;\n    private List<CompletionSuggestion> suggestions;\n    // The index of the element at the top of the displayed list\n    private int displayOffset;\n    // The actual selectedIndex, -1 means none selected, range is 0 -> maxSuggestions\n    private int selectedIndex;\n    private final Vector2d lastMousePosition;\n    private int lastCursorPosition;\n    \n    /**\n     * Create a new AutoComplete with the given values and a {@code maxSuggestion} size of 7\n     *\n     * @param type             The {@link SearchableType<T>} that this {@link AutoComplete<T>} completes for.\n     * @param editBox          The attached {@link AutoCompletingEditBox<T>} that this {@link AutoComplete<T>} is attached to.\n     * @param entries          The entries that should be used for completion.\n     * @param x                The x position of this widget on the screen.\n     * @param y                The y position of this widget on the screen.\n     * @param width            The width of this widget on the screen.\n     * @param suggestionHeight The height of each individual suggestion. Recommended to be {@code Font#lineHeight + 2}\n     */\n    public AutoComplete(SearchableType<T> type, AutoCompletingEditBox<T> editBox, Supplier<List<T>> entries, int x, int y, int width, int suggestionHeight) {\n        \n        this(type, editBox, entries, x, y, width, suggestionHeight, 7);\n    }\n    \n    /**\n     * Create a new AutoComplete with the given values.\n     *\n     * @param type             The {@link SearchableType<T>} that this {@link AutoComplete<T>} completes for.\n     * @param editBox          The attached {@link AutoCompletingEditBox<T>} that this {@link AutoComplete<T>} is attached to.\n     * @param entries          The entries that should be used for completion.\n     * @param x                The x position of this widget on the screen.\n     * @param y                The y position of this widget on the screen.\n     * @param width            The width of this widget on the screen.\n     * @param suggestionHeight The height of each individual suggestion.\n     * @param maxSuggestions   How many suggestions to show.\n     */\n    public AutoComplete(SearchableType<T> type, AutoCompletingEditBox<T> editBox, Supplier<List<T>> entries, int x, int y, int width, int suggestionHeight, int maxSuggestions) {\n        \n        super(x, y, width, suggestionHeight * maxSuggestions, Component.empty());\n        this.type = type;\n        this.editBox = editBox;\n        this.entries = entries;\n        this.suggestionHeight = suggestionHeight;\n        this.maxSuggestions = maxSuggestions;\n        this.suggestions = List.of();\n        this.displayOffset = 0;\n        this.selectedIndex = -1;\n        this.lastMousePosition = new Vector2d(0, 0);\n        this.lastCursorPosition = -1;\n    }\n    \n    /**\n     * Compiles suggestions for the given value.\n     *\n     * @param value the input argument\n     */\n    @Override", "public class AutoComplete<T> extends AbstractWidget implements Consumer<String> {\n    \n    private final SearchableType<T> type;\n    private final AutoCompletingEditBox<T> editBox;\n    private final Supplier<List<T>> entries;\n    private final int suggestionHeight;\n    private final int maxSuggestions;\n    private List<CompletionSuggestion> suggestions;\n    // The index of the element at the top of the displayed list\n    private int displayOffset;\n    // The actual selectedIndex, -1 means none selected, range is 0 -> maxSuggestions\n    private int selectedIndex;\n    private final Vector2d lastMousePosition;\n    private int lastCursorPosition;\n    \n    /**\n     * Create a new AutoComplete with the given values and a {@code maxSuggestion} size of 7\n     *\n     * @param type             The {@link SearchableType<T>} that this {@link AutoComplete<T>} completes for.\n     * @param editBox          The attached {@link AutoCompletingEditBox<T>} that this {@link AutoComplete<T>} is attached to.\n     * @param entries          The entries that should be used for completion.\n     * @param x                The x position of this widget on the screen.\n     * @param y                The y position of this widget on the screen.\n     * @param width            The width of this widget on the screen.\n     * @param suggestionHeight The height of each individual suggestion. Recommended to be {@code Font#lineHeight + 2}\n     */\n    public AutoComplete(SearchableType<T> type, AutoCompletingEditBox<T> editBox, Supplier<List<T>> entries, int x, int y, int width, int suggestionHeight) {\n        \n        this(type, editBox, entries, x, y, width, suggestionHeight, 7);\n    }\n    \n    /**\n     * Create a new AutoComplete with the given values.\n     *\n     * @param type             The {@link SearchableType<T>} that this {@link AutoComplete<T>} completes for.\n     * @param editBox          The attached {@link AutoCompletingEditBox<T>} that this {@link AutoComplete<T>} is attached to.\n     * @param entries          The entries that should be used for completion.\n     * @param x                The x position of this widget on the screen.\n     * @param y                The y position of this widget on the screen.\n     * @param width            The width of this widget on the screen.\n     * @param suggestionHeight The height of each individual suggestion.\n     * @param maxSuggestions   How many suggestions to show.\n     */\n    public AutoComplete(SearchableType<T> type, AutoCompletingEditBox<T> editBox, Supplier<List<T>> entries, int x, int y, int width, int suggestionHeight, int maxSuggestions) {\n        \n        super(x, y, width, suggestionHeight * maxSuggestions, Component.empty());\n        this.type = type;\n        this.editBox = editBox;\n        this.entries = entries;\n        this.suggestionHeight = suggestionHeight;\n        this.maxSuggestions = maxSuggestions;\n        this.suggestions = List.of();\n        this.displayOffset = 0;\n        this.selectedIndex = -1;\n        this.lastMousePosition = new Vector2d(0, 0);\n        this.lastCursorPosition = -1;\n    }\n    \n    /**\n     * Compiles suggestions for the given value.\n     *\n     * @param value the input argument\n     */\n    @Override", "    public void accept(String value) {\n        \n        int position = this.editBox().getCursorPosition();\n        if(lastCursorPosition != position) {\n            displayOffset = 0;\n            selectedIndex = 0;\n            TokenRange replacementRange = this.editBox().completionVisitor().rangeAt(position);\n            suggestions = type.getSuggestionsFor(entries.get(), value, position, replacementRange);\n        }\n        lastCursorPosition = position;\n    }\n    \n    // For some reason mojang has these as 2 methods...\n    @Override\n    protected boolean clicked(double xpos, double ypos) {\n        \n        return super.clicked(xpos, ypos) && ypos < this.getY() + (suggestionHeight * shownSuggestions());\n    }\n    \n    @Override", "    public boolean isMouseOver(double xpos, double ypos) {\n        \n        return super.isMouseOver(xpos, ypos) && ypos < this.getY() + (suggestionHeight * shownSuggestions());\n    }\n    \n    @Override\n    public boolean mouseScrolled(double xpos, double ypos, double delta) {\n        \n        if(isMouseOver(xpos, ypos) || this.editBox().isMouseOver(xpos, ypos)) {\n            displayOffset = (int) Mth.clamp(displayOffset - delta, 0, Math.max(this.suggestions.size() - maxSuggestions, 0));\n            lastMousePosition.set(0);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    @Override", "        if(isMouseOver(xpos, ypos) || this.editBox().isMouseOver(xpos, ypos)) {\n            displayOffset = (int) Mth.clamp(displayOffset - delta, 0, Math.max(this.suggestions.size() - maxSuggestions, 0));\n            lastMousePosition.set(0);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public boolean mouseClicked(double mx, double my, int mb) {\n        ", "    public boolean mouseClicked(double mx, double my, int mb) {\n        \n        if(super.mouseClicked(mx, my, mb)) {\n            updateHoveringState(mx, my);\n            if(selectedIndex != -1) {\n                insertSuggestion();\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Inserts the currently selected suggestion into attached {@link AutoCompletingEditBox<T>}.\n     */", "    public void insertSuggestion() {\n        \n        int index = displayOffset + selectedIndex;\n        if(index >= 0 && index < this.suggestions.size()) {\n            CompletionSuggestion suggestion = this.suggestions.get(index);\n            this.editBox.deleteChars(suggestion.replacementRange());\n            this.editBox.insertText(suggestion.toInsert());\n        }\n    }\n    \n    @Override", "    public void renderWidget(GuiGraphics guiGraphics, int mx, int my, float partial) {\n        \n        if(!editBox.isFocused()) {\n            return;\n        }\n        updateHoveringState(mx, my);\n        PoseStack pose = guiGraphics.pose();\n        pose.translate(0, 0, 500);\n        for(int i = displayOffset; i < Math.min(displayOffset + maxSuggestions, suggestions.size()); i++) {\n            CompletionSuggestion suggestion = suggestions.get(i);\n            int minX = this.getX() + 2;\n            int minY = this.getY() + (suggestionHeight * (i - displayOffset));\n            int maxY = minY + suggestionHeight;\n            boolean hovered = selectedIndex != -1 && displayOffset + selectedIndex == i;\n            \n            guiGraphics.fill(this.getX(), minY, this.getX() + this.getWidth(), maxY, hovered ? 0xe0111111 : 0xe0000000);\n            guiGraphics.drawString(Minecraft.getInstance().font, suggestion.display(), minX, minY + 1, hovered ? Objects.requireNonNull(ChatFormatting.YELLOW.getColor()) : 0xFFFFFFFF);\n        }\n        pose.translate(0, 0, -500);\n        \n        this.lastMousePosition.set(mx, my);\n    }\n    \n    private void updateHoveringState(double xpos, double ypos) {\n        ", "        for(int i = displayOffset; i < Math.min(displayOffset + maxSuggestions, suggestions.size()); i++) {\n            CompletionSuggestion suggestion = suggestions.get(i);\n            int minX = this.getX() + 2;\n            int minY = this.getY() + (suggestionHeight * (i - displayOffset));\n            int maxY = minY + suggestionHeight;\n            boolean hovered = selectedIndex != -1 && displayOffset + selectedIndex == i;\n            \n            guiGraphics.fill(this.getX(), minY, this.getX() + this.getWidth(), maxY, hovered ? 0xe0111111 : 0xe0000000);\n            guiGraphics.drawString(Minecraft.getInstance().font, suggestion.display(), minX, minY + 1, hovered ? Objects.requireNonNull(ChatFormatting.YELLOW.getColor()) : 0xFFFFFFFF);\n        }\n        pose.translate(0, 0, -500);\n        \n        this.lastMousePosition.set(mx, my);\n    }\n    \n    private void updateHoveringState(double xpos, double ypos) {\n        ", "        if(!lastMousePosition.equals(xpos, ypos)) {\n            selectedIndex = -1;\n            if(isMouseOver(xpos, ypos)) {\n                int minY = this.getY();\n                for(int i = 0; i < shownSuggestions(); i++) {\n                    int maxY = minY + suggestionHeight;\n                    if(xpos >= getX() && xpos <= this.getX() + this.getWidth() && ypos >= minY && ypos < maxY) {\n                        selectedIndex = i;\n                    }\n                    minY = maxY;\n                }\n            }\n        }\n    }\n    \n    /**\n     * Scrolls the current suggestions up by 1.\n     */", "    public void scrollUp() {\n        \n        this.scrollUp(1);\n    }\n    \n    /**\n     * Scrolls the current suggestions up by the given amount.\n     *\n     * @param amount The amount to scroll by.\n     */\n    public void scrollUp(int amount) {\n        \n        this.offsetDisplay(this.selectedIndex - amount);\n    }\n    \n    /**\n     * Scrolls the current suggestions down by 1.\n     */", "    public void scrollUp(int amount) {\n        \n        this.offsetDisplay(this.selectedIndex - amount);\n    }\n    \n    /**\n     * Scrolls the current suggestions down by 1.\n     */\n    public void scrollDown() {\n        \n        this.scrollDown(1);\n    }\n    \n    /**\n     * Scrolls the current suggestions down by the given amount.\n     *\n     * @param amount The amount to scroll by.\n     */", "    public void scrollDown() {\n        \n        this.scrollDown(1);\n    }\n    \n    /**\n     * Scrolls the current suggestions down by the given amount.\n     *\n     * @param amount The amount to scroll by.\n     */\n    public void scrollDown(int amount) {\n        \n        this.offsetDisplay(this.selectedIndex + amount);\n    }\n    \n    private void offsetDisplay(int offset) {\n        \n        offset = Mth.clamp(offset, 0, shownSuggestions() - 1);\n        final int halfSuggestions = Math.floorDiv(maxSuggestions, 2);\n        int currentItem = this.displayOffset + offset;", "    public void scrollDown(int amount) {\n        \n        this.offsetDisplay(this.selectedIndex + amount);\n    }\n    \n    private void offsetDisplay(int offset) {\n        \n        offset = Mth.clamp(offset, 0, shownSuggestions() - 1);\n        final int halfSuggestions = Math.floorDiv(maxSuggestions, 2);\n        int currentItem = this.displayOffset + offset;\n        if(currentItem < this.displayOffset + halfSuggestions) {\n            this.displayOffset = Math.max(currentItem - halfSuggestions, 0);", "        if(currentItem < this.displayOffset + halfSuggestions) {\n            this.displayOffset = Math.max(currentItem - halfSuggestions, 0);\n        } else if(currentItem > this.displayOffset + halfSuggestions) {\n            this.displayOffset = Math.min(currentItem - halfSuggestions, Math.max(this.suggestions.size() - maxSuggestions, 0));\n        }\n        this.selectedIndex = currentItem - this.displayOffset;\n    }\n    \n    private int shownSuggestions() {\n        \n        return Math.min(maxSuggestions, suggestions.size());\n    }\n    ", "    public int maxSuggestions() {\n        \n        return maxSuggestions;\n    }\n    \n    public AutoCompletingEditBox<T> editBox() {\n        \n        return editBox;\n    }\n    \n    @Override\n    protected void updateWidgetNarration(NarrationElementOutput output) {\n        //TODO I am not sure what this should actually do.\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/autcomplete/CompletionSuggestion.java", "chunked_list": ["package com.blamejared.searchables.api.autcomplete;\n\nimport com.blamejared.searchables.api.TokenRange;\nimport net.minecraft.network.chat.Component;\n\n/**\n * Represents a suggestion to be shown in {@link AutoComplete}\n *\n * @param suggestion       The suggestion to insert.\n * @param display          The component to display to the user.", " * @param suggestion       The suggestion to insert.\n * @param display          The component to display to the user.\n * @param suffix           The text to insert of the {@code suggestion}. Generally either {@literal \":\"} or {@literal \" \"}\n * @param replacementRange The range of the current String to replace with this suggestion. Given the string {@code \"sha\"} and suggestion of {@code \"shape\"}, the range will be {@code TokenRange(0, 5)}\n */\npublic record CompletionSuggestion(String suggestion, Component display, String suffix, TokenRange replacementRange) {\n    \n    /**\n     * Inserts the suggestion into the given string.\n     *\n     * @param into The string to insert into.\n     *\n     * @return The given string with this suggestion inserted into it.\n     */", "    public String replaceIn(final String into) {\n        \n        return replacementRange.replace(into, toInsert());\n    }\n    \n    /**\n     * Gets the string to insert, combining the suggestion and the suffix.\n     *\n     * @return The string to insert.\n     */\n    public String toInsert() {\n        \n        return suggestion + suffix;\n    }\n    \n    \n}\n", "    public String toInsert() {\n        \n        return suggestion + suffix;\n    }\n    \n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/api/autcomplete/CompletionVisitor.java", "chunked_list": ["package com.blamejared.searchables.api.autcomplete;\n\nimport com.blamejared.searchables.api.TokenRange;\nimport com.blamejared.searchables.lang.StringSearcher;\nimport com.blamejared.searchables.lang.expression.type.*;\nimport com.blamejared.searchables.lang.expression.visitor.Visitor;\n\nimport java.util.*;\nimport java.util.function.Consumer;\n", "import java.util.function.Consumer;\n\n/**\n * Generates a list of TokenRanges that can be used to split a given string into parts.\n * Mainly used to split strings for completion purposes.\n */\npublic class CompletionVisitor implements Visitor<TokenRange>, Consumer<String> {\n    \n    private final List<TokenRange> tokens = new ArrayList<>();\n    private TokenRange lastRange = TokenRange.EMPTY;\n    \n    /**\n     * Resets this visitor to a state that allows it to run again.\n     */", "    public void reset() {\n        \n        tokens.clear();\n        lastRange = TokenRange.EMPTY;\n    }\n    \n    /**\n     * Reduces the tokens into their outermost parts.\n     * For example the string {@code \"shape:square color:red\"} will be split into:\n     * {@code [\n     * TokenRange(0, 12, [TokenRange(0, 5), TokenRange(5, 6), TokenRange(6, 12)]),\n     * TokenRange(13, 22, [TokenRange(13, 18), TokenRange(18, 19), TokenRange(19, 22)])\n     * ]}\n     */\n    protected void reduceTokens() {\n        // Can this be done while visiting?\n        ListIterator<TokenRange> iterator = tokens.listIterator(tokens.size());\n        TokenRange lastRange = null;", "        while(iterator.hasPrevious()) {\n            TokenRange previous = iterator.previous();\n            if(lastRange == null) {\n                lastRange = previous;\n            } else {\n                if(lastRange.covers(previous)) {\n                    lastRange.addRange(previous);\n                    iterator.remove();\n                } else {\n                    lastRange = previous;\n                }\n            }\n        }\n    }\n    \n    /**\n     * Gets the tokens in this visitor.\n     *\n     * @return The tokens in this visitor.\n     */\n    public List<TokenRange> tokens() {\n        \n        return tokens;\n    }\n    \n    /**\n     * Gets the {@link Optional<TokenRange>} at the given position.\n     *\n     * @param position The current cursor position.\n     *\n     * @return An {@link Optional<TokenRange>} at the given position, or an empty optional if out of bounds.\n     */\n    public Optional<TokenRange> tokenAt(final int position) {\n        \n        return tokens.stream()\n                .filter(range -> range.contains(position))\n                .findFirst();\n    }\n    \n    /**\n     * Gets the {@link TokenRange} at the given position, or {@link TokenRange#EMPTY} if out of bounds.\n     *\n     * @param position The current cursor position.\n     *\n     * @return An {@link TokenRange} at the given range, or {@link TokenRange#EMPTY} if out of bounds.\n     */", "    public TokenRange rangeAt(final int position) {\n        \n        return tokenAt(position).orElse(TokenRange.EMPTY);\n    }\n    \n    @Override\n    public TokenRange visitGrouping(final GroupingExpression expr) {\n        \n        TokenRange leftRange = expr.left().accept(this);\n        getAndPushRange();\n        TokenRange rightRange = expr.right().accept(this);\n        return TokenRange.encompassing(leftRange, rightRange);\n    }\n    \n    @Override", "    public TokenRange visitComponent(final ComponentExpression expr) {\n        \n        TokenRange leftRange = expr.left().accept(this);\n        addToken(getAndPushRange());\n        TokenRange rightRange = expr.right().accept(this);\n        return addToken(TokenRange.encompassing(leftRange, rightRange));\n    }\n    \n    @Override\n    public TokenRange visitLiteral(final LiteralExpression expr) {\n        \n        return addToken(getAndPushRange(expr.displayValue().length()));\n    }\n    \n    @Override", "    public TokenRange visitLiteral(final LiteralExpression expr) {\n        \n        return addToken(getAndPushRange(expr.displayValue().length()));\n    }\n    \n    @Override\n    public TokenRange visitPaired(final PairedExpression expr) {\n        \n        TokenRange leftRange = addToken(expr.first().accept(this));\n        TokenRange rightRange = addToken(expr.second().accept(this));\n        return addToken(TokenRange.encompassing(leftRange, rightRange));\n    }\n    \n    private TokenRange addToken(final TokenRange range) {\n        \n        this.tokens.add(range.recalculate());\n        return range;\n    }\n    \n    private TokenRange getAndPushRange() {\n        \n        return getAndPushRange(1);\n    }\n    \n    private TokenRange getAndPushRange(final int end) {\n        \n        TokenRange oldRange = lastRange;\n        lastRange = TokenRange.between(lastRange.end(), lastRange.end() + end);\n        return TokenRange.between(oldRange.end(), oldRange.end() + end);\n    }\n    \n    /**\n     * Resets this visitor and compiles a list of {@link TokenRange} from the given String\n     *\n     * @param search The string to search\n     */\n    @Override", "    public void accept(final String search) {\n        \n        reset();\n        StringSearcher.search(search, this);\n    }\n    \n    @Override\n    public TokenRange postVisit(final TokenRange obj) {\n        \n        this.reduceTokens();\n        return Visitor.super.postVisit(obj);\n    }\n    \n}\n"]}
{"filename": "common/src/main/java/com/blamejared/searchables/mixin/package-info.java", "chunked_list": ["@ParametersAreNonnullByDefault\n@MethodsReturnNonnullByDefault\n@FieldsAreNonnullByDefault\npackage com.blamejared.searchables.mixin;\n\nimport net.minecraft.FieldsAreNonnullByDefault;\nimport net.minecraft.MethodsReturnNonnullByDefault;\n\nimport javax.annotation.ParametersAreNonnullByDefault;", "import javax.annotation.ParametersAreNonnullByDefault;"]}
{"filename": "common/src/main/java/com/blamejared/searchables/mixin/AccessEditBox.java", "chunked_list": ["package com.blamejared.searchables.mixin;\n\nimport net.minecraft.client.gui.components.EditBox;\nimport org.jetbrains.annotations.Nullable;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.gen.Accessor;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n", "import java.util.function.Predicate;\n\n@Mixin(EditBox.class)\npublic interface AccessEditBox {\n    \n    @Accessor(\"filter\")\n    Predicate<String> searchables$getFilter();\n    \n    @Nullable\n    @Accessor(\"responder\")\n    Consumer<String> searchables$getResponder();\n    \n}\n"]}
{"filename": "fabric/src/main/java/com/blamejared/searchables/SearchablesFabric.java", "chunked_list": ["package com.blamejared.searchables;\n\npublic class SearchablesFabric {\n\n}\n"]}
