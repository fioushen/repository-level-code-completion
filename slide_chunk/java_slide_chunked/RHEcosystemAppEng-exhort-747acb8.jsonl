{"filename": ".mvn/wrapper/MavenWrapperDownloader.java", "chunked_list": ["/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;", "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = \"0.5.5\";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = \"https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/\"\n        + WRAPPER_VERSION + \"/maven-wrapper-\" + WRAPPER_VERSION + \".jar\";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            \".mvn/wrapper/maven-wrapper.properties\";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            \".mvn/wrapper/maven-wrapper.jar\";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = \"wrapperUrl\";\n", "    public static void main(String args[]) {\n        System.out.println(\"- Downloader started\");\n        File baseDirectory = new File(args[0]);\n        System.out.println(\"- Using base directory: \" + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if(mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;", "        if(mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n            } finally {\n                try {", "                try {\n                    if(mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println(\"- Downloading from: \" + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);", "        if(!outputFile.getParentFile().exists()) {\n            if(!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        \"- ERROR creating output directory '\" + outputFile.getParentFile().getAbsolutePath() + \"'\");\n            }\n        }\n        System.out.println(\"- Downloading to: \" + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println(\"Done\");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println(\"- Error downloading\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {", "        if (System.getenv(\"MVNW_USERNAME\") != null && System.getenv(\"MVNW_PASSWORD\") != null) {\n            String username = System.getenv(\"MVNW_USERNAME\");\n            char[] password = System.getenv(\"MVNW_PASSWORD\").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/AnalysisIT.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport io.quarkus.test.junit.QuarkusIntegrationTest;\n\n@QuarkusIntegrationTest\npublic class AnalysisIT extends AnalysisTest {\n\n  // Run the same tests\n\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/VulnerabilityProviderTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n", "import org.junit.jupiter.api.Test;\n\nimport com.redhat.exhort.integration.providers.VulnerabilityProvider;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.quarkus.test.junit.QuarkusTestProfile;\nimport io.quarkus.test.junit.TestProfile;\n\nimport jakarta.inject.Inject;\n", "import jakarta.inject.Inject;\n\n@QuarkusTest\n@TestProfile(VulnerabilityProviderTest.PartialConfigProfile.class)\npublic class VulnerabilityProviderTest {\n\n  @Inject VulnerabilityProvider provider;\n\n  @Test\n  public void test() {\n    String[] expected = new String[] {Constants.OSS_INDEX_PROVIDER};\n    assertArrayEquals(expected, provider.getEnabled().toArray(new String[] {}));\n  }\n", "  public void test() {\n    String[] expected = new String[] {Constants.OSS_INDEX_PROVIDER};\n    assertArrayEquals(expected, provider.getEnabled().toArray(new String[] {}));\n  }\n\n  public static class PartialConfigProfile implements QuarkusTestProfile {\n\n    @Override\n    public Map<String, String> getConfigOverrides() {\n      return Map.of(\n          \"api.snyk.disabled\", \"true\",\n          \"api.ossindex.disabled\", \"false\");\n    }\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/AbstractAnalysisTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport static com.github.tomakehurst.wiremock.client.WireMock.*;\nimport static com.redhat.exhort.extensions.WiremockV3Extension.SNYK_TOKEN;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.File;\nimport java.io.IOException;", "import java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.Collection;\nimport java.util.Map;\n\nimport org.apache.camel.Exchange;\nimport org.cyclonedx.CycloneDxMediaType;\nimport org.junit.jupiter.api.AfterEach;\n", "import org.junit.jupiter.api.AfterEach;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.gargoylesoftware.htmlunit.BrowserVersion;\nimport com.gargoylesoftware.htmlunit.WebClient;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.github.jknack.handlebars.internal.Files;\nimport com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.client.BasicCredentials;", "import com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.client.BasicCredentials;\nimport com.google.common.base.Charsets;\nimport com.redhat.exhort.config.ObjectMapperProducer;\nimport com.redhat.exhort.extensions.InjectWireMock;\nimport com.redhat.exhort.extensions.WiremockV3Extension;\n\nimport io.quarkus.test.common.QuarkusTestResource;\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.RestAssured;", "import io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.RestAssured;\nimport io.restassured.config.DecoderConfig;\nimport io.restassured.config.EncoderConfig;\n\nimport jakarta.ws.rs.core.MediaType;\n\n@QuarkusTest\n@QuarkusTestResource(WiremockV3Extension.class)\npublic abstract class AbstractAnalysisTest {\n\n  static final String OK_USER = \"test-user\";\n  static final String OK_TOKEN = \"test-token\";\n  static final String ERROR_TOKEN = \"fail\";\n  static final String INVALID_TOKEN = \"invalid-token\";\n  static final String UNAUTH_TOKEN = \"test-not-authorized\";\n  static final String RATE_LIMIT_TOKEN = \"too-many-requests-token\";\n\n  static final String WIREMOCK_URL_TEMPLATE = \"__WIREMOCK_URL__\";\n\n  @InjectWireMock WireMockServer server;\n\n  static {\n    RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();\n    RestAssured.config()\n        .encoderConfig(EncoderConfig.encoderConfig().defaultContentCharset(\"UTF-8\"));\n    RestAssured.config()\n        .decoderConfig(DecoderConfig.decoderConfig().defaultContentCharset(\"UTF-8\"));\n  }\n\n  @AfterEach\n  void resetMock() {\n    server.resetAll();\n  }\n\n  protected void assertJson(String expectedFile, String currentBody) {\n    ObjectMapper mapper = ObjectMapperProducer.newInstance();\n    JsonNode current;", "@QuarkusTestResource(WiremockV3Extension.class)\npublic abstract class AbstractAnalysisTest {\n\n  static final String OK_USER = \"test-user\";\n  static final String OK_TOKEN = \"test-token\";\n  static final String ERROR_TOKEN = \"fail\";\n  static final String INVALID_TOKEN = \"invalid-token\";\n  static final String UNAUTH_TOKEN = \"test-not-authorized\";\n  static final String RATE_LIMIT_TOKEN = \"too-many-requests-token\";\n\n  static final String WIREMOCK_URL_TEMPLATE = \"__WIREMOCK_URL__\";\n\n  @InjectWireMock WireMockServer server;\n\n  static {\n    RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();\n    RestAssured.config()\n        .encoderConfig(EncoderConfig.encoderConfig().defaultContentCharset(\"UTF-8\"));\n    RestAssured.config()\n        .decoderConfig(DecoderConfig.decoderConfig().defaultContentCharset(\"UTF-8\"));\n  }\n\n  @AfterEach\n  void resetMock() {\n    server.resetAll();\n  }\n\n  protected void assertJson(String expectedFile, String currentBody) {\n    ObjectMapper mapper = ObjectMapperProducer.newInstance();\n    JsonNode current;", "    try {\n      current = mapper.readTree(currentBody);\n      JsonNode expected =\n          mapper.readTree(\n              getClass().getClassLoader().getResourceAsStream(\"__files/\" + expectedFile));\n      assertEquals(expected, current);\n    } catch (IOException e) {\n      fail(\"Unexpected processing exception\");\n    }\n  }\n\n  protected void assertHtml(String expectedFile, String currentBody) {\n    String expected;", "    try {\n      expected =\n          Files.read(\n              getClass().getClassLoader().getResourceAsStream(\"__files/\" + expectedFile),\n              Charset.defaultCharset());\n      expected = expected.replaceAll(WIREMOCK_URL_TEMPLATE, server.baseUrl());\n      assertEquals(expected, currentBody);\n    } catch (IOException e) {\n      fail(\"Unable to read HTML file\", e);\n    }\n  }\n\n  protected void assertReportContains(String expectedText, String currentBody) {\n    assertTrue(currentBody.contains(expectedText));\n  }\n\n  protected void assertReportDoesNotContains(String expectedText, String currentBody) {\n    assertFalse(currentBody.contains(expectedText));\n  }\n\n  protected void testReportIsValidHtml(String html) {\n    try (WebClient webClient = new WebClient(BrowserVersion.CHROME)) {\n      HtmlPage page = webClient.loadHtmlCodeIntoCurrentWindow(html);\n      assertTrue(page.isHtmlPage(), \"The string is valid HTML.\");\n      assertEquals(\"Dependency Analysis\", page.getTitleText());\n      assertNotNull(page.getElementsById(\"Icons\"));\n      assertNotNull(page.getElementsById(\"modal\"));\n      assertNotNull(page.getFirstByXPath(\"//div[@class='card']\"));\n      assertNotNull(page.getFirstByXPath(\"//div[@class='card-body']\"));\n      assertTrue(html.contains(\"Total Vulnerabilities:\"));\n    } catch (Exception e) {\n      fail(\"The string is not valid HTML.\", e);\n    }\n  }\n\n  protected String getContentType(String sbomType) {\n    switch (sbomType) {\n      case \"cyclonedx\":\n        return CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON;\n      case \"spdx\":\n        return Constants.SPDX_MEDIATYPE_JSON;\n      default:\n        fail(\"Sbom Type not implemented: \" + sbomType);\n    }\n    return null;\n  }\n\n  protected File loadSBOMFile(String sbomType) {\n    return new File(\n        getClass()\n            .getClassLoader()\n            .getResource(String.format(\"%s/maven-sbom.json\", sbomType))\n            .getPath());\n  }\n\n  protected String loadFileAsString(String file) {", "    try {\n      return Files.read(getClass().getClassLoader().getResourceAsStream(file), Charsets.UTF_8);\n    } catch (IOException e) {\n      fail(\"Unable to read expected file: \" + file, e);\n      return null;\n    }\n  }\n\n  protected void verifyRequest(String provider, Map<String, String> headers, boolean isEmpty) {\n    switch (provider) {\n      case Constants.SNYK_PROVIDER:\n        verifySnykRequest(headers.get(Constants.SNYK_TOKEN_HEADER));\n        break;\n      case Constants.OSS_INDEX_PROVIDER:\n        verifyOssRequest(\n            headers.get(Constants.OSS_INDEX_USER_HEADER),\n            headers.get(Constants.OSS_INDEX_TOKEN_HEADER),\n            isEmpty);\n    }\n  }\n\n  protected void verifySnykRequest(String token) {", "    if (token == null) {\n      server.verify(1, postRequestedFor(urlEqualTo(Constants.SNYK_DEP_GRAPH_API_PATH)));\n    } else {\n      server.verify(\n          1,\n          postRequestedFor(urlEqualTo(Constants.SNYK_DEP_GRAPH_API_PATH))\n              .withHeader(\"Authorization\", equalTo(\"token \" + token)));\n    }\n  }\n\n  protected void verifyTokenRequest(String provider, Map<String, String> headers) {\n    switch (provider) {\n      case Constants.SNYK_PROVIDER:\n        verifySnykTokenRequest(headers.get(Constants.SNYK_TOKEN_HEADER));\n        break;\n      case Constants.OSS_INDEX_PROVIDER:\n        verifyOssRequest(\n            headers.get(Constants.OSS_INDEX_USER_HEADER),\n            headers.get(Constants.OSS_INDEX_TOKEN_HEADER),\n            false);\n    }\n  }\n\n  protected void verifySnykTokenRequest(String token) {", "    if (token == null) {\n      server.verify(1, getRequestedFor(urlEqualTo(Constants.SNYK_TOKEN_API_PATH)));\n    } else {\n      server.verify(\n          1,\n          getRequestedFor(urlEqualTo(Constants.SNYK_TOKEN_API_PATH))\n              .withHeader(\"Authorization\", equalTo(\"token \" + token)));\n    }\n  }\n\n  protected void stubAllProviders() {\n    stubSnykRequests();\n    stubOssToken();\n  }\n\n  protected void verifyProviders(\n      Collection<String> providers, Map<String, String> credentials, boolean isEmpty) {\n    providers.stream()\n        .forEach(\n            p -> {\n              switch (p) {\n                case Constants.SNYK_PROVIDER:\n                  verifySnykRequest(credentials.get(Constants.SNYK_TOKEN_HEADER));\n                  break;\n                case Constants.OSS_INDEX_PROVIDER:\n                  verifyOssRequest(\n                      credentials.get(Constants.OSS_INDEX_USER_HEADER),\n                      credentials.get(Constants.OSS_INDEX_TOKEN_HEADER),\n                      isEmpty);\n                  break;\n              }\n            });\n  }\n\n  protected void stubSnykTokenRequests() {\n    // Missing token\n    server.stubFor(\n        get(Constants.SNYK_TOKEN_API_PATH)\n            .willReturn(\n                aResponse()\n                    .withStatus(401)\n                    .withBody(\n                        \"{\\\"code\\\": 401, \\\"error\\\": \\\"Not authorised\\\"\"\n                            + \", \\\"message\\\": \\\"Not authorised\\\"}\")));\n    // Default request\n    server.stubFor(\n        get(Constants.SNYK_TOKEN_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + OK_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"snyk/user_validation.json\")));\n    // Internal Error\n    server.stubFor(\n        get(Constants.SNYK_TOKEN_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + ERROR_TOKEN))\n            .willReturn(aResponse().withStatus(500)));\n    // Invalid token\n    server.stubFor(\n        get(Constants.SNYK_TOKEN_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + INVALID_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(401)\n                    .withBody(\n                        \"{\\\"code\\\": 401, \\\"error\\\": \\\"Invalid auth token\"\n                            + \" provided\\\", \\\"message\\\": \\\"Invalid auth\"\n                            + \" token provided\\\"}\")));\n    // Too many requests\n    server.stubFor(\n        get(Constants.SNYK_TOKEN_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + RATE_LIMIT_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(429)\n                    .withBody(\n                        \"{\\\"message\\\": \\\"The org acme (82be6926-dff6-4c22-a54a-8fb25ed4ee43)\"\n                            + \" has exceeded the rate limit.\\\"\"\n                            + \", \\\"error\\\": \\\"true\\\"}\")));\n  }\n\n  protected void stubSnykRequests() {\n    // Missing token\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .willReturn(\n                aResponse()\n                    .withStatus(401)\n                    .withBody(\n                        \"{\\\"code\\\": 401, \\\"error\\\": \\\"Not authorised\\\"\"\n                            + \", \\\"message\\\": \\\"Not authorised\\\"}\")));\n    // Other requests\n    Constants.PKG_MANAGERS.forEach(this::stubSnykEmptyRequest);\n    // Dependency request\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\n                \"Authorization\", equalTo(\"token \" + OK_TOKEN).or(equalTo(\"token \" + SNYK_TOKEN)))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(equalToJson(loadFileAsString(\"__files/snyk/maven_request.json\")))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"snyk/maven_report.json\")));\n    // Internal Error\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + ERROR_TOKEN))\n            .willReturn(aResponse().withStatus(500)));\n    // Invalid token\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + INVALID_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(401)\n                    .withBody(\n                        \"{\\\"code\\\": 401, \\\"error\\\": \\\"Invalid auth token\"\n                            + \" provided\\\", \\\"message\\\": \\\"Invalid auth\"\n                            + \" token provided\\\"}\")));\n    // Forbidden (i.e. token does not have access to the API)\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + UNAUTH_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(403)\n                    .withBody(\n                        \"{\\\"message\\\": \\\"The org acme (82be6926-dff6-4c22-a54a-8fb25ed4ee43) is not\"\n                            + \" entitled for api access. Please upgrade your plan to access this\"\n                            + \" capability\\\", \\\"error\\\": \\\"true\\\"}\")));\n    // Too many requests\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\"Authorization\", equalTo(\"token \" + RATE_LIMIT_TOKEN))\n            .willReturn(\n                aResponse()\n                    .withStatus(429)\n                    .withBody(\n                        \"{\\\"message\\\": \\\"The org acme (82be6926-dff6-4c22-a54a-8fb25ed4ee43)\"\n                            + \" has exceeded the rate limit.\\\"\"\n                            + \", \\\"error\\\": \\\"true\\\"}\")));\n  }\n\n  private void stubSnykEmptyRequest(String provider) {\n    // Empty request\n    server.stubFor(\n        post(Constants.SNYK_DEP_GRAPH_API_PATH)\n            .withHeader(\n                \"Authorization\", equalTo(\"token \" + OK_TOKEN).or(equalTo(\"token \" + SNYK_TOKEN)))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(\n                equalToJson(\n                    loadFileAsString(\"__files/snyk/empty_request.json\")\n                        .replaceAll(\"__PKG_MANAGER__\", provider)))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBody(\n                        loadFileAsString(\"__files/snyk/empty_report.json\")\n                            .replaceAll(\"__PKG_MANAGER__\", provider))));\n  }\n\n  protected void stubOssToken() {\n\n    server.stubFor(\n        post(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .willReturn(\n                aResponse()\n                    .withStatus(401)\n                    .withBody(\n                        \"{\\\"code\\\": 401, \\\"error\\\": \\\"Not authorised\\\"\"\n                            + \", \\\"message\\\": \\\"Not authorised\\\"}\")));\n    server.stubFor(\n        post(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)\n            .withBasicAuth(OK_USER, OK_TOKEN)\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(equalToJson(loadFileAsString(\"__files/ossindex/empty_request.json\")))\n            .willReturn(aResponse().withStatus(200).withBodyFile(\"ossindex/empty_report.json\")));\n    server.stubFor(\n        post(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)\n            .withBasicAuth(OK_USER, OK_TOKEN)\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(equalToJson(loadFileAsString(\"__files/ossindex/maven_request.json\")))\n            .willReturn(aResponse().withStatus(200).withBodyFile(\"ossindex/maven_report.json\")));\n    server.stubFor(\n        post(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)\n            .withBasicAuth(OK_USER, RATE_LIMIT_TOKEN)\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .willReturn(\n                aResponse()\n                    .withStatus(429)\n                    .withBody(\n                        \"{\\\"message\\\": \\\"The org acme (82be6926-dff6-4c22-a54a-8fb25ed4ee43)\"\n                            + \" has exceeded the rate limit.\\\"\"\n                            + \", \\\"error\\\": \\\"true\\\"}\")));\n    server.stubFor(\n        post(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)\n            .withBasicAuth(OK_USER, ERROR_TOKEN)\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .willReturn(aResponse().withStatus(500)));\n  }\n\n  protected void verifyOssRequest(String user, String pass, boolean isEmpty) {", "    if (user == null || pass == null || isEmpty) {\n      server.verify(0, postRequestedFor(urlEqualTo(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)));\n    } else {\n      server.verify(\n          1,\n          postRequestedFor(urlEqualTo(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH))\n              .withBasicAuth(new BasicCredentials(user, pass)));\n    }\n  }\n\n  protected void stubTCRequests() {\n    server.stubFor(\n        post(urlMatching(Constants.TRUSTED_CONTENT_PATH + \".*\"))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_ENCODING, \"identity\")\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"trustedcontent/gav_report.json\")));\n    server.stubFor(\n        post(urlMatching(Constants.TRUSTED_CONTENT_VEX_PATH))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(\n                equalToJson(loadFileAsString(\"__files/trustedcontent/oss_vulns_vex_request.json\")))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_ENCODING, \"identity\")\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"trustedcontent/short_vex_report.json\")));\n    server.stubFor(\n        post(urlMatching(Constants.TRUSTED_CONTENT_VEX_PATH))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(\n                equalToJson(loadFileAsString(\"__files/trustedcontent/snyk_vulns_vex_request.json\")))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_ENCODING, \"identity\")\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"trustedcontent/short_vex_report.json\")));\n    server.stubFor(\n        post(urlMatching(Constants.TRUSTED_CONTENT_VEX_PATH))\n            .withHeader(Exchange.CONTENT_TYPE, equalTo(MediaType.APPLICATION_JSON))\n            .withRequestBody(\n                equalToJson(loadFileAsString(\"__files/trustedcontent/long_vex_request.json\")))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n                    .withHeader(Exchange.CONTENT_ENCODING, \"identity\")\n                    .withHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON)\n                    .withBodyFile(\"trustedcontent/long_vex_report.json\")));\n  }\n\n  protected void verifyTCRequests() {\n    verifyTCRemediations();\n    verifyTCRecommendations();\n  }\n\n  protected void verifyTCRecommendations() {\n    server.verify(1, postRequestedFor(urlMatching(Constants.TRUSTED_CONTENT_PATH + \".*\")));\n  }\n\n  protected void verifyTCRemediations() {\n    server.verify(1, postRequestedFor(urlMatching(Constants.TRUSTED_CONTENT_VEX_PATH)));\n  }\n\n  protected void verifyNoInteractions() {\n    verifyNoInteractionsWithSnyk();\n    verifyNoInteractionsWithOSS();\n    verifyNoInteractionsWithTC();\n  }\n\n  protected void verifyNoInteractionsWithSnyk() {\n    server.verify(0, postRequestedFor(urlEqualTo(Constants.SNYK_DEP_GRAPH_API_PATH)));\n    server.verify(0, getRequestedFor(urlEqualTo(Constants.SNYK_TOKEN_API_PATH)));\n  }\n\n  protected void verifyNoInteractionsWithOSS() {\n    server.verify(0, postRequestedFor(urlEqualTo(Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH)));\n  }\n\n  protected void verifyNoInteractionsWithTC() {\n    verifyNoInteractionsWithTCRecommendations();\n    verifyNoInteractionsWithTCRemediations();\n  }\n\n  protected void verifyNoInteractionsWithTCRemediations() {\n    server.verify(0, postRequestedFor(urlMatching(Constants.TRUSTED_CONTENT_VEX_PATH)));\n  }\n\n  protected void verifyNoInteractionsWithTCRecommendations() {\n    server.verify(0, postRequestedFor(urlMatching(Constants.TRUSTED_CONTENT_PATH + \".*\")));\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/AnalysisTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport static io.restassured.RestAssured.given;\nimport static org.apache.camel.Exchange.CONTENT_TYPE;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.hamcrest.core.StringStartsWith.startsWithIgnoringCase;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Version;", "import java.net.http.HttpClient;\nimport java.net.http.HttpClient.Version;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\nimport org.cyclonedx.CycloneDxMediaType;", "\nimport org.cyclonedx.CycloneDxMediaType;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;", "import com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.ProviderStatus;\nimport com.redhat.exhort.api.Summary;\nimport com.redhat.exhort.api.TransitiveDependencyReport;\nimport com.redhat.exhort.integration.report.DependencyReportHelper;\n\nimport io.quarkus.test.junit.QuarkusTest;", "\nimport io.quarkus.test.junit.QuarkusTest;\n\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\n\n@QuarkusTest\npublic class AnalysisTest extends AbstractAnalysisTest {\n\n  private static final String CYCLONEDX = \"cyclonedx\";\n  private static final String SPDX = \"spdx\";\n\n  @ParameterizedTest\n  @ValueSource(strings = {CYCLONEDX, SPDX})", "  public void testWithWrongProvider(String sbom) {\n    List<PackageRef> req = Collections.emptyList();\n    given()\n        .header(CONTENT_TYPE, getContentType(sbom))\n        .queryParam(Constants.PROVIDERS_PARAM, \"unknown\")\n        .body(req)\n        .when()\n        .post(\"/api/v3/analysis\")\n        .then()\n        .assertThat()\n        .statusCode(422)\n        .contentType(MediaType.TEXT_PLAIN)\n        .body(equalTo(\"Unsupported providers: [unknown]\"));\n\n    verifyNoInteractions();\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {CYCLONEDX, SPDX})", "  public void testWithInvalidPkgManagers(String sbom) {\n    given()\n        .header(CONTENT_TYPE, getContentType(sbom))\n        .body(loadFileAsString(String.format(\"%s/unsupported-invalid-sbom.json\", sbom)))\n        .when()\n        .post(\"/api/v3/analysis\")\n        .then()\n        .assertThat()\n        .statusCode(422)\n        .contentType(MediaType.TEXT_PLAIN)\n        .body(equalTo(\"Unsupported package types received: [foo]\"));\n\n    verifyNoInteractions();\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {CYCLONEDX, SPDX})", "  public void testWithMixedPkgManagers(String sbom) {\n    given()\n        .header(CONTENT_TYPE, getContentType(sbom))\n        .body(loadFileAsString(String.format(\"%s/unsupported-mixed-sbom.json\", sbom)))\n        .when()\n        .post(\"/api/v3/analysis\")\n        .then()\n        .assertThat()\n        .statusCode(422)\n        .contentType(MediaType.TEXT_PLAIN)\n        .body(\n            startsWithIgnoringCase(\n                \"It is not supported to submit mixed Package Manager types. Found: [\"));\n\n    verifyNoInteractions();\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"emptySbomArguments\")", "  public void testEmptySbom(\n      List<String> providers, Map<String, String> authHeaders, String pkgManager) {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .headers(authHeaders)\n            .queryParam(Constants.PROVIDERS_PARAM, providers)\n            .body(loadFileAsString(String.format(\"%s/empty-sbom.json\", CYCLONEDX)))\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    providers.forEach(\n        p -> {\n          AnalysisReportValue reportValue = report.get(p);\n          assertEquals(Response.Status.OK.getStatusCode(), reportValue.getStatus().getCode());\n          assertTrue(reportValue.getStatus().getOk());\n          assertEquals(Response.Status.OK.getReasonPhrase(), reportValue.getStatus().getMessage());\n          assertEquals(0, reportValue.getSummary().getDependencies().getScanned());\n          assertEquals(0, reportValue.getSummary().getDependencies().getTransitive());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getTotal());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getDirect());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getCritical());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getHigh());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getMedium());\n          assertEquals(0, reportValue.getSummary().getVulnerabilities().getLow());\n\n          assertTrue(reportValue.getDependencies().isEmpty());\n        });\n\n    verifyProviders(providers, authHeaders, true);\n\n    verifyNoInteractionsWithTC();\n  }\n\n  private static Stream<Arguments> emptySbomArguments() {\n    return Stream.of(\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER), Collections.emptyMap(), Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.OSS_INDEX_PROVIDER),\n            Collections.emptyMap(),\n            Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Map.of(Constants.SNYK_TOKEN_HEADER, OK_TOKEN),\n            Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Map.of(\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                OK_TOKEN),\n            Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Map.of(\n                Constants.SNYK_TOKEN_HEADER,\n                OK_TOKEN,\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                OK_TOKEN),\n            Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Collections.emptyMap(),\n            Constants.MAVEN_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Collections.emptyMap(),\n            Constants.NPM_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Collections.emptyMap(),\n            Constants.GOLANG_PKG_MANAGER),\n        Arguments.of(\n            List.of(Constants.SNYK_PROVIDER, Constants.OSS_INDEX_PROVIDER),\n            Collections.emptyMap(),\n            Constants.PYPI_PKG_MANAGER));\n  }\n\n  @Test", "  public void testAllWithToken() {\n    stubAllProviders();\n    stubTCRequests();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .header(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)\n            .header(Constants.OSS_INDEX_USER_HEADER, OK_USER)\n            .header(Constants.OSS_INDEX_TOKEN_HEADER, OK_TOKEN)\n            .body(loadSBOMFile(CYCLONEDX))\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .asPrettyString();\n\n    assertJson(\"reports/report_all_token.json\", body);\n    verifySnykRequest(OK_TOKEN);\n    verifyOssRequest(OK_USER, OK_TOKEN, false);\n    verifyTCRequests();\n  }\n\n  @Test", "  public void testSnykWithNoToken() {\n    stubAllProviders();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .queryParam(Constants.PROVIDERS_PARAM, Constants.SNYK_PROVIDER)\n            .body(loadSBOMFile(CYCLONEDX))\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .asPrettyString();\n\n    assertJson(\"reports/report_all_no_snyk_token.json\", body);\n    verifySnykRequest(null);\n    verifyTCRequests();\n  }\n\n  @Test", "  public void testUnauthorizedRequest() {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadFileAsString(String.format(\"%s/empty-sbom.json\", CYCLONEDX)))\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .header(Constants.SNYK_TOKEN_HEADER, INVALID_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    assertEquals(1, report.size());\n    ProviderStatus status = report.get(Constants.SNYK_PROVIDER).getStatus();\n    assertFalse(status.getOk());\n    assertEquals(Constants.SNYK_PROVIDER, status.getName());\n    assertEquals(Response.Status.UNAUTHORIZED.getStatusCode(), status.getCode());\n\n    verifySnykRequest(INVALID_TOKEN);\n    verifyNoInteractionsWithTC();\n  }\n\n  @Test", "  public void testForbiddenRequest() {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadFileAsString(String.format(\"%s/empty-sbom.json\", CYCLONEDX)))\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .header(Constants.SNYK_TOKEN_HEADER, UNAUTH_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    assertEquals(1, report.size());\n    ProviderStatus status = report.get(Constants.SNYK_PROVIDER).getStatus();\n    assertFalse(status.getOk());\n    assertEquals(Constants.SNYK_PROVIDER, status.getName());\n    assertEquals(Response.Status.FORBIDDEN.getStatusCode(), status.getCode());\n\n    verifySnykRequest(UNAUTH_TOKEN);\n    verifyNoInteractionsWithTC();\n  }\n\n  @Test", "  public void testSBOMJsonWithToken() {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .header(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    assertSummary(report.get(Constants.SNYK_PROVIDER).getSummary());\n    assertDependenciesReport(report.get(Constants.SNYK_PROVIDER).getDependencies());\n\n    verifyTCRequests();\n    verifySnykRequest(OK_TOKEN);\n  }\n\n  @Test", "  public void testNonVerboseJson() {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .queryParam(Constants.VERBOSE_MODE_HEADER, Boolean.FALSE)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    assertSummary(report.get(Constants.SNYK_PROVIDER).getSummary());\n    assertTrue(report.get(Constants.SNYK_PROVIDER).getDependencies().isEmpty());\n\n    verifyTCRequests();\n    verifySnykRequest(null);\n  }\n\n  @Test", "  public void testNonVerboseWithToken() {\n    stubAllProviders();\n    stubTCRequests();\n\n    AnalysisReport report =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .header(\"Accept\", MediaType.APPLICATION_JSON)\n            .header(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)\n            .queryParam(Constants.VERBOSE_MODE_HEADER, Boolean.FALSE)\n            .body(loadSBOMFile(CYCLONEDX))\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(AnalysisReport.class);\n\n    assertSummary(report.get(Constants.SNYK_PROVIDER).getSummary());\n    assertTrue(report.get(Constants.SNYK_PROVIDER).getDependencies().isEmpty());\n\n    verifySnykRequest(OK_TOKEN);\n    verifyTCRequests();\n  }\n\n  @Test", "  public void testHtmlWithoutToken() {\n    stubTCRequests();\n    stubAllProviders();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.TEXT_HTML)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.TEXT_HTML)\n            .extract()\n            .body()\n            .asString();\n\n    testReportIsValidHtml(body);\n    assertReportContains(\"Sign up for a free Snyk account\", body);\n\n    verifySnykRequest(null);\n    verifyTCRequests();\n  }\n\n  @Test", "  public void testHtmlWithToken() {\n    stubAllProviders();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.TEXT_HTML)\n            .header(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)\n            .header(Constants.OSS_INDEX_USER_HEADER, OK_USER)\n            .header(Constants.OSS_INDEX_TOKEN_HEADER, OK_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.TEXT_HTML)\n            .extract()\n            .body()\n            .asString();\n\n    testReportIsValidHtml(body);\n    assertReportDoesNotContains(\"Sign up for a free Snyk account\", body);\n\n    verifySnykRequest(OK_TOKEN);\n    verifyTCRequests();\n    verifyOssRequest(OK_USER, OK_TOKEN, false);\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {\"HTTP_1_1\", \"HTTP_2\"})", "  public void testMultipart_HttpVersions(String version) throws IOException, InterruptedException {\n    stubAllProviders();\n    stubTCRequests();\n\n    HttpClient client = HttpClient.newHttpClient();\n    HttpRequest request =\n        HttpRequest.newBuilder(URI.create(\"http://localhost:8081/api/v3/analysis\"))\n            .setHeader(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .setHeader(\"Accept\", Constants.MULTIPART_MIXED)\n            .setHeader(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)\n            .setHeader(Constants.OSS_INDEX_USER_HEADER, OK_USER)\n            .setHeader(Constants.OSS_INDEX_TOKEN_HEADER, OK_TOKEN)\n            .version(Version.valueOf(version))\n            .POST(HttpRequest.BodyPublishers.ofFile(loadSBOMFile(CYCLONEDX).toPath()))\n            .build();\n\n    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n    assertEquals(Response.Status.OK.getStatusCode(), response.statusCode());\n\n    verifySnykRequest(OK_TOKEN);\n    verifyTCRequests();\n    verifyOssRequest(OK_USER, OK_TOKEN, false);\n  }\n\n  @Test", "  public void testHtmlUnauthorized() {\n    stubAllProviders();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.TEXT_HTML)\n            .header(Constants.SNYK_TOKEN_HEADER, INVALID_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.TEXT_HTML)\n            .extract()\n            .body()\n            .asString();\n\n    testReportIsValidHtml(body);\n    assertReportContains(\"Snyk: Unauthorized: Verify the provided credentials are valid.\", body);\n\n    verifySnykRequest(INVALID_TOKEN);\n    verifyTCRecommendations();\n    verifyNoInteractionsWithTCRemediations();\n    verifyNoInteractionsWithOSS();\n  }\n\n  @Test", "  public void testHtmlForbidden() {\n    stubAllProviders();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.TEXT_HTML)\n            .header(Constants.SNYK_TOKEN_HEADER, UNAUTH_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.TEXT_HTML)\n            .extract()\n            .body()\n            .asString();\n\n    testReportIsValidHtml(body);\n    assertReportContains(\n        \"Snyk: Forbidden: The provided credentials don't have the required permissions.\", body);\n\n    verifySnykRequest(UNAUTH_TOKEN);\n    verifyTCRecommendations();\n    verifyNoInteractionsWithTCRemediations();\n    verifyNoInteractionsWithOSS();\n  }\n\n  @Test", "  public void testHtmlError() {\n    stubAllProviders();\n    stubTCRequests();\n\n    String body =\n        given()\n            .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n            .body(loadSBOMFile(CYCLONEDX))\n            .header(\"Accept\", MediaType.TEXT_HTML)\n            .header(Constants.SNYK_TOKEN_HEADER, ERROR_TOKEN)\n            .when()\n            .post(\"/api/v3/analysis\")\n            .then()\n            .assertThat()\n            .statusCode(200)\n            .contentType(MediaType.TEXT_HTML)\n            .extract()\n            .body()\n            .asString();\n\n    testReportIsValidHtml(body);\n    assertReportContains(\"Snyk: Server Error\", body);\n\n    verifySnykRequest(ERROR_TOKEN);\n    verifyTCRecommendations();\n    verifyNoInteractionsWithTCRemediations();\n    verifyNoInteractionsWithOSS();\n  }\n\n  @Test", "  public void testUnknownMediaType() {\n    given()\n        .header(CONTENT_TYPE, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON)\n        .body(loadSBOMFile(CYCLONEDX))\n        .header(\"Accept\", MediaType.APPLICATION_XML)\n        .when()\n        .post(\"/api/v3/analysis\")\n        .then()\n        .assertThat()\n        .statusCode(415)\n        .contentType(MediaType.TEXT_PLAIN);\n\n    verifyNoInteractions();\n  }\n\n  private void assertSummary(Summary summary) {\n    assertEquals(2, summary.getDependencies().getScanned());\n    assertEquals(7, summary.getDependencies().getTransitive());\n\n    assertEquals(4, summary.getVulnerabilities().getTotal());\n    assertEquals(0, summary.getVulnerabilities().getDirect());\n    assertEquals(0, summary.getVulnerabilities().getCritical());\n    assertEquals(1, summary.getVulnerabilities().getHigh());\n    assertEquals(3, summary.getVulnerabilities().getMedium());\n    assertEquals(0, summary.getVulnerabilities().getLow());\n  }\n\n  private void assertDependenciesReport(List<DependencyReport> dependencies) {\n    assertEquals(2, dependencies.size());\n\n    PackageRef hibernate =\n        PackageRef.builder()\n            .pkgManager(Constants.MAVEN_PKG_MANAGER)\n            .namespace(\"io.quarkus\")\n            .name(\"quarkus-hibernate-orm\")\n            .version(\"2.13.5.Final\")\n            .build();\n    DependencyReport report = getReport(hibernate.name(), dependencies);\n    assertNotNull(report);\n    assertEquals(hibernate, report.getRef());\n    assertEquals(\n        PackageRef.builder()\n            .purl(\"pkg:maven/io.quarkus/quarkus-hibernate-orm@2.13.5.redhat-00001\")\n            .build(),\n        report.getRecommendation());\n    assertTrue(report.getIssues().isEmpty());\n    assertTrue(report.getRemediations().isEmpty());\n    assertTrue(new DependencyReportHelper().hasRemediation(report));\n\n    assertEquals(1, report.getTransitive().size());\n    TransitiveDependencyReport tReport = report.getTransitive().get(0);\n    PackageRef jackson =\n        PackageRef.builder()\n            .pkgManager(Constants.MAVEN_PKG_MANAGER)\n            .namespace(\"com.fasterxml.jackson.core\")\n            .name(\"jackson-databind\")\n            .version(\"2.13.1\")\n            .build();\n    assertEquals(jackson, tReport.getRef());\n    assertEquals(3, tReport.getIssues().size());\n    assertEquals(tReport.getHighestVulnerability(), tReport.getIssues().get(0));\n    assertEquals(report.getHighestVulnerability(), tReport.getHighestVulnerability());\n\n    assertEquals(\n        PackageRef.builder()\n            .pkgManager(Constants.MAVEN_PKG_MANAGER)\n            .namespace(jackson.purl().getNamespace())\n            .name(jackson.purl().getName())\n            .version(\"2.13.1.Final-redhat-00002\")\n            .build(),\n        tReport.getRemediations().get(\"CVE-2022-42003\").getMavenPackage());\n\n    assertNull(tReport.getRemediations().get(\"CVE-2020-36518\"));\n  }\n\n  private DependencyReport getReport(String pkgName, List<DependencyReport> dependencies) {\n    DependencyReport dep =\n        dependencies.stream()\n            .filter(d -> d.getRef().name().equals(pkgName))\n            .findFirst()\n            .orElse(null);\n    assertNotNull(dep);\n    return dep;\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/TokenValidationIT.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport io.quarkus.test.junit.QuarkusIntegrationTest;\n\n@QuarkusIntegrationTest\npublic class TokenValidationIT extends TokenValidationTest {\n\n  // run the same tests\n\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/TokenValidationTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport static io.restassured.RestAssured.given;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Map;\nimport java.util.stream.Stream;\n", "import java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport io.quarkus.test.junit.QuarkusTest;\n\nimport jakarta.ws.rs.core.MediaType;", "\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\n\n@QuarkusTest\npublic class TokenValidationTest extends AbstractAnalysisTest {\n\n  @Test\n  public void testMissingToken() {\n    String msg =\n        given()\n            .when()\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(400)\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n    assertEquals(\"Missing authentication header\", msg);\n\n    verifyNoInteractions();\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"tokenErrorArguments\")", "  public void testMissingToken() {\n    String msg =\n        given()\n            .when()\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(400)\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n    assertEquals(\"Missing authentication header\", msg);\n\n    verifyNoInteractions();\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"tokenErrorArguments\")", "  public void testServerError(String provider, Map<String, String> headers) {\n    stubOssToken();\n    stubSnykTokenRequests();\n\n    String msg =\n        given()\n            .when()\n            .headers(headers)\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n\n    assertEquals(\"Unable to validate \" + provider + \" Token: Server Error\", msg);\n    verifyTokenRequest(provider, headers);\n  }\n\n  private static Stream<Arguments> tokenErrorArguments() {\n    return Stream.of(\n        Arguments.of(\n            Constants.OSS_INDEX_PROVIDER,\n            Map.of(\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                ERROR_TOKEN)),\n        Arguments.of(Constants.SNYK_PROVIDER, Map.of(Constants.SNYK_TOKEN_HEADER, ERROR_TOKEN)));\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"tokenSuccessArguments\")", "  public void testSuccess(String provider, Map<String, String> headers) {\n    stubOssToken();\n    stubSnykTokenRequests();\n\n    String msg =\n        given()\n            .when()\n            .headers(headers)\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(Response.Status.OK.getStatusCode())\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n\n    assertEquals(\"Token validated successfully\", msg);\n    verifyTokenRequest(provider, headers);\n  }\n\n  private static Stream<Arguments> tokenSuccessArguments() {\n    return Stream.of(\n        Arguments.of(\n            Constants.OSS_INDEX_PROVIDER,\n            Map.of(\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                OK_TOKEN)),\n        Arguments.of(Constants.SNYK_PROVIDER, Map.of(Constants.SNYK_TOKEN_HEADER, OK_TOKEN)));\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"tokenUnauthorizedArguments\")", "  public void testUnauthorized(String provider, Map<String, String> headers) {\n    stubOssToken();\n    stubSnykTokenRequests();\n\n    String msg =\n        given()\n            .when()\n            .headers(headers)\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(Response.Status.UNAUTHORIZED.getStatusCode())\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n\n    assertEquals(\"Invalid token provided. Unauthorized\", msg);\n    verifyTokenRequest(provider, headers);\n  }\n\n  private static Stream<Arguments> tokenUnauthorizedArguments() {\n    return Stream.of(\n        Arguments.of(\n            Constants.OSS_INDEX_PROVIDER,\n            Map.of(\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                INVALID_TOKEN)),\n        Arguments.of(Constants.SNYK_PROVIDER, Map.of(Constants.SNYK_TOKEN_HEADER, INVALID_TOKEN)));\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"tokenTooManyRequestsArguments\")", "  public void testTooManyRequests(String provider, Map<String, String> headers) {\n    stubOssToken();\n    stubSnykTokenRequests();\n\n    String msg =\n        given()\n            .when()\n            .headers(headers)\n            .get(\"/api/v3/token\")\n            .then()\n            .assertThat()\n            .statusCode(Response.Status.TOO_MANY_REQUESTS.getStatusCode())\n            .contentType(MediaType.TEXT_PLAIN)\n            .extract()\n            .body()\n            .asString();\n\n    assertEquals(\"Unable to validate \" + provider + \" Token: Too Many Requests\", msg);\n    verifyTokenRequest(provider, headers);\n  }\n\n  private static Stream<Arguments> tokenTooManyRequestsArguments() {\n    return Stream.of(\n        Arguments.of(\n            Constants.OSS_INDEX_PROVIDER,\n            Map.of(\n                Constants.OSS_INDEX_USER_HEADER,\n                OK_USER,\n                Constants.OSS_INDEX_TOKEN_HEADER,\n                RATE_LIMIT_TOKEN)),\n        Arguments.of(\n            Constants.SNYK_PROVIDER, Map.of(Constants.SNYK_TOKEN_HEADER, RATE_LIMIT_TOKEN)));\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/backend/IssueTestUtils.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend;\n\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.SeverityUtils;\n\npublic class IssueTestUtils {\n\n  public static Issue buildIssue(int i) {\n    return new Issue()\n        .id(\"ID-\" + i)\n        .title(\"Vulnerability \" + i)\n        .cvssScore(Float.valueOf(i))\n        .addCvesItem(\"CVE-\" + i)\n        .severity(SeverityUtils.fromScore(i));\n  }\n}\n", "  public static Issue buildIssue(int i) {\n    return new Issue()\n        .id(\"ID-\" + i)\n        .title(\"Vulnerability \" + i)\n        .cvssScore(Float.valueOf(i))\n        .addCvesItem(\"CVE-\" + i)\n        .severity(SeverityUtils.fromScore(i));\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/backend/ProviderAggregatorTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend;\n\nimport static com.redhat.exhort.integration.backend.IssueTestUtils.buildIssue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.util.Collection;", "\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.stream.Collectors;", "import java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.providers.ProviderAggregator;", "import com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.providers.ProviderAggregator;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.DirectDependency;\n\nimport jakarta.ws.rs.core.Response.Status;\n\npublic class ProviderAggregatorTest {\n\n  @Test\n  public void testBuildReport_empty() {\n    AnalysisReportValue report =\n        new SimpleProviderAggregator()\n            .buildReport(\n                Collections.emptyMap(),\n                DependencyTree.builder()\n                    .root(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))\n                    .build());\n    assertEmptyReport(report);\n\n    report =\n        new SimpleProviderAggregator()\n            .buildReport(\n                Collections.emptyMap(),\n                DependencyTree.builder()\n                    .root(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))\n                    .dependencies(Collections.emptyMap())\n                    .build());\n    assertEmptyReport(report);\n  }\n\n  @Test", "  public void testBuildReport_empty() {\n    AnalysisReportValue report =\n        new SimpleProviderAggregator()\n            .buildReport(\n                Collections.emptyMap(),\n                DependencyTree.builder()\n                    .root(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))\n                    .build());\n    assertEmptyReport(report);\n\n    report =\n        new SimpleProviderAggregator()\n            .buildReport(\n                Collections.emptyMap(),\n                DependencyTree.builder()\n                    .root(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))\n                    .dependencies(Collections.emptyMap())\n                    .build());\n    assertEmptyReport(report);\n  }\n\n  @Test", "  public void testBuildReport() {\n    DependencyTree tree = buildTree();\n    AnalysisReportValue report = new SimpleProviderAggregator().buildReport(buildIssues(), tree);\n    assertNotNull(report);\n\n    assertEquals(3, report.getSummary().getDependencies().getScanned());\n    assertEquals(4, report.getSummary().getDependencies().getTransitive());\n    assertEquals(3, report.getDependencies().size());\n\n    assertEquals(4, report.getSummary().getVulnerabilities().getTotal());\n    assertEquals(1, report.getSummary().getVulnerabilities().getHigh());\n    assertEquals(1, report.getSummary().getVulnerabilities().getCritical());\n    assertEquals(1, report.getSummary().getVulnerabilities().getDirect());\n    assertEquals(1, report.getSummary().getVulnerabilities().getMedium());\n    assertEquals(1, report.getSummary().getVulnerabilities().getLow());\n\n    assertOkStatus(report);\n\n    // this dependency has one transitive dependency with 3 issues\n    assertEquals(\n        Float.valueOf(10),\n        report.getDependencies().get(0).getHighestVulnerability().getCvssScore());\n\n    assertEquals(\n        Float.valueOf(10),\n        report\n            .getDependencies()\n            .get(0)\n            .getTransitive()\n            .get(0)\n            .getHighestVulnerability()\n            .getCvssScore());\n    assertEquals(\n        Float.valueOf(10),\n        report.getDependencies().get(0).getTransitive().get(0).getIssues().get(0).getCvssScore());\n    assertEquals(\n        Float.valueOf(8),\n        report.getDependencies().get(0).getTransitive().get(0).getIssues().get(1).getCvssScore());\n    assertEquals(\n        Float.valueOf(5),\n        report.getDependencies().get(0).getTransitive().get(0).getIssues().get(2).getCvssScore());\n\n    assertEquals(Collections.emptyList(), report.getDependencies().get(0).getIssues());\n    assertEquals(\n        Collections.emptyList(),\n        report.getDependencies().get(0).getTransitive().get(1).getIssues());\n    assertNull(report.getDependencies().get(0).getTransitive().get(1).getHighestVulnerability());\n\n    // this has only one issue in the direct dependency\n    assertEquals(\n        Float.valueOf(3), report.getDependencies().get(1).getHighestVulnerability().getCvssScore());\n    assertEquals(\n        Float.valueOf(3), report.getDependencies().get(1).getIssues().get(0).getCvssScore());\n\n    // this dependency does not have issues\n    assertNull(report.getDependencies().get(2).getHighestVulnerability());\n  }\n\n  private void assertEmptyReport(AnalysisReportValue report) {\n    assertNotNull(report);\n\n    assertEquals(0, report.getSummary().getDependencies().getScanned());\n    assertEquals(0, report.getSummary().getDependencies().getTransitive());\n\n    assertNoVulnerabilities(report);\n    assertEquals(Collections.emptyList(), report.getDependencies());\n  }\n\n  private void assertNoVulnerabilities(AnalysisReportValue report) {\n    assertEquals(0, report.getSummary().getVulnerabilities().getTotal());\n    assertEquals(0, report.getSummary().getVulnerabilities().getHigh());\n    assertEquals(0, report.getSummary().getVulnerabilities().getCritical());\n    assertEquals(0, report.getSummary().getVulnerabilities().getDirect());\n    assertEquals(0, report.getSummary().getVulnerabilities().getMedium());\n    assertEquals(0, report.getSummary().getVulnerabilities().getLow());\n\n    assertOkStatus(report);\n  }\n\n  private void assertOkStatus(AnalysisReportValue report) {\n    assertEquals(Boolean.TRUE, report.getStatus().getOk());\n    assertEquals(Status.OK.getStatusCode(), report.getStatus().getCode());\n    assertEquals(Status.OK.getReasonPhrase(), report.getStatus().getMessage());\n    assertEquals(\"simple\", report.getStatus().getName());\n  }\n\n  private static final Map<String, Collection<String>> DEFAULT_TREE =\n      Map.of(\n          \"com.example:dep-a:jar:1.0.0\",\n          List.of(\"com.example:dep-a-a:jar:1.0.0\", \"com.example:dep-a-b:jar:1.0.0\"),\n          \"com.example:dep-b:jar:1.0.0\",\n          List.of(\"com.example:dep-b-a:jar:1.0.0\", \"com.example:dep-b-b:jar:1.0.0\"),\n          \"com.example:dep-c:jar:1.0.0\",\n          Collections.emptyList());\n\n  private static DependencyTree buildTree() {\n    Map<PackageRef, DirectDependency> deps = new HashMap<>();\n    DEFAULT_TREE.entrySet().stream()\n        .sorted(Comparator.comparing(Entry::getKey))\n        .forEach(\n            e -> {\n              PackageRef ref = PackageRef.parse(e.getKey(), Constants.MAVEN_PKG_MANAGER);\n              Set<PackageRef> transitive =\n                  e.getValue().stream()\n                      .sorted()\n                      .map(s -> PackageRef.parse(s, Constants.MAVEN_PKG_MANAGER))\n                      .collect(Collectors.toSet());\n              deps.put(ref, DirectDependency.builder().ref(ref).transitive(transitive).build());\n            });\n\n    DependencyTree tree =\n        DependencyTree.builder()\n            .root(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))\n            .dependencies(deps)\n            .build();\n    return tree;\n  }\n\n  private static Map<String, List<Issue>> buildIssues() {\n    Map<String, List<Issue>> issues = new HashMap<>();\n    issues.put(\"com.example:dep-a-a\", List.of(buildIssue(5), buildIssue(10), buildIssue(8)));\n    issues.put(\"com.example:dep-c\", List.of(buildIssue(3)));\n\n    return issues;\n  }\n\n  static final class SimpleProviderAggregator extends ProviderAggregator {\n\n    @Override\n    protected String getProviderName() {\n      return \"simple\";\n    }\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/backend/BackendUtilsTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend;\n\nimport static com.redhat.exhort.integration.backend.IssueTestUtils.buildIssue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n", "import static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependencyReport;", "import com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.ProviderStatus;\nimport com.redhat.exhort.api.TransitiveDependencyReport;\n\npublic class BackendUtilsTest {\n\n  @Test\n  public void testRemoveEmptyDependencies_empty() {\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(new AnalysisReport());\n    assertEquals(new AnalysisReport(), result);\n  }\n\n  @Test", "  public void testRemoveEmptyDependencies_empty() {\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(new AnalysisReport());\n    assertEquals(new AnalysisReport(), result);\n  }\n\n  @Test\n  public void testRemoveEmptyDependencies_empty_reports() {\n\n    AnalysisReport reports = new AnalysisReport();\n    reports.put(\"one\", new AnalysisReportValue());\n    reports.put(\"two\", new AnalysisReportValue());\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(reports);\n    assertEquals(reports, result);\n  }\n\n  @Test", "  public void testRemoveDependencies_no_issues_no_recommendations() {\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(buildReport());\n    assertNotNull(result);\n    AnalysisReportValue report = result.get(PROVIDER_NAME);\n    assertNotNull(report);\n    assertTrue(report.getDependencies().isEmpty());\n  }\n\n  @Test\n  public void testRemoveDependencies_with_recommendations() {\n    AnalysisReport reports = buildReport();\n    addRecommendations(reports);\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(reports);\n    List<DependencyReport> dependencies = result.get(PROVIDER_NAME).getDependencies();\n    assertEquals(2, dependencies.size());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0\", dependencies.get(0).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0-redhat-001\",\n        dependencies.get(0).getRecommendation().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0\", dependencies.get(1).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0-redhat-001\",\n        dependencies.get(1).getRecommendation().purl().getCoordinates());\n  }\n\n  @Test", "  public void testRemoveDependencies_with_recommendations() {\n    AnalysisReport reports = buildReport();\n    addRecommendations(reports);\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(reports);\n    List<DependencyReport> dependencies = result.get(PROVIDER_NAME).getDependencies();\n    assertEquals(2, dependencies.size());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0\", dependencies.get(0).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0-redhat-001\",\n        dependencies.get(0).getRecommendation().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0\", dependencies.get(1).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0-redhat-001\",\n        dependencies.get(1).getRecommendation().purl().getCoordinates());\n  }\n\n  @Test", "  public void testRemoveDependencies_with_issues() {\n    AnalysisReport reports = buildReport();\n    addIssues(reports);\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(reports);\n    List<DependencyReport> dependencies = result.get(PROVIDER_NAME).getDependencies();\n    assertEquals(2, dependencies.size());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0\", dependencies.get(0).getRef().purl().getCoordinates());\n    assertEquals(2, dependencies.get(0).getIssues().size());\n    assertEquals(Float.valueOf(10), dependencies.get(0).getHighestVulnerability().getCvssScore());\n    assertEquals(\n        \"pkg:maven/com.example/dep-c@1.0.0\", dependencies.get(1).getRef().purl().getCoordinates());\n    assertEquals(Float.valueOf(8), dependencies.get(1).getHighestVulnerability().getCvssScore());\n    assertNull(dependencies.get(1).getIssues());\n    assertEquals(1, dependencies.get(1).getTransitive().get(0).getIssues().size());\n    assertEquals(\n        Float.valueOf(8),\n        dependencies.get(1).getTransitive().get(0).getHighestVulnerability().getCvssScore());\n  }\n\n  @Test", "  public void testRemoveDependencies() {\n    AnalysisReport reports = buildReport();\n    addIssues(reports);\n    addRecommendations(reports);\n    AnalysisReport result = BackendUtils.removeEmptyDependencies(reports);\n\n    List<DependencyReport> dependencies = result.get(PROVIDER_NAME).getDependencies();\n    assertEquals(3, dependencies.size());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0\", dependencies.get(0).getRef().purl().getCoordinates());\n    assertEquals(2, dependencies.get(0).getIssues().size());\n    assertEquals(Float.valueOf(10), dependencies.get(0).getHighestVulnerability().getCvssScore());\n    assertEquals(\n        \"pkg:maven/com.example/dep-c@1.0.0\", dependencies.get(2).getRef().purl().getCoordinates());\n    assertEquals(Float.valueOf(8), dependencies.get(2).getHighestVulnerability().getCvssScore());\n    assertNull(dependencies.get(1).getIssues());\n    assertEquals(1, dependencies.get(2).getTransitive().get(0).getIssues().size());\n    assertEquals(\n        Float.valueOf(8),\n        dependencies.get(2).getTransitive().get(0).getHighestVulnerability().getCvssScore());\n\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0\", dependencies.get(0).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-a@1.0.0-redhat-001\",\n        dependencies.get(0).getRecommendation().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0\", dependencies.get(1).getRef().purl().getCoordinates());\n    assertEquals(\n        \"pkg:maven/com.example/dep-b@1.0.0-redhat-001\",\n        dependencies.get(1).getRecommendation().purl().getCoordinates());\n  }\n\n  private static AnalysisReportValue emptyReport(String providerName) {\n    return new AnalysisReportValue()\n        .status(new ProviderStatus().name(providerName))\n        .dependencies(Collections.emptyList());\n  }\n\n  private static void addIssues(AnalysisReport report) {\n    // Add issues to direct dependency dep-a\n    report\n        .get(PROVIDER_NAME)\n        .getDependencies()\n        .get(0)\n        .issues(List.of(buildIssue(10), buildIssue(5)))\n        .highestVulnerability(buildIssue(10));\n    // Add issues to transitive dependency dep-c-a\n    report\n        .get(PROVIDER_NAME)\n        .getDependencies()\n        .get(2)\n        .highestVulnerability(buildIssue(8))\n        .getTransitive()\n        .get(0)\n        .issues(List.of(buildIssue(8)))\n        .highestVulnerability(buildIssue(8));\n  }\n\n  private static void addRecommendations(AnalysisReport report) {\n    // Add recommendation dependency dep-a\n    report\n        .get(PROVIDER_NAME)\n        .getDependencies()\n        .get(0)\n        .recommendation(new PackageRef(\"pkg:maven/com.example/dep-a@1.0.0-redhat-001\"));\n    // Add recommendation to dependency dep-b\n    report\n        .get(PROVIDER_NAME)\n        .getDependencies()\n        .get(1)\n        .recommendation(new PackageRef(\"pkg:maven/com.example/dep-b@1.0.0-redhat-001\"));\n  }\n\n  private static final String PROVIDER_NAME = \"example\";\n\n  private static final AnalysisReport buildReport() {\n    AnalysisReport result = new AnalysisReport();\n    result.put(\n        PROVIDER_NAME,\n        emptyReport(PROVIDER_NAME)\n            .dependencies(\n                List.of(\n                    new DependencyReport()\n                        .ref(new PackageRef(\"pkg:maven/com.example/dep-a@1.0.0\"))\n                        .transitive(\n                            List.of(\n                                new TransitiveDependencyReport()\n                                    .ref(new PackageRef(\"pkg:maven/com.example/dep-a-a@1.0.0\")),\n                                new TransitiveDependencyReport()\n                                    .ref(new PackageRef(\"pkg:maven/com.example/dep-a-b@1.0.0\")))),\n                    new DependencyReport().ref(new PackageRef(\"pkg:maven/com.example/dep-b@1.0.0\")),\n                    new DependencyReport()\n                        .ref(new PackageRef(\"pkg:maven/com.example/dep-c@1.0.0\"))\n                        .transitive(\n                            List.of(\n                                new TransitiveDependencyReport()\n                                    .ref(new PackageRef(\"pkg:maven/com.example/dep-c-a@1.0.0\")),\n                                new TransitiveDependencyReport()\n                                    .ref(new PackageRef(\"pkg:maven/com.example/dep-c-b@1.0.0\")),\n                                new TransitiveDependencyReport()\n                                    .ref(\n                                        new PackageRef(\"pkg:maven/com.example/dep-c-c@1.0.0\")))))));\n    return result;\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/integration/backend/sbom/SbomParserTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.params.provider.Arguments.arguments;", "import static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.params.provider.Arguments.arguments;\n\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.cyclonedx.CycloneDxMediaType;\nimport org.junit.jupiter.api.Test;", "import org.cyclonedx.CycloneDxMediaType;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.sbom.cyclonedx.CycloneDxParser;\nimport com.redhat.exhort.integration.backend.sbom.spdx.SpdxParser;", "import com.redhat.exhort.integration.backend.sbom.cyclonedx.CycloneDxParser;\nimport com.redhat.exhort.integration.backend.sbom.spdx.SpdxParser;\nimport com.redhat.exhort.model.DependencyTree;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\n\npublic class SbomParserTest {\n\n  private static final Collection<String> MEDIA_TYPES =\n      List.of(Constants.SPDX_MEDIATYPE_JSON, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON);\n  private static final PackageRef DEFAULT_MAVEN_ROOT =\n      DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER);\n  private static final PackageRef EXPECTED_ROOT =\n      PackageRef.builder()\n          .namespace(\"org.acme.dbaas\")\n          .name(\"postgresql-orm-quarkus\")\n          .version(\"1.0.0-SNAPSHOT\")\n          .pkgManager(Constants.MAVEN_PKG_MANAGER)\n          .build();\n\n  @Test\n  void testInvalidContentType() {\n    ClientErrorException ex =\n        assertThrows(\n            ClientErrorException.class, () -> SbomParserFactory.newInstance(MediaType.TEXT_PLAIN));\n    assertEquals(\"Unsupported Content-Type header: \" + MediaType.TEXT_PLAIN, ex.getMessage());\n    assertEquals(\n        Response.Status.UNSUPPORTED_MEDIA_TYPE.getStatusCode(), ex.getResponse().getStatus());\n  }\n\n  @Test\n  void testCycloneDxContentType() {\n    SbomParser parser =\n        SbomParserFactory.newInstance(CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON);\n    assertNotNull(parser);\n    assertTrue(parser instanceof CycloneDxParser);\n  }\n\n  @Test\n  void testSpdxContentType() {\n    SbomParser parser = SbomParserFactory.newInstance(Constants.SPDX_MEDIATYPE_JSON);\n    assertNotNull(parser);\n    assertTrue(parser instanceof SpdxParser);\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testParseEmptySBOM(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/empty-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(0, tree.dependencies().size());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testSBOMWithoutDependencies(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/no-deps-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(0, tree.dependencies().size());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testParseInvalidSBOM(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    InputStream file = getClass().getClassLoader().getResourceAsStream(\"invalid_deps_file.txt\");\n    ClientErrorException ex =\n        assertThrows(ClientErrorException.class, () -> parser.buildTree(file));\n    assertNotNull(ex);\n    assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), ex.getResponse().getStatus());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testMinimalSbom(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/minimal-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(2, tree.dependencies().size());\n    assertEquals(7, tree.transitiveCount());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getSbomUseCases\")\n  void testSbom(String mediaType, String pkgManager, int direct, int transitive, PackageRef root) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/%s-sbom.json\", getFolder(mediaType), pkgManager);\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(direct, tree.dependencies().size());\n    assertEquals(transitive, tree.transitiveCount());\n    assertEquals(root, tree.root());\n  }\n\n  static Stream<String> getMediaTypes() {\n    return MEDIA_TYPES.stream();\n  }\n\n  static Stream<Arguments> getSbomUseCases() {\n    return getMediaTypes()\n        .mapMulti(\n            (t, consumer) -> {\n              consumer.accept(arguments(t, Constants.MAVEN_PKG_MANAGER, 2, 7, EXPECTED_ROOT));\n              consumer.accept(\n                  arguments(\n                      t,\n                      Constants.GOLANG_PKG_MANAGER,\n                      2,\n                      3,\n                      PackageRef.builder()\n                          .namespace(\"github.com/fabric8-analytics\")\n                          .name(\"cli-tools\")\n                          .version(\"v0.2.6-0.20211007133944-2af417bfb988\")\n                          .pkgManager(Constants.NPM_PKG_MANAGER)\n                          .build()));\n              consumer.accept(\n                  arguments(\n                      t,\n                      Constants.NPM_PKG_MANAGER,\n                      2,\n                      3,\n                      PackageRef.builder()\n                          .name(\"fabric8-analytics-lsp-server\")\n                          .version(\"0.0.0-development\")\n                          .pkgManager(Constants.NPM_PKG_MANAGER)\n                          .build()));\n              consumer.accept(arguments(t, Constants.PYPI_PKG_MANAGER, 2, 0, DEFAULT_MAVEN_ROOT));\n            });\n  }\n\n  private String getFolder(String mediaType) {\n    switch (mediaType) {\n      case CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON:\n        return \"cyclonedx\";\n      case Constants.SPDX_MEDIATYPE_JSON:\n        return \"spdx\";\n      default:\n        fail(\"Not implemented: \" + mediaType);\n    }\n    return null;\n  }\n}\n", "public class SbomParserTest {\n\n  private static final Collection<String> MEDIA_TYPES =\n      List.of(Constants.SPDX_MEDIATYPE_JSON, CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON);\n  private static final PackageRef DEFAULT_MAVEN_ROOT =\n      DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER);\n  private static final PackageRef EXPECTED_ROOT =\n      PackageRef.builder()\n          .namespace(\"org.acme.dbaas\")\n          .name(\"postgresql-orm-quarkus\")\n          .version(\"1.0.0-SNAPSHOT\")\n          .pkgManager(Constants.MAVEN_PKG_MANAGER)\n          .build();\n\n  @Test\n  void testInvalidContentType() {\n    ClientErrorException ex =\n        assertThrows(\n            ClientErrorException.class, () -> SbomParserFactory.newInstance(MediaType.TEXT_PLAIN));\n    assertEquals(\"Unsupported Content-Type header: \" + MediaType.TEXT_PLAIN, ex.getMessage());\n    assertEquals(\n        Response.Status.UNSUPPORTED_MEDIA_TYPE.getStatusCode(), ex.getResponse().getStatus());\n  }\n\n  @Test\n  void testCycloneDxContentType() {\n    SbomParser parser =\n        SbomParserFactory.newInstance(CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON);\n    assertNotNull(parser);\n    assertTrue(parser instanceof CycloneDxParser);\n  }\n\n  @Test\n  void testSpdxContentType() {\n    SbomParser parser = SbomParserFactory.newInstance(Constants.SPDX_MEDIATYPE_JSON);\n    assertNotNull(parser);\n    assertTrue(parser instanceof SpdxParser);\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testParseEmptySBOM(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/empty-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(0, tree.dependencies().size());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testSBOMWithoutDependencies(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/no-deps-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(0, tree.dependencies().size());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testParseInvalidSBOM(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    InputStream file = getClass().getClassLoader().getResourceAsStream(\"invalid_deps_file.txt\");\n    ClientErrorException ex =\n        assertThrows(ClientErrorException.class, () -> parser.buildTree(file));\n    assertNotNull(ex);\n    assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), ex.getResponse().getStatus());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getMediaTypes\")\n  void testMinimalSbom(String mediaType) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/minimal-sbom.json\", getFolder(mediaType));\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(2, tree.dependencies().size());\n    assertEquals(7, tree.transitiveCount());\n    assertEquals(EXPECTED_ROOT, tree.root());\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"getSbomUseCases\")\n  void testSbom(String mediaType, String pkgManager, int direct, int transitive, PackageRef root) {\n    SbomParser parser = SbomParserFactory.newInstance(mediaType);\n    String fileName = String.format(\"%s/%s-sbom.json\", getFolder(mediaType), pkgManager);\n    InputStream file = getClass().getClassLoader().getResourceAsStream(fileName);\n\n    DependencyTree tree = parser.buildTree(file);\n    assertEquals(direct, tree.dependencies().size());\n    assertEquals(transitive, tree.transitiveCount());\n    assertEquals(root, tree.root());\n  }\n\n  static Stream<String> getMediaTypes() {\n    return MEDIA_TYPES.stream();\n  }\n\n  static Stream<Arguments> getSbomUseCases() {\n    return getMediaTypes()\n        .mapMulti(\n            (t, consumer) -> {\n              consumer.accept(arguments(t, Constants.MAVEN_PKG_MANAGER, 2, 7, EXPECTED_ROOT));\n              consumer.accept(\n                  arguments(\n                      t,\n                      Constants.GOLANG_PKG_MANAGER,\n                      2,\n                      3,\n                      PackageRef.builder()\n                          .namespace(\"github.com/fabric8-analytics\")\n                          .name(\"cli-tools\")\n                          .version(\"v0.2.6-0.20211007133944-2af417bfb988\")\n                          .pkgManager(Constants.NPM_PKG_MANAGER)\n                          .build()));\n              consumer.accept(\n                  arguments(\n                      t,\n                      Constants.NPM_PKG_MANAGER,\n                      2,\n                      3,\n                      PackageRef.builder()\n                          .name(\"fabric8-analytics-lsp-server\")\n                          .version(\"0.0.0-development\")\n                          .pkgManager(Constants.NPM_PKG_MANAGER)\n                          .build()));\n              consumer.accept(arguments(t, Constants.PYPI_PKG_MANAGER, 2, 0, DEFAULT_MAVEN_ROOT));\n            });\n  }\n\n  private String getFolder(String mediaType) {\n    switch (mediaType) {\n      case CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON:\n        return \"cyclonedx\";\n      case Constants.SPDX_MEDIATYPE_JSON:\n        return \"spdx\";\n      default:\n        fail(\"Not implemented: \" + mediaType);\n    }\n    return null;\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/model/CvssParserTest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.redhat.exhort.api.CvssVector;\n\npublic class CvssParserTest {\n\n  private static final String[] INPUTS = {\n    \"CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H\",\n    \"CVSS:3.1/AV:A/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:L/E:U/RL:U/RC:R\"\n  };\n\n  private static final CvssVector[] EXPECTATIONS = {\n    new CvssVector()\n        .attackVector(\"Network\")\n        .attackComplexity(\"High\")\n        .privilegesRequired(\"None\")\n        .userInteraction(\"None\")\n        .scope(\"Unchanged\")\n        .confidentialityImpact(\"None\")\n        .integrityImpact(\"None\")\n        .availabilityImpact(\"High\")\n        .cvss(INPUTS[0]),\n    new CvssVector()\n        .attackVector(\"Adjacent Network\")\n        .attackComplexity(\"High\")\n        .privilegesRequired(\"Low\")\n        .userInteraction(\"Required\")\n        .scope(\"Unchanged\")\n        .confidentialityImpact(\"High\")\n        .integrityImpact(\"Low\")\n        .availabilityImpact(\"Low\")\n        .exploitCodeMaturity(\"Unproven that exploit exists\")\n        .remediationLevel(\"Unavailable\")\n        .reportConfidence(\"Reasonable\")\n        .cvss(INPUTS[1])\n  };\n\n  @Test\n  void testVectors() {", "import com.redhat.exhort.api.CvssVector;\n\npublic class CvssParserTest {\n\n  private static final String[] INPUTS = {\n    \"CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H\",\n    \"CVSS:3.1/AV:A/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:L/E:U/RL:U/RC:R\"\n  };\n\n  private static final CvssVector[] EXPECTATIONS = {\n    new CvssVector()\n        .attackVector(\"Network\")\n        .attackComplexity(\"High\")\n        .privilegesRequired(\"None\")\n        .userInteraction(\"None\")\n        .scope(\"Unchanged\")\n        .confidentialityImpact(\"None\")\n        .integrityImpact(\"None\")\n        .availabilityImpact(\"High\")\n        .cvss(INPUTS[0]),\n    new CvssVector()\n        .attackVector(\"Adjacent Network\")\n        .attackComplexity(\"High\")\n        .privilegesRequired(\"Low\")\n        .userInteraction(\"Required\")\n        .scope(\"Unchanged\")\n        .confidentialityImpact(\"High\")\n        .integrityImpact(\"Low\")\n        .availabilityImpact(\"Low\")\n        .exploitCodeMaturity(\"Unproven that exploit exists\")\n        .remediationLevel(\"Unavailable\")\n        .reportConfidence(\"Reasonable\")\n        .cvss(INPUTS[1])\n  };\n\n  @Test\n  void testVectors() {", "    for (int i = 0; i < INPUTS.length; i++) {\n      assertEquals(EXPECTATIONS[i], CvssParser.fromVectorString(INPUTS[i]), \"Failed: \" + INPUTS[i]);\n    }\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/extensions/WiremockV3Extension.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.extensions;\n\nimport static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;\n\nimport java.util.Map;\n\nimport com.github.tomakehurst.wiremock.WireMockServer;\n", "import com.github.tomakehurst.wiremock.WireMockServer;\n\nimport io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n\npublic class WiremockV3Extension implements QuarkusTestResourceLifecycleManager {\n\n  public static final String SNYK_TOKEN = \"snyk-token-xyz\";\n\n  private final WireMockServer server = new WireMockServer(options().dynamicPort());\n\n  @Override\n  public Map<String, String> start() {\n    server.start();\n\n    return Map.of(\n        \"api.snyk.host\", server.baseUrl(),\n        \"api.snyk.token\", SNYK_TOKEN,\n        \"api.trustedContent.gav.host\", server.baseUrl(),\n        \"api.trustedContent.vex.host\", server.baseUrl(),\n        \"api.ossindex.host\", server.baseUrl());\n  }\n\n  @Override", "  public void stop() {\n    if (server != null) {\n      server.stop();\n    }\n  }\n\n  @Override\n  public void inject(TestInjector testInjector) {\n    testInjector.injectIntoFields(\n        server,\n        new TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n  }\n}\n"]}
{"filename": "src/test/java/com/redhat/exhort/extensions/InjectWireMock.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.extensions;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport io.quarkus.test.common.QuarkusTestResource;\n\n@QuarkusTestResource(WiremockV3Extension.class)", "\n@QuarkusTestResource(WiremockV3Extension.class)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InjectWireMock {}\n"]}
{"filename": "src/main/java/com/redhat/exhort/config/ObjectMapperProducer.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.config;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\n\npublic class ObjectMapperProducer {\n\n  public static ObjectMapper newInstance() {\n    return new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n  }\n}\n", "  public static ObjectMapper newInstance() {\n    return new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/config/CustomReflectionConfiguration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.config;\n\nimport org.apache.camel.http.base.HttpOperationFailedException;\nimport org.jboss.resteasy.reactive.common.jaxrs.ResponseImpl;\nimport org.spdx.storage.listedlicense.LicenseJsonTOC;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n", "import io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.WebApplicationException;\nimport jakarta.ws.rs.core.Response;\n\n@RegisterForReflection(\n    targets = {\n      HttpOperationFailedException.class,\n      WebApplicationException.class,", "      HttpOperationFailedException.class,\n      WebApplicationException.class,\n      ClientErrorException.class,\n      Response.class,\n      ResponseImpl.class,\n      LicenseJsonTOC.class\n    })\npublic class CustomReflectionConfiguration {}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/Constants.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n", "import io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.ws.rs.core.MediaType;\n\n@RegisterForReflection\npublic final class Constants {\n\n  private Constants() {}\n\n  public static final String PROVIDERS_PARAM = \"providers\";\n", "  public static final String PROVIDERS_PARAM = \"providers\";\n\n  public static final String ACCEPT_HEADER = \"Accept\";\n  public static final String ACCEPT_ENCODING_HEADER = \"Accept-Encoding\";\n  public static final String SNYK_TOKEN_HEADER = \"ex-snyk-token\";\n  public static final String OSS_INDEX_USER_HEADER = \"ex-oss-index-user\";\n  public static final String OSS_INDEX_TOKEN_HEADER = \"ex-oss-index-token\";\n  public static final String VERBOSE_MODE_HEADER = \"verbose\";\n\n  public static final MediaType MULTIPART_MIXED_TYPE = new MediaType(\"multipart\", \"mixed\");\n  public static final String MULTIPART_MIXED = MULTIPART_MIXED_TYPE.toString();", "  public static final MediaType MULTIPART_MIXED_TYPE = new MediaType(\"multipart\", \"mixed\");\n  public static final String MULTIPART_MIXED = MULTIPART_MIXED_TYPE.toString();\n  public static final String SPDX_MEDIATYPE_JSON = \"application/vnd.spdx+json\";\n\n  public static final String SNYK_PROVIDER = \"snyk\";\n  public static final String OSS_INDEX_PROVIDER = \"oss-index\";\n\n  public static final String TRUSTED_CONTENT_NAME = \"trusted-content\";\n\n  public static final String MAVEN_PKG_MANAGER = \"maven\";\n  public static final String NPM_PKG_MANAGER = \"npm\";", "  public static final String MAVEN_PKG_MANAGER = \"maven\";\n  public static final String NPM_PKG_MANAGER = \"npm\";\n  public static final String PYPI_PKG_MANAGER = \"pypi\";\n  public static final String GOLANG_PKG_MANAGER = \"golang\";\n\n  public static final String PKG_MANAGER_PROPERTY = \"pkgManager\";\n  public static final String REQUEST_CONTENT_PROPERTY = \"requestContent\";\n  public static final String REPORT_PROPERTY = \"report\";\n  public static final String DEPENDENCY_TREE_PROPERTY = \"dependencyTree\";\n  public static final String PROVIDER_PRIVATE_DATA_PROPERTY = \"providerPrivateData\";\n  public static final String RESPONSE_STATUS_PROPERTY = \"responseStatus\";\n", "  public static final String DEPENDENCY_TREE_PROPERTY = \"dependencyTree\";\n  public static final String PROVIDER_PRIVATE_DATA_PROPERTY = \"providerPrivateData\";\n  public static final String RESPONSE_STATUS_PROPERTY = \"responseStatus\";\n\n  public static final String SNYK_DEP_GRAPH_API_PATH = \"/test/dep-graph\";\n  public static final String SNYK_TOKEN_API_PATH = \"/user/me\";\n  public static final String OSS_INDEX_AUTH_COMPONENT_API_PATH = \"/authorized/component-report\";\n  public static final String TRUSTED_CONTENT_PATH = \"/api/policy/v1alpha1/trusted::gav\";\n  public static final String TRUSTED_CONTENT_VEX_PATH = \"/tc\";\n\n  public static final String DEFAULT_ACCEPT_MEDIA_TYPE = MediaType.APPLICATION_JSON;", "  public static final String TRUSTED_CONTENT_VEX_PATH = \"/tc\";\n\n  public static final String DEFAULT_ACCEPT_MEDIA_TYPE = MediaType.APPLICATION_JSON;\n  public static final boolean DEFAULT_VERBOSE_MODE = false;\n\n  public static final List<String> PKG_MANAGERS =\n      Collections.unmodifiableList(\n          new ArrayList<>() {\n            {\n              add(MAVEN_PKG_MANAGER);\n              add(NPM_PKG_MANAGER);\n              add(PYPI_PKG_MANAGER);\n              add(GOLANG_PKG_MANAGER);\n            }\n          });\n", "  public static final List<String> PROVIDERS =\n      Collections.unmodifiableList(\n          new ArrayList<>() {\n            {\n              add(SNYK_PROVIDER);\n              add(OSS_INDEX_PROVIDER);\n            }\n          });\n\n  public static final List<MediaType> VALID_RESPONSE_MEDIA_TYPES =\n      Collections.unmodifiableList(\n          new ArrayList<>() {\n            {\n              add(MediaType.APPLICATION_JSON_TYPE);\n              add(MediaType.TEXT_HTML_TYPE);\n              add(MULTIPART_MIXED_TYPE);\n            }\n          });\n}\n", "  public static final List<MediaType> VALID_RESPONSE_MEDIA_TYPES =\n      Collections.unmodifiableList(\n          new ArrayList<>() {\n            {\n              add(MediaType.APPLICATION_JSON_TYPE);\n              add(MediaType.TEXT_HTML_TYPE);\n              add(MULTIPART_MIXED_TYPE);\n            }\n          });\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/report/ReportIntegration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.report;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;\n\nimport com.redhat.exhort.integration.Constants;\n\nimport jakarta.enterprise.context.ApplicationScoped;", "\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.core.MediaType;\n\n@ApplicationScoped\npublic class ReportIntegration extends EndpointRouteBuilder {\n\n  @Inject ReportTemplate reportTemplate;\n\n  @Override", "  public void configure() {\n    // fmt:off\n        from(direct(\"report\"))\n            .routeId(\"report\")\n            .choice()\n                .when(exchangeProperty(Constants.REQUEST_CONTENT_PROPERTY).isEqualTo(MediaType.TEXT_HTML))\n                    .to(direct(\"htmlReport\"))\n                .when(exchangeProperty(Constants.REQUEST_CONTENT_PROPERTY).isEqualTo(Constants.MULTIPART_MIXED))\n                    .to(direct(\"multipartReport\"))\n                .otherwise()\n                    .to(direct(\"jsonReport\"))\n            .end();\n\n        from(direct(\"htmlReport\"))\n            .routeId(\"htmlReport\")\n            .setHeader(Exchange.CONTENT_TYPE, constant(MediaType.TEXT_HTML))\n            .setProperty(Constants.REPORT_PROPERTY, body())\n            .setBody(method(reportTemplate, \"setVariables\"))\n            .to(freemarker(\"report.ftl\"));\n\n        from(direct(\"multipartReport\"))\n            .routeId(\"multipartReport\")\n            .to(direct(\"htmlReport\"))\n            .bean(ReportTransformer.class, \"attachHtmlReport\")\n            .setBody(exchangeProperty(Constants.REPORT_PROPERTY))\n            .bean(ReportTransformer.class, \"filterVerboseResult\")\n            .marshal().json()\n            .marshal().mimeMultipart(false, false, true)\n            .setHeader(Exchange.CONTENT_TYPE, constant(MediaType.TEXT_HTML));\n\n        from(direct(\"jsonReport\"))\n            .routeId(\"jsonReport\")\n            .bean(ReportTransformer.class, \"filterVerboseResult\")\n            .marshal().json();\n        //fmt:on\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/report/DependencyReportHelper.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.report;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.Issue;", "import com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.Remediation;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic final class DependencyReportHelper {\n\n  public int transitiveIssuesCount(DependencyReport report) {\n    return report.getTransitive().stream().mapToInt(t -> t.getIssues().size()).sum();\n  }\n", "public final class DependencyReportHelper {\n\n  public int transitiveIssuesCount(DependencyReport report) {\n    return report.getTransitive().stream().mapToInt(t -> t.getIssues().size()).sum();\n  }\n\n  public boolean hasRemediation(DependencyReport report) {\n    if (!report.getRemediations().isEmpty()) {\n      return true;\n    }\n    return report.getTransitive() != null\n        && report.getTransitive().stream().anyMatch(t -> !t.getRemediations().isEmpty());\n  }\n", "  public int transitiveRemediationCount(DependencyReport report) {\n    return report.getTransitive().stream().mapToInt(t -> t.getRemediations().size()).sum();\n  }\n\n  public PackageRef findRemediationByIssue(DependencyReport report, Issue issue) {\n    if (issue.getCves() == null || issue.getCves().isEmpty()) {\n      return null;\n    }\n    List<Remediation> result = new ArrayList<>();\n    issue.getCves().stream()\n        .map(cve -> report.getRemediations().get(cve))\n        .filter(Objects::nonNull)\n        .forEach(result::add);\n", "    if (result.isEmpty()) {\n      return null;\n    }\n    // Assuming there's only one CVE by issue\n    return result.get(0).getMavenPackage();\n  }\n\n  public PackageRef findTransitiveRemediationByIssue(DependencyReport report, Issue issue) {\n    if (issue.getCves() == null || issue.getCves().isEmpty()) {\n      return null;\n    }\n    List<Remediation> result = new ArrayList<>();\n    issue.getCves().stream()\n        .forEach(\n            cve ->\n                report.getTransitive().stream()\n                    .map(t -> t.getRemediations().get(cve))\n                    .filter(Objects::nonNull)\n                    .forEach(result::add));\n", "    if (issue.getCves() == null || issue.getCves().isEmpty()) {\n      return null;\n    }\n    List<Remediation> result = new ArrayList<>();\n    issue.getCves().stream()\n        .forEach(\n            cve ->\n                report.getTransitive().stream()\n                    .map(t -> t.getRemediations().get(cve))\n                    .filter(Objects::nonNull)\n                    .forEach(result::add));\n", "    if (result.isEmpty()) {\n      return null;\n    }\n    // Assuming there's only one CVE by issue\n    return result.get(0).getMavenPackage();\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/report/ReportTemplate.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.report;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.camel.Body;", "\nimport org.apache.camel.Body;\nimport org.apache.camel.ExchangeProperty;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.integration.Constants;", "import com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.integration.Constants;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@RegisterForReflection\n@ApplicationScoped\npublic class ReportTemplate {\n\n  @ConfigProperty(name = \"report.trustedContent.link\")\n  String remediationPath;\n\n  @ConfigProperty(name = \"report.snyk.link\")\n  String packagePath;\n\n  @ConfigProperty(name = \"report.snyk.issue.regex\")\n  String snykIssuePathRegex;\n\n  @ConfigProperty(name = \"report.vex.link\")\n  String vexPath;\n\n  @ConfigProperty(name = \"report.sbom.link\")\n  String sbomPath;\n\n  @ConfigProperty(name = \"report.snyk.signup.link\")\n  String snykSignup;\n\n  @ConfigProperty(name = \"report.ossindex.issue.regex\")\n  String ossIssuePathRegex;\n\n  public Map<String, Object> setVariables(\n      @Body AnalysisReport report,\n      @ExchangeProperty(Constants.PROVIDER_PRIVATE_DATA_PROPERTY) List<String> providerPrivateData)\n      throws JsonMappingException, JsonProcessingException, IOException {\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(\"report\", report);\n    params.put(\"remediationPath\", remediationPath);\n    params.put(\"packagePath\", packagePath);\n    params.put(\"snykIssueLinkFormatter\", new IssueLinkFormatter(snykIssuePathRegex));\n    params.put(\"ossIndexIssueLinkFormatter\", new IssueLinkFormatter(ossIssuePathRegex));\n    params.put(\"issueVisibilityHelper\", new IssueVisibilityHelper(providerPrivateData));\n    params.put(\"vexPath\", vexPath);\n    params.put(\"sbomPath\", sbomPath);\n    params.put(\"snykSignup\", snykSignup);\n    params.put(\"dependencyHelper\", new DependencyReportHelper());\n\n    return params;\n  }\n\n  @RegisterForReflection", "@ApplicationScoped\npublic class ReportTemplate {\n\n  @ConfigProperty(name = \"report.trustedContent.link\")\n  String remediationPath;\n\n  @ConfigProperty(name = \"report.snyk.link\")\n  String packagePath;\n\n  @ConfigProperty(name = \"report.snyk.issue.regex\")\n  String snykIssuePathRegex;\n\n  @ConfigProperty(name = \"report.vex.link\")\n  String vexPath;\n\n  @ConfigProperty(name = \"report.sbom.link\")\n  String sbomPath;\n\n  @ConfigProperty(name = \"report.snyk.signup.link\")\n  String snykSignup;\n\n  @ConfigProperty(name = \"report.ossindex.issue.regex\")\n  String ossIssuePathRegex;\n\n  public Map<String, Object> setVariables(\n      @Body AnalysisReport report,\n      @ExchangeProperty(Constants.PROVIDER_PRIVATE_DATA_PROPERTY) List<String> providerPrivateData)\n      throws JsonMappingException, JsonProcessingException, IOException {\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(\"report\", report);\n    params.put(\"remediationPath\", remediationPath);\n    params.put(\"packagePath\", packagePath);\n    params.put(\"snykIssueLinkFormatter\", new IssueLinkFormatter(snykIssuePathRegex));\n    params.put(\"ossIndexIssueLinkFormatter\", new IssueLinkFormatter(ossIssuePathRegex));\n    params.put(\"issueVisibilityHelper\", new IssueVisibilityHelper(providerPrivateData));\n    params.put(\"vexPath\", vexPath);\n    params.put(\"sbomPath\", sbomPath);\n    params.put(\"snykSignup\", snykSignup);\n    params.put(\"dependencyHelper\", new DependencyReportHelper());\n\n    return params;\n  }\n\n  @RegisterForReflection", "  public static record IssueLinkFormatter(String issuePathRegex) {\n\n    public String format(String id) {\n      return String.format(issuePathRegex, id, id);\n    }\n  }\n\n  @RegisterForReflection\n  public static record IssueVisibilityHelper(List<String> providerData) {\n    public boolean showIssue(String provider, Issue issue) {\n      if (!issue.getUnique() || providerData == null) {\n        return true;\n      }\n      return !providerData.contains(provider);\n    }\n  }\n}\n", "  public static record IssueVisibilityHelper(List<String> providerData) {\n    public boolean showIssue(String provider, Issue issue) {\n      if (!issue.getUnique() || providerData == null) {\n        return true;\n      }\n      return !providerData.contains(provider);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/report/ReportTransformer.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.report;\n\nimport java.util.Collections;\n\nimport org.apache.camel.Body;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.ExchangeProperty;\nimport org.apache.camel.attachment.AttachmentMessage;", "import org.apache.camel.ExchangeProperty;\nimport org.apache.camel.attachment.AttachmentMessage;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.integration.Constants;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.activation.DataHandler;\nimport jakarta.ws.rs.core.MediaType;", "import jakarta.activation.DataHandler;\nimport jakarta.ws.rs.core.MediaType;\n\n@RegisterForReflection\npublic class ReportTransformer {\n\n  public AnalysisReport filterVerboseResult(\n      @Body AnalysisReport report,\n      @ExchangeProperty(Constants.VERBOSE_MODE_HEADER) Boolean verbose) {\n    if (Boolean.FALSE.equals(verbose)) {\n      report.values().forEach(r -> r.dependencies(Collections.emptyList()));\n    }\n    return report;\n  }\n", "    if (Boolean.FALSE.equals(verbose)) {\n      report.values().forEach(r -> r.dependencies(Collections.emptyList()));\n    }\n    return report;\n  }\n\n  public void attachHtmlReport(Exchange exchange) {\n    exchange\n        .getIn(AttachmentMessage.class)\n        .addAttachment(\n            \"report.html\",\n            new DataHandler(exchange.getIn().getBody(String.class), MediaType.TEXT_HTML));\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/ExhortIntegration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend;\n\nimport static com.redhat.exhort.integration.Constants.DEPENDENCY_TREE_PROPERTY;\nimport static com.redhat.exhort.integration.Constants.PROVIDERS_PARAM;\nimport static com.redhat.exhort.integration.Constants.REQUEST_CONTENT_PROPERTY;\n\nimport java.io.InputStream;\nimport java.util.List;", "import java.io.InputStream;\nimport java.util.List;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Message;\nimport org.apache.camel.builder.AggregationStrategies;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;\nimport org.apache.camel.component.micrometer.MicrometerConstants;\nimport org.apache.camel.component.micrometer.routepolicy.MicrometerRoutePolicyFactory;\n", "import org.apache.camel.component.micrometer.routepolicy.MicrometerRoutePolicyFactory;\n\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.sbom.SbomParser;\nimport com.redhat.exhort.integration.backend.sbom.SbomParserFactory;\nimport com.redhat.exhort.integration.providers.ProviderAggregationStrategy;\nimport com.redhat.exhort.integration.providers.VulnerabilityProvider;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.GraphRequest;\n", "import com.redhat.exhort.model.GraphRequest;\n\nimport io.micrometer.core.instrument.MeterRegistry;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.mail.internet.ContentType;\nimport jakarta.mail.internet.ParseException;\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.MediaType;", "import jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\n\n@ApplicationScoped\npublic class ExhortIntegration extends EndpointRouteBuilder {\n\n  private final MeterRegistry registry;\n\n  @Inject VulnerabilityProvider vulnerabilityProvider;\n\n  ExhortIntegration(MeterRegistry registry) {\n    this.registry = registry;\n  }\n\n  @Override", "  public void configure() {\n    // fmt:off\n    getContext().getRegistry().bind(MicrometerConstants.METRICS_REGISTRY_NAME, registry);\n    getContext().addRoutePolicyFactory(new MicrometerRoutePolicyFactory());\n    \n    restConfiguration().contextPath(\"/api/v3/\")\n        .clientRequestValidation(true);\n\n    onException(IllegalArgumentException.class)\n        .routeId(\"onExhortIllegalArgumentException\")\n        .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(422))\n        .setHeader(Exchange.CONTENT_TYPE, constant(MediaType.TEXT_PLAIN))\n        .handled(true)\n        .setBody().simple(\"${exception.message}\");\n\n    onException(ClientErrorException.class)\n        .routeId(\"onExhortClientErrorException\")\n        .setHeader(Exchange.HTTP_RESPONSE_CODE, simple(\"${exception.getResponse().getStatus()}\"))\n        .setHeader(Exchange.CONTENT_TYPE, constant(MediaType.TEXT_PLAIN))\n        .handled(true)\n        .setBody().simple(\"${exception.message}\");\n\n    rest()\n        .post(\"/analysis\")\n            .routeId(\"restAnalysis\")\n            .to(\"direct:analysis\")\n        .get(\"/token\")\n            .routeId(\"restTokenValidation\")\n            .to(\"direct:validateToken\")\n        .get(\"/test\").to(\"direct:testFreemarker\");\n\n    from(direct(\"analysis\"))\n      .routeId(\"analysis\")\n        .setProperty(PROVIDERS_PARAM, method(vulnerabilityProvider, \"getProvidersFromQueryParam\"))\n        .setProperty(REQUEST_CONTENT_PROPERTY, method(BackendUtils.class, \"getResponseMediaType\"))\n        .setProperty(Constants.VERBOSE_MODE_HEADER, header(Constants.VERBOSE_MODE_HEADER))\n        .process(this::processAnalysisRequest)\n        .setProperty(DEPENDENCY_TREE_PROPERTY, simple(\"${body.tree}\"))\n        .to(direct(\"findVulnerabilities\"))\n        .to(direct(\"findRemediations\"))\n        .to(direct(\"recommendTrustedContent\"))\n        .transform().method(BackendUtils.class, \"removeEmptyDependencies\")\n        .to(direct(\"report\"))\n        .process(this::cleanUpHeaders);\n\n    from(direct(\"findVulnerabilities\"))\n        .routeId(\"findVulnerabilities\")\n        .recipientList(method(vulnerabilityProvider, \"getProviderEndpoints\"))\n        .aggregationStrategy(AggregationStrategies.beanAllowNull(ProviderAggregationStrategy.class, \"aggregate\"))\n            .parallelProcessing();\n\n    from(direct(\"validateToken\"))\n        .routeId(\"validateToken\")\n        .choice()\n            .when(header(Constants.SNYK_TOKEN_HEADER).isNotNull())\n                .to(direct(\"snykValidateToken\"))\n            .when(header(Constants.OSS_INDEX_TOKEN_HEADER).isNotNull())\n                .to(direct(\"ossValidateCredentials\"))\n            .otherwise()\n                .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(Response.Status.BAD_REQUEST.getStatusCode()))\n                .setBody(constant(\"Missing authentication header\"))\n        .end()\n        .setHeader(Exchange.CONTENT_TYPE, constant(MediaType.TEXT_PLAIN))\n        .process(this::cleanUpHeaders);\n    //fmt:on\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void processAnalysisRequest(Exchange exchange) {\n    exchange.getIn().removeHeader(Constants.ACCEPT_HEADER);\n    exchange.getIn().removeHeader(Constants.ACCEPT_ENCODING_HEADER);\n\n    ContentType ct;", "    try {\n      ct = new ContentType(exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class));\n    } catch (ParseException e) {\n      throw new ClientErrorException(Response.Status.UNSUPPORTED_MEDIA_TYPE, e);\n    }\n    SbomParser parser = SbomParserFactory.newInstance(ct.getBaseType());\n    DependencyTree tree = parser.parse(exchange.getIn().getBody(InputStream.class));\n    List<String> providers = exchange.getProperty(PROVIDERS_PARAM, List.class);\n    exchange\n        .getIn()\n        .setBody(\n            new GraphRequest.Builder(tree.root().purl().getType(), providers).tree(tree).build());\n  }\n\n  private void cleanUpHeaders(Exchange exchange) {\n    Message msg = exchange.getIn();\n    msg.removeHeader(Constants.VERBOSE_MODE_HEADER);\n    msg.removeHeaders(\"ex-.*-user\");\n    msg.removeHeaders(\"ex-.*-token\");\n    msg.removeHeader(\"Authorization\");\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/BackendUtils.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport org.apache.camel.Body;", "\nimport org.apache.camel.Body;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Header;\nimport org.apache.camel.http.base.HttpOperationFailedException;\nimport org.jboss.resteasy.reactive.common.util.MediaTypeHelper;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependenciesSummary;", "import com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependenciesSummary;\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.ProviderStatus;\nimport com.redhat.exhort.api.Summary;\nimport com.redhat.exhort.api.VulnerabilitiesSummary;\nimport com.redhat.exhort.integration.Constants;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n", "import io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.Response.Status;\n\n@RegisterForReflection\npublic class BackendUtils {\n\n  public String getResponseMediaType(@Header(Constants.ACCEPT_HEADER) String acceptHeader) {", "public class BackendUtils {\n\n  public String getResponseMediaType(@Header(Constants.ACCEPT_HEADER) String acceptHeader) {\n    if (acceptHeader == null || acceptHeader.isBlank()) {\n      return Constants.DEFAULT_ACCEPT_MEDIA_TYPE;\n    }\n    List<MediaType> requested = MediaTypeHelper.parseHeader(acceptHeader);\n    MediaType match = MediaTypeHelper.getBestMatch(Constants.VALID_RESPONSE_MEDIA_TYPES, requested);\n    if (match == null) {\n      throw new ClientErrorException(\n          \"Unexpected Accept header \"\n              + acceptHeader\n              + \". Supported content types are: \"\n              + Constants.VALID_RESPONSE_MEDIA_TYPES,\n          Status.UNSUPPORTED_MEDIA_TYPE);\n    }\n    return match.toString();\n  }\n", "    if (match == null) {\n      throw new ClientErrorException(\n          \"Unexpected Accept header \"\n              + acceptHeader\n              + \". Supported content types are: \"\n              + Constants.VALID_RESPONSE_MEDIA_TYPES,\n          Status.UNSUPPORTED_MEDIA_TYPE);\n    }\n    return match.toString();\n  }\n", "  public static void processResponseError(Exchange exchange, String provider) {\n    ProviderStatus status = new ProviderStatus().ok(false).name(provider);\n    Exception exception = (Exception) exchange.getProperty(Exchange.EXCEPTION_CAUGHT);\n    Throwable cause = exception.getCause();\n\n    if (cause != null) {\n      if (cause instanceof HttpOperationFailedException) {\n        HttpOperationFailedException httpException = (HttpOperationFailedException) cause;\n        status.message(prettifyHttpError(httpException)).code(httpException.getStatusCode());\n\n      } else {\n        status\n            .message(cause.getMessage())\n            .code(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());\n      }\n    } else {\n      status\n          .message(exception.getMessage())\n          .code(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());\n    }\n    exchange.getMessage().setBody(newEmptyReportValue(status));\n  }\n", "  public static void processTokenFallBack(Exchange exchange, String provider) {\n    Exception exception = (Exception) exchange.getProperty(Exchange.EXCEPTION_CAUGHT);\n    Throwable cause = exception.getCause();\n    String body;\n    int code = Response.Status.INTERNAL_SERVER_ERROR.getStatusCode();\n\n    if (cause instanceof HttpOperationFailedException) {\n      HttpOperationFailedException httpException = (HttpOperationFailedException) cause;\n      code = httpException.getStatusCode();\n      if (code == Response.Status.UNAUTHORIZED.getStatusCode()) {\n        body = \"Invalid token provided. Unauthorized\";\n      } else {\n        body = \"Unable to validate \" + provider + \" Token: \" + httpException.getStatusText();\n      }\n    } else {\n      body = \"Unable to validate \" + provider + \" Token: \" + cause.getMessage();\n    }\n    exchange.getMessage().setHeader(Exchange.HTTP_RESPONSE_CODE, code);\n    exchange.getMessage().setBody(body);\n  }\n", "      if (code == Response.Status.UNAUTHORIZED.getStatusCode()) {\n        body = \"Invalid token provided. Unauthorized\";\n      } else {\n        body = \"Unable to validate \" + provider + \" Token: \" + httpException.getStatusText();\n      }\n    } else {\n      body = \"Unable to validate \" + provider + \" Token: \" + cause.getMessage();\n    }\n    exchange.getMessage().setHeader(Exchange.HTTP_RESPONSE_CODE, code);\n    exchange.getMessage().setBody(body);\n  }\n", "  public static AnalysisReport removeEmptyDependencies(@Body AnalysisReport reports) {\n    AnalysisReport result = new AnalysisReport();\n    reports\n        .entrySet()\n        .forEach(\n            entry -> {\n              ProviderStatus status = entry.getValue().getStatus();\n              if (entry.getValue().getDependencies() == null) {\n                entry.getValue().dependencies(Collections.emptyList());\n              }\n              List<DependencyReport> filteredDeps =\n                  entry.getValue().getDependencies().stream()\n                      .map(BackendUtils::removeEmptyTransitive)\n                      .filter(Predicate.not(BackendUtils::filterDependency))\n                      .collect(Collectors.toList());\n              result.put(\n                  entry.getKey(),\n                  new AnalysisReportValue()\n                      .status(status)\n                      .summary(entry.getValue().getSummary())\n                      .dependencies(filteredDeps));\n            });\n    return result;\n  }\n\n  private static String prettifyHttpError(HttpOperationFailedException httpException) {\n    String text = httpException.getStatusText();\n    switch (httpException.getStatusCode()) {\n      case 401:\n        return text + \": Verify the provided credentials are valid.\";\n      case 403:\n        return text + \": The provided credentials don't have the required permissions.\";\n      case 429:\n        return text + \": The rate limit has been exceeded.\";\n      default:\n        return text;\n    }\n  }\n\n  private static boolean filterDependency(DependencyReport report) {", "    if (report.getRecommendation() != null) {\n      return false;\n    }\n    if (report.getHighestVulnerability() == null) {\n      return true;\n    }\n    boolean hasIssues = report.getIssues() != null && !report.getIssues().isEmpty();\n    boolean hasTransitiveIssues =\n        report.getTransitive() != null && !report.getTransitive().isEmpty();\n\n    return !hasIssues && !hasTransitiveIssues;\n  }\n\n  private static DependencyReport removeEmptyTransitive(DependencyReport report) {", "    if (report.getTransitive() == null) {\n      return report;\n    }\n    report.setTransitive(\n        report.getTransitive().stream()\n            .filter(t -> t.getIssues() != null && !t.getIssues().isEmpty())\n            .collect(Collectors.toList()));\n    return report;\n  }\n\n  private static AnalysisReportValue newEmptyReportValue(ProviderStatus status) {\n    return new AnalysisReportValue()\n        .status(status)\n        .dependencies(Collections.emptyList())\n        .summary(\n            new Summary()\n                .dependencies(new DependenciesSummary())\n                .vulnerabilities(new VulnerabilitiesSummary()));\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/SbomParser.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom;\n\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Predicate;\n", "import java.util.function.Predicate;\n\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.model.DependencyTree;\n\npublic abstract class SbomParser {\n\n  public DependencyTree parse(InputStream input) {\n    DependencyTree tree = buildTree(input);\n    validate(tree);\n    return tree;\n  }\n\n  protected abstract DependencyTree buildTree(InputStream input);\n\n  protected void validate(DependencyTree tree) {\n    PackageRef ref = tree.root();\n    Set<String> types = new HashSet<>();", "  public DependencyTree parse(InputStream input) {\n    DependencyTree tree = buildTree(input);\n    validate(tree);\n    return tree;\n  }\n\n  protected abstract DependencyTree buildTree(InputStream input);\n\n  protected void validate(DependencyTree tree) {\n    PackageRef ref = tree.root();\n    Set<String> types = new HashSet<>();", "    if (ref != null) {\n      types.add(ref.purl().getType());\n    }\n    tree.dependencies().values().stream().forEach(d -> types.add(d.ref().purl().getType()));\n    if (types.size() > 1) {\n      throw new IllegalArgumentException(\n          \"It is not supported to submit mixed Package Manager types. Found: \" + types);\n    }\n    List<String> invalidTypes =\n        types.stream().filter(Predicate.not(Constants.PKG_MANAGERS::contains)).toList();\n    if (!invalidTypes.isEmpty()) {\n      throw new IllegalArgumentException(\"Unsupported package types received: \" + invalidTypes);\n    }\n  }\n}\n", "    if (!invalidTypes.isEmpty()) {\n      throw new IllegalArgumentException(\"Unsupported package types received: \" + invalidTypes);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/SbomParserFactory.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom;\n\nimport org.cyclonedx.CycloneDxMediaType;\n\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.sbom.cyclonedx.CycloneDxParser;\nimport com.redhat.exhort.integration.backend.sbom.spdx.SpdxParser;\n", "import com.redhat.exhort.integration.backend.sbom.spdx.SpdxParser;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.Response;\n\npublic class SbomParserFactory {\n\n  public static final SbomParser newInstance(String mediaType) {\n    switch (mediaType) {\n      case CycloneDxMediaType.APPLICATION_CYCLONEDX_JSON:\n        return new CycloneDxParser();\n      case Constants.SPDX_MEDIATYPE_JSON:\n        return new SpdxParser();\n      default:\n        throw new ClientErrorException(\n            \"Unsupported Content-Type header: \" + mediaType,\n            Response.Status.UNSUPPORTED_MEDIA_TYPE);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/cyclonedx/CycloneDxParser.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom.cyclonedx;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport org.cyclonedx.model.Bom;\nimport org.cyclonedx.model.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.config.ObjectMapperProducer;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.sbom.SbomParser;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.DirectDependency;\n", "import com.redhat.exhort.model.DirectDependency;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.Response;\n\npublic class CycloneDxParser extends SbomParser {\n\n  private static final ObjectMapper mapper = ObjectMapperProducer.newInstance();\n  private static final Logger LOGGER = LoggerFactory.getLogger(CycloneDxParser.class);\n\n  @Override\n  protected DependencyTree buildTree(InputStream input) {", "    try {\n      DependencyTree.Builder treeBuilder = DependencyTree.builder();\n      Map<PackageRef, DirectDependency.Builder> direct = new HashMap<>();\n      String packageManager = Constants.MAVEN_PKG_MANAGER;\n\n      Bom bom = mapper.readValue(input, Bom.class);\n      Map<String, PackageRef> componentPurls = new HashMap<>();\n      if (bom.getComponents() != null) {\n        componentPurls.putAll(\n            bom.getComponents().stream()\n                .filter(c -> c.getBomRef() != null)\n                .collect(\n                    Collectors.toMap(\n                        Component::getBomRef,\n                        c -> PackageRef.builder().purl(c.getPurl()).build())));\n        List<String> types =\n            componentPurls.values().stream().map(v -> v.purl().getType()).distinct().toList();", "        if (!types.isEmpty()) {\n          packageManager = types.get(0);\n        }\n      }\n\n      Optional<Component> rootComponent = Optional.ofNullable(bom.getMetadata().getComponent());\n      if (rootComponent.isPresent()) {\n        treeBuilder.root(PackageRef.builder().purl(rootComponent.get().getPurl()).build());\n      } else { // rootless SBOM\n        treeBuilder.root(DependencyTree.getDefaultRoot(packageManager));\n      }\n\n      bom.getDependencies().stream()\n          .forEach(\n              d -> {", "                if (rootComponent.isEmpty()) {\n                  PackageRef ref = componentPurls.get(d.getRef());\n                  direct.put(ref, DirectDependency.builder().ref(ref));\n                } else if (d.getRef().equals(rootComponent.get().getBomRef())) {\n                  d.getDependencies()\n                      .forEach(\n                          rootDep -> {\n                            PackageRef ref = componentPurls.get(rootDep.getRef());\n                            direct.put(\n                                ref,\n                                DirectDependency.builder().ref(ref).transitive(new HashSet<>()));\n                          });", "                } else if (d.getDependencies() != null) {\n                  PackageRef source = componentPurls.get(d.getRef());\n                  DirectDependency.Builder directBuilder = direct.get(source);\n                  if (directBuilder == null) {\n                    direct.values().stream()\n                        .filter(v -> v.transitive.contains(source))\n                        .forEach(\n                            v ->\n                                d.getDependencies()\n                                    .forEach(\n                                        t -> {\n                                          PackageRef target = componentPurls.get(t.getRef());\n                                          v.transitive.add(target);\n                                        }));\n                  } else {\n                    d.getDependencies()\n                        .forEach(\n                            t -> {\n                              PackageRef target = componentPurls.get(t.getRef());\n                              directBuilder.transitive.add(target);\n                            });\n                  }\n                }\n              });\n      Map<PackageRef, DirectDependency> deps =\n          direct.entrySet().stream()\n              .map(e -> Map.entry(e.getKey(), e.getValue().build()))\n              .collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n      return treeBuilder.dependencies(deps).build();\n    } catch (IOException e) {\n      LOGGER.error(\"Unable to parse the CycloneDX SBOM file\", e);\n      throw new ClientErrorException(\n          \"Unable to parse received CycloneDX SBOM file\", Response.Status.BAD_REQUEST);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/spdx/SpdxParser.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom.spdx;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;", "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.spdx.jacksonstore.MultiFormatStore;\nimport org.spdx.jacksonstore.MultiFormatStore.Format;\nimport org.spdx.library.InvalidSPDXAnalysisException;\nimport org.spdx.library.model.Relationship;\nimport org.spdx.library.model.SpdxPackage;\nimport org.spdx.storage.simple.InMemSpdxStore;\n\nimport com.redhat.exhort.api.PackageRef;", "\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.sbom.SbomParser;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.DirectDependency;\n\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.core.Response;\n\npublic class SpdxParser extends SbomParser {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SpdxParser.class);\n\n  @Override\n  protected DependencyTree buildTree(InputStream input) {", "import jakarta.ws.rs.core.Response;\n\npublic class SpdxParser extends SbomParser {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SpdxParser.class);\n\n  @Override\n  protected DependencyTree buildTree(InputStream input) {\n    try {\n      MultiFormatStore inputStore = new MultiFormatStore(new InMemSpdxStore(), Format.JSON_PRETTY);\n      SpdxWrapper wrapper = new SpdxWrapper(inputStore, input);\n      PackageRef root = wrapper.getRootRef();\n      Map<PackageRef, DirectDependency> deps = buildDeps(wrapper);", "    try {\n      MultiFormatStore inputStore = new MultiFormatStore(new InMemSpdxStore(), Format.JSON_PRETTY);\n      SpdxWrapper wrapper = new SpdxWrapper(inputStore, input);\n      PackageRef root = wrapper.getRootRef();\n      Map<PackageRef, DirectDependency> deps = buildDeps(wrapper);\n      if (root == null) {\n        Optional<PackageRef> first = deps.keySet().stream().findFirst();\n        if (first.isEmpty()) {\n          root = DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER);\n        } else {\n          root = DependencyTree.getDefaultRoot(first.get().purl().getType());\n        }\n      }\n      DependencyTree tree = new DependencyTree(root, deps);\n      return tree;\n    } catch (SpdxProcessingException | InvalidSPDXAnalysisException | IOException e) {\n      LOGGER.error(\"Unable to parse the SPDX SBOM file\", e);\n      throw new ClientErrorException(\n          \"Unable to parse received SPDX SBOM file: \" + e.getMessage(),\n          Response.Status.BAD_REQUEST);\n    }\n  }\n\n  private Map<PackageRef, DirectDependency> buildDeps(SpdxWrapper wrapper) {\n    Collection<SpdxPackage> packages = wrapper.getPackages();\n    Map<String, Set<String>> links = new HashMap<>();\n    packages.stream()\n        .filter(Predicate.not(wrapper::hasRootName))\n        .forEach(\n            p -> {", "              try {\n                String id = p.getId();\n                Set<String> rels =\n                    p.getRelationships().stream()\n                        .map(this::getRelationshipId)\n                        .collect(Collectors.toSet());\n                links.put(id, rels);\n              } catch (InvalidSPDXAnalysisException e) {\n                throw new SpdxProcessingException(\"Unable to retrieve relationsips\", e);\n              }\n            });\n    Set<String> directDeps =\n        links.keySet().stream()\n            .filter(\n                k ->\n                    links.entrySet().stream()\n                        .filter(e -> !e.getKey().equals(k))\n                        .noneMatch(e -> e.getValue().contains(k)))\n            .collect(Collectors.toSet());\n    Map<String, Set<String>> flatDepTree = new HashMap<>();\n    directDeps.stream()\n        .forEach(\n            d -> {\n              flatDepTree.put(d, addAllTransitive(d, links));\n            });\n    Map<PackageRef, DirectDependency> deps = new HashMap<>();\n    flatDepTree.keySet().stream()\n        .map(wrapper::getPackageById)\n        .forEach(\n            p -> {\n              PackageRef ref = wrapper.toPackageRef(p);\n              Set<PackageRef> transitive =\n                  flatDepTree.get(p.getId()).stream()\n                      .map(wrapper::getPackageById)\n                      .map(wrapper::toPackageRef)\n                      .collect(Collectors.toSet());\n              DirectDependency dep =\n                  DirectDependency.builder().ref(ref).transitive(transitive).build();\n              deps.put(ref, dep);\n            });\n    return deps;\n  }\n\n  private Set<String> addAllTransitive(String depKey, Map<String, Set<String>> links) {\n    Set<String> deps = links.get(depKey);", "    if (deps == null) {\n      return Collections.emptySet();\n    }\n    Set<String> result = new HashSet<>(deps);\n    deps.stream()\n        .forEach(\n            d -> {\n              result.addAll(addAllTransitive(d, links));\n            });\n    return result;\n  }\n\n  private String getRelationshipId(Relationship r) {", "    try {\n      return r.getRelatedSpdxElement().get().getId();\n    } catch (InvalidSPDXAnalysisException e) {\n      throw new SpdxProcessingException(\"Unable to retrieve related Spdx element\", e);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/spdx/SpdxWrapper.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom.spdx;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;", "import java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport org.spdx.jacksonstore.MultiFormatStore;\nimport org.spdx.library.InvalidSPDXAnalysisException;\nimport org.spdx.library.SpdxConstants;\nimport org.spdx.library.Version;\nimport org.spdx.library.model.ExternalRef;\nimport org.spdx.library.model.SpdxDocument;\nimport org.spdx.library.model.SpdxPackage;", "import org.spdx.library.model.SpdxDocument;\nimport org.spdx.library.model.SpdxPackage;\nimport org.spdx.library.model.TypedValue;\n\nimport com.redhat.exhort.api.PackageRef;\n\npublic class SpdxWrapper {\n\n  private static final String SUPPORTED_VERSION = Version.TWO_POINT_THREE_VERSION;\n  private static final String PURL_REFERENCE = \"http://spdx.org/rdf/references/purl\";\n\n  private MultiFormatStore inputStore;\n  private SpdxDocument doc;\n  private String uri;\n  private SpdxPackage root;\n  private Collection<SpdxPackage> packages;\n\n  public SpdxWrapper(MultiFormatStore inputStore, InputStream input)\n      throws InvalidSPDXAnalysisException, IOException {\n    this.inputStore = inputStore;\n    this.inputStore.deSerialize(input, false);\n    this.uri = inputStore.getDocumentUris().get(0);\n    this.doc = new SpdxDocument(inputStore, uri, null, false);\n    List<String> verify = doc.verify(Version.TWO_POINT_THREE_VERSION);", "    if (!verify.isEmpty()) {\n      throw new SpdxProcessingException(\"Invalid \" + SUPPORTED_VERSION + \" document received\");\n    }\n    this.packages = parsePackages();\n    this.root = findRoot();\n  }\n\n  public PackageRef getRootRef() {\n    if (root != null) {\n      return toPackageRef(root);\n    }\n    return null;\n  }\n\n  private SpdxPackage findRoot() throws InvalidSPDXAnalysisException {", "    if (root != null) {\n      return toPackageRef(root);\n    }\n    return null;\n  }\n\n  private SpdxPackage findRoot() throws InvalidSPDXAnalysisException {\n    if (doc.getName().isEmpty()) {\n      return null;\n    }\n    return packages.stream().filter(p -> hasRootName(p)).findFirst().orElse(null);\n  }\n", "  public boolean hasRootName(SpdxPackage p) {\n    try {\n      return p.getName().isPresent() && p.getName().get().equals(doc.getName().get());\n    } catch (InvalidSPDXAnalysisException e) {\n      throw new SpdxProcessingException(\"Unable to retrieve name for package\", e);\n    }\n  }\n\n  public PackageRef toPackageRef(SpdxPackage spdxPackage) {\n    try {\n      Optional<ExternalRef> ref =\n          spdxPackage.getExternalRefs().stream()\n              .filter(\n                  r -> {", "  public PackageRef toPackageRef(SpdxPackage spdxPackage) {\n    try {\n      Optional<ExternalRef> ref =\n          spdxPackage.getExternalRefs().stream()\n              .filter(\n                  r -> {\n                    try {\n                      return PURL_REFERENCE.equals(r.getReferenceType().getIndividualURI());\n                    } catch (InvalidSPDXAnalysisException e) {\n                      throw new SpdxProcessingException(\"Unalbe to retrieve referenceType\", e);\n                    }\n                  })\n              .findFirst();", "      if (ref.isEmpty()) {\n        throw new SpdxProcessingException(\n            \"Missing Purl External Reference for Package: \" + spdxPackage.getName());\n      }\n      return new PackageRef(ref.get().getReferenceLocator());\n    } catch (InvalidSPDXAnalysisException e) {\n      throw new SpdxProcessingException(\"Unable to find PackageUrl from SpdxPackage\", e);\n    }\n  }\n\n  public Collection<SpdxPackage> getPackages() {\n    return this.packages;\n  }\n", "  public SpdxPackage getPackageById(String id) {\n    try {\n      return new SpdxPackage(inputStore, uri, id, null, false);\n    } catch (InvalidSPDXAnalysisException e) {\n      throw new SpdxProcessingException(\"Unable to create SpdxPackage for id: \" + id, e);\n    }\n  }\n\n  private Collection<SpdxPackage> parsePackages() throws InvalidSPDXAnalysisException {\n    return inputStore\n        .getAllItems(uri, SpdxConstants.CLASS_SPDX_PACKAGE)\n        .filter(p -> root == null || !p.getId().equals(root.getId()))\n        .map(TypedValue::getId)\n        .map(this::getPackageById)\n        .collect(Collectors.toList());\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/backend/sbom/spdx/SpdxProcessingException.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.backend.sbom.spdx;\n\npublic class SpdxProcessingException extends RuntimeException {\n\n  public SpdxProcessingException(String msg) {\n    super(msg);\n  }\n\n  public SpdxProcessingException(String msg, Throwable e) {\n    super(msg, e);\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/VulnerabilityProvider.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers;\n\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Predicate;", "import java.util.Map;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.ExchangeProperty;\nimport org.apache.camel.Headers;\nimport org.apache.camel.util.URISupport;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n", "import org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport com.redhat.exhort.integration.Constants;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.annotation.PostConstruct;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.ws.rs.ClientErrorException;\n", "import jakarta.ws.rs.ClientErrorException;\n\n@ApplicationScoped\n@RegisterForReflection\npublic class VulnerabilityProvider {\n\n  @ConfigProperty(name = \"api.snyk.disabled\", defaultValue = \"false\")\n  boolean snykDisabled;\n\n  @ConfigProperty(name = \"api.ossindex.disabled\", defaultValue = \"false\")\n  boolean ossIndexDisabled;\n\n  private List<String> providers;\n\n  @PostConstruct", "  public void initProviders() {\n    providers =\n        Collections.unmodifiableList(\n            Constants.PROVIDERS.stream()\n                .filter(p -> !(Constants.SNYK_PROVIDER.equals(p) && snykDisabled))\n                .filter(p -> !(Constants.OSS_INDEX_PROVIDER.equals(p) && ossIndexDisabled))\n                .toList());\n  }\n\n  public String get(@ExchangeProperty(Exchange.MULTICAST_INDEX) int index) {\n    return providers.get(index);\n  }\n\n  public List<String> getProviderEndpoints(\n      @ExchangeProperty(Constants.PROVIDERS_PARAM) List<String> providers) {\n    return providers.stream()\n        .map(\n            p -> {\n              switch (p) {\n                case Constants.SNYK_PROVIDER:\n                  return \"direct:snykDepGraph\";\n                case Constants.OSS_INDEX_PROVIDER:\n                  return \"direct:ossIndexScan\";\n                default:\n                  throw new IllegalArgumentException(\"Unexpected provider: \" + p);\n              }\n            })\n        .collect(Collectors.toList());\n  }\n\n  public List<String> getEnabled() {\n    return providers;\n  }\n\n  public List<String> getProvidersFromQueryParam(@Headers Map<String, String> headers)\n      throws URISyntaxException {\n    String query = headers.get(Exchange.HTTP_QUERY);\n    Map<String, Object> props = URISupport.parseQuery(query);\n    List<String> providers = getProviders(props);", "  public String get(@ExchangeProperty(Exchange.MULTICAST_INDEX) int index) {\n    return providers.get(index);\n  }\n\n  public List<String> getProviderEndpoints(\n      @ExchangeProperty(Constants.PROVIDERS_PARAM) List<String> providers) {\n    return providers.stream()\n        .map(\n            p -> {\n              switch (p) {\n                case Constants.SNYK_PROVIDER:\n                  return \"direct:snykDepGraph\";\n                case Constants.OSS_INDEX_PROVIDER:\n                  return \"direct:ossIndexScan\";\n                default:\n                  throw new IllegalArgumentException(\"Unexpected provider: \" + p);\n              }\n            })\n        .collect(Collectors.toList());\n  }\n\n  public List<String> getEnabled() {\n    return providers;\n  }\n\n  public List<String> getProvidersFromQueryParam(@Headers Map<String, String> headers)\n      throws URISyntaxException {\n    String query = headers.get(Exchange.HTTP_QUERY);\n    Map<String, Object> props = URISupport.parseQuery(query);\n    List<String> providers = getProviders(props);", "    if (providers == null || providers.isEmpty()) {\n      return getEnabled().stream().filter(p -> filterByAuthHeaders(p, headers)).toList();\n    }\n    List<String> missing =\n        providers.stream()\n            .filter(Predicate.not(p -> getEnabled().contains(p)))\n            .collect(Collectors.toList());\n    if (missing.isEmpty()) {\n      return providers;\n    }\n    throw new ClientErrorException(\"Unsupported providers: \" + missing, 422);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private List<String> getProviders(Map<String, Object> props) {\n    Object o = props.get(Constants.PROVIDERS_PARAM);", "    if (o == null) {\n      return null;\n    }\n    if (o instanceof String) {\n      return List.of((String) o);\n    }\n    if (o instanceof List) {\n      return (List<String>) o;\n    }\n    throw new ClientErrorException(\"Unsupported providers: \" + o, 422);\n  }\n\n  @SuppressWarnings(\"unchecked\")", "  public void addProviderPrivateData(Exchange exchange, String provider) {\n    List<String> current =\n        (List<String>) exchange.getProperty(Constants.PROVIDER_PRIVATE_DATA_PROPERTY);\n    if (current == null) {\n      current = List.of(provider);\n    } else {\n      current = new ArrayList<>(current);\n      current.add(provider);\n    }\n    exchange.setProperty(\n        Constants.PROVIDER_PRIVATE_DATA_PROPERTY, Collections.unmodifiableList(current));\n  }\n\n  private boolean filterByAuthHeaders(String provider, Map<String, String> headers) {", "    if (headers == null || headers.isEmpty()) {\n      return true;\n    }\n    switch (provider) {\n      case Constants.OSS_INDEX_PROVIDER:\n        return headers.containsKey(Constants.OSS_INDEX_USER_HEADER)\n            && headers.containsKey(Constants.OSS_INDEX_TOKEN_HEADER);\n    }\n    return true;\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/ProviderAggregationStrategy.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class ProviderAggregationStrategy {\n", "\n@RegisterForReflection\npublic class ProviderAggregationStrategy {\n\n  public AnalysisReport aggregate(AnalysisReport response, AnalysisReportValue reportValue) {\n\n    if (response == null) {\n      response = new AnalysisReport();\n    }\n    response.put(reportValue.getStatus().getName(), reportValue);\n    return response;\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/ProviderAggregator.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;", "import java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\nimport org.apache.camel.Body;\nimport org.apache.camel.ExchangeProperty;\n\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependenciesSummary;", "import com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependenciesSummary;\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.ProviderStatus;\nimport com.redhat.exhort.api.Summary;\nimport com.redhat.exhort.api.TransitiveDependencyReport;\nimport com.redhat.exhort.api.VulnerabilitiesSummary;\nimport com.redhat.exhort.integration.Constants;", "import com.redhat.exhort.api.VulnerabilitiesSummary;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.model.CvssScoreComparable.DependencyScoreComparator;\nimport com.redhat.exhort.model.CvssScoreComparable.TransitiveScoreComparator;\nimport com.redhat.exhort.model.DependencyTree;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\nimport jakarta.ws.rs.core.Response;\n", "import jakarta.ws.rs.core.Response;\n\n@RegisterForReflection\npublic abstract class ProviderAggregator {\n\n  protected abstract String getProviderName();\n\n  protected ProviderStatus defaultOkStatus(String provider) {\n    return new ProviderStatus()\n        .name(provider)\n        .ok(Boolean.TRUE)\n        .message(\"OK\")\n        .code(Response.Status.OK.getStatusCode());\n  }\n\n  protected DependencyReport toDependencyReport(PackageRef ref, List<Issue> issues) {\n    return new DependencyReport()\n        .ref(ref)\n        .issues(\n            issues.stream()\n                .sorted(Comparator.comparing(Issue::getCvssScore).reversed())\n                .collect(Collectors.toList()));\n  }\n", "  public AnalysisReportValue buildReport(\n      @Body Map<String, List<Issue>> issuesData,\n      @ExchangeProperty(Constants.DEPENDENCY_TREE_PROPERTY) DependencyTree tree) {\n    AnalysisReportValue report = new AnalysisReportValue();\n    DependenciesSummary deps =\n        new DependenciesSummary().scanned(tree.directCount()).transitive(tree.transitiveCount());\n    VulnerabilityCounter counter = new VulnerabilityCounter();\n    report.status(defaultOkStatus(getProviderName())).dependencies(new ArrayList<>());\n    tree.dependencies().entrySet().stream()\n        .forEach(\n            e -> {\n              String ref = e.getKey().name();\n              List<Issue> issues = issuesData.get(ref);\n              DependencyReport directReport = new DependencyReport().ref(e.getKey());", "              if (issues == null) {\n                issues = Collections.emptyList();\n              }\n              directReport.issues(\n                  issues.stream()\n                      .sorted(Comparator.comparing(Issue::getCvssScore).reversed())\n                      .collect(Collectors.toList()));\n              directReport.setHighestVulnerability(issues.stream().findFirst().orElse(null));\n              directReport\n                  .getIssues()\n                  .forEach(\n                      i -> {\n                        incrementCounter(i, counter);\n                        counter.direct.incrementAndGet();\n                      });\n\n              List<TransitiveDependencyReport> transitiveReports =\n                  e.getValue().transitive().stream()\n                      .map(\n                          t -> {\n                            List<Issue> transitiveIssues = Collections.emptyList();\n                            String tRef = t.name();", "                            if (issuesData.get(tRef) != null) {\n                              transitiveIssues =\n                                  issuesData.get(tRef).stream()\n                                      .sorted(Comparator.comparing(Issue::getCvssScore).reversed())\n                                      .collect(Collectors.toList());\n                              transitiveIssues.forEach(i -> incrementCounter(i, counter));\n                            }\n                            Optional<Issue> highestTransitive =\n                                transitiveIssues.stream().findFirst();\n                            if (highestTransitive.isPresent()) {\n                              if (directReport.getHighestVulnerability() == null\n                                  || directReport.getHighestVulnerability().getCvssScore()\n                                      < highestTransitive.get().getCvssScore()) {\n                                directReport.setHighestVulnerability(highestTransitive.get());\n                              }\n                            }\n                            return new TransitiveDependencyReport()\n                                .ref(t)\n                                .issues(transitiveIssues)\n                                .highestVulnerability(highestTransitive.orElse(null));\n                          })\n                      .collect(Collectors.toList());\n              transitiveReports.sort(new TransitiveScoreComparator());\n              directReport.setTransitive(transitiveReports);\n              report.addDependenciesItem(directReport);\n            });\n    report.dependencies(\n        report.getDependencies().stream()\n            .sorted(new DependencyScoreComparator())\n            .collect(Collectors.toList()));\n    return report.summary(new Summary().dependencies(deps).vulnerabilities(counter.getSummary()));\n  }\n\n  private void incrementCounter(Issue i, VulnerabilityCounter counter) {\n    switch (i.getSeverity()) {\n      case CRITICAL:\n        counter.critical.incrementAndGet();\n        break;\n      case HIGH:\n        counter.high.incrementAndGet();\n        break;\n      case MEDIUM:\n        counter.medium.incrementAndGet();\n        break;\n      case LOW:\n        counter.low.incrementAndGet();\n        break;\n    }\n    counter.total.incrementAndGet();\n  }\n\n  private static final record VulnerabilityCounter(\n      AtomicInteger total,\n      AtomicInteger direct,\n      AtomicInteger critical,\n      AtomicInteger high,\n      AtomicInteger medium,\n      AtomicInteger low) {\n\n    VulnerabilityCounter() {\n      this(\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger());\n    }\n\n    VulnerabilitiesSummary getSummary() {\n      return new VulnerabilitiesSummary()\n          .total(total.get())\n          .direct(direct.get())\n          .critical(critical.get())\n          .high(high.get())\n          .medium(medium.get())\n          .low(low.get());\n    }\n  }\n}\n", "                            if (highestTransitive.isPresent()) {\n                              if (directReport.getHighestVulnerability() == null\n                                  || directReport.getHighestVulnerability().getCvssScore()\n                                      < highestTransitive.get().getCvssScore()) {\n                                directReport.setHighestVulnerability(highestTransitive.get());\n                              }\n                            }\n                            return new TransitiveDependencyReport()\n                                .ref(t)\n                                .issues(transitiveIssues)\n                                .highestVulnerability(highestTransitive.orElse(null));\n                          })\n                      .collect(Collectors.toList());\n              transitiveReports.sort(new TransitiveScoreComparator());\n              directReport.setTransitive(transitiveReports);\n              report.addDependenciesItem(directReport);\n            });\n    report.dependencies(\n        report.getDependencies().stream()\n            .sorted(new DependencyScoreComparator())\n            .collect(Collectors.toList()));\n    return report.summary(new Summary().dependencies(deps).vulnerabilities(counter.getSummary()));\n  }\n\n  private void incrementCounter(Issue i, VulnerabilityCounter counter) {\n    switch (i.getSeverity()) {\n      case CRITICAL:\n        counter.critical.incrementAndGet();\n        break;\n      case HIGH:\n        counter.high.incrementAndGet();\n        break;\n      case MEDIUM:\n        counter.medium.incrementAndGet();\n        break;\n      case LOW:\n        counter.low.incrementAndGet();\n        break;\n    }\n    counter.total.incrementAndGet();\n  }\n\n  private static final record VulnerabilityCounter(\n      AtomicInteger total,\n      AtomicInteger direct,\n      AtomicInteger critical,\n      AtomicInteger high,\n      AtomicInteger medium,\n      AtomicInteger low) {\n\n    VulnerabilityCounter() {\n      this(\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger(),\n          new AtomicInteger());\n    }\n\n    VulnerabilitiesSummary getSummary() {\n      return new VulnerabilitiesSummary()\n          .total(total.get())\n          .direct(direct.get())\n          .critical(critical.get())\n          .high(high.get())\n          .medium(medium.get())\n          .low(low.get());\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/ossindex/OssIndexAggregator.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.ossindex;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.redhat.exhort.api.Issue;", "\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.providers.ProviderAggregator;\nimport com.redhat.exhort.model.GraphRequest;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class OssIndexAggregator extends ProviderAggregator {\n\n  private static final int BULK_SIZE = 128;\n\n  public List<List<PackageRef>> split(GraphRequest graphRequest) {\n    List<List<PackageRef>> bulks = new ArrayList<>();\n    graphRequest\n        .tree()\n        .getAll()\n        .forEach(\n            d -> {", "\n@RegisterForReflection\npublic class OssIndexAggregator extends ProviderAggregator {\n\n  private static final int BULK_SIZE = 128;\n\n  public List<List<PackageRef>> split(GraphRequest graphRequest) {\n    List<List<PackageRef>> bulks = new ArrayList<>();\n    graphRequest\n        .tree()\n        .getAll()\n        .forEach(\n            d -> {", "              if (bulks.isEmpty()) {\n                bulks.add(new ArrayList<>());\n              }\n              List<PackageRef> bulk = bulks.get(bulks.size() - 1);\n              if (bulk.size() == BULK_SIZE) {\n                bulk = new ArrayList<>();\n                bulks.add(bulk);\n              }\n              bulk.add(d);\n            });\n    return bulks;\n  }\n\n  public Map<String, List<Issue>> aggregateSplit(\n      Map<String, List<Issue>> oldExchange, Map<String, List<Issue>> newExchange)\n      throws IOException {", "    if (oldExchange != null) {\n      oldExchange.putAll(newExchange);\n      return oldExchange;\n    }\n    return newExchange;\n  }\n\n  @Override\n  protected final String getProviderName() {\n    return Constants.OSS_INDEX_PROVIDER;\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/ossindex/OssIndexIntegration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.ossindex;\n\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.camel.Exchange;", "\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Message;\nimport org.apache.camel.builder.AggregationStrategies;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.BackendUtils;\nimport com.redhat.exhort.integration.providers.VulnerabilityProvider;", "import com.redhat.exhort.integration.backend.BackendUtils;\nimport com.redhat.exhort.integration.providers.VulnerabilityProvider;\nimport com.redhat.exhort.model.DependencyTree;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.ClientErrorException;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.core.MediaType;\n", "import jakarta.ws.rs.core.MediaType;\n\n@ApplicationScoped\npublic class OssIndexIntegration extends EndpointRouteBuilder {\n\n  @ConfigProperty(name = \"api.ossindex.timeout\", defaultValue = \"1000s\")\n  String timeout;\n\n  @Inject VulnerabilityProvider vulnerabilityProvider;\n\n  @Override", "  public void configure() {\n    // fmt:off\n    from(direct(\"ossIndexScan\"))\n        .routeId(\"ossIndexScan\")\n        .circuitBreaker()\n          .faultToleranceConfiguration()\n            .timeoutEnabled(true)\n            .timeoutDuration(timeout)\n          .end()\n          .to(direct(\"ossIndexRequest\"))\n        .onFallback()\n          .process(e -> BackendUtils.processResponseError(e, Constants.OSS_INDEX_PROVIDER));\n\n  from(direct(\"ossIndexRequest\"))\n        .routeId(\"ossIndexRequest\")\n        .choice()\n          .when(method(OssIndexRequestBuilder.class, \"hasDependencies\"))\n            .to(direct(\"ossSplitReq\"))\n          .otherwise()\n            .to(\"log:foo?showBody=true\")\n            .setBody(constant(Collections.emptyMap()))\n        .end()\n        .transform().method(OssIndexAggregator.class, \"buildReport\");\n\n    from(direct(\"ossSplitReq\"))\n        .routeId(\"ossSplitReq\")\n        .transform().method(OssIndexAggregator.class, \"split\")\n        .split(body(), AggregationStrategies.bean(OssIndexAggregator.class, \"aggregateSplit\"))\n          .parallelProcessing()\n          .transform().method(OssIndexRequestBuilder.class, \"buildRequest\")\n          .process(this::processComponentRequest)\n          .to(vertxHttp(\"{{api.ossindex.host}}\"))\n          .transform().method(OssIndexRequestBuilder.class, \"responseToIssues\");\n    \n    from(direct(\"ossValidateCredentials\"))\n      .routeId(\"ossValidateCredentials\")\n      .circuitBreaker()\n        .faultToleranceConfiguration()\n            .timeoutEnabled(true)\n            .timeoutDuration(timeout)\n          .end()\n        .setBody(constant(List.of(DependencyTree.getDefaultRoot(Constants.MAVEN_PKG_MANAGER))))\n        .transform().method(OssIndexRequestBuilder.class, \"buildRequest\")\n        .process(this::processComponentRequest)  \n        .to(vertxHttp(\"{{api.ossindex.host}}\"))\n        .setBody(constant(\"Token validated successfully\"))\n      .onFallback()\n        .process(e -> BackendUtils.processTokenFallBack(e, Constants.OSS_INDEX_PROVIDER));\n    // fmt:on\n  }\n\n  private void processComponentRequest(Exchange exchange) {\n    Message message = exchange.getMessage();\n    message.removeHeader(Exchange.HTTP_PATH);\n    message.removeHeader(Exchange.HTTP_QUERY);\n    message.removeHeader(Exchange.HTTP_URI);\n    message.removeHeader(\"Accept-Encoding\");\n    message.setHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n    message.setHeader(Exchange.HTTP_METHOD, HttpMethod.POST);\n\n    String username = message.getHeader(Constants.OSS_INDEX_USER_HEADER, String.class);\n    String token = message.getHeader(Constants.OSS_INDEX_TOKEN_HEADER, String.class);", "    if (Objects.nonNull(username) && Objects.nonNull(token)) {\n      message.setHeader(Exchange.HTTP_PATH, Constants.OSS_INDEX_AUTH_COMPONENT_API_PATH);\n      StringBuilder auth = new StringBuilder().append(username).append(\":\").append(token);\n      message.setHeader(\n          \"Authorization\",\n          \"Basic \" + Base64.getEncoder().encodeToString(auth.toString().getBytes()));\n    } else {\n      throw new ClientErrorException(401);\n    }\n    message.removeHeader(Constants.OSS_INDEX_USER_HEADER);\n    message.removeHeader(Constants.OSS_INDEX_TOKEN_HEADER);\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/ossindex/OssIndexRequestBuilder.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.ossindex;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;", "import java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.camel.Body;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;", "import com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.SeverityUtils;\nimport com.redhat.exhort.config.ObjectMapperProducer;\nimport com.redhat.exhort.model.CvssParser;\nimport com.redhat.exhort.model.GraphRequest;", "import com.redhat.exhort.model.CvssParser;\nimport com.redhat.exhort.model.GraphRequest;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class OssIndexRequestBuilder {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(OssIndexRequestBuilder.class);\n\n  private ObjectMapper mapper = ObjectMapperProducer.newInstance();\n", "  public String buildRequest(List<PackageRef> packages) throws JsonProcessingException {\n    ArrayNode coordinates = mapper.createArrayNode();\n    packages.stream()\n        .map(PackageRef::purl)\n        .filter(Objects::nonNull)\n        .forEach(purl -> coordinates.add(purl.getCoordinates()));\n\n    ObjectNode root = mapper.createObjectNode().set(\"coordinates\", coordinates);\n    return mapper.writeValueAsString(root);\n  }\n", "  public boolean hasDependencies(@Body GraphRequest req) {\n    return req != null && req.tree() != null && !req.tree().getAll().isEmpty();\n  }\n\n  public Map<String, List<Issue>> responseToIssues(byte[] response) throws IOException {\n    ArrayNode json = (ArrayNode) mapper.readTree(response);\n    return getIssues(json);\n  }\n\n  private Map<String, List<Issue>> getIssues(ArrayNode response) {\n    Map<String, List<Issue>> reports = new HashMap<>();\n    response.forEach(\n        n -> {\n          String pkgRef = n.get(\"coordinates\").asText();", "          try {\n            PackageRef ref = PackageRef.builder().purl(pkgRef).build();\n            List<Issue> issues = new ArrayList<>();\n            ArrayNode vulnerabilities = (ArrayNode) n.get(\"vulnerabilities\");\n            vulnerabilities.forEach(v -> issues.add(toIssue(v)));\n            if (!issues.isEmpty()) {\n              reports.put(ref.name(), issues);\n            }\n          } catch (IllegalArgumentException e) {\n            LOGGER.warn(\"Unable to parse PackageURL: \" + pkgRef, e);\n          }\n        });\n\n    return reports;\n  }\n\n  private Issue toIssue(JsonNode data) {\n    float score = data.get(\"cvssScore\").floatValue();\n    return new Issue()\n        .id(data.get(\"id\").asText())\n        .title(data.get(\"title\").asText())\n        .cves(List.of(data.get(\"cve\").asText()))\n        .cvss(CvssParser.fromVectorString(data.get(\"cvssVector\").asText()))\n        .cvssScore(score)\n        .severity(SeverityUtils.fromScore(score));\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/snyk/SnykIntegration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.snyk;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Message;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n\nimport com.redhat.exhort.integration.Constants;", "\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.backend.BackendUtils;\nimport com.redhat.exhort.integration.providers.VulnerabilityProvider;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.core.MediaType;\n", "import jakarta.ws.rs.core.MediaType;\n\n@ApplicationScoped\npublic class SnykIntegration extends EndpointRouteBuilder {\n\n  @ConfigProperty(name = \"api.snyk.timeout\", defaultValue = \"10s\")\n  String timeout;\n\n  @ConfigProperty(name = \"api.snyk.token\")\n  String defaultToken;\n\n  @Inject VulnerabilityProvider vulnerabilityProvider;\n\n  @Override", "  public void configure() {\n\n    // fmt:off\n    from(direct(\"snykDepGraph\"))\n        .routeId(\"snykDepGraph\")\n        .process(this::setAuthToken)\n                .circuitBreaker()\n          .faultToleranceConfiguration()\n            .timeoutEnabled(true)\n            .timeoutDuration(timeout)\n          .end()\n        .to(direct(\"snykRequest\"))\n        .onFallback()\n          .process(e -> BackendUtils.processResponseError(e, Constants.SNYK_PROVIDER));\n\n    from(direct(\"snykRequest\"))\n        .routeId(\"snykRequest\")\n        .transform().method(SnykRequestBuilder.class, \"fromDiGraph\")\n        .process(this::processDepGraphRequest)\n        .to(vertxHttp(\"{{api.snyk.host}}\"))\n        .transform().method(SnykAggregator.class, \"transformResponse\")\n        .transform().method(SnykAggregator.class, \"buildReport\")\n      ;\n\n    from(direct(\"snykValidateToken\"))\n        .routeId(\"snykValidateToken\")\n        .process(this::processTokenRequest)\n        .circuitBreaker()\n          .faultToleranceConfiguration()\n            .timeoutEnabled(true)\n            .timeoutDuration(timeout)\n          .end()\n          .to(vertxHttp(\"{{api.snyk.host}}\"))\n          .setBody(constant(\"Token validated successfully\"))\n        .onFallback()\n          .process(e -> BackendUtils.processTokenFallBack(e, Constants.SNYK_PROVIDER));\n    // fmt:on\n  }\n\n  private void setAuthToken(Exchange exchange) {\n    Message message = exchange.getMessage();\n    String token = message.getHeader(Constants.SNYK_TOKEN_HEADER, String.class);", "    if (token == null) {\n      token = defaultToken;\n      vulnerabilityProvider.addProviderPrivateData(exchange, Constants.SNYK_PROVIDER);\n    }\n    message.setHeader(\"Authorization\", \"token \" + token);\n  }\n\n  private void processDepGraphRequest(Exchange exchange) {\n    Message message = exchange.getMessage();\n    processRequestHeaders(message);\n    message.setHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n    message.setHeader(Exchange.HTTP_PATH, Constants.SNYK_DEP_GRAPH_API_PATH);\n    message.setHeader(Exchange.HTTP_METHOD, HttpMethod.POST);\n  }\n\n  private void processTokenRequest(Exchange exchange) {\n    Message message = exchange.getMessage();\n    message.setHeader(\"Authorization\", \"token \" + message.getHeader(Constants.SNYK_TOKEN_HEADER));\n    processRequestHeaders(message);\n    message.setHeader(Exchange.HTTP_PATH, Constants.SNYK_TOKEN_API_PATH);\n    message.setHeader(Exchange.HTTP_METHOD, HttpMethod.GET);\n  }\n\n  private void processRequestHeaders(Message message) {\n    message.removeHeader(Exchange.HTTP_PATH);\n    message.removeHeader(Exchange.HTTP_QUERY);\n    message.removeHeader(Exchange.HTTP_URI);\n    message.removeHeader(Constants.SNYK_TOKEN_HEADER);\n    message.removeHeader(\"Accept-Encoding\");\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/snyk/SnykRequestBuilder.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.snyk;\n\nimport java.util.Collections;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;", "import com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.config.ObjectMapperProducer;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.GraphRequest;\n", "import com.redhat.exhort.model.GraphRequest;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class SnykRequestBuilder {\n\n  private ObjectMapper mapper = ObjectMapperProducer.newInstance();\n\n  public String fromDiGraph(GraphRequest req) throws JsonProcessingException {\n    ObjectNode depGraph = mapper.createObjectNode();\n    depGraph.put(\"schemaVersion\", \"1.2.0\");\n    depGraph.set(\n        \"pkgManager\",\n        mapper.createObjectNode().put(\"name\", toSnykPackageManager(req.pkgManager())));\n\n    depGraph.set(\"pkgs\", addPackages(depGraph, req.tree()));\n    ObjectNode root = mapper.createObjectNode().set(\"depGraph\", depGraph);\n    return mapper.writeValueAsString(root);\n  }\n\n  private JsonNode addPackages(ObjectNode depGraph, DependencyTree tree) {\n    Set<com.redhat.exhort.api.PackageRef> allDeps = tree.getAll();\n    ObjectNode rootNode = createNode(tree.root(), allDeps);\n    ArrayNode nodes = mapper.createArrayNode().add(rootNode);\n    ArrayNode pkgs = mapper.createArrayNode().add(createPkg(tree.root()));\n\n    allDeps.stream()\n        .forEach(\n            d -> {\n              pkgs.add(createPkg(d));\n              nodes.add(createNode(d, Collections.emptySet()));\n            });\n    depGraph.set(\"pkgs\", pkgs);\n    depGraph.set(\n        \"graph\",\n        mapper.createObjectNode().put(\"rootNodeId\", getId(tree.root())).set(\"nodes\", nodes));\n    return pkgs;\n  }\n\n  private ObjectNode createPkg(PackageRef source) {\n    return mapper\n        .createObjectNode()\n        .put(\"id\", getId(source))\n        .set(\n            \"info\",\n            mapper.createObjectNode().put(\"name\", source.name()).put(\"version\", source.version()));\n  }\n\n  private ObjectNode createNode(PackageRef source, Set<PackageRef> deps) {\n    ArrayNode depsNode = mapper.createArrayNode();\n    deps.forEach(e -> depsNode.add(mapper.createObjectNode().put(\"nodeId\", getId(e))));\n    return mapper\n        .createObjectNode()\n        .put(\"nodeId\", getId(source))\n        .put(\"pkgId\", getId(source))\n        .set(\"deps\", depsNode);\n  }\n\n  private String getId(PackageRef ref) {\n    return new StringBuilder(ref.name()).append(\"@\").append(ref.version()).toString();\n  }\n\n  private String toSnykPackageManager(String pkgManager) {\n    switch (pkgManager) {\n      case Constants.GOLANG_PKG_MANAGER:\n        return \"gomodules\";\n      case Constants.PYPI_PKG_MANAGER:\n        return \"pip\";\n      default:\n        return pkgManager;\n    }\n  }\n}\n", "  public String fromDiGraph(GraphRequest req) throws JsonProcessingException {\n    ObjectNode depGraph = mapper.createObjectNode();\n    depGraph.put(\"schemaVersion\", \"1.2.0\");\n    depGraph.set(\n        \"pkgManager\",\n        mapper.createObjectNode().put(\"name\", toSnykPackageManager(req.pkgManager())));\n\n    depGraph.set(\"pkgs\", addPackages(depGraph, req.tree()));\n    ObjectNode root = mapper.createObjectNode().set(\"depGraph\", depGraph);\n    return mapper.writeValueAsString(root);\n  }\n\n  private JsonNode addPackages(ObjectNode depGraph, DependencyTree tree) {\n    Set<com.redhat.exhort.api.PackageRef> allDeps = tree.getAll();\n    ObjectNode rootNode = createNode(tree.root(), allDeps);\n    ArrayNode nodes = mapper.createArrayNode().add(rootNode);\n    ArrayNode pkgs = mapper.createArrayNode().add(createPkg(tree.root()));\n\n    allDeps.stream()\n        .forEach(\n            d -> {\n              pkgs.add(createPkg(d));\n              nodes.add(createNode(d, Collections.emptySet()));\n            });\n    depGraph.set(\"pkgs\", pkgs);\n    depGraph.set(\n        \"graph\",\n        mapper.createObjectNode().put(\"rootNodeId\", getId(tree.root())).set(\"nodes\", nodes));\n    return pkgs;\n  }\n\n  private ObjectNode createPkg(PackageRef source) {\n    return mapper\n        .createObjectNode()\n        .put(\"id\", getId(source))\n        .set(\n            \"info\",\n            mapper.createObjectNode().put(\"name\", source.name()).put(\"version\", source.version()));\n  }\n\n  private ObjectNode createNode(PackageRef source, Set<PackageRef> deps) {\n    ArrayNode depsNode = mapper.createArrayNode();\n    deps.forEach(e -> depsNode.add(mapper.createObjectNode().put(\"nodeId\", getId(e))));\n    return mapper\n        .createObjectNode()\n        .put(\"nodeId\", getId(source))\n        .put(\"pkgId\", getId(source))\n        .set(\"deps\", depsNode);\n  }\n\n  private String getId(PackageRef ref) {\n    return new StringBuilder(ref.name()).append(\"@\").append(ref.version()).toString();\n  }\n\n  private String toSnykPackageManager(String pkgManager) {\n    switch (pkgManager) {\n      case Constants.GOLANG_PKG_MANAGER:\n        return \"gomodules\";\n      case Constants.PYPI_PKG_MANAGER:\n        return \"pip\";\n      default:\n        return pkgManager;\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/providers/snyk/SnykAggregator.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.providers.snyk;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n", "import java.util.Map;\n\nimport org.apache.camel.Body;\nimport org.apache.camel.ExchangeProperty;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.SeverityUtils;\nimport com.redhat.exhort.config.ObjectMapperProducer;", "import com.redhat.exhort.api.SeverityUtils;\nimport com.redhat.exhort.config.ObjectMapperProducer;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.integration.providers.ProviderAggregator;\nimport com.redhat.exhort.model.CvssParser;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class SnykAggregator extends ProviderAggregator {\n\n  private static final String SNYK_PRIVATE_VULNERABILITY_ID = \"SNYK-PRIVATE-VULNERABILITY\";\n  private static final String SNYK_PRIVATE_VULNERABILITY_TITLE =\n      \"Sign up for a free Snyk account to learn aboutn the vulnerabilities found\";\n\n  private final ObjectMapper mapper = ObjectMapperProducer.newInstance();\n\n  private Map<String, List<Issue>> getIssues(JsonNode snykResponse, boolean filterUnique) {\n    Map<String, List<Issue>> reports = new HashMap<>();\n    snykResponse\n        .withArray(\"issues\")\n        .elements()\n        .forEachRemaining(\n            n -> {\n              String pkgName = n.get(\"pkgName\").asText();\n              String issueId = n.get(\"issueId\").asText();\n              JsonNode issueData = snykResponse.get(\"issuesData\").get(issueId);\n              List<Issue> issues = reports.get(pkgName);", "@RegisterForReflection\npublic class SnykAggregator extends ProviderAggregator {\n\n  private static final String SNYK_PRIVATE_VULNERABILITY_ID = \"SNYK-PRIVATE-VULNERABILITY\";\n  private static final String SNYK_PRIVATE_VULNERABILITY_TITLE =\n      \"Sign up for a free Snyk account to learn aboutn the vulnerabilities found\";\n\n  private final ObjectMapper mapper = ObjectMapperProducer.newInstance();\n\n  private Map<String, List<Issue>> getIssues(JsonNode snykResponse, boolean filterUnique) {\n    Map<String, List<Issue>> reports = new HashMap<>();\n    snykResponse\n        .withArray(\"issues\")\n        .elements()\n        .forEachRemaining(\n            n -> {\n              String pkgName = n.get(\"pkgName\").asText();\n              String issueId = n.get(\"issueId\").asText();\n              JsonNode issueData = snykResponse.get(\"issuesData\").get(issueId);\n              List<Issue> issues = reports.get(pkgName);", "              if (issues == null) {\n                issues = new ArrayList<>();\n                reports.put(pkgName, issues);\n              }\n              issues.add(toIssue(issueId, issueData, filterUnique));\n            });\n    return reports;\n  }\n\n  private Issue toIssue(String id, JsonNode data, boolean filterUnique) {\n    List<String> cves = new ArrayList<>();\n    data.withArray(\"/identifiers/CVE\").elements().forEachRemaining(cve -> cves.add(cve.asText()));\n    String cvssV3 = data.get(\"CVSSv3\").asText();\n", "    if (cves.isEmpty() && filterUnique) {\n      return toFilteredIssue(data);\n    }\n    return new Issue()\n        .id(id)\n        .title(data.get(\"title\").asText())\n        .severity(SeverityUtils.fromValue(data.get(\"severity\").asText()))\n        .cvss(CvssParser.fromVectorString(cvssV3))\n        .cvssScore(data.get(\"cvssScore\").floatValue())\n        .cves(cves)\n        .unique(cves.isEmpty());\n  }\n\n  private Issue toFilteredIssue(JsonNode data) {\n    return new Issue()\n        .id(SNYK_PRIVATE_VULNERABILITY_ID)\n        .title(SNYK_PRIVATE_VULNERABILITY_TITLE)\n        .severity(SeverityUtils.fromValue(data.get(\"severity\").asText()))\n        .cvssScore(data.get(\"cvssScore\").floatValue())\n        .unique(Boolean.TRUE);\n  }\n\n  protected final String getProviderName() {\n    return Constants.SNYK_PROVIDER;\n  }\n\n  public Map<String, List<Issue>> transformResponse(\n      @Body byte[] providerResponse,\n      @ExchangeProperty(Constants.PROVIDER_PRIVATE_DATA_PROPERTY) String privateProviders)\n      throws IOException {\n    boolean filterUnique =\n        privateProviders != null && privateProviders.contains(Constants.SNYK_PROVIDER);\n\n    JsonNode snykResponse = mapper.readTree((byte[]) providerResponse);\n    return getIssues(snykResponse, filterUnique);\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/trustedcontent/TrustedContentBodyMapper.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.trustedcontent;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;", "import java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.apache.camel.Body;\nimport org.apache.camel.ExchangeProperty;\n\nimport com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;", "import com.redhat.exhort.api.AnalysisReport;\nimport com.redhat.exhort.api.AnalysisReportValue;\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.api.Remediation;\nimport com.redhat.exhort.api.TransitiveDependencyReport;\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.trustedcontent.MavenPackage;", "import com.redhat.exhort.model.DependencyTree;\nimport com.redhat.exhort.model.trustedcontent.MavenPackage;\nimport com.redhat.exhort.model.trustedcontent.VexRequest;\nimport com.redhat.exhort.model.trustedcontent.VexResult;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class TrustedContentBodyMapper {\n\n  public static VexRequest buildVexRequest(@Body AnalysisReport reports) {\n    Set<String> cves = new HashSet<>();\n    reports.values().stream()\n        .map(AnalysisReportValue::getDependencies)\n        .flatMap(List::stream)\n        .forEach(\n            d -> {", "public class TrustedContentBodyMapper {\n\n  public static VexRequest buildVexRequest(@Body AnalysisReport reports) {\n    Set<String> cves = new HashSet<>();\n    reports.values().stream()\n        .map(AnalysisReportValue::getDependencies)\n        .flatMap(List::stream)\n        .forEach(\n            d -> {\n              if (d.getIssues() != null) {\n                d.getIssues().stream().forEach(i -> cves.addAll(i.getCves()));\n              }", "              if (d.getIssues() != null) {\n                d.getIssues().stream().forEach(i -> cves.addAll(i.getCves()));\n              }\n              if (d.getTransitive() != null) {\n                cves.addAll(\n                    d.getTransitive().stream()\n                        .map(TransitiveDependencyReport::getIssues)\n                        .flatMap(List::stream)\n                        .filter(Objects::nonNull)\n                        .map(Issue::getCves)\n                        .filter(Objects::nonNull)\n                        .flatMap(List::stream)\n                        .collect(Collectors.toSet()));\n              }\n            });\n\n    return new VexRequest(List.copyOf(cves));\n  }\n\n  public Map<String, Remediation> createRemediations(VexRequest request, List<VexResult> response) {\n    Map<String, Remediation> remediations = new HashMap<>();", "    for (int i = 0; i < request.cves().size(); i++) {\n      VexResult result = response.get(i);\n      if (result != null) {\n        String cve = request.cves().get(i);\n        PackageRef ref =\n            toMavenPkgRef(\n                result.mavenPackage().groupId(),\n                result.mavenPackage().artifactId(),\n                result.mavenPackage().version());\n        Remediation r =\n            new Remediation().issueRef(cve).mavenPackage(ref).productStatus(result.productStatus());\n        remediations.put(cve, r);\n      }\n    }\n    return remediations;\n  }\n", "  public AnalysisReport filterRemediations(\n      AnalysisReport req, Map<String, Remediation> remediations) {\n    if (remediations == null || remediations.isEmpty()) {\n      return req;\n    }\n    req.values()\n        .forEach(\n            report ->\n                report.getDependencies().stream()\n                    .forEach(\n                        d -> {\n                          Map<String, Remediation> depRemediations = new HashMap<>();", "                          if (d.getIssues() != null) {\n                            d.getIssues()\n                                .forEach(\n                                    i -> {\n                                      List<String> cves = i.getCves();\n                                      if (cves != null) {\n                                        cves.forEach(\n                                            cve -> {\n                                              Remediation r = remediations.get(cve);\n                                              if (r != null\n                                                  && r.getMavenPackage()\n                                                      .name()\n                                                      .equals(d.getRef().name())) {\n                                                depRemediations.put(cve, r);\n                                              }\n                                            });\n                                      }\n                                    });", "                                              if (r != null\n                                                  && r.getMavenPackage()\n                                                      .name()\n                                                      .equals(d.getRef().name())) {\n                                                depRemediations.put(cve, r);\n                                              }\n                                            });\n                                      }\n                                    });\n                            if (d.getTransitive() != null) {\n                              d.getTransitive()\n                                  .forEach(\n                                      transitive -> {\n                                        Map<String, Remediation> transRemediations =\n                                            new HashMap<>();", "                            if (d.getTransitive() != null) {\n                              d.getTransitive()\n                                  .forEach(\n                                      transitive -> {\n                                        Map<String, Remediation> transRemediations =\n                                            new HashMap<>();\n                                        if (transitive.getIssues() != null) {\n                                          transitive\n                                              .getIssues()\n                                              .forEach(\n                                                  i -> {\n                                                    List<String> cves = i.getCves();", "                                                    if (cves != null) {\n                                                      cves.forEach(\n                                                          cve -> {\n                                                            Remediation r = remediations.get(cve);\n                                                            if (r != null)\n                                                              if (r.getMavenPackage()\n                                                                  .name()\n                                                                  .equals(\n                                                                      transitive.getRef().name())) {\n                                                                transRemediations.put(cve, r);\n                                                              } else if (r.getMavenPackage()\n                                                                  .name()\n                                                                  .equals(d.getRef().name())) {\n                                                                depRemediations.put(cve, r);\n                                                              }\n                                                          });\n                                                    }\n                                                  });\n                                        }\n                                        transitive.setRemediations(transRemediations);\n                                      });\n                            }\n                          }\n                          d.setRemediations(depRemediations);\n                        }));\n    return req;\n  }\n\n  // Only look for recommendations for direct dependencies\n  public List<String> buildGavRequest(\n      @ExchangeProperty(Constants.DEPENDENCY_TREE_PROPERTY) DependencyTree tree) {\n    return tree.dependencies().keySet().stream()\n        .map(PackageRef::toGav)\n        .sorted()\n        .collect(Collectors.toUnmodifiableList());\n  }\n", "                                                              } else if (r.getMavenPackage()\n                                                                  .name()\n                                                                  .equals(d.getRef().name())) {\n                                                                depRemediations.put(cve, r);\n                                                              }\n                                                          });\n                                                    }\n                                                  });\n                                        }\n                                        transitive.setRemediations(transRemediations);\n                                      });\n                            }\n                          }\n                          d.setRemediations(depRemediations);\n                        }));\n    return req;\n  }\n\n  // Only look for recommendations for direct dependencies\n  public List<String> buildGavRequest(\n      @ExchangeProperty(Constants.DEPENDENCY_TREE_PROPERTY) DependencyTree tree) {\n    return tree.dependencies().keySet().stream()\n        .map(PackageRef::toGav)\n        .sorted()\n        .collect(Collectors.toUnmodifiableList());\n  }\n", "  public AnalysisReport addRecommendations(\n      AnalysisReport reports, Map<String, PackageRef> recommendations) {\n    if (recommendations == null || recommendations.isEmpty()) {\n      return reports;\n    }\n\n    reports\n        .values()\n        .forEach(\n            report ->\n                recommendations\n                    .entrySet()\n                    .forEach(\n                        r -> {\n                          Optional<DependencyReport> dep =\n                              report.getDependencies().stream()\n                                  .filter(d -> d.getRef().toGav().equals(r.getKey()))\n                                  .findFirst();", "                          if (dep.isPresent()) {\n                            dep.get().setRecommendation(r.getValue());\n                          }\n                        }));\n    return reports;\n  }\n\n  public Map<String, PackageRef> createGavRecommendations(\n      List<String> gavRequest, List<MavenPackage> recommendations) {\n    Map<String, PackageRef> result = new HashMap<>();\n    for (int i = 0; i < gavRequest.size(); i++) {\n      MavenPackage pkg = recommendations.get(i);", "    for (int i = 0; i < gavRequest.size(); i++) {\n      MavenPackage pkg = recommendations.get(i);\n      if (pkg != null) {\n        result.put(\n            gavRequest.get(i), toMavenPkgRef(pkg.groupId(), pkg.artifactId(), pkg.version()));\n      }\n    }\n    return result;\n  }\n\n  public int cvesSize(@Body VexRequest req) {", "  public int cvesSize(@Body VexRequest req) {\n    if (req == null || req.cves() == null) {\n      return 0;\n    }\n    return req.cves().size();\n  }\n\n  public int gavsSize(@Body List<String> gavs) {\n    if (gavs == null) {\n      return 0;\n    }\n    return gavs.size();\n  }\n\n  private PackageRef toMavenPkgRef(String groupId, String artifactId, String version) {\n    return PackageRef.builder()\n        .pkgManager(Constants.MAVEN_PKG_MANAGER)\n        .namespace(groupId)\n        .name(artifactId)\n        .version(version)\n        .build();\n  }\n}\n", "    if (gavs == null) {\n      return 0;\n    }\n    return gavs.size();\n  }\n\n  private PackageRef toMavenPkgRef(String groupId, String artifactId, String version) {\n    return PackageRef.builder()\n        .pkgManager(Constants.MAVEN_PKG_MANAGER)\n        .namespace(groupId)\n        .name(artifactId)\n        .version(version)\n        .build();\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/integration/trustedcontent/TrustedContentIntegration.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.integration.trustedcontent;\n\nimport java.util.Collections;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Message;\nimport org.apache.camel.builder.AggregationStrategies;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;", "import org.apache.camel.builder.AggregationStrategies;\nimport org.apache.camel.builder.endpoint.EndpointRouteBuilder;\nimport org.apache.camel.component.jackson.ListJacksonDataFormat;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.redhat.exhort.integration.Constants;\nimport com.redhat.exhort.model.trustedcontent.MavenPackage;\nimport com.redhat.exhort.model.trustedcontent.VexResult;", "import com.redhat.exhort.model.trustedcontent.MavenPackage;\nimport com.redhat.exhort.model.trustedcontent.VexResult;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.core.MediaType;\n\n@ApplicationScoped\npublic class TrustedContentIntegration extends EndpointRouteBuilder {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(TrustedContentIntegration.class);\n\n  @ConfigProperty(name = \"api.trustedContent.timeout\", defaultValue = \"10s\")\n  String timeout;\n\n  @Override", "public class TrustedContentIntegration extends EndpointRouteBuilder {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(TrustedContentIntegration.class);\n\n  @ConfigProperty(name = \"api.trustedContent.timeout\", defaultValue = \"10s\")\n  String timeout;\n\n  @Override\n  public void configure() {\n    // fmt:off\n    from(direct(\"findRemediations\"))\n        .routeId(\"findRemediations\")\n        .circuitBreaker()\n        .faultToleranceConfiguration()\n        .timeoutEnabled(true)\n        .timeoutDuration(timeout)\n        .end()\n        .enrich(direct(\"trustedContentVex\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"filterRemediations\"))\n        .onFallback()\n        .process(this::processFallback);\n\n    from(direct(\"trustedContentVex\"))\n        .routeId(\"trustedContentVex\")\n        .process(this::processVexRequest)\n        .transform().method(TrustedContentBodyMapper.class, \"buildVexRequest\")\n        .choice().when(method(TrustedContentBodyMapper.class, \"cvesSize\").isGreaterThan(0))\n        .enrich(direct(\"vexRequest\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"createRemediations\"))\n        .otherwise().setBody(constant(Collections.emptyMap()));\n\n    from(direct(\"vexRequest\"))\n        .routeId(\"doVexRequest\")\n        .marshal().json()\n        .to(vertxHttp(\"{{api.trustedContent.vex.host}}\"))\n        .unmarshal(new ListJacksonDataFormat(VexResult.class));\n\n    from(direct(\"trustedContentGav\"))\n        .routeId(\"trustedContentGav\")\n        .bean(TrustedContentBodyMapper.class, \"buildGavRequest\")\n        .choice().when(method(TrustedContentBodyMapper.class, \"gavsSize\").isGreaterThan(0))\n        .enrich(direct(\"gavRequest\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"createGavRecommendations\"))\n        .otherwise().setBody(constant(Collections.emptyMap()));\n\n    from(direct(\"gavRequest\"))\n        .routeId(\"gavRequest\")\n        .marshal().json()\n        .process(this::processGavRequest)\n        .to(vertxHttp(\"{{api.trustedContent.gav.host}}\"))\n        .unmarshal(new ListJacksonDataFormat(MavenPackage.class));\n\n    from(direct(\"recommendTrustedContent\"))\n      .routeId(\"recommendTrustedContent\")\n      .circuitBreaker()\n        .faultToleranceConfiguration()\n        .timeoutEnabled(true)\n        .timeoutDuration(timeout)\n        .end()\n        .enrich(direct(\"trustedContentGav\"), AggregationStrategies.bean(TrustedContentBodyMapper.class, \"addRecommendations\"))\n      .onFallback()\n        .process(this::processFallback);\n    // fmt:on\n  }\n\n  private void processVexRequest(Exchange exchange) {\n    processRequest(exchange.getMessage(), Constants.TRUSTED_CONTENT_VEX_PATH);\n  }\n\n  private void processGavRequest(Exchange exchange) {\n    Message message = exchange.getMessage();\n    processRequest(message, Constants.TRUSTED_CONTENT_PATH);\n    message.setHeader(Exchange.HTTP_QUERY, \"minimal=true\");\n  }\n\n  private void processRequest(Message message, String path) {\n    message.removeHeader(Exchange.HTTP_PATH);\n    message.removeHeader(Exchange.HTTP_QUERY);\n    message.removeHeader(Exchange.HTTP_URI);\n    message.setHeader(Exchange.HTTP_PATH, path);\n    message.setHeader(Exchange.HTTP_METHOD, HttpMethod.POST);\n    message.setHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n    message.setHeader(\"Accept\", MediaType.APPLICATION_JSON);\n  }\n\n  private void processFallback(Exchange exchange) {\n    // Ignore error and don't process Trusted Content requests\n    Exception exception = (Exception) exchange.getProperty(Exchange.EXCEPTION_CAUGHT);\n    LOGGER.warn(\"Unable to process Trusted Content request\", exception);\n  }\n}\n", "  public void configure() {\n    // fmt:off\n    from(direct(\"findRemediations\"))\n        .routeId(\"findRemediations\")\n        .circuitBreaker()\n        .faultToleranceConfiguration()\n        .timeoutEnabled(true)\n        .timeoutDuration(timeout)\n        .end()\n        .enrich(direct(\"trustedContentVex\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"filterRemediations\"))\n        .onFallback()\n        .process(this::processFallback);\n\n    from(direct(\"trustedContentVex\"))\n        .routeId(\"trustedContentVex\")\n        .process(this::processVexRequest)\n        .transform().method(TrustedContentBodyMapper.class, \"buildVexRequest\")\n        .choice().when(method(TrustedContentBodyMapper.class, \"cvesSize\").isGreaterThan(0))\n        .enrich(direct(\"vexRequest\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"createRemediations\"))\n        .otherwise().setBody(constant(Collections.emptyMap()));\n\n    from(direct(\"vexRequest\"))\n        .routeId(\"doVexRequest\")\n        .marshal().json()\n        .to(vertxHttp(\"{{api.trustedContent.vex.host}}\"))\n        .unmarshal(new ListJacksonDataFormat(VexResult.class));\n\n    from(direct(\"trustedContentGav\"))\n        .routeId(\"trustedContentGav\")\n        .bean(TrustedContentBodyMapper.class, \"buildGavRequest\")\n        .choice().when(method(TrustedContentBodyMapper.class, \"gavsSize\").isGreaterThan(0))\n        .enrich(direct(\"gavRequest\"),\n            AggregationStrategies.bean(TrustedContentBodyMapper.class, \"createGavRecommendations\"))\n        .otherwise().setBody(constant(Collections.emptyMap()));\n\n    from(direct(\"gavRequest\"))\n        .routeId(\"gavRequest\")\n        .marshal().json()\n        .process(this::processGavRequest)\n        .to(vertxHttp(\"{{api.trustedContent.gav.host}}\"))\n        .unmarshal(new ListJacksonDataFormat(MavenPackage.class));\n\n    from(direct(\"recommendTrustedContent\"))\n      .routeId(\"recommendTrustedContent\")\n      .circuitBreaker()\n        .faultToleranceConfiguration()\n        .timeoutEnabled(true)\n        .timeoutDuration(timeout)\n        .end()\n        .enrich(direct(\"trustedContentGav\"), AggregationStrategies.bean(TrustedContentBodyMapper.class, \"addRecommendations\"))\n      .onFallback()\n        .process(this::processFallback);\n    // fmt:on\n  }\n\n  private void processVexRequest(Exchange exchange) {\n    processRequest(exchange.getMessage(), Constants.TRUSTED_CONTENT_VEX_PATH);\n  }\n\n  private void processGavRequest(Exchange exchange) {\n    Message message = exchange.getMessage();\n    processRequest(message, Constants.TRUSTED_CONTENT_PATH);\n    message.setHeader(Exchange.HTTP_QUERY, \"minimal=true\");\n  }\n\n  private void processRequest(Message message, String path) {\n    message.removeHeader(Exchange.HTTP_PATH);\n    message.removeHeader(Exchange.HTTP_QUERY);\n    message.removeHeader(Exchange.HTTP_URI);\n    message.setHeader(Exchange.HTTP_PATH, path);\n    message.setHeader(Exchange.HTTP_METHOD, HttpMethod.POST);\n    message.setHeader(Exchange.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n    message.setHeader(\"Accept\", MediaType.APPLICATION_JSON);\n  }\n\n  private void processFallback(Exchange exchange) {\n    // Ignore error and don't process Trusted Content requests\n    Exception exception = (Exception) exchange.getProperty(Exchange.EXCEPTION_CAUGHT);\n    LOGGER.warn(\"Unable to process Trusted Content request\", exception);\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/CvssScoreComparable.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport java.util.Comparator;\n\nimport com.redhat.exhort.api.DependencyReport;\nimport com.redhat.exhort.api.Issue;\nimport com.redhat.exhort.api.TransitiveDependencyReport;\n\npublic interface CvssScoreComparable {\n\n  Issue getHighestVulnerability();\n", "import com.redhat.exhort.api.TransitiveDependencyReport;\n\npublic interface CvssScoreComparable {\n\n  Issue getHighestVulnerability();\n\n  public static class DependencyScoreComparator implements Comparator<DependencyReport> {\n\n    @Override\n    public int compare(DependencyReport d1, DependencyReport d2) {\n      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() == null) {\n        return 0;\n      }", "    public int compare(DependencyReport d1, DependencyReport d2) {\n      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() == null) {\n        return 0;\n      }\n      if (d1.getHighestVulnerability() != null && d2.getHighestVulnerability() == null) {\n        return -1;\n      }\n      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() != null) {\n        return 1;\n      }\n      return Float.compare(\n          d2.getHighestVulnerability().getCvssScore(), d1.getHighestVulnerability().getCvssScore());\n    }\n  }\n", "  public static class TransitiveScoreComparator implements Comparator<TransitiveDependencyReport> {\n\n    @Override\n    public int compare(TransitiveDependencyReport d1, TransitiveDependencyReport d2) {\n      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() == null) {\n        return 0;\n      }\n      if (d1.getHighestVulnerability() != null && d2.getHighestVulnerability() == null) {\n        return -1;\n      }\n      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() != null) {\n        return 1;\n      }\n      return Float.compare(\n          d2.getHighestVulnerability().getCvssScore(), d1.getHighestVulnerability().getCvssScore());\n    }\n  }\n}\n", "      if (d1.getHighestVulnerability() == null && d2.getHighestVulnerability() != null) {\n        return 1;\n      }\n      return Float.compare(\n          d2.getHighestVulnerability().getCvssScore(), d1.getHighestVulnerability().getCvssScore());\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/DirectDependency.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport java.util.Collections;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport com.redhat.exhort.api.PackageRef;\n", "import com.redhat.exhort.api.PackageRef;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record DirectDependency(\n    PackageRef ref, Set<PackageRef> transitive, PackageRef recommendation) {\n\n  public DirectDependency {\n    Objects.requireNonNull(ref);\n    if (transitive != null) {\n      transitive = Collections.unmodifiableSet(transitive);\n    } else {\n      transitive = Collections.emptySet();\n    }\n  }\n", "    if (transitive != null) {\n      transitive = Collections.unmodifiableSet(transitive);\n    } else {\n      transitive = Collections.emptySet();\n    }\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n", "  public static class Builder {\n\n    public PackageRef ref;\n    public Set<PackageRef> transitive;\n    public PackageRef recommendation;\n\n    public Builder ref(PackageRef ref) {\n      this.ref = ref;\n      return this;\n    }\n", "    public Builder transitive(Set<PackageRef> transitive) {\n      this.transitive = transitive;\n      return this;\n    }\n\n    public Builder recommendation(PackageRef recommendation) {\n      this.recommendation = recommendation;\n      return this;\n    }\n\n    public DirectDependency build() {\n      return new DirectDependency(ref, transitive, recommendation);\n    }\n  }\n}\n", "    public DirectDependency build() {\n      return new DirectDependency(ref, transitive, recommendation);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/GraphRequest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Predicate;", "import java.util.Objects;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.redhat.exhort.api.PackageRef;\nimport com.redhat.exhort.integration.Constants;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record GraphRequest(\n    String pkgManager,\n    List<String> providers,\n    DependencyTree tree,\n    Map<String, PackageRef> recommendations) {\n\n  public GraphRequest {\n    Objects.requireNonNull(pkgManager);\n    Objects.requireNonNull(providers);\n    Objects.requireNonNull(tree);\n", "\n@RegisterForReflection\npublic record GraphRequest(\n    String pkgManager,\n    List<String> providers,\n    DependencyTree tree,\n    Map<String, PackageRef> recommendations) {\n\n  public GraphRequest {\n    Objects.requireNonNull(pkgManager);\n    Objects.requireNonNull(providers);\n    Objects.requireNonNull(tree);\n", "    if (!Constants.PKG_MANAGERS.contains(pkgManager)) {\n      throw new IllegalArgumentException(\"Unsupported package manager: \" + pkgManager);\n    }\n    List<String> invalidProviders =\n        providers.stream()\n            .filter(Predicate.not(Constants.PROVIDERS::contains))\n            .collect(Collectors.toList());\n    if (!invalidProviders.isEmpty()) {\n      throw new IllegalArgumentException(\"Unsupported providers: \" + invalidProviders);\n    }\n", "    if (recommendations != null) {\n      recommendations = Collections.unmodifiableMap(recommendations);\n    } else {\n      recommendations = Collections.emptyMap();\n    }\n  }\n\n  public static class Builder {\n\n    String pkgManager;\n    List<String> providers;\n    DependencyTree tree;\n    Map<String, PackageRef> recommendations;\n\n    public Builder(String pkgManager, List<String> providers) {\n      this.pkgManager = pkgManager;\n      this.providers = providers;\n    }\n\n    public Builder(GraphRequest copy) {\n      this.pkgManager = copy.pkgManager;\n      this.providers = copy.providers;\n      this.tree = copy.tree;\n", "      if (copy.recommendations != null) {\n        this.recommendations = new HashMap<>(copy.recommendations);\n      }\n    }\n\n    public Builder tree(DependencyTree tree) {\n      this.tree = tree;\n      return this;\n    }\n\n    public Builder recommendations(Map<String, PackageRef> recommendations) {\n      this.recommendations = recommendations;\n      return this;\n    }\n", "    public Builder recommendations(Map<String, PackageRef> recommendations) {\n      this.recommendations = recommendations;\n      return this;\n    }\n\n    public GraphRequest build() {\n      return new GraphRequest(pkgManager, providers, tree, recommendations);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/CvssParser.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.BiConsumer;\n\nimport com.redhat.exhort.api.CvssVector;", "\nimport com.redhat.exhort.api.CvssVector;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class CvssParser {\n\n  private static final record IndexItem(\n      BiConsumer<String, CvssVector> setter, Map<String, String> parameters) {}\n\n  private static final Map<String, IndexItem> INDEX = new HashMap<>();\n  private static final Map<String, String> ATTACK_VECTORS = new HashMap<>();\n  private static final Map<String, String> ATTACK_COMPLEXITY = new HashMap<>();\n  private static final Map<String, String> PRIVILEGES_REQUIRED = new HashMap<>();\n  private static final Map<String, String> USER_INTERACTION = new HashMap<>();\n  private static final Map<String, String> SCOPE = new HashMap<>();\n  private static final Map<String, String> IMPACT = new HashMap<>();\n  private static final Map<String, String> EXPLOIT_CODE_MATURITY = new HashMap<>();\n  private static final Map<String, String> REMEDIATION_LEVEL = new HashMap<>();\n  private static final Map<String, String> REPORT_CONFIDENCE = new HashMap<>();\n\n  static {\n    INDEX.put(\"AV\", new IndexItem((v, b) -> b.attackVector(v), ATTACK_VECTORS));\n    INDEX.put(\"AC\", new IndexItem((v, b) -> b.attackComplexity(v), ATTACK_COMPLEXITY));\n    INDEX.put(\"PR\", new IndexItem((v, b) -> b.privilegesRequired(v), PRIVILEGES_REQUIRED));\n    INDEX.put(\"UI\", new IndexItem((v, b) -> b.userInteraction(v), USER_INTERACTION));\n    INDEX.put(\"S\", new IndexItem((v, b) -> b.scope(v), SCOPE));\n    INDEX.put(\"C\", new IndexItem((v, b) -> b.confidentialityImpact(v), IMPACT));\n    INDEX.put(\"I\", new IndexItem((v, b) -> b.integrityImpact(v), IMPACT));\n    INDEX.put(\"A\", new IndexItem((v, b) -> b.availabilityImpact(v), IMPACT));\n    INDEX.put(\"E\", new IndexItem((v, b) -> b.exploitCodeMaturity(v), EXPLOIT_CODE_MATURITY));\n    INDEX.put(\"RL\", new IndexItem((v, b) -> b.remediationLevel(v), REMEDIATION_LEVEL));\n    INDEX.put(\"RC\", new IndexItem((v, b) -> b.reportConfidence(v), REPORT_CONFIDENCE));\n\n    ATTACK_VECTORS.put(\"N\", \"Network\");\n    ATTACK_VECTORS.put(\"A\", \"Adjacent Network\");\n    ATTACK_VECTORS.put(\"L\", \"Local\");\n    ATTACK_VECTORS.put(\"P\", \"Physical\");\n\n    ATTACK_COMPLEXITY.put(\"L\", \"Low\");\n    ATTACK_COMPLEXITY.put(\"H\", \"High\");\n\n    PRIVILEGES_REQUIRED.put(\"N\", \"None\");\n    PRIVILEGES_REQUIRED.put(\"L\", \"Low\");\n    PRIVILEGES_REQUIRED.put(\"H\", \"High\");\n\n    USER_INTERACTION.put(\"N\", \"None\");\n    USER_INTERACTION.put(\"R\", \"Required\");\n\n    SCOPE.put(\"U\", \"Unchanged\");\n    SCOPE.put(\"C\", \"Changed\");\n\n    IMPACT.put(\"N\", \"None\");\n    IMPACT.put(\"L\", \"Low\");\n    IMPACT.put(\"H\", \"High\");\n\n    EXPLOIT_CODE_MATURITY.put(\"X\", \"Not Defined\");\n    EXPLOIT_CODE_MATURITY.put(\"U\", \"Unproven that exploit exists\");\n    EXPLOIT_CODE_MATURITY.put(\"P\", \"Proof of concept code\");\n    EXPLOIT_CODE_MATURITY.put(\"F\", \"Functional exploit exists\");\n    EXPLOIT_CODE_MATURITY.put(\"H\", \"High\");\n\n    REMEDIATION_LEVEL.put(\"X\", \"Not Defined\");\n    REMEDIATION_LEVEL.put(\"O\", \"Official fix\");\n    REMEDIATION_LEVEL.put(\"T\", \"Temporary fix\");\n    REMEDIATION_LEVEL.put(\"W\", \"Workaround\");\n    REMEDIATION_LEVEL.put(\"U\", \"Unavailable\");\n\n    REPORT_CONFIDENCE.put(\"X\", \"Not Defined\");\n    REPORT_CONFIDENCE.put(\"U\", \"Unknown\");\n    REPORT_CONFIDENCE.put(\"R\", \"Reasonable\");\n    REPORT_CONFIDENCE.put(\"C\", \"Confirmed\");\n  }\n", "  public static CvssVector fromVectorString(String vector) {\n    Objects.requireNonNull(vector);\n    CvssVector result = new CvssVector();\n    String[] parts = vector.split(\"/\");\n    for (int i = 0; i < parts.length; i++) {\n      String[] metrics = parts[i].split(\":\");\n      if (metrics.length == 2 && INDEX.containsKey(metrics[0])) {\n        IndexItem item = INDEX.get(metrics[0]);\n        String value = item.parameters().get(metrics[1]);\n        item.setter().accept(value, result);\n      }\n    }\n\n    return result.cvss(vector);\n  }\n\n  private CvssParser() {}\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/DependencyTree.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n", "import java.util.Set;\n\nimport com.redhat.exhort.api.PackageRef;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record DependencyTree(PackageRef root, Map<PackageRef, DirectDependency> dependencies) {\n\n  public static final PackageRef getDefaultRoot(String type) {\n    return PackageRef.builder()\n        .pkgManager(type)\n        .namespace(\"com.redhat.exhort\")\n        .name(\"default-app\")\n        .version(\"0.0.1\")\n        .build();\n  }\n\n  public DependencyTree {\n    Objects.requireNonNull(root);", "  public static final PackageRef getDefaultRoot(String type) {\n    return PackageRef.builder()\n        .pkgManager(type)\n        .namespace(\"com.redhat.exhort\")\n        .name(\"default-app\")\n        .version(\"0.0.1\")\n        .build();\n  }\n\n  public DependencyTree {\n    Objects.requireNonNull(root);", "    if (dependencies != null) {\n      dependencies = Collections.unmodifiableMap(dependencies);\n    } else {\n      dependencies = Collections.emptyMap();\n    }\n  }\n\n  public int directCount() {\n    return dependencies.size();\n  }\n", "  public int transitiveCount() {\n    return dependencies.values().stream()\n        .map(d -> d.transitive().size())\n        .reduce(Integer::sum)\n        .orElse(0);\n  }\n\n  public int count() {\n    return directCount() + transitiveCount();\n  }\n\n  public Set<PackageRef> getAll() {\n    Set<PackageRef> result = new HashSet<>(dependencies.keySet());\n    dependencies.values().forEach(d -> result.addAll(d.transitive()));\n    return result;\n  }\n", "  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static class Builder {\n\n    public PackageRef root;\n    public Map<PackageRef, DirectDependency> dependencies;\n\n    public Builder root(PackageRef root) {\n      this.root = root;\n      return this;\n    }\n", "    public Builder root(PackageRef root) {\n      this.root = root;\n      return this;\n    }\n\n    public Builder dependencies(Map<PackageRef, DirectDependency> dependencies) {\n      this.dependencies = dependencies;\n      return this;\n    }\n\n    public DependencyTree build() {\n      return new DependencyTree(root, dependencies);\n    }\n  }\n}\n", "    public DependencyTree build() {\n      return new DependencyTree(root, dependencies);\n    }\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/trustedcontent/MavenPackage.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model.trustedcontent;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record MavenPackage(String artifactId, String groupId, String version) {}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/trustedcontent/VexRequest.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model.trustedcontent;\n\nimport java.util.List;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record VexRequest(List<String> cves) {}\n", "@RegisterForReflection\npublic record VexRequest(List<String> cves) {}\n"]}
{"filename": "src/main/java/com/redhat/exhort/model/trustedcontent/VexResult.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.model.trustedcontent;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic record VexResult(MavenPackage mavenPackage, String productStatus) {}\n"]}
{"filename": "src/main/java/com/redhat/exhort/api/SeverityUtils.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.api;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class SeverityUtils {\n\n  public static Severity fromValue(String value) {\n    if (value == null) {\n      return null;\n    }\n    return Severity.valueOf(value.toUpperCase());\n  }\n\n  // From: https://nvd.nist.gov/vuln-metrics/cvss", "  public static Severity fromValue(String value) {\n    if (value == null) {\n      return null;\n    }\n    return Severity.valueOf(value.toUpperCase());\n  }\n\n  // From: https://nvd.nist.gov/vuln-metrics/cvss\n  public static Severity fromScore(float score) {\n    if (score < 4) {\n      return Severity.LOW;\n    }", "  public static Severity fromScore(float score) {\n    if (score < 4) {\n      return Severity.LOW;\n    }\n    if (score < 7) {\n      return Severity.MEDIUM;\n    }\n    if (score < 9) {\n      return Severity.HIGH;\n    }\n    return Severity.CRITICAL;\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/api/PackageRef.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.api;\n\nimport java.util.Objects;\n\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.github.packageurl.MalformedPackageURLException;\nimport com.github.packageurl.PackageURL;", "import com.github.packageurl.MalformedPackageURLException;\nimport com.github.packageurl.PackageURL;\nimport com.redhat.exhort.api.serialization.PackageURLSerializer;\n\npublic class PackageRef {\n\n  @JsonSerialize(using = PackageURLSerializer.class)\n  @JsonValue\n  private final PackageURL purl;\n\n  public PackageRef(String purl) {\n    Objects.requireNonNull(purl);", "    try {\n      this.purl = new PackageURL(purl);\n    } catch (MalformedPackageURLException e) {\n      throw new IllegalArgumentException(\"Unable to parse PackageURL. \" + e.getMessage());\n    }\n  }\n\n  public PackageRef(PackageURL purl) {\n    Objects.requireNonNull(purl);\n    this.purl = purl;\n  }\n", "  public PackageURL purl() {\n    return purl;\n  }\n\n  public String name() {\n    if (purl.getNamespace() == null) {\n      return purl.getName();\n    }\n    return purl.getNamespace() + \":\" + purl.getName();\n  }\n", "  public String version() {\n    return purl.getVersion();\n  }\n\n  @Override\n  public int hashCode() {\n    return name().hashCode();\n  }\n\n  @Override\n  public boolean equals(Object other) {", "  public boolean equals(Object other) {\n    if (other == null) {\n      return false;\n    }\n    if (!(other instanceof PackageRef)) {\n      return false;\n    }\n    return Objects.equals(name(), ((PackageRef) other).name());\n  }\n\n  public static PackageRef parse(String gav, String pkgManager) {\n    String[] parts = gav.split(\":\");", "  public static PackageRef parse(String gav, String pkgManager) {\n    String[] parts = gav.split(\":\");\n    if (parts.length < 4 || parts.length > 6) {\n      throw new IllegalArgumentException(\"Unexpected GAV format. \" + gav);\n    }\n    if (parts.length < 6) {\n      return builder()\n          .namespace(parts[0])\n          .name(parts[1])\n          .version(parts[3])\n          .pkgManager(pkgManager)\n          .build();\n    }\n    return builder()\n        .namespace(parts[0])\n        .name(parts[1])\n        .version(parts[4])\n        .pkgManager(pkgManager)\n        .build();\n  }\n\n  /**\n   * Convert the instance into URL query string.\n   *\n   * @param prefix prefix of the query string\n   * @return URL query string\n   */", "  public String toUrlQueryString(String prefix) {\n    if (prefix == null) {\n      prefix = \"\";\n    }\n\n    return String.format(\"%s=%s\", prefix, this.toString());\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n", "  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static class Builder {\n\n    String namespace;\n    String name;\n    String version;\n    String pkgManager;\n    String purl;\n", "    public Builder purl(String purl) {\n      this.purl = purl;\n      return this;\n    }\n\n    public Builder pkgManager(String pkgManager) {\n      this.pkgManager = pkgManager;\n      return this;\n    }\n\n    public Builder version(String version) {\n      this.version = version;\n      return this;\n    }\n", "    public Builder version(String version) {\n      this.version = version;\n      return this;\n    }\n\n    public Builder name(String name) {\n      this.name = name;\n      return this;\n    }\n\n    public Builder namespace(String namespace) {\n      this.namespace = namespace;\n      return this;\n    }\n\n    private Builder() {}\n", "    public Builder namespace(String namespace) {\n      this.namespace = namespace;\n      return this;\n    }\n\n    private Builder() {}\n\n    public PackageRef build() {\n      try {\n        if (Objects.isNull(purl)) {\n          Objects.requireNonNull(pkgManager);\n          Objects.requireNonNull(name);\n          Objects.requireNonNull(version);\n          return new PackageRef(new PackageURL(pkgManager, namespace, name, version, null, null));\n        }\n        return new PackageRef(new PackageURL(purl));\n      } catch (MalformedPackageURLException e) {\n        throw new IllegalArgumentException(\"Unable to parse PackageURL. \" + e.getMessage());\n      }\n    }\n  }\n", "      try {\n        if (Objects.isNull(purl)) {\n          Objects.requireNonNull(pkgManager);\n          Objects.requireNonNull(name);\n          Objects.requireNonNull(version);\n          return new PackageRef(new PackageURL(pkgManager, namespace, name, version, null, null));\n        }\n        return new PackageRef(new PackageURL(purl));\n      } catch (MalformedPackageURLException e) {\n        throw new IllegalArgumentException(\"Unable to parse PackageURL. \" + e.getMessage());\n      }\n    }\n  }\n", "  public String toGav() {\n    return String.format(\"%s:%s\", name(), purl.getVersion());\n  }\n\n  @Override\n  public String toString() {\n    return purl.getCoordinates();\n  }\n}\n"]}
{"filename": "src/main/java/com/redhat/exhort/api/serialization/PackageURLSerializer.java", "chunked_list": ["/*\n * Copyright 2023 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *", " *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage com.redhat.exhort.api.serialization;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.ser.std.StdSerializer;\nimport com.github.packageurl.PackageURL;", "import com.fasterxml.jackson.databind.ser.std.StdSerializer;\nimport com.github.packageurl.PackageURL;\n\npublic class PackageURLSerializer extends StdSerializer<PackageURL> {\n\n  public PackageURLSerializer() {\n    this(null);\n  }\n\n  public PackageURLSerializer(Class<PackageURL> c) {\n    super(c);\n  }\n\n  @Override", "  public void serialize(PackageURL value, JsonGenerator gen, SerializerProvider provider)\n      throws IOException {\n    gen.writeString(value.getCoordinates());\n  }\n}\n"]}
