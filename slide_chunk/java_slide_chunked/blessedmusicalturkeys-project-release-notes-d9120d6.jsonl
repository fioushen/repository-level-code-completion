{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/ProjectReleaseNotesApplication.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.CLIStrategy;\nimport java.util.List;\n\n/**\n * Entry point for the application which uses strategy pattern to determine how the request should be handled.\n *\n * @author Timothy Stratton\n */\npublic class ProjectReleaseNotesApplication {\n", " * @author Timothy Stratton\n */\npublic class ProjectReleaseNotesApplication {\n\n  public static void main(String[] args) {\n    List<CLIStrategy> strategies = CLIStrategy.getAllStrategies();\n\n    for (CLIStrategy strategy : strategies) {\n      if (strategy.canHandle(args)) {\n        strategy.handleRequest(args);\n        break;\n      }\n    }\n  }\n\n}\n", "      if (strategy.canHandle(args)) {\n        strategy.handleRequest(args);\n        break;\n      }\n    }\n  }\n\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/cli/CLIStrategy.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.cli;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.impl.HelpStrategy;\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.impl.ChangelogStrategy;\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.impl.ReleaseNotesStrategy;\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.impl.TagStrategy;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**", "\n/**\n * Decided to use the Strategy pattern to handle incoming command-line requests\n *\n * @author    Timothy Stratton\n */\n\npublic interface CLIStrategy {\n  boolean canHandle(String... inputArguments);\n  void handleRequest(String... inputArgument);\n\n  static boolean globalCanHandleRequestChecker(String abbreviatedHandle, String verboseHandle, String[] inputArguments) {\n    return inputArguments != null\n        && (\n        inputArguments[0].equals(abbreviatedHandle)\n            || inputArguments[0].equals(verboseHandle)\n    );\n  }\n\n  /**\n   * This method is used to control the global strategy resolver.\n   * We control both what strategies are visible here\n   * and the order in which they strategies might be checked and applied.\n   *\n   * @return {@link CLIStrategy List of CLIStrategy} containing all possible strategies\n   */\n  static List<CLIStrategy> getAllStrategies() {\n    List<CLIStrategy> strategies = new ArrayList<>();\n\n    //Order matters here\n    strategies.add(new HelpStrategy());\n    strategies.add(new ChangelogStrategy());\n    strategies.add(new ReleaseNotesStrategy());\n    strategies.add(new TagStrategy());\n\n    return strategies;\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/cli/impl/ReleaseNotesStrategy.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.cli.impl;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.CLIStrategy;\n\n/**\n * Generates the Release Notes for a tag of the configured project\n *\n * @author Timothy Stratton\n */\npublic class ReleaseNotesStrategy implements CLIStrategy {\n\n  @Override", " */\npublic class ReleaseNotesStrategy implements CLIStrategy {\n\n  @Override\n  public boolean canHandle(String... inputArguments) {\n\n    return CLIStrategy.globalCanHandleRequestChecker(\"-r\", \"--release-notes\", inputArguments);\n  }\n\n  @Override\n  public void handleRequest(String... inputArgument) {\n    System.out.println(\"Not yet implemented\");\n  }\n}\n", "  public void handleRequest(String... inputArgument) {\n    System.out.println(\"Not yet implemented\");\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/cli/impl/TagStrategy.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.cli.impl;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.CLIStrategy;\n\n/**\n * Tags the configured project and pushes the tag to origin\n *\n * @author Timothy Stratton\n */\npublic class TagStrategy implements CLIStrategy {\n\n  @Override", " */\npublic class TagStrategy implements CLIStrategy {\n\n  @Override\n  public boolean canHandle(String... inputArguments) {\n\n    return CLIStrategy.globalCanHandleRequestChecker(\"-t\", \"--tag\", inputArguments);\n  }\n\n  @Override\n  public void handleRequest(String... inputArgument) {\n    System.out.println(\"Not yet implemented\");\n  }\n}\n", "  public void handleRequest(String... inputArgument) {\n    System.out.println(\"Not yet implemented\");\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/cli/impl/HelpStrategy.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.cli.impl;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.CLIStrategy;\n\n/**\n * Simple Helper processors which provides users with all possible configurations\n * and operations available to them\n *\n * @author    Timothy Stratton\n */", " * @author    Timothy Stratton\n */\n\npublic class HelpStrategy implements CLIStrategy {\n\n  @Override\n  public boolean canHandle(String... inputArguments) {\n    return CLIStrategy.globalCanHandleRequestChecker(\"-h\", \"--help\", inputArguments);\n  }\n\n  @Override", "  public void handleRequest(String... inputArgument) {\n    StringBuilder output = new StringBuilder();\n\n    output.append(\"Usage: \").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-h | --help)\").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-c | --changelog) --incrementVersion=(MAJOR | MINOR | PATCH)\").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-c | --changelog) --tag=<tag-name\").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-c | --changelog) --full\").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-t | --tag) <tag-name>\").append(\"\\n\");\n    output.append(\"\\tjava -cp project-release-notes.jar com.blessedmusicalturkeys.projectreleasenotes.ProjectReleaseNotesApplication (-r | --release-notes) <email-to-send-release-notes-to> [<space-delimited-emails-to-send-release-notes-to>...]\").append(\"\\n\");\n\n    System.out.println(output);\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/cli/impl/ChangelogStrategy.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.cli.impl;\n\nimport com.atlassian.jira.rest.client.api.domain.Issue;\nimport com.blessedmusicalturkeys.projectreleasenotes.cli.CLIStrategy;\nimport com.blessedmusicalturkeys.projectreleasenotes.constants.SemanticVersion;\nimport com.blessedmusicalturkeys.projectreleasenotes.utilities.ChangelogGenerator;\nimport com.blessedmusicalturkeys.projectreleasenotes.utilities.JGit;\nimport com.blessedmusicalturkeys.projectreleasenotes.utilities.JiraClient;\nimport java.io.IOException;\nimport java.net.URISyntaxException;", "import java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.util.Collections;\nimport java.util.List;\nimport lombok.extern.slf4j.Slf4j;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.errors.MissingObjectException;\n\n/**\n * Generates the Changelog for the configured project", "/**\n * Generates the Changelog for the configured project\n *\n * @author Timothy Stratton\n */\n@Slf4j\npublic class ChangelogStrategy implements CLIStrategy {\n\n  @Override\n  public boolean canHandle(String... inputArguments) {\n    return CLIStrategy.globalCanHandleRequestChecker(\"-c\", \"--changelog\", inputArguments);\n  }\n\n  @Override", "  public boolean canHandle(String... inputArguments) {\n    return CLIStrategy.globalCanHandleRequestChecker(\"-c\", \"--changelog\", inputArguments);\n  }\n\n  @Override\n  public void handleRequest(String... inputArgument) {\n    log.info(\"Changelog Generation request received...\");\n\n    JGit gitClient;\n    JiraClient jiraClient;\n    ChangelogGenerator changelogGenerator;\n\n    log.info(\"Initializing the System...\");", "    try {\n      gitClient = new JGit();\n      jiraClient = new JiraClient();\n      changelogGenerator = new ChangelogGenerator();\n    } catch (GitAPIException | IOException | URISyntaxException e) {\n      log.error(\"Initialization exception: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n\n    log.info(\"Pulling all existing tags...\");\n    List<String> tags  = getAllTags(gitClient);\n\n    log.info(\"Generating changelog...\");\n    String tagName = processGenerateChangelogRequest(gitClient, jiraClient, changelogGenerator, tags, inputArgument);\n\n    log.info(\"Committing changelog to new tag, merging to the make working trunk, and pushing...\");", "    try {\n      gitClient.commitChangelogTagAndPush(tagName);\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Unable to commit the changelog due to: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n\n    log.info(\"Changelog Generation Complete.\");\n  }\n\n  private String processGenerateChangelogRequest(JGit gitClient, JiraClient jiraClient, ChangelogGenerator changelogGenerator,\n      List<String> tags, String... inputArgument) {\n    String tagName;\n    int numOfInputArguments = inputArgument.length;\n", "    try {\n      if (numOfInputArguments == 2 && inputArgument[1].startsWith(\"--incrementVersion\")) {\n        String versioningStrategy = inputArgument[1].split(\"--incrementVersion=\")[1];\n        List<String> issueKeys = gitClient.getAllIssuesSinceLastTag();\n\n        tagName = incrementReleaseNumber(tags, versioningStrategy);\n\n        generateChangelog(gitClient, jiraClient, changelogGenerator, tagName, issueKeys);\n      } else if (numOfInputArguments == 2 && inputArgument[1].startsWith(\"--tag\")) {\n        String tagToGenerateChangelogFor = inputArgument[1].split(\"--tag=\")[1];\n        int tagIndex = tags.indexOf(tagToGenerateChangelogFor);\n        tagName = tags.get(tagIndex);\n\n        List<String> issueKeys = gitClient.getIssuesWithinTag(tagName);\n\n        generateChangelog(gitClient, jiraClient, changelogGenerator, tagName, issueKeys);", "      } else if (numOfInputArguments == 2 && inputArgument[1].startsWith(\"--tag\")) {\n        String tagToGenerateChangelogFor = inputArgument[1].split(\"--tag=\")[1];\n        int tagIndex = tags.indexOf(tagToGenerateChangelogFor);\n        tagName = tags.get(tagIndex);\n\n        List<String> issueKeys = gitClient.getIssuesWithinTag(tagName);\n\n        generateChangelog(gitClient, jiraClient, changelogGenerator, tagName, issueKeys);\n      } else if (numOfInputArguments == 2 && inputArgument[1].startsWith(\"--full\")) {\n        for (String tag : tags) {\n          List<String> issueKeys = gitClient.getIssuesWithinTag(tag);\n\n          generateChangelog(gitClient, jiraClient, changelogGenerator, tag, issueKeys);\n        }\n        tagName = \"full-changelog-generation\";\n      } else {\n        log.info(\"Unsupported Operation requested. Rerun with `--help` option to see available operations\");\n        throw new RuntimeException(\"Unsupported Operation\");\n      }\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Unable to generate the changelog due to: [{}]\", e.getMessage() , e);\n      throw new RuntimeException(e);\n    }\n\n    return tagName;\n  }\n\n  private String incrementReleaseNumber(List<String> tags, String versioningStrategy) {\n    String tagName = null;\n    SemanticVersion incrementVersionBy;", "      } else if (numOfInputArguments == 2 && inputArgument[1].startsWith(\"--full\")) {\n        for (String tag : tags) {\n          List<String> issueKeys = gitClient.getIssuesWithinTag(tag);\n\n          generateChangelog(gitClient, jiraClient, changelogGenerator, tag, issueKeys);\n        }\n        tagName = \"full-changelog-generation\";\n      } else {\n        log.info(\"Unsupported Operation requested. Rerun with `--help` option to see available operations\");\n        throw new RuntimeException(\"Unsupported Operation\");\n      }\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Unable to generate the changelog due to: [{}]\", e.getMessage() , e);\n      throw new RuntimeException(e);\n    }\n\n    return tagName;\n  }\n\n  private String incrementReleaseNumber(List<String> tags, String versioningStrategy) {\n    String tagName = null;\n    SemanticVersion incrementVersionBy;", "    try {\n      incrementVersionBy = SemanticVersion.valueOf(versioningStrategy);\n    } catch (IllegalArgumentException e) {\n      String semanticVersioningRegex = \"^([0-9]+)\\\\.([0-9]+)\\\\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\\\\.[0-9A-Za-z-]+)*))?(?:\\\\+[0-9A-Za-z-]+)?$\";\n\n      if (versioningStrategy.matches(semanticVersioningRegex)) {\n        return versioningStrategy;\n      } else {\n        log.info(\"Version flag must equal: `MAJOR`, `MINOR`, `PATCH`, or provide an explicit semantic version, e.g. 1.2.3\");\n        throw new RuntimeException(\"Unsupported Versioning Strategy\");\n      }\n    }\n\n    String[] lastTag = tags.get(tags.size()-1).split(\"\\\\.\");\n", "    if (SemanticVersion.MAJOR == incrementVersionBy) {\n      int majorVersion = Integer.parseInt(lastTag[0])+1;\n      tagName = majorVersion + \".0.0\";\n    } else if (SemanticVersion.MINOR == incrementVersionBy) {\n      int minorVersion = Integer.parseInt(lastTag[1])+1;\n      tagName = lastTag[0] + \".\" + minorVersion + \".0\";\n    } else if (SemanticVersion.PATCH == incrementVersionBy) {\n      int patchVersion = Integer.parseInt(lastTag[2])+1;\n      tagName = lastTag[0] + \".\" + lastTag[1] + \".\" + patchVersion;\n    }\n\n    return tagName;\n  }\n\n  private List<String> getAllTags(JGit gitClient) {\n    List<String> tags;", "    try {\n      tags = gitClient.listTags();\n    } catch (MissingObjectException | GitAPIException e) {\n      log.error(\"Unable to retrieve tags for the GIT repo due to: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n    Collections.reverse(tags);\n    return tags;\n  }\n\n  private void generateChangelog(JGit gitClient, JiraClient jiraClient, ChangelogGenerator changelogGenerator, String tagName, List<String> jiraIssueKeys)\n      throws IOException {\n    List<Issue> jiraIssues = jiraClient.getIssueList(jiraIssueKeys);\n\n    changelogGenerator.generateChangelogFromExisting(gitClient.getWorkingDir(), tagName, jiraIssues);\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/constants/SemanticVersion.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.constants;\n\npublic enum SemanticVersion {\n  MAJOR, MINOR, PATCH\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/constants/ApplicationConstants.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.constants;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.utilities.EnvironmentVariables;\n\npublic class ApplicationConstants {\n  public static final String CONST_GIT_REPOSITORY_URL = EnvironmentVariables.getString(\"GIT_REPO_URL\");\n  public static final String CONST_GIT_REPOSITORY_PRIVATE_KEY = EnvironmentVariables.getBase64EncodedString(\"GIT_PRIVATE_KEY\");\n  public static final String CONST_GIT_USERNAME = EnvironmentVariables.getString(\"GIT_USERNAME\");\n  public static final String CONST_GIT_PASSWORD = EnvironmentVariables.getString(\"GIT_PASSWORD\");\n  public static final String CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM = EnvironmentVariables.getString(\"GIT_WORKING_TRUNK\");\n", "  public static final String CONST_GIT_PASSWORD = EnvironmentVariables.getString(\"GIT_PASSWORD\");\n  public static final String CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM = EnvironmentVariables.getString(\"GIT_WORKING_TRUNK\");\n\n  public static final String CONST_JIRA_BASE_URL = EnvironmentVariables.getString(\"JIRA_URL\");\n  public static final String CONST_JIRA_USER_NAME = EnvironmentVariables.getString(\"JIRA_SERVICE_ACCOUNT_USERNAME\");\n  public static final String CONST_JIRA_API_KEY = EnvironmentVariables.getString(\"JIRA_SERVICE_ACCOUNT_API_KEY\");\n  public static final String CONST_JIRA_PROJECT_KEY = EnvironmentVariables.getString(\"JIRA_PROJECT_KEY\");\n\n  public static final Boolean CONST_PREPEND_TO_CHANGELOG = EnvironmentVariables.getBoolean(\"PREPEND_TO_CHANGELOG\");\n}\n", "  public static final Boolean CONST_PREPEND_TO_CHANGELOG = EnvironmentVariables.getBoolean(\"PREPEND_TO_CHANGELOG\");\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/utilities/EnvironmentVariables.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.utilities;\n\nimport java.util.Base64;\nimport org.apache.commons.lang3.ObjectUtils.Null;\n\n/**\n * Simple Environment Vars getter\n *\n * @author Timothy Stratton\n */\npublic class EnvironmentVariables {", " * @author Timothy Stratton\n */\npublic class EnvironmentVariables {\n  public static String getString(String variableName) {\n    try {\n      return System.getenv(variableName);\n    } catch (Exception e) {\n      return null;\n    }\n  }\n", "  public static String getBase64EncodedString(String variableName) {\n    String encodedVariable = System.getenv(variableName);\n    try {\n      return new String(Base64.getDecoder().decode(encodedVariable));\n    } catch (NullPointerException e) {\n      return null;\n    }\n  }\n\n  public static Integer getInt(String variableName) {\n    return Integer.parseInt(System.getenv(variableName));\n  }\n", "  public static Integer getInt(String variableName) {\n    return Integer.parseInt(System.getenv(variableName));\n  }\n\n  public static Long getLong(String variableName) {\n    return Long.parseLong(System.getenv(variableName));\n  }\n\n  public static Double getDouble(String variableName) {\n    return Double.parseDouble(System.getenv(variableName));\n  }\n", "  public static Double getDouble(String variableName) {\n    return Double.parseDouble(System.getenv(variableName));\n  }\n\n  public static Boolean getBoolean(String variableName) {\n    return Boolean.parseBoolean(System.getenv(variableName));\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/utilities/ChangelogGenerator.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.utilities;\n\nimport com.atlassian.jira.rest.client.api.domain.Issue;\nimport com.blessedmusicalturkeys.projectreleasenotes.constants.ApplicationConstants;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.List;\nimport net.steppschuh.markdowngenerator.rule.HorizontalRule;", "import java.util.List;\nimport net.steppschuh.markdowngenerator.rule.HorizontalRule;\nimport net.steppschuh.markdowngenerator.text.heading.Heading;\n\n/**\n * Generates the Changelog for a given List of JIRA issues\n *\n * @author Timothy Stratton\n */\npublic class ChangelogGenerator {\n", " */\npublic class ChangelogGenerator {\n\n  public void generateChangelogFromExisting(File repoDir, String releaseName, List<Issue> issues) throws IOException {\n    StringBuilder changelogBuilder = new StringBuilder();\n\n    changelogBuilder.append(new Heading(\"Release \" + releaseName, 1)).append(\"\\n\");\n\n    //Story tickets\n    changelogBuilder.append(new Heading(\"Stories Completed\", 2)).append(\"\\n\");\n    for (Issue issue : issues) {", "    for (Issue issue : issues) {\n      if (issue.getIssueType().getName().equals(\"Story\")) {\n        changelogBuilder.append(new Heading(issue.getKey(), 3)).append(\"\\n\");\n        changelogBuilder.append(new Heading(issue.getSummary(), 4)).append(\"\\n\");\n        changelogBuilder.append(new Heading(issue.getDescription(), 5)).append(\"\\n\\n\");\n      }\n    }\n\n    //Bug Tickets\n    changelogBuilder.append(new Heading(\"Bugs Fixed\", 2)).append(\"\\n\");\n    for (Issue issue : issues) {", "    for (Issue issue : issues) {\n      if (issue.getIssueType().getName().equals(\"Bug\")) {\n        changelogBuilder.append(new Heading(issue.getKey(), 3)).append(\"\\n\");\n        changelogBuilder.append(new Heading(issue.getSummary(), 4)).append(\"\\n\");\n        changelogBuilder.append(new Heading(issue.getDescription(), 5)).append(\"\\n\\n\");\n      }\n    }\n\n    writeChangeLog(repoDir, changelogBuilder.toString(), ApplicationConstants.CONST_PREPEND_TO_CHANGELOG);\n  }\n", "  public void writeChangeLog(File repoDir, String fileContent, boolean... prepend) throws IOException {\n    File changelogDirectory = new File(repoDir.getAbsolutePath() + \"/changelog\");\n    boolean changelogDirExists = changelogDirectory.mkdirs();\n    File changelogFile = new File(changelogDirectory, \"changelog.md\");\n    boolean changelogFileExists = changelogFile.createNewFile();\n\n    if (changelogDirExists && !changelogFileExists && prepend != null && prepend[0]) {\n      FileInputStream fis = new FileInputStream(changelogFile);\n      byte[] buffer = new byte[10];\n      StringBuilder sb = new StringBuilder();\n      while (fis.read(buffer) != -1) {\n        sb.append(new String(buffer));\n        buffer = new byte[10];\n      }\n      fis.close();\n\n      String content = sb.toString();\n\n      fileContent = fileContent + new HorizontalRule(20, HorizontalRule.ASTERISK) + \"\\n\\n\" + content;\n    }\n\n    FileOutputStream outputStream = new FileOutputStream(changelogFile);\n    byte[] strToBytes = fileContent.getBytes();\n    outputStream.write(strToBytes);\n    outputStream.close();\n  }\n}\n", "      while (fis.read(buffer) != -1) {\n        sb.append(new String(buffer));\n        buffer = new byte[10];\n      }\n      fis.close();\n\n      String content = sb.toString();\n\n      fileContent = fileContent + new HorizontalRule(20, HorizontalRule.ASTERISK) + \"\\n\\n\" + content;\n    }\n\n    FileOutputStream outputStream = new FileOutputStream(changelogFile);\n    byte[] strToBytes = fileContent.getBytes();\n    outputStream.write(strToBytes);\n    outputStream.close();\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/utilities/JGit.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.utilities;\n\nimport com.blessedmusicalturkeys.projectreleasenotes.constants.ApplicationConstants;\nimport com.jcraft.jsch.JSch;\nimport com.jcraft.jsch.JSchException;\nimport com.jcraft.jsch.Session;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;", "import java.util.Map;\nimport java.util.Set;\nimport lombok.extern.slf4j.Slf4j;\nimport org.eclipse.jgit.api.CheckoutCommand;\nimport org.eclipse.jgit.api.CommitCommand;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.MergeCommand;\nimport org.eclipse.jgit.api.MergeResult;\nimport org.eclipse.jgit.api.TagCommand;\nimport org.eclipse.jgit.api.TransportConfigCallback;", "import org.eclipse.jgit.api.TagCommand;\nimport org.eclipse.jgit.api.TransportConfigCallback;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.transport.PushResult;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.RemoteRefUpdate.Status;\nimport org.eclipse.jgit.transport.SshSessionFactory;", "import org.eclipse.jgit.transport.RemoteRefUpdate.Status;\nimport org.eclipse.jgit.transport.SshSessionFactory;\nimport org.eclipse.jgit.transport.SshTransport;\nimport org.eclipse.jgit.transport.Transport;\nimport org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;\nimport org.eclipse.jgit.transport.ssh.jsch.JschConfigSessionFactory;\nimport org.eclipse.jgit.transport.ssh.jsch.OpenSshConfig;\nimport org.eclipse.jgit.util.FS;\n\n/**", "\n/**\n * Class that connects to the provided GIT repository and performs GIT operations on it\n *\n * @author Timothy Stratton\n */\n@Slf4j\npublic class JGit {\n\n  public static final String REFS_TAGS = \"refs/tags/\";\n  public static final String REFS_HEADS = \"refs/heads/\";\n  private final String gitPrivateKey;\n  private final Git git;\n  private final File workingDir;\n\n  private final String CONST_MERGE_PREAMBLE = \"Merged in\";\n\n  private final Set<String> typicalGitFolders = Set\n      .of(\"\", //no folder\n          \"feature/\", \"features/\",\n          \"hotfix/\", \"hotfixes/\",\n          \"fix/\", \"fixes/\",\n          \"bug/\", \"bugs/\",\n          \"bugfix/\", \"bugfixes/\",\n          \"release/\", \"releases/\");\n\n  public JGit() throws IOException, GitAPIException {\n    this.workingDir = Files.createTempDirectory(\"workspace\").toFile();\n    this.gitPrivateKey = ApplicationConstants.CONST_GIT_REPOSITORY_PRIVATE_KEY;\n\n    String gitUsername = ApplicationConstants.CONST_GIT_USERNAME;\n    String gitPassword = ApplicationConstants.CONST_GIT_PASSWORD;\n", "  public static final String REFS_TAGS = \"refs/tags/\";\n  public static final String REFS_HEADS = \"refs/heads/\";\n  private final String gitPrivateKey;\n  private final Git git;\n  private final File workingDir;\n\n  private final String CONST_MERGE_PREAMBLE = \"Merged in\";\n\n  private final Set<String> typicalGitFolders = Set\n      .of(\"\", //no folder\n          \"feature/\", \"features/\",\n          \"hotfix/\", \"hotfixes/\",\n          \"fix/\", \"fixes/\",\n          \"bug/\", \"bugs/\",\n          \"bugfix/\", \"bugfixes/\",\n          \"release/\", \"releases/\");\n\n  public JGit() throws IOException, GitAPIException {\n    this.workingDir = Files.createTempDirectory(\"workspace\").toFile();\n    this.gitPrivateKey = ApplicationConstants.CONST_GIT_REPOSITORY_PRIVATE_KEY;\n\n    String gitUsername = ApplicationConstants.CONST_GIT_USERNAME;\n    String gitPassword = ApplicationConstants.CONST_GIT_PASSWORD;\n", "    if (this.gitPrivateKey != null && !this.gitPrivateKey.isEmpty() && ApplicationConstants.CONST_GIT_REPOSITORY_URL != null\n        && ApplicationConstants.CONST_GIT_REPOSITORY_URL.startsWith(\"git@\")) { //ssh connection starts with `git@`\n      git = Git.cloneRepository()\n          .setDirectory(workingDir)\n          .setTransportConfigCallback(new SshTransportConfigCallback())\n          .setURI(ApplicationConstants.CONST_GIT_REPOSITORY_URL)\n          .call();\n      log.info(\"Generating changelog from working branch [{}] with SSH Credentials\", ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM);\n\n    } else if (gitUsername != null && gitPassword != null && ApplicationConstants.CONST_GIT_REPOSITORY_URL != null\n        && ApplicationConstants.CONST_GIT_REPOSITORY_URL.startsWith(\"https://\")){\n      git = Git.cloneRepository()\n          .setDirectory(workingDir)\n          .setURI(ApplicationConstants.CONST_GIT_REPOSITORY_URL)\n          .setCredentialsProvider(\n              new UsernamePasswordCredentialsProvider(ApplicationConstants.CONST_GIT_USERNAME,\n                  ApplicationConstants.CONST_GIT_PASSWORD))\n          .call();\n\n      log.info(\"Generating changelog from working branch [{}] with GIT User [{}]...\", ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM, ApplicationConstants.CONST_GIT_USERNAME);\n    } else {\n      log.info(\"GIT usage:\");\n      log.info(\"    SSH or HTTPS only.\");\n      log.info(\"    For SSH:\");\n      log.info(\"        Must provide env vars GIT_PRIVATE_KEY and GIT_REPO_URL. GIT_REPO_URL must start with `git@` for `git@<domain>/<repository>.git\");\n      log.info(\"    For HTTP:\");\n      log.info(\"        Must provide env vars GIT_USERNAME, GIT_PASSWORD, and GIT_REPO_URL. GIT_REPO_URL must start with `https://` for `https://<domain>/<repository>.git\");\n\n      throw new RuntimeException(\"Unsupported GIT Operation\");\n    }\n\n    git.checkout().setName(ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM).call();\n  }\n\n  public List<String> listTags() throws MissingObjectException, GitAPIException {\n    Set<String> tags = new LinkedHashSet<>();\n\n    Iterable<RevCommit> commits = git.log().call();", "    } else if (gitUsername != null && gitPassword != null && ApplicationConstants.CONST_GIT_REPOSITORY_URL != null\n        && ApplicationConstants.CONST_GIT_REPOSITORY_URL.startsWith(\"https://\")){\n      git = Git.cloneRepository()\n          .setDirectory(workingDir)\n          .setURI(ApplicationConstants.CONST_GIT_REPOSITORY_URL)\n          .setCredentialsProvider(\n              new UsernamePasswordCredentialsProvider(ApplicationConstants.CONST_GIT_USERNAME,\n                  ApplicationConstants.CONST_GIT_PASSWORD))\n          .call();\n\n      log.info(\"Generating changelog from working branch [{}] with GIT User [{}]...\", ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM, ApplicationConstants.CONST_GIT_USERNAME);\n    } else {\n      log.info(\"GIT usage:\");\n      log.info(\"    SSH or HTTPS only.\");\n      log.info(\"    For SSH:\");\n      log.info(\"        Must provide env vars GIT_PRIVATE_KEY and GIT_REPO_URL. GIT_REPO_URL must start with `git@` for `git@<domain>/<repository>.git\");\n      log.info(\"    For HTTP:\");\n      log.info(\"        Must provide env vars GIT_USERNAME, GIT_PASSWORD, and GIT_REPO_URL. GIT_REPO_URL must start with `https://` for `https://<domain>/<repository>.git\");\n\n      throw new RuntimeException(\"Unsupported GIT Operation\");\n    }\n\n    git.checkout().setName(ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM).call();\n  }\n\n  public List<String> listTags() throws MissingObjectException, GitAPIException {\n    Set<String> tags = new LinkedHashSet<>();\n\n    Iterable<RevCommit> commits = git.log().call();", "    for (RevCommit commit : commits) {\n      Map<ObjectId, String> namedCommits = git.nameRev().addPrefix(REFS_TAGS).add(commit).call();\n      if (namedCommits.containsKey(commit.getId()) && !namedCommits.get(commit.getId())\n          .contains(\"~\")) {\n        tags.add(namedCommits.get(commit.getId()));\n      }\n    }\n\n    return new ArrayList<>(tags);\n  }\n\n  public List<String> getAllIssuesSinceLastTag()\n      throws GitAPIException, MissingObjectException {\n    Set<String> issues = new LinkedHashSet<>();\n    Date dateOfLastTag = null;\n\n    //retrieve the date of the last tag\n    Iterable<RevCommit> commits = git.log().call();", "    for (RevCommit commit : commits) {\n      Map<ObjectId, String> namedCommits = git.nameRev().addPrefix(REFS_TAGS).add(commit).call();\n      if (namedCommits.containsKey(commit.getId())) {\n        dateOfLastTag = commit.getAuthorIdent().getWhen();\n        break;\n      }\n    }\n\n    // get all merged issues since the last tag\n    commits = git.log().call();\n    for (RevCommit commit : commits) {", "    for (RevCommit commit : commits) {\n      if (commit.getAuthorIdent().getWhen().compareTo(dateOfLastTag) > 0\n          && commit.getShortMessage().contains(CONST_MERGE_PREAMBLE)) {\n        assert ApplicationConstants.CONST_JIRA_PROJECT_KEY != null;\n        if (commit.getShortMessage().contains(ApplicationConstants.CONST_JIRA_PROJECT_KEY)) {\n          issues.add(parseIssueKeyFromCommit(commit));\n        }\n      }\n    }\n\n    return new ArrayList<>(issues);\n  }\n\n  public List<String> getIssuesWithinTag(String tagName)\n      throws GitAPIException, MissingObjectException {\n    Set<String> issues = new LinkedHashSet<>();\n\n    Iterable<RevCommit> commits = git.log().call();", "    for (RevCommit commit : commits) {\n      Map<ObjectId, String> namedCommits = git.nameRev().addPrefix(REFS_TAGS).add(commit).call();\n      if (namedCommits.containsKey(commit.getId())\n          && commit.getShortMessage().contains(CONST_MERGE_PREAMBLE)\n          && namedCommits.get(commit.getId()).contains(tagName)\n      ) {\n        issues.add(parseIssueKeyFromCommit(commit));\n      }\n    }\n\n    return new ArrayList<>(issues);\n  }\n\n  private String parseIssueKeyFromCommit(RevCommit commit) {\n    String unparsedIssueString;\n", "    for (String gitFolder : typicalGitFolders) {\n      try {\n        unparsedIssueString = commit.getShortMessage()\n            .split(CONST_MERGE_PREAMBLE + \" \" + gitFolder + ApplicationConstants.CONST_JIRA_PROJECT_KEY)[1];\n\n        return ApplicationConstants.CONST_JIRA_PROJECT_KEY + \"-\" + unparsedIssueString.split(\"-\")[1];\n      } catch (IndexOutOfBoundsException e) { /* nothing to be done, continue */ }\n    }\n\n    log.info(\"Unable to parse Issue Number from commit: [{}]\", commit.getShortMessage());\n    throw new RuntimeException(\"Unsupported Git Folder Structure\");\n  }\n", "  public void commitChangelogTagAndPush(String releaseName) throws GitAPIException, IOException {\n    String changelogBranchName = checkoutChangelogBranchCommitAndTag(releaseName);\n\n    mergeChangelogBranchIntoWorkingTrunk(changelogBranchName);\n\n    Iterable<PushResult> pushResults = null;\n    if (this.gitPrivateKey != null && !this.gitPrivateKey.isEmpty() && ApplicationConstants.CONST_GIT_REPOSITORY_URL != null\n        && ApplicationConstants.CONST_GIT_REPOSITORY_URL.startsWith(\"git@\")) {\n      pushResults = git.push()\n          .setPushTags()\n          .setTransportConfigCallback(new SshTransportConfigCallback())\n          .setRefSpecs(new RefSpec(REFS_HEADS + ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM))\n          .setForce(true)\n          .call();\n    } else {\n      pushResults = git.push()\n          .setPushTags()\n          .setCredentialsProvider(new UsernamePasswordCredentialsProvider(ApplicationConstants.CONST_GIT_USERNAME,\n              ApplicationConstants.CONST_GIT_PASSWORD))\n          .setRefSpecs(new RefSpec(ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM))\n          .setForce(true)\n          .call();\n    }\n\n    printPushResultStatus(pushResults);;\n  }\n", "  public void mergeChangelogBranchIntoWorkingTrunk(String changelogBranchName)\n      throws IOException, GitAPIException {\n    CheckoutCommand checkoutCmd = git.checkout();\n    checkoutCmd.setName(ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM);\n    checkoutCmd.setCreateBranch(false);\n    checkoutCmd.call();\n\n    ObjectId mergeBase = git.getRepository().resolve(changelogBranchName);\n\n    MergeResult merge = git.merge()\n        .include(mergeBase)\n        .setCommit(true)\n        .setFastForward(MergeCommand.FastForwardMode.NO_FF)\n        .setMessage(\"Merged in [\" + changelogBranchName + \"] to [\" + ApplicationConstants.CONST_GIT_WORKING_TRUNK_TO_BRANCH_FROM + \"]\")\n        .call();\n\n    log.info(\"Merge Successful: [{}], Merge Status: [{}]...\", merge.getMergeStatus().isSuccessful(), merge.getMergeStatus());\n", "    if (merge.getConflicts() != null) {//should not have conflict b/c of this trivial change\n      for (Map.Entry<String, int[][]> entry : merge.getConflicts().entrySet()) {\n        log.info(\"Key: [{}]\", entry.getKey());\n        for (int[] arr : entry.getValue()) {\n          log.info(\"value: [{}]\", Arrays.toString(arr));\n        }\n      }\n    }\n  }\n\n  private String checkoutChangelogBranchCommitAndTag(String releaseName) throws GitAPIException {\n    String changelogBranchName = \"update-changelog-\" + new Date().getTime();\n    git.checkout().setCreateBranch(true).setName(changelogBranchName).call();\n\n    git.add().addFilepattern(\"changelog\").call();\n\n    CommitCommand commitCommand = git.commit();\n    commitCommand.setAuthor(\"project-release-notes\", \"no@no.com\");\n    commitCommand.setMessage(\"Generated Changelog for release [\" + releaseName + \"] at [\" + LocalDateTime.now() + \"]\");\n    RevCommit commit = commitCommand.call();\n\n    TagCommand tagCommand = git.tag();\n    tagCommand.setObjectId(commit);\n    tagCommand.setName(releaseName);\n    tagCommand.call();\n\n    Iterable<PushResult> pushResults = null;", "    if (this.gitPrivateKey != null && !this.gitPrivateKey.isEmpty() && ApplicationConstants.CONST_GIT_REPOSITORY_URL != null\n        && ApplicationConstants.CONST_GIT_REPOSITORY_URL.startsWith(\"git@\")) {\n      pushResults = git.push()\n          .setPushTags()\n          .setTransportConfigCallback(new SshTransportConfigCallback())\n          .call();\n    } else {\n      pushResults = git.push()\n          .setPushTags()\n          .setCredentialsProvider(new UsernamePasswordCredentialsProvider(ApplicationConstants.CONST_GIT_USERNAME,\n              ApplicationConstants.CONST_GIT_PASSWORD))\n          .call();\n    }\n\n    printPushResultStatus(pushResults);\n\n    return changelogBranchName;\n  }\n\n  private void printPushResultStatus(Iterable<PushResult> pushResults) {\n    pushResults.forEach(pushResult -> {\n      pushResult.getRemoteUpdates().forEach(remoteRefUpdate -> {", "            if ((remoteRefUpdate.getStatus().compareTo(Status.UP_TO_DATE) == 0) //Ref is up to date\n                || (remoteRefUpdate.getStatus().compareTo(Status.OK) == 0)) { //Or Ref was updated successfully\n              log.info(\"Push Ref: [{}], Push Status: [{}], Push Message: [{}]...\",\n                  remoteRefUpdate.getRemoteName(), remoteRefUpdate.getStatus(), remoteRefUpdate.getMessage());\n            } else {\n              log.warn(\"Push Ref: [{}], Push Status: [{}], Push Error Message: [{}]...\",\n                  remoteRefUpdate.getRemoteName(), remoteRefUpdate.getStatus(), remoteRefUpdate.getMessage());\n            }\n          }\n      );\n    });\n  }\n", "  public File getWorkingDir() {\n    return this.workingDir;\n  }\n\n  private class SshTransportConfigCallback implements TransportConfigCallback {\n\n    private final SshSessionFactory sshSessionFactory = new JschConfigSessionFactory() {\n      @Override\n      protected void configure(OpenSshConfig.Host hc, Session session) {\n        session.setConfig(\"StrictHostKeyChecking\", \"no\");\n      }\n\n      @Override\n      protected JSch createDefaultJSch(FS fs) throws JSchException {\n        File privateKeyFile = createPrivateKeyFile();\n        JSch jSch = super.createDefaultJSch(fs);\n        jSch.removeAllIdentity();\n        jSch.addIdentity(privateKeyFile.getAbsolutePath());\n        return jSch;\n      }\n    };\n\n    private File createPrivateKeyFile() {", "      try {\n        File privateKeyFile = Files.createTempFile(\"id_rsa\", \"\").toFile();\n        FileOutputStream outputStream = new FileOutputStream(privateKeyFile);\n        byte[] strToBytes = gitPrivateKey.getBytes();\n        outputStream.write(strToBytes);\n        outputStream.close();\n        return privateKeyFile;\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    @Override", "    public void configure(Transport transport) {\n      SshTransport sshTransport = (SshTransport) transport;\n      sshTransport.setSshSessionFactory(sshSessionFactory);\n    }\n\n  }\n}\n"]}
{"filename": "src/main/java/com/blessedmusicalturkeys/projectreleasenotes/utilities/JiraClient.java", "chunked_list": ["package com.blessedmusicalturkeys.projectreleasenotes.utilities;\n\nimport com.atlassian.jira.rest.client.api.IssueRestClient;\nimport com.atlassian.jira.rest.client.api.JiraRestClient;\nimport com.atlassian.jira.rest.client.api.JiraRestClientFactory;\nimport com.atlassian.jira.rest.client.api.RestClientException;\nimport com.atlassian.jira.rest.client.api.domain.Issue;\nimport com.atlassian.jira.rest.client.internal.async.AsynchronousJiraRestClientFactory;\nimport com.blessedmusicalturkeys.projectreleasenotes.constants.ApplicationConstants;\nimport java.net.URI;", "import com.blessedmusicalturkeys.projectreleasenotes.constants.ApplicationConstants;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * For those projects using JIRA to track issues, this class will connect to your JIRA\n * and link the tickets within source control to the generated changelogs/release notes\n *", " * and link the tickets within source control to the generated changelogs/release notes\n *\n * TODO: A ticket client factory that we pull from based on input args\n *\n * @author Timothy Stratton\n */\npublic class JiraClient {\n\n  private final JiraRestClient client;\n\n  public JiraClient() throws URISyntaxException {\n    JiraRestClientFactory factory = new AsynchronousJiraRestClientFactory();\n\n    URI uri = new URI(ApplicationConstants.CONST_JIRA_BASE_URL);\n    this.client = factory.createWithBasicHttpAuthentication(uri, ApplicationConstants.CONST_JIRA_USER_NAME,\n        ApplicationConstants.CONST_JIRA_API_KEY);\n  }\n", "  public Issue getIssue(String issueKey) {\n    IssueRestClient issueRestClient = this.client.getIssueClient();\n\n    try {\n      return issueRestClient.getIssue(issueKey).claim();\n    } catch (RestClientException e) {\n      return null;\n    }\n  }\n\n  public List<Issue> getIssueList(List<String> issueKeys) {\n    return issueKeys.stream().map(this::getIssue).filter(Objects::nonNull).toList();\n  }\n\n}\n"]}
