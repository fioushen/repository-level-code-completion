{"filename": "lib/src/test/java/net/fellbaum/jemoji/EmojiManagerTest.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;", "import java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class EmojiManagerTest {\n\n    public static final String ALL_EMOJIS_STRING = EmojiManager.getAllEmojisLengthDescending().stream().map(Emoji::getEmoji).collect(Collectors.joining());\n    private static final String SIMPLE_EMOJI_STRING = \"Hello \u2764\ufe0f World\";\n\n    @Test\n    public void extractEmojisInOrder() {\n        List<Emoji> emojis = EmojiManager.extractEmojisInOrder(ALL_EMOJIS_STRING + ALL_EMOJIS_STRING);\n\n        Assert.assertEquals(EmojiManager.getAllEmojisLengthDescending().size() * 2, emojis.size());\n\n        List<Emoji> allEmojis = new ArrayList<>(EmojiManager.getAllEmojisLengthDescending());\n        allEmojis.addAll(EmojiManager.getAllEmojisLengthDescending());\n        Assert.assertEquals(allEmojis, emojis);\n    }\n\n    @Test", "    public void extractEmojisInOrder() {\n        List<Emoji> emojis = EmojiManager.extractEmojisInOrder(ALL_EMOJIS_STRING + ALL_EMOJIS_STRING);\n\n        Assert.assertEquals(EmojiManager.getAllEmojisLengthDescending().size() * 2, emojis.size());\n\n        List<Emoji> allEmojis = new ArrayList<>(EmojiManager.getAllEmojisLengthDescending());\n        allEmojis.addAll(EmojiManager.getAllEmojisLengthDescending());\n        Assert.assertEquals(allEmojis, emojis);\n    }\n\n    @Test", "    public void extractEmojis() {\n        Set<Emoji> emojis = EmojiManager.extractEmojis(ALL_EMOJIS_STRING + ALL_EMOJIS_STRING);\n\n        Assert.assertEquals(EmojiManager.getAllEmojisLengthDescending().size(), emojis.size());\n        Set<Emoji> allEmojis = EmojiManager.getAllEmojis();\n        Assert.assertEquals(allEmojis, emojis);\n    }\n\n    @Test\n    public void getEmoji() {\n        String emojiString = \"\ud83d\udc4d\";\n\n        Optional<Emoji> emoji = EmojiManager.getEmoji(emojiString);\n        Assert.assertTrue(emoji.isPresent());\n        Assert.assertEquals(emojiString, emoji.get().getEmoji());\n    }\n\n    @Test", "    public void getEmoji() {\n        String emojiString = \"\ud83d\udc4d\";\n\n        Optional<Emoji> emoji = EmojiManager.getEmoji(emojiString);\n        Assert.assertTrue(emoji.isPresent());\n        Assert.assertEquals(emojiString, emoji.get().getEmoji());\n    }\n\n    @Test\n    public void isEmoji() {\n        String emojiString = \"\\uD83D\\uDC4D\";\n\n        Assert.assertTrue(EmojiManager.isEmoji(emojiString));\n    }\n\n    @Test", "    public void isEmoji() {\n        String emojiString = \"\\uD83D\\uDC4D\";\n\n        Assert.assertTrue(EmojiManager.isEmoji(emojiString));\n    }\n\n    @Test\n    public void getByAlias() {\n        String alias = \"smile\";\n\n        Optional<Emoji> emoji = EmojiManager.getByAlias(alias);\n        Assert.assertTrue(emoji.isPresent());\n        Assert.assertEquals(\"\ud83d\ude04\", emoji.get().getEmoji());\n    }\n\n    @Test", "    public void getByAliasWithColon() {\n        String alias = \":smile:\";\n\n        Optional<Emoji> emoji = EmojiManager.getByAlias(alias);\n        Assert.assertTrue(emoji.isPresent());\n        Assert.assertEquals(\"\ud83d\ude04\", emoji.get().getEmoji());\n    }\n\n    @Test\n    public void containsEmoji() {\n        Assert.assertTrue(EmojiManager.containsEmoji(SIMPLE_EMOJI_STRING));\n    }\n\n    @Test", "    public void containsEmoji() {\n        Assert.assertTrue(EmojiManager.containsEmoji(SIMPLE_EMOJI_STRING));\n    }\n\n    @Test\n    public void removeEmojis() {\n        Assert.assertEquals(\"Hello  World\", EmojiManager.removeAllEmojis(SIMPLE_EMOJI_STRING));\n    }\n\n    @Test\n    public void removeAllEmojisExcept() {\n        Assert.assertEquals(\"Hello \u2764\ufe0f World\", EmojiManager.removeAllEmojisExcept(SIMPLE_EMOJI_STRING + \"\ud83d\udc4d\", Collections.singletonList(EmojiManager.getEmoji(\"\u2764\ufe0f\").get())));\n    }\n\n    @Test", "    public void removeAllEmojisExcept() {\n        Assert.assertEquals(\"Hello \u2764\ufe0f World\", EmojiManager.removeAllEmojisExcept(SIMPLE_EMOJI_STRING + \"\ud83d\udc4d\", Collections.singletonList(EmojiManager.getEmoji(\"\u2764\ufe0f\").get())));\n    }\n\n    @Test\n    public void replaceEmojis() {\n        Assert.assertEquals(\"Hello :heart: World\", EmojiManager.replaceEmojis(SIMPLE_EMOJI_STRING, \":heart:\", Collections.singletonList(EmojiManager.getEmoji(\"\u2764\ufe0f\").get())));\n    }\n\n    @Test\n    public void replaceAllEmojis() {\n        Assert.assertEquals(\"Hello something World something something something\", EmojiManager.replaceAllEmojis(SIMPLE_EMOJI_STRING + \" \ud83d\udc4d \ud83d\udc68\ud83c\udfff\u200d\ud83e\uddb1 \ud83d\ude0a\", \"something\"));\n    }\n\n    @Test", "    public void replaceAllEmojis() {\n        Assert.assertEquals(\"Hello something World something something something\", EmojiManager.replaceAllEmojis(SIMPLE_EMOJI_STRING + \" \ud83d\udc4d \ud83d\udc68\ud83c\udfff\u200d\ud83e\uddb1 \ud83d\ude0a\", \"something\"));\n    }\n\n    @Test\n    public void replaceAllEmojisFunction() {\n        Assert.assertEquals(\"Hello SMILEYS_AND_EMOTION World PEOPLE_AND_BODY PEOPLE_AND_BODY SMILEYS_AND_EMOTION\", EmojiManager.replaceAllEmojis(SIMPLE_EMOJI_STRING + \" \ud83d\udc4d \ud83d\udc68\ud83c\udfff\u200d\ud83e\uddb1 \ud83d\ude0a\", emoji -> emoji.getGroup().toString()));\n    }\n}"]}
{"filename": "lib/src/test/java/net/fellbaum/jemoji/FitzpatrickTest.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class FitzpatrickTest {\n\n    private static final String fitzPatrickEmoji = \"\ud83d\udc4b\ud83c\udffb\";\n    private static final String nonFitzPatrickEmoji = \"\ud83d\udc4b\";\n\n    @Test", "    public void isFitzpatrickEmoji() {\n        assertTrue(Fitzpatrick.isFitzpatrickEmoji(fitzPatrickEmoji));\n        assertFalse(Fitzpatrick.isFitzpatrickEmoji(nonFitzPatrickEmoji));\n    }\n\n    @Test\n    public void removeFitzpatrick() {\n        assertEquals(\"\ud83d\udc4b\", Fitzpatrick.removeFitzpatrick(fitzPatrickEmoji));\n        assertEquals(\"\ud83d\udc4b\", Fitzpatrick.removeFitzpatrick(nonFitzPatrickEmoji));\n    }\n}"]}
{"filename": "lib/src/test/java/net/fellbaum/jemoji/HairStyleTest.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class HairStyleTest {\n\n    private static final String RED_HAIR = \"\\uD83D\\uDC68\\u200D\\uD83E\\uDDB0\";\n    private static final String noHair = \"\ud83d\udc68\";\n\n    @Test", "    public void isHairStyleEmoji() {\n        assertTrue(HairStyle.isHairStyleEmoji(RED_HAIR));\n        assertFalse(HairStyle.isHairStyleEmoji(noHair));\n    }\n\n    @Test\n    public void removeHairStyle() {\n        assertEquals(noHair, HairStyle.removeHairStyle(RED_HAIR));\n        assertEquals(noHair, HairStyle.removeHairStyle(noHair));\n    }\n}"]}
{"filename": "lib/src/java9/java/module-info.java", "chunked_list": ["module net.fellbaum.jemoji {\n    requires com.fasterxml.jackson.databind;\n\n    opens net.fellbaum.jemoji to com.fasterxml.jackson.databind;\n    exports net.fellbaum.jemoji;\n}"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/Fitzpatrick.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic enum Fitzpatrick {\n\n    LIGHT_SKIN(\"\\uD83C\\uDFFB\"),\n    MEDIUM_LIGHT_SKIN(\"\\uD83C\\uDFFC\"),\n    MEDIUM_SKIN(\"\\uD83C\\uDFFD\"),\n    MEDIUM_DARK_SKIN(\"\\uD83C\\uDFFE\"),\n    DARK_SKIN(\"\\uD83C\\uDFFF\");\n\n    private static final List<Fitzpatrick> FITZPATRICK_LIST = Arrays.asList(values());\n    private final String unicode;\n\n    Fitzpatrick(final String unicode) {\n        this.unicode = unicode;\n    }\n\n    /**\n     * Gets the unicode of the fitzpatrick modifier.\n     *\n     * @return The unicode of the fitzpatrick modifier.\n     */", "    public String getUnicode() {\n        return unicode;\n    }\n\n    /**\n     * Check if the given emoji contains a fitzpatrick modifier.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return True if the emoji contains a fitzpatrick modifier.\n     */\n    public static boolean isFitzpatrickEmoji(final String unicode) {\n        return FITZPATRICK_LIST.stream().anyMatch(fitzpatrick -> unicode.contains(fitzpatrick.unicode) && !unicode.equals(fitzpatrick.unicode));\n    }\n\n    /**\n     * Removes the fitzpatrick modifier from the given emoji.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return The unicode of the emoji without the fitzpatrick modifier.\n     */", "    public static boolean isFitzpatrickEmoji(final String unicode) {\n        return FITZPATRICK_LIST.stream().anyMatch(fitzpatrick -> unicode.contains(fitzpatrick.unicode) && !unicode.equals(fitzpatrick.unicode));\n    }\n\n    /**\n     * Removes the fitzpatrick modifier from the given emoji.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return The unicode of the emoji without the fitzpatrick modifier.\n     */\n    public static String removeFitzpatrick(String unicode) {", "    public static String removeFitzpatrick(String unicode) {\n        for (Fitzpatrick value : FITZPATRICK_LIST) {\n            unicode = unicode.replaceAll(\"\\u200D?\" + value.getUnicode(), \"\");\n        }\n        return unicode;\n    }\n}\n"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/EmojiSubGroup.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Represents an emoji sub group.\n */\npublic enum EmojiSubGroup {\n\n    ALPHANUM(\"alphanum\"),\n    ANIMAL_AMPHIBIAN(\"animal-amphibian\"),\n    ANIMAL_BIRD(\"animal-bird\"),\n    ANIMAL_BUG(\"animal-bug\"),\n    ANIMAL_MAMMAL(\"animal-mammal\"),\n    ANIMAL_MARINE(\"animal-marine\"),\n    ANIMAL_REPTILE(\"animal-reptile\"),\n    ARROW(\"arrow\"),\n    ARTS_CRAFTS(\"arts & crafts\"),\n    AV_SYMBOL(\"av-symbol\"),\n    AWARD_MEDAL(\"award-medal\"),\n    BODY_PARTS(\"body-parts\"),\n    BOOK_PAPER(\"book-paper\"),\n    CAT_FACE(\"cat-face\"),\n    CLOTHING(\"clothing\"),\n    COMPUTER(\"computer\"),\n    COUNTRY_FLAG(\"country-flag\"),\n    CURRENCY(\"currency\"),\n    DISHWARE(\"dishware\"),\n    DRINK(\"drink\"),\n    EMOTION(\"emotion\"),\n    EVENT(\"event\"),\n    FACE_AFFECTION(\"face-affection\"),\n    FACE_CONCERNED(\"face-concerned\"),\n    FACE_COSTUME(\"face-costume\"),\n    FACE_GLASSES(\"face-glasses\"),\n    FACE_HAND(\"face-hand\"),\n    FACE_HAT(\"face-hat\"),\n    FACE_NEGATIVE(\"face-negative\"),\n    FACE_NEUTRAL_SKEPTICAL(\"face-neutral-skeptical\"),\n    FACE_SLEEPY(\"face-sleepy\"),\n    FACE_SMILING(\"face-smiling\"),\n    FACE_TONGUE(\"face-tongue\"),\n    FACE_UNWELL(\"face-unwell\"),\n    FAMILY(\"family\"),\n    FLAG(\"flag\"),\n    FOOD_ASIAN(\"food-asian\"),\n    FOOD_FRUIT(\"food-fruit\"),\n    FOOD_MARINE(\"food-marine\"),\n    FOOD_PREPARED(\"food-prepared\"),\n    FOOD_SWEET(\"food-sweet\"),\n    FOOD_VEGETABLE(\"food-vegetable\"),\n    GAME(\"game\"),\n    GENDER(\"gender\"),\n    GEOMETRIC(\"geometric\"),\n    HAIR_STYLE(\"hair-style\"),\n    HANDS(\"hands\"),\n    HAND_FINGERS_CLOSED(\"hand-fingers-closed\"),\n    HAND_FINGERS_OPEN(\"hand-fingers-open\"),\n    HAND_FINGERS_PARTIAL(\"hand-fingers-partial\"),\n    HAND_PROP(\"hand-prop\"),\n    HAND_SINGLE_FINGER(\"hand-single-finger\"),\n    HEART(\"heart\"),\n    HOTEL(\"hotel\"),\n    HOUSEHOLD(\"household\"),\n    KEYCAP(\"keycap\"),\n    LIGHT_VIDEO(\"light & video\"),\n    LOCK(\"lock\"),\n    MAIL(\"mail\"),\n    MATH(\"math\"),\n    MEDICAL(\"medical\"),\n    MONEY(\"money\"),\n    MONKEY_FACE(\"monkey-face\"),\n    MUSIC(\"music\"),\n    MUSICAL_INSTRUMENT(\"musical-instrument\"),\n    OFFICE(\"office\"),\n    OTHER_OBJECT(\"other-object\"),\n    OTHER_SYMBOL(\"other-symbol\"),\n    PERSON(\"person\"),\n    PERSON_ACTIVITY(\"person-activity\"),\n    PERSON_FANTASY(\"person-fantasy\"),\n    PERSON_GESTURE(\"person-gesture\"),\n    PERSON_RESTING(\"person-resting\"),\n    PERSON_ROLE(\"person-role\"),\n    PERSON_SPORT(\"person-sport\"),\n    PERSON_SYMBOL(\"person-symbol\"),\n    PHONE(\"phone\"),\n    PLACE_BUILDING(\"place-building\"),\n    PLACE_GEOGRAPHIC(\"place-geographic\"),\n    PLACE_MAP(\"place-map\"),\n    PLACE_OTHER(\"place-other\"),\n    PLACE_RELIGIOUS(\"place-religious\"),\n    PLANT_FLOWER(\"plant-flower\"),\n    PLANT_OTHER(\"plant-other\"),\n    PUNCTUATION(\"punctuation\"),\n    RELIGION(\"religion\"),\n    SCIENCE(\"science\"),\n    SKIN_TONE(\"skin-tone\"),\n    SKY_WEATHER(\"sky & weather\"),\n    SOUND(\"sound\"),\n    SPORT(\"sport\"),\n    SUBDIVISION_FLAG(\"subdivision-flag\"),\n    TIME(\"time\"),\n    TOOL(\"tool\"),\n    TRANSPORT_AIR(\"transport-air\"),\n    TRANSPORT_GROUND(\"transport-ground\"),\n    TRANSPORT_SIGN(\"transport-sign\"),\n    TRANSPORT_WATER(\"transport-water\"),\n    WARNING(\"warning\"),\n    WRITING(\"writing\"),\n    ZODIAC(\"zodiac\");\n\n    private static final List<EmojiSubGroup> EMOJI_SUBGROUPS = Arrays.asList(values());\n    private final String name;\n\n    EmojiSubGroup(final String name) {\n        this.name = name;\n    }\n\n    /**\n     * Gets the name of the emoji subgroup.\n     *\n     * @return The name of the emoji subgroup\n     */", " * Represents an emoji sub group.\n */\npublic enum EmojiSubGroup {\n\n    ALPHANUM(\"alphanum\"),\n    ANIMAL_AMPHIBIAN(\"animal-amphibian\"),\n    ANIMAL_BIRD(\"animal-bird\"),\n    ANIMAL_BUG(\"animal-bug\"),\n    ANIMAL_MAMMAL(\"animal-mammal\"),\n    ANIMAL_MARINE(\"animal-marine\"),\n    ANIMAL_REPTILE(\"animal-reptile\"),\n    ARROW(\"arrow\"),\n    ARTS_CRAFTS(\"arts & crafts\"),\n    AV_SYMBOL(\"av-symbol\"),\n    AWARD_MEDAL(\"award-medal\"),\n    BODY_PARTS(\"body-parts\"),\n    BOOK_PAPER(\"book-paper\"),\n    CAT_FACE(\"cat-face\"),\n    CLOTHING(\"clothing\"),\n    COMPUTER(\"computer\"),\n    COUNTRY_FLAG(\"country-flag\"),\n    CURRENCY(\"currency\"),\n    DISHWARE(\"dishware\"),\n    DRINK(\"drink\"),\n    EMOTION(\"emotion\"),\n    EVENT(\"event\"),\n    FACE_AFFECTION(\"face-affection\"),\n    FACE_CONCERNED(\"face-concerned\"),\n    FACE_COSTUME(\"face-costume\"),\n    FACE_GLASSES(\"face-glasses\"),\n    FACE_HAND(\"face-hand\"),\n    FACE_HAT(\"face-hat\"),\n    FACE_NEGATIVE(\"face-negative\"),\n    FACE_NEUTRAL_SKEPTICAL(\"face-neutral-skeptical\"),\n    FACE_SLEEPY(\"face-sleepy\"),\n    FACE_SMILING(\"face-smiling\"),\n    FACE_TONGUE(\"face-tongue\"),\n    FACE_UNWELL(\"face-unwell\"),\n    FAMILY(\"family\"),\n    FLAG(\"flag\"),\n    FOOD_ASIAN(\"food-asian\"),\n    FOOD_FRUIT(\"food-fruit\"),\n    FOOD_MARINE(\"food-marine\"),\n    FOOD_PREPARED(\"food-prepared\"),\n    FOOD_SWEET(\"food-sweet\"),\n    FOOD_VEGETABLE(\"food-vegetable\"),\n    GAME(\"game\"),\n    GENDER(\"gender\"),\n    GEOMETRIC(\"geometric\"),\n    HAIR_STYLE(\"hair-style\"),\n    HANDS(\"hands\"),\n    HAND_FINGERS_CLOSED(\"hand-fingers-closed\"),\n    HAND_FINGERS_OPEN(\"hand-fingers-open\"),\n    HAND_FINGERS_PARTIAL(\"hand-fingers-partial\"),\n    HAND_PROP(\"hand-prop\"),\n    HAND_SINGLE_FINGER(\"hand-single-finger\"),\n    HEART(\"heart\"),\n    HOTEL(\"hotel\"),\n    HOUSEHOLD(\"household\"),\n    KEYCAP(\"keycap\"),\n    LIGHT_VIDEO(\"light & video\"),\n    LOCK(\"lock\"),\n    MAIL(\"mail\"),\n    MATH(\"math\"),\n    MEDICAL(\"medical\"),\n    MONEY(\"money\"),\n    MONKEY_FACE(\"monkey-face\"),\n    MUSIC(\"music\"),\n    MUSICAL_INSTRUMENT(\"musical-instrument\"),\n    OFFICE(\"office\"),\n    OTHER_OBJECT(\"other-object\"),\n    OTHER_SYMBOL(\"other-symbol\"),\n    PERSON(\"person\"),\n    PERSON_ACTIVITY(\"person-activity\"),\n    PERSON_FANTASY(\"person-fantasy\"),\n    PERSON_GESTURE(\"person-gesture\"),\n    PERSON_RESTING(\"person-resting\"),\n    PERSON_ROLE(\"person-role\"),\n    PERSON_SPORT(\"person-sport\"),\n    PERSON_SYMBOL(\"person-symbol\"),\n    PHONE(\"phone\"),\n    PLACE_BUILDING(\"place-building\"),\n    PLACE_GEOGRAPHIC(\"place-geographic\"),\n    PLACE_MAP(\"place-map\"),\n    PLACE_OTHER(\"place-other\"),\n    PLACE_RELIGIOUS(\"place-religious\"),\n    PLANT_FLOWER(\"plant-flower\"),\n    PLANT_OTHER(\"plant-other\"),\n    PUNCTUATION(\"punctuation\"),\n    RELIGION(\"religion\"),\n    SCIENCE(\"science\"),\n    SKIN_TONE(\"skin-tone\"),\n    SKY_WEATHER(\"sky & weather\"),\n    SOUND(\"sound\"),\n    SPORT(\"sport\"),\n    SUBDIVISION_FLAG(\"subdivision-flag\"),\n    TIME(\"time\"),\n    TOOL(\"tool\"),\n    TRANSPORT_AIR(\"transport-air\"),\n    TRANSPORT_GROUND(\"transport-ground\"),\n    TRANSPORT_SIGN(\"transport-sign\"),\n    TRANSPORT_WATER(\"transport-water\"),\n    WARNING(\"warning\"),\n    WRITING(\"writing\"),\n    ZODIAC(\"zodiac\");\n\n    private static final List<EmojiSubGroup> EMOJI_SUBGROUPS = Arrays.asList(values());\n    private final String name;\n\n    EmojiSubGroup(final String name) {\n        this.name = name;\n    }\n\n    /**\n     * Gets the name of the emoji subgroup.\n     *\n     * @return The name of the emoji subgroup\n     */", "    public String getName() {\n        return name;\n    }\n\n    /**\n     * Gets all emoji subgroups.\n     *\n     * @return All emoji subgroups\n     */\n    public static List<EmojiSubGroup> getSubGroups() {\n        return EMOJI_SUBGROUPS;\n    }\n\n    /**\n     * Gets the emoji subgroup for the given name.\n     *\n     * @param name The name of the emoji subgroup.\n     * @return The emoji subgroup.\n     */\n    @JsonCreator", "    public static List<EmojiSubGroup> getSubGroups() {\n        return EMOJI_SUBGROUPS;\n    }\n\n    /**\n     * Gets the emoji subgroup for the given name.\n     *\n     * @param name The name of the emoji subgroup.\n     * @return The emoji subgroup.\n     */\n    @JsonCreator", "    public static EmojiSubGroup fromString(final String name) {\n        for (final EmojiSubGroup emojiSubGroup : EMOJI_SUBGROUPS) {\n            if (emojiSubGroup.getName().equals(name)) {\n                return emojiSubGroup;\n            }\n        }\n        throw new IllegalArgumentException(\"No EmojiSubGroup found for name: \" + name);\n    }\n}\n"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/HairStyle.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic enum HairStyle {\n\n    RED_HAIR(\"\ud83e\uddb0\"),\n    CURLY_HAIR(\"\ud83e\uddb1\"),\n    WHITE_HAIR(\"\ud83e\uddb3\"),\n    BALD(\"\ud83e\uddb2\");\n\n    private static final List<HairStyle> HAIR_STYLE_LIST = Arrays.asList(values());\n    private final String unicode;\n\n    HairStyle(final String unicode) {\n        this.unicode = unicode;\n    }\n\n    /**\n     * Gets the unicode of the hairstyle.\n     *\n     * @return The unicode of the hairstyle.\n     */", "    public String getUnicode() {\n        return unicode;\n    }\n\n    /**\n     * Check if the given emoji contains a hairstyle element.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return True if the emoji contains a hairstyle element.\n     */\n    public static boolean isHairStyleEmoji(final String unicode) {\n        return HAIR_STYLE_LIST.stream().anyMatch(hairStyle -> unicode.contains(hairStyle.unicode) && !unicode.equals(hairStyle.unicode));\n    }\n\n    /**\n     * Removes the hairstyle element from the given emoji.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return The unicode of the emoji without the hairstyle element.\n     */", "    public static boolean isHairStyleEmoji(final String unicode) {\n        return HAIR_STYLE_LIST.stream().anyMatch(hairStyle -> unicode.contains(hairStyle.unicode) && !unicode.equals(hairStyle.unicode));\n    }\n\n    /**\n     * Removes the hairstyle element from the given emoji.\n     *\n     * @param unicode The unicode of the emoji.\n     * @return The unicode of the emoji without the hairstyle element.\n     */\n    public static String removeHairStyle(String unicode) {", "    public static String removeHairStyle(String unicode) {\n        for (HairStyle value : HAIR_STYLE_LIST) {\n            unicode = unicode.replaceAll(\"\\u200D?\" + value.getUnicode(), \"\");\n        }\n        return unicode;\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/EmojiManager.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;", "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic final class EmojiManager {\n\n    private static final String PATH = \"emojis.json\";\n\n    private static final Map<String, Emoji> EMOJI_UNICODE_TO_EMOJI;\n    private static final Map<Integer, List<Emoji>> EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING;\n    private static final List<Emoji> EMOJIS_LENGTH_DESCENDING;\n\n    private static final Pattern EMOJI_PATTERN;\n    private static final Pattern NOT_WANTED_EMOJI_CHARACTERS = Pattern.compile(\"[\\\\p{Alpha}\\\\p{Z}]\");\n\n    private static final Comparator<Emoji> EMOJI_CODEPOINT_COMPARATOR = (final Emoji o1, final Emoji o2) -> {", "\n@SuppressWarnings(\"unused\")\npublic final class EmojiManager {\n\n    private static final String PATH = \"emojis.json\";\n\n    private static final Map<String, Emoji> EMOJI_UNICODE_TO_EMOJI;\n    private static final Map<Integer, List<Emoji>> EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING;\n    private static final List<Emoji> EMOJIS_LENGTH_DESCENDING;\n\n    private static final Pattern EMOJI_PATTERN;\n    private static final Pattern NOT_WANTED_EMOJI_CHARACTERS = Pattern.compile(\"[\\\\p{Alpha}\\\\p{Z}]\");\n\n    private static final Comparator<Emoji> EMOJI_CODEPOINT_COMPARATOR = (final Emoji o1, final Emoji o2) -> {", "        if (o1.getEmoji().codePoints().toArray().length == o2.getEmoji().codePoints().toArray().length) return 0;\n        return o1.getEmoji().codePoints().toArray().length > o2.getEmoji().codePoints().toArray().length ? -1 : 1;\n    };\n\n    static {\n        final String fileContent = readFileAsString();\n        try {\n            final List<Emoji> emojis = new ObjectMapper().readValue(fileContent, new TypeReference<List<Emoji>>() {\n                    }).stream()\n                    .filter(emoji -> emoji.getQualification() == Qualification.FULLY_QUALIFIED || emoji.getQualification() == Qualification.COMPONENT)\n                    .collect(Collectors.toList());\n\n            EMOJI_UNICODE_TO_EMOJI = Collections.unmodifiableMap(\n                    emojis.stream().collect(Collectors.toMap(Emoji::getEmoji, Function.identity()))\n            );\n\n            EMOJIS_LENGTH_DESCENDING = Collections.unmodifiableList(emojis.stream().sorted(EMOJI_CODEPOINT_COMPARATOR).collect(Collectors.toList()));\n\n            EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING = emojis.stream().collect(getEmojiLinkedHashMapCollector());\n\n            EMOJI_PATTERN = Pattern.compile(EMOJIS_LENGTH_DESCENDING.stream()\n                    .map(s -> \"(\" + Pattern.quote(s.getEmoji()) + \")\").collect(Collectors.joining(\"|\")), Pattern.UNICODE_CHARACTER_CLASS);\n        } catch (final JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static Collector<Emoji, ?, LinkedHashMap<Integer, List<Emoji>>> getEmojiLinkedHashMapCollector() {\n        return Collectors.groupingBy(\n                emoji -> emoji.getEmoji().codePoints().toArray()[0],\n                LinkedHashMap::new,\n                Collectors.collectingAndThen(\n                        Collectors.toList(),\n                        list -> {\n                            list.sort(EMOJI_CODEPOINT_COMPARATOR);\n                            return list;\n                        }\n                )\n        );\n    }\n\n    private static String readFileAsString() {", "        try {\n            final ClassLoader classLoader = EmojiManager.class.getClassLoader();\n            try (final InputStream is = classLoader.getResourceAsStream(PATH)) {\n                if (is == null) return null;\n                try (final InputStreamReader isr = new InputStreamReader(is, StandardCharsets.UTF_8);\n                     final BufferedReader reader = new BufferedReader(isr)) {\n                    return reader.lines().collect(Collectors.joining(System.lineSeparator()));\n                }\n            }\n        } catch (final IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EmojiManager() {\n    }\n\n    /**\n     * Returns the emoji for the given unicode.\n     *\n     * @param emoji The unicode of the emoji.\n     * @return The emoji.\n     */", "    public static Optional<Emoji> getEmoji(final String emoji) {\n        if (isStringNullOrEmpty(emoji)) return Optional.empty();\n        return Optional.ofNullable(EMOJI_UNICODE_TO_EMOJI.get(emoji));\n    }\n\n    /**\n     * Check if the given string is an emoji.\n     *\n     * @param emoji The emoji to check.\n     * @return True if the given string is an emoji.\n     */", "    public static boolean isEmoji(final String emoji) {\n        if (isStringNullOrEmpty(emoji)) return false;\n        return EMOJI_UNICODE_TO_EMOJI.containsKey(emoji);\n    }\n\n    /**\n     * Gets all emojis.\n     *\n     * @return A set of all emojis.\n     */\n    public static Set<Emoji> getAllEmojis() {\n        return new HashSet<>(EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Gets all emojis that are part of the given group.\n     *\n     * @param group The group to get the emojis for.\n     * @return A set of all emojis that are part of the given group.\n     */", "    public static Set<Emoji> getAllEmojis() {\n        return new HashSet<>(EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Gets all emojis that are part of the given group.\n     *\n     * @param group The group to get the emojis for.\n     * @return A set of all emojis that are part of the given group.\n     */\n    public static Set<Emoji> getAllEmojisByGroup(final EmojiGroup group) {\n        return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets all emojis that are part of the given subgroup.\n     *\n     * @param subgroup The subgroup to get the emojis for.\n     * @return A set of all emojis that are part of the given subgroup.\n     */", "    public static Set<Emoji> getAllEmojisByGroup(final EmojiGroup group) {\n        return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets all emojis that are part of the given subgroup.\n     *\n     * @param subgroup The subgroup to get the emojis for.\n     * @return A set of all emojis that are part of the given subgroup.\n     */\n    public static Set<Emoji> getAllEmojisBySubGroup(final EmojiSubGroup subgroup) {\n        return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getSubgroup() == subgroup).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets all emojis in descending order by their char length.\n     *\n     * @return A list of all emojis.\n     */", "    public static Set<Emoji> getAllEmojisBySubGroup(final EmojiSubGroup subgroup) {\n        return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getSubgroup() == subgroup).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets all emojis in descending order by their char length.\n     *\n     * @return A list of all emojis.\n     */\n    public static List<Emoji> getAllEmojisLengthDescending() {\n        return EMOJIS_LENGTH_DESCENDING;\n    }\n\n    /**\n     * Gets an emoji for the given alias i.e. :thumbsup: if present.\n     *\n     * @param alias The alias of the emoji.\n     * @return The emoji.\n     */", "    public static List<Emoji> getAllEmojisLengthDescending() {\n        return EMOJIS_LENGTH_DESCENDING;\n    }\n\n    /**\n     * Gets an emoji for the given alias i.e. :thumbsup: if present.\n     *\n     * @param alias The alias of the emoji.\n     * @return The emoji.\n     */\n    public static Optional<Emoji> getByAlias(final String alias) {", "    public static Optional<Emoji> getByAlias(final String alias) {\n        if (isStringNullOrEmpty(alias)) return Optional.empty();\n        final String aliasWithoutColon = removeColonFromAlias(alias);\n        final String aliasWithColon = addColonToAlias(alias);\n        return EMOJI_UNICODE_TO_EMOJI.values()\n                .stream()\n                .filter(emoji -> emoji.getAllAliases().contains(aliasWithoutColon) || emoji.getAllAliases().contains(aliasWithColon))\n                .findFirst();\n    }\n\n    /**\n     * Gets an emoji for the given Discord alias i.e. :thumbsup: if present.\n     *\n     * @param alias The Discord alias of the emoji.\n     * @return The emoji.\n     */", "    public static Optional<Emoji> getByDiscordAlias(final String alias) {\n        if (isStringNullOrEmpty(alias)) return Optional.empty();\n        final String aliasWithoutColon = removeColonFromAlias(alias);\n        final String aliasWithColon = addColonToAlias(alias);\n        return EMOJI_UNICODE_TO_EMOJI.values()\n                .stream()\n                .filter(emoji -> emoji.getDiscordAliases().contains(aliasWithoutColon) || emoji.getDiscordAliases().contains(aliasWithColon))\n                .findFirst();\n    }\n\n    /**\n     * Gets an emoji for the given GitHub alias i.e. :thumbsup: if present.\n     *\n     * @param alias The GitHub alias of the emoji.\n     * @return The emoji.\n     */", "    public static Optional<Emoji> getByGithubAlias(final String alias) {\n        if (isStringNullOrEmpty(alias)) return Optional.empty();\n        final String aliasWithoutColon = removeColonFromAlias(alias);\n        final String aliasWithColon = addColonToAlias(alias);\n        return EMOJI_UNICODE_TO_EMOJI.values()\n                .stream()\n                .filter(emoji -> emoji.getGithubAliases().contains(aliasWithoutColon) || emoji.getGithubAliases().contains(aliasWithColon))\n                .findFirst();\n    }\n\n    /**\n     * Gets an emoji for the given Slack alias i.e. :thumbsup: if present.\n     *\n     * @param alias The Slack alias of the emoji.\n     * @return The emoji.\n     */", "    public static Optional<Emoji> getBySlackAlias(final String alias) {\n        if (isStringNullOrEmpty(alias)) return Optional.empty();\n        final String aliasWithoutColon = removeColonFromAlias(alias);\n        final String aliasWithColon = addColonToAlias(alias);\n        return EMOJI_UNICODE_TO_EMOJI.values()\n                .stream()\n                .filter(emoji -> emoji.getSlackAliases().contains(aliasWithoutColon) || emoji.getSlackAliases().contains(aliasWithColon))\n                .findFirst();\n    }\n\n    private static String removeColonFromAlias(final String alias) {\n        return alias.startsWith(\":\") && alias.endsWith(\":\") ? alias.substring(1, alias.length() - 1) : alias;\n    }\n\n    private static String addColonToAlias(final String alias) {\n        return alias.startsWith(\":\") && alias.endsWith(\":\") ? alias : \":\" + alias + \":\";\n    }\n\n    /**\n     * Gets the pattern checking for all emojis.\n     *\n     * @return The pattern for all emojis.\n     */", "    public static Pattern getEmojiPattern() {\n        return EMOJI_PATTERN;\n    }\n\n    /**\n     * Checks if the given text contains emojis.\n     *\n     * @param text The text to check.\n     * @return True if the given text contains emojis.\n     */\n    public static boolean containsEmoji(final String text) {", "    public static boolean containsEmoji(final String text) {\n        if (isStringNullOrEmpty(text)) return false;\n\n        final List<Emoji> emojis = new ArrayList<>();\n\n        final int[] textCodePointsArray = text.codePoints().toArray();\n        final long textCodePointsLength = textCodePointsArray.length;\n\n        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final List<Emoji> emojisByCodePoint = EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(textCodePointsArray[textIndex]);\n            if (emojisByCodePoint == null) continue;", "        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final List<Emoji> emojisByCodePoint = EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(textCodePointsArray[textIndex]);\n            if (emojisByCodePoint == null) continue;\n            for (final Emoji emoji : emojisByCodePoint) {\n                final int[] emojiCodePointsArray = emoji.getEmoji().codePoints().toArray();\n                final int emojiCodePointsLength = emojiCodePointsArray.length;\n                // Emoji code points are in bounds of the text code points\n                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n", "                for (int i = 0; i < emojiCodePointsLength; i++) {\n                    if (textCodePointsArray[textIndex + i] != emojiCodePointsArray[i]) {\n                        break;\n                    }\n                    if (i == emojiCodePointsLength - 1) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extracts all emojis from the given text in the order they appear.\n     *\n     * @param text The text to extract emojis from.\n     * @return A list of emojis.\n     */", "    public static List<Emoji> extractEmojisInOrder(final String text) {\n        if (isStringNullOrEmpty(text)) return Collections.emptyList();\n\n        final List<Emoji> emojis = new ArrayList<>();\n\n        final int[] textCodePointsArray = text.codePoints().toArray();\n        final long textCodePointsLength = textCodePointsArray.length;\n\n        // JDK 21 Characters.isEmoji\n\n        nextTextIteration:", "        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final List<Emoji> emojisByCodePoint = EMOJI_FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(textCodePointsArray[textIndex]);\n            if (emojisByCodePoint == null) continue;\n            for (final Emoji emoji : emojisByCodePoint) {\n                final int[] emojiCodePointsArray = emoji.getEmoji().codePoints().toArray();\n                final int emojiCodePointsLength = emojiCodePointsArray.length;\n                // Emoji code points are in bounds of the text code points\n                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n", "                for (int i = 0; i < emojiCodePointsLength; i++) {\n                    if (textCodePointsArray[textIndex + i] != emojiCodePointsArray[i]) {\n                        break;\n                    }\n                    if (i == emojiCodePointsLength - 1) {\n                        emojis.add(emoji);\n                        textIndex += emojiCodePointsLength - 1;\n                        continue nextTextIteration;\n                    }\n                }\n            }\n        }\n        return Collections.unmodifiableList(emojis);\n    }\n\n    /**\n     * Extracts all emojis from the given text.\n     *\n     * @param text The text to extract emojis from.\n     * @return A list of emojis.\n     */", "    public static Set<Emoji> extractEmojis(final String text) {\n        return Collections.unmodifiableSet(new HashSet<>(extractEmojisInOrder(text)));\n    }\n\n    /**\n     * Removes all emojis from the given text.\n     *\n     * @param text The text to remove emojis from.\n     * @return The text without emojis.\n     */\n    public static String removeAllEmojis(final String text) {\n        return removeEmojis(text, EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Removes the given emojis from the given text.\n     *\n     * @param text           The text to remove emojis from.\n     * @param emojisToRemove The emojis to remove.\n     * @return The text without the given emojis.\n     */", "    public static String removeAllEmojis(final String text) {\n        return removeEmojis(text, EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Removes the given emojis from the given text.\n     *\n     * @param text           The text to remove emojis from.\n     * @param emojisToRemove The emojis to remove.\n     * @return The text without the given emojis.\n     */", "    public static String removeEmojis(final String text, final Collection<Emoji> emojisToRemove) {\n        final LinkedHashMap<Integer, List<Emoji>> FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING = emojisToRemove.stream().sorted(EMOJI_CODEPOINT_COMPARATOR).collect(getEmojiLinkedHashMapCollector());\n\n        final int[] textCodePointsArray = text.codePoints().toArray();\n        final long textCodePointsLength = textCodePointsArray.length;\n\n        final StringBuilder sb = new StringBuilder();\n\n        nextTextIteration:\n        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final int currentCodepoint = textCodePointsArray[textIndex];\n            sb.appendCodePoint(currentCodepoint);\n\n            final List<Emoji> emojisByCodePoint = FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(currentCodepoint);", "        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final int currentCodepoint = textCodePointsArray[textIndex];\n            sb.appendCodePoint(currentCodepoint);\n\n            final List<Emoji> emojisByCodePoint = FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(currentCodepoint);\n            if (emojisByCodePoint == null) continue;\n            for (final Emoji emoji : emojisByCodePoint) {\n                final int[] emojiCodePointsArray = emoji.getEmoji().codePoints().toArray();\n                final int emojiCodePointsLength = emojiCodePointsArray.length;\n                // Check if Emoji code points are in bounds of the text code points\n                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n", "                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n\n                for (int i = 0; i < emojiCodePointsLength; i++) {\n                    if (textCodePointsArray[textIndex + i] != emojiCodePointsArray[i]) {\n                        break;\n                    }\n                    if (i == emojiCodePointsLength - 1) {\n                        sb.delete(sb.length() - Character.charCount(currentCodepoint), sb.length());\n\n                        textIndex += emojiCodePointsLength - 1;\n                        continue nextTextIteration;\n                    }\n                }\n            }\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Removes all emojis except the given emojis from the given text.\n     *\n     * @param text         The text to remove emojis from.\n     * @param emojisToKeep The emojis to keep.\n     * @return The text with only the given emojis.\n     */", "                    if (i == emojiCodePointsLength - 1) {\n                        sb.delete(sb.length() - Character.charCount(currentCodepoint), sb.length());\n\n                        textIndex += emojiCodePointsLength - 1;\n                        continue nextTextIteration;\n                    }\n                }\n            }\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Removes all emojis except the given emojis from the given text.\n     *\n     * @param text         The text to remove emojis from.\n     * @param emojisToKeep The emojis to keep.\n     * @return The text with only the given emojis.\n     */", "    public static String removeAllEmojisExcept(final String text, final Collection<Emoji> emojisToKeep) {\n        final Set<Emoji> emojisToRemove = new HashSet<>(EMOJIS_LENGTH_DESCENDING);\n        emojisToRemove.removeAll(emojisToKeep);\n\n        return removeEmojis(text, emojisToRemove);\n    }\n\n    /**\n     * Removes all emojis except the given emojis from the given text.\n     *\n     * @param text         The text to remove emojis from.\n     * @param emojisToKeep The emojis to keep.\n     * @return The text with only the given emojis.\n     */", "    public static String removeAllEmojisExcept(final String text, final Emoji... emojisToKeep) {\n        return removeAllEmojisExcept(text, Arrays.asList(emojisToKeep));\n    }\n\n    /**\n     * Replaces all emojis in the text with the given replacement string.\n     *\n     * @param text              The text to replace emojis from.\n     * @param replacementString The replacement string.\n     * @return The text with all emojis replaced.\n     */", "    public static String replaceAllEmojis(final String text, final String replacementString) {\n        return replaceEmojis(text, replacementString, EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Replaces all emojis in the text with the given replacement function.\n     *\n     * @param text                The text to replace emojis from.\n     * @param replacementFunction The replacement function.\n     * @return The text with all emojis replaced.\n     */", "    public static String replaceAllEmojis(final String text, Function<Emoji, String> replacementFunction) {\n        return replaceEmojis(text, replacementFunction, EMOJIS_LENGTH_DESCENDING);\n    }\n\n    /**\n     * Replaces the given emojis with the given replacement string.\n     *\n     * @param text              The text to replace emojis from.\n     * @param replacementString The replacement string.\n     * @param emojisToReplace   The emojis to replace.\n     * @return The text with the given emojis replaced.\n     */", "    public static String replaceEmojis(final String text, final String replacementString, final Collection<Emoji> emojisToReplace) {\n        return replaceEmojis(text, emoji -> replacementString, emojisToReplace);\n    }\n\n    /**\n     * Replaces all emojis in the text with the given replacement function.\n     *\n     * @param text                The text to replace emojis from.\n     * @param replacementFunction The replacement function.\n     * @param emojisToReplace     The emojis to replace.\n     * @return The text with all emojis replaced.\n     */", "    public static String replaceEmojis(final String text, Function<Emoji, String> replacementFunction, final Collection<Emoji> emojisToReplace) {\n        if (isStringNullOrEmpty(text)) return \"\";\n\n        final LinkedHashMap<Integer, List<Emoji>> FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING = emojisToReplace.stream().sorted(EMOJI_CODEPOINT_COMPARATOR).collect(getEmojiLinkedHashMapCollector());\n\n        final int[] textCodePointsArray = text.codePoints().toArray();\n        final long textCodePointsLength = textCodePointsArray.length;\n\n        final StringBuilder sb = new StringBuilder();\n\n        nextTextIteration:", "        for (int textIndex = 0; textIndex < textCodePointsLength; textIndex++) {\n            final int currentCodepoint = textCodePointsArray[textIndex];\n            sb.appendCodePoint(currentCodepoint);\n\n            final List<Emoji> emojisByCodePoint = FIRST_CODEPOINT_TO_EMOJIS_ORDER_CODEPOINT_LENGTH_DESCENDING.get(currentCodepoint);\n            if (emojisByCodePoint == null) continue;\n            for (final Emoji emoji : emojisByCodePoint) {\n                final int[] emojiCodePointsArray = emoji.getEmoji().codePoints().toArray();\n                final int emojiCodePointsLength = emojiCodePointsArray.length;\n                // Check if Emoji code points are in bounds of the text code points\n                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n", "                if (!((textIndex + emojiCodePointsLength) <= textCodePointsLength)) {\n                    continue;\n                }\n\n                for (int i = 0; i < emojiCodePointsLength; i++) {\n                    if (textCodePointsArray[textIndex + i] != emojiCodePointsArray[i]) {\n                        break;\n                    }\n                    if (i == emojiCodePointsLength - 1) {\n                        //Does the same but is slower apparently\n                        //sb.replace(sb.length() - Character.charCount(currentCodepoint), sb.length(), replacementString);\n                        sb.delete(sb.length() - Character.charCount(currentCodepoint), sb.length());\n                        sb.append(replacementFunction.apply(emoji));\n\n                        textIndex += emojiCodePointsLength - 1;\n                        continue nextTextIteration;\n                    }\n                }\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static boolean isStringNullOrEmpty(final String string) {\n        return null == string || string.isEmpty();\n    }\n\n", "                    if (i == emojiCodePointsLength - 1) {\n                        //Does the same but is slower apparently\n                        //sb.replace(sb.length() - Character.charCount(currentCodepoint), sb.length(), replacementString);\n                        sb.delete(sb.length() - Character.charCount(currentCodepoint), sb.length());\n                        sb.append(replacementFunction.apply(emoji));\n\n                        textIndex += emojiCodePointsLength - 1;\n                        continue nextTextIteration;\n                    }\n                }\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static boolean isStringNullOrEmpty(final String string) {\n        return null == string || string.isEmpty();\n    }\n\n", "    /*public static List<Emoji> testEmojiPattern(final String text) {\n        if (isStringNullOrEmpty(text)) return Collections.emptyList();\n\n        final Matcher matcher = EMOJI_PATTERN.matcher(text);\n\n        final List<Emoji> emojis = new ArrayList<>();\n        while (matcher.find()) {\n            emojis.add(EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getEmoji().equals(matcher.group())).findFirst().get());\n        }\n        return Collections.unmodifiableList(emojis);\n    }*/\n", "    /*public static List<Emoji> extractEmojisInOrderEmojiRegex(String text) {\n        if (isStringNullOrEmpty(text)) return Collections.emptyList();\n\n        final List<Emoji> emojis = new ArrayList<>();\n        System.out.println(EMOJI_PATTERN.pattern());\n        System.out.println(EMOJI_PATTERN.toString());\n\n        Matcher matcher = EMOJI_PATTERN.matcher(text);\n        while (matcher.find()) {\n            String emoji = matcher.group();\n\n            emojis.add(EMOJI_CHAR_TO_EMOJI.get(emoji));\n        }\n\n        return emojis;\n    }*/\n}\n\n\n", "        while (matcher.find()) {\n            String emoji = matcher.group();\n\n            emojis.add(EMOJI_CHAR_TO_EMOJI.get(emoji));\n        }\n\n        return emojis;\n    }*/\n}\n\n\n"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/EmojiGroup.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Represents an emoji group.\n */\npublic enum EmojiGroup {\n\n    ACTIVITIES(\"Activities\"),\n    ANIMALS_AND_NATURE(\"Animals & Nature\"),\n    COMPONENT(\"Component\"),\n    FLAGS(\"Flags\"),\n    FOOD_AND_DRINK(\"Food & Drink\"),\n    OBJECTS(\"Objects\"),\n    PEOPLE_AND_BODY(\"People & Body\"),\n    SMILEYS_AND_EMOTION(\"Smileys & Emotion\"),\n    SYMBOLS(\"Symbols\"),\n    TRAVEL_AND_PLACES(\"Travel & Places\");\n\n    private static final List<EmojiGroup> EMOJI_GROUPS = Arrays.asList(values());\n    private final String name;\n\n    EmojiGroup(final String name) {\n        this.name = name;\n    }\n\n    /**\n     * Gets the name of the group.\n     *\n     * @return The name of the group\n     */", " * Represents an emoji group.\n */\npublic enum EmojiGroup {\n\n    ACTIVITIES(\"Activities\"),\n    ANIMALS_AND_NATURE(\"Animals & Nature\"),\n    COMPONENT(\"Component\"),\n    FLAGS(\"Flags\"),\n    FOOD_AND_DRINK(\"Food & Drink\"),\n    OBJECTS(\"Objects\"),\n    PEOPLE_AND_BODY(\"People & Body\"),\n    SMILEYS_AND_EMOTION(\"Smileys & Emotion\"),\n    SYMBOLS(\"Symbols\"),\n    TRAVEL_AND_PLACES(\"Travel & Places\");\n\n    private static final List<EmojiGroup> EMOJI_GROUPS = Arrays.asList(values());\n    private final String name;\n\n    EmojiGroup(final String name) {\n        this.name = name;\n    }\n\n    /**\n     * Gets the name of the group.\n     *\n     * @return The name of the group\n     */", "    public String getName() {\n        return name;\n    }\n\n    /**\n     * Gets all emoji groups.\n     *\n     * @return All emoji groups\n     */\n    public static List<EmojiGroup> getGroups() {\n        return EMOJI_GROUPS;\n    }\n\n    /**\n     * Gets the emoji group for the given name.\n     *\n     * @param name The name of the group.\n     * @return The emoji group.\n     */\n    @JsonCreator", "    public static List<EmojiGroup> getGroups() {\n        return EMOJI_GROUPS;\n    }\n\n    /**\n     * Gets the emoji group for the given name.\n     *\n     * @param name The name of the group.\n     * @return The emoji group.\n     */\n    @JsonCreator", "    public static EmojiGroup fromString(String name) {\n        for (EmojiGroup emojiGroup : EMOJI_GROUPS) {\n            if (emojiGroup.getName().equals(name)) {\n                return emojiGroup;\n            }\n        }\n        throw new IllegalArgumentException(\"No EmojiGroup found for name \" + name);\n    }\n\n}"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/Emoji.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;", "import java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Represents an emoji.\n */\npublic class Emoji {\n\n    private final String emoji;\n    private final String unicode;\n    private final List<String> discordAliases;\n    private final List<String> githubAliases;\n    private final List<String> slackAliases;\n    private final boolean hasFitzpatrick;\n    private final boolean hasHairStyle;\n    private final double version;\n    private final Qualification qualification;\n    private final String description;\n    private final EmojiGroup group;\n    private final EmojiSubGroup subgroup;\n\n    private final List<String> allAliases;\n\n    Emoji(\n            @JsonProperty(\"emoji\") String emoji,\n            @JsonProperty(\"unicode\") String unicode,\n            @JsonProperty(\"discordAliases\") List<String> discordAliases,\n            @JsonProperty(\"githubAliases\") List<String> githubAliases,\n            @JsonProperty(\"slackAliases\") List<String> slackAliases,\n            @JsonProperty(\"hasFitzpatrick\") boolean hasFitzpatrick,\n            @JsonProperty(\"hasHairStyle\") boolean hasHairStyle,\n            @JsonProperty(\"version\") double version,\n            @JsonProperty(\"qualification\") Qualification qualification,\n            @JsonProperty(\"description\") String description,\n            @JsonProperty(\"group\") EmojiGroup group,\n            @JsonProperty(\"subgroup\") EmojiSubGroup subgroup) {\n        this.emoji = emoji;\n        this.unicode = unicode;\n        this.discordAliases = discordAliases;\n        this.githubAliases = githubAliases;\n        this.slackAliases = slackAliases;\n        this.hasFitzpatrick = hasFitzpatrick;\n        this.hasHairStyle = hasHairStyle;\n        this.version = version;\n        this.qualification = qualification;\n        this.description = description;\n        this.group = group;\n        this.subgroup = subgroup;\n        Set<String> aliases = new HashSet<>();\n        aliases.addAll(getDiscordAliases());\n        aliases.addAll(getGithubAliases());\n        aliases.addAll(getSlackAliases());\n        allAliases = Collections.unmodifiableList(new ArrayList<>(aliases));\n    }\n\n    /**\n     * Gets the emoji.\n     *\n     * @return The emoji\n     */", " */\npublic class Emoji {\n\n    private final String emoji;\n    private final String unicode;\n    private final List<String> discordAliases;\n    private final List<String> githubAliases;\n    private final List<String> slackAliases;\n    private final boolean hasFitzpatrick;\n    private final boolean hasHairStyle;\n    private final double version;\n    private final Qualification qualification;\n    private final String description;\n    private final EmojiGroup group;\n    private final EmojiSubGroup subgroup;\n\n    private final List<String> allAliases;\n\n    Emoji(\n            @JsonProperty(\"emoji\") String emoji,\n            @JsonProperty(\"unicode\") String unicode,\n            @JsonProperty(\"discordAliases\") List<String> discordAliases,\n            @JsonProperty(\"githubAliases\") List<String> githubAliases,\n            @JsonProperty(\"slackAliases\") List<String> slackAliases,\n            @JsonProperty(\"hasFitzpatrick\") boolean hasFitzpatrick,\n            @JsonProperty(\"hasHairStyle\") boolean hasHairStyle,\n            @JsonProperty(\"version\") double version,\n            @JsonProperty(\"qualification\") Qualification qualification,\n            @JsonProperty(\"description\") String description,\n            @JsonProperty(\"group\") EmojiGroup group,\n            @JsonProperty(\"subgroup\") EmojiSubGroup subgroup) {\n        this.emoji = emoji;\n        this.unicode = unicode;\n        this.discordAliases = discordAliases;\n        this.githubAliases = githubAliases;\n        this.slackAliases = slackAliases;\n        this.hasFitzpatrick = hasFitzpatrick;\n        this.hasHairStyle = hasHairStyle;\n        this.version = version;\n        this.qualification = qualification;\n        this.description = description;\n        this.group = group;\n        this.subgroup = subgroup;\n        Set<String> aliases = new HashSet<>();\n        aliases.addAll(getDiscordAliases());\n        aliases.addAll(getGithubAliases());\n        aliases.addAll(getSlackAliases());\n        allAliases = Collections.unmodifiableList(new ArrayList<>(aliases));\n    }\n\n    /**\n     * Gets the emoji.\n     *\n     * @return The emoji\n     */", "    public String getEmoji() {\n        return emoji;\n    }\n\n    /**\n     * Gets the unicode representation of the emoji as a string i.e. \\uD83D\\uDC4D.\n     *\n     * @return The unicode representation of the emoji\n     */\n    public String getUnicode() {\n        return unicode;\n    }\n\n    /**\n     * Gets the HTML decimal code for this emoji.\n     *\n     * @return The HTML decimal code for this emoji.\n     */", "    public String getUnicode() {\n        return unicode;\n    }\n\n    /**\n     * Gets the HTML decimal code for this emoji.\n     *\n     * @return The HTML decimal code for this emoji.\n     */\n    public String getHtmlDecimalCode() {\n        return getEmoji().codePoints().mapToObj(operand -> \"&#\" + operand).collect(Collectors.joining(\";\")) + \";\";\n    }\n\n    /**\n     * Gets the HTML hexadecimal code for this emoji.\n     *\n     * @return The HTML hexadecimal code for this emoji.\n     */", "    public String getHtmlDecimalCode() {\n        return getEmoji().codePoints().mapToObj(operand -> \"&#\" + operand).collect(Collectors.joining(\";\")) + \";\";\n    }\n\n    /**\n     * Gets the HTML hexadecimal code for this emoji.\n     *\n     * @return The HTML hexadecimal code for this emoji.\n     */\n    public String getHtmlHexadecimalCode() {\n        return getEmoji().codePoints().mapToObj(operand -> \"&#x\" + Integer.toHexString(operand).toUpperCase()).collect(Collectors.joining(\";\")) + \";\";\n    }\n\n    /**\n     * Gets variations of this emoji with different Fitzpatrick or HairStyle modifiers, if there are any.\n     * The returned list does not include this emoji itself.\n     *\n     * @return Variations of this emoji with different Fitzpatrick or HairStyle modifiers, if there are any.\n     */\n    public List<Emoji> getVariations() {\n        final String baseEmoji = HairStyle.removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji));\n        return EmojiManager.getAllEmojis()\n                .parallelStream()\n                .filter(emoji -> HairStyle.removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji.getEmoji())).equals(baseEmoji))\n                .filter(emoji -> !emoji.equals(this))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Gets the URL encoded emoji.\n     *\n     * @return The URL encoded emoji\n     */", "    public String getHtmlHexadecimalCode() {\n        return getEmoji().codePoints().mapToObj(operand -> \"&#x\" + Integer.toHexString(operand).toUpperCase()).collect(Collectors.joining(\";\")) + \";\";\n    }\n\n    /**\n     * Gets variations of this emoji with different Fitzpatrick or HairStyle modifiers, if there are any.\n     * The returned list does not include this emoji itself.\n     *\n     * @return Variations of this emoji with different Fitzpatrick or HairStyle modifiers, if there are any.\n     */\n    public List<Emoji> getVariations() {\n        final String baseEmoji = HairStyle.removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji));\n        return EmojiManager.getAllEmojis()\n                .parallelStream()\n                .filter(emoji -> HairStyle.removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji.getEmoji())).equals(baseEmoji))\n                .filter(emoji -> !emoji.equals(this))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Gets the URL encoded emoji.\n     *\n     * @return The URL encoded emoji\n     */", "    public String getURLEncoded() {\n        try {\n            return URLEncoder.encode(getEmoji(), StandardCharsets.UTF_8.toString());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Gets the Discord aliases for this emoji.\n     *\n     * @return The Discord aliases for this emoji.\n     */\n    public List<String> getDiscordAliases() {\n        return discordAliases;\n    }\n\n    /**\n     * Gets the GitHub aliases for this emoji.\n     *\n     * @return The GitHub aliases for this emoji.\n     */\n    public List<String> getGithubAliases() {\n        return githubAliases;\n    }\n\n    /**\n     * Gets the Slack aliases for this emoji.\n     *\n     * @return The Slack aliases for this emoji.\n     */\n    public List<String> getSlackAliases() {\n        return slackAliases;\n    }\n\n    /**\n     * Gets all the aliases for this emoji.\n     *\n     * @return All the aliases for this emoji.\n     */\n    public List<String> getAllAliases() {\n        return allAliases;\n    }\n\n    /**\n     * Checks if this emoji has a fitzpatrick modifier.\n     *\n     * @return True if this emoji has a fitzpatrick modifier, false otherwise.\n     */", "    public boolean hasFitzpatrickComponent() {\n        return hasFitzpatrick;\n    }\n\n    /**\n     * Checks if this emoji has a hairstyle modifier.\n     *\n     * @return True if this emoji has a hairstyle modifier, false otherwise.\n     */\n    public boolean hasHairStyleComponent() {\n        return hasHairStyle;\n    }\n\n    /**\n     * Gets the version this emoji was added to the unicode consortium.\n     *\n     * @return The version this emoji was added to the unicode consortium.\n     */", "    public boolean hasHairStyleComponent() {\n        return hasHairStyle;\n    }\n\n    /**\n     * Gets the version this emoji was added to the unicode consortium.\n     *\n     * @return The version this emoji was added to the unicode consortium.\n     */\n    public double getVersion() {\n        return version;\n    }\n\n    /**\n     * Gets the qualification of this emoji.\n     *\n     * @return The qualification of this emoji.\n     */", "    public double getVersion() {\n        return version;\n    }\n\n    /**\n     * Gets the qualification of this emoji.\n     *\n     * @return The qualification of this emoji.\n     */\n    public Qualification getQualification() {\n        return qualification;\n    }\n\n    /**\n     * Gets the description of this emoji.\n     *\n     * @return The description of this emoji.\n     */", "    public Qualification getQualification() {\n        return qualification;\n    }\n\n    /**\n     * Gets the description of this emoji.\n     *\n     * @return The description of this emoji.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the group or \"category\" this emoji belongs to.\n     *\n     * @return The group this emoji belongs to.\n     */", "    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the group or \"category\" this emoji belongs to.\n     *\n     * @return The group this emoji belongs to.\n     */\n    public EmojiGroup getGroup() {\n        return group;\n    }\n\n    /**\n     * Gets the subgroup of this emoji.\n     *\n     * @return The subgroup of this emoji.\n     */", "    public EmojiGroup getGroup() {\n        return group;\n    }\n\n    /**\n     * Gets the subgroup of this emoji.\n     *\n     * @return The subgroup of this emoji.\n     */\n    public EmojiSubGroup getSubgroup() {\n        return subgroup;\n    }\n\n    @Override", "    public EmojiSubGroup getSubgroup() {\n        return subgroup;\n    }\n\n    @Override\n    public String toString() {\n        return \"Emoji{\" +\n                \"emoji='\" + emoji + '\\'' +\n                \", unicode='\" + unicode + '\\'' +\n                \", discordAliases=\" + discordAliases +\n                \", githubAliases=\" + githubAliases +\n                \", slackAliases=\" + slackAliases +\n                \", hasFitzpatrick=\" + hasFitzpatrick +\n                \", hasHairStyle=\" + hasHairStyle +\n                \", version=\" + version +\n                \", qualification=\" + qualification +\n                \", description='\" + description + '\\'' +\n                \", group=\" + group +\n                \", subgroup=\" + subgroup +\n                '}';\n    }\n\n    @Override", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Emoji emoji1 = (Emoji) o;\n\n        if (hasFitzpatrick != emoji1.hasFitzpatrick) return false;\n        if (hasHairStyle != emoji1.hasHairStyle) return false;\n        if (Double.compare(emoji1.version, version) != 0) return false;\n        if (!emoji.equals(emoji1.emoji)) return false;\n        if (!unicode.equals(emoji1.unicode)) return false;", "        if (Double.compare(emoji1.version, version) != 0) return false;\n        if (!emoji.equals(emoji1.emoji)) return false;\n        if (!unicode.equals(emoji1.unicode)) return false;\n        if (!discordAliases.equals(emoji1.discordAliases)) return false;\n        if (!githubAliases.equals(emoji1.githubAliases)) return false;\n        if (!slackAliases.equals(emoji1.slackAliases)) return false;\n        if (qualification != emoji1.qualification) return false;\n        if (!description.equals(emoji1.description)) return false;\n        if (group != emoji1.group) return false;\n        return subgroup == emoji1.subgroup;\n    }\n\n    @Override", "        if (group != emoji1.group) return false;\n        return subgroup == emoji1.subgroup;\n    }\n\n    @Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result = emoji.hashCode();\n        result = 31 * result + unicode.hashCode();\n        result = 31 * result + discordAliases.hashCode();\n        result = 31 * result + githubAliases.hashCode();\n        result = 31 * result + slackAliases.hashCode();\n        result = 31 * result + (hasFitzpatrick ? 1 : 0);\n        result = 31 * result + (hasHairStyle ? 1 : 0);\n        temp = Double.doubleToLongBits(version);\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + qualification.hashCode();\n        result = 31 * result + description.hashCode();\n        result = 31 * result + group.hashCode();\n        result = 31 * result + subgroup.hashCode();\n        return result;\n    }\n}\n"]}
{"filename": "lib/src/main/java/net/fellbaum/jemoji/Qualification.java", "chunked_list": ["package net.fellbaum.jemoji;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic enum Qualification {\n\n    COMPONENT(\"component\"),\n    FULLY_QUALIFIED(\"fully-qualified\"),\n    MINIMALLY_QUALIFIED(\"minimally-qualified\"),\n    UNQUALIFIED(\"unqualified\");\n\n    private static final List<Qualification> QUALIFICATION_LIST = Arrays.asList(values());\n    private final String qualification;\n\n    Qualification(final String qualification) {\n        this.qualification = qualification;\n    }\n", "    public String getQualification() {\n        return qualification;\n    }\n\n    @JsonCreator\n    public static Qualification fromString(final String qualification) {\n        for (Qualification q : QUALIFICATION_LIST) {\n            if (q.getQualification().equals(qualification)) {\n                return q;\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown qualification encountered\");\n    }\n}\n"]}
{"filename": "lib/src/jmh/java/benchmark/EmojiManagerBenchmark.java", "chunked_list": ["package benchmark;\n\nimport net.fellbaum.jemoji.Emoji;\nimport net.fellbaum.jemoji.EmojiManager;\nimport net.fellbaum.jemoji.EmojiManagerTest;\nimport org.openjdk.jmh.annotations.Benchmark;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;", "import java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\npublic class EmojiManagerBenchmark {\n\n    private static final String TEXT = new BufferedReader(new InputStreamReader(Objects.requireNonNull(EmojiManagerBenchmark.class.getClassLoader().getResourceAsStream(\"ExampleTextFileWithEmojis.txt\"))))\n            .lines().collect(Collectors.joining(\"\\n\"));\n\n    private static final String CONTAINS_EMOJI_TEXT = new BufferedReader(new InputStreamReader(Objects.requireNonNull(EmojiManagerBenchmark.class.getClassLoader().getResourceAsStream(\"ContainsBenchmarkTextFileWithEmojis.txt\"))))\n            .lines().collect(Collectors.joining(\"\\n\"));\n", "public class EmojiManagerBenchmark {\n\n    private static final String TEXT = new BufferedReader(new InputStreamReader(Objects.requireNonNull(EmojiManagerBenchmark.class.getClassLoader().getResourceAsStream(\"ExampleTextFileWithEmojis.txt\"))))\n            .lines().collect(Collectors.joining(\"\\n\"));\n\n    private static final String CONTAINS_EMOJI_TEXT = new BufferedReader(new InputStreamReader(Objects.requireNonNull(EmojiManagerBenchmark.class.getClassLoader().getResourceAsStream(\"ContainsBenchmarkTextFileWithEmojis.txt\"))))\n            .lines().collect(Collectors.joining(\"\\n\"));\n\n    public static void main(String[] args) throws Exception {\n        org.openjdk.jmh.Main.main(args);\n    }\n\n    private static final Collector<?, ?, ?> SHUFFLER = Collectors.collectingAndThen(\n            Collectors.toCollection(ArrayList::new),\n            list -> {\n                Collections.shuffle(list);\n                return list;\n            }\n    );\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Collector<T, ?, List<T>> toShuffledList() {\n        return (Collector<T, ?, List<T>>) SHUFFLER;\n    }\n\n    private static final String EMOJIS_RANDOM_ORDER = String.join(\"\", EmojiManager.getAllEmojisLengthDescending().stream().map(Emoji::getEmoji).collect(toShuffledList()));\n\n    @Benchmark\n    //@BenchmarkMode(Mode.AverageTime)\n    //@Warmup(iterations = 1)", "    public static void main(String[] args) throws Exception {\n        org.openjdk.jmh.Main.main(args);\n    }\n\n    private static final Collector<?, ?, ?> SHUFFLER = Collectors.collectingAndThen(\n            Collectors.toCollection(ArrayList::new),\n            list -> {\n                Collections.shuffle(list);\n                return list;\n            }\n    );\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Collector<T, ?, List<T>> toShuffledList() {\n        return (Collector<T, ?, List<T>>) SHUFFLER;\n    }\n\n    private static final String EMOJIS_RANDOM_ORDER = String.join(\"\", EmojiManager.getAllEmojisLengthDescending().stream().map(Emoji::getEmoji).collect(toShuffledList()));\n\n    @Benchmark\n    //@BenchmarkMode(Mode.AverageTime)\n    //@Warmup(iterations = 1)", "    public String replaceAllEmojis() {\n        return EmojiManager.replaceAllEmojis(TEXT, \"<replaced emoji>\");\n    }\n\n    @Benchmark\n    public String replaceAllEmojisFunction() {\n        return EmojiManager.replaceAllEmojis(TEXT, emoji -> emoji.getGroup().toString());\n    }\n\n    @Benchmark\n    public String removeAllEmojis() {\n        return EmojiManager.removeAllEmojis(TEXT);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrder() {\n        return EmojiManager.extractEmojisInOrder(TEXT);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrderOnlyEmojisLengthDescending() {\n        return EmojiManager.extractEmojisInOrder(EmojiManagerTest.ALL_EMOJIS_STRING);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrderOnlyEmojisRandomOrder() {\n        return EmojiManager.extractEmojisInOrder(EMOJIS_RANDOM_ORDER);\n    }\n\n    @Benchmark", "    public String removeAllEmojis() {\n        return EmojiManager.removeAllEmojis(TEXT);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrder() {\n        return EmojiManager.extractEmojisInOrder(TEXT);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrderOnlyEmojisLengthDescending() {\n        return EmojiManager.extractEmojisInOrder(EmojiManagerTest.ALL_EMOJIS_STRING);\n    }\n\n    @Benchmark\n    public List<Emoji> extractEmojisInOrderOnlyEmojisRandomOrder() {\n        return EmojiManager.extractEmojisInOrder(EMOJIS_RANDOM_ORDER);\n    }\n\n    @Benchmark", "    public boolean containsEmoji() {\n        return EmojiManager.containsEmoji(CONTAINS_EMOJI_TEXT);\n    }\n\n}\n"]}
