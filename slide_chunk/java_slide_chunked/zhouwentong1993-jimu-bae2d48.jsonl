{"filename": "core/src/test/java/com/wentong/jimu/test/CompleteFutureTest.java", "chunked_list": ["package com.wentong.jimu.test;\n\nimport org.junit.Test;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class CompleteFutureTest {\n\n    @Test\n    public void testWhenException() {\n        // \u6d4b\u8bd5 CompleteFuture \u629b\u51fa\u5f02\u5e38\u65f6\u8fd4\u56de\u503c\u7684\u60c5\u51b5\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            throw new RuntimeException(\"test\");\n        });\n        future.whenComplete((s, e) -> {\n            System.out.println(s);\n            System.out.println(e);\n        });\n    }\n\n}\n", "    public void testWhenException() {\n        // \u6d4b\u8bd5 CompleteFuture \u629b\u51fa\u5f02\u5e38\u65f6\u8fd4\u56de\u503c\u7684\u60c5\u51b5\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            throw new RuntimeException(\"test\");\n        });\n        future.whenComplete((s, e) -> {\n            System.out.println(s);\n            System.out.println(e);\n        });\n    }\n\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/locker/MemoryLockTest.java", "chunked_list": ["package com.wentong.jimu.locker;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.concurrent.TimeUnit;\n\nclass MemoryLockTest {\n\n    @Test", "\n    @Test\n    void tryLock() {\n        Lock lock = new MemoryLock();\n        Assertions.assertTrue(lock.tryLock(\"key1\"));\n        boolean lock1 = lock.tryLock(\"key1\", 100, TimeUnit.MILLISECONDS);\n        Assertions.assertFalse(lock1);\n        lock.release(\"key1\");\n        boolean lock2 = lock.tryLock(\"key1\");\n        Assertions.assertTrue(lock2);", "        boolean lock2 = lock.tryLock(\"key1\");\n        Assertions.assertTrue(lock2);\n    }\n\n    @Test\n    void testTryLockAndDeleteKey() {\n        Lock lock = new MemoryLock();\n        Assertions.assertTrue(lock.tryLock(\"key2\", 1000, TimeUnit.SECONDS));\n        Assertions.assertFalse(lock.tryLock(\"key2\", 10, TimeUnit.MILLISECONDS));\n        lock.deleteLock(\"key2\");", "        Assertions.assertFalse(lock.tryLock(\"key2\", 10, TimeUnit.MILLISECONDS));\n        lock.deleteLock(\"key2\");\n        Assertions.assertTrue(lock.tryLock(\"key2\", 10, TimeUnit.MILLISECONDS));\n\n    }\n\n    @Test\n    void lease() throws Exception {\n        Lock lock = new MemoryLock();\n        lock.tryLock(\"key3\", 2, 1, TimeUnit.SECONDS);", "        Lock lock = new MemoryLock();\n        lock.tryLock(\"key3\", 2, 1, TimeUnit.SECONDS);\n        Assertions.assertFalse(lock.tryLock(\"key3\", 10, TimeUnit.MILLISECONDS));\n        TimeUnit.SECONDS.sleep(2);\n        Assertions.assertTrue(lock.tryLock(\"key3\", 10, TimeUnit.MILLISECONDS));\n\n    }\n\n    @Test\n    void lock() {", "    @Test\n    void lock() {\n    }\n\n    @Test\n    void deleteLock() {\n    }\n}"]}
{"filename": "core/src/test/java/com/wentong/jimu/service/ServiceB.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.ServiceContext;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class ServiceB extends AbstractService<String> {\n    @Override\n    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceB.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + context.get(\"name\");\n    }\n}\n", "    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceB.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + context.get(\"name\");\n    }\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/service/ServiceC.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.ServiceContext;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class ServiceC extends AbstractService<String> {\n\n    @Override\n    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceC.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + message;\n    }\n}\n", "    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceC.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + message;\n    }\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/service/ServiceA.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.ServiceContext;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class ServiceA extends AbstractService<String> {\n\n    @Override\n    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceA.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + context.get(\"name\");\n    }\n}\n", "    public Object process(String message, ServiceContext context) {\n        log.info(\"ServiceA.process\");\n        log.info(\"message: {}, context:{}\", message, context);\n        return \"Hello \" + context.get(\"name\");\n    }\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/service/ServiceTest.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.flow.ServiceContext;\nimport com.wentong.jimu.flow.dispatcher.MemoryFlowDispatcher;\nimport com.wentong.jimu.flow.dispatcher.FlowDispatcher;\nimport org.junit.Test;\n\npublic class ServiceTest {\n\n    @Test", "public class ServiceTest {\n\n    @Test\n    public void testBasic() {\n        ServiceFactory.registerService(\"ServiceA\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceA\"));\n        ServiceFactory.registerService(\"ServiceB\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceA\"));\n        ServiceFactory.registerService(\"ServiceC\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceA\"));\n        ServiceContext serviceContext = new ServiceContext();\n        serviceContext.put(\"name\", \"wentong\");\n        serviceContext.put(\"age\", 18);\n\n        Flow flow = new Flow();\n        flow.startFlow(\"ServiceA\", \"hello\", serviceContext, false).nextFlow(\"ServiceB\", false).flowFinalTask(\"ServiceC\");\n        FlowDispatcher dispatcher = new MemoryFlowDispatcher();\n        dispatcher.submit(flow);\n    }\n\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/service/StartupTest.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.flow.ServiceContext;\nimport com.wentong.jimu.flow.dispatcher.FlowDispatcher;\nimport com.wentong.jimu.flow.dispatcher.MemoryFlowDispatcher;\nimport com.wentong.jimu.flow.task.TaskRunner;\nimport org.junit.Test;\n\npublic class StartupTest {\n\n    @Test", "\npublic class StartupTest {\n\n    @Test\n    public void testAll() {\n        ServiceFactory.registerService(\"ServiceA\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceA\"));\n        ServiceFactory.registerService(\"ServiceB\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceB\"));\n        ServiceFactory.registerService(\"ServiceC\", ServiceLoader.getInstance().loadClass(\"com.wentong.jimu.service.ServiceC\"));\n\n        ServiceContext serviceContext = new ServiceContext();\n        serviceContext.put(\"name\", \"wentong\");\n        serviceContext.put(\"age\", 18);\n\n        Flow flow = new Flow();\n        flow.startFlow(\"ServiceA\", \"hello\", serviceContext, false).nextFlow(\"ServiceB\", false).flowFinalTask(\"ServiceC\");\n        FlowDispatcher dispatcher = new MemoryFlowDispatcher();\n        dispatcher.submit(flow);\n\n        TaskRunner taskRunner = new TaskRunner(dispatcher);\n        taskRunner.go();\n\n        // \u4e3b\u7ebf\u7a0b join \u5728\u8fd9\u513f", "        try {\n            Thread.currentThread().join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n"]}
{"filename": "core/src/test/java/com/wentong/jimu/actor/ActorTest.java", "chunked_list": ["package com.wentong.jimu.actor;\n\nimport akka.actor.ActorRef;\nimport akka.actor.ActorSystem;\nimport akka.actor.Props;\nimport org.junit.Test;\n\npublic class ActorTest {\n\n    @Test\n    public void testActor1() {\n        // \u521b\u5efa actor \u7cfb\u7edf\n        ActorSystem system = ActorSystem.create(\"HelloWorld\");\n\n        // \u521b\u5efa HelloWorldActor \u5b9e\u4f8b\n        ActorRef helloWorldActor = system.actorOf(Props.create(HelloWorldActor.class), \"HelloWorldActor\");\n", "    public void testActor1() {\n        // \u521b\u5efa actor \u7cfb\u7edf\n        ActorSystem system = ActorSystem.create(\"HelloWorld\");\n\n        // \u521b\u5efa HelloWorldActor \u5b9e\u4f8b\n        ActorRef helloWorldActor = system.actorOf(Props.create(HelloWorldActor.class), \"HelloWorldActor\");\n\n        for (int i = 0; i < 100; i++) {\n\n            // \u53d1\u9001\u4e00\u6761\u6d88\u606f\u7ed9 HelloWorldActor\n            helloWorldActor.tell(\"hello\", ActorRef.noSender());\n        }\n\n        // \u5173\u95ed actor \u7cfb\u7edf\n//        system.terminate();\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/init/InputConvertScanner.java", "chunked_list": ["package com.wentong.jimu.init;\n\nimport cn.hutool.core.annotation.AnnotationUtil;\nimport com.wentong.jimu.flow.convert.InputConverter;\nimport com.wentong.jimu.service.Service;\nimport jakarta.annotation.PostConstruct;\nimport lombok.SneakyThrows;\n\nimport java.lang.annotation.Annotation;\nimport java.util.HashMap;", "import java.lang.annotation.Annotation;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * \u8f93\u5165\u8f6c\u6362\u626b\u63cf\u5668\n */\npublic class InputConvertScanner {\n\n    private Map<String, String> map = new HashMap<>();\n", "public class InputConvertScanner {\n\n    private Map<String, String> map = new HashMap<>();\n\n    public String getExpression(String service) {\n        return map.get(service);\n    }\n\n    public static void main(String[] args) {\n        // invoke init method\n        new InputConvertScanner().init();\n    }\n\n    @SneakyThrows\n    @PostConstruct", "    public static void main(String[] args) {\n        // invoke init method\n        new InputConvertScanner().init();\n    }\n\n    @SneakyThrows\n    @PostConstruct\n    public void init() {\n        List<Annotation> annotations = AnnotationUtil.scanMetaAnnotation(InputConverter.class);\n        InputConverter[] processes = AnnotationUtil.getAnnotations(Service.class.getMethod(\"process\", Object.class), false, InputConverter.class);\n        System.out.println(processes);\n\n\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/locker/Lock.java", "chunked_list": ["package com.wentong.jimu.locker;\n\nimport java.util.concurrent.TimeUnit;\n\npublic interface Lock {\n\n    /**\n     * Try to lock the key.\n     * @param key key to try\n     * @param timeout try timeout\n     * @param timeUnit timeunit\n     * @return true means lock success, false means lock failed.\n     */\n    boolean tryLock(String key, long timeout, TimeUnit timeUnit);\n\n    /**\n     * Try to lock the key with lease time.\n     * @param key key to try\n     * @param timeout try timeout\n     * @param leaseTime key to lease\n     * @param timeUnit timeunit\n     * @return true means lock success, false means lock failed.\n     */\n    boolean tryLock(String key, long timeout, long leaseTime, TimeUnit timeUnit);\n\n    void release(String key);\n\n    boolean tryLock(String key);\n\n    /**\n     * Delete the lock.\n     * @param key key to delete\n     */\n    void deleteLock(String key);\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/locker/MemoryLock.java", "chunked_list": ["package com.wentong.jimu.locker;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.*;\n\n/**", "\n/**\n * \u57fa\u4e8e\u5185\u5b58\u7684\u9501\n * \u8fd9\u91cc\u6ca1\u6709\u901a\u8fc7 ReentrantLock \u5b9e\u73b0\uff0c\u501f\u52a9\u4e8e\u4fe1\u53f7\u91cf\u5b9e\u73b0\u7684\u3002\n */\n@Slf4j\npublic class MemoryLock implements Lock {\n\n    private static final CacheLoader<String, Semaphore> LOADER = new CacheLoader<>() {\n        @Override\n        public Semaphore load(String key) {\n            return new Semaphore(1, true);\n        }\n    };\n    private static final LoadingCache<String, Semaphore> CACHE = CacheBuilder.newBuilder().build(LOADER);\n\n    private static final ThreadGroup THREAD_GROUP = new ThreadGroup(\"LocalOnlyLock-scheduler\");\n    private static final ThreadFactory THREAD_FACTORY = runnable -> new Thread(THREAD_GROUP, runnable);\n    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1, THREAD_FACTORY);\n\n    @Override", "        public Semaphore load(String key) {\n            return new Semaphore(1, true);\n        }\n    };\n    private static final LoadingCache<String, Semaphore> CACHE = CacheBuilder.newBuilder().build(LOADER);\n\n    private static final ThreadGroup THREAD_GROUP = new ThreadGroup(\"LocalOnlyLock-scheduler\");\n    private static final ThreadFactory THREAD_FACTORY = runnable -> new Thread(THREAD_GROUP, runnable);\n    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1, THREAD_FACTORY);\n\n    @Override", "    public boolean tryLock(String key, long timeout, TimeUnit timeUnit) {\n        try {\n            return CACHE.getUnchecked(key).tryAcquire(timeout, timeUnit);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public boolean tryLock(String key, long timeout, long leaseTime, TimeUnit timeUnit) {", "    public boolean tryLock(String key, long timeout, long leaseTime, TimeUnit timeUnit) {\n        try {\n            boolean lock = CACHE.getUnchecked(key).tryAcquire(timeout, timeUnit);\n            if (lock) {\n                SCHEDULER.schedule(() -> release(key), leaseTime, timeUnit);\n            }\n            return lock;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override", "    public void release(String key) {\n        synchronized (CACHE) {\n            if (CACHE.getUnchecked(key).availablePermits() == 0) {\n                CACHE.getUnchecked(key).release();\n            }\n        }\n    }\n\n    @Override\n    public boolean tryLock(String key) {\n        return CACHE.getUnchecked(key).tryAcquire();\n    }\n\n    @Override", "    public boolean tryLock(String key) {\n        return CACHE.getUnchecked(key).tryAcquire();\n    }\n\n    @Override\n    public void deleteLock(String key) {\n        CACHE.invalidate(key);\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/metrics/NotingMetrics.java", "chunked_list": ["package com.wentong.jimu.metrics;\n\n/**\n * \u4ec0\u4e48\u4e5f\u4e0d\u505a\u7684 metrics\n */\npublic class NotingMetrics implements Metrics{\n\n    @Override\n    public void start() {\n\n    }\n\n    @Override", "    public void start() {\n\n    }\n\n    @Override\n    public void stop() {\n\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/metrics/Metrics.java", "chunked_list": ["package com.wentong.jimu.metrics;\n\npublic interface Metrics {\n\n    void start();\n\n    void stop();\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/metrics/LoggingMetrics.java", "chunked_list": ["package com.wentong.jimu.metrics;\n\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class LoggingMetrics implements Metrics{\n\n    private ThreadLocal<Long> timer = new ThreadLocal<>();\n\n    @Override\n    public void start() {\n        long startTime = System.currentTimeMillis();\n        log.info(\"start at {}\", startTime);\n        timer.set(startTime);\n    }\n\n    @Override", "    public void start() {\n        long startTime = System.currentTimeMillis();\n        log.info(\"start at {}\", startTime);\n        timer.set(startTime);\n    }\n\n    @Override\n    public void stop() {\n        log.info(\"stop\");\n        Long start = timer.get();\n        if (start != null) {\n            log.info(\"cost {} ms\", System.currentTimeMillis() - start);\n        }\n        timer.remove();\n    }\n}\n", "        if (start != null) {\n            log.info(\"cost {} ms\", System.currentTimeMillis() - start);\n        }\n        timer.remove();\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/thread/CountDownLatch2.java", "chunked_list": ["/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.wentong.jimu.thread;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n", "import java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/**\n * Add reset feature for @see java.util.concurrent.CountDownLatch\n */\npublic class CountDownLatch2 {\n  private final Sync sync;\n\n  /**\n   * Constructs a {@code CountDownLatch2} initialized with the given count.\n   * \n   * @param count the number of times {@link #countDown} must be invoked before\n   *        threads can pass through {@link #await}\n   * @throws IllegalArgumentException if {@code count} is negative\n   */\n  public CountDownLatch2(int count) {", "    if (count < 0) {\n      throw new IllegalArgumentException(\"count < 0\");\n    }\n    this.sync = new Sync(count);\n  }\n\n  /**\n   * Causes the current thread to wait until the latch has counted down to zero,\n   * unless the thread is {@linkplain Thread#interrupt interrupted}.\n   * \n   * <p>\n   * If the current count is zero then this method returns immediately.\n   * \n   * <p>\n   * If the current count is greater than zero then the current thread becomes\n   * disabled for thread scheduling purposes and lies dormant until one of two\n   * things happen:\n   * <ul>\n   * <li>The count reaches zero due to invocations of the {@link #countDown}\n   * method; or\n   * <li>Some other thread {@linkplain Thread#interrupt interrupts} the current\n   * thread.\n   * </ul>\n   * \n   * <p>\n   * If the current thread:\n   * <ul>\n   * <li>has its interrupted status set on entry to this method; or\n   * <li>is {@linkplain Thread#interrupt interrupted} while waiting,\n   * </ul>\n   * then {@link InterruptedException} is thrown and the current thread's\n   * interrupted status is cleared.\n   * \n   * @throws InterruptedException if the current thread is interrupted while\n   *         waiting\n   */", "  public void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n  }\n\n  /**\n   * Causes the current thread to wait until the latch has counted down to zero,\n   * unless the thread is {@linkplain Thread#interrupt interrupted}, or the\n   * specified waiting time elapses.\n   * \n   * <p>\n   * If the current count is zero then this method returns immediately with the\n   * value {@code true}.\n   * \n   * <p>\n   * If the current count is greater than zero then the current thread becomes\n   * disabled for thread scheduling purposes and lies dormant until one of three\n   * things happen:\n   * <ul>\n   * <li>The count reaches zero due to invocations of the {@link #countDown}\n   * method; or\n   * <li>Some other thread {@linkplain Thread#interrupt interrupts} the current\n   * thread; or\n   * <li>The specified waiting time elapses.\n   * </ul>\n   * \n   * <p>\n   * If the count reaches zero then the method returns with the value\n   * {@code true}.\n   * \n   * <p>\n   * If the current thread:\n   * <ul>\n   * <li>has its interrupted status set on entry to this method; or\n   * <li>is {@linkplain Thread#interrupt interrupted} while waiting,\n   * </ul>\n   * then {@link InterruptedException} is thrown and the current thread's\n   * interrupted status is cleared.\n   * \n   * <p>\n   * If the specified waiting time elapses then the value {@code false} is\n   * returned. If the time is less than or equal to zero, the method will not\n   * wait at all.\n   * \n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the {@code timeout} argument\n   * @return {@code true} if the count reached zero and {@code false} if the\n   *         waiting time elapsed before the count reached zero\n   * @throws InterruptedException if the current thread is interrupted while\n   *         waiting\n   */", "  public boolean await(long timeout, TimeUnit unit) throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n  }\n\n  /**\n   * Decrements the count of the latch, releasing all waiting threads if the\n   * count reaches zero.\n   * \n   * <p>\n   * If the current count is greater than zero then it is decremented. If the\n   * new count is zero then all waiting threads are re-enabled for thread\n   * scheduling purposes.\n   * \n   * <p>\n   * If the current count equals zero then nothing happens.\n   */", "  public void countDown() {\n    sync.releaseShared(1);\n  }\n\n  /**\n   * Returns the current count.\n   * \n   * <p>\n   * This method is typically used for debugging and testing purposes.\n   * \n   * @return the current count\n   */", "  public long getCount() {\n    return sync.getCount();\n  }\n\n  public void reset() {\n    sync.reset();\n  }\n\n  /**\n   * Returns a string identifying this latch, as well as its state. The state,\n   * in brackets, includes the String {@code \"Count =\"} followed by the current\n   * count.\n   * \n   * @return a string identifying this latch, as well as its state\n   */", "  public String toString() {\n    return super.toString() + \"[Count = \" + sync.getCount() + \"]\";\n  }\n\n  /**\n   * Synchronization control For CountDownLatch2. Uses AQS state to represent\n   * count.\n   */\n  private static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    private final int startCount;\n\n    Sync(int count) {\n      this.startCount = count;\n      setState(count);\n    }\n\n    int getCount() {\n      return getState();\n    }\n\n    protected int tryAcquireShared(int acquires) {\n      return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n      // Decrement count; signal when transition to zero", "      for (;;) {\n        int state = getState();\n        if (state == 0) {\n          return false;\n        }\n        int nextc = state - 1;\n        if (compareAndSetState(state, nextc)) {\n          return nextc == 0;\n        }\n      }\n    }\n\n    protected void reset() {\n      setState(startCount);\n    }\n  }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/thread/ServiceThread.java", "chunked_list": ["package com.wentong.jimu.thread;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n@Slf4j\npublic abstract class ServiceThread implements Runnable {\n\n    private static final long JOIN_TIME = 90 * 1000;\n    private static final AtomicInteger index = new AtomicInteger();\n\n    protected final Thread thread;\n    protected final CountDownLatch2 waitPoint = new CountDownLatch2(1);\n    protected volatile AtomicBoolean hasNotified = new AtomicBoolean(false);\n    protected volatile boolean stopped = false;\n\n    public ServiceThread() {\n        this.thread = new Thread(this, this.getServiceName() + \"-\" + index.incrementAndGet());\n    }\n", "@Slf4j\npublic abstract class ServiceThread implements Runnable {\n\n    private static final long JOIN_TIME = 90 * 1000;\n    private static final AtomicInteger index = new AtomicInteger();\n\n    protected final Thread thread;\n    protected final CountDownLatch2 waitPoint = new CountDownLatch2(1);\n    protected volatile AtomicBoolean hasNotified = new AtomicBoolean(false);\n    protected volatile boolean stopped = false;\n\n    public ServiceThread() {\n        this.thread = new Thread(this, this.getServiceName() + \"-\" + index.incrementAndGet());\n    }\n", "    public abstract String getServiceName();\n\n    public void start() {\n        this.thread.start();\n    }\n\n\n    @Override\n    public final void run() {\n        try {\n            doService();\n        } catch (Exception e) {\n            log.error(\"\", e);\n        }\n    }\n", "    public final void run() {\n        try {\n            doService();\n        } catch (Exception e) {\n            log.error(\"\", e);\n        }\n    }\n\n    public abstract void doService();\n\n    public void shutdown() {\n        this.shutdown(false);\n    }\n", "    public abstract void doService();\n\n    public void shutdown() {\n        this.shutdown(false);\n    }\n\n    public void shutdown(final boolean interrupt) {\n        this.stopped = true;\n        log.info(\"shutdown thread \" + this.getServiceName() + \" interrupt \" + interrupt);\n\n        if (hasNotified.compareAndSet(false, true)) {\n            waitPoint.countDown(); // notify\n        }\n", "        if (hasNotified.compareAndSet(false, true)) {\n            waitPoint.countDown(); // notify\n        }\n\n        try {\n            if (interrupt) {\n                this.thread.interrupt();\n            }\n\n            long beginTime = System.currentTimeMillis();\n            if (!this.thread.isDaemon()) {\n                this.thread.join(this.getJointime());\n            }\n            long eclipseTime = System.currentTimeMillis() - beginTime;\n            log.info(\"join thread \" + this.getServiceName() + \" eclipse time(ms) \" + eclipseTime + \" \" + this.getJointime());\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted\", e);\n        }\n    }\n", "            if (!this.thread.isDaemon()) {\n                this.thread.join(this.getJointime());\n            }\n            long eclipseTime = System.currentTimeMillis() - beginTime;\n            log.info(\"join thread \" + this.getServiceName() + \" eclipse time(ms) \" + eclipseTime + \" \" + this.getJointime());\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted\", e);\n        }\n    }\n\n    public long getJointime() {\n        return JOIN_TIME;\n    }\n", "    public long getJointime() {\n        return JOIN_TIME;\n    }\n\n    public void stop() {\n        this.stop(false);\n    }\n\n    public void stop(final boolean interrupt) {\n        this.stopped = true;\n        log.info(\"stop thread \" + this.getServiceName() + \" interrupt \" + interrupt);\n", "    public void stop(final boolean interrupt) {\n        this.stopped = true;\n        log.info(\"stop thread \" + this.getServiceName() + \" interrupt \" + interrupt);\n\n        if (hasNotified.compareAndSet(false, true)) {\n            waitPoint.countDown(); // notify\n        }\n\n        if (interrupt) {\n            this.thread.interrupt();\n        }\n    }\n", "        if (interrupt) {\n            this.thread.interrupt();\n        }\n    }\n\n    public void makeStop() {\n        this.stopped = true;\n        log.info(\"makestop thread \" + this.getServiceName());\n    }\n\n    public void wakeup() {", "    public void wakeup() {\n        if (hasNotified.compareAndSet(false, true)) {\n            waitPoint.countDown(); // notify\n        }\n    }\n\n    protected void waitForRunning(long interval) {\n        if (hasNotified.compareAndSet(true, false)) {\n            this.onWaitEnd();\n            return;\n        }\n\n        // entry to wait\n        waitPoint.reset();\n", "        try {\n            waitPoint.await(interval, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted\", e);\n        } finally {\n            hasNotified.set(false);\n            this.onWaitEnd();\n        }\n    }\n\n    protected void onWaitEnd() {\n    }\n", "    public boolean isStopped() {\n        return stopped;\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/Flow.java", "chunked_list": ["package com.wentong.jimu.flow;\n\nimport cn.hutool.core.util.IdUtil;\nimport com.wentong.jimu.flow.task.FlowTask;\nimport com.wentong.jimu.flow.task.TaskFactory;\nimport lombok.NonNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;", "import java.util.List;\nimport java.util.Objects;\n\nimport static com.wentong.jimu.flow.FlowType.TEST;\n\npublic class Flow {\n\n    private final List<FlowTask> tasks = new ArrayList<>();\n    private ServiceContext serviceContext;\n\n    private String flowId;\n", "    public Flow startFlow(@NonNull String service, Object input, ServiceContext serviceContext,  boolean finalTask) {\n        flowId = IdUtil.fastUUID();\n        FlowTask task = TaskFactory.buildTask(service, input, this, TEST, finalTask);\n        tasks.add(task);\n        this.serviceContext = serviceContext;\n        return this;\n    }\n\n    /**\n     * next flow\uff0c\u7528\u6765\u8fde\u63a5\u90a3\u79cd\u6ca1\u6709\u7ec8\u6b62\u4efb\u52a1\u7684\n     */", "    public Flow nextFlowWithoutEndTask(String... service) {\n        Objects.requireNonNull(serviceContext, \"\u5fc5\u987b\u5148\u8c03\u7528 startFlow \u65b9\u6cd5\");\n        for (String s : service) {\n            FlowTask task = TaskFactory.buildTask(s, this, TEST, false);\n            tasks.add(task);\n        }\n        return this;\n    }\n\n    public Flow nextFlow(String service, boolean finalTask) {\n        Objects.requireNonNull(serviceContext, \"\u5fc5\u987b\u5148\u8c03\u7528 startFlow \u65b9\u6cd5\");\n        FlowTask task = TaskFactory.buildTask(service, this, TEST, finalTask);\n        tasks.add(task);\n        return this;\n    }\n", "    public Flow nextFlow(String service, boolean finalTask) {\n        Objects.requireNonNull(serviceContext, \"\u5fc5\u987b\u5148\u8c03\u7528 startFlow \u65b9\u6cd5\");\n        FlowTask task = TaskFactory.buildTask(service, this, TEST, finalTask);\n        tasks.add(task);\n        return this;\n    }\n\n    public Flow flowFinalTask(String service) {\n        Objects.requireNonNull(serviceContext, \"\u5fc5\u987b\u5148\u8c03\u7528 startFlow \u65b9\u6cd5\");\n        FlowTask task = TaskFactory.buildTask(service, this, TEST, true);\n        tasks.add(task);\n        return this;\n    }\n", "    public ServiceContext getServiceContext() {\n        return serviceContext;\n    }\n\n    public String getFlowId() {\n        return flowId;\n    }\n\n    public List<FlowTask> getTasks() {\n        return tasks;\n    }\n", "    public String getTaskType() {\n        return tasks.get(0).getTaskType();\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/FlowType.java", "chunked_list": ["package com.wentong.jimu.flow;\n\npublic class FlowType {\n\n    public static final String TEST = \"test\";\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/ServiceContext.java", "chunked_list": ["package com.wentong.jimu.flow;\n\nimport cn.hutool.core.lang.Dict;\n\n/**\n * flow \u4e0a\u4e0b\u6587\n */\npublic class ServiceContext extends Dict {\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/DefaultTask.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport cn.hutool.core.util.IdUtil;\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.metrics.LoggingMetrics;\nimport com.wentong.jimu.metrics.Metrics;\nimport com.wentong.jimu.service.Service;\nimport lombok.extern.slf4j.Slf4j;\n\n/**", "\n/**\n * \u9ed8\u8ba4\u7684 Task\n */\n@Slf4j\npublic class DefaultTask implements FlowTask {\n\n    private Object input;\n\n    private final Service service;\n\n    private final Flow flow;\n\n    private final String id;\n\n    private final Metrics metrics;\n\n    private final String flowType;\n\n    private final boolean finalTask;\n\n    public DefaultTask(Service<?> service, Object input, Flow flow, String flowType, boolean finalTask) {\n        this.service = service;\n        this.input = input;\n        this.flow = flow;\n        this.flowType = flowType;\n        this.finalTask = finalTask;\n        this.id = IdUtil.fastUUID();\n        metrics = new LoggingMetrics();\n    }\n\n    @Override", "    public void before() {\n        service.before();\n    }\n\n    @Override\n    public TaskResult process() {\n        String executionId = IdUtil.fastUUID();\n        log.info(\"\u6267\u884c id\uff1a{}\", executionId);\n        metrics.start();\n        Object output = service.process(input, getFlow().getServiceContext());\n        metrics.stop();\n        return TaskResult.builder().input(input).output(output).executionId(IdUtil.fastUUID()).taskId(getId()).status(TaskStatusEnum.SUCCESS).build();\n    }\n\n    @Override", "    public void after() {\n        service.after();\n    }\n\n    @Override\n    public void exception(Throwable e) {\n        service.exception(e);\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    @Override", "    public String getId() {\n        return id;\n    }\n\n    @Override\n    public Flow getFlow() {\n        return this.flow;\n    }\n\n    @Override\n    public TaskStatusEnum getStatus() {\n        return null;\n    }\n\n    @Override", "    public TaskStatusEnum getStatus() {\n        return null;\n    }\n\n    @Override\n    public String getTaskType() {\n        return flowType;\n    }\n\n    @Override\n    public boolean finalTask() {\n        return finalTask;\n    }\n\n    @Override", "    public boolean finalTask() {\n        return finalTask;\n    }\n\n    @Override\n    public String toString() {\n        return \"DefaultTask{\" + \"input=\" + input + \", service=\" + service + \", flow=\" + flow + \", id='\" + id + '\\'' + \", metrics=\" + metrics + \", flowType='\" + flowType + '\\'' + '}';\n    }\n\n    public void setInput(Object input) {\n        this.input = input;\n    }\n\n}\n", "    public void setInput(Object input) {\n        this.input = input;\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskExecutor.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport cn.hutool.core.util.IdUtil;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport com.wentong.jimu.flow.worker.Worker;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class TaskExecutor {\n\n    private final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1000), new ThreadFactoryBuilder().setNameFormat(\"demo-pool-%d\").build());\n\n    public CompletableFuture<TaskResult> submit(Worker worker, Task task) {\n        return CompletableFuture.supplyAsync(() -> {\n            task.before();\n            try {\n                return worker.execute(task);\n            } catch (Throwable e) {\n                task.exception(e);\n                return TaskResult.builder().executionId(IdUtil.fastUUID()).status(TaskStatusEnum.FAIL).build();\n            }\n\n        }, threadPoolExecutor);\n    }\n\n}\n", "            try {\n                return worker.execute(task);\n            } catch (Throwable e) {\n                task.exception(e);\n                return TaskResult.builder().executionId(IdUtil.fastUUID()).status(TaskStatusEnum.FAIL).build();\n            }\n\n        }, threadPoolExecutor);\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskResult.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * \u4efb\u52a1\u6267\u884c\u7ed3\u679c\n */\n@Data\n@Builder\npublic class TaskResult {\n\n    private Object input;\n    private Object output;\n    private Throwable throwable;\n    private String executionId;\n    private TaskStatusEnum status;\n    private String taskId;\n\n}\n", "@Data\n@Builder\npublic class TaskResult {\n\n    private Object input;\n    private Object output;\n    private Throwable throwable;\n    private String executionId;\n    private TaskStatusEnum status;\n    private String taskId;\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskConstant.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\npublic class TaskConstant {\n\n    public static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskRunner.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport com.wentong.jimu.flow.dispatcher.FlowDispatcher;\nimport com.wentong.jimu.flow.task.poller.LocalTaskPoller;\nimport com.wentong.jimu.flow.task.poller.PollingExecutor;\nimport com.wentong.jimu.flow.task.poller.PollingSemaphore;\nimport com.wentong.jimu.flow.task.reporter.LocalTaskReporter;\nimport com.wentong.jimu.flow.worker.LocalSampleWorker;\nimport com.wentong.jimu.flow.worker.Worker;\n", "import com.wentong.jimu.flow.worker.Worker;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.wentong.jimu.flow.task.TaskConstant.CPU_COUNT;\n\npublic class TaskRunner {\n\n    private final PollingExecutor pollingExecutor;\n    private final List<Worker> workers = new ArrayList<>();\n\n    private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(CPU_COUNT);\n\n    public TaskRunner(FlowDispatcher flowDispatcher) {\n        pollingExecutor = new PollingExecutor(new PollingSemaphore(), new LocalTaskPoller(flowDispatcher), new LocalTaskReporter(flowDispatcher));", "import static com.wentong.jimu.flow.task.TaskConstant.CPU_COUNT;\n\npublic class TaskRunner {\n\n    private final PollingExecutor pollingExecutor;\n    private final List<Worker> workers = new ArrayList<>();\n\n    private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(CPU_COUNT);\n\n    public TaskRunner(FlowDispatcher flowDispatcher) {\n        pollingExecutor = new PollingExecutor(new PollingSemaphore(), new LocalTaskPoller(flowDispatcher), new LocalTaskReporter(flowDispatcher));", "        for (int i = 0; i < CPU_COUNT; i++) {\n            workers.add(new LocalSampleWorker());\n        }\n    }\n\n    /**\n     * \u4efb\u52a1\u521d\u59cb\u5316\n     * \u91cc\u9762\u5305\u62ec\u4e00\u4e2a\u5b9a\u65f6\u4efb\u52a1\uff0c\u5b9a\u65f6\u53bb\u62c9\u53d6\u4efb\u52a1\n     */\n    public synchronized void go() {\n        workers.forEach(worker -> scheduledExecutorService.scheduleWithFixedDelay(() -> pollingExecutor.getAndExecute(worker), 0, 2, TimeUnit.SECONDS));\n    }\n}\n", "    public synchronized void go() {\n        workers.forEach(worker -> scheduledExecutorService.scheduleWithFixedDelay(() -> pollingExecutor.getAndExecute(worker), 0, 2, TimeUnit.SECONDS));\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskStatusEnum.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\npublic enum TaskStatusEnum {\n\n    WAITING, // \u7b49\u5f85\n    RUNNING, // \u8fd0\u884c\u4e2d\n    SUCCESS, // \u6210\u529f\n    FAIL // \u5931\u8d25\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/Task.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\n/**\n * \u4efb\u52a1\n */\npublic interface Task {\n\n    /**\n     * \u524d\u7f6e\u5904\u7406\u5668\n     */\n    void before();\n\n    /**\n     * \u670d\u52a1\u5904\u7406\n     */\n    TaskResult process();\n\n    /**\n     * \u540e\u7f6e\u5904\u7406\u5668\n     */\n    void after();\n\n    /**\n     * \u5f02\u5e38\u5904\u7406\u5668\n     */\n    void exception(Throwable e);\n\n    /**\n     * \u83b7\u53d6\u4efb\u52a1 id\n     */\n    String getId();\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/TaskFactory.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.service.ServiceFactory;\n\npublic class TaskFactory {\n\n    public static FlowTask buildTask(String service, Object input, Flow flow, String flowType, boolean finalTask) {\n        return new DefaultTask(ServiceFactory.getService(service), input, flow, flowType, finalTask);\n    }\n", "    public static FlowTask buildTask(String service, Flow flow, String flowType, boolean finalTask) {\n        return new DefaultTask(ServiceFactory.getService(service), null, flow, flowType, finalTask);\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/FlowTask.java", "chunked_list": ["package com.wentong.jimu.flow.task;\n\nimport com.wentong.jimu.flow.Flow;\n\npublic interface FlowTask extends Task {\n\n    Flow getFlow();\n\n    TaskStatusEnum getStatus();\n\n    String getTaskType();\n\n    boolean finalTask();\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/reporter/LocalTaskReporter.java", "chunked_list": ["package com.wentong.jimu.flow.task.reporter;\n\nimport com.wentong.jimu.flow.dispatcher.FlowDispatcher;\nimport com.wentong.jimu.flow.task.TaskResult;\nimport lombok.NonNull;\n\nimport java.util.Arrays;\n\npublic class LocalTaskReporter implements TaskReporter {\n\n    private final FlowDispatcher flowDispatcher;\n\n    public LocalTaskReporter(FlowDispatcher flowDispatcher) {\n        this.flowDispatcher = flowDispatcher;\n    }\n\n    @Override", "public class LocalTaskReporter implements TaskReporter {\n\n    private final FlowDispatcher flowDispatcher;\n\n    public LocalTaskReporter(FlowDispatcher flowDispatcher) {\n        this.flowDispatcher = flowDispatcher;\n    }\n\n    @Override\n    public void report(@NonNull TaskResult... taskResults) {\n        Arrays.stream(taskResults).forEach(flowDispatcher::reportTaskResult);\n    }\n}\n", "    public void report(@NonNull TaskResult... taskResults) {\n        Arrays.stream(taskResults).forEach(flowDispatcher::reportTaskResult);\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/reporter/TaskReporter.java", "chunked_list": ["package com.wentong.jimu.flow.task.reporter;\n\nimport com.wentong.jimu.flow.task.TaskResult;\nimport lombok.NonNull;\n\npublic interface TaskReporter {\n\n    void report(@NonNull TaskResult... taskResult);\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/poller/LocalTaskPoller.java", "chunked_list": ["package com.wentong.jimu.flow.task.poller;\n\nimport com.wentong.jimu.flow.dispatcher.FlowDispatcher;\nimport com.wentong.jimu.flow.task.FlowTask;\n\nimport java.util.List;\n\n/**\n * \u901a\u8fc7\u672c\u5730\u65b9\u6cd5\u8c03\u7528 dispatcher \u7684\u65b9\u5f0f\u53bb\u83b7\u53d6\u4efb\u52a1\uff0c\u4ec5\u9002\u7528\u4e8e\u5355\u673a\u73af\u5883\u3002\n */\npublic class LocalTaskPoller implements TaskPoller {\n\n    private final FlowDispatcher flowDispatcher;\n\n    public LocalTaskPoller(FlowDispatcher flowDispatcher) {\n        this.flowDispatcher = flowDispatcher;\n    }\n\n    @Override", " * \u901a\u8fc7\u672c\u5730\u65b9\u6cd5\u8c03\u7528 dispatcher \u7684\u65b9\u5f0f\u53bb\u83b7\u53d6\u4efb\u52a1\uff0c\u4ec5\u9002\u7528\u4e8e\u5355\u673a\u73af\u5883\u3002\n */\npublic class LocalTaskPoller implements TaskPoller {\n\n    private final FlowDispatcher flowDispatcher;\n\n    public LocalTaskPoller(FlowDispatcher flowDispatcher) {\n        this.flowDispatcher = flowDispatcher;\n    }\n\n    @Override", "    public FlowTask poll(String flowType) {\n        return flowDispatcher.getTask(flowType);\n    }\n\n    @Override\n    public List<FlowTask> batchPoll(String flowType, int size) {\n        return flowDispatcher.getTasks(flowType, size);\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/poller/PollingSemaphore.java", "chunked_list": ["package com.wentong.jimu.flow.task.poller;\n\nimport java.util.concurrent.Semaphore;\n\n/**\n * \u7528\u6765\u63a7\u5236\u4efb\u52a1\u62c9\u53d6\u7684\u4fe1\u53f7\u91cf\n */\npublic class PollingSemaphore {\n\n    private static final int DEFAULT_PERMITS = Runtime.getRuntime().availableProcessors() * 10;\n\n    private final Semaphore semaphore;\n\n    public PollingSemaphore() {\n        semaphore = new Semaphore(DEFAULT_PERMITS);\n    }\n", "    public boolean canPoll() {\n        return semaphore.tryAcquire();\n    }\n\n    public void release() {\n        semaphore.release();\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/poller/PollingExecutor.java", "chunked_list": ["package com.wentong.jimu.flow.task.poller;\n\nimport com.wentong.jimu.flow.task.Task;\nimport com.wentong.jimu.flow.task.TaskExecutor;\nimport com.wentong.jimu.flow.task.TaskResult;\nimport com.wentong.jimu.flow.task.reporter.TaskReporter;\nimport com.wentong.jimu.flow.worker.Worker;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.CompletableFuture;", "\nimport java.util.concurrent.CompletableFuture;\n\n@Slf4j\npublic class PollingExecutor {\n\n    private final PollingSemaphore pollingSemaphore;\n    private final TaskPoller taskPoller;\n    private final TaskExecutor taskExecutor;\n    private final TaskReporter taskReporter;\n\n    public PollingExecutor(PollingSemaphore pollingSemaphore, TaskPoller taskPoller, TaskReporter taskReporter) {\n        this.pollingSemaphore = pollingSemaphore;\n        this.taskPoller = taskPoller;\n        this.taskReporter = taskReporter;\n        this.taskExecutor = new TaskExecutor();\n    }\n", "    public void getAndExecute(Worker worker) {\n        if (pollingSemaphore.canPoll()) {\n            try {\n                Task task = taskPoller.poll(worker.getFlowType());\n                if (task != null) {\n                    log.info(\"polling task: {}\", task);\n                    CompletableFuture<TaskResult> future = taskExecutor.submit(worker, task);\n                    future.whenComplete((result, throwable) -> {\n                        // \u5728\u4efb\u52a1\u4e2d\u5df2\u7ecf\u5904\u7406\u4e86\u5f02\u5e38\uff0c\u8fd9\u91cc\u4e0d\u9700\u8981\u518d\u5904\u7406\n                        log.info(\"task result: {}\", result);\n                        taskReporter.report(result);\n                    });\n                }\n            } finally {\n                pollingSemaphore.release();\n            }\n        }\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/task/poller/TaskPoller.java", "chunked_list": ["package com.wentong.jimu.flow.task.poller;\n\nimport com.wentong.jimu.flow.task.FlowTask;\n\nimport java.util.List;\n\npublic interface TaskPoller {\n\n    FlowTask poll(String flowType);\n\n    List<FlowTask> batchPoll(String flowType, int size);\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/executor/DefaultFlowExecutor.java", "chunked_list": ["package com.wentong.jimu.flow.executor;\n\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.lifecycle.LifeCycle;\nimport com.wentong.jimu.service.Service;\nimport com.wentong.jimu.thread.ServiceThread;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;", "import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * \u9ed8\u8ba4\u7684\u6d41\u7a0b\u6267\u884c\u5668\uff0c\u901a\u8fc7\u7ebf\u7a0b\u6c60\u548c\u961f\u5217\u6765\u6267\u884c\u6d41\u7a0b\u3002\n */\n@Slf4j\npublic class DefaultFlowExecutor extends ServiceThread implements LifeCycle {\n\n    private static final int DEFAULT_THREAD_POOL_SIZE = 10000;\n\n    private final Flow flow;\n\n    public DefaultFlowExecutor(Flow flow) {\n        this.flow = flow;\n    }\n\n    private BlockingQueue<Service<?>> queue = new ArrayBlockingQueue<>(DEFAULT_THREAD_POOL_SIZE);\n\n    @Override", "public class DefaultFlowExecutor extends ServiceThread implements LifeCycle {\n\n    private static final int DEFAULT_THREAD_POOL_SIZE = 10000;\n\n    private final Flow flow;\n\n    public DefaultFlowExecutor(Flow flow) {\n        this.flow = flow;\n    }\n\n    private BlockingQueue<Service<?>> queue = new ArrayBlockingQueue<>(DEFAULT_THREAD_POOL_SIZE);\n\n    @Override", "    public String getServiceName() {\n        return \"DefaultFlowExecutor\";\n    }\n\n    @Override\n    public void onStart() {\n        log.info(getServiceName() + \" start\");\n        while (!stopped) {\n            Service<?> service = null;\n            try {\n                service = queue.poll(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                log.info(\"\u4ece\u961f\u5217\u4e2d\u83b7\u53d6\u670d\u52a1\u5931\u8d25\", e);\n            }", "            try {\n                service = queue.poll(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                log.info(\"\u4ece\u961f\u5217\u4e2d\u83b7\u53d6\u670d\u52a1\u5931\u8d25\", e);\n            }\n            if (service != null) {\n                try {\n                    service.before();\n                    // \u8fd9\u91cc\u7684 message \u662f\u4e0a\u4e00\u4e2a\u4efb\u52a1\u7684\u8fd4\u56de\u503c\u6216\u8005\u662f\u5165\u53e3\u7684\u53c2\u6570\u3002Context \u662f\u56f4\u7ed5\u7740 flow \u7684\u8bbe\u8ba1\u3002\n                    // \u5e94\u8be5\u63d0\u4f9b\u7ed9 task \u66f4\u6539 Context \u7684\u80fd\u529b\u3002\n                    service.process(null, flow.getServiceContext());\n                    service.after();\n                } catch (Exception e) {\n                    log.error(\"\", e);\n                    service.exception(e);\n                }\n            }\n            waitForRunning(1);\n        }\n    }\n\n    @Override", "    public void doService() {\n\n    }\n\n    @Override\n    public void onStop() {\n\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/executor/FlowExecutor.java", "chunked_list": ["package com.wentong.jimu.flow.executor;\n\n/**\n * flow \u4efb\u52a1\u6267\u884c\u5668\n */\npublic interface FlowExecutor {\n\n    Object submit(String flowId);\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/convert/InputConverter.java", "chunked_list": ["package com.wentong.jimu.flow.convert;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * \u8f93\u5165\u8f6c\u6362\u5668\n */", " * \u8f93\u5165\u8f6c\u6362\u5668\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InputConverter {\n\n    String expression();\n\n}\n", "}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/dispatcher/FlowDispatcher.java", "chunked_list": ["package com.wentong.jimu.flow.dispatcher;\n\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.flow.task.FlowTask;\nimport com.wentong.jimu.flow.task.TaskResult;\n\nimport java.util.List;\n\n/**\n * flow \u8c03\u5ea6\u5668", "/**\n * flow \u8c03\u5ea6\u5668\n */\npublic interface FlowDispatcher {\n\n    /**\n     * \u63d0\u4ea4 flow\n     */\n    void submit(Flow flow);\n\n    List<FlowTask> getTasks(String flowType, int size);\n\n    FlowTask getTask(String flowType);\n\n    void reportTaskResult(TaskResult taskResult);\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/dispatcher/MemoryFlowDispatcher.java", "chunked_list": ["package com.wentong.jimu.flow.dispatcher;\n\nimport cn.hutool.core.collection.CollUtil;\nimport com.wentong.jimu.flow.Flow;\nimport com.wentong.jimu.flow.task.DefaultTask;\nimport com.wentong.jimu.flow.task.FlowTask;\nimport com.wentong.jimu.flow.task.TaskResult;\nimport com.wentong.jimu.locker.Lock;\nimport com.wentong.jimu.locker.MemoryLock;\nimport lombok.NonNull;", "import com.wentong.jimu.locker.MemoryLock;\nimport lombok.NonNull;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * \u57fa\u4e8e\u5185\u5b58\u7684\u6d41\u7a0b\u8c03\u5ea6\u5668\uff0c\u7ef4\u62a4\u6d41\u7a0b\u72b6\u6001\u4ee5\u53ca\u4efb\u52a1\u72b6\u6001\u3002\u4efb\u52a1\u72b6\u6001\u7531\u6267\u884c\u5668\u4e0a\u62a5\u7ef4\u62a4\uff0c\u91c7\u7528 ack \u673a\u5236\u3002\n * \u91c7\u7528\u62c9\u53d6\u7684\u6a21\u578b\u8bbe\u8ba1\uff0c\u5373\u7531 FlowExecutor \u4e3b\u52a8\u62c9\u53d6\u4efb\u52a1\uff0c\u652f\u6301\u6279\u91cf\u548c\u5355\u4e2a\u62c9\u53d6\u3002", " * \u57fa\u4e8e\u5185\u5b58\u7684\u6d41\u7a0b\u8c03\u5ea6\u5668\uff0c\u7ef4\u62a4\u6d41\u7a0b\u72b6\u6001\u4ee5\u53ca\u4efb\u52a1\u72b6\u6001\u3002\u4efb\u52a1\u72b6\u6001\u7531\u6267\u884c\u5668\u4e0a\u62a5\u7ef4\u62a4\uff0c\u91c7\u7528 ack \u673a\u5236\u3002\n * \u91c7\u7528\u62c9\u53d6\u7684\u6a21\u578b\u8bbe\u8ba1\uff0c\u5373\u7531 FlowExecutor \u4e3b\u52a8\u62c9\u53d6\u4efb\u52a1\uff0c\u652f\u6301\u6279\u91cf\u548c\u5355\u4e2a\u62c9\u53d6\u3002\n */\n@Slf4j\npublic class MemoryFlowDispatcher implements FlowDispatcher {\n\n    private final Map<String, Flow> flowMap = new HashMap<>();\n    // taskType -> tasks\n    private final Map<String, Deque<FlowTask>> taskTypeMap = new HashMap<>();\n    // taskId -> task\n    private final Map<String, FlowTask> taskMap = new HashMap<>();\n    // \u6b63\u5728\u5904\u7406\u4e2d\u7684\u4efb\u52a1\u6570\u636e\u3002key \u4e3a taskId\uff0cvalue \u4e3a task\n    // \u6682\u65f6\u6ca1\u6709\u7528\u5904\uff0c\u53ea\u662f\u7528\u6765\u76d1\u63a7\u4efb\u52a1\u7684\u6267\u884c\u60c5\u51b5\u3002\n    private final Map<String, FlowTask> processingTask = new HashMap<>();\n    // flowId -> tasks \u6620\u5c04\u5173\u7cfb\n    private final Map<String, List<FlowTask>> flowTaskMap = new HashMap<>();\n    // \u5b9a\u4e49\u9501\u63a5\u53e3\n    private final Lock lock = new MemoryLock();\n\n    @Override", "    public synchronized void submit(Flow flow) {\n        if (CollUtil.isEmpty(flow.getTasks())) {\n            log.warn(\"flow {} has no task\", flow.getFlowId());\n            return;\n        }\n\n        // \u521b\u5efa flowId -> flow \u6620\u5c04\n        flowMap.put(flow.getFlowId(), flow);\n\n        // \u521b\u5efa flowId -> tasks \u6620\u5c04\n        flowTaskMap.put(flow.getFlowId(), flow.getTasks());\n\n        flow.getTasks().forEach(task -> {\n            // \u52a0\u5165\u5230 id \u6620\u5c04\n            taskMap.put(task.getId(), task);\n        });\n        // \u5c06\u7b2c\u4e00\u4e2a\u4efb\u52a1\u653e\u5230\u6267\u884c\u961f\u5217\u4e2d\u53bb\u3002\n        putTaskIntoQueue(flow.getTasks().get(0));\n    }\n\n    private void putTaskIntoQueue(FlowTask task) {\n        Deque<FlowTask> flowTasks = taskTypeMap.get(task.getTaskType());", "        if (CollUtil.isEmpty(flowTasks)) {\n            flowTasks = new LinkedList<>();\n            flowTasks.addFirst(task);\n            taskTypeMap.put(task.getTaskType(), flowTasks);\n        } else {\n            flowTasks.addFirst(task);\n        }\n    }\n\n    @Override\n    public List<FlowTask> getTasks(@NonNull String flowType, int size) {\n        Deque<FlowTask> tasks = taskTypeMap.get(flowType);", "        if (!CollUtil.isEmpty(tasks)) {\n            List<FlowTask> result = new ArrayList<>();\n            for (int i = 0; i < Math.min(size, tasks.size()); i++) {\n                FlowTask flowTask = tasks.pollFirst();\n                // \u589e\u52a0\u9501\u63a7\u5236\uff0c\u907f\u514d\u91cd\u590d\u83b7\u53d6\u4efb\u52a1\n                if (lock.tryLock(flowTask.getId(), 1, 30, TimeUnit.SECONDS)) {\n                    result.add(flowTask);\n                    processingTask.put(flowTask.getId(), flowTask);\n                }\n            }\n            return result;\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    @Override", "    public FlowTask getTask(String flowType) {\n        Deque<FlowTask> tasks = taskTypeMap.get(flowType);\n        FlowTask flowTask = tasks.pollFirst();\n        if (flowTask != null) {\n            if (lock.tryLock(flowTask.getId(), 1, 30, TimeUnit.SECONDS)) {\n                processingTask.put(flowTask.getId(), flowTask);\n                return flowTask;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    @Override", "    public void reportTaskResult(TaskResult taskResult) {\n        log.info(\"report task id: {} result: {}\", taskResult.getTaskId(), taskResult);\n        String taskId = taskResult.getTaskId();\n        FlowTask flowTask = processingTask.remove(taskId);\n        if (flowTask == null) {\n            log.warn(\"task {} is not in processing\", taskId);\n            return;\n        }\n        lock.release(taskId);\n        switch (taskResult.getStatus()) {\n            case SUCCESS -> {", "                if (flowTask.finalTask()) {\n                    // \u5982\u679c\u662f\u6700\u540e\u4e00\u4e2a\u4efb\u52a1\uff0c\u90a3\u4e48\u5c31\u5c06 flow \u4ece flowMap \u4e2d\u79fb\u9664\n                    flowMap.remove(flowTask.getFlow().getFlowId());\n                    log.info(\"flow {} is finished\", flowTask.getFlow().getFlowId());\n                    break;\n                }\n                // \u6267\u884c\u6210\u529f\uff0c\u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u653e\u5165\u961f\u5217\u4e2d\n                // \u8fd9\u91cc\u5f3a\u8f6c\u7c7b\u578b\u4e86\uff0c\u5c06 input \u8bbe\u7f6e\u4e86\u4e00\u4e0b\u3002\n                DefaultTask nextTask = (DefaultTask) getNextTaskAndRemoveThisTask(taskId);\n                if (nextTask != null) {\n                    nextTask.setInput(taskResult.getOutput());\n                    putTaskIntoQueue(nextTask);\n                }\n            }\n            case FAIL ->\n                // \u6267\u884c\u5931\u8d25\uff0c\u5c06\u4efb\u52a1\u653e\u56de\u961f\u5217\u4e2d\n                    putTaskIntoQueue(flowTask);\n            default -> throw new IllegalStateException(\"Unexpected value: \" + taskResult.getStatus());\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u4e0b\u4e00\u4e2a\u4efb\u52a1\u3002Attention\uff1a\u8fd9\u4e2a\u65b9\u6cd5\u6709\u526f\u4f5c\u7528\u3002\u4f1a\u5220\u9664\u8be5\u4efb\u52a1\n     */\n    private FlowTask getNextTaskAndRemoveThisTask(String taskId) {\n        FlowTask flowTask = taskMap.get(taskId);", "                if (nextTask != null) {\n                    nextTask.setInput(taskResult.getOutput());\n                    putTaskIntoQueue(nextTask);\n                }\n            }\n            case FAIL ->\n                // \u6267\u884c\u5931\u8d25\uff0c\u5c06\u4efb\u52a1\u653e\u56de\u961f\u5217\u4e2d\n                    putTaskIntoQueue(flowTask);\n            default -> throw new IllegalStateException(\"Unexpected value: \" + taskResult.getStatus());\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u4e0b\u4e00\u4e2a\u4efb\u52a1\u3002Attention\uff1a\u8fd9\u4e2a\u65b9\u6cd5\u6709\u526f\u4f5c\u7528\u3002\u4f1a\u5220\u9664\u8be5\u4efb\u52a1\n     */\n    private FlowTask getNextTaskAndRemoveThisTask(String taskId) {\n        FlowTask flowTask = taskMap.get(taskId);", "        if (flowTask == null) {\n            return null;\n        }\n        Flow flow = flowTask.getFlow();\n        List<FlowTask> flowTasks = flowTaskMap.get(flow.getFlowId());\n        FlowTask nextFlow = flowTasks.get(flowTasks.indexOf(flowTask) + 1);\n        flowTasks.remove(flowTask);\n        return nextFlow;\n    }\n\n}"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/worker/Worker.java", "chunked_list": ["package com.wentong.jimu.flow.worker;\n\n\nimport com.wentong.jimu.flow.task.Task;\nimport com.wentong.jimu.flow.task.TaskResult;\n\n/**\n * \u4efb\u52a1\u6267\u884c\u8005\n */\npublic interface Worker {\n\n    TaskResult execute(Task task);\n\n    String getFlowType();\n}\n", " */\npublic interface Worker {\n\n    TaskResult execute(Task task);\n\n    String getFlowType();\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/flow/worker/LocalSampleWorker.java", "chunked_list": ["package com.wentong.jimu.flow.worker;\n\nimport com.wentong.jimu.flow.task.Task;\nimport com.wentong.jimu.flow.task.TaskResult;\n\nimport static com.wentong.jimu.flow.FlowType.TEST;\n\npublic class LocalSampleWorker implements Worker {\n\n    @Override\n    public TaskResult execute(Task task) {\n        return task.process();\n    }\n\n    @Override", "    public TaskResult execute(Task task) {\n        return task.process();\n    }\n\n    @Override\n    public String getFlowType() {\n        return TEST;\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/exception/FlowBizException.java", "chunked_list": ["package com.wentong.jimu.exception;\n\npublic class FlowBizException extends RuntimeException{\n\n    public FlowBizException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/lifecycle/LifeCycle.java", "chunked_list": ["package com.wentong.jimu.lifecycle;\n\npublic interface LifeCycle {\n\n    void onStart();\n\n    void onStop();\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/aviator/AviatorLoader.java", "chunked_list": ["package com.wentong.jimu.aviator;\n\n/**\n * aviator \u52a0\u8f7d\u5668\n */\npublic class AviatorLoader {\n\n    public Object load(String expression) {\n        return null;\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/service/Service.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport com.wentong.jimu.flow.ServiceContext;\n\npublic interface Service<T> {\n\n    /**\n     * \u524d\u7f6e\u5904\u7406\u5668\n     */\n    void before();\n\n    /**\n     * \u670d\u52a1\u5904\u7406\n     */\n    Object process(T message, ServiceContext context);\n\n    /**\n     * \u540e\u7f6e\u5904\u7406\u5668\n     */\n    void after();\n\n    /**\n     * \u5f02\u5e38\u5904\u7406\u5668\n     */\n    void exception(Throwable e);\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/service/ServiceFactory.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ServiceFactory {\n\n    private static final Map<String, Service<?>> CONTAINER = new HashMap<>();\n\n    public static void registerService(String serviceName, Service<?> service) {\n        CONTAINER.put(serviceName, service);\n    }\n", "    public static void registerService(String serviceName, Service<?> service) {\n        CONTAINER.put(serviceName, service);\n    }\n\n    public static Service<?> getService(String serviceName) {\n        Service<?> service = CONTAINER.get(serviceName);\n        Objects.requireNonNull(service, \"service:\" + serviceName + \" is null\");\n        return service;\n    }\n\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/service/ServiceLoader.java", "chunked_list": ["package com.wentong.jimu.service;\n\nimport java.lang.reflect.InvocationTargetException;\n\npublic class ServiceLoader {\n\n    private final static ServiceLoader INSTANCE = new ServiceLoader();\n\n    public static ServiceLoader getInstance() {\n        return INSTANCE;\n    }\n\n    public Service<?> loadClass(String servicePath) {", "    public static ServiceLoader getInstance() {\n        return INSTANCE;\n    }\n\n    public Service<?> loadClass(String servicePath) {\n        try {\n            Class<?> serviceClass = Class.forName(servicePath);\n            return (Service<?>) serviceClass.getDeclaredConstructor().newInstance();\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | InvocationTargetException |\n                 NoSuchMethodException e) {\n            throw new IllegalStateException(\"Service \" + servicePath + \" not found\", e);\n        }\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/service/AbstractService.java", "chunked_list": ["package com.wentong.jimu.service;\n\npublic abstract class AbstractService<T> implements Service<T> {\n\n    @Override\n    public void before() {\n        // do nothing\n    }\n\n    @Override\n    public void after() {\n        // do nothing\n    }\n\n    @Override", "    public void after() {\n        // do nothing\n    }\n\n    @Override\n    public void exception(Throwable e) {\n        // do nothing\n    }\n}\n"]}
{"filename": "core/src/main/java/com/wentong/jimu/actor/HelloWorldActor.java", "chunked_list": ["package com.wentong.jimu.actor;\n\nimport akka.actor.AbstractActor;\n\n// \u5b9a\u4e49\u4e00\u4e2a\u540d\u4e3a HelloWorldActor \u7684 actor\npublic class HelloWorldActor extends AbstractActor {\n\n    @Override\n    public Receive createReceive() {\n        return receiveBuilder().match(String.class, message -> {\n            System.out.println(Thread.currentThread().getName());", "    public Receive createReceive() {\n        return receiveBuilder().match(String.class, message -> {\n            System.out.println(Thread.currentThread().getName());\n            if (\"hello\".equals(message)) {\n                System.out.println(\"Hello World!\");\n            } else {\n                System.out.println(\"Unknown message\");\n            }\n        }).build();\n    }\n}\n\n"]}
