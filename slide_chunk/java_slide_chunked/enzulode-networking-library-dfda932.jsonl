{"filename": "src/main/java/com/enzulode/network/UDPChannelClient.java", "chunked_list": ["package com.enzulode.network;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.exception.ServerNotAvailableException;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.mapper.RequestMapper;\nimport com.enzulode.network.mapper.ResponseMapper;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;", "import com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.interconnection.impl.PingRequest;\nimport com.enzulode.network.model.interconnection.impl.PongResponse;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;", "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketTimeoutException;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\nimport java.util.Objects;\n", "import java.util.Objects;\n\n/**\n * This class is a UDPChannel client implementation\n *\n */\npublic class UDPChannelClient implements AutoCloseable\n{\n\t/**\n\t * Local address instance\n\t *\n\t */\n\tprivate final InetSocketAddress localAddress;\n\n\t/**\n\t * Server address instance\n\t *\n\t */\n\tprivate final InetSocketAddress serverAddress;\n\n\t/**\n\t * Datagram channel instance\n\t *\n\t */\n\tprivate final DatagramChannel channel;\n\n\t/**\n\t * UDPChannel client constructor with default params\n\t *\n\t * @throws NetworkException if it's failed to open a channel\n\t */\n\tpublic UDPChannelClient() throws NetworkException\n\t{\n\t\tthis(0, \"127.0.0.1\", 8080);\n\t}\n\n\t/**\n\t * UDPSocket client constructor.\n\t *\n\t * @param localPort the port, UDPSocket will be bind to (0 - any available port automatically / provide your own port)\n\t * @param serverHost the remote server host\n\t * @param serverPort the remote server port\n\t * @throws NetworkException if it's failed to open a datagram channel\n\t */\n\tpublic UDPChannelClient(int localPort, String serverHost, int serverPort) throws NetworkException\n\t{\n//\t\tRequiring server host to be non-null\n\t\tObjects.requireNonNull(serverHost, \"Server host cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\tthis.channel = DatagramChannel.open();\n", "\t\t\tif (localPort == 0)\n\t\t\t{\n\t\t\t\tthis.channel.bind(new InetSocketAddress(\"127.0.0.1\", localPort));\n\t\t\t\tthis.localAddress = new InetSocketAddress(\"127.0.0.1\", this.channel.socket().getLocalPort());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.localAddress = new InetSocketAddress(\"127.0.0.1\", localPort);\n\t\t\t\tthis.channel.bind(localAddress);\n\t\t\t}\n\n\t\t\tthis.serverAddress = new InetSocketAddress(serverHost, serverPort);\n\n//\t\t\tConfigure channel\n\t\t\tthis.channel.configureBlocking(false);\n\t\t\tthis.channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tthis.channel.setOption(StandardSocketOptions.SO_REUSEPORT, true);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to open datagram channel\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Client address getter\n\t *\n\t * @return client address instance\n\t */", "\tpublic InetSocketAddress getLocalAddress()\n\t{\n\t\treturn localAddress;\n\t}\n\n\t/**\n\t * Server address getter\n\t *\n\t * @return server address instance\n\t */\n\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method allows you to send a request and receive a response for it\n\t *\n\t * @param <T> means the expected type of response\n\t * @param request request to be sent\n\t * @return a response instance\n\t * @throws NetworkException if it failed to send the response to the server,\n\t * if the server response data was corrupted, if it failed to receive response from the server or\n\t * request mapping failed\n\t * @throws ServerNotAvailableException if server is not currently available\n\t */\n\tpublic <T extends Response> T sendRequestAndWaitResponse(Request request) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequiring request to be non-null\n\t\tObjects.requireNonNull(request, \"Request cannot be null\");\n\n//\t\tReadjusting request addresses\n\t\trequest.setFrom(localAddress);\n\t\trequest.setTo(serverAddress);\n\n\t\ttry\n\t\t{\n//\t\t\tMap request instance to bytes array\n\t\t\tbyte[] requestBytes = RequestMapper.mapFromInstanceToBytes(request);\n\n//\t\t\tIf request size is more than default buffer size - send with overhead : else - send without overhead", "\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method allows you to send a request and receive a response for it\n\t *\n\t * @param <T> means the expected type of response\n\t * @param request request to be sent\n\t * @return a response instance\n\t * @throws NetworkException if it failed to send the response to the server,\n\t * if the server response data was corrupted, if it failed to receive response from the server or\n\t * request mapping failed\n\t * @throws ServerNotAvailableException if server is not currently available\n\t */\n\tpublic <T extends Response> T sendRequestAndWaitResponse(Request request) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequiring request to be non-null\n\t\tObjects.requireNonNull(request, \"Request cannot be null\");\n\n//\t\tReadjusting request addresses\n\t\trequest.setFrom(localAddress);\n\t\trequest.setTo(serverAddress);\n\n\t\ttry\n\t\t{\n//\t\t\tMap request instance to bytes array\n\t\t\tbyte[] requestBytes = RequestMapper.mapFromInstanceToBytes(request);\n\n//\t\t\tIf request size is more than default buffer size - send with overhead : else - send without overhead", "\t\t\tif (requestBytes.length > NetworkUtils.REQUEST_BUFFER_SIZE)\n\t\t\t\tsendRequestWithOverhead(requestBytes);\n\t\t\telse\n\t\t\t\tsendRequestNoOverhead(requestBytes);\n\n\t\t\treturn waitForResponse();\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map request from instance to bytes\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends request with overhead after separation\n\t *\n\t * @param requestBytes raw request bytes\n\t * @throws NetworkException if it's failed to send a frame\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tprivate void sendRequestWithOverhead(byte[] requestBytes) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request bytes array to be non-null\n\t\tObjects.requireNonNull(requestBytes, \"Request bytes array cannot be null\");\n\n//\t\tGet response chunks from rew response bytes\n\t\tList<byte[]> requestChunks = NetworkUtils.splitIntoChunks(requestBytes, NetworkUtils.RESPONSE_BUFFER_SIZE);\n\n//\t\tWrap chunks with UDPFrames\n\t\tList<UDPFrame> udpFrames = NetworkUtils.wrapChunksWithUDPFrames(requestChunks);\n\n//\t\tMap UDOFrames to bytes\n\t\tList<byte[]> framesBytes = NetworkUtils.udpFramesToBytes(udpFrames);\n\n//\t\tSending all request frames to the server\n\t\ttry\n\t\t{\n\t\t\tlong idx = 0;", "\t\t\tfor (byte[] frameBytes : framesBytes)\n\t\t\t{\n\t\t\t\tcheckServerConnection();\n\t\t\t\tchannel.send(ByteBuffer.wrap(frameBytes), serverAddress);\n\t\t\t}\n\t\t}\n\t\tcatch (SocketTimeoutException e)\n\t\t{\n\t\t\tthrow new ServerNotAvailableException(\"Server is not currently available\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send response with an overhead\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends request without overhead\n\t *\n\t * @param requestBytes raw request bytes\n\t * @throws NetworkException if it's failed to send request\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tprivate void sendRequestNoOverhead(byte[] requestBytes) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request bytes array to be non-null\n\t\tObjects.requireNonNull(requestBytes, \"Request bytes array cannot be null\");\n\n\t\ttry\n\t\t{\n//\t\t\tWrap raw bytes with UDPFrame\n\t\t\tUDPFrame udpFrame = new UDPFrame(requestBytes, true);\n\n//\t\t\tGet UDPFrameBytes from UDPFrame instance\n\t\t\tbyte[] udpFrameBytes = FrameMapper.mapFromInstanceToBytes(udpFrame);\n\n//\t\t\tTrying to send the request\n\t\t\tcheckServerConnection();\n\t\t\tchannel.send(ByteBuffer.wrap(udpFrameBytes), serverAddress);\n\t\t}\n\t\tcatch (SocketTimeoutException e)\n\t\t{\n\t\t\tthrow new ServerNotAvailableException(\"Server is not currently available\", e);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map UDPFrame to raw bytes\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send request with no overhead\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method checks the server availability\n\t *\n\t * @throws ServerNotAvailableException if server is not currently available\n\t * @throws NetworkException if something went wrong during sending or receiving something (but the server is ok)\n\t */\n\tprivate void checkServerConnection() throws NetworkException, ServerNotAvailableException\n\t{\n\t\ttry\n\t\t{\n//\t\t\tCreating PING request\n\t\t\tRequest request = new PingRequest();\n\t\t\trequest.setFrom(localAddress);\n\t\t\trequest.setTo(serverAddress);\n\n//\t\t\tMapping PING request into bytes\n\t\t\tbyte[] pingRequestBytes = RequestMapper.mapFromInstanceToBytes(request);\n\n//\t\t\tWrapping request bytes with udp frame\n\t\t\tUDPFrame frame = new UDPFrame(pingRequestBytes, true);\n\n//\t\t\tMapping pingFrame into bytes\n\t\t\tbyte[] pingFrameBytes = FrameMapper.mapFromInstanceToBytes(frame);\n\n//\t\t\tSending ping request\n\t\t\tchannel.send(ByteBuffer.wrap(pingFrameBytes), serverAddress);\n\t\t\tByteBuffer pingResponseBuffer = ByteBuffer.allocate(NetworkUtils.RESPONSE_BUFFER_SIZE * 2);\n\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tint timeout = 5000;", "\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSocketAddress addr = channel.receive(pingResponseBuffer);\n\n\t\t\t\tif (System.currentTimeMillis() > startTime + timeout)\n\t\t\t\t\tthrow new ServerNotAvailableException(\"Server is not available\");\n\n\t\t\t\tif (addr == null) continue;\n\n\t\t\t\tbyte[] currentFrameBytes = new byte[pingResponseBuffer.position()];\n\t\t\t\tpingResponseBuffer.rewind();\n\t\t\t\tpingResponseBuffer.get(currentFrameBytes);\n\t\t\t\tUDPFrame responseFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);\n\t\t\t\tResponse response = ResponseMapper.mapFromBytesToInstance(responseFrame.data());", "\t\t\t\tif (!(response instanceof PongResponse)) throw new ServerNotAvailableException(\"Server is not available\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (IOException | MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send ping request\", e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Method waits for response\n\t *\n\t * @param <T> response type param\n\t * @return response instance\n\t * @throws NetworkException if it's failed to receive response from the server\n\t * @throws ServerNotAvailableException if server is not currently available\n\t */\n\tprivate <T extends Response> T waitForResponse() throws NetworkException, ServerNotAvailableException\n\t{\n\t\tByteBuffer responseBuffer = ByteBuffer.allocate(NetworkUtils.RESPONSE_BUFFER_SIZE * 2);\n\n\t\ttry(ByteArrayOutputStream baos = new ByteArrayOutputStream())\n\t\t{\n\t\t\tboolean gotAll = false;\n\n\t\t\tdo\n\t\t\t{\n//\t\t\t\tReceiving incoming byte buffer\n\t\t\t\tresponseBuffer.clear();\n\n\t\t\t\tSocketAddress addr = channel.receive(responseBuffer);\n\n//\t\t\t\tSkip current iteration if nothing was got in receive", "\t\t\t\tif (addr == null) continue;\n\n//\t\t\t\tRetrieving current frame bytes from incoming byte buffer\n\t\t\t\tbyte[] currentFrameBytes = new byte[responseBuffer.position()];\n\t\t\t\tresponseBuffer.rewind();\n\t\t\t\tresponseBuffer.get(currentFrameBytes);\n\n//\t\t\t\tMapping UDPFrame from raw bytes\n\t\t\t\tUDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);\n\n//\t\t\t\tEnriching response bytes with new bytes\n\t\t\t\tbaos.writeBytes(currentFrame.data());\n\n//\t\t\t\tChange gotAll state if got the last UDPFrame", "\t\t\t\tif (currentFrame.last()) gotAll = true;\n\n\t\t\t} while (!gotAll);\n\n//\t\t\tMapping request instance from raw request bytes\n\t\t\tbyte[] responseBytes = baos.toByteArray();\n\t\t\treturn ResponseMapper.mapFromBytesToInstance(responseBytes);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to receive response: mapping failure detected\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to receive response from server\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method forced by {@link AutoCloseable} interface.\n\t * Allows to use this class in the try-with-resources construction\n\t * Automatically closes datagram channel\n\t */\n\t@Override", "\tpublic void close() throws NetworkException\n\t{\n\t\ttry\n\t\t{\n\t\t\tchannel.close();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to close datagram channel\", e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/UDPSocketClient.java", "chunked_list": ["package com.enzulode.network;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.exception.ServerNotAvailableException;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.mapper.RequestMapper;\nimport com.enzulode.network.mapper.ResponseMapper;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;", "import com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;", "import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This class is a UDPSocket client implementation\n *\n */\npublic final class UDPSocketClient implements AutoCloseable\n{\n\t/**\n\t * Opened datagram socket\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Local address instance\n\t *\n\t */\n\tprivate final InetSocketAddress localAddress;\n\n\t/**\n\t * Server address instance\n\t */\n\tprivate final InetSocketAddress serverAddress;\n\n\t/**\n\t * UDPSocket client constructor with default params\n\t *\n\t * @throws NetworkException if it's failed to open a socket and bind it to a concrete port\n\t */\n\tpublic UDPSocketClient() throws NetworkException\n\t{\n\t\tthis(0, \"127.0.0.1\", 8080);\n\t}\n\n\t/**\n\t * UDPSocket client constructor.\n\t *\n\t * @param localPort the port, UDPSocket will be bind to (0 - any available port automatically / provide your own port)\n\t * @param serverHost the remote server host\n\t * @param serverPort the remote server port\n\t * @throws NetworkException if it's failed to open a socket and bind it to a concrete port\n\t */\n\tpublic UDPSocketClient(\n\t\t\tint localPort,\n\t\t\tString serverHost,\n\t\t\tint serverPort\n\t) throws NetworkException\n\t{\n//\t\tRequiring server host to be non-null\n\t\tObjects.requireNonNull(serverHost, \"Server host cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\tthis.socket = new DatagramSocket(localPort);\n\n\t\t\tthis.localAddress = new InetSocketAddress(\"127.0.0.1\", socket.getLocalPort());\n\t\t\tthis.serverAddress = new InetSocketAddress(serverHost, serverPort);\n\n//\t\t\tSocket configuration\n\t\t\tthis.socket.setReuseAddress(true);\n\t\t\tthis.socket.setSoTimeout(2000);\n\t\t}\n\t\tcatch (SocketException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Unable to open datagram socket\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Client address getter\n\t *\n\t * @return client address instance\n\t */", "\tpublic InetSocketAddress getLocalAddress()\n\t{\n\t\treturn localAddress;\n\t}\n\n\t/**\n\t * Server address getter\n\t *\n\t * @return server address instance\n\t */\n\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method allows you to send a request and receive a response for it\n\t *\n\t * @param request request to be sent\n\t * @return a response instance\n\t * @param <T> means the expected type of response\n\t * @throws NetworkException if it failed to send the response to the server,\n\t * if the server response data was corrupted, if it failed to receive response from the server or\n\t * request mapping failed\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tpublic <T extends Response> T sendRequestAndWaitResponse(Request request) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request to be non-null\n\t\tObjects.requireNonNull(request, \"Request cannot be null\");\n\n//\t\tReadjusting request addresses\n\t\trequest.setFrom(localAddress);\n\t\trequest.setTo(serverAddress);\n\n\t\ttry\n\t\t{\n//\t\t\tFirst of all, we should get our request byte representation\n\t\t\tbyte[] requestBytes = RequestMapper.mapFromInstanceToBytes(request);\n\n//\t\t\tIf request size is more than default buffer size - send with overhead : else - send without overhead", "\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method allows you to send a request and receive a response for it\n\t *\n\t * @param request request to be sent\n\t * @return a response instance\n\t * @param <T> means the expected type of response\n\t * @throws NetworkException if it failed to send the response to the server,\n\t * if the server response data was corrupted, if it failed to receive response from the server or\n\t * request mapping failed\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tpublic <T extends Response> T sendRequestAndWaitResponse(Request request) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request to be non-null\n\t\tObjects.requireNonNull(request, \"Request cannot be null\");\n\n//\t\tReadjusting request addresses\n\t\trequest.setFrom(localAddress);\n\t\trequest.setTo(serverAddress);\n\n\t\ttry\n\t\t{\n//\t\t\tFirst of all, we should get our request byte representation\n\t\t\tbyte[] requestBytes = RequestMapper.mapFromInstanceToBytes(request);\n\n//\t\t\tIf request size is more than default buffer size - send with overhead : else - send without overhead", "\t\t\tif (requestBytes.length > NetworkUtils.REQUEST_BUFFER_SIZE)\n\t\t\t\tsendRequestWithOverhead(requestBytes);\n\t\t\telse\n\t\t\t\tsendRequestNoOverhead(requestBytes);\n\n//\t\t\tWaiting for response\n\t\t\treturn waitForResponse();\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map request from instance to bytes during request proceeding\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends request with overhead after separation\n\t *\n\t * @param requestBytes raw request bytes\n\t * @throws NetworkException if it's failed to send some of DatagramPackets\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tprivate void sendRequestWithOverhead(byte[] requestBytes) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request bytes array to be non-null\n\t\tObjects.requireNonNull(requestBytes, \"Request bytes array cannot be null\");\n\n//\t\tGet request chunks from raw request bytes\n\t\tList<byte[]> requestChunks = NetworkUtils.splitIntoChunks(requestBytes, NetworkUtils.REQUEST_BUFFER_SIZE);\n\n//\t\tWrap chunks with UDPFrames\n\t\tList<UDPFrame> udpFrames = NetworkUtils.wrapChunksWithUDPFrames(requestChunks);\n\n//\t\tWrap UDPFrames with DatagramPackets\n\t\tList<DatagramPacket> datagramPackets = NetworkUtils.wrapUDPFramesWithDatagramPackets(\n\t\t\t\tudpFrames,\n\t\t\t\tserverAddress\n\t\t);\n\n//\t\tTrying to send datagram packets\n\t\ttry\n\t\t{", "\t\t\tfor (DatagramPacket packet : datagramPackets)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tTimeUnit.MILLISECONDS.sleep(10);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ignored) {}\n\t\t\t\tsocket.send(packet);\n\t\t\t}\n\t\t}\n\t\tcatch (SocketTimeoutException e)\n\t\t{\n\t\t\tthrow new ServerNotAvailableException(\"Server is not currently available\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send packets\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends request without overhead\n\t *\n\t * @param requestBytes raw request bytes\n\t * @throws NetworkException if it's failed to send DatagramPacket\n\t * @throws ServerNotAvailableException if server timeout exception was caught\n\t */\n\tprivate void sendRequestNoOverhead(byte[] requestBytes) throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tRequire request bytes array to be non-null\n\t\tObjects.requireNonNull(requestBytes, \"Request bytes array cannot be null\");\n\n\t\ttry\n\t\t{\n//\t\t\tWrap raw bytes with UDPFrame\n\t\t\tUDPFrame udpFrame = new UDPFrame(requestBytes, true);\n\n//\t\t\tGet UDPFrameBytes from UDPFrame instance\n\t\t\tbyte[] udpFrameBytes = FrameMapper.mapFromInstanceToBytes(udpFrame);\n\n//\t\t\tWrap UDPFrame with DatagramPacket\n\t\t\tDatagramPacket requestPacket = new DatagramPacket(udpFrameBytes, udpFrameBytes.length, serverAddress);\n\t\t\t\n//\t\t\tTrying to send the request\n\t\t\tsocket.send(requestPacket);\n\t\t}\n\t\tcatch (SocketTimeoutException e)\n\t\t{\n\t\t\tthrow new ServerNotAvailableException(\"Server is not currently available\", e);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map UDPFrame to raw bytes\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send request with no overhead\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method waits for response\n\t *\n\t * @param <T> response type param\n\t * @return response instance\n\t * @throws NetworkException if it's failed to receive response from the server\n\t */\n\tprivate <T extends Response> T waitForResponse() throws NetworkException, ServerNotAvailableException\n\t{\n//\t\tResponse byte buffer initiation\n\t\tbyte[] responseBytes = new byte[NetworkUtils.RESPONSE_BUFFER_SIZE];\n\n//\t\tAfter the request was sent we should prepare a datagram packet for response\n\t\tDatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length);\n\n\t\ttry\n\t\t{\n\t\t\tbyte[] allResponseBytes = new byte[0];\n\t\t\tboolean gotAll = false;\n\t\t\tdo\n\t\t\t{\n//\t\t\t\tReceiving a response frame\n\t\t\t\tsocket.receive(responsePacket);\n\n//\t\t\t\tRetrieving response raw bytes\n\t\t\t\tbyte[] currentFrameBytes = responsePacket.getData();\n\n//\t\t\t\tMapping UDPFrame from raw bytes\n\t\t\t\tUDPFrame udpFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);\n\n//\t\t\t\tEnriching response bytes with new bytes\n\t\t\t\tallResponseBytes = NetworkUtils.concatTwoByteArrays(allResponseBytes, udpFrame.data());\n", "\t\t\t\tif (udpFrame.last())\n\t\t\t\t\tgotAll = true;\n\t\t\t}\n\t\t\twhile (!gotAll);\n\n//\t\t\tMapping response bytes into an instance\n\t\t\treturn ResponseMapper.mapFromBytesToInstance(allResponseBytes);\n\t\t}\n\t\tcatch (SocketTimeoutException e)\n\t\t{\n\t\t\tthrow new ServerNotAvailableException(\"Server is not currently available\", e);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Mapping operation failure detected\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to receive response from the server\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method forced by {@link AutoCloseable} interface.\n\t * Allows to use this class in the try-with-resources construction\n\t * Automatically closes datagram socket\n\t */\n\t@Override", "\tpublic void close()\n\t{\n\t\tsocket.close();\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/UDPSocketServer.java", "chunked_list": ["package com.enzulode.network;\n\nimport com.enzulode.network.concurrent.factories.ThreadNamingFactory;\nimport com.enzulode.network.concurrent.task.recursive.RecursiveRequestHandlingAction;\nimport com.enzulode.network.concurrent.task.recursive.RecursiveRequestReceivingAction;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.handling.RequestHandler;\nimport com.enzulode.network.model.interconnection.Request;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.concurrent.*;\n\n/**", "\n/**\n * This class is a UDPSocket server implementation\n *\n */\npublic final class UDPSocketServer implements AutoCloseable\n{\n\t/**\n\t * Default server port\n\t *\n\t */", "\tpublic static final int DEFAULT_PORT = 8080;\n\n\t/**\n\t * DatagramSocket instance\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Server address instance\n\t *\n\t */\n\tprivate final InetSocketAddress serverAddress;\n\n\t/**\n\t * Current request handler instance\n\t *\n\t */\n\tprivate RequestHandler handler;\n\n\t/**\n\t * Request receiving executors\n\t *\n\t */\n\tprivate final ForkJoinPool requestReceivingPool;\n\n\t/**\n\t * Request handling thread pool\n\t *\n\t */\n\tprivate final ForkJoinPool requestHandlingPool;\n\n\t/**\n\t * Response sending thread pool\n\t *\n\t */\n\tprivate final ExecutorService responseSendingExecutors;\n\n\t/**\n\t * A concurrent map instance for resolved requests\n\t *\n\t */\n\tprivate final ConcurrentMap<SocketAddress, Request> requestsMap;\n\n\t/**\n\t * UDPChannelServer constructor without port specified.\n\t * Server will be bind to DEFAULT_PORT\n\t *\n\t * @throws NetworkException if it's failed to bind DatagramSocket\n\t */\n\tpublic UDPSocketServer() throws NetworkException\n\t{\n\t\tthis(DEFAULT_PORT);\n\t}\n\n\t/**\n\t * UDPChannelServer constructor with port specified.\n\t * Server will be bind to provided port\n\t *\n\t * @param port the {@link DatagramSocket} will be bind to this\n\t * @throws NetworkException if it's failed to bind DatagramSocket\n\t */\n\tpublic UDPSocketServer(int port) throws NetworkException\n\t{\n\t\tthis(new InetSocketAddress(\"127.0.0.1\", port));\n\t}\n\n\t/**\n\t * UDPSocketServer constructor\n\t *\n\t * @param serverAddress address to bind a server socket\n\t * @throws NetworkException if it's failed to bind socket\n\t */\n\tpublic UDPSocketServer(InetSocketAddress serverAddress) throws NetworkException\n\t{\n//\t\tRequiring server socket address to be non-null\n\t\tObjects.requireNonNull(serverAddress, \"Socket binding address cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\tthis.socket = new DatagramSocket(serverAddress);\n", "\t\t\tif (serverAddress.getPort() == 0)\n\t\t\t\tthis.serverAddress = new InetSocketAddress(\"127.0.0.1\", socket.getLocalPort());\n\t\t\telse\n\t\t\t\tthis.serverAddress = serverAddress;\n\n//\t\t\tConfigure socket\n\t\t\tthis.socket.setReuseAddress(true);\n\n\t\t\tthis.requestReceivingPool = new ForkJoinPool(1);\n\t\t\tthis.requestHandlingPool = new ForkJoinPool(4);\n\n\t\t\tthis.responseSendingExecutors = Executors.newCachedThreadPool(\n\t\t\t\t\tnew ThreadNamingFactory(\"responding\", \"thread\")\n\t\t\t);\n\n\t\t\tthis.requestsMap = new ConcurrentHashMap<>();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to create a datagram socket\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Server address getter\n\t *\n\t * @return server address instance\n\t */", "\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * Current request handler getter\n\t *\n\t * @return current request handler instance\n\t */\n\tpublic RequestHandler getHandler()\n\t{\n\t\treturn handler;\n\t}\n\n\t/**\n\t * This method sets current request handler\n\t *\n\t * @param handler request handler\n\t */", "\tpublic RequestHandler getHandler()\n\t{\n\t\treturn handler;\n\t}\n\n\t/**\n\t * This method sets current request handler\n\t *\n\t * @param handler request handler\n\t */\n\tpublic void subscribe(RequestHandler handler)\n\t{\n//\t\tRequire request handler to be non-null\n\t\tObjects.requireNonNull(handler, \"Request handler cannot be null\");\n\n\t\tthis.handler = handler;\n\t}\n\n\t/**\n\t * This method handles incoming requests with provided {@link RequestHandler} and\n\t * sends a specific response\n\t *\n\t * @throws NetworkException if it's failed to select a channel or send the response\n\t */", "\tpublic void subscribe(RequestHandler handler)\n\t{\n//\t\tRequire request handler to be non-null\n\t\tObjects.requireNonNull(handler, \"Request handler cannot be null\");\n\n\t\tthis.handler = handler;\n\t}\n\n\t/**\n\t * This method handles incoming requests with provided {@link RequestHandler} and\n\t * sends a specific response\n\t *\n\t * @throws NetworkException if it's failed to select a channel or send the response\n\t */", "\tpublic void handleIncomingRequests() throws NetworkException\n\t{\n\t\tif (handler == null)\n\t\t\tthrow new NetworkException(\"Request handler is not currently set\");\n\n\t\trequestReceivingPool.submit(new RecursiveRequestReceivingAction(socket, requestsMap));\n\n\t\twhile (true)\n\t\t{\n\t\t\tif (requestsMap.isEmpty()) continue;\n", "\t\t\tif (requestsMap.isEmpty()) continue;\n\n\t\t\tfor (Iterator<Request> i = requestsMap.values().iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tRequest req = i.next();\n\t\t\t\ti.remove();\n\n\t\t\t\tvar requestHandlingAction = new RecursiveRequestHandlingAction(socket, req, handler, responseSendingExecutors);\n\t\t\t\trequestHandlingPool.submit(requestHandlingAction);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Method forced by {@link AutoCloseable} interface.\n\t * Automatically closes socket in case of using inside try-with-resources code block\n\t *\n\t */\n\t@Override", "\tpublic void close()\n\t{\n\t\tsocket.close();\n\t}\n}"]}
{"filename": "src/main/java/com/enzulode/network/UDPChannelServer.java", "chunked_list": ["package com.enzulode.network;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.handling.RequestHandler;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.mapper.RequestMapper;\nimport com.enzulode.network.mapper.ResponseMapper;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;", "import com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;", "import java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * This class is a UDPChannel server implementation\n *\n */\npublic final class UDPChannelServer implements AutoCloseable\n{\n\t/**\n\t * Default server port\n\t *\n\t */\n\tprivate static final int DEFAULT_PORT = 8080;\n\n\t/**\n\t * Datagram channel instance\n\t *\n\t */\n\tprivate final DatagramChannel channel;\n\n\t/**\n\t * Server address instance\n\t *\n\t */\n\tprivate final InetSocketAddress serverAddress;\n\n\t/**\n\t * Request handler instance\n\t * \n\t */\n\tprivate RequestHandler handler;\n\n\t/**\n\t * UDPChannelServer constructor without port specified.\n\t * Server will be bind to DEFAULT_PORT\n\t *\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer() throws NetworkException\n\t{\n\t\tthis(DEFAULT_PORT);\n\t}\n\n\t/**\n\t * UDPChannelServer constructor with port specified.\n\t * Server will be bind to provided port\n\t *\n\t * @param port the {@link DatagramChannel} will be bind to this\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer(\n\t\t\tint port\n\t) throws NetworkException\n\t{\n\t\tthis(new InetSocketAddress(\"127.0.0.1\", port));\n\t}\n\n\t/**\n\t * UDPChannelServer constructor with server address specified\n\t * Server will be bind to provided address\n\t *\n\t * @param address an address to bind a socket\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer(\n\t\t\tInetSocketAddress address\n\t) throws NetworkException\n\t{\n//\t\tRequiring socket address to be non-null\n\t\tObjects.requireNonNull(address, \"Socket binding address cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\tthis.channel = DatagramChannel.open();\n\n//\t\t\tChannel configuration\n\t\t\tchannel.bind(address);\n", " *\n */\npublic final class UDPChannelServer implements AutoCloseable\n{\n\t/**\n\t * Default server port\n\t *\n\t */\n\tprivate static final int DEFAULT_PORT = 8080;\n\n\t/**\n\t * Datagram channel instance\n\t *\n\t */\n\tprivate final DatagramChannel channel;\n\n\t/**\n\t * Server address instance\n\t *\n\t */\n\tprivate final InetSocketAddress serverAddress;\n\n\t/**\n\t * Request handler instance\n\t * \n\t */\n\tprivate RequestHandler handler;\n\n\t/**\n\t * UDPChannelServer constructor without port specified.\n\t * Server will be bind to DEFAULT_PORT\n\t *\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer() throws NetworkException\n\t{\n\t\tthis(DEFAULT_PORT);\n\t}\n\n\t/**\n\t * UDPChannelServer constructor with port specified.\n\t * Server will be bind to provided port\n\t *\n\t * @param port the {@link DatagramChannel} will be bind to this\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer(\n\t\t\tint port\n\t) throws NetworkException\n\t{\n\t\tthis(new InetSocketAddress(\"127.0.0.1\", port));\n\t}\n\n\t/**\n\t * UDPChannelServer constructor with server address specified\n\t * Server will be bind to provided address\n\t *\n\t * @param address an address to bind a socket\n\t * @throws NetworkException if it's failed to open DatagramChannel\n\t */\n\tpublic UDPChannelServer(\n\t\t\tInetSocketAddress address\n\t) throws NetworkException\n\t{\n//\t\tRequiring socket address to be non-null\n\t\tObjects.requireNonNull(address, \"Socket binding address cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\tthis.channel = DatagramChannel.open();\n\n//\t\t\tChannel configuration\n\t\t\tchannel.bind(address);\n", "\t\t\tif (address.getPort() == 0)\n\t\t\t\tserverAddress = new InetSocketAddress(\"localhost\", channel.socket().getLocalPort());\n\t\t\telse\n\t\t\t\tserverAddress = address;\n\n\t\t\tthis.channel.configureBlocking(false);\n\t\t\tthis.channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tthis.channel.setOption(StandardSocketOptions.SO_REUSEPORT, true);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to open DatagramChannel\", e);\n\t\t}\n\n\t}\n\n\t/**\n\t * UDPChannelServer channel getter\n\t *\n\t * @return server channel getter\n\t */", "\tpublic DatagramChannel getChannel()\n\t{\n\t\treturn channel;\n\t}\n\n\t/**\n\t * Server address getter\n\t *\n\t * @return server address instance\n\t */\n\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method sets current request handler\n\t *\n\t * @param handler request handler\n\t */", "\tpublic InetSocketAddress getServerAddress()\n\t{\n\t\treturn serverAddress;\n\t}\n\n\t/**\n\t * This method sets current request handler\n\t *\n\t * @param handler request handler\n\t */\n\tpublic void addRequestHandler(RequestHandler handler)\n\t{\n//\t\tRequiring request handler to be non-null\n\t\tObjects.requireNonNull(handler, \"Request handler cannot be null\");\n\n\t\tthis.handler = handler;\n\t}\n\n\t/**\n\t * This method handles the request with provided {@link RequestHandler} and\n\t * sends response\n\t *\n\t * @throws NetworkException if it's failed to select a channel or send the response\n\t */", "\tpublic void addRequestHandler(RequestHandler handler)\n\t{\n//\t\tRequiring request handler to be non-null\n\t\tObjects.requireNonNull(handler, \"Request handler cannot be null\");\n\n\t\tthis.handler = handler;\n\t}\n\n\t/**\n\t * This method handles the request with provided {@link RequestHandler} and\n\t * sends response\n\t *\n\t * @throws NetworkException if it's failed to select a channel or send the response\n\t */", "\tpublic void handleRequest() throws NetworkException\n\t{\n\t\tif (handler == null)\n\t\t\tthrow new NetworkException(\"Failed to handle the request: RequestHandler was not set\");\n\n\t\tRequest request = waitRequest();\n\t\tResponse response = handler.handle(request);\n\n\t\tsendResponse(response, request.getFrom());\n\t}\n\n\t/**\n\t * Waiting request from clients\n\t *\n\t * @param <T> request type parameter\n\t * @return request instance\n\t * @throws NetworkException if it's failed to receive the request from client\n\t */\n\tprivate <T extends Request> T waitRequest() throws NetworkException\n\t{\n\t\tByteBuffer incomingBuffer = ByteBuffer.allocate(NetworkUtils.REQUEST_BUFFER_SIZE * 2);\n\n\t\ttry\n\t\t{\n\t\t\tbyte[] allRequestBytes = new byte[0];\n\t\t\tboolean gotAll = false;\n\n\t\t\tdo\n\t\t\t{\n//\t\t\t\tReceiving incoming byte buffer\n\t\t\t\tincomingBuffer.clear();\n\t\t\t\tSocketAddress addr = channel.receive(incomingBuffer);\n//\t\t\t\tSkip current iteration if nothing was got in receive", "\t\t\t\tif (addr == null) continue;\n\n//\t\t\t\tRetrieving current frame bytes from incoming byte buffer\n\t\t\t\tbyte[] currentFrameBytes = new byte[incomingBuffer.position()];\n\t\t\t\tincomingBuffer.rewind();\n\t\t\t\tincomingBuffer.get(currentFrameBytes);\n\n//\t\t\t\tMapping UDPFrame from raw bytes\n\t\t\t\tUDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);\n\n//\t\t\t\tEnriching request bytes with new bytes\n\t\t\t\tallRequestBytes = NetworkUtils.concatTwoByteArrays(allRequestBytes, currentFrame.data());\n\n//\t\t\t\tChange gotAll state if got the last UDPFrame", "\t\t\t\tif (currentFrame.last()) gotAll = true;\n\n\t\t\t} while (!gotAll);\n\n//\t\t\tMapping request instance from raw request bytes\n\t\t\treturn RequestMapper.mapFromBytesToInstance(allRequestBytes);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to receive request: mapping failure detected\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to receive request from server\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends response\n\t *\n\t * @param response response instance\n\t * @throws NetworkException if it's failed to send response with an overhead or\n\t * if it's failed to send response without an overhead\n\t */\n\tprivate void sendResponse(Response response, InetSocketAddress destination) throws NetworkException\n\t{\n//\t\tRequiring response instance to be non-null\n\t\tObjects.requireNonNull(response, \"Response cannot be null\");\n\n\t\tresponse.setFrom(serverAddress);\n\t\tresponse.setTo(destination);\n\n\t\ttry\n\t\t{\n//\t\t\tMapping response to a byte array\n\t\t\tbyte[] responseBytes = ResponseMapper.mapFromInstanceToBytes(response);\n\n//\t\t\tCheck if response should be divided into separate chunks", "\t\t\tif (responseBytes.length > NetworkUtils.RESPONSE_BUFFER_SIZE)\n\t\t\t\tsendResponseWithOverhead(responseBytes, destination);\n\t\t\telse\n\t\t\t\tsendResponseNoOverhead(responseBytes, destination);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map response instance to bytes\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends response with an overhead\n\t *\n\t * @param responseBytes raw response bytes\n\t * @param destination response destination\n\t * @throws NetworkException if it's failed to send response with an overhead\n\t */\n\tprivate void sendResponseWithOverhead(\n\t\t\tbyte[] responseBytes,\n\t\t\tInetSocketAddress destination\n\t) throws NetworkException\n\t{\n//\t\tRequiring response bytes and destination address to be non-null\n\t\tObjects.requireNonNull(responseBytes, \"Response bytes array cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Destination address cannot be null\");\n\n//\t\tGet response chunks from rew response bytes\n\t\tList<byte[]> responseChunks = NetworkUtils.splitIntoChunks(responseBytes, NetworkUtils.RESPONSE_BUFFER_SIZE);\n\n//\t\tWrap chunks with UDPFrames\n\t\tList<UDPFrame> udpFrames = NetworkUtils.wrapChunksWithUDPFrames(responseChunks);\n\n//\t\tMap udpFrames to bytes\n\t\tList<byte[]> framesBytes = NetworkUtils.udpFramesToBytes(udpFrames);\n\n//\t\tSending all response frames to the client\n\t\ttry\n\t\t{", "\t\t\tfor (byte[] frameBytes : framesBytes)\n\t\t\t\tchannel.send(ByteBuffer.wrap(frameBytes), destination);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send response with an overhead\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method sends response without an overhead\n\t *\n\t * @param responseBytes raw response bytes\n\t * @param destination response destination\n\t * @throws NetworkException if it's failed to send response without an overhead\n\t */\n\tprivate void sendResponseNoOverhead(\n\t\t\tbyte[] responseBytes,\n\t\t\tInetSocketAddress destination\n\t) throws NetworkException\n\t{\n//\t\tRequiring response bytes and destination address to be non-null\n\t\tObjects.requireNonNull(responseBytes, \"Response bytes array cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Destination address cannot be null\");\n\n\t\ttry\n\t\t{\n//\t\t\tWrap raw response bytes with UDPFrame\n\t\t\tUDPFrame udpFrame = new UDPFrame(responseBytes, true);\n\n//\t\t\tGet UDPFrame bytes\n\t\t\tbyte[] udpFrameBytes = FrameMapper.mapFromInstanceToBytes(udpFrame);\n\n//\t\t\tSending response frame to the client\n\t\t\tchannel.send(ByteBuffer.wrap(udpFrameBytes), destination);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map frame to bytes\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send response without an overhead\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method provided by {@link AutoCloseable} interface.\n\t * Allows to use this class in the try-with-resources construction.\n\t * Automatically closes selector and datagram channel\n\t *\n\t */\n\t@Override", "\tpublic void close() throws NetworkException\n\t{\n\t\ttry\n\t\t{\n\t\t\tchannel.close();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Unable to close DatagramChannel\", e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/task/RespondingTask.java", "chunked_list": ["package com.enzulode.network.concurrent.task;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.mapper.ResponseMapper;\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;\n", "import com.enzulode.network.util.NetworkUtils;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;", "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Response sending task\n *\n */\npublic class RespondingTask implements Runnable\n{\n\t/**\n\t * Logger instance\n\t *\n\t */\n\tprivate final Logger logger;\n\n\t/**\n\t * Task lock instance\n\t *\n\t */\n\tprivate final Lock lock;\n\n\t/**\n\t * Datagram socket instance\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Response instance\n\t *\n\t */\n\tprivate final Response response;\n\n\t/**\n\t * Response-sending task constructor\n\t *\n\t * @param socket datagram socket instance\n\t * @param response response instance\n\t */\n\tpublic RespondingTask(DatagramSocket socket, Response response)\n\t{\n\t\tObjects.requireNonNull(socket, \"Socket instance cannot be null\");\n\t\tObjects.requireNonNull(response, \"Response instance cannot be null\");\n\n\t\tthis.logger = Logger.getLogger(RespondingTask.class.getName());\n\t\tthis.lock = new ReentrantLock();\n\t\tthis.socket = socket;\n\t\tthis.response = response;\n\t}\n\n\t/**\n\t * The task body\n\t *\n\t */\n\t@Override", " */\npublic class RespondingTask implements Runnable\n{\n\t/**\n\t * Logger instance\n\t *\n\t */\n\tprivate final Logger logger;\n\n\t/**\n\t * Task lock instance\n\t *\n\t */\n\tprivate final Lock lock;\n\n\t/**\n\t * Datagram socket instance\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Response instance\n\t *\n\t */\n\tprivate final Response response;\n\n\t/**\n\t * Response-sending task constructor\n\t *\n\t * @param socket datagram socket instance\n\t * @param response response instance\n\t */\n\tpublic RespondingTask(DatagramSocket socket, Response response)\n\t{\n\t\tObjects.requireNonNull(socket, \"Socket instance cannot be null\");\n\t\tObjects.requireNonNull(response, \"Response instance cannot be null\");\n\n\t\tthis.logger = Logger.getLogger(RespondingTask.class.getName());\n\t\tthis.lock = new ReentrantLock();\n\t\tthis.socket = socket;\n\t\tthis.response = response;\n\t}\n\n\t/**\n\t * The task body\n\t *\n\t */\n\t@Override", "\tpublic void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tbyte[] responseBytes = ResponseMapper.mapFromInstanceToBytes(response);\n\n\t\t\tif (responseBytes.length > NetworkUtils.RESPONSE_BUFFER_SIZE)\n\t\t\t\tsendResponseWithOverhead(responseBytes, response.getTo());\n\t\t\telse\n\t\t\t\tsendResponseNoOverhead(responseBytes, response.getTo());\n\t\t}\n\t\tcatch (MappingException | NetworkException e)\n\t\t{\n\t\t\tlogger.log(Level.SEVERE, \"Something went wrong during responding\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method for sending response without an overhead\n\t *\n\t * @param responseBytes response bytes array\n\t * @param destination response destination\n\t * @throws NetworkException if it's failed to send the response\n\t */\n\tprivate void sendResponseNoOverhead(byte[] responseBytes, InetSocketAddress destination) throws NetworkException\n\t{\n//\t\tCheck that response bytes and response destination are not null\n\t\tObjects.requireNonNull(responseBytes, \"Response bytes cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Response destination cannot be null\");\n\n//\t\tWrap raw response bytes with UDPFrame\n\t\tUDPFrame udpFrame = new UDPFrame(responseBytes, true);\n\n\t\ttry\n\t\t{\n//\t\t\tMap UDPFrame to bytes\n\t\t\tbyte[] udpFrameBytes = FrameMapper.mapFromInstanceToBytes(udpFrame);\n\n//\t\t\tWrap UDPFrame bytes with DatagramPacket\n\t\t\tDatagramPacket responsePacket = new DatagramPacket(udpFrameBytes, udpFrameBytes.length, destination);\n\n//\t\t\tSending response to the client\n\t\t\tlock.lock();\n\t\t\tsocket.send(responsePacket);\n\t\t\tlock.unlock();\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map frame to bytes\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send response to the client\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Method for sending the response with an overhead\n\t *\n\t * @param responseBytes response byte array\n\t * @param destination response destination\n\t * @throws NetworkException if it's failed to send the response\n\t */\n\tprivate void sendResponseWithOverhead(byte[] responseBytes, InetSocketAddress destination) throws NetworkException\n\t{\n//\t\tCheck that response bytes and response destination are not null\n\t\tObjects.requireNonNull(responseBytes, \"Response bytes cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Response destination cannot be null\");\n\n\t\tList<DatagramPacket> responsePackets = NetworkUtils.getPacketsForOverheadedResponseBytes(responseBytes, destination);\n\n\t\ttry\n\t\t{", "\t\t\tfor (DatagramPacket packet : responsePackets)\n\t\t\t{\n\t\t\t\tNetworkUtils.timeout(10);\n\t\t\t\tlock.lock();\n\t\t\t\tsocket.send(packet);\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to send the overheaded response\", e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/task/recursive/RecursiveRequestHandlingAction.java", "chunked_list": ["package com.enzulode.network.concurrent.task.recursive;\n\nimport com.enzulode.network.concurrent.task.RespondingTask;\nimport com.enzulode.network.handling.RequestHandler;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.interconnection.impl.PingRequest;\nimport com.enzulode.network.model.interconnection.impl.PongResponse;\nimport com.enzulode.network.model.interconnection.util.ResponseCode;\n", "import com.enzulode.network.model.interconnection.util.ResponseCode;\n\nimport java.net.DatagramSocket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.RecursiveAction;\n\npublic class RecursiveRequestHandlingAction extends RecursiveAction\n{\n\t/**\n\t * Datagram socket instance\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Request to be handled\n\t *\n\t */\n\tprivate final Request request;\n\n\t/**\n\t * Request handler instance\n\t *\n\t */\n\tprivate final RequestHandler handler;\n\n\t/**\n\t * Specific executor service instance\n\t *\n\t */\n\tprivate final ExecutorService responseSendingThreadPool;\n\n\tpublic RecursiveRequestHandlingAction(\n\t\t\tDatagramSocket socket,\n\t\t\tRequest request,\n\t\t\tRequestHandler handler,\n\t\t\tExecutorService responseSendingThreadPool\n\t)\n\t{\n\t\tsuper();\n\n\t\tthis.socket = socket;\n\t\tthis.request = request;\n\t\tthis.handler = handler;\n\t\tthis.responseSendingThreadPool = responseSendingThreadPool;\n\t}\n\n\t/**\n\t * The main computation performed by this task.\n\t */\n\t@Override\n\tprotected void compute()\n\t{\n\t\tResponse response;", "\t\tif (request instanceof PingRequest)\n\t\t\tresponse = new PongResponse(ResponseCode.SUCCEED);\n\t\telse\n\t\t\tresponse = handler.handle(request);\n\n\t\tresponse.setFrom(request.getTo());\n\t\tresponse.setTo(request.getFrom());\n\n\t\tresponseSendingThreadPool.submit(new RespondingTask(socket, response));\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/task/recursive/RecursiveRequestReceivingAction.java", "chunked_list": ["package com.enzulode.network.concurrent.task.recursive;\n\nimport com.enzulode.network.concurrent.structures.ConcurrentFrameReceivingMap;\nimport com.enzulode.network.concurrent.structures.Pair;\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;", "import com.enzulode.network.model.transport.UDPFrame;\nimport com.enzulode.network.util.NetworkUtils;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.RecursiveAction;", "import java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.RecursiveAction;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Request receiving task\n *", " * Request receiving task\n *\n */\npublic class RecursiveRequestReceivingAction extends RecursiveAction\n{\n\t/**\n\t * Logger instance\n\t *\n\t */\n\tprivate final Logger logger;\n\n\t/**\n\t * Lock instance\n\t *\n\t */\n\tprivate final Lock lock;\n\n\t/**\n\t * Datagram socket instance\n\t *\n\t */\n\tprivate final DatagramSocket socket;\n\n\t/**\n\t * Concurrent frame receiving map instance\n\t *\n\t */\n\tprivate final ConcurrentFrameReceivingMap map;\n\n\t/**\n\t * Request-storing concurrent map instance\n\t *\n\t */\n\tprivate final ConcurrentMap<SocketAddress, Request> requestMap;\n\n\tpublic RecursiveRequestReceivingAction(DatagramSocket socket, ConcurrentMap<SocketAddress, Request> requestMap)\n\t{\n\t\tsuper();\n\n\t\tthis.logger = Logger.getLogger(RecursiveRequestReceivingAction.class.getName());\n\t\tthis.lock = new ReentrantLock();\n\t\tthis.socket = socket;\n\t\tthis.map = new ConcurrentFrameReceivingMap();\n\t\tthis.requestMap = requestMap;\n\t}\n\n\t/**\n\t * The main computation performed by this task.\n\t */\n\t@Override\n\tprotected void compute()\n\t{\n\n//\t\tDeclaring incoming request bytes buffer\n\t\tbyte[] incomingFrameBytes = new byte[NetworkUtils.REQUEST_BUFFER_SIZE * 2];\n\t\tDatagramPacket incomingRequestPacket = new DatagramPacket(incomingFrameBytes, incomingFrameBytes.length);\n", "\t\twhile (true)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlock.lock();\n\t\t\t\tif (!socket.isClosed())\n\t\t\t\t{\n\t\t\t\t\tsocket.receive(incomingRequestPacket);\n\t\t\t\t}\n\t\t\t\tlock.unlock();\n\n\t//\t\t\tMapping a current frame to instance from bytes\n\t\t\t\tUDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(incomingRequestPacket.getData());\n\n\t//\t\t\tAdding a frame into the frames map\n\t\t\t\tmap.add(incomingRequestPacket.getSocketAddress(), currentFrame);\n", "\t\t\t\tfor (Pair<SocketAddress, List<UDPFrame>> completedRequestFrameList : map.findCompletedRequestsFrameLists())\n\t\t\t\t{\n\t\t\t\t\tRequest request = NetworkUtils.requestFromFrames(completedRequestFrameList.value());\n\n\t//\t\t\t\tPut complete request into the completed requests map\n\t\t\t\t\trequestMap.put(completedRequestFrameList.key(), request);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException | MappingException | NetworkException e)\n\t\t\t{\n\t\t\t\tlogger.log(Level.SEVERE, \"Something went wrong during receiving\", e);\n\t\t\t}\n\t\t}\n\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/structures/ConcurrentFrameReceivingMap.java", "chunked_list": ["package com.enzulode.network.concurrent.structures;\n\nimport com.enzulode.network.model.transport.UDPFrame;\n\nimport java.net.SocketAddress;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;", "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * This map is designed for udp frame receiving\n *\n */\npublic class ConcurrentFrameReceivingMap\n{\n\t/**\n\t * Concurrent map instance\n\t *\n\t */\n\tprivate final ConcurrentMap<SocketAddress, List<UDPFrame>> map;\n\n\t/**\n\t * Map lock instance\n\t *\n\t */\n\tprivate final Lock lock;\n\n\t/**\n\t * Concurrent frame receiving map constructor\n\t *\n\t */\n\tpublic ConcurrentFrameReceivingMap()\n\t{\n\t\tmap = new ConcurrentHashMap<>();\n\t\tlock = new ReentrantLock();\n\t}\n\n\t/**\n\t * This method puts a new udp frame into the map using sender {@link SocketAddress} as key\n\t *\n\t * @param address sender address\n\t * @param frame frame to be added into the map\n\t */", "\tpublic void add(SocketAddress address, UDPFrame frame)\n\t{\n\t\tif (map.containsKey(address) && map.get(address) != null)\n\t\t{\n\t\t\tmap.get(address).add(frame);\n\t\t\treturn;\n\t\t}\n\n\t\tlock.lock();\n\t\tList<UDPFrame> frames = new LinkedList<>();\n\t\tframes.add(frame);\n\t\tmap.put(address, frames);\n\t\tlock.unlock();\n\t}\n\n\t/**\n\t * This method finds a list of udp frames for a specific socket address\n\t *\n\t * @param address requested frames address\n\t * @return unmodifiable list of udp frames\n\t */\n\tpublic List<UDPFrame> findFramesByAddress(SocketAddress address)\n\t{\n\t\treturn (map.containsKey(address) && map.get(address) != null)\n\t\t\t\t? Collections.unmodifiableList(map.get(address))\n\t\t\t\t: Collections.emptyList();\n\t}\n\n\t/**\n\t * This method returns a list of {@link Pair}. Each pair contains a frames sender address and\n\t * the list of frame referring to it\n\t *\n\t * @return a list of pairs of socket address and list frames referring to this specific address\n\t */\n\tpublic List<Pair<SocketAddress, List<UDPFrame>>> findCompletedRequestsFrameLists()\n\t{\n\t\tList<Pair<SocketAddress, List<UDPFrame>>> completedRequestsFramesList = new ArrayList<>();\n", "\t\tfor (Iterator<Map.Entry<SocketAddress, List<UDPFrame>>> i = map.entrySet().iterator(); i.hasNext();)\n\t\t{\n\t\t\tMap.Entry<SocketAddress, List<UDPFrame>> entry = i.next();\n\n\t\t\tif (validateFrameListCompleted(entry.getValue()))\n\t\t\t{\n\t\t\t\tlock.lock();\n\t\t\t\tcompletedRequestsFramesList.add(new Pair<>(entry.getKey(), entry.getValue()));\n\t\t\t\ti.remove();\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\treturn Collections.unmodifiableList(completedRequestsFramesList);\n\t}\n\n\t/**\n\t * This method validates a list of frames for completion\n\t *\n\t * @param frames list of frames to be validated\n\t * @return validation result. True if the last frame of the request contains frame that is marked as last\n\t * and false otherwise\n\t */\n\tprivate boolean validateFrameListCompleted(List<UDPFrame> frames)\n\t{\n\t\treturn frames.get(frames.size() - 1).last();\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/structures/Pair.java", "chunked_list": ["package com.enzulode.network.concurrent.structures;\n\n/**\n * Special record for paired elements containing\n *\n * @param key pair key\n * @param value pair value\n * @param <K> pair key type\n * @param <V> pair value type\n */\npublic record Pair<K, V>(K key, V value)\n{\n}\n", " * @param <V> pair value type\n */\npublic record Pair<K, V>(K key, V value)\n{\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/concurrent/factories/ThreadNamingFactory.java", "chunked_list": ["package com.enzulode.network.concurrent.factories;\n\nimport java.util.Objects;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Special thread factory to name threads\n *\n */\npublic class ThreadNamingFactory implements ThreadFactory\n{\n\t/**\n\t * Thread counter\n\t *\n\t */\n\tprivate final AtomicInteger threadNumber;\n\n\t/**\n\t * Thread prefix\n\t *\n\t */\n\tprivate final String threadPrefix;\n\n\t/**\n\t * Thread pool group\n\t *\n\t */\n\tprivate final ThreadGroup threadPoolGroup;\n\n\t/**\n\t * Thread naming factory constructor\n\t *\n\t * @param threadGroupName thread group name\n\t * @param threadName thread name\n\t */\n\tpublic ThreadNamingFactory(final String threadGroupName, final String threadName)\n\t{\n\t\tObjects.requireNonNull(threadGroupName, \"Thread group name cannot be null\");\n\t\tObjects.requireNonNull(threadName, \"Thread type cannot be null\");\n\n\t\tthreadNumber = new AtomicInteger(1);\n\n\t\tthreadPrefix = \"pool-\" + threadGroupName.strip() + \"-\" + threadName + \"-\";\n\t\tthreadPoolGroup = new ThreadGroup(threadGroupName);\n\t}\n\n\t/**\n\t * Thread factory method\n\t *\n\t * @param r a runnable to be executed by new thread instance\n\t * @return named thread instance\n\t */\n\t@Override", " *\n */\npublic class ThreadNamingFactory implements ThreadFactory\n{\n\t/**\n\t * Thread counter\n\t *\n\t */\n\tprivate final AtomicInteger threadNumber;\n\n\t/**\n\t * Thread prefix\n\t *\n\t */\n\tprivate final String threadPrefix;\n\n\t/**\n\t * Thread pool group\n\t *\n\t */\n\tprivate final ThreadGroup threadPoolGroup;\n\n\t/**\n\t * Thread naming factory constructor\n\t *\n\t * @param threadGroupName thread group name\n\t * @param threadName thread name\n\t */\n\tpublic ThreadNamingFactory(final String threadGroupName, final String threadName)\n\t{\n\t\tObjects.requireNonNull(threadGroupName, \"Thread group name cannot be null\");\n\t\tObjects.requireNonNull(threadName, \"Thread type cannot be null\");\n\n\t\tthreadNumber = new AtomicInteger(1);\n\n\t\tthreadPrefix = \"pool-\" + threadGroupName.strip() + \"-\" + threadName + \"-\";\n\t\tthreadPoolGroup = new ThreadGroup(threadGroupName);\n\t}\n\n\t/**\n\t * Thread factory method\n\t *\n\t * @param r a runnable to be executed by new thread instance\n\t * @return named thread instance\n\t */\n\t@Override", "\tpublic Thread newThread(Runnable r)\n\t{\n\t\tThread thread = new Thread(threadPoolGroup, r);\n\t\tthread.setName(threadPrefix + threadNumber.getAndIncrement());\n\t\treturn thread;\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/interconnection/Request.java", "chunked_list": ["package com.enzulode.network.model.interconnection;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.net.InetSocketAddress;\nimport java.util.Objects;\n\n/**\n * An abstract request entity\n *", " * An abstract request entity\n *\n */\npublic abstract class Request implements Serializable\n{\n    /**\n     * Request serial version uid\n\t *\n     */\n    @Serial\n    private static final long serialVersionUID = -6487298602742247864L;\n\n    /**\n\t * The source address\n\t *\n\t */\n\tprivate InetSocketAddress from;\n\n\t/**\n\t * The destination address\n\t *\n\t */\n\tprivate InetSocketAddress to;\n\n\t/**\n\t * Empty request constructor\n\t *\n\t */\n\tpublic Request()\n\t{\n\t}\n\n\t/**\n\t * Request constructor\n\t *\n\t * @param from source address\n\t * @param to destination address\n\t */\n\tpublic Request(InetSocketAddress from, InetSocketAddress to)\n\t{\n//\t\tCheck source and destination addresses to be non-null\n\t\tObjects.requireNonNull(from, \"Request source address cannot be null\");\n\t\tObjects.requireNonNull(to, \"Request destination address cannot be null\");\n\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\n\t/**\n\t * Request source address getter\n\t *\n\t * @return current request source address\n\t */", "\tpublic InetSocketAddress getFrom()\n\t{\n\t\treturn from;\n\t}\n\n\t/**\n\t * Request destination address getter\n\t *\n\t * @return current request destination address\n\t */\n\tpublic InetSocketAddress getTo()\n\t{\n\t\treturn to;\n\t}\n\n\t/**\n\t * Request source address setter\n\t *\n\t * @param from source address to be set\n\t */", "\tpublic InetSocketAddress getTo()\n\t{\n\t\treturn to;\n\t}\n\n\t/**\n\t * Request source address setter\n\t *\n\t * @param from source address to be set\n\t */\n\tpublic void setFrom(InetSocketAddress from)\n\t{\n//\t\tRequiring request source address to be non-null\n\t\tObjects.requireNonNull(from, \"Request source address cannot be null\");\n\n\t\tthis.from = from;\n\t}\n\n\t/**\n\t * Request destination address setter\n\t *\n\t * @param to destination address to be set\n\t */", "\tpublic void setFrom(InetSocketAddress from)\n\t{\n//\t\tRequiring request source address to be non-null\n\t\tObjects.requireNonNull(from, \"Request source address cannot be null\");\n\n\t\tthis.from = from;\n\t}\n\n\t/**\n\t * Request destination address setter\n\t *\n\t * @param to destination address to be set\n\t */", "\tpublic void setTo(InetSocketAddress to)\n\t{\n//\t\tRequiring request destination address to be non-null\n\t\tObjects.requireNonNull(to, \"Request destination address cannot be null\");\n\n\t\tthis.to = to;\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/interconnection/Response.java", "chunked_list": ["package com.enzulode.network.model.interconnection;\n\nimport com.enzulode.network.model.interconnection.util.ResponseCode;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.net.InetSocketAddress;\nimport java.util.Objects;\n\n/**", "\n/**\n * An abstract response entity\n *\n */\npublic abstract class Response implements Serializable\n{\n    /**\n     * Response serial version uid\n     *\n     */\n    @Serial\n    private static final long serialVersionUID = -5875730935109456363L;\n\n    /**\n\t * The address of sender\n\t *\n\t */\n\tprivate InetSocketAddress from;\n\n\t/**\n\t * The destination address\n\t *\n\t */\n\tprivate InetSocketAddress to;\n\n\t/**\n\t * Response code\n     *\n\t */\n\tprotected final ResponseCode code;\n\n\t/**\n\t * Response constructor without source and destination address provided\n\t *\n\t * @param code response code\n\t */\n\tpublic Response(ResponseCode code)\n\t{\n//\t\tRequiring response code to be non-null\n\t\tObjects.requireNonNull(code, \"Response code cannot be null\");\n\n\t\tthis.code = code;\n\t}\n\n\t/**\n\t * Response constructor\n\t *\n\t * @param from source address\n\t * @param to destination address\n\t * @param code response code\n\t */\n\tpublic Response(InetSocketAddress from, InetSocketAddress to, ResponseCode code)\n\t{\n//\t\tRequiring response params to be non-null\n\t\tObjects.requireNonNull(from, \"Response source address cannot be null\");\n\t\tObjects.requireNonNull(to, \"Response destination address cannot be null\");\n\t\tObjects.requireNonNull(code, \"Response code cannot be null\");\n\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.code = code;\n\t}\n\n\t/**\n\t * Response source address getter\n\t *\n\t * @return current response source address\n\t */", "\tpublic InetSocketAddress getFrom()\n\t{\n\t\treturn from;\n\t}\n\n\t/**\n\t * Response destination address getter\n\t *\n\t * @return current response destination address\n\t */\n\tpublic InetSocketAddress getTo()\n\t{\n\t\treturn to;\n\t}\n\n\t/**\n\t * Response status code getter\n\t *\n\t * @return response code\n\t */", "\tpublic InetSocketAddress getTo()\n\t{\n\t\treturn to;\n\t}\n\n\t/**\n\t * Response status code getter\n\t *\n\t * @return response code\n\t */\n\tpublic ResponseCode getCode()\n\t{\n\t\treturn code;\n\t}\n\n\t/**\n\t * Response source address setter\n\t *\n\t * @param from source address to be set\n\t */", "\tpublic ResponseCode getCode()\n\t{\n\t\treturn code;\n\t}\n\n\t/**\n\t * Response source address setter\n\t *\n\t * @param from source address to be set\n\t */\n\tpublic void setFrom(InetSocketAddress from)\n\t{\n//\t\tRequiring response source address to be non-null\n\t\tObjects.requireNonNull(from, \"Response source address cannot be null\");\n\n\t\tthis.from = from;\n\t}\n\n\t/**\n\t * Response destination address setter\n\t *\n\t * @param to destination address to be set\n\t */", "\tpublic void setFrom(InetSocketAddress from)\n\t{\n//\t\tRequiring response source address to be non-null\n\t\tObjects.requireNonNull(from, \"Response source address cannot be null\");\n\n\t\tthis.from = from;\n\t}\n\n\t/**\n\t * Response destination address setter\n\t *\n\t * @param to destination address to be set\n\t */", "\tpublic void setTo(InetSocketAddress to)\n\t{\n//\t\tRequiring response destination address to be non-null\n\t\tObjects.requireNonNull(to, \"Response destination address cannot be null\");\n\n\t\tthis.to = to;\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/interconnection/util/ResponseCode.java", "chunked_list": ["package com.enzulode.network.model.interconnection.util;\n\n/**\n * Possible response codes\n */\npublic enum ResponseCode\n{\n    /**\n     * If previous request succeed - you have to send this response code\n     *\n     */\n    SUCCEED,\n\n    /**\n     * If previous request failed - you have to send this response code\n     *\n     */\n\tFAILED;\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/interconnection/impl/PongResponse.java", "chunked_list": ["package com.enzulode.network.model.interconnection.impl;\n\nimport com.enzulode.network.model.interconnection.Response;\nimport com.enzulode.network.model.interconnection.util.ResponseCode;\n\nimport java.io.Serial;\n\n/**\n * The purpose of this response is in checking another side availability\n *", " * The purpose of this response is in checking another side availability\n *\n */\npublic final class PongResponse extends Response\n{\n\t/**\n\t * Serial UID\n\t *\n\t */\n\t@Serial\n\tprivate static final long serialVersionUID = 3899919185329016906L;\n\n\t/**\n\t * Response constructor without source and destination address provided\n\t *\n\t * @param code response code\n\t */\n\tpublic PongResponse(ResponseCode code)\n\t{\n\t\tsuper(code);\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/interconnection/impl/PingRequest.java", "chunked_list": ["package com.enzulode.network.model.interconnection.impl;\n\nimport com.enzulode.network.model.interconnection.Request;\n\nimport java.io.Serial;\n\n/**\n * The purpose of this request is in checking another side availability\n *\n */\npublic final class PingRequest extends Request\n{\n\t/**\n\t * Serial UID\n\t *\n\t */\n\t@Serial\n\tprivate static final long serialVersionUID = -8297293467377473934L;\n}\n", " *\n */\npublic final class PingRequest extends Request\n{\n\t/**\n\t * Serial UID\n\t *\n\t */\n\t@Serial\n\tprivate static final long serialVersionUID = -8297293467377473934L;\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/model/transport/UDPFrame.java", "chunked_list": ["package com.enzulode.network.model.transport;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.util.Objects;\n\n/**\n * This record represents a piece of data sent over the UPD proto\n *\n * @param data The data stored in UDPFrame", " *\n * @param data The data stored in UDPFrame\n * @param last This property defines is the frame last\n */\npublic record UDPFrame(byte[] data, boolean last) implements Serializable\n{\n\t/**\n\t * UDPFrame serial version uid\n\t *\n\t */\n\t@Serial\n\tprivate static final long serialVersionUID = -2423240935234456363L;\n\n\t/**\n\t * This record represents a piece of data sent over the UPD proto\n\t *\n\t * @param data The data stored in UDPFrame\n\t * @param last This property defines is the frame last\n\t */\n\tpublic UDPFrame\n\t{\n//\t\tRequiring UDPFrame stored data to be non-null\n\t\tObjects.requireNonNull(data, \"UDPFrame stored data cannot be null\");\n\t}\n\n\t/**\n\t * UDPFrame stored data getter\n\t *\n\t * @return data bytes array\n\t */\n\t@Override\n\tpublic byte[] data()\n\t{\n\t\treturn data;\n\t}\n\n\t/**\n\t * Is UDPFrame last property getter\n\t *\n\t * @return true if the frame is last and false otherwise\n\t */\n\t@Override", "\tpublic boolean last()\n\t{\n\t\treturn last;\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/util/NetworkUtils.java", "chunked_list": ["package com.enzulode.network.util;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.exception.NetworkException;\nimport com.enzulode.network.mapper.FrameMapper;\nimport com.enzulode.network.mapper.RequestMapper;\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.transport.UDPFrame;\n\nimport java.io.ByteArrayOutputStream;", "\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;", "import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Utility class for network interactions\n *\n */\npublic class NetworkUtils\n{\n\n\t/**\n\t * Default request buffer size\n\t *\n\t */", "\tpublic static final int REQUEST_BUFFER_SIZE = 1024 * 4;\n\n\t/**\n\t * Default response buffer size\n\t *\n\t */\n\tpublic static final int RESPONSE_BUFFER_SIZE = 1024 * 4;\n\n\t/**\n\t * This method divides an array of bytes into separate chunks\n\t *\n\t * @param array byte array to be divided\n\t * @param chunk chunk size\n\t * @return list of chunks\n\t */", "\tpublic static List<byte[]> splitIntoChunks(byte[] array, int chunk)\n\t{\n//\t\tRequiring splittable array to be non-null\n\t\tObjects.requireNonNull(array, \"Splittable array cannot be null\");\n\n\t\tList<byte[]> chunks = new ArrayList<>();\n\n//\t\tPrevent excessive operations if chunk size is 1\n\t\tif (chunk == 1)\n\t\t{\n\t\t\tfor (byte item : array)\n\t\t\t\tchunks.add(new byte[] { item });\n\n\t\t\treturn chunks;\n\t\t}\n\n//\t\tArray should be simply wrapped with a list if chunk size is equal to array length", "\t\tif (chunk == 1)\n\t\t{\n\t\t\tfor (byte item : array)\n\t\t\t\tchunks.add(new byte[] { item });\n\n\t\t\treturn chunks;\n\t\t}\n\n//\t\tArray should be simply wrapped with a list if chunk size is equal to array length\n\t\tif (chunk == array.length)\n\t\t\treturn List.of(array);\n\n//\t\tPointer initialization\n\t\tint pointer = 0;\n", "\t\tif (chunk == array.length)\n\t\t\treturn List.of(array);\n\n//\t\tPointer initialization\n\t\tint pointer = 0;\n\n\t\twhile(pointer <= array.length)\n\t\t{\n\t\t\tif (pointer == array.length)\n\t\t\t\tchunks.add(new byte[] {array[array.length - 1]});\n", "\t\t\tif (pointer == array.length)\n\t\t\t\tchunks.add(new byte[] {array[array.length - 1]});\n\n\t\t\tif (pointer < array.length && pointer + chunk > array.length)\n\t\t\t\tchunks.add(Arrays.copyOfRange(array, pointer, pointer + (array.length - pointer)));\n\t\t\telse\n\t\t\t\tchunks.add(Arrays.copyOfRange(array, pointer, pointer + chunk));\n\n\t\t\tpointer += chunk;\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * This method wraps chunks with frames ({@link UDPFrame})\n\t *\n\t * @param chunks request chunks\n\t * @return list of {@link UDPFrame}\n\t */", "\tpublic static List<UDPFrame> wrapChunksWithUDPFrames(List<byte[]> chunks)\n\t{\n//\t\tRequiring list of chunks to be non-null\n\t\tObjects.requireNonNull(chunks, \"Byte chunks list cannot be null\");\n\n//\t\tGetting request chunks from raw bytes\n\t\tList<UDPFrame> frames = new ArrayList<>();\n\n//\t\tWrapping separate chunks into separate frames\n\t\tfor (int i = 0; i < chunks.size() - 1; i++)\n\t\t\tframes.add(new UDPFrame(chunks.get(i), false));\n\n\t\tframes.add(new UDPFrame(chunks.get(chunks.size() - 1), true));\n\t\treturn frames;\n\t}\n\n\t/**\n\t * This method wraps every frame ({@link UDPFrame}) with {@link DatagramPacket}\n\t *\n\t * @param frames frames to be wrapped\n\t * @param destination packet destination\n\t * @return list of {@link DatagramPacket}\n\t * @throws NetworkException if it's failed to map frames to bytes\n\t */", "\t\tfor (int i = 0; i < chunks.size() - 1; i++)\n\t\t\tframes.add(new UDPFrame(chunks.get(i), false));\n\n\t\tframes.add(new UDPFrame(chunks.get(chunks.size() - 1), true));\n\t\treturn frames;\n\t}\n\n\t/**\n\t * This method wraps every frame ({@link UDPFrame}) with {@link DatagramPacket}\n\t *\n\t * @param frames frames to be wrapped\n\t * @param destination packet destination\n\t * @return list of {@link DatagramPacket}\n\t * @throws NetworkException if it's failed to map frames to bytes\n\t */", "\tpublic static List<DatagramPacket> wrapUDPFramesWithDatagramPackets(\n\t\t\tList<UDPFrame> frames,\n\t\t\tInetSocketAddress destination\n\t) throws NetworkException\n\t{\n//\t\tRequiring list of frames and destination address to be non-null\n\t\tObjects.requireNonNull(frames, \"List of frames cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Destination inet address cannot be null\");\n\n\t\tList<DatagramPacket> packets = new ArrayList<>();\n\n\t\ttry\n\t\t{", "\t\t\tfor (UDPFrame frame : frames)\n\t\t\t{\n//\t\t\t\tMapping every frame to raw bytes\n\t\t\t\tbyte[] frameBytes = FrameMapper.mapFromInstanceToBytes(frame);\n//\t\t\t\tWrapping every frame byte array with datagram packet\n\t\t\t\tpackets.add(new DatagramPacket(frameBytes, frameBytes.length, destination));\n\t\t\t}\n\n\t\t\treturn packets;\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\n\t\t\t\t\t\"Failed to wrap UDPFrames with datagram packets: mapping exception occurred\", e\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method concatenates two byte arrays\n\t *\n\t * @param first first array to be concatenated\n\t * @param second second array to be concatenated\n\t * @return concatenation result\n\t */", "\tpublic static byte[] concatTwoByteArrays(byte[] first, byte[] second)\n\t{\n//\t\tRequiring arrays to be non-null\n\t\tObjects.requireNonNull(first, \"First array cannot be null\");\n\t\tObjects.requireNonNull(second, \"Second array cannot be null\");\n\n\t\tbyte[] result = new byte[first.length + second.length];\n\t\tSystem.arraycopy(first, 0, result, 0, first.length);\n\t\tSystem.arraycopy(second, 0, result, first.length, second.length);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Remap UDPFrames list to list of byte arrays\n\t *\n\t * @param frames list of UDPFrames to be unwrapped\n\t * @return a list of byte arrays\n\t * @throws NetworkException if some of the frames was not mapped to bytes\n\t */", "\tpublic static List<byte[]> udpFramesToBytes(List<UDPFrame> frames) throws NetworkException\n\t{\n//\t\tRequiring list of frames to be non-null\n\t\tObjects.requireNonNull(frames, \"List of frames cannot be null\");\n\n\t\tList<byte[]> bytes = new ArrayList<>();\n\n\t\ttry\n\t\t{\n\t\t\tfor (UDPFrame frame : frames)\n\t\t\t\tbytes.add(FrameMapper.mapFromInstanceToBytes(frame));\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map frame to bytes\", e);\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\t/**\n\t * This method makes a thread sleeping for a specified period of time\n\t *\n\t * @param timeout timeout in milliseconds\n\t */", "\t\t\tfor (UDPFrame frame : frames)\n\t\t\t\tbytes.add(FrameMapper.mapFromInstanceToBytes(frame));\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map frame to bytes\", e);\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\t/**\n\t * This method makes a thread sleeping for a specified period of time\n\t *\n\t * @param timeout timeout in milliseconds\n\t */", "\tpublic static void timeout(long timeout)\n\t{\n\t\ttry\n\t\t{\n\t\t\tTimeUnit.MILLISECONDS.sleep(timeout);\n\t\t}\n\t\tcatch (InterruptedException ignored)\n\t\t{\n\t\t}\n\t}\n\n\t/**\n\t * This method maps the request from UDPFrames to a java instance\n\t *\n\t * @param frames list of udp frames\n\t * @return a request instance\n\t * @param <T> request type param\n\t * @throws NetworkException if something went wrong during byte array output stream operations or during mapping operations\n\t */\n\tpublic static <T extends Request> T requestFromFrames(List<UDPFrame> frames) throws NetworkException\n\t{\n//\t\tCheck the frame list is not null\n\t\tObjects.requireNonNull(frames, \"Frame list cannot be null\");\n\n\t\ttry(ByteArrayOutputStream baos = new ByteArrayOutputStream();)\n\t\t{\n//\t\t\tByte arrays concatenation", "\t\t\tfor (UDPFrame frame : frames)\n\t\t\t\tbaos.writeBytes(frame.data());\n\n\t\t\treturn RequestMapper.mapFromBytesToInstance(baos.toByteArray());\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to close byte array output stream\", e);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tthrow new NetworkException(\"Failed to map request\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method wraps overheaded response bytes with datagram packets\n\t *\n\t * @param responseBytes overheaded response bytes\n\t * @param destination response destination\n\t * @return list of datagram packets\n\t * @throws NetworkException if it's failed to wrap response frames with datagram packets\n\t */", "\tpublic static List<DatagramPacket> getPacketsForOverheadedResponseBytes(byte[] responseBytes, InetSocketAddress destination) throws NetworkException\n\t{\n//\t\tCheck that response bytes and response destination are not null\n\t\tObjects.requireNonNull(responseBytes, \"Response bytes cannot be null\");\n\t\tObjects.requireNonNull(destination, \"Response destination cannot be null\");\n\n//\t\tGet response chunks from rew response bytes\n\t\tList<byte[]> responseChunks = NetworkUtils.splitIntoChunks(responseBytes, NetworkUtils.RESPONSE_BUFFER_SIZE);\n\n//\t\tWrap chunks with UDPFrames\n\t\tList<UDPFrame> udpFrames = NetworkUtils.wrapChunksWithUDPFrames(responseChunks);\n\n\t\treturn NetworkUtils.wrapUDPFramesWithDatagramPackets(udpFrames, destination);\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/exception/MappingException.java", "chunked_list": ["package com.enzulode.network.exception;\n\n/**\n * Exception represents mapping issues\n *\n */\npublic class MappingException extends Exception\n{\n\t/**\n\t * Mapper Exception constructor with no cause provided\n\t *\n\t * @param message exception message\n\t */\n\tpublic MappingException(String message)\n\t{\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * Mapper Exception constructor\n\t *\n\t * @param message exception message\n\t * @param cause exception cause\n\t */\n\tpublic MappingException(String message, Throwable cause)\n\t{\n\t\tsuper(message, cause);\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/exception/NetworkException.java", "chunked_list": ["package com.enzulode.network.exception;\n\n/**\n * Exception represents network issues\n *\n */\npublic class NetworkException extends Exception\n{\n\t/**\n\t * Network Exception constructor with no cause provided\n\t *\n\t * @param message exception message\n\t */\n\tpublic NetworkException(String message)\n\t{\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * Network Exception constructor\n\t *\n\t * @param message exception message\n\t * @param cause exception cause\n\t */\n\tpublic NetworkException(String message, Throwable cause)\n\t{\n\t\tsuper(message, cause);\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/exception/ServerNotAvailableException.java", "chunked_list": ["package com.enzulode.network.exception;\n\n/**\n * Exception represents the situation, when the server is not available\n *\n */\npublic class ServerNotAvailableException extends Exception\n{\n\t/**\n\t * Server not available exception constructor with no cause provided\n\t *\n\t * @param message exception message\n\t */\n\tpublic ServerNotAvailableException(String message)\n\t{\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * Server not available exception constructor\n\t *\n\t * @param message exception message\n\t * @param cause exception cause\n\t */\n\tpublic ServerNotAvailableException(String message, Throwable cause)\n\t{\n\t\tsuper(message, cause);\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/handling/RequestHandler.java", "chunked_list": ["package com.enzulode.network.handling;\n\nimport com.enzulode.network.model.interconnection.Request;\nimport com.enzulode.network.model.interconnection.Response;\n\n/**\n * Request handling functional interface\n *\n */\n@FunctionalInterface\npublic interface RequestHandler\n{\n\t/**\n\t * Handling method\n\t *\n\t * @param request request that is being handled\n\t * @return response instance\n\t */\n\tResponse handle(Request request);\n}\n", " */\n@FunctionalInterface\npublic interface RequestHandler\n{\n\t/**\n\t * Handling method\n\t *\n\t * @param request request that is being handled\n\t * @return response instance\n\t */\n\tResponse handle(Request request);\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/mapper/ResponseMapper.java", "chunked_list": ["package com.enzulode.network.mapper;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.model.interconnection.Response;\nimport org.apache.commons.lang3.SerializationException;\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport java.util.Objects;\n\n/**", "\n/**\n * This class converts element response instance into a byte array and in an opposite way\n *\n */\npublic final class ResponseMapper\n{\n    /**\n\t * This method maps response instance into raw response bytes\n\t *\n\t * @param response response instance\n\t * @return response raw bytes\n\t * @throws MappingException if serialization not succeed\n\t */", "\tpublic static byte[] mapFromInstanceToBytes(Response response) throws MappingException\n\t{\n//\t\tRequiring response instance to be non-null\n\t\tObjects.requireNonNull(response, \"Response instance cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.serialize(response);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map Response instance to bytes\", e);\n\t\t}\n\t}\n\t/**\n\t * This method maps raw response bytes into response instance\n\t *\n\t * @param bytes raw response bytes\n\t * @param <T> response type param\n\t * @return response instance\n\t * @throws MappingException if deserialization not succeed\n\t */\n\tpublic static <T extends Response> T mapFromBytesToInstance(byte[] bytes) throws MappingException\n\t{\n//\t\tRequiring response bytes to be non-null\n\t\tObjects.requireNonNull(bytes, \"Response bytes array cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.deserialize(bytes);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map Response bytes to instance\", e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/mapper/RequestMapper.java", "chunked_list": ["package com.enzulode.network.mapper;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.model.interconnection.Request;\nimport org.apache.commons.lang3.SerializationException;\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport java.util.Objects;\n\n/**", "\n/**\n * This class converts element request instance into a byte array and in an opposite way\n *\n */\npublic final class RequestMapper\n{\n    /**\n\t * This method maps request instance into raw request bytes\n\t *\n\t * @param request request instance\n\t * @return request raw bytes\n\t * @throws MappingException if serialization not succeed\n\t */", "\tpublic static byte[] mapFromInstanceToBytes(Request request) throws MappingException\n\t{\n//\t\tRequiring request instance to be non-null\n\t\tObjects.requireNonNull(request, \"Request instance cannot be null\");\n\t\t\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.serialize(request);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map Request instance to bytes\", e);\n\t\t}\n\t}\n\n\t/**\n\t * This method maps raw request bytes into request instance\n\t *\n\t * @param bytes raw request bytes\n\t * @param <T> request type param\n\t * @return request instance\n\t * @throws MappingException if deserialization not succeed\n\t */\n\tpublic static <T extends Request> T mapFromBytesToInstance(byte[] bytes) throws MappingException\n\t{\n//\t\tRequiring request bytes to be non-null\n\t\tObjects.requireNonNull(bytes, \"Request bytes array cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.deserialize(bytes);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map Request bytes to instance\", e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/com/enzulode/network/mapper/FrameMapper.java", "chunked_list": ["package com.enzulode.network.mapper;\n\nimport com.enzulode.network.exception.MappingException;\nimport com.enzulode.network.model.transport.UDPFrame;\nimport org.apache.commons.lang3.SerializationException;\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport java.util.Objects;\n\n/**", "\n/**\n * This class converts UDPFrame instance into a byte array and in an opposite way\n *\n */\npublic final class FrameMapper\n{\n\t/**\n\t * This method maps {@link UDPFrame} instance into raw response bytes\n\t *\n\t * @param udpFrame {@link UDPFrame} instance\n\t * @return frame raw bytes\n\t * @throws MappingException if serialization not succeed\n\t */", "\tpublic static byte[] mapFromInstanceToBytes(UDPFrame udpFrame) throws MappingException\n\t{\n//\t\tRequiring non-null UDPFrame instance\n\t\tObjects.requireNonNull(udpFrame, \"UDPFrame instance cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.serialize(udpFrame);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map UDPFrame to bytes\", e);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param udpFrameBytes raw {@link UDPFrame} bytes\n\t * @return {@link UDPFrame} instance\n\t * @throws MappingException if deserialization not succeed\n\t */", "\tpublic static UDPFrame mapFromBytesToInstance(byte[] udpFrameBytes) throws MappingException\n\t{\n//\t\tRequiring non-null UDPFrame bytes array\n\t\tObjects.requireNonNull(udpFrameBytes, \"UDPFrame bytes array cannot be null\");\n\n\t\ttry\n\t\t{\n\t\t\treturn SerializationUtils.deserialize(udpFrameBytes);\n\t\t}\n\t\tcatch (SerializationException e)\n\t\t{\n\t\t\tthrow new MappingException(\"Failed to map UDPFrame bytes to instance\", e);\n\t\t}\n\t}\n}\n"]}
