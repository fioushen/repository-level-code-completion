{"filename": "src/Moc/QClassSolver.java", "chunked_list": ["package Moc;\n\nimport Constant.Configs;\nimport Main.Decompiler;\nimport Main.Environment;\nimport Util.*;\nimport ghidra.app.emulator.EmulatorHelper;\nimport ghidra.pcode.emulate.UnimplementedCallOtherException;\nimport ghidra.pcode.emulate.UnimplementedInstructionException;\nimport ghidra.pcode.memstate.MemoryFaultHandler;", "import ghidra.pcode.emulate.UnimplementedInstructionException;\nimport ghidra.pcode.memstate.MemoryFaultHandler;\nimport ghidra.pcode.utils.Utils;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.address.AddressSet;\nimport ghidra.program.model.address.AddressSetView;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.mem.MemoryAccessException;\nimport ghidra.program.model.pcode.HighFunction;", "import ghidra.program.model.mem.MemoryAccessException;\nimport ghidra.program.model.pcode.HighFunction;\nimport ghidra.program.model.pcode.PcodeOpAST;\nimport ghidra.program.model.symbol.*;\nimport ghidra.program.util.string.FoundString;\nimport ghidra.util.LittleEndianDataConverter;\nimport ghidra.util.exception.CancelledException;\nimport ghidra.util.task.TaskMonitor;\nimport ghidra.util.task.TimeoutTaskMonitor;\nimport org.json.JSONObject;", "import ghidra.util.task.TimeoutTaskMonitor;\nimport org.json.JSONObject;\n\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class QClassSolver {\n\n    public Program program;\n    public String className;\n", "    public Program program;\n    public String className;\n\n    public Address metaObject;\n    public Function metaCall;\n\n    public String parentClassName;\n    public Address parentMetaObject;\n\n    public Address metaStringData;\n    public Address metaDataCounter;", "    public Address metaStringData;\n    public Address metaDataCounter;\n    public Function staticMetaCall;\n\n    public List<String> strings = new ArrayList<>();\n    public StringBuilder stringConcat = new StringBuilder();\n\n    public JSONObject propertyIndexMap = new JSONObject();\n    public JSONObject signalMap = new JSONObject();\n    public JSONObject slotMap = new JSONObject();\n\n    // meta data", "    public JSONObject signalMap = new JSONObject();\n    public JSONObject slotMap = new JSONObject();\n\n    // meta data\n    public int revision;\n    public int methodCount;\n    public int propertyCount;\n    public int signalCount;\n\n    public int methodStartIndex;\n    public int propertyStartIndex;\n", "    public int methodStartIndex;\n    public int propertyStartIndex;\n\n    public JSONObject result;\n    \n    // This config enable whether to fork a branch when encountering conditional branches during emulation\n    // Disabled by default for performance concern\n    public boolean enableBranchFork = false;\n\n\n    public QClassSolver(Program program, String className) {\n        this.program = program;\n        this.className = className;\n    }\n", "    public void solve() {\n        // find meta call function\n        List<Address> metaAddrs = FunctionUtil.locateFunctionWithSig(program, className + \"::qt_metacall(typedefCalldword,int,void**)\", true);\n        if (metaAddrs.size() == 0) {\n            // try fuzzy search...\n            for (Function f: FunctionUtil.getAllFunctions(program)) {\n                String sig = FunctionUtil.getFunctionSignature(f);\n                if (sig.contains(className) && sig.contains(\"qt_metacall\")) {\n                    metaCall = f;\n                    break;\n                }\n            }\n", "            if (metaCall == null) {\n                System.out.println(\"qt_metacall not found for \" + className);\n                return;\n            }\n\n        }\n        else {\n            metaCall = FunctionUtil.getFunctionWith(program, metaAddrs.get(0));\n        }\n\n        // find meta object\n        metaObject = null;\n        SymbolTable symbolTable = program.getSymbolTable();\n", "        for (Symbol symbol: symbolTable.getAllSymbols(true)) {\n            if (symbol.getName().equals(\"staticMetaObject\")) {\n                Namespace ns = symbol.getParentNamespace();\n                if (ns.getName().equals(className)) {\n                    metaObject = symbol.getAddress();\n                    break;\n                }\n            }\n        }\n\n        if (metaObject == null) { // not found\n            System.out.println(\"staticMetaObject not found for \" + className);\n            return;\n        }\n\n        // parent class\n        Address current = metaObject;\n        byte[] bytes = new byte[Environment.POINTER_SIZE];", "        if (metaObject == null) { // not found\n            System.out.println(\"staticMetaObject not found for \" + className);\n            return;\n        }\n\n        // parent class\n        Address current = metaObject;\n        byte[] bytes = new byte[Environment.POINTER_SIZE];\n        try {\n            program.getMemory().getBytes(current, bytes);\n        } catch (MemoryAccessException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        long addVal = NumericUtil.byteToLongLittleEndian(bytes);\n        parentMetaObject = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n", "        try {\n            program.getMemory().getBytes(current, bytes);\n        } catch (MemoryAccessException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        long addVal = NumericUtil.byteToLongLittleEndian(bytes);\n        parentMetaObject = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n\n        if (parentMetaObject == null) {\n            System.out.println(\"Parent meta object not an address type: \" + className);\n        }\n\n        Symbol[] symbols = symbolTable.getSymbols(parentMetaObject);", "        if (parentMetaObject == null) {\n            System.out.println(\"Parent meta object not an address type: \" + className);\n        }\n\n        Symbol[] symbols = symbolTable.getSymbols(parentMetaObject);\n        for (Symbol sym: symbols) {\n            Namespace ns = sym.getParentNamespace();\n            if (!ns.getName().equals(\"Global\")) {\n                parentClassName = ns.getName();\n                break;\n            }\n        }\n\n\n        // meta string data\n        current = current.add(Environment.POINTER_SIZE);", "        if (current != null) {\n            bytes = new byte[Environment.POINTER_SIZE];\n            try {\n                program.getMemory().getBytes(current, bytes);\n            } catch (MemoryAccessException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            addVal = NumericUtil.byteToLongLittleEndian(bytes);\n            metaStringData = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n", "            if (metaStringData == null) {\n                System.out.println(\"Meta string data not an address type: \" + className);\n            }\n        }\n\n        // meta data counter\n        current = current.add(Environment.POINTER_SIZE);\n        if (current != null) {\n            bytes = new byte[Environment.POINTER_SIZE];\n            try {\n                program.getMemory().getBytes(current, bytes);\n            } catch (MemoryAccessException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            addVal = NumericUtil.byteToLongLittleEndian(bytes);\n            metaDataCounter = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n", "            try {\n                program.getMemory().getBytes(current, bytes);\n            } catch (MemoryAccessException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            addVal = NumericUtil.byteToLongLittleEndian(bytes);\n            metaDataCounter = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n\n            if (metaDataCounter == null) {\n                System.out.println(\"Meta string data not an address type: \" + className);\n            }\n        }\n\n        // static meta call\n        current = current.add(Environment.POINTER_SIZE);", "            if (metaDataCounter == null) {\n                System.out.println(\"Meta string data not an address type: \" + className);\n            }\n        }\n\n        // static meta call\n        current = current.add(Environment.POINTER_SIZE);\n        if (current != null) {\n            bytes = new byte[Environment.POINTER_SIZE];\n            try {\n                program.getMemory().getBytes(current, bytes);\n            } catch (MemoryAccessException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            addVal = NumericUtil.byteToLongLittleEndian(bytes);\n            Address staticMetaCallAddress = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));", "            try {\n                program.getMemory().getBytes(current, bytes);\n            } catch (MemoryAccessException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            addVal = NumericUtil.byteToLongLittleEndian(bytes);\n            Address staticMetaCallAddress = program.getAddressFactory().getAddress(NumericUtil.longToHexString(addVal));\n            if (staticMetaCallAddress.getUnsignedOffset() == 0) {\n                // static_metacall not exist\n                System.out.println(\"Meta string data not an address type: \" + className);\n                staticMetaCall = null;\n            }\n            else {\n                staticMetaCall = FunctionUtil.getFunctionWith(program, staticMetaCallAddress);\n            }\n        }\n\n        // construct string array\n        analyzeString();\n", "            if (staticMetaCallAddress.getUnsignedOffset() == 0) {\n                // static_metacall not exist\n                System.out.println(\"Meta string data not an address type: \" + className);\n                staticMetaCall = null;\n            }\n            else {\n                staticMetaCall = FunctionUtil.getFunctionWith(program, staticMetaCallAddress);\n            }\n        }\n\n        // construct string array\n        analyzeString();\n", "        try {\n            analyzeMetaData();\n            analyzeMethodMeta();\n            analyzePropertyMeta();\n            analyzeMetaCall();\n        }\n        catch (MemoryAccessException e) {\n            e.printStackTrace();\n        }\n\n        processResult();\n    }\n\n", "    public void analyzeString() {\n\n        Address current = metaStringData;\n        Address start, end;\n\n        byte[] bytes = new byte[this.className.length()];\n\n        // find the start of the string table\n        while (true) {\n            try {\n                program.getMemory().getBytes(current, bytes);\n                String s = new String(bytes);", "        while (true) {\n            try {\n                program.getMemory().getBytes(current, bytes);\n                String s = new String(bytes);\n                if (s.startsWith(this.className)) {\n                    start = current;\n                    break;\n                }\n                current = current.next();\n            }\n            catch (MemoryAccessException e) {\n                return;\n            }\n        }\n\n\n        SymbolTable symboltable = program.getSymbolTable();\n        // find the end of the string table\n        do {\n            current = current.next();\n        }", "        while (symboltable.getSymbols(current).length == 0); // loop until next string table is reached, which ends the current table\n        end = current;\n\n\n        if (start == null || end == null)\n            return;\n\n        AddressSetView addressSetView = new AddressSet(start, end);\n        List<FoundString> foundStrings = StringUtil.findStrings(program, addressSetView, 1, 1, true, true);\n\n        for (int i=0; i<foundStrings.size(); ++i) {\n\n            String str = foundStrings.get(i).getString(program.getMemory());\n            strings.add(str);\n            stringConcat.append(str);\n            stringConcat.append(\" \");", "        for (int i=0; i<foundStrings.size(); ++i) {\n\n            String str = foundStrings.get(i).getString(program.getMemory());\n            strings.add(str);\n            stringConcat.append(str);\n            stringConcat.append(\" \");\n            if (i < foundStrings.size() - 1) {\n                FoundString nextStr = foundStrings.get(i+1);\n                if (nextStr.getAddress().getUnsignedOffset() - foundStrings.get(i).getEndAddress().getUnsignedOffset() != 1) {\n                    // space exists\n                    strings.add(\" \");\n                    stringConcat.append(\" \");\n                }\n            }\n        }\n\n    }\n\n", "                if (nextStr.getAddress().getUnsignedOffset() - foundStrings.get(i).getEndAddress().getUnsignedOffset() != 1) {\n                    // space exists\n                    strings.add(\" \");\n                    stringConcat.append(\" \");\n                }\n            }\n        }\n\n    }\n\n", "    public void analyzeMetaData() throws MemoryAccessException {\n        if (metaDataCounter == null)\n            return;\n\n        Address current = metaDataCounter;\n        byte[] bytes = new byte[4];\n\n        // revision\n        program.getMemory().getBytes(current, bytes);\n        revision = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n\n        // classname\n        current = current.add(4);\n\n        // classinfo\n        current = current.add(8);\n\n        // methods\n        program.getMemory().getBytes(current, bytes);\n        methodCount = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n        program.getMemory().getBytes(current, bytes);\n        methodStartIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n\n        // properties\n        program.getMemory().getBytes(current, bytes);\n        propertyCount = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n        program.getMemory().getBytes(current, bytes);\n        propertyStartIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n\n        // enums/sets\n        current = current.add(8);\n\n        // constructors\n        current = current.add(8);\n\n        // flags\n        current = current.add(4);\n\n        // signalCount\n        program.getMemory().getBytes(current, bytes);\n        signalCount = (int) NumericUtil.byteToLongLittleEndian(bytes);\n        current = current.add(4);\n\n    }\n\n", "    public void analyzeMethodMeta() throws MemoryAccessException {\n        if (signalCount == 0 || methodStartIndex == 0)\n            return;\n\n        Address current = metaDataCounter.add(methodStartIndex*4);\n        // parse signal\n        for (int i=0; i<signalCount; ++i) {\n            byte[] bytes = new byte[4];\n\n            // name\n            program.getMemory().getBytes(current.add(0), bytes);\n            int index = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // argc\n            program.getMemory().getBytes(current.add(4), bytes);\n            int argc = (int) NumericUtil.byteToLongLittleEndian(bytes);\n            String argc_str = getStringFromMeta(argc);\n\n            // param index\n            program.getMemory().getBytes(current.add(8), bytes);\n            int paramIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // tag\n            program.getMemory().getBytes(current.add(12), bytes);\n            int tag = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // flags\n            program.getMemory().getBytes(current.add(16), bytes);\n            int flags = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n\n            // get signal name\n            String signalName = parseName(index);\n\n            // parse args\n            JSONObject args = parseArgs(paramIndex, argc);\n\n            JSONObject tmp = new JSONObject();\n            tmp.put(\"name\", signalName);\n            //tmp.put(\"argc\", argc);\n            tmp.put(\"args\", args);\n            signalMap.put(i + \"\", tmp);\n\n            current = current.add(20); // entry size = 20\n        }\n\n        // parse slots\n        int slotCount = methodCount - signalCount;", "        for (int i=0; i<slotCount; ++i) {\n\n            byte[] bytes = new byte[4];\n\n            // name\n            program.getMemory().getBytes(current.add(0), bytes);\n            int index = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // argc\n            program.getMemory().getBytes(current.add(4), bytes);\n            int argc = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // param index\n            program.getMemory().getBytes(current.add(8), bytes);\n            int paramIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // tag\n            program.getMemory().getBytes(current.add(12), bytes);\n            int tag = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // flags\n            program.getMemory().getBytes(current.add(16), bytes);\n            int flags = (int) NumericUtil.byteToLongLittleEndian(bytes);\n\n            // get slot name\n            String slotName = parseName(index);\n\n            // parse args\n            JSONObject args = parseArgs(paramIndex, argc);\n\n            JSONObject tmp = new JSONObject();\n            tmp.put(\"name\", slotName);\n            //tmp.put(\"argc\", argc);\n            tmp.put(\"args\", args);\n            slotMap.put(i + \"\", tmp);\n\n            current = current.add(20);\n        }\n    }\n", "    public JSONObject parseArgs(int startIndex, int argc) throws MemoryAccessException{\n\n        JSONObject result = new JSONObject();\n\n        if (this.revision <= 5) {\n            // in old version, the string at argc represents the arguments\n            String args = getStringFromMeta(argc);\n            if (args.equals(\"\"))\n                return result;\n            else {\n                String[] tokens = args.split(\",\");", "                for (int i=0; i<tokens.length; ++i) {\n                    result.put(i + \"\", new JSONObject());\n                    result.getJSONObject(i + \"\").put(\"name\", tokens[i]);\n                }\n                return result;\n            }\n        }\n        else {\n            Address current = metaDataCounter.add(startIndex * 4);\n\n\n            byte[] bytes = new byte[4];\n\n            // return type\n            program.getMemory().getBytes(current, bytes);\n            int retType = (int) NumericUtil.byteToLongLittleEndian(bytes);\n            result.put(\"retType\", retType);\n            current = current.add(4);\n\n            // arg type", "            for (int i = 0; i < argc; ++i) {\n                program.getMemory().getBytes(current, bytes);\n                int typeIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n                String type = parseType(typeIndex);\n                result.put(i + \"\", new JSONObject());\n                result.getJSONObject(i + \"\").put(\"type\", type);\n                current = current.add(4);\n            }\n\n            // arg index\n            for (int i = 0; i < argc; ++i) {\n                program.getMemory().getBytes(current, bytes);\n                int index = (int) NumericUtil.byteToLongLittleEndian(bytes);\n                String name = parseName(index);\n                result.getJSONObject(i + \"\").put(\"name\", name);\n                current = current.add(4);\n            }\n\n            return result;\n        }\n\n    }\n\n", "            for (int i = 0; i < argc; ++i) {\n                program.getMemory().getBytes(current, bytes);\n                int index = (int) NumericUtil.byteToLongLittleEndian(bytes);\n                String name = parseName(index);\n                result.getJSONObject(i + \"\").put(\"name\", name);\n                current = current.add(4);\n            }\n\n            return result;\n        }\n\n    }\n\n", "    public void analyzePropertyMeta() throws MemoryAccessException{\n        if (propertyCount == 0 || propertyStartIndex == 0)\n            return;\n\n        Address properyStart = metaDataCounter.add(propertyStartIndex*4);\n        for (int i=0; i<propertyCount; ++i) {\n\n            JSONObject tmp = new JSONObject();\n\n            Address propertyAddress = properyStart.add(i*12); // entry size = 12\n            // string index\n            byte[] bytes = new byte[4];\n            program.getMemory().getBytes(propertyAddress, bytes);\n            int index = (int) NumericUtil.byteToLongLittleEndian(bytes);\n            String propertyName = parseName(index);\n            tmp.put(\"name\", propertyName);\n\n            // type\n            program.getMemory().getBytes(propertyAddress.add(4), bytes);\n            int typeIndex = (int) NumericUtil.byteToLongLittleEndian(bytes);\n            String type = parseType(typeIndex);\n            tmp.put(\"type\", type);\n\n            // flags\n            program.getMemory().getBytes(propertyAddress.add(8), bytes);\n            int flags = (int) NumericUtil.byteToLongLittleEndian(bytes);\n            tmp.put(\"flags\", flags);\n\n            // add to result\n            propertyIndexMap.put(i + \"\", tmp);\n\n        }\n    }\n\n", "    public void analyzeMetaCall() {\n\n        // analyze the property-memory mapping in the meta call function\n        if (metaCall == null && staticMetaCall == null)\n            return;\n\n        Set<String> propKeySet = propertyIndexMap.keySet();\n        Function funcToExec = null;\n\n\n        if (staticMetaCall != null) {\n            // emulate static meta call if possible\n            funcToExec = staticMetaCall;\n        }", "        if (staticMetaCall != null) {\n            // emulate static meta call if possible\n            funcToExec = staticMetaCall;\n        }\n        else if (metaCall != null) {\n            funcToExec = metaCall;\n        }\n\n\n        for (String key: propKeySet) {\n\n            int index = Integer.valueOf(key);\n\n            // execute meta call function with emulation\n            //List<Long> symbolicOffset = emulate(index, funcToExec);\n            List<String> exps = new ArrayList<>();\n\n            Map<Long, Boolean> unexploredBranch = new HashMap<>();\n            String resultExp = emulate(index, funcToExec, unexploredBranch);\n            exps.add(resultExp);\n\n            int maxExploreAttempt = 5;\n            int attempt = 0;", "        for (String key: propKeySet) {\n\n            int index = Integer.valueOf(key);\n\n            // execute meta call function with emulation\n            //List<Long> symbolicOffset = emulate(index, funcToExec);\n            List<String> exps = new ArrayList<>();\n\n            Map<Long, Boolean> unexploredBranch = new HashMap<>();\n            String resultExp = emulate(index, funcToExec, unexploredBranch);\n            exps.add(resultExp);\n\n            int maxExploreAttempt = 5;\n            int attempt = 0;", "            while (!checkAllExplored(unexploredBranch) && attempt < maxExploreAttempt) {\n                resultExp = emulate(index, funcToExec, unexploredBranch);\n                exps.add(resultExp);\n                attempt ++;\n            }\n\n\n            /*\n            // construct property expression\n            Node head = null;\n            for (int i = 0; i < symbolicOffset.size(); ++i) {\n                int offset = (int) (long) symbolicOffset.get(i);\n                String hex = \"0x\" + Integer.toHexString(offset);", "            for (int i = 0; i < symbolicOffset.size(); ++i) {\n                int offset = (int) (long) symbolicOffset.get(i);\n                String hex = \"0x\" + Integer.toHexString(offset);\n                if (i == 0) {\n                    Node currentNode = new ExpNode(\"INT_ADD\", new LeafNode(Environment.EXP_R0), new LeafNode(String.format(\"(const, %s, 4)\", hex)));\n                    Node parent = new ExpNode(\"LOAD\", new LeafNode(\"(const, 0x1a1, 4)\"), currentNode);\n                    head = parent;\n                }\n                else {\n                    Node currentNode = new ExpNode(\"INT_ADD\", head, new LeafNode(String.format(\"(const, %s, 4)\", hex)));\n                    head = new ExpNode(\"LOAD\", new LeafNode(\"(const, 0x1a1, 4)\"), currentNode);\n                }\n            }\n\n            String exp = \"\";", "            if (head != null) {\n                try {\n                    exp = Node.evaluate(head);\n                } catch (StackOverflowError e) {\n\n                }\n            }\n            */\n\n            // put expression\n            for (int i=0; i<exps.size(); ++i) {\n                propertyIndexMap.getJSONObject(key).put(\"expression\" + i, exps.get(i));\n            }\n        }\n\n    }\n\n    private boolean checkAllExplored(Map<Long, Boolean> map) {", "            for (int i=0; i<exps.size(); ++i) {\n                propertyIndexMap.getJSONObject(key).put(\"expression\" + i, exps.get(i));\n            }\n        }\n\n    }\n\n    private boolean checkAllExplored(Map<Long, Boolean> map) {\n        for (Boolean b: map.values()) {\n            if (!b)\n                return false;\n        }\n        return true;\n    }\n", "        for (Boolean b: map.values()) {\n            if (!b)\n                return false;\n        }\n        return true;\n    }\n\n    public String emulate(int index, Function function, Map<Long, Boolean> unexploredBranch) {\n        // r1 = 0: QMetaObject::InvokeMetaMethod\n        // r1 = 1: QMetaObject::ReadProperty\n        // r1 = 2: QMetaObject::WriteProperty\n        // r1 = 10:QMetaObject::IndexOfMethod\n\n        // r1 = 1 (READ), r2 = index, r3 stores the result\n\n        EmulatorHelper emulatorHelper = new EmulatorHelper(program);\n\n        HighFunction currentDecompileFunc = Decompiler.decompileFuncRegister(program, function).getHighFunction();\n\n        long probeLRVal = 0xFFFE; // we assign lr with a value that marks the end of the function execution\n        long symbolicVal = 0xE0; // assign a value at high memory as a symbolic value\n        long symbolicRegionLimit = 0x1000; // symbolic region size\n        long symbolicRegionSize = 0x1000;\n        long indexBase = 0xE0;\n        int resultRegion = 0x2000;\n\n        // hope the symbolic computation region does not overlap with the code...\n        long baseAddr = Environment.getProgram().getImageBase().getUnsignedOffset();", "        if (baseAddr > resultRegion + 0x100) {\n            // as long as the base address is larger than the symbolic computation region then we're fine\n        }\n        else {\n            System.out.println(\"Image base has conflict with the symbolic computation region, cannot safely proceed, exiting...\");\n            return \"\";\n        }\n\n        Map<Long, String> symbolicMap = new HashMap<>();\n\n        List<String> exps = new ArrayList<>();\n        String resultExp = null;\n\n        // initialize registers", "        if (Environment.LANGUAGE_NAME.contains(\"ARM\")) {\n            emulatorHelper.writeRegister(\"r0\", symbolicVal);\n            emulatorHelper.writeRegister(\"r1\", 1);\n            emulatorHelper.writeRegister(\"r2\", index);\n            emulatorHelper.writeRegister(\"r3\", resultRegion);\n            emulatorHelper.writeRegister(\"lr\", probeLRVal); // return address\n        }\n        else if (Environment.LANGUAGE_NAME.contains(\"x86\")) {\n            emulatorHelper.writeRegister(\"RDI\", symbolicVal);\n            emulatorHelper.writeRegister(\"ESI\", 1);\n            emulatorHelper.writeRegister(\"EDX\", index);\n            emulatorHelper.writeRegister(\"RCX\", resultRegion);\n            //emulatorHelper.writeMemory(emulatorHelper.getStackPointerRegister().getAddress(), DataConverter.getInstance(false).getBytes(probeLRVal));\n        }\n\n\n        // result Region: a: 0x2000, *a: 0x2008, **a: 0x2010\n        emulatorHelper.writeMemory(AddressUtil.getAddressFromLong(program, resultRegion), NumericUtil.intToBytes(resultRegion+8, true));\n        emulatorHelper.writeMemory(AddressUtil.getAddressFromLong(program, resultRegion+8), NumericUtil.intToBytes(0, true));\n\n\n        // set starting point\n        Address startingPoint = function.getEntryPoint();\n        emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), startingPoint.getUnsignedOffset());\n\n        List<Long> symbolicOffset = new ArrayList<>();\n\n        Map<Long, List<Long>> symbolicRegions = new HashMap<>();\n\n        // define memory read handler to intercept memory reads\n        emulatorHelper.setMemoryFaultHandler(new MemoryFaultHandler() {\n            @Override", "            public boolean uninitializedRead(Address address, int i, byte[] bytes, int i1) {\n                if (address.getUnsignedOffset() >= symbolicVal && address.getUnsignedOffset() < (symbolicVal + symbolicRegionLimit)) {\n                    // falls into the symbolic value region\n                    Function f = FunctionUtil.getFunctionWith(program, emulatorHelper.getExecutionAddress());\n                    HighFunction highFunction = Decompiler.decompileFuncRegister(program, f).getHighFunction();\n                    Iterator<PcodeOpAST> asts = highFunction.getPcodeOps(emulatorHelper.getExecutionAddress());\n\n                    String exp = \"\";\n                    while (asts.hasNext()) {\n                        PcodeOpAST ast = asts.next();\n                        if (ast.getMnemonic().equals(\"INT_ADD\")) {\n                            exp = PCodeUtil.evaluateVarNode(ast.getOutput());\n                            break;\n                        }\n                    }", "                    while (asts.hasNext()) {\n                        PcodeOpAST ast = asts.next();\n                        if (ast.getMnemonic().equals(\"INT_ADD\")) {\n                            exp = PCodeUtil.evaluateVarNode(ast.getOutput());\n                            break;\n                        }\n                    }\n                    if (exp.contains(Environment.EXP_R0)) {\n                        exps.add(exp);\n\n                        // assigns new symbolic value\n                        long newSymbolicIndex = indexBase + symbolicMap.keySet().size();\n                        symbolicMap.put(newSymbolicIndex, exp);\n                        emulatorHelper.writeMemory(address, Utils.longToBytes(newSymbolicIndex, Environment.POINTER_SIZE, false));\n                    }\n                }\n                return true;\n            }\n\n            @Override", "            public boolean unknownAddress(Address address, boolean b) {\n                return false;\n            }\n        });\n\n\n        TaskMonitor monitor = TimeoutTaskMonitor.timeoutIn(Configs.EMULATION_TIMEOUT, TimeUnit.SECONDS);\n\n        Function currentFunction = function;\n        if (currentFunction.getThunkedFunction(true) != null)\n            currentFunction = currentFunction.getThunkedFunction(true);\n\n\n        // start emulation", "        if (currentFunction.getThunkedFunction(true) != null)\n            currentFunction = currentFunction.getThunkedFunction(true);\n\n\n        // start emulation\n        while (!monitor.isCancelled()) {\n            Address currentAdd = emulatorHelper.getExecutionAddress();\n            //System.out.println(currentAdd);\n\n            try {\n                boolean success = emulatorHelper.step(monitor);\n", "            try {\n                boolean success = emulatorHelper.step(monitor);\n\n                if (!success) {\n                    String error = emulatorHelper.getLastError();\n                    if (error.contains(\"Unimplemented\")) {\n                        emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n                    }\n                    System.out.println(emulatorHelper.getLastError());\n                }\n            } catch (CancelledException e) {\n                break;\n            } catch (UnimplementedCallOtherException | UnimplementedInstructionException e) {\n                e.printStackTrace();\n                // skip unknown ops\n                emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n            }\n\n            Address next = AddressUtil.getAddressFromLong(program, emulatorHelper.readRegister(emulatorHelper.getPCRegister()).longValue());", "            if (next.getUnsignedOffset() != currentAdd.getUnsignedOffset()) {\n                Environment.PCODE_INS_COUNT += 1;\n            }\n\n            if (currentFunction.getBody().contains(next)) {\n                Iterator<PcodeOpAST> asts = currentDecompileFunc.getPcodeOps(currentAdd);\n                boolean branchFlag = false;\n                Address branchAddr = null;\n                // detect conditional branch\n                while (asts.hasNext()) {\n                    PcodeOpAST ast = asts.next();", "                while (asts.hasNext()) {\n                    PcodeOpAST ast = asts.next();\n                    if (ast.getMnemonic().equals(\"CBRANCH\")) { // conditional branch happens\n                        if (enableBranchFork)\n                            branchFlag = true;\n                        branchAddr = ast.getInputs()[0].getAddress();\n                        break;\n                    }\n                }\n\n                if (branchFlag) {", "                if (branchFlag) {\n                    if (!currentFunction.toString().contains(\"qt_metacall\") && currentFunction.getEntryPoint().getUnsignedOffset() != function.getEntryPoint().getUnsignedOffset()) {\n                        // jump happens (not in metacall function), fork another branch\n                        long branch1 = AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset();\n                        long branch2 = branchAddr.getUnsignedOffset();\n\n                        // decide which branch to go\n                        if (!unexploredBranch.containsKey(branch1) || !unexploredBranch.get(branch1)) {\n                            // go to branch 1\n                            emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), branch1);\n                            unexploredBranch.put(branch1, true);\n                            next = AddressUtil.getAddressFromLong(program, branch1);\n", "                            if (!unexploredBranch.containsKey(branch2) || !unexploredBranch.get(branch2)) {\n                                // explore branch2 in later execution\n                                unexploredBranch.put(branch2, false);\n                            }\n                        }\n                        else {\n                            // branch 1 has been explored, check branch 2\n                            if (!unexploredBranch.containsKey(branch2) || !unexploredBranch.get(branch2)) {\n                                // explore branch2\n                                emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), branch2);\n                                unexploredBranch.put(branch2, true);\n                                next = AddressUtil.getAddressFromLong(program, branch2);\n                            }\n                            else {\n                                // both branch have been explored, randomly choose a branch\n                                long choice = System.currentTimeMillis() % 2;", "                                if (choice == 0) {\n                                    // explore branch 1\n                                    emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), branch1);\n                                    next = AddressUtil.getAddressFromLong(program, branch1);\n                                }\n                                else {\n                                    // explore branch 2\n                                    emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), branch2);\n                                    next = AddressUtil.getAddressFromLong(program, branch2);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else { \n                // jump to another function detected", "                if (next.getUnsignedOffset() == probeLRVal || next.toString().equals(\"00000000\")) {\n                    // emulation ends, select results\n                    byte[] bytes = emulatorHelper.readMemory(AddressUtil.getAddressFromLong(program, resultRegion+8), 4);\n                    long val = NumericUtil.byteToLongLittleEndian(bytes);\n                    if (val == 0)\n                        resultExp = \"NULL\";\n                    else {\n                        if (symbolicMap.get(val) != null)\n                            resultExp = symbolicMap.get(val);\n                        else\n                            resultExp = \"NULL\";\n                    }\n                    break;\n                }\n\n                // jumping to other functions", "                try {\n                    Function nextFunction = FunctionUtil.getFunctionWith(program, next);\n                    if (nextFunction.getThunkedFunction(true) != null)\n                        nextFunction = nextFunction.getThunkedFunction(true);\n                    String nextFuncName = nextFunction.getName();\n                    if (nextFuncName.equals(\"qt_metacall\") && nextFunction.toString().contains(parentClassName)) {\n                        // skip invoking parent meta call function\n                        //emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), currentAdd.add(Environment.POINTER_SIZE).getUnsignedOffset());\n                        emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n\n                        // replace return value as the index\n                        emulatorHelper.writeRegister(Environment.RETURN_REG, index);\n                    }", "                    else if (nextFunction.isExternal()) {\n                        // skip external function\n                        emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n                    }\n                    else {\n\n                        Function currentFunc = FunctionUtil.getFunctionWith(program, currentAdd);\n                        if (currentFunc.getThunkedFunction(true) != null)\n                            currentFunc = currentFunc.getThunkedFunction(true);\n                        Namespace currentNs = currentFunc.getParentNamespace();\n                        Namespace nextNs = nextFunction.getParentNamespace();", "                        if (currentFunc.getEntryPoint().getUnsignedOffset() == function.getEntryPoint().getUnsignedOffset() ||\n                            nextFunction.getEntryPoint().getUnsignedOffset() == function.getEntryPoint().getUnsignedOffset()) {\n                            // jump to next function\n                            currentFunction = nextFunction;\n                            currentDecompileFunc = Decompiler.decompileFuncRegister(program, currentFunction).getHighFunction();\n                        }\n                        else if (!currentNs.getName().equals(nextNs.getName())) {\n                            // do not execute functions in other class's context\n                            emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n                        }\n                        else {\n                            // jump to next function\n                            currentFunction = nextFunction;\n                            currentDecompileFunc = Decompiler.decompileFuncRegister(program, currentFunction).getHighFunction();\n                        }\n\n                    }\n\n                } catch (NullPointerException e) {", "                    if (next.toString().equals(\"ffff0fc0\")) {\n                        // TODO skip this shit\n                        emulatorHelper.writeRegister(Environment.RETURN_REG, 0); // set return value as 0\n                    }\n                    emulatorHelper.writeRegister(emulatorHelper.getPCRegister(), AddressUtil.getAddressInNextIns(program, currentAdd).getUnsignedOffset());\n                }\n            }\n\n        }\n\n\n        return resultExp;\n    }\n\n", "    public String getStringFromMeta(int startIndex) {\n        try {\n            String result = \"\";\n            for (int j = startIndex; j < stringConcat.length(); ++j) {\n                if (stringConcat.charAt(j) != ' ') {\n                    result = result + stringConcat.charAt(j);\n                } else\n                    break;\n            }\n            return result;\n        }\n        catch (Exception e) {\n            return \"\";\n        }\n    }\n", "    public String parseType(int index) {\n        if (this.revision <= 5) {\n            return getStringFromMeta(index);\n        }\n        else {\n            switch (index) {\n                // Based on https://codebrowser.dev/qt5/qtbase/src/corelib/kernel/qmetatype.h.html\n                case 0:\n                    return \"UnknownType\";\n                case 1:\n                    return \"Bool\";\n                case 2:\n                    return \"Int\";\n                case 3:\n                    return \"UInt\";\n                case 4:\n                    return \"LongLong\";\n                case 5:\n                    return \"ULongLong\";\n                case 6:\n                    return \"Double\";\n                case 7:\n                    return \"QChar\";\n                case 8:\n                    return \"QVariantMap\";\n                case 9:\n                    return \"QVariantList\";\n                case 10:\n                    return \"QString\";\n                case 11:\n                    return \"QStringList\";\n                case 12:\n                    return \"QByteArray\";\n                case 13:\n                    return \"QBitArray\";\n                case 14:\n                    return \"QDate\";\n                case 15:\n                    return \"QTime\";\n                case 16:\n                    return \"QDateTime\";\n                case 17:\n                    return \"QUrl\";\n                case 18:\n                    return \"QLocale\";\n                case 19:\n                    return \"QRect\";\n                case 20:\n                    return \"QRectF\";\n                case 21:\n                    return \"QSize\";\n                case 22:\n                    return \"QSizeF\";\n                case 23:\n                    return \"QLine\";\n                case 24:\n                    return \"QLineF\";\n                case 25:\n                    return \"QPoint\";\n                case 26:\n                    return \"QPointF\";\n                case 27:\n                    return \"QRegExp\";\n                case 28:\n                    return \"QVariantHash\";\n                case 29:\n                    return \"QEasingCurve\";\n                case 30:\n                    return \"QUuid\";\n                case 32:\n                    return \"Long\";\n                case 33:\n                    return \"Short\";\n                case 34:\n                    return \"Char\";\n                case 35:\n                    return \"ULong\";\n                case 36:\n                    return \"UShort\";\n                case 37:\n                    return \"UChar\";\n                case 38:\n                    return \"Float\";\n                case 41:\n                    return \"QVariant\";\n                case 42:\n                    return \"QModelIndex\";\n                case 43:\n                    return \"Void\";\n                case 44:\n                    return \"QRegularExpression\";\n                case 45:\n                    return \"QJsonValue\";\n                case 46:\n                    return \"QJsonObject\";\n                case 47:\n                    return \"QJsonArray\";\n                case 48:\n                    return \"QJsonDocument\";\n                case 51:\n                    return \"Nullptr\";\n                case 52:\n                    return \"QCborSimpleType\";\n                case 53:\n                    return \"QCborValue\";\n                case 54:\n                    return \"QCborArray\";\n                case 55:\n                    return \"QCborMap\";\n                case 64:\n                    return \"QFont\";\n                case 65:\n                    return \"QPixmap\";\n                case 66:\n                    return \"QBrush\";\n                case 67:\n                    return \"QColor\";\n                case 68:\n                    return \"QPalette\";\n                case 69:\n                    return \"QIcon\";\n                case 70:\n                    return \"QImage\";\n                case 71:\n                    return \"QPolygon\";\n                case 72:\n                    return \"QRegion\";\n                case 73:\n                    return \"QBitmap\";\n                case 74:\n                    return \"QCursor\";\n                case 75:\n                    return \"QKeySequence\";\n                case 76:\n                    return \"QPen\";\n                case 77:\n                    return \"QTextLength\";\n                case 78:\n                    return \"QTextFormat\";\n                case 79:\n                    return \"QMatrix\";\n                case 80:\n                    return \"QTransform\";\n                case 81:\n                    return \"QMatrix4x4\";\n                case 82:\n                    return \"QVector2D\";\n                case 83:\n                    return \"QVector3D\";\n                case 84:\n                    return \"QVector4D\";\n                case 85:\n                    return \"QQuaternion\";\n                case 86:\n                    return \"QPolygonF\";\n                case 121:\n                    return \"QSizePolicy\";\n                default:\n                    return \"\" + index;\n            }\n        }\n    }\n", "    public String parseName(int index) {\n        if (this.revision <= 5) {\n            return getStringFromMeta(index);\n        }\n        else {\n            try {\n                return strings.get(index);\n            } catch (Exception e) {\n                return null;\n            }\n        }\n    }\n\n", "    public void processResult() {\n        if (metaCall == null && staticMetaCall == null)\n            return;\n\n        result = new JSONObject();\n        result.put(\"parent\", parentClassName);\n        result.put(\"metaCall\", metaCall.getEntryPoint());\n        if (staticMetaCall != null) {\n            result.put(\"staticMetaCall\", staticMetaCall.getEntryPoint());\n        }\n        result.put(\"stringData\", metaStringData);\n        result.put(\"methodCount\", methodCount);\n        result.put(\"propertyCount\", propertyCount);\n        result.put(\"signalCount\", signalCount);\n\n        result.put(\"property\", propertyIndexMap);\n        result.put(\"signal\", signalMap);\n        result.put(\"slot\", slotMap);\n    }\n\n\n}\n"]}
{"filename": "src/Moc/QtConnectSolver.java", "chunked_list": ["package Moc;\n\nimport Constant.Constants;\nimport Main.Decompiler;\nimport Main.Environment;\nimport Util.*;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.data.DataType;\nimport ghidra.program.model.listing.Function;", "import ghidra.program.model.data.DataType;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.listing.Parameter;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.pcode.*;\nimport ghidra.program.model.symbol.Symbol;\nimport ghidra.program.model.symbol.SymbolTable;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;", "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class QtConnectSolver {\n\n    Address startAdd; // address of bl connect\n    Address connAdd; // address of the connection function\n\n    public String signalFunction;\n    public String signalClass;", "    public String signalFunction;\n    public String signalClass;\n    public String signalExp;\n    public long signalAddress = -1;\n\n    public String slotFunction;\n    public String slotClass;\n    public String slotExp;\n    public long slotAddress = -1;\n\n    public String signalClassType = null;", "    public long slotAddress = -1;\n\n    public String signalClassType = null;\n    public String slotClassType = null;\n\n    public boolean allSolved = false;\n    public boolean invalid = false;\n    public int connectType = -1;\n\n    public HighFunction highFunction;\n\n    public QtConnectSolver(Address start) {\n        this.startAdd = start;\n        this.slotFunction = null;\n        this.signalFunction = null;\n        this.signalExp = null;\n        this.slotExp = null;\n        this.slotClass = null;\n    }\n", "    public HighFunction highFunction;\n\n    public QtConnectSolver(Address start) {\n        this.startAdd = start;\n        this.slotFunction = null;\n        this.signalFunction = null;\n        this.signalExp = null;\n        this.slotExp = null;\n        this.slotClass = null;\n    }\n", "    public void setConnectAddr(Address connectAddr) {\n        this.connAdd = connectAddr;\n    }\n\n    public void solve() {\n\n        Function func = FunctionUtil.getFunctionWith(Environment.getProgram(), connAdd);\n        Parameter[] params = func.getParameters();\n        int paramLen = params.length;\n\n        if (paramLen < 2) {\n            System.out.println(\"Invalid length \" + paramLen + \" of the Qt connect function, skipping\");\n            return;\n        }\n\n        // we determine type 1 or type 2 Qt connect based on the second parameter\n        String p1Type = params[1].getDataType().getName();\n        // System.out.println(\"param[1] type \" + p1Type);", "        if (paramLen < 2) {\n            System.out.println(\"Invalid length \" + paramLen + \" of the Qt connect function, skipping\");\n            return;\n        }\n\n        // we determine type 1 or type 2 Qt connect based on the second parameter\n        String p1Type = params[1].getDataType().getName();\n        // System.out.println(\"param[1] type \" + p1Type);\n        if (p1Type.equals(\"char *\")) {\n            this.connectType = 2;\n            if (Environment.LANGUAGE_NAME.contains(\"x86:LE:64\") || Environment.LANGUAGE_NAME.contains(\"x86:LE:32\"))\n                solveType2_x86();", "        if (p1Type.equals(\"char *\")) {\n            this.connectType = 2;\n            if (Environment.LANGUAGE_NAME.contains(\"x86:LE:64\") || Environment.LANGUAGE_NAME.contains(\"x86:LE:32\"))\n                solveType2_x86();\n            else if (Environment.LANGUAGE_NAME.contains(\"ARM:LE:32:v8\"))\n                solveType2_arm();\n        }\n        else {\n            this.connectType = 1;\n            solveType1();\n        }\n\n    }\n", "    public void solveType2_arm() {\n        Program program = Environment.getProgram();\n\n        // decompile\n        DecompileResults results = Decompiler.decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, startAdd));\n        if (results == null)\n            return;\n\n        highFunction = results.getHighFunction();\n        Iterator<PcodeOpAST> pcodeOpASTIterator = highFunction.getPcodeOps(startAdd);\n\n\n        // analyze the decompiled code at bl connect\n        PcodeOpAST pcodeAST = null;", "        while (pcodeOpASTIterator.hasNext()) {\n            PcodeOpAST tmp = pcodeOpASTIterator.next();\n            if (tmp.getMnemonic().equals(\"CALL\")) {\n                pcodeAST = tmp;\n                break;\n            }\n        }\n        if (pcodeAST == null) {\n            System.out.println(\"Error: CALL instruction not found in \" + startAdd);\n            return;\n        }\n\n        Function connectFunc = FunctionUtil.getFunctionWith(program, pcodeAST.getInputs()[0].getAddress());\n        String funcSig = FunctionUtil.getFunctionSignature(connectFunc);\n\n        Varnode[] varnodes = pcodeAST.getInputs();\n\n        // iterate each parameters in the connect function call", "        for (int i = 0; i < varnodes.length; ++i) {\n            Varnode currentNode = varnodes[i];\n\n            if (i == 1) {\n                // sender\n                signalExp = PCodeUtil.evaluateVarNode(currentNode);\n                String[] classRes = solveClassName(currentNode);\n                signalClass = classRes[0];\n                signalClassType = classRes[1];\n\n            } else if (i == 2) {\n                // sender signal\n                Address signalStrAddr = currentNode.getAddress();\n                String tmp = PCodeUtil.evaluateVarNode(currentNode);\n                signalFunction = StringUtil.getStringFromAddress(program, signalStrAddr);\n                signalFunction = removeSlotFunctionPrefix(signalFunction);\n                // remove parameters", "            } else if (i == 2) {\n                // sender signal\n                Address signalStrAddr = currentNode.getAddress();\n                String tmp = PCodeUtil.evaluateVarNode(currentNode);\n                signalFunction = StringUtil.getStringFromAddress(program, signalStrAddr);\n                signalFunction = removeSlotFunctionPrefix(signalFunction);\n                // remove parameters\n                //if (signalFunction.contains(\"(\"))\n                //    signalFunction = signalFunction.substring(0, signalFunction.indexOf(\"(\"));\n\n                if (signalClass == null)\n                    signalClass = resolveIfOneFunc(signalFunction);\n", "                if (signalClass == null)\n                    signalClass = resolveIfOneFunc(signalFunction);\n\n            } else if (i == 3) {\n                // receiver class instance\n                slotExp = PCodeUtil.evaluateVarNode(currentNode);\n                String[] classRes = solveClassName(currentNode);\n                slotClass = classRes[0];\n                slotClassType = classRes[1];\n\n            } else if (i == 4) {\n                // receiver slot function", "            } else if (i == 4) {\n                // receiver slot function\n                if (currentNode.isConstant()) {\n                    Address slotStrAddr = currentNode.getAddress();\n                    slotFunction = StringUtil.getStringFromAddress(program, slotStrAddr);\n                    slotFunction = removeSlotFunctionPrefix(slotFunction);\n                    // remove parameters\n                    //if (slotFunction.contains(\"(\"))\n                    //    slotFunction = slotFunction.substring(0, slotFunction.indexOf(\"(\"));\n\n                    if (slotClass == null)\n                        slotClass = resolveIfOneFunc(slotFunction);\n                }\n            }\n        }\n        checkSolvedType2();", "                    if (slotClass == null)\n                        slotClass = resolveIfOneFunc(slotFunction);\n                }\n            }\n        }\n        checkSolvedType2();\n        if (allSolved)\n            System.out.println(\"Solved Qt connect: \" + signalFunction + \"\\t\" + slotFunction);\n\n    }\n\n    // ARM solving is slightly different from x86 due to shift of parameters", "    public void solveType2_x86() {\n        Program program = Environment.getProgram();\n\n        // decompile\n        DecompileResults results = Decompiler.decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, startAdd));\n        if (results == null)\n            return;\n\n        highFunction = results.getHighFunction();\n        Iterator<PcodeOpAST> pcodeOpASTIterator = highFunction.getPcodeOps(startAdd);\n\n\n        // analyze the decompiled code at bl connect\n        PcodeOpAST pcodeAST = null;", "        while (pcodeOpASTIterator.hasNext()) {\n            PcodeOpAST tmp = pcodeOpASTIterator.next();\n            if (tmp.getMnemonic().equals(\"CALL\")) {\n                pcodeAST = tmp;\n                break;\n            }\n        }\n        if (pcodeAST == null) {\n            System.out.println(\"Error: CALL instruction not found in \" + startAdd);\n            return;\n        }\n\n        Function connectFunc = FunctionUtil.getFunctionWith(program, pcodeAST.getInputs()[0].getAddress());\n        String funcSig = FunctionUtil.getFunctionSignature(connectFunc);\n\n        Varnode[] varnodes = pcodeAST.getInputs();\n        \n        // iterate each parameters in the connect function call", "        for (int i = 0; i < varnodes.length; ++i) {\n            Varnode currentNode = varnodes[i];\n\n            if (i == 2) {\n                // sender instance\n                if (signalExp == null) {\n                    signalExp = PCodeUtil.evaluateVarNode(currentNode);\n                    String[] classRes = solveClassName(currentNode);\n                    signalClass = classRes[0];\n                    signalClassType = classRes[1];\n                }\n", "            } else if (i == 3) {\n                // signal function\n                Address signalStrAddr = currentNode.getAddress();\n                String tmp = PCodeUtil.evaluateVarNode(currentNode);\n                signalFunction = StringUtil.getStringFromAddress(program, signalStrAddr);\n                signalFunction = removeSlotFunctionPrefix(signalFunction);\n                // remove parameters\n                //if (signalFunction.contains(\"(\"))\n                //    signalFunction = signalFunction.substring(0, signalFunction.indexOf(\"(\"));\n\n                if (signalClass == null)\n                    signalClass = resolveIfOneFunc(signalFunction);\n            }", "                if (signalClass == null)\n                    signalClass = resolveIfOneFunc(signalFunction);\n            }\n            else if (i == 4) {\n                // slot class instance\n                if (slotClass == null) {\n                    slotExp = PCodeUtil.evaluateVarNode(currentNode);\n                    String[] classRes = solveClassName(currentNode);\n                    slotClass = classRes[0];\n                    slotClassType = classRes[1];\n                }\n            }", "            else if (i == 5) {\n                // receiver slot function\n                if (currentNode.isConstant()) {\n                    Address slotStrAddr = currentNode.getAddress();\n                    slotFunction = StringUtil.getStringFromAddress(program, slotStrAddr);\n                    slotFunction = removeSlotFunctionPrefix(slotFunction);\n                    // remove parameters\n                    //if (slotFunction.contains(\"(\"))\n                    //    slotFunction = slotFunction.substring(0, slotFunction.indexOf(\"(\"));\n\n                    if (slotClass == null)\n                        slotClass = resolveIfOneFunc(slotFunction);\n                }\n            }\n        }\n        checkSolvedType2();", "                    if (slotClass == null)\n                        slotClass = resolveIfOneFunc(slotFunction);\n                }\n            }\n        }\n        checkSolvedType2();\n        if (allSolved)\n            System.out.println(\"Solved Qt connect: \" + signalFunction + \"\\t\" + slotFunction);\n    }\n\n    public void solveType1() {\n        Program program = Environment.getProgram();\n\n        // decompile\n        DecompileResults results = Decompiler.decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, startAdd));", "    public void solveType1() {\n        Program program = Environment.getProgram();\n\n        // decompile\n        DecompileResults results = Decompiler.decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, startAdd));\n        if (results == null)\n            return;\n\n        highFunction = results.getHighFunction();\n        Iterator<PcodeOpAST> pcodeOpASTIterator = highFunction.getPcodeOps(startAdd);\n\n\n        // analyze the decompiled code at connect CALL\n        PcodeOpAST pcodeAST = null;", "        while (pcodeOpASTIterator.hasNext()) {\n            PcodeOpAST tmp = pcodeOpASTIterator.next();\n            if (tmp.getMnemonic().equals(\"CALL\")) {\n                pcodeAST = tmp;\n                break;\n            }\n        }\n        if (pcodeAST == null) {\n            System.out.println(\"Error: CALL instruction not found in \" + startAdd);\n            return;\n        }\n\n        Function connectFunc = FunctionUtil.getFunctionWith(program, pcodeAST.getInputs()[0].getAddress());\n        String funcSig = FunctionUtil.getFunctionSignature(connectFunc);\n\n        Varnode[] varnodes = pcodeAST.getInputs();\n", "        if (funcSig.contains(\"connectImpl\")) {\n            if (varnodes.length < 6) {\n                System.out.println(\"Unsupported param length \" + varnodes.length + \" of connectImpl at address: \" + startAdd);\n                return;\n            }\n            // only need to resolve function pointer at 1 and 3. This is shifted to varnode[3] and varnode[5]\n            Varnode signalNode = varnodes[3];\n            Varnode slotNode = varnodes[5];\n\n            if (signalNode.isConstant() && signalNode.getAddress().getUnsignedOffset() == 0) {\n                invalid = true;\n                return;\n            }", "            if (signalNode.isConstant() && signalNode.getAddress().getUnsignedOffset() == 0) {\n                invalid = true;\n                return;\n            }\n            if (slotNode.isConstant() && slotNode.getAddress().getUnsignedOffset() == 0) {\n                invalid = true;\n                return;\n            }\n\n            String signalExp = PCodeUtil.evaluateVarNode(signalNode);\n            String slotExp = PCodeUtil.evaluateVarNode(slotNode);\n\n            // System.out.println(\"\\nSignal: \" + signalExp);\n            // System.out.println(\"Slot: \" + slotExp);\n\n            DecompileResults decompileResults = Decompiler.decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));\n            Iterator<PcodeOpAST> asts = decompileResults.getHighFunction().getPcodeOps();", "            while (asts.hasNext()) {\n                PcodeOpAST ast = asts.next();\n                if (ast.getMnemonic().equals(\"COPY\")) {\n\n                    if (ast.getSeqnum().getTarget().getUnsignedOffset() >= startAdd.getUnsignedOffset())\n                        break; // exit loop when reach the connect statement\n\n                    Varnode[] inputs = ast.getInputs();\n                    Varnode output = ast.getOutput();\n                    String srcExp = PCodeUtil.evaluateVarNode(inputs[0]);\n                    String dstExp = output.toString();\n", "                    if (dstExp.contains(\"(stack\")) {\n                        String constExp = dstExp.replace(\"stack\", \"const\");\n                        if (signalExp.contains(constExp)) {\n                            if (inputs[0].isConstant()) {\n                                Address srcAddr = inputs[0].getAddress();\n                                Function f = program.getFunctionManager().getFunctionAt(program.getAddressFactory().getAddress(NumericUtil.longToHexString(srcAddr.getUnsignedOffset())));\n                                if (f != null)\n                                    signalFunction = f.toString();\n                                else {\n                                    if (srcAddr.getUnsignedOffset() != 0)\n                                        signalFunction = \"FUN_\" + NumericUtil.longToHexString(srcAddr.getUnsignedOffset()).replace(\"0x\", \"\");\n                                }\n                                signalAddress = srcAddr.getUnsignedOffset();\n                                signalClassType = \"funptr\";\n                            }\n                        }", "                                    if (srcAddr.getUnsignedOffset() != 0)\n                                        signalFunction = \"FUN_\" + NumericUtil.longToHexString(srcAddr.getUnsignedOffset()).replace(\"0x\", \"\");\n                                }\n                                signalAddress = srcAddr.getUnsignedOffset();\n                                signalClassType = \"funptr\";\n                            }\n                        }\n                        else if (slotExp.contains(constExp)) {\n                            if (inputs[0].isConstant()) {\n                                Address srcAddr = inputs[0].getAddress();\n                                Function f = program.getFunctionManager().getFunctionAt(program.getAddressFactory().getAddress(NumericUtil.longToHexString(srcAddr.getUnsignedOffset())));", "                            if (inputs[0].isConstant()) {\n                                Address srcAddr = inputs[0].getAddress();\n                                Function f = program.getFunctionManager().getFunctionAt(program.getAddressFactory().getAddress(NumericUtil.longToHexString(srcAddr.getUnsignedOffset())));\n                                if (f != null)\n                                    slotFunction = f.toString();\n                                else {\n                                    if (srcAddr.getUnsignedOffset() != 0)\n                                        slotFunction = \"FUN_\" + NumericUtil.longToHexString(srcAddr.getUnsignedOffset()).replace(\"0x\", \"\");\n                                }\n                                slotAddress = srcAddr.getUnsignedOffset();\n                                slotClassType = \"funptr\";\n                            }\n                        }\n                    }\n                }\n            }\n            \n            checkSolvedType1();", "            if (allSolved)\n                System.out.println(\"Solved Qt connect: \" + signalFunction + \"\\t\" + slotFunction);\n        }\n    }\n\n    private void checkSolvedType1() {\n        if (slotFunction != null && signalFunction != null && signalAddress != -1 && slotAddress != -1) {\n            allSolved = true;\n        }\n    }\n\n    private void checkSolvedType2() {", "        if (slotFunction != null && signalFunction != null && slotClass != null && signalClass != null) {\n            allSolved = true;\n        }\n    }\n\n    public String[] solveClassName (Varnode node) {\n\n        Program program = Environment.getProgram();\n        String className = null;\n        Function currentFunc = FunctionUtil.getFunctionWith(program, startAdd);\n", "        if (node.getDef() == null) {\n            // node has no defs\n\n            // 1. the node is a this pointer\n            if (node.toString().equals(Environment.EXP_R0)) {\n                className = FunctionUtil.getClassFromFuncName(currentFunc.toString());\n                if (className == null) {\n                    // TODO if function name not contain class name\n                    className = currentFunc.getName();\n                }\n                return new String[] {className, \"this\"};\n            }\n            else {\n", "                try {\n                    if (node.isRegister()) {\n                        // 2. the node is a function parameter\n                        for (Parameter param: highFunction.getFunction().getParameters()) {\n                            Varnode paramNode = param.getVariableStorage().getFirstVarnode();\n                            if (paramNode.toString().equals(node.toString())) {\n                                // parameter match\n                                DataType type = param.getDataType();\n                                className = type.getName().replace(\"*\", \"\").strip();\n                                return new String[] {className, \"funcParam\"};\n                            }\n                        }\n                    }\n                    else {", "                        if (node.isConstant()) {\n                            // 3. the node represents a symbol address\n                            Symbol[] syms = program.getSymbolTable().getSymbols(AddressUtil.getAddressFromLong(program, node.getAddress().getUnsignedOffset()));\n                            if (syms.length != 0) {\n                                className = syms[0].getName();\n\n                                return new String[] {className, \"globalObj\"};\n                            }\n                        }\n                    }\n                } catch (NullPointerException e) {\n\n                }\n            }\n        }\n        else {\n\n            // 4. constructor function\n            Iterator<PcodeOp> des = node.getDescendants();", "            while (des.hasNext()) {\n                // iterate to find constructor functions\n                PcodeOp p = des.next();\n                if (p.getMnemonic().equals(\"CALL\")) {\n                    Address callAdd = p.getInputs()[0].getAddress();\n                    Function f = FunctionUtil.getFunctionWith(Environment.getProgram(), callAdd);\n                    if (FunctionUtil.isConstructor(f)) {\n                        className = f.getName();\n                        return new String[] {className, \"headObj\"};\n                    }\n                }\n            }\n\n\n            // continue to trace to definition\n            PcodeOp o = node.getDef();", "            if (o.getMnemonic().equals(\"CALL\")) {\n                // 5. function return value\n                Function callingFunc = FunctionUtil.getFunctionWith(program, o.getInputs()[0].getAddress());\n                if (callingFunc.getThunkedFunction(true) != null)\n                    callingFunc = callingFunc.getThunkedFunction(true);\n                String sig = FunctionUtil.getFunctionSignature(callingFunc);\n                List<Address> funcs = FunctionUtil.locateFunctionWithSig(program, sig, true);\n                for (Address a: funcs) {\n                    Function f = FunctionUtil.getFunctionWith(program, a);\n                    if (f.getName().contains(\"instance\")) {\n                        String cn = FunctionUtil.getClassFromFuncName(FunctionUtil.getFunctionWith(program, this.startAdd).toString());", "                    if (f.getName().contains(\"instance\")) {\n                        String cn = FunctionUtil.getClassFromFuncName(FunctionUtil.getFunctionWith(program, this.startAdd).toString());\n                        if (cn != null) {\n                            return new String[] {cn, \"retVal\"};\n                        }\n                    }\n                    DecompileResults res = Decompiler.decompileFunc(program, f);\n                    try {\n                        String s = res.getDecompiledFunction().getSignature();\n                        String type = s.split(\" \")[0]; // return type\n                        className = type;\n                        return new String[] {className, \"retVal\"};\n                    }\n                    catch (Exception e) {\n                        // external function\n                        DataType type = f.getReturnType();", "                        if (type != null) {\n                            className = type.getName().replace(\"*\", \"\").strip();\n                            return new String[] {className, \"retVal\"};\n                        }\n                    }\n                }\n            }\n            else {\n                // 6. implicit store\n                // remove load\n                String exp = PCodeUtil.evaluateVarNode(node);\n                String targetExp = exp.replace(\"LOAD (const, 0x1a1, 4) \", \"\");\n\n                DecompileResults decompileResults = Decompiler.decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));\n                Iterator<PcodeOpAST> asts = decompileResults.getHighFunction().getPcodeOps();", "                while (asts.hasNext()) {\n                    PcodeOpAST ast = asts.next();\n                    if (ast.getMnemonic().equals(\"STORE\")) {\n                        Varnode[] inputs = ast.getInputs();\n                        //String srcExp = PCodeUtil.evaluateVarNode(inputs[2]);\n                        String dstExp = PCodeUtil.evaluateVarNode(inputs[1]);\n                        if (dstExp.equals(targetExp)) {\n                            Varnode srcNode = inputs[2];\n                            // trace from source node\n                            String cn = solveClassName(srcNode)[0];\n                            if (cn != null) {\n                                className = cn;\n                                return new String[] {className, \"stackObj\"};\n                            }\n                        }\n                    }\n                }\n            }\n\n\n        }\n\n        return new String[] {className, null};\n\n    }\n\n", "                            if (cn != null) {\n                                className = cn;\n                                return new String[] {className, \"stackObj\"};\n                            }\n                        }\n                    }\n                }\n            }\n\n\n        }\n\n        return new String[] {className, null};\n\n    }\n\n", "    public String resolveIfOneFunc(String functionName) {\n        if (functionName == null)\n            return null;\n        List<Address> addrs = FunctionUtil.locateFunctionWithSig(Environment.getProgram(), functionName, false);\n        List<String> classNames = new ArrayList<>();\n        for (Address add: addrs) {\n            Function f = FunctionUtil.getFunctionWith(Environment.getProgram(), add);\n            if (f == null)\n                continue;\n            else {\n                if (f.getThunkedFunction(true) != null)\n                    f = f.getThunkedFunction(true);\n", "                if (f.getThunkedFunction(true) != null)\n                    f = f.getThunkedFunction(true);\n\n                if (f.toString().contains(\"::\")) {\n                    String cName = FunctionUtil.getClassFromFuncName(f.toString());\n                    if (!classNames.contains(cName))\n                        classNames.add(cName);\n                }\n            }\n        }\n", "        if (classNames.size() == 1)\n            return classNames.get(0);\n        return null;\n    }\n\n    public String removeSlotFunctionPrefix(String fun) {\n        if (fun == null)\n            return \"\";\n        if (fun.startsWith(\"1\") || fun.startsWith(\"2\"))\n            return fun.substring(1, fun.length());\n\n        return fun;\n    }\n}\n", "        if (fun.startsWith(\"1\") || fun.startsWith(\"2\"))\n            return fun.substring(1, fun.length());\n\n        return fun;\n    }\n}\n"]}
{"filename": "src/Moc/Node.java", "chunked_list": ["package Moc;\n\npublic abstract class Node {\n\n    int operandNum;\n    boolean isLeaf;\n\n    enum TYPE {\n        REGISTER, CONST\n    }\n\n", "    public static String evaluate(Node node) throws StackOverflowError{\n        if (node.isLeaf)\n            return ((LeafNode) node).value;\n        else {\n            String leftExp = evaluate(((ExpNode) node).left);\n            String rightExp = evaluate(((ExpNode) node).right);\n            String op = ((ExpNode) node).op;\n            return String.format(\"%s %s %s\", op, leftExp, rightExp);\n        }\n    }\n}\n\n"]}
{"filename": "src/Moc/LeafNode.java", "chunked_list": ["package Moc;\n\npublic class LeafNode extends Node {\n\n    public String value;\n    public TYPE type;\n\n    public LeafNode(String val) {\n        operandNum = 1;\n        isLeaf = true;\n        value = val;\n", "        if (val.contains(\"register\"))\n            type = TYPE.REGISTER;\n        else if (val.contains(\"const\"))\n            type = TYPE.CONST;\n    }\n}"]}
{"filename": "src/Moc/ExpNode.java", "chunked_list": ["package Moc;\n\npublic class ExpNode extends Node {\n\n    public String op;\n    public Node left;\n    public Node mid;\n    public Node right;\n\n    public ExpNode (String op, Node l, Node r) {\n        this.op = op;\n        isLeaf = false;\n        switch (op) {\n            case \"LOAD\":\n                operandNum = 2;\n                left = l;\n                right = r;\n                break;\n\n            case \"INT_ADD\":\n                operandNum = 2;\n                left = l;\n                right = r;\n                break;\n\n            default:\n                // TODO implement others if needed\n                operandNum = 2;\n        }\n    }\n\n\n}\n"]}
{"filename": "src/Util/NumericUtil.java", "chunked_list": ["package Util;\n\nimport Main.Environment;\nimport ghidra.util.BigEndianDataConverter;\nimport ghidra.util.LittleEndianDataConverter;\n\nimport java.nio.ByteBuffer;\nimport java.util.*;\nimport java.lang.UnsupportedOperationException;\n\npublic class NumericUtil {\n", "import java.lang.UnsupportedOperationException;\n\npublic class NumericUtil {\n\n    public static String longToHexString(long val) {return String.format(\"0x%X\", val); }\n\n    public static long byteToLongLittleEndian(byte[] data) {\n        if (Environment.LANGUAGE_NAME.contains(\"LE\") && data.length == 4) {\n            long b0 = ((long) data[0]) & 0xFF;\n            long b1 = ((long) data[1] & 0xFF) << 8;\n            long b2 = ((long) data[2] & 0xFF) << 16;\n            long b3 = ((long) data[3] & 0xFF) << 24;\n            long res = b0 + b1 + b2 + b3;\n            return res;\n        }", "        else if (Environment.LANGUAGE_NAME.contains(\"LE\") && data.length == 8){\n            long b0 = ((long) data[0]) & 0xFF;\n            long b1 = ((long) data[1] & 0xFF) << 8;\n            long b2 = ((long) data[2] & 0xFF) << 16;\n            long b3 = ((long) data[3] & 0xFF) << 24;\n            long b4 = ((long) data[4] & 0xFF) << 32;\n            long b5 = ((long) data[5] & 0xFF) << 40;\n            long b6 = ((long) data[6] & 0xFF) << 44;\n            long b7 = ((long) data[7] & 0xFF) << 48;\n            return b0 + b1 + b2 + b3 + b4 + b5 + b6 + b7;\n        }\n        else\n            throw new UnsupportedOperationException();\n    }\n", "    public static byte[] intToBytes(int x, boolean littleEndian) {\n        if (littleEndian) {\n            LittleEndianDataConverter converter = new LittleEndianDataConverter();\n            return converter.getBytes(x);\n        }\n        else {\n            BigEndianDataConverter converter = new BigEndianDataConverter();\n            return converter.getBytes(x);\n        }\n    }\n", "    public static HashMap sortByValues(HashMap map, boolean descendant) {\n        List list = new LinkedList(map.entrySet());\n        // Defined Custom Comparator here\n        if (descendant) {\n            Collections.sort(list, new Comparator() {\n                public int compare(Object o1, Object o2) {\n                    return ((Comparable) ((Map.Entry) (o2)).getValue())\n                            .compareTo(((Map.Entry) (o1)).getValue());\n                }\n            });\n        }\n        else {\n            Collections.sort(list, new Comparator() {", "                public int compare(Object o1, Object o2) {\n                    return ((Comparable) ((Map.Entry) (o1)).getValue())\n                            .compareTo(((Map.Entry) (o2)).getValue());\n                }\n            });\n        }\n\n        // Here I am copying the sorted list in HashMap\n        // using LinkedHashMap to preserve the insertion order\n        HashMap sortedHashMap = new LinkedHashMap();\n        for (Iterator it = list.iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            sortedHashMap.put(entry.getKey(), entry.getValue());\n        }\n        return sortedHashMap;\n    }\n\n}\n", "        for (Iterator it = list.iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            sortedHashMap.put(entry.getKey(), entry.getValue());\n        }\n        return sortedHashMap;\n    }\n\n}\n"]}
{"filename": "src/Util/InstructionUtil.java", "chunked_list": ["package Util;\n\nimport ghidra.program.model.listing.Instruction;\nimport ghidra.program.model.listing.Program;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InstructionUtil {\n\n    /**\n     * Find instruction with pattern\n     * @param pattern e.g., something like \"blx r3\" separated with space. user * to represent arbitrary operand\n     */", "public class InstructionUtil {\n\n    /**\n     * Find instruction with pattern\n     * @param pattern e.g., something like \"blx r3\" separated with space. user * to represent arbitrary operand\n     */\n    public static List<Instruction> findInstruction(Program program, String pattern) {\n        List<Instruction> results = new ArrayList<>();\n\n        // parse pattern\n        String[] tokens = pattern.split(\" \");\n        int length = tokens.length;\n\n        String opCode = \"\";\n        List<String> operands = new ArrayList<>();\n", "        for (int i=0; i<length; ++i) {\n            if (i == 0)\n                opCode = tokens[i];\n            else\n                operands.add(tokens[i]);\n        }\n\n        if (opCode.equals(\" \"))\n            return results;\n\n\n        // find instructions", "        for (Instruction ins: program.getListing().getInstructions(true)) {\n            String mnem = ins.getMnemonicString();\n            if (mnem.equals(opCode)) {\n                int operandNum = ins.getNumOperands();\n                if (operandNum != operands.size())\n                    continue;\n\n                boolean tmpFlag = true;\n                for (int i=0; i<operandNum; ++i) {\n                    if (operands.get(i).equals(\"*\"))  // don't check *\n                        continue;\n                    else {\n                        String opName = ins.getOpObjects(i)[0].toString();", "                for (int i=0; i<operandNum; ++i) {\n                    if (operands.get(i).equals(\"*\"))  // don't check *\n                        continue;\n                    else {\n                        String opName = ins.getOpObjects(i)[0].toString();\n                        if (!operands.get(i).equals(opName))\n                            tmpFlag = false;\n                    }\n                }\n                if (tmpFlag)\n                    results.add(ins);\n            }\n        }\n\n\n        return results;\n    }\n}\n", "                if (tmpFlag)\n                    results.add(ins);\n            }\n        }\n\n\n        return results;\n    }\n}\n"]}
{"filename": "src/Util/BlockUtil.java", "chunked_list": ["package Util;\n\nimport ghidra.app.services.ProgramManager;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.block.BasicBlockModel;\nimport ghidra.program.model.block.CodeBlock;\nimport ghidra.program.model.block.CodeBlockReference;\nimport ghidra.program.model.block.CodeBlockReferenceIterator;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.mem.MemoryBlock;", "import ghidra.program.model.listing.Program;\nimport ghidra.program.model.mem.MemoryBlock;\nimport ghidra.util.exception.CancelledException;\nimport ghidra.util.task.TaskMonitor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BlockUtil {\n\n    public static MemoryBlock external = null;", "public class BlockUtil {\n\n    public static MemoryBlock external = null;\n    public static MemoryBlock plt = null;\n\n    public static CodeBlock[] locateBlockWithAddress(Program program, Address address) {\n        BasicBlockModel basicBlockModel = new BasicBlockModel(program);\n        try {\n            CodeBlock[] codeBlocks = basicBlockModel.getCodeBlocksContaining(address, TaskMonitor.DUMMY);\n            return codeBlocks;\n        } catch (CancelledException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get parent blocks of the current block\n     */", "    public static List<CodeBlockReference> getPreviousBlocks(CodeBlock codeBlock) {\n        List<CodeBlockReference> result = new ArrayList<>();\n        try {\n            CodeBlockReferenceIterator codeBlockReferenceSourcesIterator = codeBlock.getSources(TaskMonitor.DUMMY);\n            while (codeBlockReferenceSourcesIterator.hasNext()) {\n                CodeBlockReference codeBlockReference = codeBlockReferenceSourcesIterator.next();\n                // CodeBlock codeBlockSource = codeBlockReference.getSourceBlock();\n                result.add(codeBlockReference);\n            }\n            return result;\n        } catch (CancelledException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get descendent blocks of the current block\n     */", "    public static List<CodeBlockReference> getDescentdentBlocks(CodeBlock codeBlock) {\n        List<CodeBlockReference> result = new ArrayList<>();\n        try {\n            CodeBlockReferenceIterator codeBlockReferenceDestsIterator = codeBlock.getDestinations(TaskMonitor.DUMMY);\n            while (codeBlockReferenceDestsIterator.hasNext()) {\n                CodeBlockReference codeBlockReference = codeBlockReferenceDestsIterator.next();\n                // CodeBlock codeBlockDest = codeBlockReference.getDestinationBlock();\n                result.add(codeBlockReference);\n            }\n            return result;\n        } catch (CancelledException e) {\n            return null;\n        }\n    }\n", "    public static boolean isExternalBlock(Program program, CodeBlock block) {\n\n        if (external == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {\n                if (b.getName().equals(\"EXTERNAL\")) {\n                    external = b;\n                    break;\n                }\n            }\n        }\n\n        Address add = block.getFirstStartAddress();\n", "        if (add.toString().equals(\"ffff0fc0\")) // special case\n            return true;\n\n        return external.contains(add);\n    }\n\n    public static boolean isExternalAddress(Program program, Address address) {\n\n        if (external == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {", "        if (external == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {\n                if (b.getName().equals(\"EXTERNAL\")) {\n                    external = b;\n                    break;\n                }\n            }\n        }\n\n        if (address.toString().equals(\"ffff0fc0\")) // special case\n            return true;\n\n        return external.contains(address);\n    }\n\n", "        if (address.toString().equals(\"ffff0fc0\")) // special case\n            return true;\n\n        return external.contains(address);\n    }\n\n\n    public static boolean isPltBlock(Program program, CodeBlock block) {\n        if (plt == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {", "        if (plt == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {\n                if (b.getName().equals(\".plt\")) {\n                    plt = b;\n                    break;\n                }\n            }\n        }\n\n        Address add = block.getFirstStartAddress();\n        return plt.contains(add);\n    }\n\n", "    public static boolean isPltAddress(Program program, Address address) {\n        if (plt == null) {\n            MemoryBlock[] blocks = program.getMemory().getBlocks();\n            for (MemoryBlock b : blocks) {\n                if (b.getName().equals(\".PLT\")) {\n                    plt = b;\n                    break;\n                }\n            }\n        }\n\n        return plt.contains(address);\n    }\n}\n"]}
{"filename": "src/Util/PCodeUtil.java", "chunked_list": ["package Util;\n\nimport Main.Environment;\nimport ghidra.program.model.pcode.PcodeOp;\nimport ghidra.program.model.pcode.Varnode;\n\npublic class PCodeUtil {\n\n\n    public static String evaluateVarNode(Varnode node) {\n        if (node == null)\n            return null;", "    public static String evaluateVarNode(Varnode node) {\n        if (node == null)\n            return null;\n        try {\n            Environment.PCODE_INS_COUNT += 1;\n            return evaluate(node, new StringBuilder()).toString();\n        } catch (StackOverflowError | OutOfMemoryError e) {\n            return node.toString().trim();\n        }\n    }\n\n    private static StringBuilder evaluate(Varnode node, StringBuilder expression) throws StackOverflowError, OutOfMemoryError{\n        PcodeOp defNode = node.getDef();\n", "        if (defNode == null) {\n            // base case\n            return new StringBuilder(node.toString().trim());\n        }\n\n\n        String mnem = defNode.getMnemonic();\n        Varnode[] inputs = defNode.getInputs();\n\n        switch (mnem) {\n            case \"CAST\":\n            case \"COPY\":\n                // ignore mnem", "                for (Varnode input: inputs) {\n                    StringBuilder newExp = evaluate(input, new StringBuilder(\"\"));\n                    expression.append(newExp);\n                    expression.append(\" \");\n                }\n                return new StringBuilder(expression.toString().trim());\n\n            case \"INDIRECT\":\n                // continue to evaluate the first node\n                return new StringBuilder(evaluate(inputs[0], new StringBuilder()));\n\n            case \"MULTIEQUAL\":\n                // select a non-zero input and evaluate it\n                Varnode zeroNode = null;", "                for (Varnode input: inputs) {\n                    if (!(input.isConstant() && input.getAddress().getUnsignedOffset() == 0)) {\n                        return new StringBuilder(evaluate(input, new StringBuilder()));\n                    }\n                    else {\n                        zeroNode = input;\n                    }\n                }\n                if (zeroNode != null)\n                    return new StringBuilder(zeroNode.toString());\n                else\n                    return new StringBuilder();\n\n\n            default:\n                expression.append(defNode.getMnemonic());\n                expression.append(\" \");\n                // append operands", "                if (zeroNode != null)\n                    return new StringBuilder(zeroNode.toString());\n                else\n                    return new StringBuilder();\n\n\n            default:\n                expression.append(defNode.getMnemonic());\n                expression.append(\" \");\n                // append operands\n                for (Varnode input: inputs) {\n                    StringBuilder newExp = evaluate(input, new StringBuilder(\"\"));\n                    expression.append(newExp);\n                    expression.append(\" \");\n                }\n\n                return new StringBuilder(expression.toString().trim());\n        }\n\n    }\n", "                for (Varnode input: inputs) {\n                    StringBuilder newExp = evaluate(input, new StringBuilder(\"\"));\n                    expression.append(newExp);\n                    expression.append(\" \");\n                }\n\n                return new StringBuilder(expression.toString().trim());\n        }\n\n    }\n", "    public static boolean isVarNodeExpEqual(Varnode node, String exp) {\n        return evaluateVarNode(node).equals(exp);\n    }\n}\n"]}
{"filename": "src/Util/AddressUtil.java", "chunked_list": ["package Util;\n\nimport Main.Decompiler;\nimport Main.Environment;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.listing.Instruction;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.pcode.HighFunction;", "import ghidra.program.model.listing.Program;\nimport ghidra.program.model.pcode.HighFunction;\nimport ghidra.program.model.pcode.PcodeOpAST;\nimport ghidra.program.model.pcode.Varnode;\nimport ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceIterator;\nimport ghidra.util.BigEndianDataConverter;\nimport ghidra.util.LittleEndianDataConverter;\n\nimport java.util.Iterator;", "\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class AddressUtil {\n\n    public static Address getAddressFromLong(Program program, long val) {\n        return program.getAddressFactory().getAddress(NumericUtil.longToHexString(val));\n    }\n\n    public static ReferenceIterator getReferenceToAddress(Program program, Address address) {\n        ReferenceIterator iterator = program.getReferenceManager().getReferencesTo(address);\n        return iterator;\n    }\n", "    public static ReferenceIterator getReferenceToAddress(Program program, Address address) {\n        ReferenceIterator iterator = program.getReferenceManager().getReferencesTo(address);\n        return iterator;\n    }\n\n    public static int getReferenceCount(Program program, Address address) {\n        return program.getReferenceManager().getReferenceCountTo(address);\n    }\n\n    public static Address findConnectionAddress(Program program, Address address, List<Address> allConnectAdd) {\n        Function currentFunc = FunctionUtil.getFunctionWith(program, address);", "    public static Address findConnectionAddress(Program program, Address address, List<Address> allConnectAdd) {\n        Function currentFunc = FunctionUtil.getFunctionWith(program, address);\n        if (currentFunc == null)\n            return null;\n        DecompileResults results = Decompiler.decompileFuncRegister(program, currentFunc);\n        if (results == null)\n            return null;\n        HighFunction highFunction = results.getHighFunction();\n        Address current = address;\n        while(current.next() != null) {\n            Iterator<PcodeOpAST> pcodeOpASTIterator = highFunction.getPcodeOps(current);", "        while(current.next() != null) {\n            Iterator<PcodeOpAST> pcodeOpASTIterator = highFunction.getPcodeOps(current);\n            while (pcodeOpASTIterator.hasNext()) {\n                PcodeOpAST ast = pcodeOpASTIterator.next();\n                String mnem = ast.getMnemonic();\n                if (mnem.equals(\"CALL\")) {\n                    Varnode inputNode = ast.getInputs()[0];\n                    Address callAdd = inputNode.getAddress();\n                    if (allConnectAdd.contains(callAdd))\n                        return current;\n                }\n            }\n            current = current.next();", "                    if (allConnectAdd.contains(callAdd))\n                        return current;\n                }\n            }\n            current = current.next();\n            if (currentFunc.getBody().getMaxAddress().getUnsignedOffset() <= current.getUnsignedOffset())\n                return null;\n        }\n        return null;\n    }\n", "    public static Address getAddressInNextIns(Program program, Address current) {\n        Instruction currentIns = program.getListing().getInstructionAt(current);\n        Address next = current;\n        Instruction nextIns = null;\n        do {\n            next = next.next();\n            nextIns = program.getListing().getInstructionAt(next);\n        } while (nextIns == null);\n\n        return next;\n    }\n\n}\n"]}
{"filename": "src/Util/StringUtil.java", "chunked_list": ["package Util;\n\nimport Constant.Configs;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.address.AddressSetView;\nimport ghidra.program.model.data.StringDataType;\nimport ghidra.program.model.listing.Data;\nimport ghidra.program.model.listing.DataIterator;\nimport ghidra.program.model.listing.GhidraClass;\nimport ghidra.program.model.listing.Program;", "import ghidra.program.model.listing.GhidraClass;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.mem.MemoryAccessException;\nimport ghidra.program.model.symbol.Namespace;\nimport ghidra.program.model.symbol.Symbol;\nimport ghidra.program.model.symbol.SymbolTable;\nimport ghidra.program.util.string.FoundString;\nimport ghidra.program.util.string.FoundStringCallback;\nimport ghidra.program.util.string.StringSearcher;\nimport ghidra.util.task.TimeoutTaskMonitor;", "import ghidra.program.util.string.StringSearcher;\nimport ghidra.util.task.TimeoutTaskMonitor;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class StringUtil {\n\n    public static List<Address> getRefToString(Program program, String str) {\n        List<Address> results = new ArrayList<>();\n\n        DataIterator dataIterator = program.getListing().getDefinedData(true);", "public class StringUtil {\n\n    public static List<Address> getRefToString(Program program, String str) {\n        List<Address> results = new ArrayList<>();\n\n        DataIterator dataIterator = program.getListing().getDefinedData(true);\n        while (dataIterator.hasNext()) {\n            Data data = dataIterator.next();\n            if (data.getDataType().toString().equals(\"string\")) {\n                if (data.toString().contains(str)) {\n                    results.add(data.getAddress());\n                }\n            }\n        }\n\n        return results;\n    }\n", "            if (data.getDataType().toString().equals(\"string\")) {\n                if (data.toString().contains(str)) {\n                    results.add(data.getAddress());\n                }\n            }\n        }\n\n        return results;\n    }\n\n    public static String getStringFromAddress(Program program, Address address) {\n\n        String addrStr = NumericUtil.longToHexString(address.getUnsignedOffset());\n        Data data = program.getListing().getDataAt(program.getAddressFactory().getAddress(addrStr));", "    public static String getStringFromAddress(Program program, Address address) {\n\n        String addrStr = NumericUtil.longToHexString(address.getUnsignedOffset());\n        Data data = program.getListing().getDataAt(program.getAddressFactory().getAddress(addrStr));\n        if (data == null)\n            return null;\n\n        if (data.getDataType() instanceof StringDataType) {\n            return data.getValue().toString();\n        }\n\n        return data.toString();\n    }\n", "    public static List<FoundString> findStrings(Program program, AddressSetView addressSet, int minimumStringLength,\n                                         int alignment, boolean requireNullTermination, boolean includeAllCharWidths) {\n\n        final List<FoundString> list = new ArrayList<>();\n        FoundStringCallback foundStringCallback = foundString -> list.add(foundString);\n\n        StringSearcher searcher = new StringSearcher(program, minimumStringLength, alignment,\n                includeAllCharWidths, requireNullTermination);\n\n        searcher.search(addressSet, foundStringCallback, true, TimeoutTaskMonitor.timeoutIn(Configs.DISASSEMBLE_TIMEOUT, TimeUnit.SECONDS));\n\n        return list;\n    }\n", "    public static List<String> getAllClassNames(Program program) {\n        List<String> classNames = new ArrayList<>();\n        SymbolTable symbolTable = program.getSymbolTable();\n        Iterator<GhidraClass> igc = symbolTable.getClassNamespaces();\n        while (igc.hasNext()) {\n            GhidraClass c = igc.next();\n            String className = c.getName();\n            if (!classNames.contains(className))\n                classNames.add(className);\n        }\n\n        return classNames;\n    }\n\n", "    public static int countCharInStr(String s, char c) {\n        int cnt = 0;\n        for (int i=0; i<s.length(); ++i) {\n            if (s.charAt(i) == c)\n                cnt++;\n        }\n\n        return cnt;\n    }\n\n    public static boolean isRegisterExp(String s) {", "    public static boolean isRegisterExp(String s) {\n        if (s.contains(\"(register,\") && countCharInStr(s, '(') == 1)\n            return true;\n\n        return false;\n    }\n\n    public static boolean isInterExp(String s) {\n        if (s.contains(\"(unique,\") && countCharInStr(s, '(') == 1)\n            return true;\n\n        return false;\n    }\n}\n", "        if (s.contains(\"(unique,\") && countCharInStr(s, '(') == 1)\n            return true;\n\n        return false;\n    }\n}\n"]}
{"filename": "src/Util/FileUtil.java", "chunked_list": ["package Util;\n\nimport Constant.Constants;\nimport Main.Environment;\nimport ghidra.program.model.listing.Function;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;", "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class FileUtil {\n    public static void writeToFile(String path, String content, boolean append) {\n        try {\n            PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(path, append)));\n            if (!append && content.equals(\"\")) {\n                out.print(content);\n            }\n            else {\n                out.println(content);\n            }\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n", "            if (!append && content.equals(\"\")) {\n                out.print(content);\n            }\n            else {\n                out.println(content);\n            }\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n", "    public static void writeListToFile(String path, List<?> list, boolean append) {\n        try {\n            PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(path, append)));\n            for (int i=0; i<list.size(); ++i)\n                out.println(list.get(i).toString());\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "    public static boolean isResultExist(String name) {\n        File file = new File(Environment.CONNECT_DIR);\n        String[] files = file.list();\n        if (files == null)\n            return false;\n\n        for (String fname : files) {\n            if (fname.contains(name))\n                return true;\n        }\n\n        file = new File(Environment.META_DIR);\n        files = file.list();", "        if (files == null)\n            return false;\n\n        for (String fname : files) {\n            if (fname.contains(name))\n                return true;\n        }\n\n        return false;\n    }\n", "    public static List<String> readListFromFile(String fileName) {\n        BufferedReader reader;\n        List<String> results = new ArrayList<>();\n        try {\n            reader = new BufferedReader(new FileReader(fileName));\n            String line = reader.readLine();\n            while (line != null) {\n                results.add(line.replace(\"\\n\", \"\"));\n                line = reader.readLine();\n            }\n            reader.close();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        return results;\n    }\n\n", "    public static String readFromFile(String path) throws FileNotFoundException {\n        InputStream is = new FileInputStream(path);\n        try {\n            return IOUtils.toString(is, \"UTF-8\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n", "    public static File[] listFilesForFolder(String dir) {\n        File folder = new File(dir);\n        return folder.listFiles();\n    }\n\n    public static boolean fileContainsString(File file, String str) {\n        try {\n            Scanner scanner = new Scanner(file);\n            while (scanner.hasNextLine()) {\n                if (scanner.nextLine().contains(str)) {\n                    return true;\n                }\n            }\n            scanner.close();\n        }\n        catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n}\n", "            while (scanner.hasNextLine()) {\n                if (scanner.nextLine().contains(str)) {\n                    return true;\n                }\n            }\n            scanner.close();\n        }\n        catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n}\n"]}
{"filename": "src/Util/FunctionUtil.java", "chunked_list": ["package Util;\n\nimport Constant.Configs;\nimport Constant.Constants;\nimport Main.Environment;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.mem.MemoryBlock;\nimport ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceManager;", "import ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceManager;\nimport ghidra.util.task.TimeoutTaskMonitor;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\npublic class FunctionUtil {\n\n", "\npublic class FunctionUtil {\n\n\n    public static List<Function> getAllFunctions(Program program) {\n        // load all function if not done\n        FunctionIterator funcIt = program.getFunctionManager().getFunctions(true);\n        List<Function> functions = new ArrayList<>();\n\n        for (Function extfun : funcIt) {\n            functions.add(extfun);\n        }\n\n        return functions;\n    }\n", "        for (Function extfun : funcIt) {\n            functions.add(extfun);\n        }\n\n        return functions;\n    }\n\n    public static String getClassFromFuncName(String name) {\n        name = name.replace(\"<EXTERNAL>::\", \"\");\n        if (name.contains(\"::\")) {\n            String[] tokens = name.split(\"::\");\n            int lastIndex = tokens.length - 1;\n            return tokens[lastIndex - 1];\n        }\n        else\n            return null;\n    }\n", "        if (name.contains(\"::\")) {\n            String[] tokens = name.split(\"::\");\n            int lastIndex = tokens.length - 1;\n            return tokens[lastIndex - 1];\n        }\n        else\n            return null;\n    }\n\n    public static Function getFunctionWithName(Program program, String funcName) {\n\n        // remove parameters", "    public static Function getFunctionWithName(Program program, String funcName) {\n\n        // remove parameters\n        if (funcName.contains(\"(\"))\n            funcName = funcName.substring(0, funcName.indexOf(\"(\"));\n\n        for (Function function: getAllFunctions(program)) {\n            if (function.toString().equals(funcName))\n                return function;\n        }\n\n        return null;\n    }\n", "    public static List<Function> getAllExternalFunctions(Program program) {\n\n        MemoryBlock[] blocks = program.getMemory().getBlocks();\n        MemoryBlock external = null;\n        for (MemoryBlock block : blocks) {\n            if (block.getName().equals(\"EXTERNAL\")) {\n                external = block;\n                break;\n            }\n        }\n\n        List<Function> externalFunc = new ArrayList<>();\n", "        if (external == null)\n            return externalFunc;\n\n\n        for (Function fun: program.getFunctionManager().getFunctions(true)) {\n            if (external.contains(fun.getEntryPoint()))\n                externalFunc.add(fun);\n        }\n\n        /*\n        FunctionIterator externalFuncIt = program.getFunctionManager().getExternalFunctions();\n", "        for (Function extfun: externalFuncIt) {\n            externalFunc.add(extfun);\n        }*/\n\n        return externalFunc;\n    }\n\n\n    public static String getFunctionSignature(Function f) {\n        StringBuilder signature = new StringBuilder();\n        String name = f.toString();\n        String returnType = f.getReturnType().toString();\n        StringBuilder params = new StringBuilder();\n", "    public static String getFunctionSignature(Function f) {\n        StringBuilder signature = new StringBuilder();\n        String name = f.toString();\n        String returnType = f.getReturnType().toString();\n        StringBuilder params = new StringBuilder();\n\n        for (Parameter p: f.getParameters()) {\n            if (p.getDataType().toString().contains(\"\\n\")) {\n                // special case\n                try {\n                    params.append(p.toString().split(\" \")[0].substring(1));\n                    params.append(\"*\");\n                } catch (Exception e) {\n\n                }\n            }\n            else {\n                params.append(p.getDataType().toString().replace(\" \", \"\"));\n            }\n            params.append(\",\");\n\n        }\n", "                try {\n                    params.append(p.toString().split(\" \")[0].substring(1));\n                    params.append(\"*\");\n                } catch (Exception e) {\n\n                }\n            }\n            else {\n                params.append(p.getDataType().toString().replace(\" \", \"\"));\n            }\n            params.append(\",\");\n\n        }\n", "        if (params.length() > 0)\n            params.deleteCharAt(params.length()-1); // remove the last comma\n\n        // signature.append(returnType);\n        // signature.append(\" \");\n        name = name.replace(\"<EXTERNAL>::\", \"\");\n        name = name.replace(\"\\n\", \"\");\n        signature.append(name);\n        signature.append(\"(\");\n        signature.append(params);\n        signature.append(\")\");\n\n        return signature.toString();\n    }\n\n", "    public static Function getFunctionWith(Program program, Address address) {\n        return program.getFunctionManager().getFunctionContaining(address);\n    }\n\n    public static Set<Function> getCallingFunction(Function function) {\n        try {\n            return function.getCallingFunctions(TimeoutTaskMonitor.timeoutIn(500, TimeUnit.SECONDS));\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n", "    public static Set<Function> getCalledFunction(Function function) {\n        try {\n            return function.getCalledFunctions(TimeoutTaskMonitor.timeoutIn(500, TimeUnit.SECONDS));\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    public static List<Address> getConnectAddress(Program program) {\n        List<Address> results = new ArrayList<>();\n        for (Function f: program.getFunctionManager().getFunctions(true)) {\n            String funcName = FunctionUtil.getFunctionSignature(f);", "    public static List<Address> getConnectAddress(Program program) {\n        List<Address> results = new ArrayList<>();\n        for (Function f: program.getFunctionManager().getFunctions(true)) {\n            String funcName = FunctionUtil.getFunctionSignature(f);\n            if (funcName.startsWith(\"connect(\") || funcName.startsWith(\"connect<\") ||\n                funcName.startsWith(\"QObject::connect(\") || funcName.startsWith(\"QObject::connect<\") ||\n                funcName.startsWith(\"connectImpl(\")) {\n                if (!results.contains(f.getEntryPoint())) {\n                    results.add(f.getEntryPoint());\n                }\n            }\n        }\n        return results;\n    }\n", "    public static List<Address> locateFunctionWithSig(Program program, String signature, boolean exactlyEqual) {\n        List<Address> results = new ArrayList<>();\n        for (Function f: program.getFunctionManager().getFunctions(true)) {\n            Function thunkedFunc = f.getThunkedFunction(true);\n            if (thunkedFunc != null)\n                f = thunkedFunc;\n            if (exactlyEqual) {\n                if (getFunctionSignature(f).equals(signature) || (thunkedFunc != null && getFunctionSignature(thunkedFunc).equals(signature))) {\n                    if (!results.contains(f.getEntryPoint()))\n                        results.add(f.getEntryPoint());\n                }\n            }\n            else {", "                    if (!results.contains(f.getEntryPoint()))\n                        results.add(f.getEntryPoint());\n                }\n            }\n            else {\n                if (getFunctionSignature(f).contains(signature) || (thunkedFunc != null && getFunctionSignature(thunkedFunc).contains(signature))) {\n                    if (!results.contains(f.getEntryPoint()))\n                        results.add(f.getEntryPoint());\n                }\n            }\n        }\n\n        return results;\n    }\n", "    public static List<Function> getFunctionWithoutCaller(Program program) {\n        List<Function> results = new ArrayList<>();\n        for (Function f: program.getFunctionManager().getFunctions(true)) {\n            try {\n                if (f.getCallingFunctions(TimeoutTaskMonitor.timeoutIn(500, TimeUnit.SECONDS)).size() == 0)\n                    results.add(f);\n            }\n            catch (NullPointerException e) {\n                results.add(f);\n            }\n        }\n        return results;\n    }\n", "    public static void recursiveGetCalledFunc(Function function, Set<Function> res) {\n\n        String className = function.toString().split(\"::\")[0];\n\n        if (function == null)\n            return;\n\n        Set<Function> callingFunc = function.getCalledFunctions(TimeoutTaskMonitor.timeoutIn(Configs.DISASSEMBLE_TIMEOUT, TimeUnit.SECONDS));\n\n        if (callingFunc == null)\n            return;\n", "        if (callingFunc == null)\n            return;\n\n        for (Function des: callingFunc) {\n            if (des.toString().contains(\"::\")) {\n                if (des.toString().split(\"::\")[0].equals(className)) {\n                    // class name match\n                    res.add(des);\n                    recursiveGetCalledFunc(des, res);\n                }\n            }", "            else if (des.getThunkedFunction(true) != null && des.getThunkedFunction(true).toString().contains(\"::\")\n                    && des.getThunkedFunction(true).toString().split(\"::\")[0].equals(className)) {\n                // class name of thunked function match\n                res.add(des.getThunkedFunction(true));\n                recursiveGetCalledFunc(des.getThunkedFunction(true), res);\n            }\n        }\n    }\n\n\n    public static boolean isConstructor(Function func) {", "    public static boolean isConstructor(Function func) {\n        if (func == null)\n            return false;\n\n        if (!func.toString().contains(\"::\")) {\n            if (func.getThunkedFunction(true) != null) {\n                func = func.getThunkedFunction(true); // handle thunked function\n                if (!func.toString().contains(\"::\"))\n                    return false;\n            }\n            else\n                return false;\n        }\n\n        String[] tokens = func.toString().split(\"::\");\n        int lastIndex = tokens.length - 1;\n        int lastButTwo = lastIndex - 1;\n\n        return tokens[lastIndex].equals(tokens[lastButTwo]);\n\n        /*", "        if (tokens.length == 2 && tokens[0].equals(tokens[1]) ||\n                (tokens.length == 3 && tokens[1].equals(tokens[2]))) {\n            return true;\n        }\n        return false;*/\n    }\n\n\n    public static Function getParentConstructor(Program program, Function func) {\n        ReferenceManager referenceManager = program.getReferenceManager();\n", "    public static Function getParentConstructor(Program program, Function func) {\n        ReferenceManager referenceManager = program.getReferenceManager();\n\n        for (Address add: func.getBody().getAddresses(true)) {\n            Reference[] references = referenceManager.getReferencesFrom(add);\n            for (Reference ref: references) {\n                Function targetFunc = program.getFunctionManager().getFunctionAt(ref.getToAddress());\n                if (targetFunc != null) {\n                    if (FunctionUtil.isConstructor(targetFunc)) {\n                        // return the first constructor that gets called\n                        if (targetFunc.getThunkedFunction(true) != null)\n                            return targetFunc.getThunkedFunction(true);\n                        else\n                            return targetFunc;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n", "                    if (FunctionUtil.isConstructor(targetFunc)) {\n                        // return the first constructor that gets called\n                        if (targetFunc.getThunkedFunction(true) != null)\n                            return targetFunc.getThunkedFunction(true);\n                        else\n                            return targetFunc;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n", "    public static boolean isSignalFunction(Function function) {\n        Set<Function> calledFunc = function.getCalledFunctions(TimeoutTaskMonitor.timeoutIn(Configs.DISASSEMBLE_TIMEOUT, TimeUnit.SECONDS));\n        for (Function f: calledFunc) {\n            String sig = getFunctionSignature(f);\n            if (sig.equals(Constants.ACTIVATE))\n                return true;\n        }\n        return false;\n    }\n}\n"]}
{"filename": "src/Main/Environment.java", "chunked_list": ["package Main;\n\nimport ghidra.base.project.GhidraProject;\nimport ghidra.program.model.listing.Program;\n\n// Global environment to store program information\npublic class Environment {\n\n    public static Program program;\n\n    public static String tag;\n", "    public static Program program;\n\n    public static String tag;\n\n    public static GhidraProject project;\n\n    public static String LANGUAGE_NAME; // https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors\n\n    // For ARM binaries, use default compiler spec\n    // For x86 binaries, use gcc compiler spec\n    public static String COMPILER_SPEC; // https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/CompilerSpecID.html\n", "    public static String COMPILER_SPEC; // https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/CompilerSpecID.html\n\n    public static String BINARY_FILE_LIST;\n\n    public static int POINTER_SIZE;\n\n    // File location\n    public static String OUTPUT_DIR;\n    public static String META_DIR;\n    public static String CONNECT_DIR;\n\n    // registers", "    public static String META_DIR;\n    public static String CONNECT_DIR;\n\n    // registers\n    public static String EXP_R0 = \"(register, 0x20, 4)\";\n    public static String EXP_R1 = \"(register, 0x24, 4)\";\n    public static String EXP_R2 = \"(register, 0x28, 4)\";\n    public static String EXP_R3 = \"(register, 0x2c, 4)\";\n    public static String EXP_R4 = \"(stack, 0x0, 4)\";\n    public static String EXP_R5 = \"(stack, 0x4, 4)\";\n", "    public static String EXP_R4 = \"(stack, 0x0, 4)\";\n    public static String EXP_R5 = \"(stack, 0x4, 4)\";\n\n    public static String RETURN_REG = \"r0\";\n\n\n    // global stats\n    public static int PCODE_INS_COUNT = 0;\n\n\n    // initProgram must be called before analysis!!", "    public static void initProgram(Program p) {\n        program = p;\n    }\n\n    public static void initTag(String s) {\n        tag = s;\n    }\n\n    public static void initProject(GhidraProject p) {\n        project = p;\n    }\n", "    public static void initProject(GhidraProject p) {\n        project = p;\n    }\n\n    public static Program getProgram() {\n        return program;\n    }\n\n    public static String getTag() {\n        return tag;\n    }\n", "    public static String getTag() {\n        return tag;\n    }\n\n    public static GhidraProject getProject() {\n        return project;\n    }\n}\n"]}
{"filename": "src/Main/Main.java", "chunked_list": ["package Main;\n\nimport Constant.Configs;\nimport Constant.Constants;\nimport Util.FileUtil;\nimport ghidra.GhidraJarApplicationLayout;\nimport ghidra.base.project.GhidraProject;\nimport ghidra.framework.Application;\nimport ghidra.framework.ApplicationConfiguration;\nimport ghidra.framework.HeadlessGhidraApplicationConfiguration;", "import ghidra.framework.ApplicationConfiguration;\nimport ghidra.framework.HeadlessGhidraApplicationConfiguration;\nimport ghidra.util.InvalidNameException;\nimport ghidra.util.exception.CancelledException;\nimport ghidra.util.exception.DuplicateNameException;\nimport ghidra.util.exception.VersionException;\nimport org.json.JSONObject;\n\nimport java.io.*;\nimport java.util.ArrayList;", "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.lang.UnsupportedOperationException;\n\npublic class Main {\n\n    private static long startTime;\n    private static long endTime;\n\n    /**\n     * args[0]: path to json config file\n     * args[1]: enable Qt connect analysis\n     * args[2]: enable Qt meta analysis\n     */", "    public static void main(String[] args) throws\n            IOException, VersionException, CancelledException, DuplicateNameException, InvalidNameException {\n        \n        if (args.length < 1) {\n            System.out.println(\"You must provde a config json file as argument. See env.json for details.\");\n            return;\n        }\n\n        String configFile = args[0];\n\n        // runtime config", "        if (args.length >= 2)\n            Configs.ANALYZE_CONNECT = (args[1].equals(\"1\"));\n        else\n            Configs.ANALYZE_CONNECT = true; // enabled by default\n\n        if (args.length >= 3)\n            Configs.ANALYZE_META = (args[2].equals(\"1\"));\n        else\n            Configs.ANALYZE_META = true; // enabled by default\n\n        if (!loadConfig(configFile)) {\n            System.out.println(\"Unable to load config from env.json\");\n            return;\n        }\n\n        // startTime = System.currentTimeMillis();\n\n        // Define Ghidra components\n        String projectDirectoryName = Constants.DIRECTORY_NAME;\n\n        GhidraProject ghidraProject;\n\n        // Initialize application", "        if (!loadConfig(configFile)) {\n            System.out.println(\"Unable to load config from env.json\");\n            return;\n        }\n\n        // startTime = System.currentTimeMillis();\n\n        // Define Ghidra components\n        String projectDirectoryName = Constants.DIRECTORY_NAME;\n\n        GhidraProject ghidraProject;\n\n        // Initialize application", "        if (!Application.isInitialized()) {\n            ApplicationConfiguration configuration = new HeadlessGhidraApplicationConfiguration();\n            configuration.setInitializeLogging(false);\n            Application.initializeApplication(new GhidraJarApplicationLayout(), configuration);\n        }\n\n        // Create a Ghidra project\n        String projectName = Constants.PROJECT_NAME;\n        try {\n            ghidraProject = GhidraProject.openProject(projectDirectoryName, projectName);\n        }\n        catch (IOException e) {\n            // create a new project if not exist\n            // throw e;\n            ghidraProject = GhidraProject.createProject(projectDirectoryName, projectName, false);\n        }\n\n        List<String> programs = new ArrayList<>();\n        initLanguage();\n\n\n        //////////////////////////\n        // init folders\n        Environment.META_DIR = Environment.OUTPUT_DIR + \"/Meta/\";\n        Environment.CONNECT_DIR = Environment.OUTPUT_DIR + \"/Connect/\";\n\n        System.out.println(\"Output directory at: \" + Environment.OUTPUT_DIR);\n\n        File directory = new File(Environment.OUTPUT_DIR);", "        try {\n            ghidraProject = GhidraProject.openProject(projectDirectoryName, projectName);\n        }\n        catch (IOException e) {\n            // create a new project if not exist\n            // throw e;\n            ghidraProject = GhidraProject.createProject(projectDirectoryName, projectName, false);\n        }\n\n        List<String> programs = new ArrayList<>();\n        initLanguage();\n\n\n        //////////////////////////\n        // init folders\n        Environment.META_DIR = Environment.OUTPUT_DIR + \"/Meta/\";\n        Environment.CONNECT_DIR = Environment.OUTPUT_DIR + \"/Connect/\";\n\n        System.out.println(\"Output directory at: \" + Environment.OUTPUT_DIR);\n\n        File directory = new File(Environment.OUTPUT_DIR);", "        if (!directory.exists()) {\n            directory.mkdir();\n        }\n        directory = new File(Environment.META_DIR);\n        if (!directory.exists()) {\n            directory.mkdir();\n        }\n        directory = new File(Environment.CONNECT_DIR);\n        if (!directory.exists()) {\n            directory.mkdir();\n        }\n\n        programs = FileUtil.readListFromFile(Environment.BINARY_FILE_LIST);\n\n\n        // Load and analyze binary file", "        if (!directory.exists()) {\n            directory.mkdir();\n        }\n\n        programs = FileUtil.readListFromFile(Environment.BINARY_FILE_LIST);\n\n\n        // Load and analyze binary file\n        for (String p: programs) {\n            String fileName = p.substring(p.lastIndexOf(\"/\")+1);\n            //if (FileUtil.isResultExist(fileName))\n            //    continue; // skip finished tasks\n            Analyzer analyzer = new Analyzer(ghidraProject, p);\n            analyzer.startAnalyzing();\n        }\n\n        // endTime = System.currentTimeMillis();\n\n        // Close project\n        ghidraProject.setDeleteOnClose(false);\n        ghidraProject.close();\n\n    }\n", "        for (String p: programs) {\n            String fileName = p.substring(p.lastIndexOf(\"/\")+1);\n            //if (FileUtil.isResultExist(fileName))\n            //    continue; // skip finished tasks\n            Analyzer analyzer = new Analyzer(ghidraProject, p);\n            analyzer.startAnalyzing();\n        }\n\n        // endTime = System.currentTimeMillis();\n\n        // Close project\n        ghidraProject.setDeleteOnClose(false);\n        ghidraProject.close();\n\n    }\n", "    public static boolean loadConfig(String f) {\n        String configPath = f;\n        try {\n            String config = FileUtil.readFromFile(configPath);\n            if (config == null)\n                return false;\n            JSONObject configJson = new JSONObject(config);\n            // project meta configs\n            Constants.DIRECTORY_NAME = configJson.getString(\"DIRECTORY_NAME\");\n            Environment.OUTPUT_DIR = configJson.getString(\"OUTPUT_DIR\");\n            Constants.PROJECT_NAME = configJson.getString(\"PROJECT_NAME\");\n            Environment.LANGUAGE_NAME = configJson.getString(\"LANGUAGE_NAME\");\n            Environment.BINARY_FILE_LIST = configJson.getString(\"BINARY_FILE_LIST\");\n            // timeout settings\n            Configs.DISASSEMBLE_TIMEOUT = configJson.getInt(\"DISASSEMBLE_TIMEOUT\");\n            Configs.DECOMPILE_TIMEOUT = configJson.getInt(\"DECOMPILE_TIMEOUT\");\n            Configs.DECOMPILE_MODE = configJson.getString(\"DECOMPILE_MODE\");\n            Configs.EMULATION_TIMEOUT = configJson.getInt(\"EMULATION_TIMEOUT\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n\n    // Init necessary registers in PCode expressions", "    public static void initLanguage() {\n        if (Environment.LANGUAGE_NAME.contains(\"32\")) {\n            Environment.POINTER_SIZE = 4;\n        }\n        else if (Environment.LANGUAGE_NAME.contains(\"64\")){\n            Environment.POINTER_SIZE = 8;\n        }\n        else {\n            throw new UnsupportedOperationException();\n        }\n", "        if (Environment.LANGUAGE_NAME.contains(\"ARM:LE:32:v8\")) {\n            Environment.EXP_R0 = \"(register, 0x20, 4)\"; // this\n            Environment.EXP_R1 = \"(register, 0x24, 4)\";\n            Environment.EXP_R2 = \"(register, 0x28, 4)\";\n            Environment.EXP_R3 = \"(register, 0x2c, 4)\";\n            Environment.RETURN_REG = \"r0\";\n            Environment.COMPILER_SPEC = \"default\";\n        }\n        else if (Environment.LANGUAGE_NAME.contains(\"x86:LE:64\")) {\n            Environment.EXP_R0 = \"(register, 0x38, 8)\";      // this\n            Environment.EXP_R1 = \"(register, 0x10, 8)\";     // RDX\n            Environment.EXP_R2 = \"(register, 0x80, 8)\";     // R8\n            Environment.EXP_R3 = \"(register, 0x88, 8)\";     // R9\n            Environment.RETURN_REG = \"AL\";  // (register, 0x0, 8)\n            Environment.COMPILER_SPEC = \"gcc\"; // set gcc compiler style fo x86\n        }", "        else if (Environment.LANGUAGE_NAME.contains(\"x86:LE:64\")) {\n            Environment.EXP_R0 = \"(register, 0x38, 8)\";      // this\n            Environment.EXP_R1 = \"(register, 0x10, 8)\";     // RDX\n            Environment.EXP_R2 = \"(register, 0x80, 8)\";     // R8\n            Environment.EXP_R3 = \"(register, 0x88, 8)\";     // R9\n            Environment.RETURN_REG = \"AL\";  // (register, 0x0, 8)\n            Environment.COMPILER_SPEC = \"gcc\"; // set gcc compiler style fo x86\n        }\n        else if (Environment.LANGUAGE_NAME.contains(\"x86:LE:32\")) {\n            Environment.EXP_R0 = \"(register, 0x0, 4)\";      // RCX, this\n            Environment.EXP_R1 = \"(register, 0x10, 4)\";     // RDX\n            Environment.EXP_R2 = \"(register, 0x80, 4)\";     // R8\n            Environment.EXP_R3 = \"(register, 0x88, 4)\";     // R9\n            Environment.RETURN_REG = \"AL\";  // (register, 0x0, 8)\n            Environment.COMPILER_SPEC = \"gcc\"; // set gcc compiler style fo x86\n        }\n        else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n\n\n}\n", "        else if (Environment.LANGUAGE_NAME.contains(\"x86:LE:32\")) {\n            Environment.EXP_R0 = \"(register, 0x0, 4)\";      // RCX, this\n            Environment.EXP_R1 = \"(register, 0x10, 4)\";     // RDX\n            Environment.EXP_R2 = \"(register, 0x80, 4)\";     // R8\n            Environment.EXP_R3 = \"(register, 0x88, 4)\";     // R9\n            Environment.RETURN_REG = \"AL\";  // (register, 0x0, 8)\n            Environment.COMPILER_SPEC = \"gcc\"; // set gcc compiler style fo x86\n        }\n        else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n\n\n}\n"]}
{"filename": "src/Main/Analyzer.java", "chunked_list": ["package Main;\n\nimport Constant.Configs;\nimport Constant.Constants;\nimport Moc.QClassSolver;\nimport Taint.InputExpSolver;\nimport Taint.QTaintEngine;\nimport Moc.QtConnectSolver;\nimport Util.*;\nimport ghidra.app.plugin.core.analysis.AutoAnalysisManager;", "import Util.*;\nimport ghidra.app.plugin.core.analysis.AutoAnalysisManager;\nimport ghidra.app.plugin.processors.sleigh.SleighLanguageProvider;\nimport ghidra.base.project.GhidraProject;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.lang.*;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.scalar.Scalar;\nimport ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceIterator;", "import ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceIterator;\nimport ghidra.program.util.GhidraProgramUtilities;\nimport ghidra.test.TestProgramManager;\nimport ghidra.util.InvalidNameException;\nimport ghidra.util.exception.CancelledException;\nimport ghidra.util.exception.DuplicateNameException;\nimport ghidra.util.exception.VersionException;\nimport ghidra.util.task.TimeoutTaskMonitor;\nimport org.json.JSONArray;", "import ghidra.util.task.TimeoutTaskMonitor;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class Analyzer {\n", "import java.util.concurrent.TimeUnit;\n\npublic class Analyzer {\n\n    public TestProgramManager programManager;\n    public List<Address> connectionPoints = new ArrayList<>();\n    public long size;\n    public long analysisTime;\n\n    public Analyzer(GhidraProject project, String programName) throws VersionException, CancelledException, DuplicateNameException, InvalidNameException, IOException {\n\n        // Load binary file\n        File file = new File(programName);\n        size = file.length();", "        if (!file.exists()) {\n            throw new FileNotFoundException(\"Can not find Program: \" + programName);\n        }\n\n        LanguageProvider languageProvider;\n        try {\n            languageProvider = new SleighLanguageProvider();\n        } catch (Exception e) {\n            System.out.println(\"Unable to build language provider.\");\n            return;\n        }\n\n        Language language = languageProvider.getLanguage(new LanguageID(Environment.LANGUAGE_NAME));\n\n        CompilerSpec compilerSpec;", "        if (Environment.COMPILER_SPEC.equals(\"default\"))\n            compilerSpec = language.getDefaultCompilerSpec();\n        else\n            compilerSpec = language.getCompilerSpecByID(new CompilerSpecID(Environment.COMPILER_SPEC));\n\n        programManager = new TestProgramManager();\n\n        String appName = programName.substring(programName.lastIndexOf(\"/\")+1);\n        Program program;\n        try {\n            // open analyzed program if exists\n            program = project.openProgram(\"/\", appName, false);\n        }\n        catch (FileNotFoundException e) {\n            // import program if not exists\n            program = project.importProgram(file, language, compilerSpec);\n        }\n\n        long base = program.getImageBase().getUnsignedOffset();\n\n        // Initialize environment variables\n        Environment.initProgram(program);\n        Environment.initTag(program.getName()); // + \"@\" + program.getExecutableMD5());\n        Environment.initProject(project);\n\n        // Display the Processor used by Ghidra\n        System.out.println(\"Processor used : \" + program.getLanguage().getProcessor().toString());\n\n        long startTime = System.currentTimeMillis();", "        try {\n            // open analyzed program if exists\n            program = project.openProgram(\"/\", appName, false);\n        }\n        catch (FileNotFoundException e) {\n            // import program if not exists\n            program = project.importProgram(file, language, compilerSpec);\n        }\n\n        long base = program.getImageBase().getUnsignedOffset();\n\n        // Initialize environment variables\n        Environment.initProgram(program);\n        Environment.initTag(program.getName()); // + \"@\" + program.getExecutableMD5());\n        Environment.initProject(project);\n\n        // Display the Processor used by Ghidra\n        System.out.println(\"Processor used : \" + program.getLanguage().getProcessor().toString());\n\n        long startTime = System.currentTimeMillis();", "        if (GhidraProgramUtilities.shouldAskToAnalyze(program)) { // if the program has not been analyzed yet...\n            // Use the Ghidra headless analyzer to analyze the loaded binary file\n            int txId = program.startTransaction(\"Analysis\");\n            AutoAnalysisManager mgr = AutoAnalysisManager.getAnalysisManager(program);\n\n            mgr.initializeOptions();\n            mgr.reAnalyzeAll(null);\n\n            // The analysis will take sometime.\n            System.out.println(\"Analyzing...\");\n            mgr.startAnalysis(TimeoutTaskMonitor.timeoutIn(Configs.DISASSEMBLE_TIMEOUT, TimeUnit.SECONDS));\n\n            // Marked as analyzed\n            GhidraProgramUtilities.setAnalyzedFlag(program, true);\n        }\n        analysisTime = System.currentTimeMillis() - startTime;\n    }\n\n", "    public void analyzeInputSignals() {\n        Program program = Environment.getProgram();\n\n        List<Function> results = new ArrayList<>();\n\n        List<String> eventHandlers = new ArrayList<>();\n        eventHandlers.add(Constants.DO_KEY_PRESS);\n        eventHandlers.add(Constants.PROCESS_KEY_EVENT);\n\n        for (String sig: eventHandlers) {\n            List<Address> handlerAdds = FunctionUtil.locateFunctionWithSig(program, sig, false);", "        for (String sig: eventHandlers) {\n            List<Address> handlerAdds = FunctionUtil.locateFunctionWithSig(program, sig, false);\n            for (Address handlerAdd: handlerAdds) {\n                Function func = FunctionUtil.getFunctionWith(program, handlerAdd);\n                Set<Function> calledFuncs = new HashSet<>();\n                FunctionUtil.recursiveGetCalledFunc(func, calledFuncs);\n                for (Function call: calledFuncs) {\n                    if (FunctionUtil.isSignalFunction(call)) {\n                        results.add(call);\n                    }\n                }\n                System.out.println();\n            }\n        }\n\n        FileUtil.writeToFile(Environment.OUTPUT_DIR + \"signal\", \"\", false);\n\n        JSONArray output = new JSONArray();", "        for (Function func: results) {\n            JSONObject object = new JSONObject();\n            String sig = FunctionUtil.getFunctionSignature(func);\n            String className = sig.split(\"::\")[0];\n            String methodSig = sig.split(\"::\")[1];\n            String signalStr = \"2\" + methodSig;\n\n            object.put(\"class\", className);\n            object.put(\"signal\", signalStr);\n            output.put(object);\n        }\n\n        FileUtil.writeToFile(Environment.OUTPUT_DIR + \"signal\", output.toString(4), true);\n\n        programManager.release(program);\n    }\n\n", "    public void startAnalyzing() {\n\n        // start the analysis\n        // startTimeoutWatcher(Constants.TIMEOUT); // set timeout\n        System.out.println(\"\\n------------------ Starting Analysis ----------------\\n\");\n\n        Program program = Environment.getProgram();\n\n        System.out.println(program.getName());\n        \n        if (Configs.ANALYZE_CONNECT) {\n            System.out.println(\"Start analyzing Qt connects...\");\n            solveAllConnect();\n        }\n        ", "        if (Configs.ANALYZE_CONNECT) {\n            System.out.println(\"Start analyzing Qt connects...\");\n            solveAllConnect();\n        }\n        \n        if (Configs.ANALYZE_META) {\n            System.out.println(\"Start analyzing Qt metadata...\");\n            analyzeProperty();\n        }\n\n        // taint\n        //identifyInputVarFromFunc();\n        //identifyConnections();\n        //startTaint();\n\n        // Release Program\n        System.out.println(\"\\n------------------ Ending Analysis ----------------\\n\");\n        programManager.release(program);\n\n    }\n\n    /**\n     * Entry function to analyze class metadata by reversing the Qt metacall functions\n     */", "    public void analyzeProperty() {\n\n        Program program = Environment.getProgram();\n\n        long startTime = System.currentTimeMillis();\n\n        JSONObject result = new JSONObject();\n\n        List<String> classNames = new ArrayList<>();\n        classNames = StringUtil.getAllClassNames(program);\n", "        for (String cn: classNames) {\n            QClassSolver classSolver = new QClassSolver(Environment.getProgram(), cn);\n            classSolver.solve();\n\n            result.put(cn, classSolver.result);\n        }\n\n        if (!result.isEmpty()) {\n\n            long endTime = System.currentTimeMillis();\n            long elapseTime = endTime - startTime;\n\n            result.put(\"ClassCount\", classNames.size());\n            result.put(\"FunctionCount\", program.getFunctionManager().getFunctionCount());\n            result.put(\"Time\", elapseTime);\n            result.put(\"Size\", size);\n\n            FileUtil.writeToFile(Environment.META_DIR + Environment.tag + \".json\", result.toString(4), false);\n        }\n    }\n\n    /**\n     * Entry function to solve Qt connect functions and resolve call relationships\n     */", "    public void solveAllConnect() {\n        Program program = Environment.getProgram();\n\n        long startTime = System.currentTimeMillis();\n\n        List<Address> allConnectAdds = FunctionUtil.getConnectAddress(program);\n        if (allConnectAdds.size() == 0)\n            return;\n\n        JSONObject allConnectResults = new JSONObject();\n", "        for (Address connectAddr: allConnectAdds) {\n            ReferenceIterator refs = AddressUtil.getReferenceToAddress(program, connectAddr);\n            for (Reference ref : refs) {\n                Address connectAdd = AddressUtil.findConnectionAddress(program, ref.getFromAddress(), allConnectAdds);\n                if (connectAdd == null)\n                    continue;\n\n                QtConnectSolver solver = new QtConnectSolver(connectAdd);\n                solver.setConnectAddr(connectAddr);\n                solver.solve();\n", "                if (!solver.invalid) {\n                    JSONObject currentResult = new JSONObject();\n                    currentResult.put(\"QtConnectType\", solver.connectType);\n                    currentResult.put(\"allSolved\", solver.allSolved);\n                    currentResult.put(\"signalExp\", solver.signalExp);\n                    currentResult.put(\"signalFunction\", solver.signalFunction);\n                    currentResult.put(\"slotExp\", solver.slotExp);\n                    currentResult.put(\"slotFunction\", solver.slotFunction);\n                    currentResult.put(\"signalClassType\", solver.signalClassType);\n                    currentResult.put(\"slotClassType\", solver.slotClassType);\n                    currentResult.put(\"address\", connectAdd);\n", "                    if (solver.connectType == 1) {\n                        currentResult.put(\"signalAddress\", solver.signalAddress);\n                        currentResult.put(\"slotAddress\", solver.slotAddress);\n                    }\n                    else if (solver.connectType == 2) {\n                        currentResult.put(\"signalClass\", solver.signalClass);\n                        currentResult.put(\"slotClass\", solver.slotClass);\n                    }\n\n                    int currentIndex = allConnectResults.keySet().size();\n                    allConnectResults.put(currentIndex + \"\", currentResult);\n                }\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n        long elapseTime = endTime - startTime;\n\n        allConnectResults.put(\"ClassCount\", StringUtil.getAllClassNames(program).size());\n        allConnectResults.put(\"FunctionCount\", program.getFunctionManager().getFunctionCount());\n        allConnectResults.put(\"Time\", elapseTime + analysisTime);\n        allConnectResults.put(\"Size\", size);\n\n        // output result", "        if (!allConnectResults.isEmpty())\n            FileUtil.writeToFile(Environment.CONNECT_DIR + Environment.tag + \".json\", allConnectResults.toString(4), false);\n    }\n\n\n    /** Below are examples of using the Taint analysis engine on PCode (not being called), feel free to tweak them for your own purposes **/\n\n    public void identifyInputVarFromFunc() {\n        Program program = Environment.getProgram();\n        List<Address> funcAddrs = FunctionUtil.locateFunctionWithSig(program, Constants.SIG_QLINEEDIT_TEXT, true);\n\n        ReferenceIterator referenceIterator = AddressUtil.getReferenceToAddress(program, funcAddrs.get(0));", "        for (Reference ref: referenceIterator) {\n            Address entry = ref.getFromAddress();\n            // Taint return value of getText()\n            QTaintEngine taintEngine = new QTaintEngine(entry, Environment.EXP_R0);\n            taintEngine.taint();\n            System.out.println();\n        }\n    }\n\n\n    public void identifyConnections() {\n\n        Program program = Environment.getProgram();\n        List<Address> allConnectAdds = FunctionUtil.getConnectAddress(program);\n\n        List<String> signals = new ArrayList<>(List.of(Constants.SIGNAL_EDITING_END, Constants.SIGNAL_KEY_EVENT, Constants.SIGNAL_RETURN_PRESSED));\n        List<String> funSigs = new ArrayList<>(List.of(Constants.SIG_RETURN_PRESSED));\n", "    public void identifyConnections() {\n\n        Program program = Environment.getProgram();\n        List<Address> allConnectAdds = FunctionUtil.getConnectAddress(program);\n\n        List<String> signals = new ArrayList<>(List.of(Constants.SIGNAL_EDITING_END, Constants.SIGNAL_KEY_EVENT, Constants.SIGNAL_RETURN_PRESSED));\n        List<String> funSigs = new ArrayList<>(List.of(Constants.SIG_RETURN_PRESSED));\n\n        for (String signal: signals) {\n            List<Address> adrs = StringUtil.getRefToString(program, signal);\n            for (Address adr: adrs) {\n                ReferenceIterator sets = AddressUtil.getReferenceToAddress(program, adr);", "        for (String signal: signals) {\n            List<Address> adrs = StringUtil.getRefToString(program, signal);\n            for (Address adr: adrs) {\n                ReferenceIterator sets = AddressUtil.getReferenceToAddress(program, adr);\n                for (Reference ref: sets) {\n                    Address connectAdd = AddressUtil.findConnectionAddress(program, ref.getFromAddress(), allConnectAdds);\n                    if (connectAdd != null && !connectionPoints.contains(connectAdd))\n                        connectionPoints.add(connectAdd);\n                }\n            }\n        }\n", "        for (String funSig: funSigs) {\n            List<Address> funAdd = FunctionUtil.locateFunctionWithSig(program, funSig, true);\n            for (Address adr: funAdd) {\n                ReferenceIterator sets = AddressUtil.getReferenceToAddress(program, adr);\n                for (Reference ref: sets) {\n                    Address connectAdd = AddressUtil.findConnectionAddress(program, ref.getFromAddress(), allConnectAdds);\n                    if (connectAdd != null && !connectionPoints.contains(connectAdd))\n                        connectionPoints.add(connectAdd);\n                }\n            }\n        }\n\n    }\n", "    public void startTaint() {\n\n        Program program = Environment.getProgram();\n\n        JSONObject result = new JSONObject();\n\n        long startTime = System.currentTimeMillis();\n\n        for (Address ad: connectionPoints) {\n\n            // solve sender and receiver\n            QtConnectSolver connectSolver = new QtConnectSolver(ad);\n            connectSolver.solve();\n            String slot = connectSolver.slotClass + \"::\" + connectSolver.slotFunction;\n\n\n            Function slotFunc = FunctionUtil.getFunctionWithName(program, slot);\n", "        for (Address ad: connectionPoints) {\n\n            // solve sender and receiver\n            QtConnectSolver connectSolver = new QtConnectSolver(ad);\n            connectSolver.solve();\n            String slot = connectSolver.slotClass + \"::\" + connectSolver.slotFunction;\n\n\n            Function slotFunc = FunctionUtil.getFunctionWithName(program, slot);\n\n            if (slotFunc == null) {\n                System.out.println(\"slot not found! \" + slot);\n                continue;\n            }\n\n            // get all descendant functions\n            Set<Function> descendants = new HashSet<>();\n            FunctionUtil.recursiveGetCalledFunc(slotFunc, descendants);\n            descendants.add(slotFunc);\n\n\n            // start to taint", "            if (slotFunc == null) {\n                System.out.println(\"slot not found! \" + slot);\n                continue;\n            }\n\n            // get all descendant functions\n            Set<Function> descendants = new HashSet<>();\n            FunctionUtil.recursiveGetCalledFunc(slotFunc, descendants);\n            descendants.add(slotFunc);\n\n\n            // start to taint", "            for (Function f: descendants) {\n\n                // identify inputs\n                InputExpSolver inputSolver = new InputExpSolver(connectSolver);\n                inputSolver.solve();\n\n                String taintExp = inputSolver.inputExp;\n\n                QTaintEngine taintEngine = new QTaintEngine(f.getEntryPoint(), taintExp);\n                taintEngine.taint();\n", "                if (!taintEngine.jsonResult.isEmpty()) {\n                    taintEngine.jsonResult.put(\"Signal\", connectSolver.signalClass);\n                    result.put(f.getEntryPoint().toString(), taintEngine.jsonResult);\n                }\n            }\n        }\n\n        long elapseTime = System.currentTimeMillis() - startTime;\n        long iteratedIns = Environment.PCODE_INS_COUNT;\n\n        result.put(\"Time\", elapseTime);\n        result.put(\"Ins\", iteratedIns);\n\n        FileUtil.writeToFile(Environment.OUTPUT_DIR + \"result.json\", result.toString(4), false);\n\n    }\n", "    public static void startTimeoutWatcher(int sec) {\n        Thread t = new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(sec * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                // Logger.printOutput(\"TimeOut\");\n                System.exit(1);\n            }\n        };\n        t.setDaemon(true);\n        t.start();\n    }\n}\n"]}
{"filename": "src/Main/Decompiler.java", "chunked_list": ["package Main;\n\nimport Constant.Configs;\nimport ghidra.app.decompiler.DecompInterface;\nimport ghidra.app.decompiler.DecompileException;\nimport ghidra.app.decompiler.DecompileOptions;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.listing.Program;\nimport ghidra.util.task.TimeoutTaskMonitor;", "import ghidra.program.model.listing.Program;\nimport ghidra.util.task.TimeoutTaskMonitor;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Decompiler {\n\n    private static DecompInterface ifc;\n\n    private static void initIfc () {\n        if (ifc == null) {\n            DecompileOptions options = new DecompileOptions();\n            ifc = new DecompInterface();\n            ifc.setOptions(options);\n        }\n    }\n\n    private static DecompileResults decompile(Program program, String decompileMode, Function function) {\n\n        initIfc(); // init decompile interface\n", "        if (ifc == null) {\n            DecompileOptions options = new DecompileOptions();\n            ifc = new DecompInterface();\n            ifc.setOptions(options);\n        }\n    }\n\n    private static DecompileResults decompile(Program program, String decompileMode, Function function) {\n\n        initIfc(); // init decompile interface\n", "        if ( !ifc.openProgram(program)) {\n            // fail to open program\n            return null;\n        }\n        ifc.setSimplificationStyle(decompileMode);\n        DecompileResults res = ifc.decompileFunction(function, Configs.DECOMPILE_TIMEOUT, TimeoutTaskMonitor.timeoutIn(Configs.DECOMPILE_TIMEOUT, TimeUnit.SECONDS));\n        if (res == null || !res.decompileCompleted()) {\n            ifc.closeProgram();\n            return null; // decompile failed\n        }\n        else {\n            ifc.closeProgram();\n            return res;\n        }\n    }\n\n", "    public static DecompileResults decompileFunc(Program program, Function function) {\n        return decompile(program, Configs.DECOMPILE_MODE, function);\n    }\n\n    // for solving function call params\n    public static DecompileResults decompileFuncNormalize(Program program, Function function) {\n        return decompile(program, \"normalize\", function);\n    }\n\n\n    public static DecompileResults decompileFuncRegister(Program program, Function function) {\n        return decompile(program, \"register\", function);\n    }\n}\n", "    public static DecompileResults decompileFuncRegister(Program program, Function function) {\n        return decompile(program, \"register\", function);\n    }\n}\n"]}
{"filename": "src/Taint/TaintPath.java", "chunked_list": ["package Taint;\n\nimport Util.StringUtil;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.pcode.PcodeOp;\nimport ghidra.program.model.pcode.PcodeOpAST;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TaintPath {\n\n    public List<PcodeOp> path;\n    public List<Address> trace;\n\n    public TaintPath() {\n        path = new ArrayList<>();\n        trace = new ArrayList<>();\n    }\n", "import java.util.List;\n\npublic class TaintPath {\n\n    public List<PcodeOp> path;\n    public List<Address> trace;\n\n    public TaintPath() {\n        path = new ArrayList<>();\n        trace = new ArrayList<>();\n    }\n", "    public void addToPath(PcodeOp p) {\n        path.add(p);\n    }\n\n\n    public boolean containsPath(PcodeOp p) {\n        for (PcodeOp op: path) {\n            if (p.toString().equals(op.toString()))\n                return true;\n        }\n        return false;\n    }\n", "    public boolean pathEmpty() {\n        return path.size() == 0;\n    }\n\n\n    @Override\n    public TaintPath clone() {\n\n        TaintPath p = new TaintPath();\n        p.path = new ArrayList<>(this.path);\n        return p;\n    }\n}\n"]}
{"filename": "src/Taint/QTaintEngine.java", "chunked_list": ["package Taint;\n\nimport Constant.Configs;\nimport Constant.Constants;\nimport Main.Decompiler;\nimport Main.Environment;\nimport Util.BlockUtil;\nimport Util.FunctionUtil;\nimport Util.PCodeUtil;\nimport com.google.gson.JsonArray;", "import Util.PCodeUtil;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.block.CodeBlock;\nimport ghidra.program.model.block.CodeBlockReference;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.pcode.*;\nimport org.json.JSONArray;", "import ghidra.program.model.pcode.*;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**", "\n/**\n * Taint analysis engine running of Ghidra's PCode level\n * Input: inputLocations (HashMap)\n */\npublic class QTaintEngine {\n\n    Address start;\n    Function taintFunction;\n    String taintExpression;\n    List<TaintPath> paths;\n    HashMap<Address, String> inputLocations;", "    public JSONObject jsonResult = new JSONObject();\n    public String outputStr = \"\";\n\n\n    public QTaintEngine(Address startAdd, String taintExp) {\n        start = startAdd;\n        taintExpression = taintExp;\n        paths = new ArrayList<>();\n        inputLocations = new HashMap<>();\n\n    }\n", "    public void taint() {\n\n        if (taintExpression.equals(\"\"))\n            return;\n\n        Program program = Environment.getProgram();\n        Function startFunc = FunctionUtil.getFunctionWith(program, start);\n\n        // locate block at the target function\n        CodeBlock[] currentBlocks = BlockUtil.locateBlockWithAddress(program, startFunc.getEntryPoint());\n        if (currentBlocks == null || currentBlocks.length == 0) {\n            System.out.println(\"Error: block not found for address: \" + startFunc.getEntryPoint());\n            return;\n        }\n\n        identifyInputLoc();\n        identifyIndirectInputLoc();\n        startTaint();\n        evaluateResult();\n\n        /*\n        QTaintPath taintPath = new QTaintPath();\n        taintPath.addTaintVar(taintExpression);\n        CodeBlock currentBlock = currentBlocks[0];\n        recursiveTaint(currentBlock, taintPath, new ArrayList<>());\n", "        if (currentBlocks == null || currentBlocks.length == 0) {\n            System.out.println(\"Error: block not found for address: \" + startFunc.getEntryPoint());\n            return;\n        }\n\n        identifyInputLoc();\n        identifyIndirectInputLoc();\n        startTaint();\n        evaluateResult();\n\n        /*\n        QTaintPath taintPath = new QTaintPath();\n        taintPath.addTaintVar(taintExpression);\n        CodeBlock currentBlock = currentBlocks[0];\n        recursiveTaint(currentBlock, taintPath, new ArrayList<>());\n", "        for (QTaintPath path: allPaths) {\n            evaluateEqualExp(path);\n        }\n        */\n    }\n\n\n    public void identifyInputLoc() {\n        Program program = Environment.getProgram();\n\n        taintFunction = FunctionUtil.getFunctionWith(program, start);\n        DecompileResults decompileResults = Decompiler.decompileFunc(Environment.getProgram(), taintFunction);\n        HighFunction highFunction = decompileResults.getHighFunction();\n\n\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();\n", "        while (asts.hasNext()) {\n            PcodeOpAST ast = asts.next();\n            long a = ast.getSeqnum().getTarget().getUnsignedOffset();\n            if (ast.getSeqnum().getTarget().getUnsignedOffset() < start.getUnsignedOffset())\n                continue; // loop until we reach the starting point\n            Iterator<PcodeOpAST> o = highFunction.getPcodeOps(ast.getSeqnum().getTarget());\n            Varnode[] inputs = ast.getInputs();\n            Varnode output = ast.getOutput();\n\n            String exp = PCodeUtil.evaluateVarNode(output);\n            if (exp != null && exp.equals(taintExpression)) {", "            if (exp != null && exp.equals(taintExpression)) {\n                if (ast.getOutput() == null)\n                    continue;\n                inputLocations.put(ast.getSeqnum().getTarget(), output.toString());\n            }\n\n        }\n    }\n\n    // deal with load/store indirect reference\n    public void identifyIndirectInputLoc() {\n        Program program = Environment.getProgram();\n\n        Function currentFunc = FunctionUtil.getFunctionWith(program, start);\n        DecompileResults decompileResults = Decompiler.decompileFuncRegister(Environment.getProgram(), currentFunc);\n        HighFunction highFunction = decompileResults.getHighFunction();\n\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();\n\n        List<String> stackExp = new ArrayList<>();\n", "    public void identifyIndirectInputLoc() {\n        Program program = Environment.getProgram();\n\n        Function currentFunc = FunctionUtil.getFunctionWith(program, start);\n        DecompileResults decompileResults = Decompiler.decompileFuncRegister(Environment.getProgram(), currentFunc);\n        HighFunction highFunction = decompileResults.getHighFunction();\n\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();\n\n        List<String> stackExp = new ArrayList<>();\n", "        while (asts.hasNext()) {\n            PcodeOpAST ast = asts.next();\n            if (ast.getSeqnum().getTarget().getUnsignedOffset() < start.getUnsignedOffset())\n                continue; // loop until we reach the starting point\n            Varnode[] inputs = ast.getInputs();\n            for (int i=0; i<inputs.length; ++i) {\n                String mnem = ast.getMnemonic();\n\n                if (mnem.equals(\"STORE\")) {\n                    String expOfSrc = PCodeUtil.evaluateVarNode(inputs[2]);\n                    if (expOfSrc!= null && expOfSrc.contains(taintExpression)) {\n                        String expToAdd = PCodeUtil.evaluateVarNode(inputs[1]);", "                if (mnem.equals(\"STORE\")) {\n                    String expOfSrc = PCodeUtil.evaluateVarNode(inputs[2]);\n                    if (expOfSrc!= null && expOfSrc.contains(taintExpression)) {\n                        String expToAdd = PCodeUtil.evaluateVarNode(inputs[1]);\n                        if (!stackExp.contains(expToAdd))\n                            stackExp.add(expToAdd);\n                    }\n                }\n                else if (stackExp.size() != 0) {\n                    String outputExp = PCodeUtil.evaluateVarNode(ast.getOutput());\n                    if (stackExp.contains(outputExp)) {", "                else if (stackExp.size() != 0) {\n                    String outputExp = PCodeUtil.evaluateVarNode(ast.getOutput());\n                    if (stackExp.contains(outputExp)) {\n                        if (!inputLocations.containsKey(ast.getSeqnum().getTarget()))\n                            inputLocations.put(ast.getSeqnum().getTarget(), ast.getOutput().toString());\n                    }\n                }\n\n            }\n        }\n    }\n\n\n\n    private void startTaint() {\n        Program program = Environment.getProgram();\n\n        Function currentFunc = FunctionUtil.getFunctionWith(program, start);\n        DecompileResults decompileResults = Decompiler.decompileFunc(Environment.getProgram(), currentFunc);\n        HighFunction highFunction = decompileResults.getHighFunction();\n", "        for (Address add: inputLocations.keySet()) {\n            Iterator<PcodeOpAST> asts = highFunction.getPcodeOps(add);\n            String targetReg = inputLocations.get(add);\n            while (asts.hasNext()) {\n                PcodeOpAST ast = asts.next();\n                if (ast.getOutput() == null)\n                    continue;\n                if (ast.getOutput().toString().equals(targetReg)) {\n                    // start to taint descendants\n                    Iterator<PcodeOp> descendants = ast.getOutput().getDescendants();\n                    while (descendants.hasNext()) {\n                        Environment.PCODE_INS_COUNT ++;\n                        PcodeOp des = descendants.next();\n                        TaintPath path = new TaintPath();\n                        path.addToPath(ast);\n                        path.addToPath(des);\n                        recursiveTraverse(des, path);\n                    }\n                }\n            }\n        }\n    }\n", "                    while (descendants.hasNext()) {\n                        Environment.PCODE_INS_COUNT ++;\n                        PcodeOp des = descendants.next();\n                        TaintPath path = new TaintPath();\n                        path.addToPath(ast);\n                        path.addToPath(des);\n                        recursiveTraverse(des, path);\n                    }\n                }\n            }\n        }\n    }\n", "    public void evaluateResult() {\n        jsonResult.put(\"Function\", taintFunction.toString());\n        jsonResult.put(\"TaintExpression\", taintExpression);\n\n        JSONObject allPaths = new JSONObject();\n        for (TaintPath p: paths) {\n            int count = paths.indexOf(p);\n            JSONArray jsonArray = new JSONArray();\n            for (PcodeOp op: p.path) {\n                String mnem = op.getMnemonic();\n                Varnode[] inputs = op.getInputs();", "            for (PcodeOp op: p.path) {\n                String mnem = op.getMnemonic();\n                Varnode[] inputs = op.getInputs();\n                if (mnem.equals(\"CALL\")) {\n                    Function func = FunctionUtil.getFunctionWith(Environment.getProgram(), inputs[0].getAddress());\n                    StringBuilder tmp = new StringBuilder();\n                    tmp.append(op);\n                    tmp.append(\"  \");\n                    tmp.append(func.getName());\n                    if (func.getName().equals(\"operator==\")) {\n                        tmp.append(\" ==> \");\n                        String exp1 = PCodeUtil.evaluateVarNode(inputs[1]);\n                        String exp2 = PCodeUtil.evaluateVarNode(inputs[2]);\n                        tmp.append(exp1);\n                        tmp.append(\"=\");\n                        tmp.append(exp2);\n                    }\n                    jsonArray.put(tmp.toString());\n                }", "                    if (func.getName().equals(\"operator==\")) {\n                        tmp.append(\" ==> \");\n                        String exp1 = PCodeUtil.evaluateVarNode(inputs[1]);\n                        String exp2 = PCodeUtil.evaluateVarNode(inputs[2]);\n                        tmp.append(exp1);\n                        tmp.append(\"=\");\n                        tmp.append(exp2);\n                    }\n                    jsonArray.put(tmp.toString());\n                }\n                else if (mnem.equals(\"INT_EQUAL\")) {\n                    StringBuilder tmp = new StringBuilder();\n                    tmp.append(op);\n                    String exp1 = PCodeUtil.evaluateVarNode(inputs[0]);\n                    String exp2 = PCodeUtil.evaluateVarNode(inputs[1]);\n                    tmp.append(\" ==> \");\n                    tmp.append(exp1);\n                    tmp.append(\"=\");\n                    tmp.append(exp2);\n                    jsonArray.put(tmp.toString());\n                }\n                else {\n                    jsonArray.put(op.toString());\n                }\n\n            }\n            allPaths.put(String.valueOf(count), jsonArray);\n        }\n        jsonResult.put(\"paths\", allPaths);\n        outputStr = jsonResult.toString(4);\n    }\n\n", "                else if (mnem.equals(\"INT_EQUAL\")) {\n                    StringBuilder tmp = new StringBuilder();\n                    tmp.append(op);\n                    String exp1 = PCodeUtil.evaluateVarNode(inputs[0]);\n                    String exp2 = PCodeUtil.evaluateVarNode(inputs[1]);\n                    tmp.append(\" ==> \");\n                    tmp.append(exp1);\n                    tmp.append(\"=\");\n                    tmp.append(exp2);\n                    jsonArray.put(tmp.toString());\n                }\n                else {\n                    jsonArray.put(op.toString());\n                }\n\n            }\n            allPaths.put(String.valueOf(count), jsonArray);\n        }\n        jsonResult.put(\"paths\", allPaths);\n        outputStr = jsonResult.toString(4);\n    }\n\n", "    public void recursiveTraverse(PcodeOp current, TaintPath currentPath) {\n\n        if (current == null || current.getOutput() == null) {\n            // no outputStr, search ends\n            paths.add(currentPath);\n            return;\n        }\n\n        Iterator<PcodeOp> descendants = current.getOutput().getDescendants();\n\n        if (!descendants.hasNext()) {\n            // no descendants, search ends\n            paths.add(currentPath);\n            return;\n        }\n", "        if (!descendants.hasNext()) {\n            // no descendants, search ends\n            paths.add(currentPath);\n            return;\n        }\n\n        while (descendants.hasNext()) {\n            PcodeOp des = descendants.next();\n            if (des.getMnemonic().equals(\"MULTIEQUAL\"))\n                continue;\n            TaintPath newPath = currentPath.clone();\n            newPath.addToPath(des);\n            recursiveTraverse(des, newPath);\n        }\n    }\n\n\n\n}\n", "            if (des.getMnemonic().equals(\"MULTIEQUAL\"))\n                continue;\n            TaintPath newPath = currentPath.clone();\n            newPath.addToPath(des);\n            recursiveTraverse(des, newPath);\n        }\n    }\n\n\n\n}\n"]}
{"filename": "src/Taint/InputExpSolver.java", "chunked_list": ["package Taint;\n\nimport Constant.Configs;\nimport Main.Decompiler;\nimport Main.Environment;\nimport Moc.QtConnectSolver;\nimport Util.FunctionUtil;\nimport Util.NumericUtil;\nimport Util.PCodeUtil;\nimport ghidra.app.decompiler.DecompileResults;", "import Util.PCodeUtil;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.pcode.HighFunction;\nimport ghidra.program.model.pcode.PcodeOpAST;\nimport ghidra.program.model.pcode.Varnode;\nimport ghidra.program.model.symbol.Symbol;\nimport ghidra.util.task.TimeoutTaskMonitor;", "import ghidra.program.model.symbol.Symbol;\nimport ghidra.util.task.TimeoutTaskMonitor;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class InputExpSolver {\n\n    String slotClass;\n    Function slotConstructor;\n    Function slotFunction;\n\n    String signalClass;\n    String signalExp;\n    Set<Function> calledConstructors;\n", "    public String inputExp = \"\";\n\n    public InputExpSolver() {\n\n    }\n\n    public InputExpSolver(QtConnectSolver solver) {\n        this.slotFunction = FunctionUtil.getFunctionWithName(Environment.getProgram(), solver.slotFunction);\n        if (slotFunction == null)\n            slotFunction = slotFunction.getThunkedFunction(true);\n        this.slotClass = getClassNameFromFunctionName(slotFunction.toString());\n        this.slotConstructor = FunctionUtil.getFunctionWithName(Environment.getProgram(), getConstructorName(this.slotClass));\n        this.signalExp = solver.signalExp;\n        this.signalClass = solver.signalClass;\n    }\n\n    // INT_ADD LOAD (const, 0x1a1, 4) INT_ADD (register, 0x20, 4) (const, 0x360, 4) (const, 0x784, 4)\n", "        if (slotFunction == null)\n            slotFunction = slotFunction.getThunkedFunction(true);\n        this.slotClass = getClassNameFromFunctionName(slotFunction.toString());\n        this.slotConstructor = FunctionUtil.getFunctionWithName(Environment.getProgram(), getConstructorName(this.slotClass));\n        this.signalExp = solver.signalExp;\n        this.signalClass = solver.signalClass;\n    }\n\n    // INT_ADD LOAD (const, 0x1a1, 4) INT_ADD (register, 0x20, 4) (const, 0x360, 4) (const, 0x784, 4)\n\n    public void solve () {\n        String inputBase = signalExp;\n        switch (this.signalClass) {\n            case \"PasswordTextField\":\n            case \"TextField\":\n            case \"WebEntryField\":\n            case \"NavigationSearchBox\":\n            case \"CompleterTextField\":\n            case \"ExtEntryField\":\n                inputExp = \"LOAD (const, 0x1a1, 4) INT_ADD \" + inputBase + \" (const, 0x31c, 4)\";\n                break;\n        }\n    }\n\n\n    public List<String> getInitNullExpAtFunction(Program program, Function fun) {\n        List<String> result = new ArrayList<>();\n        DecompileResults decompileResults = Decompiler.decompileFuncNormalize(program, fun);\n        HighFunction highFunction = decompileResults.getHighFunction();\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();", "    public void solve () {\n        String inputBase = signalExp;\n        switch (this.signalClass) {\n            case \"PasswordTextField\":\n            case \"TextField\":\n            case \"WebEntryField\":\n            case \"NavigationSearchBox\":\n            case \"CompleterTextField\":\n            case \"ExtEntryField\":\n                inputExp = \"LOAD (const, 0x1a1, 4) INT_ADD \" + inputBase + \" (const, 0x31c, 4)\";\n                break;\n        }\n    }\n\n\n    public List<String> getInitNullExpAtFunction(Program program, Function fun) {\n        List<String> result = new ArrayList<>();\n        DecompileResults decompileResults = Decompiler.decompileFuncNormalize(program, fun);\n        HighFunction highFunction = decompileResults.getHighFunction();\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();", "        while (asts.hasNext()) {\n            PcodeOpAST ast = asts.next();\n            if (ast.getMnemonic().equals(\"STORE\")) {\n                Varnode[] inputs = ast.getInputs();\n                String srcExp = PCodeUtil.evaluateVarNode(inputs[2]);\n                String dstExp = PCodeUtil.evaluateVarNode(inputs[1]);\n                if (inputs[2].isConstant()) {\n                    Address a = inputs[2].getAddress();\n                    a = program.getAddressFactory().getAddress(NumericUtil.longToHexString(a.getUnsignedOffset()));\n                    Symbol[] symbols = program.getSymbolTable().getSymbols(a);\n                    if (symbols != null && symbols.length != 0) {", "                    if (symbols != null && symbols.length != 0) {\n                        for (Symbol symbol: symbols) {\n                            if (symbol.toString().contains(\"QString11shared_null\")) {\n                                if (dstExp != null)\n                                    result.add(dstExp);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<String> checkExpInSlot(Function fun, List<String> exp) {\n        List<String> result = new ArrayList<>();\n        DecompileResults decompileResults = Decompiler.decompileFuncNormalize(Environment.getProgram(), fun);\n        HighFunction highFunction = decompileResults.getHighFunction();\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();", "        while (asts.hasNext()) {\n            PcodeOpAST ast = asts.next();\n            Varnode[] inputs = ast.getInputs();\n            Varnode output = ast.getOutput();\n            if (output != null) {\n                String outputExp = PCodeUtil.evaluateVarNode(output);\n                if (exp.contains(outputExp) && !result.contains(outputExp)) {\n                    result.add(outputExp);\n                }\n            }\n        }\n        return result;\n    }\n", "    public Function getConstructor(String className) {\n        if (className == null)\n            return null;\n\n        for (Function constructor: calledConstructors) {\n            if (constructor == null)\n                continue;\n            if (constructor.getName().contains(className))\n                return constructor;\n        }\n\n        return null;\n        /*\n        String name = getConstructorName(className);\n        Function func = FunctionUtil.getFunctionWithName(Environment.getProgram(), name);", "        if (func != null)\n            return func;\n        else {\n            name = \"<EXTERNAL>::\" + name;\n            return FunctionUtil.getFunctionWithName(Environment.getProgram(), name);\n        }\n        */\n    }\n\n    public String getConstructorName(String className) {\n        return className + \"::\" + className;\n    }\n    ", "    public String getConstructorName(String className) {\n        return className + \"::\" + className;\n    }\n    \n    public String getClassNameFromFunctionName(String funcName) {\n        if (funcName.contains(\"::\"))\n            return funcName.split(\"::\")[0];\n        else\n            return null;\n    }\n\n\n", "    public void getAllCalledConstructors() {\n\n        calledConstructors = new HashSet<>();\n        calledConstructors.add(slotConstructor);\n\n        Set<Function> calledFunctions = slotConstructor.getCalledFunctions(TimeoutTaskMonitor.timeoutIn(Configs.DISASSEMBLE_TIMEOUT, TimeUnit.SECONDS));\n\n        for (Function f: calledFunctions) {\n            if (!f.getName().contains(\"::\")) {\n                Function thunkedFunc = f.getThunkedFunction(true);\n                if (thunkedFunc != null && thunkedFunc.toString().contains(\"::\")) {", "            if (!f.getName().contains(\"::\")) {\n                Function thunkedFunc = f.getThunkedFunction(true);\n                if (thunkedFunc != null && thunkedFunc.toString().contains(\"::\")) {\n                    if (FunctionUtil.isConstructor(thunkedFunc)) {\n                        calledConstructors.add(thunkedFunc);\n                    }\n                }\n            }\n            else {\n                if (FunctionUtil.isConstructor(f))\n                    calledConstructors.add(f);\n            }\n        }\n    }\n}\n", "                if (FunctionUtil.isConstructor(f))\n                    calledConstructors.add(f);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/Constant/Constants.java", "chunked_list": ["package Constant;\n\npublic class Constants {\n\n    // These configs should be overwritten by env.json\n    public static String DIRECTORY_NAME;\n    public static String PROJECT_NAME;\n\n    // Signature\n    public final static String SIG_CONNECT = \"connect(QObject*,char*,QObject*,char*,typedefConnectionTypedword)\";\n    public final static String ACTIVATE = \"activate(QObject*,QMetaObject*,int,void**)\";", "    public final static String SIG_CONNECT = \"connect(QObject*,char*,QObject*,char*,typedefConnectionTypedword)\";\n    public final static String ACTIVATE = \"activate(QObject*,QMetaObject*,int,void**)\";\n    public final static String SIG_RETURN_PRESSED = \"returnPressed()\";\n\n    public final static String SIG_QLINEEDIT_TEXT = \"QLineEdit::text()\";\n    public final static String SIG_QLINEEDIT_EDIT_FINISH = \"QLineEdit::editingFinished()\";\n    public final static String SIG_QLINEEDIT_RETURN = \"QLineEdit::returnPressed()\";\n\n    public final static String SIG_TEXTFIELD_GETTEXT = \"TextField::getText(int,int)\";\n    public final static String SIG_TEXTFIELD_EDIT_FINISH = \"TextField::editingFinished()\";\n", "    public final static String SIG_TEXTFIELD_GETTEXT = \"TextField::getText(int,int)\";\n    public final static String SIG_TEXTFIELD_EDIT_FINISH = \"TextField::editingFinished()\";\n\n    public final static String SIG_TEXTAREA_GETTEXT = \"TextArea::getText(int,int)\";\n    public final static String SIG_TEXTAREA_EDIT_FINISH = \"TextArea::editingFinished()\";\n\n    public final static String SIG_QINPUTDIALOG_GETTEXT = \"QInputDialog::getText(QWidget*,QString*,QString*,typedefEchoModedword,QString*,bool*,typedefQFlagsdword)\";\n    public final static String SIG_QINPUTDIALOG_GETINT = \"QInputDialog::getInt(QWidget*,QString*,QString*,int,int,int,int,bool*,typedefQFlagsdword)\";\n    public final static String SIG_QINPUTDIALOG_GETDOUBLE = \"QInputDialog::getDouble(QWidget*,QString*,QString*,double,double,double,int,bool*,typedefQFlagsdword)\";\n    public final static String SIG_QINPUTDIALOG_GETITEM = \"QInputDialog::getItem(QWidget*,QString*,QString*,QStringList*,int,bool,bool*,typedefQFlagsdword)\";\n\n    // Signals and Slots", "    public final static String SIG_QINPUTDIALOG_GETDOUBLE = \"QInputDialog::getDouble(QWidget*,QString*,QString*,double,double,double,int,bool*,typedefQFlagsdword)\";\n    public final static String SIG_QINPUTDIALOG_GETITEM = \"QInputDialog::getItem(QWidget*,QString*,QString*,QStringList*,int,bool,bool*,typedefQFlagsdword)\";\n\n    // Signals and Slots\n    public final static String SIGNAL_EDITING_END = \"2editingEnded(TextField*)\";\n    public final static String EDITING_OFFSET = \"0x314\";\n\n    public final static String SIGNAL_KEY_EVENT = \"2keyEvent(QKeyEvent)\";\n    public final static String KEY_OFFSET = \"0x304\";\n\n    public final static String SIGNAL_RELEASE = \"2released(ControlBase*)\";\n", "    public final static String KEY_OFFSET = \"0x304\";\n\n    public final static String SIGNAL_RELEASE = \"2released(ControlBase*)\";\n\n    public final static String SIGNAL_RETURN_PRESSED = \"2returnPressed()\";\n\n    public final static String SIGNAL_EDIT_FINISH = \"2editingFinished()\";\n\n    // Events\n    public final static String PROCESS_KEY_EVENT = \"processKeyEvent(QKeyEvent*)\";\n    public final static String DO_KEY_PRESS = \"doKeyPress(QKeyEvent*)\";\n\n", "    public final static String PROCESS_KEY_EVENT = \"processKeyEvent(QKeyEvent*)\";\n    public final static String DO_KEY_PRESS = \"doKeyPress(QKeyEvent*)\";\n\n\n    public static int PCODE_R0 = 0x20;\n\n}\n"]}
{"filename": "src/Constant/Configs.java", "chunked_list": ["package Constant;\n\npublic class Configs {\n\n    public static int DISASSEMBLE_TIMEOUT;\n\n    public static int EMULATION_TIMEOUT; // s\n\n    public static int DECOMPILE_TIMEOUT; // s\n\n    // all available options: \"decompile\"|\"normalize\"|\"register\"|\"firstpass\"|\"paramid\"", "    public static int DECOMPILE_TIMEOUT; // s\n\n    // all available options: \"decompile\"|\"normalize\"|\"register\"|\"firstpass\"|\"paramid\"\n    public static String DECOMPILE_MODE;\n\n    public static boolean ANALYZE_CONNECT;\n\n    public static boolean ANALYZE_META;\n\n    public static boolean ANALYZE_TAINT;\n}\n", "    public static boolean ANALYZE_TAINT;\n}\n"]}
