{"filename": "forge/src/main/java/fr/fyustorm/minetiface/MinetifaceMod.java", "chunked_list": ["package fr.fyustorm.minetiface;\n\nimport fr.fyustorm.minetiface.common.StartupCommon;\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\nimport net.minecraftforge.fml.loading.FMLPaths;\nimport org.slf4j.Logger;", "import net.minecraftforge.fml.loading.FMLPaths;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Path;\n\n@Mod(MinetifaceMod.MOD_ID)\npublic class MinetifaceMod\n{\n    public static final String MOD_ID = \"assets/minetiface\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceMod.class);\n\n    public MinetifaceMod() {\n        MinecraftForge.EVENT_BUS.register(this);\n\n        Path configPath = FMLPaths.CONFIGDIR.get();\n        MinetifaceConfig.loadConfig(configPath);\n\n        final IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();\n        modEventBus.register(StartupCommon.class);\n\n        LOGGER.info(\"Minetiface init\");\n    }\n}\n", "    public static final String MOD_ID = \"assets/minetiface\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceMod.class);\n\n    public MinetifaceMod() {\n        MinecraftForge.EVENT_BUS.register(this);\n\n        Path configPath = FMLPaths.CONFIGDIR.get();\n        MinetifaceConfig.loadConfig(configPath);\n\n        final IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();\n        modEventBus.register(StartupCommon.class);\n\n        LOGGER.info(\"Minetiface init\");\n    }\n}\n"]}
{"filename": "forge/src/main/java/fr/fyustorm/minetiface/common/RegisterCommandEvent.java", "chunked_list": ["package fr.fyustorm.minetiface.common;\n\nimport com.mojang.brigadier.CommandDispatcher;\nimport net.minecraft.commands.CommandSourceStack;\nimport net.minecraftforge.event.RegisterCommandsEvent;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RegisterCommandEvent {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RegisterCommandEvent.class);\n\n    @SubscribeEvent", "\npublic class RegisterCommandEvent {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RegisterCommandEvent.class);\n\n    @SubscribeEvent\n    public static void onRegisterCommandEvent(RegisterCommandsEvent event) {\n        CommandDispatcher<CommandSourceStack> commandDispatcher = event.getDispatcher();\n        MinetifaceCommand.register(commandDispatcher);\n        LOGGER.info(\"Minetiface register commands\");\n    }\n}\n"]}
{"filename": "forge/src/main/java/fr/fyustorm/minetiface/common/StartupCommon.java", "chunked_list": ["package fr.fyustorm.minetiface.common;\n\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.level.block.Block;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.event.RegistryEvent;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class StartupCommon {\n    private static final Logger LOGGER = LoggerFactory.getLogger(StartupCommon.class);\n\n    @SubscribeEvent\n    public static void onCommonSetupEvent(FMLCommonSetupEvent event) {\n        MinecraftForge.EVENT_BUS.register(RegisterCommandEvent.class);\n        LOGGER.info(\"Minetiface common setup\");\n    }\n}\n"]}
{"filename": "forge/src/main/java/fr/fyustorm/minetiface/common/MinetifaceCommand.java", "chunked_list": ["package fr.fyustorm.minetiface.common;\n\nimport com.mojang.brigadier.Command;\nimport com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.builder.LiteralArgumentBuilder;\nimport com.mojang.brigadier.context.CommandContext;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport com.mojang.brigadier.exceptions.SimpleCommandExceptionType;\nimport fr.fyustorm.minetiface.MinetifaceMod;\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;", "import fr.fyustorm.minetiface.MinetifaceMod;\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport fr.fyustorm.minetiface.commons.intiface.ToyController;\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugClientDevice;\nimport net.minecraft.commands.CommandSourceStack;\nimport net.minecraft.commands.Commands;\nimport net.minecraft.network.chat.TranslatableComponent;\nimport net.minecraft.world.entity.Entity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;", "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.URISyntaxException;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n\npublic class MinetifaceCommand {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceMod.class);\n\n    private static final ExecutorService executor = Executors.newSingleThreadExecutor();\n", "\npublic class MinetifaceCommand {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceMod.class);\n\n    private static final ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {\n\n        LiteralArgumentBuilder<CommandSourceStack> connectCommand = Commands.literal(\"minetiface-connect\")\n                .executes(o -> {\n                    commandConnect(o);\n                    return Command.SINGLE_SUCCESS;\n                });\n\n        LiteralArgumentBuilder<CommandSourceStack> disconnectCommand = Commands.literal(\"minetiface-disconnect\")\n                .executes(o -> {\n                    commandDisconnect(o);\n                    return Command.SINGLE_SUCCESS;\n                });\n\n        LiteralArgumentBuilder<CommandSourceStack> scanCommand = Commands.literal(\"minetiface-scan\")\n                .executes(o -> {\n                    commandDisconnect(o);\n                    return Command.SINGLE_SUCCESS;\n                });\n\n        dispatcher.register(connectCommand);\n        dispatcher.register(disconnectCommand);\n        dispatcher.register(scanCommand);\n\n        LOGGER.info(\"Minetiface commands registered\");\n    }\n\n    private static void commandConnect(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        LOGGER.info(\"Connect command\");", "        try {\n            if (ToyController.instance().isConnected()) {\n                commandScan(context);\n                return;\n            }\n\n            ToyController.instance().connectServer();\n            sendMessage(context, \"commands.connect.success\");\n            commandScan(context);\n        } catch (URISyntaxException e) {\n            throw new SimpleCommandExceptionType(\n                    new TranslatableComponent(\"commands.connect.invalid_address\", MinetifaceConfig.INSTANCE.serverUrl))\n                    .create();\n        } catch (Exception e) {\n            throw new SimpleCommandExceptionType(new TranslatableComponent(\"commands.connect.error\")).create();\n        }\n    }\n\n    private static void commandDisconnect(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        LOGGER.info(\"Disconnect command\");\n        ToyController.instance().disconnectServer();\n        sendMessage(context, \"commands.disconnected\");\n    }\n\n\n\n    private static void commandScan(CommandContext<CommandSourceStack> context) {\n        executor.submit(() -> {\n            LOGGER.info(\"Scanning devices\");\n\n            List<ButtplugClientDevice> devices;", "            try {\n                sendMessage(context, \"commands.connect.scan\");\n                devices = ToyController.instance().scanDevices().get();\n\n                if (devices.isEmpty()) {\n                    sendMessage(context, \"commands.connect.no_device\");\n                    return;\n                }\n\n                String devicesStr = ToyController.instance().getDevicesString();\n\n                sendMessage(context, new TranslatableComponent(\"commands.connect.devices\", devices.size(), devicesStr));\n\n                sendMessage(context, \"commands.connect.add_more\");\n            } catch (Exception e) {\n                LOGGER.error(\"Error while scanning devices\", e);", "                try {\n                    sendMessage(context, new TranslatableComponent(\"commands.connect.scan_failed\", e.getMessage()));\n                } catch (CommandSyntaxException ex) {\n                    LOGGER.error(\"Error while sending feedback error\", e);\n                }\n            }\n        });\n    }\n\n    private static void sendMessage(CommandContext<CommandSourceStack> commandContext, TranslatableComponent finalText) throws CommandSyntaxException {\n        Entity entity = commandContext.getSource().getEntity();", "        if (entity == null) {\n            return;\n        }\n\n        commandContext.getSource().getPlayerOrException().sendMessage(finalText, entity.getUUID());\n    }\n\n    private static void sendMessage(CommandContext<CommandSourceStack> commandContext, String translationKey) throws CommandSyntaxException {\n        TranslatableComponent finalText = new TranslatableComponent(translationKey);\n        sendMessage(commandContext, finalText);\n    }\n}\n"]}
{"filename": "forge/src/main/java/fr/fyustorm/minetiface/client/ClientEventHandler.java", "chunked_list": ["package fr.fyustorm.minetiface.client;\n\nimport fr.fyustorm.minetiface.MinetifaceMod;\nimport fr.fyustorm.minetiface.commons.intiface.MinetifaceController;\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraftforge.event.TickEvent;\nimport net.minecraftforge.event.entity.living.LivingDamageEvent;\nimport net.minecraftforge.event.entity.living.LivingDeathEvent;", "import net.minecraftforge.event.entity.living.LivingDamageEvent;\nimport net.minecraftforge.event.entity.living.LivingDeathEvent;\nimport net.minecraftforge.event.entity.living.LivingHurtEvent;\nimport net.minecraftforge.event.entity.player.PlayerXpEvent;\nimport net.minecraftforge.event.world.BlockEvent;\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\nimport net.minecraftforge.fml.common.Mod;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.util.UUID;\n\n\n@Mod.EventBusSubscriber(modid = MinetifaceMod.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)\npublic class ClientEventHandler {\n    public static final Logger LOGGER = LoggerFactory.getLogger(ClientEventHandler.class);\n\n    private static int playerTickCount = 0;\n    private static int clientTickCount = 0;\n\n    @SubscribeEvent", "    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {\n        // Forge is 80 ticks per second and fabric 20 ticks per second\n        // So let's send only 20 ticks per second to have the same tickrate\n        playerTickCount++;\n        if (playerTickCount == 4) {\n            MinetifaceController.getInstance().onPlayerTick();\n            playerTickCount = 0;\n        }\n    }\n\n    @SubscribeEvent", "    public static void onClientTick(TickEvent.ClientTickEvent event) {\n        // Forge is 80 ticks per second and fabric 20 ticks per second\n        // So let's send only 20 ticks per second to have the same tickrate\n        clientTickCount++;\n        if (clientTickCount == 4) {\n            MinetifaceController.getInstance().onClientTick();\n            clientTickCount = 0;\n        }\n    }\n\n    @SubscribeEvent", "    public static void onLivingDamage(LivingDamageEvent event) {\n        Entity source = event.getSource().getEntity();\n\n        if (source instanceof Player playerSource) {\n            UUID entityId = playerSource.getGameProfile().getId();\n            if (Minecraft.getInstance().player == null) {\n                return;\n            }\n            UUID playerId = Minecraft.getInstance().player.getGameProfile().getId();\n\n            if (!entityId.equals(playerId)) {\n                return;\n            }\n\n            // If we are self attacking (arrow for example)", "            if (!entityId.equals(playerId)) {\n                return;\n            }\n\n            // If we are self attacking (arrow for example)\n            if (source.equals(event.getEntity())) {\n                return;\n            }\n\n            MinetifaceController.getInstance().onDamage(event.getAmount());\n        }\n    }\n\n    @SubscribeEvent", "    public static void onHurt(LivingHurtEvent event) {\n        Entity entity = event.getEntityLiving();\n        if (entity instanceof Player player) {\n            UUID entityId = player.getGameProfile().getId();\n            if (Minecraft.getInstance().player == null) {\n                return;\n            }\n            UUID playerId = Minecraft.getInstance().player.getGameProfile().getId();\n\n            if (!entityId.equals(playerId)) {\n                return;\n            }\n            MinetifaceController.getInstance().onHurt(event.getAmount());\n        }\n    }\n\n    @SubscribeEvent", "            if (!entityId.equals(playerId)) {\n                return;\n            }\n            MinetifaceController.getInstance().onHurt(event.getAmount());\n        }\n    }\n\n    @SubscribeEvent\n    public static void onDeath(LivingDeathEvent event) {\n        Entity entity = event.getEntityLiving();\n        if (entity instanceof Player player) {\n            UUID entityId = player.getGameProfile().getId();", "    public static void onDeath(LivingDeathEvent event) {\n        Entity entity = event.getEntityLiving();\n        if (entity instanceof Player player) {\n            UUID entityId = player.getGameProfile().getId();\n            if (Minecraft.getInstance().player == null) {\n                return;\n            }\n            UUID playerId = Minecraft.getInstance().player.getGameProfile().getId();\n\n            if (!entityId.equals(playerId)) {\n                return;\n            }\n\n            MinetifaceController.getInstance().onDeath();\n        }\n    }\n\n    @SubscribeEvent", "            if (!entityId.equals(playerId)) {\n                return;\n            }\n\n            MinetifaceController.getInstance().onDeath();\n        }\n    }\n\n    @SubscribeEvent\n    public static void onBreak(BlockEvent.BreakEvent event) {\n        UUID eventPlayer = event.getPlayer().getGameProfile().getId();", "    public static void onBreak(BlockEvent.BreakEvent event) {\n        UUID eventPlayer = event.getPlayer().getGameProfile().getId();\n        if (Minecraft.getInstance().player == null) {\n            return;\n        }\n        UUID playerId = Minecraft.getInstance().player.getUUID();\n\n        if (!eventPlayer.equals(playerId)) {\n            return;\n        }\n\n        String blockId = event.getState().getBlock().getDescriptionId();\n        MinetifaceController.getInstance().onBreak(blockId);\n    }\n\n    @SubscribeEvent", "    public static void onXpChange(PlayerXpEvent.XpChange event) {\n        UUID eventPlayer = event.getPlayer().getGameProfile().getId();\n        if (Minecraft.getInstance().player == null) {\n            return;\n        }\n        UUID playerId = Minecraft.getInstance().player.getUUID();\n\n        if (!eventPlayer.equals(playerId)) {\n            return;\n        }\n\n        Player player = event.getPlayer();\n        MinetifaceController.getInstance().onXpChange(player.experienceProgress, player.totalExperience, event.getAmount());\n    }\n}\n\n"]}
{"filename": "fabric/src/main/java/fr/fyustorm/minetiface/MinetifaceMod.java", "chunked_list": ["package fr.fyustorm.minetiface;\n\nimport com.mojang.brigadier.Command;\nimport com.mojang.brigadier.context.CommandContext;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport com.mojang.brigadier.exceptions.SimpleCommandExceptionType;\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport fr.fyustorm.minetiface.commons.intiface.ToyController;\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugClientDevice;\nimport net.fabricmc.api.ModInitializer;", "import io.github.blackspherefollower.buttplug4j.client.ButtplugClientDevice;\nimport net.fabricmc.api.ModInitializer;\nimport net.fabricmc.fabric.api.client.command.v1.ClientCommandManager;\nimport net.fabricmc.fabric.api.client.command.v1.FabricClientCommandSource;\nimport net.fabricmc.loader.api.FabricLoader;\nimport net.minecraft.text.TranslatableText;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.URISyntaxException;", "\nimport java.net.URISyntaxException;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MinetifaceMod implements ModInitializer {\n    public static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceMod.class);\n    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    @Override", "    public void onInitialize() {\n        LOGGER.info(\"Initializing minetiface\");\n\n        MinetifaceConfig.loadConfig(FabricLoader.getInstance().getConfigDir());\n\n        ClientCommandManager.DISPATCHER.register(ClientCommandManager\n                .literal(\"minetiface-connect\")\n                .executes(o -> {\n                    commandConnect(o);\n                    return Command.SINGLE_SUCCESS;\n                }));\n\n\n\t\tClientCommandManager.DISPATCHER.register(ClientCommandManager\n\t\t\t\t.literal(\"minetiface-disconnect\")\n\t\t\t\t.executes(o -> {\n\t\t\t\t\tcommandDisconnect(o);\n\t\t\t\t\treturn Command.SINGLE_SUCCESS;\n\t\t\t\t}));\n    }\n\n    private void commandConnect(CommandContext<FabricClientCommandSource> context) throws CommandSyntaxException {\n        LOGGER.info(\"Connect command\");", "        try {\n            if (ToyController.instance().isConnected()) {\n                commandScan(context);\n                return;\n            }\n\n            ToyController.instance().connectServer();\n            context.getSource().sendFeedback(new TranslatableText(\"commands.connect.success\"));\n            commandScan(context);\n        } catch (URISyntaxException e) {\n            throw new SimpleCommandExceptionType(\n\t\t\t\t\tnew TranslatableText(\"commands.connect.invalid_address\", MinetifaceConfig.INSTANCE.serverUrl))\n                    .create();\n        } catch (Exception e) {\n            throw new SimpleCommandExceptionType(new TranslatableText(\"commands.connect.error\")).create();\n        }\n    }\n\n    private void commandDisconnect(CommandContext<FabricClientCommandSource> context) {\n        LOGGER.info(\"Disconnect command\");\n        ToyController.instance().disconnectServer();\n\t\tcontext.getSource().sendFeedback(new TranslatableText(\"commands.disconnected\"));\n    }\n\n    private void commandScan(CommandContext<FabricClientCommandSource> context) throws CommandSyntaxException {\n        executor.submit(() -> {\n            LOGGER.info(\"Scanning devices\");\n            context.getSource().sendFeedback(new TranslatableText(\"commands.connect.scan\"));\n            List<ButtplugClientDevice> devices;", "            try {\n                devices = ToyController.instance().scanDevices().get();\n\n                if (devices.isEmpty()) {\n                    context.getSource().sendFeedback(new TranslatableText(\"commands.connect.no_device\"));\n                    return;\n                }\n\n                String devicesStr = ToyController.instance().getDevicesString();\n\n                context.getSource()\n                        .sendFeedback(new TranslatableText(\"commands.connect.devices\", devices.size(), devicesStr));\n\n                context.getSource()\n                        .sendFeedback(new TranslatableText(\"commands.connect.add_more\"));\n            } catch (Exception e) {\n                LOGGER.error(\"Error while scanning devices\", e);\n                context.getSource().sendFeedback(new TranslatableText(\"commands.connect.scan_failed\", e.getMessage()));\n            }\n        });\n    }\n}\n\n"]}
{"filename": "fabric/src/main/java/fr/fyustorm/minetiface/mixin/ClientPlayerInteractionManagerMixins.java", "chunked_list": ["package fr.fyustorm.minetiface.mixin;\n\nimport fr.fyustorm.minetiface.commons.intiface.MinetifaceController;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.client.network.ClientPlayerInteractionManager;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.World;\nimport org.slf4j.Logger;", "import net.minecraft.world.World;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\n@Mixin(ClientPlayerInteractionManager.class)\npublic class ClientPlayerInteractionManagerMixins {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(ClientPlayerInteractionManagerMixins.class);\n\n    @Shadow\n    @Final\n    private MinecraftClient client;\n    @Inject(method = \"breakBlock(Lnet/minecraft/util/math/BlockPos;)Z\", at = @At(\"HEAD\"))\n    private void onBreak(BlockPos pos, CallbackInfoReturnable<Boolean> ci) {\n        World world = client.world;\n        ClientPlayerEntity player = client.player;", "        if (world == null || player == null) {\n            return;\n        }\n\n        BlockState state = world.getBlockState(pos);\n        MinetifaceController.getInstance().onBreak(state.getBlock().getTranslationKey());\n    }\n}\n"]}
{"filename": "fabric/src/main/java/fr/fyustorm/minetiface/mixin/MinecraftClientMixins.java", "chunked_list": ["package fr.fyustorm.minetiface.mixin;\n\nimport fr.fyustorm.minetiface.commons.intiface.MinetifaceController;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\nimport net.minecraft.client.MinecraftClient;\n", "import net.minecraft.client.MinecraftClient;\n\n@Mixin(MinecraftClient.class)\npublic class MinecraftClientMixins {\n    @Inject(at = @At(\"TAIL\"), method = \"tick()V\")\n    private void onTickEnd(CallbackInfo ci) {\n        MinetifaceController.getInstance().onClientTick();\n    }\n}\n"]}
{"filename": "fabric/src/main/java/fr/fyustorm/minetiface/mixin/ClientPlayerEntityMixins.java", "chunked_list": ["package fr.fyustorm.minetiface.mixin;\n\nimport fr.fyustorm.minetiface.commons.intiface.MinetifaceController;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(ClientPlayerEntity.class)\npublic class ClientPlayerEntityMixins {\n    @Inject(at = @At(\"TAIL\"), method = \"tick()V\")\n    private void playerTick(CallbackInfo ci) {\n        MinetifaceController.getInstance().onPlayerTick();\n    }\n\n    @Inject(at = @At(\"HEAD\"), method = \"setExperience(FII)V\")\n    private void onXpAdded(float progress, int total, int level, CallbackInfo ci) {\n        MinetifaceController.getInstance().onXpChange(progress, total, level);\n    }\n}\n", "\n@Mixin(ClientPlayerEntity.class)\npublic class ClientPlayerEntityMixins {\n    @Inject(at = @At(\"TAIL\"), method = \"tick()V\")\n    private void playerTick(CallbackInfo ci) {\n        MinetifaceController.getInstance().onPlayerTick();\n    }\n\n    @Inject(at = @At(\"HEAD\"), method = \"setExperience(FII)V\")\n    private void onXpAdded(float progress, int total, int level, CallbackInfo ci) {\n        MinetifaceController.getInstance().onXpChange(progress, total, level);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/fr/fyustorm/minetiface/mixin/LivingEntityMixins.java", "chunked_list": ["package fr.fyustorm.minetiface.mixin;\n\nimport fr.fyustorm.minetiface.commons.intiface.MinetifaceController;\nimport net.minecraft.client.MinecraftClient;\nimport net.minecraft.client.network.ClientPlayerEntity;\nimport net.minecraft.server.network.ServerPlayerEntity;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n\nimport org.spongepowered.asm.mixin.injection.At;\n\nimport net.minecraft.entity.LivingEntity;\nimport net.minecraft.entity.damage.DamageSource;\n\nimport java.util.UUID;\n\n@Mixin(LivingEntity.class)\npublic class LivingEntityMixins {\n\n    @Inject(at = @At(\"TAIL\"), method = \"damage(Lnet/minecraft/entity/damage/DamageSource;F)Z\")", "\n@Mixin(LivingEntity.class)\npublic class LivingEntityMixins {\n\n    @Inject(at = @At(\"TAIL\"), method = \"damage(Lnet/minecraft/entity/damage/DamageSource;F)Z\")\n    public void onDamage(DamageSource source, float amount, CallbackInfoReturnable<Boolean> ci) {\n        LivingEntity target = (LivingEntity) (Object) this;\n\n        ClientPlayerEntity player = MinecraftClient.getInstance().player;\n        if (player == null) {\n            return;\n        }\n\n        UUID clientId = MinecraftClient.getInstance().player.getUuid();\n        UUID playerEventId = null;\n", "        if (player == null) {\n            return;\n        }\n\n        UUID clientId = MinecraftClient.getInstance().player.getUuid();\n        UUID playerEventId = null;\n\n        if (target instanceof ServerPlayerEntity && target.getUuid().equals(clientId)) {\n            // Self damage\n            MinetifaceController.getInstance().onHurt(amount);\n        } else if (source.getName().equals(\"player\") && source.getSource() instanceof ServerPlayerEntity playerSource) {\n            playerEventId = playerSource.getUuid();", "        } else if (source.getName().equals(\"player\") && source.getSource() instanceof ServerPlayerEntity playerSource) {\n            playerEventId = playerSource.getUuid();\n        } else if (source.getName().equals(\"arrow\") && source.getAttacker() instanceof ServerPlayerEntity playerAttacker) {\n            playerEventId = playerAttacker.getUuid();\n        }\n\n        // On attack\n        if (clientId.equals(playerEventId)) {\n            MinetifaceController.getInstance().onDamage(amount);\n        }\n    }\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/config/MinetifaceConfig.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.config;\n\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.io.File;\nimport java.io.FileInputStream;", "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n", "import java.util.concurrent.Executors;\n\nimport static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n\npublic class MinetifaceConfig {\n\n    public static final ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    public static final String CONFIG_NAME = \"minetiface.config\";\n\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n    private static final Logger LOGGER = LogManager.getLogger(MinetifaceConfig.class);", "    public static final String CONFIG_NAME = \"minetiface.config\";\n\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n    private static final Logger LOGGER = LogManager.getLogger(MinetifaceConfig.class);\n    public static MinetifaceConfig INSTANCE;\n    public String serverUrl = \"localhost:12345\";\n\n    public float minimumFeedback = 10;\n    public float maximumFeedback = 30;\n    public float maximumScore = 80;\n    public float feedbackScoreLostPerTick = 2f;", "    public float maximumFeedback = 30;\n    public float maximumScore = 80;\n    public float feedbackScoreLostPerTick = 2f;\n    public float scoreLostPerTick = 0.05f;\n    public int maximumSecondsKeepScore = 30;\n\n    // Intiface (linear)\n    /**\n     * Maximum time to go from position 0 to 1 and vice-versa (in ms)\n     */\n    public long fullMaxTime = 5000;\n\n    /**\n     * Minimum time to go from position 0 to 1 and vice-versa (in ms)\n     */", "    public long fullMaxTime = 5000;\n\n    /**\n     * Minimum time to go from position 0 to 1 and vice-versa (in ms)\n     */\n    public long fullMinTime = 100;\n\n    // Masochist\n    public boolean masochistEnabled = true;\n    public float masochistMultiplier = 1;\n    public float masochistInstantPointsMultiplier = 1;", "    public boolean masochistEnabled = true;\n    public float masochistMultiplier = 1;\n    public float masochistInstantPointsMultiplier = 1;\n    public float masochistDurationMultiplier = 1;\n\n    // Xp\n    public boolean xpEnabled = true;\n    public float xpMultiplier = 1;\n    public float xpInstantPointsMultiplier = 1;\n    public float xpDurationMultiplier = 1;\n\n    // Mining", "    public float xpInstantPointsMultiplier = 1;\n    public float xpDurationMultiplier = 1;\n\n    // Mining\n    public boolean miningEnabled = true;\n    public float minePointsMultiplier = 1;\n    public float mineInstantPointsMultiplier = 1;\n    public float mineDurationMultiplier = 1;\n    public Map<String, BlockScoreConfig> blocksScore;\n    public static Map<String, BlockScoreConfig> defaultBlocks;\n    public float defaultBlockScore = 1;\n\n    // Attack", "    public static Map<String, BlockScoreConfig> defaultBlocks;\n    public float defaultBlockScore = 1;\n\n    // Attack\n    public boolean attackEnabled = true;\n    public float attackMultiplier = 1;\n    public float attackInstantPointsMultiplier = 1;\n    public float attackDurationMultiplier = 1;\n\n    static {\n        MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n        defaultBlocks = new HashMap<>();\n        defaultBlocks.put(\"block.minecraft.coal_ore\", new BlockScoreConfig(\"block.minecraft.coal_ore\", \"Coal Ore\", 5f));\n        defaultBlocks.put(\"block.minecraft.iron_ore\", new BlockScoreConfig(\"block.minecraft.iron_ore\", \"Iron Ore\", 5f));\n        defaultBlocks.put(\"block.minecraft.deepslate_iron_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_iron_ore\", \"Deepslate Iron Ore\", 10f));\n        defaultBlocks.put(\"block.minecraft.copper_ore\", new BlockScoreConfig(\"block.minecraft.copper_ore\", \"Copper Ore\", 5f));\n        defaultBlocks.put(\"block.minecraft.deepslate_copper_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_copper_ore\", \"Deepslate Copper Ore\", 10f));\n        defaultBlocks.put(\"block.minecraft.redstone_ore\", new BlockScoreConfig(\"block.minecraft.redstone_ore\", \"Redstone Ore\", 10f));\n        defaultBlocks.put(\"block.minecraft.deepslate_redstone_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_redstone_ore\", \"Deepslate Redstone Ore\", 20f));\n        defaultBlocks.put(\"block.minecraft.lapis_ore\", new BlockScoreConfig(\"block.minecraft.lapis_ore\", \"Lapis Ore\", 20f));\n        defaultBlocks.put(\"block.minecraft.deepslate_lapis_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_lapis_ore\", \"Deepslate Lapis Ore\", 30f));\n        defaultBlocks.put(\"block.minecraft.gold_ore\", new BlockScoreConfig(\"block.minecraft.gold_ore\", \"Gold Ore\", 30f));\n        defaultBlocks.put(\"block.minecraft.deepslate_gold_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_gold_ore\", \"Deepslate Gold Ore\", 50f));\n        defaultBlocks.put(\"block.minecraft.emerald_ore\", new BlockScoreConfig(\"block.minecraft.emerald_ore\", \"Emerald Ore\", 40f));\n        defaultBlocks.put(\"block.minecraft.deepslate_emerald_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_emerald_ore\", \"Deepslate Emerald Ore\", 60f));\n        defaultBlocks.put(\"block.minecraft.diamond_ore\", new BlockScoreConfig(\"block.minecraft.diamond_ore\", \"Diamond Ore\", 40f));\n        defaultBlocks.put(\"block.minecraft.deepslate_diamond_ore\", new BlockScoreConfig(\"block.minecraft.deepslate_diamond_ore\", \"Deepslate Diamond Ore\", 60f));\n    }\n\n    public MinetifaceConfig() {\n        blocksScore = new HashMap<>(defaultBlocks);\n    }\n", "    public static void loadConfig(Path configFolder) {\n        Path configPath = configFolder.resolve(CONFIG_NAME);\n        File config = configPath.toFile();\n        if (!config.exists()) {\n            LOGGER.warn(\"Config file missing, using defaults\");\n            INSTANCE = new MinetifaceConfig();\n            saveConfig(config);\n        } else {\n            try (FileInputStream in = new FileInputStream(config)) {\n                INSTANCE = MAPPER.readValue(in, MinetifaceConfig.class);\n", "                if (INSTANCE.blocksScore == null) {\n                    INSTANCE.blocksScore = new HashMap<>(defaultBlocks);\n                } else {\n                    for (Map.Entry<String, BlockScoreConfig> entry : defaultBlocks.entrySet()) {\n                        if (!INSTANCE.blocksScore.containsKey(entry.getKey())) {\n                            INSTANCE.blocksScore.put(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                LOGGER.error(\"Error while loading minetiface config file\", e);\n            }\n        }\n\n        executor.submit(() -> {\n            watchConfig(configFolder);\n        });\n    }\n\n    private static void reloadConfig(File configFile) {\n        try (FileInputStream in = new FileInputStream(configFile)) {\n            INSTANCE = MAPPER.readValue(in, MinetifaceConfig.class);\n", "            if (INSTANCE.blocksScore == null) {\n                INSTANCE.blocksScore = new HashMap<>(defaultBlocks);\n            } else {\n                for (Map.Entry<String, BlockScoreConfig> entry : defaultBlocks.entrySet()) {\n                    if (!INSTANCE.blocksScore.containsKey(entry.getKey())) {\n                        INSTANCE.blocksScore.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n            LOGGER.info(\"Config file reloaded\");\n        } catch (IOException e) {\n            LOGGER.error(\"Error while loading minetiface config file\", e);\n        }\n    }\n\n    private static void saveConfig(File config) {\n        try (FileOutputStream out = new FileOutputStream(config)) {\n            MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n            MAPPER.writeValue(out, INSTANCE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * We are watching config file for any extern modification\n     */\n    private static void watchConfig(Path configFolder) {\n\n        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n            configFolder.register(watcher, ENTRY_MODIFY);\n            WatchKey key;", "            for (; ; ) {\n\n                try {\n                    key = watcher.take();\n                } catch (InterruptedException x) {\n                    return;\n                }\n\n                for (WatchEvent<?> event : key.pollEvents()) {\n                    WatchEvent.Kind<?> kind = event.kind();\n\n                    // This key is registered only\n                    // for ENTRY_CREATE events,\n                    // but an OVERFLOW event can\n                    // occur regardless if events\n                    // are lost or discarded.", "                for (WatchEvent<?> event : key.pollEvents()) {\n                    WatchEvent.Kind<?> kind = event.kind();\n\n                    // This key is registered only\n                    // for ENTRY_CREATE events,\n                    // but an OVERFLOW event can\n                    // occur regardless if events\n                    // are lost or discarded.\n                    if (kind != ENTRY_MODIFY) {\n                        continue;\n                    }\n\n                    // The filename is the\n                    // context of the event.\n                    WatchEvent<Path> ev = (WatchEvent<Path>) event;", "                    if (kind != ENTRY_MODIFY) {\n                        continue;\n                    }\n\n                    // The filename is the\n                    // context of the event.\n                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n                    if (!ev.context().endsWith(CONFIG_NAME)) {\n                        continue;\n                    }\n                    LOGGER.info(\"Config file changed\");\n                    Path filename = ev.context();\n                    Path configFile = configFolder.resolve(filename);\n                    reloadConfig(configFile.toFile());\n                }\n\n                // Reset the key -- this step is critical if you want to\n                // receive further watch events.  If the key is no longer valid,\n                // the directory is inaccessible so exit the loop.\n                boolean valid = key.reset();", "                if (!valid) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Error while watching config file\", e);\n        }\n    }\n}\n"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/config/BlockScoreConfig.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.config;\n\npublic class BlockScoreConfig {\n\n    private String translationKey;\n    private String name;\n    private float score;\n\n    public BlockScoreConfig() {\n        // Used by jackson\n    }\n\n    public BlockScoreConfig(String translationKey, String name, float score) {\n        this.translationKey = translationKey;\n        this.name = name;\n        this.score = score;\n    }\n", "    public String getTranslationKey() {\n        return translationKey;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public float getScore() {\n        return score;\n    }\n", "    public float getScore() {\n        return score;\n    }\n\n    public void setScore(float score) {\n        this.score = score;\n    }\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/minecraft/block/Block.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.minecraft.block;\n\npublic abstract class Block {\n    public abstract String getDisplayName();\n\n    /**\n     * Name / id\n     */\n    public abstract  String getName();\n}\n", "    public abstract  String getName();\n}\n"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/AttackPointsCounter.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\n\npublic class AttackPointsCounter extends AbstractPointsCounter {\n\tpublic void onAttack(float amount) {\n\t\tif (!MinetifaceConfig.INSTANCE.attackEnabled) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\n\t\taddPoints(amount / 20 * MinetifaceConfig.INSTANCE.attackMultiplier);\n\t\taddInstantPoints(amount * 10 * MinetifaceConfig.INSTANCE.attackInstantPointsMultiplier);\n\t\taddSkipDownTick(amount * 10 * MinetifaceConfig.INSTANCE.attackDurationMultiplier);\n\t}\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/MasochistPointsCounter.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\n\npublic class MasochistPointsCounter extends AbstractPointsCounter {\n\n\tpublic void onHurt(float health) {\n\t\tif (!MinetifaceConfig.INSTANCE.masochistEnabled) {\n\t\t\tsuper.reset();\n\t\t\treturn;\n\t\t}\n", "\t\tif (health == 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\taddSkipDownTick(health * 10 * MinetifaceConfig.INSTANCE.masochistDurationMultiplier);\n\t\taddInstantPoints(health * MinetifaceConfig.INSTANCE.masochistInstantPointsMultiplier);\n\t\taddPoints(health * MinetifaceConfig.INSTANCE.masochistMultiplier);\n\t}\n\n\tpublic void onDeath() {\n\t\tif (!MinetifaceConfig.INSTANCE.masochistEnabled) {\n\t\t\tsuper.reset();\n\t\t\treturn;\n\t\t}\n\n\t\taddSkipDownTick(100 * MinetifaceConfig.INSTANCE.masochistDurationMultiplier);\n\t\taddInstantPoints(50 * MinetifaceConfig.INSTANCE.masochistInstantPointsMultiplier);\n\t\taddPoints(50 * MinetifaceConfig.INSTANCE.masochistMultiplier);\n\t}\n\n\t@Override", "\tpublic void onDeath() {\n\t\tif (!MinetifaceConfig.INSTANCE.masochistEnabled) {\n\t\t\tsuper.reset();\n\t\t\treturn;\n\t\t}\n\n\t\taddSkipDownTick(100 * MinetifaceConfig.INSTANCE.masochistDurationMultiplier);\n\t\taddInstantPoints(50 * MinetifaceConfig.INSTANCE.masochistInstantPointsMultiplier);\n\t\taddPoints(50 * MinetifaceConfig.INSTANCE.masochistMultiplier);\n\t}\n\n\t@Override", "\tpublic void reset() {\n\t\t// Overriding reset because it is called when player died\n\t}\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/ToyController.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;", "import java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugClientDevice;\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugClientWSClient;\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugDeviceException;", "import io.github.blackspherefollower.buttplug4j.client.ButtplugClientWSClient;\nimport io.github.blackspherefollower.buttplug4j.client.ButtplugDeviceException;\n\npublic class ToyController {\n\tprivate static final ToyController instance = new ToyController();\n\tprivate static final Logger LOGGER = LogManager.getLogger();\n\n\tprivate final ButtplugClientWSClient client;\n\tprivate List<ButtplugClientDevice> devices;\n\tprivate boolean connected = false;\n\n", "\tpublic static ToyController instance() {\n\t\treturn instance;\n\t}\n\n\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\n\tprivate ToyController() {\n\t\tdevices = new ArrayList<>();\n\t\tclient = new ButtplugClientWSClient(\"mInetiface\");\n\t}\n", "\tpublic boolean isConnected() {\n\t\treturn connected;\n\t}\n\n\tpublic void connectServer() throws URISyntaxException, Exception {\n\t\tLOGGER.info(\"URL: \" + MinetifaceConfig.INSTANCE.serverUrl);\n\t\tclient.connect(new URI(\"ws://\" + MinetifaceConfig.INSTANCE.serverUrl + \"/buttplug\"));\n\t\tconnected = true;\n\t}\n\n\tpublic void disconnectServer() {\n\t\tsetScalarLevel(0);\n\t\tclient.disconnect();\n\t\tconnected = false;\n\t}\n\n\tpublic Future<List<ButtplugClientDevice>> scanDevices() throws Exception {\n\t\tclient.startScanning();\n\n\t\treturn executor.submit(() -> {", "\tpublic void disconnectServer() {\n\t\tsetScalarLevel(0);\n\t\tclient.disconnect();\n\t\tconnected = false;\n\t}\n\n\tpublic Future<List<ButtplugClientDevice>> scanDevices() throws Exception {\n\t\tclient.startScanning();\n\n\t\treturn executor.submit(() -> {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tclient.requestDeviceList();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(\"Could not get devices list\", e);\n\t\t\t}\n\n\t\t\tdevices = client.getDevices();\n\t\t\tclient.stopScanning();\n\n\t\t\treturn devices;\n\t\t});\n\t}\n\n\t/**\n\t * Get the list of devices to be displayed\n\t */", "\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tclient.requestDeviceList();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(\"Could not get devices list\", e);\n\t\t\t}\n\n\t\t\tdevices = client.getDevices();\n\t\t\tclient.stopScanning();\n\n\t\t\treturn devices;\n\t\t});\n\t}\n\n\t/**\n\t * Get the list of devices to be displayed\n\t */", "\tpublic String getDevicesString() {\n\t\tStringBuilder devicesStr = new StringBuilder();\n\t\tint count = 1;\n\t\tfor (ButtplugClientDevice buttplugClientDevice : devices) {\n\t\t\tdevicesStr.append(buttplugClientDevice.getName());\n\t\t\tif (count++ < devices.size()) {\n\t\t\t\tdevicesStr.append(\", \");\n\t\t\t}\n\t\t}\n\t\treturn devicesStr.toString();\n\t}\n", "\tpublic void setScalarLevel(double level) {\n\t\ttry {\n\t\t\tfor (ButtplugClientDevice device : devices) {\n\t\t\t\tif (device.getScalarVibrateCount() > 0) {\n\t\t\t\t\tdevice.sendScalarVibrateCmd(level);\n\t\t\t\t}\n\t\t\t\tif (device.getScalarRotateCount() > 0) {\n\t\t\t\t\tdevice.sendScalarRotateCmd(level);\n\t\t\t\t}\n\t\t\t\tif (device.getScalarOscillateCount() > 0) {\n\t\t\t\t\tdevice.sendScalarOscillateCmd(level);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ButtplugDeviceException e) {\n\t\t\tLOGGER.error(\"Could not send scalar command\", e);\n\t\t}\n\t}\n\n\tprivate double currentPosition = 1;\n\tprivate long lastLinearCommandTimestamp = 0;\n\tprivate long lastLinearCommandDuration = 0;\n\tprivate double lastLinearPosition = 1;\n", "\t\t\t\tif (device.getScalarOscillateCount() > 0) {\n\t\t\t\t\tdevice.sendScalarOscillateCmd(level);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ButtplugDeviceException e) {\n\t\t\tLOGGER.error(\"Could not send scalar command\", e);\n\t\t}\n\t}\n\n\tprivate double currentPosition = 1;\n\tprivate long lastLinearCommandTimestamp = 0;\n\tprivate long lastLinearCommandDuration = 0;\n\tprivate double lastLinearPosition = 1;\n", "\t// public void setLinearLevel(double level) {\n\n\t// \tlong currentTime = new Date().getTime();\n\t// \tlong timeSinceLastCmd = currentTime - lastLinearCommandTimestamp;\n\n\t// \tif (timeSinceLastCmd < MinetifaceConfig.INSTANCE.minTimeBetweenCmd) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tlong duration;\n\t// \tif (timeSinceLastCmd >= lastLinearCommandDuration) {\n\t// \t\t// Last command is completed so we can invert the position\n\t// \t\tlastLinearPosition = currentPosition;\n\t// \t\tcurrentPosition = currentPosition == 0 ? 1 : 0;\n\n\t// \t\t// Calculating time to move depending on the level (0 min intensity, 1 max intensity)\n\t// \t\tduration = (long) (MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level);\n\t// \t} else {\n\t// \t\t// Last command is not completed, so we are still aiming the same position\n\t// \t\t// but we are updating the duration (speed)\n\n\t// \t\t// We are trying to compute the real position\n\t// \t\tdouble percentDone = (double) timeSinceLastCmd / (double) lastLinearCommandDuration;\n\t// \t\tdouble newPosition = currentPosition == 1 ? lastLinearPosition + percentDone : lastLinearPosition - percentDone;\n\t// \t\tdouble percentRemaining = currentPosition == 1 ? 1 - newPosition : newPosition;\n\n\t// \t\tduration = (long) ((MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level) * percentRemaining);\n\t// \t\tlastLinearPosition = newPosition;\n\t// \t}\n\n\t// \tlastLinearCommandTimestamp = currentTime;\n\t// \tlastLinearCommandDuration = duration;\n", "\t// \tif (timeSinceLastCmd >= lastLinearCommandDuration) {\n\t// \t\t// Last command is completed so we can invert the position\n\t// \t\tlastLinearPosition = currentPosition;\n\t// \t\tcurrentPosition = currentPosition == 0 ? 1 : 0;\n\n\t// \t\t// Calculating time to move depending on the level (0 min intensity, 1 max intensity)\n\t// \t\tduration = (long) (MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level);\n\t// \t} else {\n\t// \t\t// Last command is not completed, so we are still aiming the same position\n\t// \t\t// but we are updating the duration (speed)\n\n\t// \t\t// We are trying to compute the real position\n\t// \t\tdouble percentDone = (double) timeSinceLastCmd / (double) lastLinearCommandDuration;\n\t// \t\tdouble newPosition = currentPosition == 1 ? lastLinearPosition + percentDone : lastLinearPosition - percentDone;\n\t// \t\tdouble percentRemaining = currentPosition == 1 ? 1 - newPosition : newPosition;\n\n\t// \t\tduration = (long) ((MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level) * percentRemaining);\n\t// \t\tlastLinearPosition = newPosition;\n\t// \t}\n\n\t// \tlastLinearCommandTimestamp = currentTime;\n\t// \tlastLinearCommandDuration = duration;\n", "\t// \ttry {\n\t// \t\tfor (ButtplugClientDevice device : devices) {\n\t// \t\t\tif (device.getLinearCount() > 0) {\n\t// \t\t\t\tdevice.sendLinearCmd(currentPosition, duration);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t} catch (ButtplugDeviceException e) {\n\t// \t\tLOGGER.error(\"Could not send linear command\", e);\n\t// \t}\n\t// }\n", "\tpublic void setLinearLevel(double level) {\n\t\tif (level <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong currentTime = new Date().getTime();\n\t\tlong timeSinceLastCmd = currentTime - lastLinearCommandTimestamp;\n\n\t\tif (timeSinceLastCmd < lastLinearCommandDuration) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong duration;\n\n\t\t// Last command is completed so we can invert the position\n\t\tcurrentPosition = currentPosition == 0 ? 1 : 0;\n\n\t\t// Calculating time to move depending on the level (0 min intensity, 1 max intensity)\n\t\tduration = (long) (MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level);\n\n\t\tlastLinearCommandTimestamp = currentTime;\n\t\tlastLinearCommandDuration = duration;\n", "\t\tif (timeSinceLastCmd < lastLinearCommandDuration) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong duration;\n\n\t\t// Last command is completed so we can invert the position\n\t\tcurrentPosition = currentPosition == 0 ? 1 : 0;\n\n\t\t// Calculating time to move depending on the level (0 min intensity, 1 max intensity)\n\t\tduration = (long) (MinetifaceConfig.INSTANCE.fullMaxTime - (MinetifaceConfig.INSTANCE.fullMaxTime - MinetifaceConfig.INSTANCE.fullMinTime) * level);\n\n\t\tlastLinearCommandTimestamp = currentTime;\n\t\tlastLinearCommandDuration = duration;\n", "\t\ttry {\n\t\t\tfor (ButtplugClientDevice device : devices) {\n\t\t\t\tif (device.getLinearCount() > 0) {\n\t\t\t\t\tdevice.sendLinearCmd(currentPosition, duration);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ButtplugDeviceException e) {\n\t\t\tLOGGER.error(\"Could not send linear command\", e);\n\t\t}\n\t}\n", "\t// public double getLinearPosition() {\n\t// \tlong currentTime = new Date().getTime();\n\t// \tlong timeSinceLastCmd = currentTime - lastLinearCommandTimestamp;\n\n\t// \tdouble percentDone;\n\t// \tif (timeSinceLastCmd > lastLinearCommandDuration) {\n\t// \t\tpercentDone = 1;\n\t// \t} else {\n\t// \t\tpercentDone = (double) timeSinceLastCmd / (double) lastLinearCommandDuration;\n\t// \t}\n\n\t// \tpercentDone = currentPosition == 1 ? (1 - lastLinearPosition) * percentDone : lastLinearPosition * percentDone;\n\n\t// \treturn currentPosition == 1 ? lastLinearPosition + percentDone : lastLinearPosition - percentDone;\n\t// }\n", "\tpublic double getLinearPosition() {\n\t\tlong currentTime = new Date().getTime();\n\t\tlong timeSinceLastCmd = currentTime - lastLinearCommandTimestamp;\n\n\t\tdouble percentDone;\n\t\tif (timeSinceLastCmd > lastLinearCommandDuration) {\n\t\t\tpercentDone = 1;\n\t\t} else {\n\t\t\tpercentDone = (double) timeSinceLastCmd / (double) lastLinearCommandDuration;\n\t\t}\n\n\t\treturn currentPosition == 1 ? percentDone : 1 - percentDone;\n\t}\n}\n"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/MiningPointsCounter.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MiningPointsCounter extends AbstractPointsCounter {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(MiningPointsCounter.class);\n", "\tpublic void onBreak(String blockId) {\n\t\tif (!MinetifaceConfig.INSTANCE.miningEnabled) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\n\t\tFloat blockValue = null;\n\t\tif (MinetifaceConfig.INSTANCE.blocksScore.containsKey(blockId)) {\n\t\t\tblockValue = MinetifaceConfig.INSTANCE.blocksScore.get(blockId)\n\t\t\t\t\t.getScore();\n\t\t}\n\n\t\tLOGGER.info(\"Value {}\", blockValue);\n", "\t\tif (blockValue == null) {\n\t\t\tblockValue = MinetifaceConfig.INSTANCE.defaultBlockScore;\n\t\t}\n\n\t\taddSkipDownTick(blockValue * 20 * MinetifaceConfig.INSTANCE.mineDurationMultiplier);\n\t\taddInstantPoints(blockValue * 5 * MinetifaceConfig.INSTANCE.mineInstantPointsMultiplier);\n\t\taddPoints(blockValue / 10 * MinetifaceConfig.INSTANCE.minePointsMultiplier);\n\t}\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/ExperienceCounter.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\n\npublic class ExperienceCounter extends AbstractPointsCounter {\n\n\tprivate int lastLevel;\n\n\tpublic ExperienceCounter() {\n\t\tsuper();\n\t\tlastLevel = -1;\n\t}\n", "\tpublic void onXpChange(float progress, int total, int level) {\n\t\tif (!MinetifaceConfig.INSTANCE.xpEnabled) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\n\t\tif (lastLevel == -1) {\n\t\t\tlastLevel = level;\n\t\t\treturn;\n\t\t}\n\n\t\tboolean levelChanged = lastLevel != level;\n\t\tlastLevel = level;\n", "\t\tif (levelChanged) {\n\t\t\ttotal *= 2;\n\t\t}\n\n\t\taddSkipDownTick(total * MinetifaceConfig.INSTANCE.xpDurationMultiplier / 10);\n\t\taddInstantPoints(total * MinetifaceConfig.INSTANCE.xpInstantPointsMultiplier / 10);\n\t\taddPoints(0.5f * MinetifaceConfig.INSTANCE.xpMultiplier);\n\t}\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/AbstractPointsCounter.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\n\npublic abstract class AbstractPointsCounter {\n\n\tprotected float points;\n\tprotected float instantPoints;\n\tprotected int skipDownTick;\n\n\tprotected AbstractPointsCounter() {\n\t\tpoints = 0;\n\t\tinstantPoints = 0;\n\t\tskipDownTick = 0;\n\t}\n\n\t/**\n\t * This method will be called every tick by the controller\n\t */", "\tpublic void onTick() {\n\n\t\tskipDownTick = Math.max(skipDownTick - 1, 0);\n\n\t\tif (skipDownTick <= 0) {\n\t\t\tpoints = Math.max(0, points - MinetifaceConfig.INSTANCE.scoreLostPerTick);\n\t\t}\n\n\t\tinstantPoints = Math.max(0f, instantPoints - MinetifaceConfig.INSTANCE.feedbackScoreLostPerTick);\n\t}\n\n\t/**\n\t * This method will be called when the player died for example\n\t */", "\tpublic void reset() {\n\t\tpoints = 0;\n\t\tinstantPoints = 0;\n\t\tskipDownTick = 0;\n\t}\n\n\tpublic float getPoints() {\n\t\treturn points;\n\t}\n\n\tpublic float getInstantPoints() {\n\t\treturn instantPoints;\n\t}\n", "\tpublic float getInstantPoints() {\n\t\treturn instantPoints;\n\t}\n\n\tpublic int getSkipDownTicks() {\n\t\treturn skipDownTick;\n\t}\n\n\tprotected void addSkipDownTick(float value) {\n\t\tskipDownTick = (int) Math.min(skipDownTick + value, MinetifaceConfig.INSTANCE.maximumSecondsKeepScore * 20);\n\t}\n\n\tprotected void addInstantPoints(float value) {\n\t\tinstantPoints = Math.max(Math.min(instantPoints + value, MinetifaceConfig.INSTANCE.maximumFeedback), MinetifaceConfig.INSTANCE.minimumFeedback);\n\t}\n\n\tprotected void addPoints(float value) {\n\t\tpoints = Math.min(points + value, MinetifaceConfig.INSTANCE.maximumScore);\n\t}\n}"]}
{"filename": "commons/src/main/java/fr/fyustorm/minetiface/commons/intiface/MinetifaceController.java", "chunked_list": ["package fr.fyustorm.minetiface.commons.intiface;\n\nimport fr.fyustorm.minetiface.commons.config.MinetifaceConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MinetifaceController {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceController.class);\n\tprivate static final int TICKS_PER_SECOND = 20;\n\tprivate final List<AbstractPointsCounter> listPointsCounter;\n\tprivate final MiningPointsCounter miningPointsCounter;\n\tprivate final AttackPointsCounter attackPointsCounter;\n\tprivate final MasochistPointsCounter masochistPointsCounter;\n\tprivate final ExperienceCounter experienceCounter;\n\n\tprivate static final MinetifaceController instance;\n\n\tprivate long playerTick;\n\tprivate long clientTick;\n\tprivate boolean paused;\n\n\tstatic {\n\t\tinstance = new MinetifaceController();\n\t}\n", "\npublic class MinetifaceController {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(MinetifaceController.class);\n\tprivate static final int TICKS_PER_SECOND = 20;\n\tprivate final List<AbstractPointsCounter> listPointsCounter;\n\tprivate final MiningPointsCounter miningPointsCounter;\n\tprivate final AttackPointsCounter attackPointsCounter;\n\tprivate final MasochistPointsCounter masochistPointsCounter;\n\tprivate final ExperienceCounter experienceCounter;\n\n\tprivate static final MinetifaceController instance;\n\n\tprivate long playerTick;\n\tprivate long clientTick;\n\tprivate boolean paused;\n\n\tstatic {\n\t\tinstance = new MinetifaceController();\n\t}\n", "\tpublic static MinetifaceController getInstance() {\n\t\treturn instance;\n\t}\n\n\tprivate MinetifaceController() {\n\t\tplayerTick = -1;\n\t\tclientTick = -1;\n\t\tpaused = false;\n\n\t\tlistPointsCounter = new ArrayList<>();\n\n\t\tminingPointsCounter = new MiningPointsCounter();\n\t\tattackPointsCounter = new AttackPointsCounter();\n\t\tmasochistPointsCounter = new MasochistPointsCounter();\n\t\texperienceCounter = new ExperienceCounter();\n\n\t\tlistPointsCounter.add(miningPointsCounter);\n\t\tlistPointsCounter.add(attackPointsCounter);\n\t\tlistPointsCounter.add(masochistPointsCounter);\n\t\tlistPointsCounter.add(experienceCounter);\n\t}\n", "\tpublic float getIntensity() {\n\t\tfloat points = getPoints();\n\t\tfloat instantPoints = getInstantPoints();\n\n\t\tLOGGER.trace(\"Points {} Instant {}\", points, instantPoints);\n\n\t\treturn Math.min((points + instantPoints) / 100f, 1f);\n\t}\n\n\tpublic float getInstantPoints() {\n\n\t\tfloat instanPoints = 0f;", "\tpublic float getInstantPoints() {\n\n\t\tfloat instanPoints = 0f;\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tinstanPoints = Math.max(abstractPointsCounter.getInstantPoints(), instanPoints);\n\t\t}\n\t\treturn instanPoints;\n\t}\n\n\tpublic float getPoints() {\n\t\tfloat points = 0f;", "\tpublic float getPoints() {\n\t\tfloat points = 0f;\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tpoints = Math.max(abstractPointsCounter.getPoints(), points);\n\t\t}\n\t\treturn points;\n\t}\n\n\tpublic int getSkipDownTicks() {\n\t\tint skipDownTick = 0;\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tskipDownTick += abstractPointsCounter.getSkipDownTicks();\n\t\t}\n\t\treturn skipDownTick;\n\t}\n\n\t/**\n\t * Reset all points counters\n\t */", "\tpublic int getSkipDownTicks() {\n\t\tint skipDownTick = 0;\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tskipDownTick += abstractPointsCounter.getSkipDownTicks();\n\t\t}\n\t\treturn skipDownTick;\n\t}\n\n\t/**\n\t * Reset all points counters\n\t */", "\tpublic void reset() {\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tabstractPointsCounter.reset();\n\t\t}\n\t}\n\n\tpublic void onPlayerTick() {\n\t\tplayerTick = ++playerTick % (20 * (60 * TICKS_PER_SECOND));\n\n\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tabstractPointsCounter.onTick();\n\t\t}\n\n\t\tfloat intensity = getIntensity();\n\t\tToyController.instance().setScalarLevel(intensity);\n", "\t\tfor (AbstractPointsCounter abstractPointsCounter : listPointsCounter) {\n\t\t\tabstractPointsCounter.onTick();\n\t\t}\n\n\t\tfloat intensity = getIntensity();\n\t\tToyController.instance().setScalarLevel(intensity);\n\n\t\tif (getPoints() > 0 || getInstantPoints() > MinetifaceConfig.INSTANCE.minimumFeedback) {\n\t\t\tToyController.instance().setLinearLevel(intensity);\n\t\t}\n\t}\n", "\tpublic void onDamage(float amount) {\n\t\tLOGGER.debug(\"On damage. Amount {}\", amount);\n\t\tattackPointsCounter.onAttack(amount);\n\t}\n\n\tpublic void onHurt(float amount) {\n\t\tLOGGER.debug(\"On hurt. Amount {}\", amount);\n\t\tmasochistPointsCounter.onHurt(amount);\n\t}\n\n\tpublic void onDeath() {\n\t\tLOGGER.debug(\"Player died\");\n\t\treset();\n\t\tmasochistPointsCounter.onDeath();\n\t}\n\n\t/**\n\t * On break event\n\t * @param blockId breaked block\n\t */", "\tpublic void onDeath() {\n\t\tLOGGER.debug(\"Player died\");\n\t\treset();\n\t\tmasochistPointsCounter.onDeath();\n\t}\n\n\t/**\n\t * On break event\n\t * @param blockId breaked block\n\t */\n\tpublic void onBreak(String blockId) {\n\t\tLOGGER.info(\"Block break {}\", blockId);\n\t\tminingPointsCounter.onBreak(blockId);\n\t}\n", "\tpublic void onBreak(String blockId) {\n\t\tLOGGER.info(\"Block break {}\", blockId);\n\t\tminingPointsCounter.onBreak(blockId);\n\t}\n\n\tpublic void onClientTick() {\n\t\t// Handle when game is paused\n\t\tif (playerTick >= 0) {\n\t\t\tif (clientTick != playerTick) {\n\t\t\t\tclientTick = playerTick;\n\t\t\t\tpaused = false;\n\t\t\t} else {", "\t\t\tif (clientTick != playerTick) {\n\t\t\t\tclientTick = playerTick;\n\t\t\t\tpaused = false;\n\t\t\t} else {\n\t\t\t\tif (!paused) {\n\t\t\t\t\tpaused = true;\n\t\t\t\t\tLOGGER.debug(\"Paused\");\n\t\t\t\t\tToyController.instance().setScalarLevel(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n", "\tpublic void onXpChange(float progress, int total, int level) {\n\t\tLOGGER.debug(\"Xp changed. Progress {} Total {} Level {}\", progress, total, level);\n\t\texperienceCounter.onXpChange(progress, total, level);\n\t}\n}\n"]}
