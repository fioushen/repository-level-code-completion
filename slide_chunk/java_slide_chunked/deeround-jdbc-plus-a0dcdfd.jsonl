{"filename": "jdbc-plus-samples/src/test/java/com/github/deeround/jdbc/plus/samples/Tests.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples;\n\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageInfo;\nimport com.github.deeround.jdbc.plus.samples.domain.TestUser;\nimport com.github.deeround.jdbc.plus.samples.service.JdbcTemplateTestService;\nimport com.github.deeround.jdbc.plus.samples.service.TestUserService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;", "import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Map;\n", "import java.util.Map;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/3/1 9:34\n */\n@Slf4j\n@SpringBootTest\npublic class Tests {\n\n    /**\n     * jdbc-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private JdbcTemplateTestService jdbcTemplateTestService;\n\n    /**\n     * mybatis-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private TestUserService testUserService;\n\n    @Test\n    void testPage123() {\n        PageInfo<Map<String, Object>> page1 = this.jdbcTemplateTestService.page1();\n        PageInfo<Map<String, Object>> page2 = this.jdbcTemplateTestService.page2();\n        PageInfo<Map<String, Object>> page3 = this.jdbcTemplateTestService.page3();\n        System.out.println(page1);\n        System.out.println(page2);\n        System.out.println(page3);\n    }\n\n    @Test\n    void testTenantInsert() {\n        this.jdbcTemplateTestService.insert();\n    }\n\n    @Test\n    void testTenantUpdate() {\n        this.jdbcTemplateTestService.update();\n    }\n\n    @Test\n    void testTenantDelete() {\n        this.jdbcTemplateTestService.delete();\n    }\n\n    @Test\n    void testTenantQuery() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.query();\n        System.out.println(list1);\n    }\n\n    @Test\n    void testCreateTable() {\n        this.jdbcTemplateTestService.createTable();\n    }\n\n    @Test\n    void testBatchUpdate() {\n        this.jdbcTemplateTestService.batchUpdate();\n    }\n\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n    /**\n     * \u666e\u901a\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testQueryWithMp() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.query();\n        List<TestUser> list2 = this.testUserService.list();\n        System.out.println(list1);\n        System.out.println(list2);\n    }\n\n    /**\n     * \u5206\u9875\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testPageWithMp() {\n        PageInfo<Map<String, Object>> page1 = this.jdbcTemplateTestService.page1();\n        Page<TestUser> page2 = this.testUserService.page(new Page<TestUser>(1, 2));\n        log.info(\"total:{},records:{},page1:{}\", page1.getTotal(), page1.getList().size(), page1.getList());\n        log.info(\"total:{},records:{},page2:{}\", page2.getTotal(), page2.getRecords().size(), page2.getRecords());\n    }\n\n    /**\n     * \u6761\u4ef6\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testQueryByConditionWithMp() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.getListByCondition(\"3\");\n        List<TestUser> list2 = this.testUserService.getListByCondition(\"3\");\n        System.out.println(list1);\n        System.out.println(list2);\n    }\n\n    @Test\n    void testMethod() throws Exception {\n        Class<?> clazz = JdbcTemplate.class;\n        Method query1 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n        Method query2 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n        Method query3 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n\n        System.out.println(query1.hashCode());\n        System.out.println(query2.hashCode());\n        System.out.println(query3.hashCode());\n    }\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n}\n", "public class Tests {\n\n    /**\n     * jdbc-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private JdbcTemplateTestService jdbcTemplateTestService;\n\n    /**\n     * mybatis-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private TestUserService testUserService;\n\n    @Test\n    void testPage123() {\n        PageInfo<Map<String, Object>> page1 = this.jdbcTemplateTestService.page1();\n        PageInfo<Map<String, Object>> page2 = this.jdbcTemplateTestService.page2();\n        PageInfo<Map<String, Object>> page3 = this.jdbcTemplateTestService.page3();\n        System.out.println(page1);\n        System.out.println(page2);\n        System.out.println(page3);\n    }\n\n    @Test\n    void testTenantInsert() {\n        this.jdbcTemplateTestService.insert();\n    }\n\n    @Test\n    void testTenantUpdate() {\n        this.jdbcTemplateTestService.update();\n    }\n\n    @Test\n    void testTenantDelete() {\n        this.jdbcTemplateTestService.delete();\n    }\n\n    @Test\n    void testTenantQuery() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.query();\n        System.out.println(list1);\n    }\n\n    @Test\n    void testCreateTable() {\n        this.jdbcTemplateTestService.createTable();\n    }\n\n    @Test\n    void testBatchUpdate() {\n        this.jdbcTemplateTestService.batchUpdate();\n    }\n\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n    /**\n     * \u666e\u901a\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testQueryWithMp() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.query();\n        List<TestUser> list2 = this.testUserService.list();\n        System.out.println(list1);\n        System.out.println(list2);\n    }\n\n    /**\n     * \u5206\u9875\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testPageWithMp() {\n        PageInfo<Map<String, Object>> page1 = this.jdbcTemplateTestService.page1();\n        Page<TestUser> page2 = this.testUserService.page(new Page<TestUser>(1, 2));\n        log.info(\"total:{},records:{},page1:{}\", page1.getTotal(), page1.getList().size(), page1.getList());\n        log.info(\"total:{},records:{},page2:{}\", page2.getTotal(), page2.getRecords().size(), page2.getRecords());\n    }\n\n    /**\n     * \u6761\u4ef6\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testQueryByConditionWithMp() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.getListByCondition(\"3\");\n        List<TestUser> list2 = this.testUserService.getListByCondition(\"3\");\n        System.out.println(list1);\n        System.out.println(list2);\n    }\n\n    @Test\n    void testMethod() throws Exception {\n        Class<?> clazz = JdbcTemplate.class;\n        Method query1 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n        Method query2 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n        Method query3 = clazz.getMethod(\"query\", String.class, RowMapper.class);\n\n        System.out.println(query1.hashCode());\n        System.out.println(query2.hashCode());\n        System.out.println(query3.hashCode());\n    }\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/test/java/com/github/deeround/jdbc/plus/samples/TestDynamicTableName.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples;\n\nimport com.github.deeround.jdbc.plus.samples.domain.TestLog;\nimport com.github.deeround.jdbc.plus.samples.service.JdbcTemplateTestService;\nimport com.github.deeround.jdbc.plus.samples.service.TestLogService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n", "import org.springframework.boot.test.context.SpringBootTest;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * \u52a8\u6001\u8868\u540d\u6d4b\u8bd5\u7c7b\n *\n * @author wanghao 913351190@qq.com\n * @create 2023/3/1 9:34", " * @author wanghao 913351190@qq.com\n * @create 2023/3/1 9:34\n */\n@Slf4j\n@SpringBootTest\npublic class TestDynamicTableName {\n\n    /**\n     * jdbc-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private JdbcTemplateTestService jdbcTemplateTestService;\n\n    /**\n     * mybatis-plus \u6d4b\u8bd5service\n     */\n    @Autowired\n    private TestLogService testLogService;\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n    /**\n     * \u52a8\u6001\u8868\u540d\u67e5\u8be2\uff1ajdbc-plus\u548cmybatis-plus\u67e5\u8be2\u4f7f\u7528\u5bf9\u6bd4\n     */\n    @Test\n    void testQueryWithMp() {\n        List<Map<String, Object>> list1 = this.jdbcTemplateTestService.getTestLogList();\n        List<TestLog> list2 = this.testLogService.list();\n        System.out.println(list1);\n        System.out.println(list2);\n    }\n\n    //======================jdbc-plus\u548cmybatis-plus\u4f7f\u7528\u5bf9\u6bd4==============================\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/test/java/com/github/deeround/jdbc/plus/samples/service/PageServiceTest.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/18 9:19\n */", " * @create 2023/7/18 9:19\n */\n@SpringBootTest\npublic class PageServiceTest {\n\n    @Autowired\n    TestAllService testAllService;\n\n    @Test\n    void test() {\n        this.testAllService.BATCHUPDATE_SQL_PSS();\n        this.testAllService.BATCHUPDATE_SQL_BATCHARGS();\n        this.testAllService.BATCHUPDATE_SQL_BATCHARGS_ARGTYPES();\n        this.testAllService.BATCHUPDATE_SQL();\n        this.testAllService.UPDATE_SQL();\n        this.testAllService.UPDATE_SQL_ARGS();\n        this.testAllService.UPDATE_SQL_ARGS();\n        this.testAllService.UPDATE_SQL_PSS();\n        this.testAllService.QUERY_SQL_ARGS_ARGTYPES_RSE();\n        this.testAllService.QUERY_SQL_ARGS_ARGTYPES_RCH();\n        this.testAllService.QUERY_SQL_ARGS_ARGTYPES_ROWMAPPER();\n        this.testAllService.QUERY_SQL_ARGS_RSE();\n        this.testAllService.QUERY_SQL_ARGS_RCH();\n        this.testAllService.QUERY_SQL_ARGS_ROWMAPPER();\n        this.testAllService.QUERY_SQL_PSS_RSE();\n        this.testAllService.QUERY_SQL_PSS_RCH();\n        this.testAllService.QUERY_SQL_PSS_ROWMAPPER();\n        this.testAllService.QUERY_SQL_RSE();\n        this.testAllService.QUERY_SQL_RSE_ARGS();\n        this.testAllService.QUERY_SQL_RCH();\n        this.testAllService.QUERY_SQL_RCH_ARGS();\n        this.testAllService.QUERY_SQL_ROWMAPPER();\n        this.testAllService.QUERY_SQL_ROWMAPPER_ARGS();\n        this.testAllService.QUERYFORLIST_SQL();\n        this.testAllService.QUERYFORSTREAM_SQL_ROWMAPPER_ARGS();\n    }\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/SamplesMainApplication.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/2/28 17:31\n */\n@SpringBootApplication\npublic class SamplesMainApplication {", " */\n@SpringBootApplication\npublic class SamplesMainApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SamplesMainApplication.class, args);\n    }\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/domain/TestUser.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.domain;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport java.io.Serializable;\nimport lombok.Data;\n\n/**", "\n/**\n * \n * @TableName test_user\n */\n@TableName(value =\"test_user\")\n@Data\npublic class TestUser implements Serializable {\n    /**\n     * \n     */\n    @TableId\n    private String id;\n\n    /**\n     * \n     */\n    private String name;\n\n    /**\n     * \n     */\n    private String tenantId;\n\n    @TableField(exist = false)\n    private static final long serialVersionUID = 1L;\n}"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/domain/TestLog.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.domain;\n\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n/**", "\n/**\n * @TableName test_log\n */\n@TableName(value = \"test_log\")\n@Data\npublic class TestLog implements Serializable {\n    /**\n     *\n     */\n    @TableId\n    private String id;\n\n    /**\n     *\n     */\n    private String name;\n\n    /**\n     *\n     */\n    private String tenantId;\n\n    @TableField(exist = false)\n    private static final long serialVersionUID = 1L;\n}"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/config/MybatisPlusConfiguration.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.handler.TenantLineHandler;\nimport com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.inner.TenantLineInnerInterceptor;\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.StringValue;\nimport org.mybatis.spring.annotation.MapperScan;", "import net.sf.jsqlparser.expression.StringValue;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2022/6/6 14:09", " * @author wanghao 913351190@qq.com\n * @create 2022/6/6 14:09\n */\n@Configuration\n@MapperScan(value = {\"com.github.deeround.jdbc.plus.samples.mapper\"})\npublic class MybatisPlusConfiguration {\n\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n\n        //\u591a\u79df\u6237\u63d2\u4ef6\n        interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {\n            /**\n             * \u5f53\u524d\u79df\u6237ID\n             */\n            @Override", "    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n\n        //\u591a\u79df\u6237\u63d2\u4ef6\n        interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {\n            /**\n             * \u5f53\u524d\u79df\u6237ID\n             */\n            @Override\n            public Expression getTenantId() {\n                String currentTenantId = \"test_tenant_1\";//\u53ef\u4ee5\u4ece\u8bf7\u6c42\u4e0a\u4e0b\u6587\u4e2d\u83b7\u53d6\uff08cookie\u3001session\u3001header\u7b49\uff09\n                return new StringValue(currentTenantId);\n            }\n\n            /**\n             * \u79df\u6237\u5b57\u6bb5\u540d\n             */\n            @Override", "            public Expression getTenantId() {\n                String currentTenantId = \"test_tenant_1\";//\u53ef\u4ee5\u4ece\u8bf7\u6c42\u4e0a\u4e0b\u6587\u4e2d\u83b7\u53d6\uff08cookie\u3001session\u3001header\u7b49\uff09\n                return new StringValue(currentTenantId);\n            }\n\n            /**\n             * \u79df\u6237\u5b57\u6bb5\u540d\n             */\n            @Override\n            public String getTenantIdColumn() {\n                return \"tenant_id\";\n            }\n\n            /**\n             * \u6839\u636e\u8868\u540d\u5224\u65ad\u662f\u5426\u5ffd\u7565\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n             */\n            @Override", "            public String getTenantIdColumn() {\n                return \"tenant_id\";\n            }\n\n            /**\n             * \u6839\u636e\u8868\u540d\u5224\u65ad\u662f\u5426\u5ffd\u7565\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n             */\n            @Override\n            public boolean ignoreTable(String tableName) {\n                return false;\n            }\n        }));\n\n\n        //\u52a8\u6001\u8868\u540d\u63d2\u4ef6\n        DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor();\n        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -> {", "            public boolean ignoreTable(String tableName) {\n                return false;\n            }\n        }));\n\n\n        //\u52a8\u6001\u8868\u540d\u63d2\u4ef6\n        DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor();\n        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -> {\n            if (\"test_log\".equals(tableName)) {\n                return tableName + \"_\" + LocalDateTime.now().getYear();\n            }\n            return tableName;\n        });\n        interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);\n\n\n        //\u5206\u9875\u63d2\u4ef6\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n\n\n        return interceptor;\n    }\n\n}\n", "            if (\"test_log\".equals(tableName)) {\n                return tableName + \"_\" + LocalDateTime.now().getYear();\n            }\n            return tableName;\n        });\n        interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);\n\n\n        //\u5206\u9875\u63d2\u4ef6\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n\n\n        return interceptor;\n    }\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/config/MyStatInterceptor.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.config;\n\nimport com.github.deeround.jdbc.plus.Interceptor.IInterceptor;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.time.Duration;\nimport java.time.LocalDateTime;\nimport java.util.Arrays;", "import java.time.LocalDateTime;\nimport java.util.Arrays;\n\n/**\n * SQL\u76d1\u63a7\u63d2\u4ef6\n *\n * @author wanghao 913351190@qq.com\n * @create 2023/4/23 16:16\n */\n@Slf4j\npublic class MyStatInterceptor implements IInterceptor {\n    /**\n     * \u81ea\u5b9a\u4e49\u63d2\u4ef6\u662f\u5426\u652f\u6301\n     */\n    @Override", " */\n@Slf4j\npublic class MyStatInterceptor implements IInterceptor {\n    /**\n     * \u81ea\u5b9a\u4e49\u63d2\u4ef6\u662f\u5426\u652f\u6301\n     */\n    @Override\n    public boolean supportMethod(final MethodInvocationInfo methodInfo) {\n        return IInterceptor.super.supportMethod(methodInfo);\n    }\n\n    /**\n     * SQL\u6267\u884c\u524d\u65b9\u6cd5\uff08\u4e3b\u8981\u7528\u4e8e\u5bf9SQL\u8fdb\u884c\u4fee\u6539\uff09\n     */\n    @Override", "    public void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        log.info(\"\u6267\u884cSQL\u5f00\u59cb\u65f6\u95f4\uff1a{}\", LocalDateTime.now());\n        log.info(\"\u539f\u59cbSQL\uff1a{}\", Arrays.toString(methodInfo.getActionInfo().getBatchSql()));\n        log.info(\"\u8c03\u7528\u65b9\u6cd5\u540d\u79f0\uff1a{}\", methodInfo.getName());\n        log.info(\"\u8c03\u7528\u65b9\u6cd5\u5165\u53c2\uff1a{}\", Arrays.toString(methodInfo.getArgs()));\n\n        methodInfo.putUserAttribute(\"startTime\", LocalDateTime.now());\n    }\n\n    /**\n     * SQL\u6267\u884c\u5b8c\u6210\u540e\u65b9\u6cd5\uff08\u4e3b\u8981\u7528\u4e8e\u5bf9\u8fd4\u56de\u503c\u4fee\u6539\uff09\n     *\n     * @param result \u539f\u59cb\u8fd4\u56de\u5bf9\u8c61\n     * @return \u5904\u7406\u540e\u7684\u8fd4\u56de\u5bf9\u8c61\n     */\n    @Override", "    public Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        log.info(\"\u6267\u884cSQL\u7ed3\u675f\u65f6\u95f4\uff1a{}\", LocalDateTime.now());\n        LocalDateTime startTime = (LocalDateTime) methodInfo.getUserAttribute(\"startTime\");\n        log.info(\"\u6267\u884cSQL\u8017\u65f6\uff1a{}\u6beb\u79d2\", Duration.between(startTime, LocalDateTime.now()).toMillis());\n        return result;\n    }\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/config/JdbcPlusConfig.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.config;\n\nimport com.github.deeround.jdbc.plus.Interceptor.DynamicTableNameInterceptor;\nimport com.github.deeround.jdbc.plus.Interceptor.IInterceptor;\nimport com.github.deeround.jdbc.plus.Interceptor.PaginationInterceptor;\nimport com.github.deeround.jdbc.plus.Interceptor.TenantLineInterceptor;\nimport com.github.deeround.jdbc.plus.handler.TableNameHandler;\nimport com.github.deeround.jdbc.plus.handler.TenantLineHandler;\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.StringValue;", "import net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.StringValue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author wanghao 913351190@qq.com", "/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/18 16:41\n */\n@Configuration\npublic class JdbcPlusConfig {\n\n    /**\n     * TenantLineInterceptor\u662f\u5185\u7f6e\u7684\u591a\u79df\u6237\u63d2\u4ef6\n     */\n    @Bean\n    @Order(1)", "    public IInterceptor tenantLineInterceptor() {\n        return new TenantLineInterceptor(new TenantLineHandler() {\n            /**\n             * \u5f53\u524d\u79df\u6237ID\n             */\n            @Override\n            public Expression getTenantId() {\n                String currentTenantId = \"test_tenant_4\";//\u53ef\u4ee5\u4ece\u8bf7\u6c42\u4e0a\u4e0b\u6587\u4e2d\u83b7\u53d6\uff08cookie\u3001session\u3001header\u7b49\uff09\n                return new StringValue(currentTenantId);\n            }\n\n            /**\n             * \u79df\u6237\u5b57\u6bb5\u540d\n             */\n            @Override", "            public String getTenantIdColumn() {\n                return \"tenant_id\";\n            }\n\n            /**\n             * \u6839\u636e\u8868\u540d\u5224\u65ad\u662f\u5426\u5ffd\u7565\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n             */\n            @Override\n            public boolean ignoreTable(String tableName) {\n                return TenantLineHandler.super.ignoreTable(tableName);\n            }\n        });\n    }\n\n    /**\n     * DynamicTableNameInterceptor\u662f\u5185\u7f6e\u7684\u52a8\u6001\u8868\u540d\u63d2\u4ef6\n     */\n    @Bean\n    @Order(2)", "            public boolean ignoreTable(String tableName) {\n                return TenantLineHandler.super.ignoreTable(tableName);\n            }\n        });\n    }\n\n    /**\n     * DynamicTableNameInterceptor\u662f\u5185\u7f6e\u7684\u52a8\u6001\u8868\u540d\u63d2\u4ef6\n     */\n    @Bean\n    @Order(2)", "    public IInterceptor dynamicTableNameInterceptor() {\n        return new DynamicTableNameInterceptor(new TableNameHandler() {\n            @Override\n            public String dynamicTableName(String sql, String tableName) {\n                if (\"test_log\".equals(tableName)) {\n                    return tableName + \"_\" + LocalDateTime.now().getYear();\n                }\n                return tableName;\n            }\n        });\n    }\n\n    /**\n     * PaginationInterceptor\u662f\u5185\u7f6e\u7684\u5206\u9875\u63d2\u4ef6\uff08\u5206\u9875\u63d2\u4ef6\u4e00\u822c\u60c5\u51b5\u653e\u7f6e\u6700\u540e\uff09\n     */\n    @Bean\n    @Order(9)", "    public IInterceptor paginationInterceptor() {\n        return new PaginationInterceptor();\n    }\n\n    /**\n     * MyStatInterceptor\u662f\u81ea\u5b9a\u4e49\u6269\u5c55\u7684SQL\u76d1\u63a7\u63d2\u4ef6\uff08\u6ce8\u5165\u4f4d\u7f6e\u6309\u5b9e\u9645\u60c5\u51b5\uff09\n     */\n    //@Bean\n    @Order(0)\n    public IInterceptor myStatInterceptor() {\n        return new MyStatInterceptor();\n    }\n}\n", "    public IInterceptor myStatInterceptor() {\n        return new MyStatInterceptor();\n    }\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/TestAllService.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/17 17:23\n */\npublic interface TestAllService {\n\n\n    /**\n     * int[] void BATCHUPDATE(String sql(); final BatchPreparedStatementSetter pss)\n     */\n    void BATCHUPDATE_SQL_PSS();\n\n    /**\n     * int[][] void BATCHUPDATE(String sql(); final Collection<T> batchArgs(); final int batchSize();\n     * final ParameterizedPreparedStatementSetter<T> pss)\n     */\n    void BATCHUPDATE_SQL_BATCHARGS_BATCHSIZE_PSS();\n\n    /**\n     * int[] void BATCHUPDATE(String sql(); List<Object[]> batchArgs)\n     */\n    void BATCHUPDATE_SQL_BATCHARGS();\n\n    /**\n     * int[] void BATCHUPDATE(String sql(); List<Object[]> batchArgs(); final int[] argTypes)\n     */\n    void BATCHUPDATE_SQL_BATCHARGS_ARGTYPES();\n\n    /**\n     * int[] void BATCHUPDATE(final String... sql)\n     */\n    void BATCHUPDATE_SQL();\n\n\n    /**\n     * int update(final String sql)\n     */\n    void UPDATE_SQL();\n\n    /**\n     * int update(String sql(); @Nullable Object... args)\n     */\n    void UPDATE_SQL_ARGS();\n\n    /**\n     * update(String sql(); Object[] args(); int[] argTypes)\n     */\n    void UPDATE_SQL_ARGS_ARGTYPES();\n\n    /**\n     * int update(String sql(); @Nullable PreparedStatementSetter pss)\n     */\n    void UPDATE_SQL_PSS();\n\n\n    /**\n     * T void QUERY(String sql(); Object[] args(); int[] argTypes(); ResultSetExtractor<T> rse)\n     */\n    void QUERY_SQL_ARGS_ARGTYPES_RSE();\n\n    /**\n     * void void QUERY(String sql(); Object[] args(); int[] argTypes(); RowCallbackHandler rch)\n     */\n    void QUERY_SQL_ARGS_ARGTYPES_RCH();\n\n    /**\n     * List<T> void QUERY(String sql(); Object[] args(); int[] argTypes(); RowMapper<T> rowMapper)\n     */\n    void QUERY_SQL_ARGS_ARGTYPES_ROWMAPPER();\n\n    /**\n     * T void QUERY(String sql(); @Nullable Object[] args(); ResultSetExtractor<T> rse)\n     */\n    void QUERY_SQL_ARGS_RSE();\n\n    /**\n     * void void QUERY(String sql(); @Nullable Object[] args(); RowCallbackHandler rch)\n     */\n    void QUERY_SQL_ARGS_RCH();\n\n    /**\n     * List<T> void QUERY(String sql(); @Nullable Object[] args(); RowMapper<T> rowMapper)\n     */\n    void QUERY_SQL_ARGS_ROWMAPPER();\n\n    /**\n     * T void QUERY(String sql(); @Nullable PreparedStatementSetter pss(); ResultSetExtractor<T> rse)\n     */\n    void QUERY_SQL_PSS_RSE();\n\n    /**\n     * void void QUERY(String sql(); @Nullable PreparedStatementSetter pss(); RowCallbackHandler rch)\n     */\n    void QUERY_SQL_PSS_RCH();\n\n    /**\n     * List<T> void QUERY(String sql(); @Nullable PreparedStatementSetter pss(); RowMapper<T> rowMapper)\n     */\n    void QUERY_SQL_PSS_ROWMAPPER();\n\n    /**\n     * T void QUERY(final String sql(); final ResultSetExtractor<T> rse)\n     */\n    void QUERY_SQL_RSE();\n\n    /**\n     * T void QUERY(String sql(); ResultSetExtractor<T> rse(); @Nullable Object... args)\n     */\n    void QUERY_SQL_RSE_ARGS();\n\n    /**\n     * void void QUERY(String sql(); RowCallbackHandler rch)\n     */\n    void QUERY_SQL_RCH();\n\n    /**\n     * void void QUERY(String sql(); RowCallbackHandler rch(); @Nullable Object... args)\n     */\n    void QUERY_SQL_RCH_ARGS();\n\n    /**\n     * List<T> void QUERY(String sql(); RowMapper<T> rowMapper)\n     */\n    void QUERY_SQL_ROWMAPPER();\n\n    /**\n     * List<T> void QUERY(String sql(); RowMapper<T> rowMapper(); @Nullable Object... args)\n     */\n    void QUERY_SQL_ROWMAPPER_ARGS();\n\n\n    /**\n     * List<Map<String(); Object>> void QUERYForList(String sql)\n     */\n    void QUERYFORLIST_SQL();\n\n    /**\n     * List<T> void QUERYForList(String sql(); Class<T> elementType)\n     */\n    void QUERYFORLIST_SQL_ELEMENTTYPE();\n\n    /**\n     * List<T> void QUERYForList(String sql(); Class<T> elementType(); @Nullable Object... args)\n     */\n    void QUERYFORLIST_SQL_ELEMENTTYPE_ARGS();\n\n    /**\n     * List<Map<String(); Object>> void QUERYForList(String sql(); @Nullable Object... args)\n     */\n    void QUERYFORLIST_SQL_ARGS();\n\n    /**\n     * List<T> void QUERYForList(String sql(); @Nullable Object[] args(); Class<T> elementType)\n     */\n    void QUERYFORLIST_SQL_ARGS_ELEMENTTYPE();\n\n    /**\n     * List<Map<String(); Object>> void QUERYForList(String sql(); Object[] args(); int[] argTypes)\n     */\n    void QUERYFORLIST_SQL_ARGS_ARGTYPES();\n\n    /**\n     * List<T> void QUERYForList(String sql(); Object[] args(); int[] argTypes(); Class<T> elementType)\n     */\n    void QUERYFORLIST_SQL_ARGS_ARGTYPES_ELEMENTTYPE();\n\n\n    /**\n     * Map<String(); Object> void QUERYForMap(String sql)\n     */\n    void QUERYFORMAP_SQL();\n\n    /**\n     * Map<String(); Object> void QUERYForMap(String sql(); @Nullable Object... args)\n     */\n    void QUERYFORMAP_SQL_ARGS();\n\n    /**\n     * Map<String(); Object> void QUERYForMap(String sql(); Object[] args(); int[] argTypes)\n     */\n    void QUERYFORMAP_SQL_ARGS_ARGTYPES();\n\n\n    /**\n     * T void QUERYForObject(String sql(); Class<T> requiredType)\n     */\n    void QUERYFOROBJECT_SQL_REQUIREDTYPE();\n\n    /**\n     * T void QUERYForObject(String sql(); Class<T> requiredType(); @Nullable Object... args)\n     */\n    void QUERYFOROBJECT_SQL_REQUIREDTYPE_ARGS();\n\n    /**\n     * T void QUERYForObject(String sql(); @Nullable Object[] args(); Class<T> requiredType)\n     */\n    void QUERYFOROBJECT_SQL_ARGS_REQUIREDTYPE();\n\n    /**\n     * T void QUERYForObject(String sql(); Object[] args(); int[] argTypes(); Class<T> requiredType)\n     */\n    void QUERYFOROBJECT_SQL_ARGS_ARGTYPES_REQUIREDTYPE();\n\n    /**\n     * T void QUERYForObject(String sql(); Object[] args(); int[] argTypes(); RowMapper<T> rowMapper)\n     */\n    void QUERYFOROBJECT_SQL_ARGS_ARGTYPES_ROWMAPPER();\n\n    /**\n     * T void QUERYForObject(String sql(); @Nullable Object[] args(); RowMapper<T> rowMapper)\n     */\n    void QUERYFOROBJECT_SQL_ARGS_ROWMAPPER();\n\n    /**\n     * T void QUERYForObject(String sql(); RowMapper<T> rowMapper)\n     */\n    void QUERYFOROBJECT_SQL_ROWMAPPER();\n\n    /**\n     * T void QUERYForObject(String sql(); RowMapper<T> rowMapper(); @Nullable Object... args)\n     */\n    void QUERYFOROBJECT_SQL_ROWMAPPER_ARGS();\n\n    /**\n     * SqlRowSet queryForRowSet(String sql)\n     */\n    void QUERYFORROWSET_SQL();\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, @Nullable Object... args)\n     */\n    void QUERYFORROWSET_SQL_ARGS();\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)\n     */\n    void QUERYFORROWSET_SQL_ARGS_ARGTYPES();\n\n\n    /**\n     * Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n     */\n    void QUERYFORSTREAM_SQL_PSS_ROWMAPPER();\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)\n     */\n    void QUERYFORSTREAM_SQL_ROWMAPPER();\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    void QUERYFORSTREAM_SQL_ROWMAPPER_ARGS();\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/TestLogService.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service;\n\nimport com.baomidou.mybatisplus.extension.service.IService;\nimport com.github.deeround.jdbc.plus.samples.domain.TestLog;\n\n/**\n *\n */\npublic interface TestLogService extends IService<TestLog> {\n    \n}\n", "public interface TestLogService extends IService<TestLog> {\n    \n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/TestUserService.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service;\n\nimport com.baomidou.mybatisplus.extension.service.IService;\nimport com.github.deeround.jdbc.plus.samples.domain.TestUser;\n\nimport java.util.List;\n\n/**\n *\n */\npublic interface TestUserService extends IService<TestUser> {\n    List<TestUser> getListByCondition(String name);\n}\n", " *\n */\npublic interface TestUserService extends IService<TestUser> {\n    List<TestUser> getListByCondition(String name);\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/JdbcTemplateTestService.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service;\n\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageHelper;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageInfo;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/3/1 9:06\n */\n@Service\npublic class JdbcTemplateTestService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    public PageInfo<Map<String, Object>> page1() {\n        PageHelper.startPage(1, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user where id=?\", new Object[]{\"1\"});\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 0\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n    public PageInfo<Map<String, Object>> page2() {\n        PageHelper.startPage(2, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 2\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n    public PageInfo<Map<String, Object>> page3() {\n        PageHelper.startPage(3, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 4\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n", "public class JdbcTemplateTestService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    public PageInfo<Map<String, Object>> page1() {\n        PageHelper.startPage(1, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user where id=?\", new Object[]{\"1\"});\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 0\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n    public PageInfo<Map<String, Object>> page2() {\n        PageHelper.startPage(2, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 2\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n    public PageInfo<Map<String, Object>> page3() {\n        PageHelper.startPage(3, 2);\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user LIMIT 4\uff0c2\n        PageInfo<Map<String, Object>> page = new PageInfo<>(list);\n        //PageInfo\u5bf9\u8c61\u5305\u542b\u4e86\u5206\u9875\u4fe1\u606f\uff08\u603b\u884c\u6570\u7b49\uff09\n        return page;\n    }\n\n", "    public void insert() {\n        this.jdbcTemplate.update(\"insert into test_user(id,name) values('1','wangwu')\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1ainsert into test_user(id,name,tenant_id) values('1','wangwu','test_tenant_1')\n    }\n\n    public void delete() {\n        this.jdbcTemplate.update(\"delete from test_user where id='1'\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1adelete from test_user where id='1' and tenant_id='test_tenant_1'\n    }\n\n    public void update() {\n        this.jdbcTemplate.update(\"update test_user set name='lisi' where id='1'\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aupdate test_user set name='lisi' where id='1' and tenant_id='test_tenant_1'\n    }\n\n    public List<Map<String, Object>> query() {\n        return this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user where tenant_id='test_tenant_1'\n    }\n", "    public void update() {\n        this.jdbcTemplate.update(\"update test_user set name='lisi' where id='1'\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aupdate test_user set name='lisi' where id='1' and tenant_id='test_tenant_1'\n    }\n\n    public List<Map<String, Object>> query() {\n        return this.jdbcTemplate.queryForList(\"select * from test_user\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_user where tenant_id='test_tenant_1'\n    }\n\n    public void createTable() {\n        String sql = \"CREATE TABLE test_user\\n\" +\n                \"(\\n\" +\n                \"    name      varchar(100) DEFAULT NULL,\\n\" +\n                \"    tenant_id varchar(32)  DEFAULT NULL,\\n\" +\n                \"    id        varchar(32) NOT NULL,\\n\" +\n                \"    PRIMARY KEY (id)\\n\" +\n                \")\";\n        this.jdbcTemplate.execute(sql);\n    }\n", "    public void createTable() {\n        String sql = \"CREATE TABLE test_user\\n\" +\n                \"(\\n\" +\n                \"    name      varchar(100) DEFAULT NULL,\\n\" +\n                \"    tenant_id varchar(32)  DEFAULT NULL,\\n\" +\n                \"    id        varchar(32) NOT NULL,\\n\" +\n                \"    PRIMARY KEY (id)\\n\" +\n                \")\";\n        this.jdbcTemplate.execute(sql);\n    }\n", "    public void batchUpdate() {\n        this.jdbcTemplate.batchUpdate(\"insert into test_user(id,name) values('1','wangwu')\", \"insert into test_user(id,name) values('2','wangwu2')\");\n    }\n\n    public List<Map<String, Object>> getListByCondition(String name) {\n        return this.jdbcTemplate.queryForList(\"select * from test_user where name=?\", name);\n    }\n\n    public List<Map<String, Object>> getTestLogList() {\n        return this.jdbcTemplate.queryForList(\"select * from test_log\");\n        //\u6700\u7ec8\u6267\u884cSQL\uff1aselect * from test_log_2023\n    }\n\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/impl/TestAllServiceImpl.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service.impl;\n\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageHelper;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageInfo;\nimport com.github.deeround.jdbc.plus.samples.domain.TestLog;\nimport com.github.deeround.jdbc.plus.samples.service.TestAllService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.jdbc.core.*;", "import org.springframework.dao.DataAccessException;\nimport org.springframework.jdbc.core.*;\nimport org.springframework.stereotype.Service;\n\nimport java.sql.*;\nimport java.util.*;\nimport java.util.stream.Stream;\n\n/**\n * @author wanghao 913351190@qq.com", "/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/18 8:57\n */\n@Slf4j\n@Service\npublic class TestAllServiceImpl implements TestAllService {\n\n    @SuppressWarnings(\"all\")\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n", "    public static Map<String, Object> toMap(ResultSet rs) throws SQLException {\n        Map<String, Object> hm = new HashMap<String, Object>();\n        ResultSetMetaData rsmd = rs.getMetaData();\n        int count = rsmd.getColumnCount();// \u83b7\u53d6\u5217\u7684\u6570\u91cf\n        for (int i = 1; i <= count; i++) {\n            String key = rsmd.getColumnLabel(i);\n            Object value = rs.getObject(i);\n            hm.put(key, value);\n        }\n        return hm;\n    }\n\n    /**\n     * int[] void BATCHUPDATE(String sql, final BatchPreparedStatementSetter pss)\n     */\n    @Override", "    public void BATCHUPDATE_SQL_PSS() {\n\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n\n        this.jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {\n\n            @Override\n            public void setValues(PreparedStatement ps, int i) throws SQLException {\n                if (i >= 10) {\n                    return;\n                }\n                ps.setString(1, String.valueOf(i));\n                ps.setString(2, UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n            }\n\n            @Override", "                if (i >= 10) {\n                    return;\n                }\n                ps.setString(1, String.valueOf(i));\n                ps.setString(2, UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n            }\n\n            @Override\n            public int getBatchSize() {\n                return 10;\n            }\n        });\n\n\n    }\n\n    /**\n     * int[][] void BATCHUPDATE(String sql, final Collection<T> batchArgs, final int batchSize(){}\n     * final ParameterizedPreparedStatementSetter<T> pss)\n     */\n    @Override", "            public int getBatchSize() {\n                return 10;\n            }\n        });\n\n\n    }\n\n    /**\n     * int[][] void BATCHUPDATE(String sql, final Collection<T> batchArgs, final int batchSize(){}\n     * final ParameterizedPreparedStatementSetter<T> pss)\n     */\n    @Override", "    public void BATCHUPDATE_SQL_BATCHARGS_BATCHSIZE_PSS() {\n    }\n\n    /**\n     * int[] void BATCHUPDATE(String sql, List<Object[]> batchArgs)\n     */\n    @Override\n    public void BATCHUPDATE_SQL_BATCHARGS() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        List<Object[]> batchArgs = new ArrayList<>();\n        batchArgs.add(new Object[]{\"a\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")});\n        batchArgs.add(new Object[]{\"b\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")});\n        this.jdbcTemplate.batchUpdate(sql, batchArgs);\n    }\n\n    /**\n     * int[] void BATCHUPDATE(String sql, List<Object[]> batchArgs, final int[] argTypes)\n     */\n    @Override", "    public void BATCHUPDATE_SQL_BATCHARGS_ARGTYPES() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        List<Object[]> batchArgs = new ArrayList<>();\n        batchArgs.add(new Object[]{\"a1\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")});\n        batchArgs.add(new Object[]{\"b1\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")});\n        int[] argTypes = new int[]{\n                Types.VARCHAR,\n                Types.VARCHAR\n        };\n        this.jdbcTemplate.batchUpdate(sql, batchArgs, argTypes);\n    }\n\n    /**\n     * int[] void BATCHUPDATE(final String... sql)\n     */\n    @Override", "    public void BATCHUPDATE_SQL() {\n        this.jdbcTemplate.batchUpdate(\"insert into test_log(name,id) values('a2','\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"')\",\n                \"insert into test_log(name,id) values('b2','\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"')\");\n    }\n\n\n    /**\n     * int update(final String sql)\n     */\n    @Override\n    public void UPDATE_SQL() {\n        this.jdbcTemplate.update(\"insert into test_log(name,id) values('a3','\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"')\");\n    }\n\n    /**\n     * int update(String sql, @Nullable Object... args)\n     */\n    @Override", "    public void UPDATE_SQL() {\n        this.jdbcTemplate.update(\"insert into test_log(name,id) values('a3','\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"')\");\n    }\n\n    /**\n     * int update(String sql, @Nullable Object... args)\n     */\n    @Override\n    public void UPDATE_SQL_ARGS() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        Object[] objects = {\"a4\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")};\n        this.jdbcTemplate.update(sql, objects);\n    }\n\n    /**\n     * update(String sql, Object[] args, int[] argTypes)\n     */\n    @Override", "    public void UPDATE_SQL_ARGS() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        Object[] objects = {\"a4\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")};\n        this.jdbcTemplate.update(sql, objects);\n    }\n\n    /**\n     * update(String sql, Object[] args, int[] argTypes)\n     */\n    @Override\n    public void UPDATE_SQL_ARGS_ARGTYPES() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        Object[] objects = {\"a5\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")};\n        int[] argTypes = new int[]{\n                Types.VARCHAR,\n                Types.VARCHAR\n        };\n        this.jdbcTemplate.update(sql, objects, argTypes);\n    }\n\n    /**\n     * int update(String sql, @Nullable PreparedStatementSetter pss)\n     */\n    @Override", "    public void UPDATE_SQL_ARGS_ARGTYPES() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        Object[] objects = {\"a5\", UUID.randomUUID().toString().replaceAll(\"-\", \"\")};\n        int[] argTypes = new int[]{\n                Types.VARCHAR,\n                Types.VARCHAR\n        };\n        this.jdbcTemplate.update(sql, objects, argTypes);\n    }\n\n    /**\n     * int update(String sql, @Nullable PreparedStatementSetter pss)\n     */\n    @Override", "    public void UPDATE_SQL_PSS() {\n        String sql = \"insert into test_log(name,id) values(?,?)\";\n        this.jdbcTemplate.update(sql, new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, \"a6\");\n                ps.setString(2, UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n            }\n        });\n    }\n\n\n    /**\n     * T void QUERY(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_ARGTYPES_RSE() {\n        String sql = \"select * from test_log where name=?\";\n        Object[] objects = {\"0\"};\n        int[] argTypes = new int[]{\n                Types.VARCHAR\n        };\n        Map query = this.jdbcTemplate.query(sql, objects, argTypes, new ResultSetExtractor<Map>() {\n            @Override\n            public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                while (rs.next()) {\n                    return TestAllServiceImpl.toMap(rs);\n                }\n                return null;\n            }\n        });\n    }\n\n    /**\n     * void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)\n     */\n    @Override", "            public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                while (rs.next()) {\n                    return TestAllServiceImpl.toMap(rs);\n                }\n                return null;\n            }\n        });\n    }\n\n    /**\n     * void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_ARGTYPES_RCH() {\n\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        Object[] objects = {\"test_tenant_4\"};\n        int[] argTypes = new int[]{\n                Types.VARCHAR\n        };\n        List<Object> query = new ArrayList<>();\n        final int[] rowNum = {0};\n        this.jdbcTemplate.query(sql, objects, argTypes, new RowCallbackHandler() {\n            @Override", "            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        });\n\n    }\n\n    /**\n     * List<T> void QUERY(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_ARGTYPES_ROWMAPPER() {\n\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        Object[] objects = {\"test_tenant_4\"};\n        int[] argTypes = new int[]{\n                Types.VARCHAR\n        };\n        List<Object> query = this.jdbcTemplate.query(sql, objects, argTypes, new RowMapper<Object>() {\n            @Override", "            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        });\n    }\n\n    /**\n     * T void QUERY(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_RSE() {\n        String sql = \"select * from test_log where name=?\";\n        Object[] objects = {\"0\"};\n        int[] argTypes = new int[]{\n                Types.VARCHAR\n        };\n        Map query = this.jdbcTemplate.query(sql, objects, argTypes, new ResultSetExtractor<Map>() {\n            @Override\n            public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                while (rs.next()) {\n                    return TestAllServiceImpl.toMap(rs);\n                }\n                return null;\n            }\n        });\n    }\n\n    /**\n     * void QUERY(String sql, @Nullable Object[] args, RowCallbackHandler rch)\n     */\n    @Override", "            public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                while (rs.next()) {\n                    return TestAllServiceImpl.toMap(rs);\n                }\n                return null;\n            }\n        });\n    }\n\n    /**\n     * void QUERY(String sql, @Nullable Object[] args, RowCallbackHandler rch)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_RCH() {\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        Object[] objects = {\"test_tenant_4\"};\n        List<Object> query = new ArrayList<>();\n        final int[] rowNum = {0};\n        this.jdbcTemplate.query(sql, objects, new RowCallbackHandler() {\n            @Override\n            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        });\n    }\n\n    /**\n     * List<T> void QUERY(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n     */\n    @Override", "            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        });\n    }\n\n    /**\n     * List<T> void QUERY(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERY_SQL_ARGS_ROWMAPPER() {\n\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        Object[] objects = {\"test_tenant_4\"};\n        List<Object> query = this.jdbcTemplate.query(sql, objects, new RowMapper<Object>() {\n            @Override\n            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        });\n    }\n\n    /**\n     * T void QUERY(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)\n     */\n    @Override", "            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        });\n    }\n\n    /**\n     * T void QUERY(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)\n     */\n    @Override", "    public void QUERY_SQL_PSS_RSE() {\n        String sql = \"select * from test_log where tenant_id=?\";\n        List<Object> list = this.jdbcTemplate.query(sql, new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, \"test_tenant_4\");\n            }\n        }, new ResultSetExtractor<List<Object>>() {\n            @Override\n            public List<Object> extractData(ResultSet rs) throws SQLException, DataAccessException {\n                List<Object> query = new ArrayList<>();\n                int rowNum = 0;", "                while (rs.next()) {\n                    log.info(\"rowNum==>{}\", rowNum++);\n                    query.add(TestAllServiceImpl.toMap(rs));\n                }\n                return query;\n            }\n        });\n    }\n\n    /**\n     * void QUERY(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)\n     */\n    @Override", "    public void QUERY_SQL_PSS_RCH() {\n        List<Object> query = new ArrayList<>();\n        final int[] rowNum = {0};\n        String sql = \"select * from test_log where tenant_id=?\";\n        this.jdbcTemplate.query(sql, new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, \"test_tenant_4\");\n            }\n        }, new RowCallbackHandler() {\n            @Override", "            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        });\n    }\n\n    /**\n     * List<T> void QUERY(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERY_SQL_PSS_ROWMAPPER() {\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        List<Object> query = this.jdbcTemplate.query(sql, new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, \"test_tenant_4\");\n            }\n        }, new RowMapper<Object>() {\n            @Override", "            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        });\n\n        PageInfo<Object> page = new PageInfo<>(query);\n    }\n\n    /**\n     * T void QUERY(final String sql, final ResultSetExtractor<T> rse)\n     */\n    @Override", "    public void QUERY_SQL_RSE() {\n        String sql = \"select * from test_log\";\n        List<Object> list = this.jdbcTemplate.query(sql, new ResultSetExtractor<List<Object>>() {\n            @Override\n            public List<Object> extractData(ResultSet rs) throws SQLException, DataAccessException {\n                List<Object> query = new ArrayList<>();\n                int rowNum = 0;\n                while (rs.next()) {\n                    log.info(\"rowNum==>{}\", rowNum++);\n                    query.add(TestAllServiceImpl.toMap(rs));\n                }\n                return query;\n            }\n        });\n    }\n\n    /**\n     * T void QUERY(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)\n     */\n    @Override", "    public void QUERY_SQL_RSE_ARGS() {\n        String sql = \"select * from test_log where tenant_id=?\";\n        List<Object> list = this.jdbcTemplate.query(sql, new ResultSetExtractor<List<Object>>() {\n            @Override\n            public List<Object> extractData(ResultSet rs) throws SQLException, DataAccessException {\n                List<Object> query = new ArrayList<>();\n                int rowNum = 0;\n                while (rs.next()) {\n                    log.info(\"rowNum==>{}\", rowNum++);\n                    query.add(TestAllServiceImpl.toMap(rs));\n                }\n                return query;\n            }\n        }, \"test_tenant_4\");\n    }\n\n    /**\n     * void QUERY(String sql, RowCallbackHandler rch)\n     */\n    @Override", "    public void QUERY_SQL_RCH() {\n        List<Object> query = new ArrayList<>();\n        final int[] rowNum = {0};\n        String sql = \"select * from test_log\";\n        this.jdbcTemplate.query(sql, new RowCallbackHandler() {\n            @Override\n            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        });\n    }\n\n    /**\n     * void QUERY(String sql, RowCallbackHandler rch, @Nullable Object... args)\n     */\n    @Override", "    public void QUERY_SQL_RCH_ARGS() {\n        List<Object> query = new ArrayList<>();\n        final int[] rowNum = {0};\n        String sql = \"select * from test_log where tenant_id=?\";\n        this.jdbcTemplate.query(sql, new RowCallbackHandler() {\n            @Override\n            public void processRow(ResultSet rs) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum[0]++);\n                query.add(TestAllServiceImpl.toMap(rs));\n            }\n        }, \"test_tenant_4\");\n    }\n\n    /**\n     * List<T> void QUERY(String sql, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERY_SQL_ROWMAPPER() {\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log\";\n        List<Object> query = this.jdbcTemplate.query(sql, new RowMapper<Object>() {\n            @Override\n            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        });\n\n        PageInfo<Object> page = new PageInfo<>(query);\n    }\n\n    /**\n     * List<T> void QUERY(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    @Override", "    public void QUERY_SQL_ROWMAPPER_ARGS() {\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        List<Object> query = this.jdbcTemplate.query(sql, new RowMapper<Object>() {\n            @Override\n            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        }, \"test_tenant_4\");\n\n        PageInfo<Object> page = new PageInfo<>(query);\n    }\n\n\n    /**\n     * List<Map<String, Object>> void QUERYForList(String sql)\n     */\n    @Override", "    public void QUERYFORLIST_SQL() {\n        String sql = \"select id,name,tenant_id as tenantId from test_log where tenant_id=?\";\n        List bean = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<TestLog>(TestLog.class), \"test_tenant_4\");\n    }\n\n    /**\n     * List<T> void QUERYForList(String sql, Class<T> elementType)\n     */\n    @Override\n    public void QUERYFORLIST_SQL_ELEMENTTYPE() {\n    }\n\n    /**\n     * List<T> void QUERYForList(String sql, Class<T> elementType, @Nullable Object... args)\n     */\n    @Override", "    public void QUERYFORLIST_SQL_ELEMENTTYPE() {\n    }\n\n    /**\n     * List<T> void QUERYForList(String sql, Class<T> elementType, @Nullable Object... args)\n     */\n    @Override\n    public void QUERYFORLIST_SQL_ELEMENTTYPE_ARGS() {\n    }\n\n    /**\n     * List<Map<String, Object>> void QUERYForList(String sql, @Nullable Object... args)\n     */\n    @Override", "    public void QUERYFORLIST_SQL_ARGS() {\n    }\n\n    /**\n     * List<T> void QUERYForList(String sql, @Nullable Object[] args, Class<T> elementType)\n     */\n    @Override\n    public void QUERYFORLIST_SQL_ARGS_ELEMENTTYPE() {\n    }\n\n    /**\n     * List<Map<String, Object>> void QUERYForList(String sql, Object[] args, int[] argTypes)\n     */\n    @Override", "    public void QUERYFORLIST_SQL_ARGS_ARGTYPES() {\n    }\n\n    /**\n     * List<T> void QUERYForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)\n     */\n    @Override\n    public void QUERYFORLIST_SQL_ARGS_ARGTYPES_ELEMENTTYPE() {\n    }\n\n\n    /**\n     * Map<String, Object> void QUERYForMap(String sql)\n     */\n    @Override", "    public void QUERYFORMAP_SQL() {\n    }\n\n    /**\n     * Map<String, Object> void QUERYForMap(String sql, @Nullable Object... args)\n     */\n    @Override\n    public void QUERYFORMAP_SQL_ARGS() {\n    }\n\n    /**\n     * Map<String, Object> void QUERYForMap(String sql, Object[] args, int[] argTypes)\n     */\n    @Override", "    public void QUERYFORMAP_SQL_ARGS_ARGTYPES() {\n    }\n\n\n    /**\n     * T void QUERYForObject(String sql, Class<T> requiredType)\n     */\n    @Override\n    public void QUERYFOROBJECT_SQL_REQUIREDTYPE() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, Class<T> requiredType, @Nullable Object... args)\n     */\n    @Override", "    public void QUERYFOROBJECT_SQL_REQUIREDTYPE() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, Class<T> requiredType, @Nullable Object... args)\n     */\n    @Override\n    public void QUERYFOROBJECT_SQL_REQUIREDTYPE_ARGS() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, @Nullable Object[] args, Class<T> requiredType)\n     */\n    @Override", "    public void QUERYFOROBJECT_SQL_ARGS_REQUIREDTYPE() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n     */\n    @Override\n    public void QUERYFOROBJECT_SQL_ARGS_ARGTYPES_REQUIREDTYPE() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERYFOROBJECT_SQL_ARGS_ARGTYPES_ROWMAPPER() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n     */\n    @Override\n    public void QUERYFOROBJECT_SQL_ARGS_ROWMAPPER() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERYFOROBJECT_SQL_ROWMAPPER() {\n    }\n\n    /**\n     * T void QUERYForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    @Override\n    public void QUERYFOROBJECT_SQL_ROWMAPPER_ARGS() {\n    }\n\n    /**\n     * SqlRowSet queryForRowSet(String sql)\n     */\n    @Override", "    public void QUERYFORROWSET_SQL() {\n    }\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, @Nullable Object... args)\n     */\n    @Override\n    public void QUERYFORROWSET_SQL_ARGS() {\n    }\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)\n     */\n    @Override", "    public void QUERYFORROWSET_SQL_ARGS_ARGTYPES() {\n    }\n\n\n    /**\n     * Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n     */\n    @Override\n    public void QUERYFORSTREAM_SQL_PSS_ROWMAPPER() {\n    }\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)\n     */\n    @Override", "    public void QUERYFORSTREAM_SQL_PSS_ROWMAPPER() {\n    }\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)\n     */\n    @Override\n    public void QUERYFORSTREAM_SQL_ROWMAPPER() {\n\n    }\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    @Override", "    public void QUERYFORSTREAM_SQL_ROWMAPPER_ARGS() {\n        //\u5206\u9875\u6d4b\u8bd5\n        PageHelper.startPage(1, 5);\n\n        String sql = \"select * from test_log where tenant_id=?\";\n        Stream<Object> list = this.jdbcTemplate.queryForStream(sql, new RowMapper<Object>() {\n            @Override\n            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n                log.info(\"rowNum==>{}\", rowNum);\n                return TestAllServiceImpl.toMap(rs);\n            }\n        }, \"test_tenant_4\");\n\n\n    }\n}\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/impl/TestUserServiceImpl.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service.impl;\n\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.github.deeround.jdbc.plus.samples.domain.TestUser;\nimport com.github.deeround.jdbc.plus.samples.mapper.TestUserMapper;\nimport com.github.deeround.jdbc.plus.samples.service.TestUserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;", "\nimport java.util.List;\n\n/**\n *\n */\n@Service\npublic class TestUserServiceImpl extends ServiceImpl<TestUserMapper, TestUser>\n        implements TestUserService {\n\n    @Autowired\n    private TestUserMapper testUserMapper;\n\n    @Override\n    public List<TestUser> getListByCondition(String name) {\n        return this.testUserMapper.getListByCondition(name);\n    }\n}\n\n\n\n\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/service/impl/TestLogServiceImpl.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.service.impl;\n\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.github.deeround.jdbc.plus.samples.domain.TestLog;\nimport com.github.deeround.jdbc.plus.samples.mapper.TestLogMapper;\nimport com.github.deeround.jdbc.plus.samples.service.TestLogService;\nimport org.springframework.stereotype.Service;\n\n/**\n *", "/**\n *\n */\n@Service\npublic class TestLogServiceImpl extends ServiceImpl<TestLogMapper, TestLog>\n        implements TestLogService {\n\n}\n\n\n\n\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/mapper/TestLogMapper.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.github.deeround.jdbc.plus.samples.domain.TestLog;\nimport org.springframework.stereotype.Repository;\n\n/**\n * @Entity com.github.deeround.jdbc.plus.samples.domain.TestLog\n */\n@Repository\npublic interface TestLogMapper extends BaseMapper<TestLog> {\n\n}\n\n\n\n\n", " */\n@Repository\npublic interface TestLogMapper extends BaseMapper<TestLog> {\n\n}\n\n\n\n\n"]}
{"filename": "jdbc-plus-samples/src/main/java/com/github/deeround/jdbc/plus/samples/mapper/TestUserMapper.java", "chunked_list": ["package com.github.deeround.jdbc.plus.samples.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.github.deeround.jdbc.plus.samples.domain.TestUser;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**", "\n/**\n * @Entity com.github.deeround.jdbc.plus.samples.domain.TestUser\n */\n@Repository\npublic interface TestUserMapper extends BaseMapper<TestUser> {\n\n    List<TestUser> getListByCondition(@Param(\"name\") String name);\n\n}\n\n\n\n\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/handler/TenantLineHandler.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.handler;\n\nimport net.sf.jsqlparser.expression.Expression;", "\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.schema.Column;\n\nimport java.util.List;\n\n/**\n * \u79df\u6237\u5904\u7406\u5668\uff08 TenantId \u884c\u7ea7 \uff09\n *\n * @author hubin", " *\n * @author hubin\n * @since 3.4.0\n */\npublic interface TenantLineHandler {\n\n    /**\n     * \u83b7\u53d6\u79df\u6237 ID \u503c\u8868\u8fbe\u5f0f\uff0c\u53ea\u652f\u6301\u5355\u4e2a ID \u503c\n     * <p>\n     *\n     * @return \u79df\u6237 ID \u503c\u8868\u8fbe\u5f0f\n     */\n    Expression getTenantId();\n\n    /**\n     * \u83b7\u53d6\u79df\u6237\u5b57\u6bb5\u540d\n     * <p>\n     * \u9ed8\u8ba4\u5b57\u6bb5\u540d\u53eb: tenant_id\n     *\n     * @return \u79df\u6237\u5b57\u6bb5\u540d\n     */\n    default String getTenantIdColumn() {\n        return \"tenant_id\";\n    }\n\n    /**\n     * \u6839\u636e\u8868\u540d\u5224\u65ad\u662f\u5426\u5ffd\u7565\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n     * <p>\n     * \u9ed8\u8ba4\u90fd\u8981\u8fdb\u884c\u89e3\u6790\u5e76\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n     *\n     * @param tableName \u8868\u540d\n     * @return \u662f\u5426\u5ffd\u7565, true:\u8868\u793a\u5ffd\u7565\uff0cfalse:\u9700\u8981\u89e3\u6790\u5e76\u62fc\u63a5\u591a\u79df\u6237\u6761\u4ef6\n     */\n    default boolean ignoreTable(String tableName) {\n        return false;\n    }\n\n    /**\n     * \u5ffd\u7565\u63d2\u5165\u79df\u6237\u5b57\u6bb5\u903b\u8f91\n     *\n     * @param columns        \u63d2\u5165\u5b57\u6bb5\n     * @param tenantIdColumn \u79df\u6237 ID \u5b57\u6bb5\n     * @return\n     */\n    default boolean ignoreInsert(List<Column> columns, String tenantIdColumn) {\n        return columns.stream().map(Column::getColumnName).anyMatch(i -> i.equalsIgnoreCase(tenantIdColumn));\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/handler/TableNameHandler.java", "chunked_list": ["package com.github.deeround.jdbc.plus.handler;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/26 10:10\n */\npublic interface TableNameHandler {\n\n    /**\n     * \u751f\u6210\u52a8\u6001\u8868\u540d\n     *\n     * @param sql       \u5f53\u524d\u6267\u884c SQL\n     * @param tableName \u8868\u540d\n     * @return String\n     */\n    String dynamicTableName(String sql, String tableName);\n}"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/util/ExceptionUtils.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.util;\n\n/**", "\n/**\n * \u5f02\u5e38\u8f85\u52a9\u5de5\u5177\u7c7b\n *\n * @author HCL\n * @since 2018-07-24\n */\npublic final class ExceptionUtils {\n\n    private ExceptionUtils() {\n    }\n\n    /**\n     * \u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u5f02\u5e38\uff0c\u7edf\u4e00\u6784\u5efa\uff0c\u65b9\u4fbf\u7edf\u4e00\u5904\u7406\n     *\n     * @param msg \u6d88\u606f\n     * @param t   \u5f02\u5e38\u4fe1\u606f\n     * @return \u8fd4\u56de\u5f02\u5e38\n     */", "    public static RuntimeException mpe(String msg, Throwable t, Object... params) {\n        return new RuntimeException(String.format(msg, params), t);\n    }\n\n    /**\n     * \u91cd\u8f7d\u7684\u65b9\u6cd5\n     *\n     * @param msg \u6d88\u606f\n     * @return \u8fd4\u56de\u5f02\u5e38\n     */\n    public static RuntimeException mpe(String msg, Object... params) {\n        return new RuntimeException(String.format(msg, params));\n    }\n\n    /**\n     * \u91cd\u8f7d\u7684\u65b9\u6cd5\n     *\n     * @param t \u5f02\u5e38\n     * @return \u8fd4\u56de\u5f02\u5e38\n     */", "    public static RuntimeException mpe(String msg, Object... params) {\n        return new RuntimeException(String.format(msg, params));\n    }\n\n    /**\n     * \u91cd\u8f7d\u7684\u65b9\u6cd5\n     *\n     * @param t \u5f02\u5e38\n     * @return \u8fd4\u56de\u5f02\u5e38\n     */\n    public static RuntimeException mpe(Throwable t) {\n        return new RuntimeException(t);\n    }\n", "    public static RuntimeException mpe(Throwable t) {\n        return new RuntimeException(t);\n    }\n\n    public static void throwMpe(boolean condition, String msg, Object... params) {\n        if (condition) {\n            throw mpe(msg, params);\n        }\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/util/StringPool.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.util;\n\n/**", "\n/**\n * Copy to jodd.util\n * <p>\n * Pool of <code>String</code> constants to prevent repeating of\n * hard-coded <code>String</code> literals in the code.\n * Due to fact that these are <code>public static final</code>\n * they will be inlined by java compiler and\n * reference to this class will be dropped.\n * There is <b>no</b> performance gain of using this pool.\n * Read: https://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5\n * <ul>\n * <li>Literal strings within the same class in the same package represent references to the same <code>String</code> object.</li>\n * <li>Literal strings within different classes in the same package represent references to the same <code>String</code> object.</li>\n * <li>Literal strings within different classes in different packages likewise represent references to the same <code>String</code> object.</li>\n * <li>Strings computed by constant expressions are computed at compile time and then treated as if they were literals.</li>\n * <li>Strings computed by concatenation at run time are newly created and therefore distinct.</li>\n * </ul>\n */", "public interface StringPool {\n\n    String AMPERSAND = \"&\";\n    String AND = \"and\";\n    String AT = \"@\";\n    String ASTERISK = \"*\";\n    String STAR = ASTERISK;\n    String BACK_SLASH = \"\\\\\";\n    String COLON = \":\";\n    String COMMA = \",\";\n    String DASH = \"-\";\n    String DOLLAR = \"$\";\n    String DOT = \".\";\n    String DOTDOT = \"..\";\n    String DOT_CLASS = \".class\";\n    String DOT_JAVA = \".java\";\n    String DOT_XML = \".xml\";\n    String EMPTY = \"\";\n    String EQUALS = \"=\";\n    String FALSE = \"false\";\n    String SLASH = \"/\";\n    String HASH = \"#\";\n    String HAT = \"^\";\n    String LEFT_BRACE = \"{\";\n    String LEFT_BRACKET = \"(\";\n    String LEFT_CHEV = \"<\";\n    String DOT_NEWLINE = \",\\n\";\n    String NEWLINE = \"\\n\";\n    String N = \"n\";\n    String NO = \"no\";\n    String NULL = \"null\";\n    String NUM = \"NUM\";\n    String OFF = \"off\";\n    String ON = \"on\";\n    String PERCENT = \"%\";\n    String PIPE = \"|\";\n    String PLUS = \"+\";\n    String QUESTION_MARK = \"?\";\n    String EXCLAMATION_MARK = \"!\";\n    String QUOTE = \"\\\"\";\n    String RETURN = \"\\r\";\n    String TAB = \"\\t\";\n    String RIGHT_BRACE = \"}\";\n    String RIGHT_BRACKET = \")\";\n    String RIGHT_CHEV = \">\";\n    String SEMICOLON = \";\";\n    String SINGLE_QUOTE = \"'\";\n    String BACKTICK = \"`\";\n    String SPACE = \" \";\n    String SQL = \"sql\";\n    String TILDA = \"~\";\n    String LEFT_SQ_BRACKET = \"[\";\n    String RIGHT_SQ_BRACKET = \"]\";\n    String TRUE = \"true\";\n    String UNDERSCORE = \"_\";\n    String UTF_8 = \"UTF-8\";\n    String US_ASCII = \"US-ASCII\";\n    String ISO_8859_1 = \"ISO-8859-1\";\n    String Y = \"y\";\n    String YES = \"yes\";\n    String ONE = \"1\";\n    String ZERO = \"0\";\n    String DOLLAR_LEFT_BRACE = \"${\";\n    String HASH_LEFT_BRACE = \"#{\";\n    String CRLF = \"\\r\\n\";\n\n    String HTML_NBSP = \"&nbsp;\";\n    String HTML_AMP = \"&amp\";\n    String HTML_QUOTE = \"&quot;\";\n    String HTML_LT = \"&lt;\";\n    String HTML_GT = \"&gt;\";\n\n    // ---------------------------------------------------------------- array\n\n    String[] EMPTY_ARRAY = new String[0];\n\n    byte[] BYTES_NEW_LINE = StringPool.NEWLINE.getBytes();\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/util/CollectionUtils.java", "chunked_list": ["package com.github.deeround.jdbc.plus.util;\n\nimport java.util.Collection;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/18 16:01\n */\npublic class CollectionUtils {\n    public static boolean isEmpty(Collection<?> collection) {\n        return collection == null || collection.isEmpty();\n    }\n", "public class CollectionUtils {\n    public static boolean isEmpty(Collection<?> collection) {\n        return collection == null || collection.isEmpty();\n    }\n\n    public static boolean isNotEmpty(Collection<?> collection) {\n        return !isEmpty(collection);\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/util/TableNameParser.java", "chunked_list": ["package com.github.deeround.jdbc.plus.util;/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.util.*;\nimport java.util.regex.Matcher;", "import java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * SQL \u8868\u540d\u89e3\u6790\n * <p>\n * https://github.com/mnadeem/sql-table-name-parser\n * <p>\n * Ultra light, Ultra fast parser to extract table name out SQLs, supports oracle dialect SQLs as well.", " * <p>\n * Ultra light, Ultra fast parser to extract table name out SQLs, supports oracle dialect SQLs as well.\n * USE: new TableNameParser(sql).tables()\n *\n * @author Nadeem Mohammad, hcl\n * @since 2019-04-22\n */\npublic final class TableNameParser {\n\n    private static final String TOKEN_SET = \"set\";\n    private static final String TOKEN_OF = \"of\";\n    private static final String TOKEN_DUAL = \"dual\";\n    private static final String TOKEN_DELETE = \"delete\";\n    private static final String TOKEN_CREATE = \"create\";\n    private static final String TOKEN_INDEX = \"index\";\n\n    private static final String KEYWORD_JOIN = \"join\";\n    private static final String KEYWORD_INTO = \"into\";\n    private static final String KEYWORD_TABLE = \"table\";\n    private static final String KEYWORD_FROM = \"from\";\n    private static final String KEYWORD_USING = \"using\";\n    private static final String KEYWORD_UPDATE = \"update\";\n    private static final String KEYWORD_DUPLICATE = \"duplicate\";\n\n    private static final List<String> concerned = Arrays.asList(KEYWORD_TABLE, KEYWORD_INTO, KEYWORD_JOIN, KEYWORD_USING, KEYWORD_UPDATE);\n    private static final List<String> ignored = Arrays.asList(StringPool.LEFT_BRACKET, TOKEN_SET, TOKEN_OF, TOKEN_DUAL);\n\n    /**\n     * \u8be5\u8868\u8fbe\u5f0f\u4f1a\u5339\u914d SQL \u4e2d\u4e0d\u662f SQL TOKEN \u7684\u90e8\u5206\uff0c\u6bd4\u5982\u6362\u884c\u7b26\uff0c\u6ce8\u91ca\u4fe1\u606f\uff0c\u7ed3\u5c3e\u7684 {@code ;} \u7b49\u3002\n     * <p>\n     * \u6392\u9664\u7684\u9879\u76ee\u5305\u62ec\uff1a\n     * 1\u3001\u4ee5 -- \u5f00\u5934\u7684\u6ce8\u91ca\u4fe1\u606f\n     * 2\u3001;\n     * 3\u3001\u7a7a\u767d\u5b57\u7b26\n     * 4\u3001\u4f7f\u7528 /* * / \u6ce8\u91ca\u7684\u4fe1\u606f\n     * 5\u3001\u628a ,() \u4e5f\u8981\u5206\u51fa\u6765\n     */\n    private static final Pattern NON_SQL_TOKEN_PATTERN = Pattern.compile(\"(--[^\\\\v]+)|;|(\\\\s+)|((?s)/[*].*?[*]/)\"\n            + \"|(((\\\\b|\\\\B)(?=[,()]))|((?<=[,()])(\\\\b|\\\\B)))\"\n    );\n\n    private final List<SqlToken> tokens;\n\n    /**\n     * \u4ece SQL \u4e2d\u63d0\u53d6\u8868\u540d\u79f0\n     *\n     * @param sql \u9700\u8981\u89e3\u6790\u7684 SQL \u8bed\u53e5\n     */\n    public TableNameParser(String sql) {\n        this.tokens = this.fetchAllTokens(sql);\n    }\n\n    /**\n     * \u63a5\u53d7\u4e00\u4e2a\u65b0\u7684\u8bbf\u95ee\u8005\uff0c\u5e76\u8bbf\u95ee\u5f53\u524d SQL \u7684\u8868\u540d\u79f0\n     * <p>\n     * \u73b0\u5728\u6211\u4eec\u6539\u6210\u4e86\u8bbf\u95ee\u8005\u6a21\u5f0f\uff0c\u4e0d\u5728\u5bf9\u4ee5\u524d\u7684 SQL \u505a\u6539\u52a8\n     * \u540c\u65f6\uff0c\u4f60\u53ef\u4ee5\u65b9\u4fbf\u7684\u83b7\u5f97\u8868\u540d\u4f4d\u7f6e\u7684\u7d22\u5f15\n     *\n     * @param visitor \u8bbf\u95ee\u8005\n     */", "    public void accept(TableNameVisitor visitor) {\n        int index = 0;\n        String first = this.tokens.get(index).getValue();\n        if (isOracleSpecialDelete(first, this.tokens, index)) {\n            visitNameToken(this.tokens.get(index + 1), visitor);\n        } else if (this.isCreateIndex(first, this.tokens, index)) {\n            visitNameToken(this.tokens.get(index + 4), visitor);\n        } else {\n            while (hasMoreTokens(this.tokens, index)) {\n                String current = this.tokens.get(index++).getValue();\n                if (isFromToken(current)) {\n                    processFromToken(this.tokens, index, visitor);", "            while (hasMoreTokens(this.tokens, index)) {\n                String current = this.tokens.get(index++).getValue();\n                if (isFromToken(current)) {\n                    processFromToken(this.tokens, index, visitor);\n                } else if (this.isOnDuplicateKeyUpdate(current, index)) {\n                    index = this.skipDuplicateKeyUpdateIndex(index);\n                } else if (concerned.contains(current.toLowerCase())) {\n                    if (hasMoreTokens(this.tokens, index)) {\n                        SqlToken next = this.tokens.get(index++);\n                        visitNameToken(next, visitor);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \u8868\u540d\u8bbf\u95ee\u5668\n     */", "    public interface TableNameVisitor {\n        /**\n         * @param name \u8868\u793a\u8868\u540d\u79f0\u7684 token\n         */\n        void visit(SqlToken name);\n    }\n\n    /**\n     * \u4ece SQL \u8bed\u53e5\u4e2d\u63d0\u53d6\u51fa \u6240\u6709\u7684 SQL Token\n     *\n     * @param sql SQL\n     * @return \u8bed\u53e5\n     */\n    protected List<SqlToken> fetchAllTokens(String sql) {\n        List<SqlToken> tokens = new ArrayList<>();\n        Matcher matcher = NON_SQL_TOKEN_PATTERN.matcher(sql);\n        int last = 0;", "        while (matcher.find()) {\n            int start = matcher.start();\n            if (start != last) {\n                tokens.add(new SqlToken(last, start, sql.substring(last, start)));\n            }\n            last = matcher.end();\n        }\n        if (last != sql.length()) {\n            tokens.add(new SqlToken(last, sql.length(), sql.substring(last)));\n        }\n        return tokens;\n    }\n\n    /**\n     * \u5982\u679c\u662f DELETE \u540e\u9762\u7d27\u8ddf\u7684\u4e0d\u662f FROM \u6216\u8005 * ,\u5219 \u8fd4\u56de true\n     *\n     * @param current \u5f53\u524d\u7684 token\n     * @param tokens  token \u5217\u8868\n     * @param index   \u7d22\u5f15\n     * @return \u5224\u65ad\u662f\u4e0d\u662f Oracle \u7279\u6b8a\u7684\u5220\u9664\u624b\u6cd5\n     */\n    private static boolean isOracleSpecialDelete(String current, List<SqlToken> tokens, int index) {", "        if (TOKEN_DELETE.equalsIgnoreCase(current)) {\n            if (hasMoreTokens(tokens, index++)) {\n                String next = tokens.get(index).getValue();\n                return !KEYWORD_FROM.equalsIgnoreCase(next) && !StringPool.ASTERISK.equals(next);\n            }\n        }\n        return false;\n    }\n\n    private boolean isCreateIndex(String current, List<SqlToken> tokens, int index) {\n        index++; // Point to next token", "        if (TOKEN_CREATE.equalsIgnoreCase(current) && hasIthToken(tokens, index)) {\n            String next = tokens.get(index).getValue();\n            return TOKEN_INDEX.equalsIgnoreCase(next);\n        }\n        return false;\n    }\n\n    /**\n     * @param current \u5f53\u524dtoken\n     * @param index   \u7d22\u5f15\n     * @return \u5224\u65ad\u662f\u5426\u662fmysql\u7684\u7279\u6b8a\u8bed\u6cd5 on duplicate key update\n     */\n    private boolean isOnDuplicateKeyUpdate(String current, int index) {", "        if (KEYWORD_DUPLICATE.equalsIgnoreCase(current)) {\n            if (hasMoreTokens(this.tokens, index++)) {\n                String next = this.tokens.get(index).getValue();\n                return KEYWORD_UPDATE.equalsIgnoreCase(next);\n            }\n        }\n        return false;\n    }\n\n    private static boolean hasIthToken(List<SqlToken> tokens, int currentIndex) {\n        return hasMoreTokens(tokens, currentIndex) && tokens.size() > currentIndex + 3;\n    }\n\n    private static boolean isFromToken(String currentToken) {\n        return KEYWORD_FROM.equalsIgnoreCase(currentToken);\n    }\n\n    private int skipDuplicateKeyUpdateIndex(int index) {\n        // on duplicate key update\u4e3amysql\u7684\u56fa\u5b9a\u5199\u6cd5\uff0c\u76f4\u63a5\u8df3\u8fc7\u5373\u53ef\u3002\n        return index + 2;\n    }\n\n    private static void processFromToken(List<SqlToken> tokens, int index, TableNameVisitor visitor) {\n        SqlToken sqlToken = tokens.get(index++);\n        visitNameToken(sqlToken, visitor);\n\n        String next = null;", "        if (hasMoreTokens(tokens, index)) {\n            next = tokens.get(index++).getValue();\n        }\n\n        if (shouldProcessMultipleTables(next)) {\n            processNonAliasedMultiTables(tokens, index, next, visitor);\n        } else {\n            processAliasedMultiTables(tokens, index, sqlToken, visitor);\n        }\n    }\n\n    private static void processNonAliasedMultiTables(List<SqlToken> tokens, int index, String nextToken, TableNameVisitor visitor) {", "        while (nextToken.equals(StringPool.COMMA)) {\n            visitNameToken(tokens.get(index++), visitor);\n            if (hasMoreTokens(tokens, index)) {\n                nextToken = tokens.get(index++).getValue();\n            } else {\n                break;\n            }\n        }\n    }\n\n    private static void processAliasedMultiTables(List<SqlToken> tokens, int index, SqlToken current, TableNameVisitor visitor) {\n        String nextNextToken = null;", "        if (hasMoreTokens(tokens, index)) {\n            nextNextToken = tokens.get(index++).getValue();\n        }\n\n        if (shouldProcessMultipleTables(nextNextToken)) {\n            while (hasMoreTokens(tokens, index) && nextNextToken.equals(StringPool.COMMA)) {\n                if (hasMoreTokens(tokens, index)) {\n                    current = tokens.get(index++);\n                }\n                if (hasMoreTokens(tokens, index)) {\n                    index++;\n                }", "                if (hasMoreTokens(tokens, index)) {\n                    index++;\n                }\n                if (hasMoreTokens(tokens, index)) {\n                    nextNextToken = tokens.get(index++).getValue();\n                }\n                visitNameToken(current, visitor);\n            }\n        }\n    }\n\n    private static boolean shouldProcessMultipleTables(final String nextToken) {\n        return nextToken != null && nextToken.equals(StringPool.COMMA);\n    }\n\n    private static boolean hasMoreTokens(List<SqlToken> tokens, int index) {\n        return index < tokens.size();\n    }\n\n    private static void visitNameToken(SqlToken token, TableNameVisitor visitor) {\n        String value = token.getValue().toLowerCase();", "        if (!ignored.contains(value)) {\n            visitor.visit(token);\n        }\n    }\n\n    /**\n     * parser tables\n     *\n     * @return table names extracted out of sql\n     * @see #accept(TableNameVisitor)\n     */\n    public Collection<String> tables() {\n        Map<String, String> tableMap = new HashMap<>();\n        this.accept(token -> {\n            String name = token.getValue();\n            tableMap.putIfAbsent(name.toLowerCase(), name);\n        });\n        return new HashSet<>(tableMap.values());\n    }\n\n    /**\n     * SQL \u8bcd\n     */", "    public static class SqlToken implements Comparable<SqlToken> {\n        private final int start;\n        private final int end;\n        private final String value;\n\n        private SqlToken(int start, int end, String value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n        }\n", "        public int getStart() {\n            return this.start;\n        }\n\n        public int getEnd() {\n            return this.end;\n        }\n\n        public String getValue() {\n            return this.value;\n        }\n\n        @Override", "        public String getValue() {\n            return this.value;\n        }\n\n        @Override\n        public int compareTo(SqlToken o) {\n            return Integer.compare(this.start, o.start);\n        }\n\n        @Override\n        public String toString() {\n            return this.value;\n        }\n\n    }\n\n}\n", "        public String toString() {\n            return this.value;\n        }\n\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/spring/boot/autoconfigure/JdbcPlusProperties.java", "chunked_list": ["package com.github.deeround.jdbc.plus.spring.boot.autoconfigure;\n\nimport lombok.Data;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/2/23 17:29\n */", " * @create 2023/2/23 17:29\n */\n@ConfigurationProperties(prefix = JdbcPlusProperties.PREFIX)\n@Slf4j\n@Data\npublic class JdbcPlusProperties {\n\n    public static final String PREFIX = \"jdbc.plus\";\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/spring/boot/autoconfigure/JdbcPlusAutoConfiguration.java", "chunked_list": ["package com.github.deeround.jdbc.plus.spring.boot.autoconfigure;\n\nimport com.github.deeround.jdbc.plus.Interceptor.IInterceptor;\nimport com.github.deeround.jdbc.plus.aop.JdbcTemplateMethodAdvisor;\nimport com.github.deeround.jdbc.plus.aop.JdbcTemplateMethodInterceptor;\nimport org.springframework.aop.Advisor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;", "import org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.List;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/2/23 16:52\n */", " * @create 2023/2/23 16:52\n */\n@Configuration\n@EnableConfigurationProperties(JdbcPlusProperties.class)\n@ConditionalOnProperty(prefix = JdbcPlusProperties.PREFIX, name = \"enabled\", havingValue = \"true\", matchIfMissing = true)\npublic class JdbcPlusAutoConfiguration {\n\n    @Autowired\n    private JdbcPlusProperties jdbcPlusProperties;\n\n    @Bean", "    public Advisor jdbcTemplateMethodAdvisor(List<IInterceptor> interceptors) {\n        JdbcTemplateMethodInterceptor interceptor = new JdbcTemplateMethodInterceptor(interceptors);\n        return new JdbcTemplateMethodAdvisor(interceptor);\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/JsqlParserSupport.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.Interceptor;\n\nimport com.github.deeround.jdbc.plus.util.ExceptionUtils;", "\nimport com.github.deeround.jdbc.plus.util.ExceptionUtils;\nimport com.github.deeround.jdbc.plus.util.StringPool;\nimport lombok.extern.slf4j.Slf4j;\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserUtil;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.Statements;\nimport net.sf.jsqlparser.statement.delete.Delete;\nimport net.sf.jsqlparser.statement.insert.Insert;", "import net.sf.jsqlparser.statement.delete.Delete;\nimport net.sf.jsqlparser.statement.insert.Insert;\nimport net.sf.jsqlparser.statement.select.Select;\nimport net.sf.jsqlparser.statement.update.Update;\n\n/**\n * https://github.com/JSQLParser/JSqlParser\n *\n * @author miemie\n * @since 2020-06-22", " * @author miemie\n * @since 2020-06-22\n */\n@Slf4j\npublic abstract class JsqlParserSupport {\n\n    public String parserSingle(String sql, Object obj) {\n        try {\n            Statement statement = CCJSqlParserUtil.parse(sql);\n            return this.processParser(statement, 0, sql, obj);\n        } catch (JSQLParserException e) {\n            throw ExceptionUtils.mpe(\"Failed to process, Error SQL: %s\", e.getCause(), sql);\n        }\n    }\n", "    public String parserMulti(String sql, Object obj) {\n        try {\n            // fixed github pull/295\n            StringBuilder sb = new StringBuilder();\n            Statements statements = CCJSqlParserUtil.parseStatements(sql);\n            int i = 0;\n            for (Statement statement : statements.getStatements()) {\n                if (i > 0) {\n                    sb.append(StringPool.SEMICOLON);\n                }\n                sb.append(this.processParser(statement, i, sql, obj));\n                i++;\n            }\n            return sb.toString();\n        } catch (JSQLParserException e) {\n            throw ExceptionUtils.mpe(\"Failed to process, Error SQL: %s\", e.getCause(), sql);\n        }\n    }\n\n    /**\n     * \u6267\u884c SQL \u89e3\u6790\n     *\n     * @param statement JsqlParser Statement\n     * @return sql\n     */\n    protected String processParser(Statement statement, int index, String sql, Object obj) {\n        log.debug(\"original SQL: \" + sql);", "        if (statement instanceof Insert) {\n            this.processInsert((Insert) statement, index, sql, obj);\n        } else if (statement instanceof Select) {\n            this.processSelect((Select) statement, index, sql, obj);\n        } else if (statement instanceof Update) {\n            this.processUpdate((Update) statement, index, sql, obj);\n        } else if (statement instanceof Delete) {\n            this.processDelete((Delete) statement, index, sql, obj);\n        }\n        sql = statement.toString();\n        log.debug(\"parse the finished SQL: \" + sql);\n        return sql;\n    }\n\n    /**\n     * \u65b0\u589e\n     */\n    protected void processInsert(Insert insert, int index, String sql, Object obj) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * \u5220\u9664\n     */\n    protected void processDelete(Delete delete, int index, String sql, Object obj) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * \u66f4\u65b0\n     */\n    protected void processUpdate(Update update, int index, String sql, Object obj) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * \u67e5\u8be2\n     */\n    protected void processSelect(Select select, int index, String sql, Object obj) {\n        throw new UnsupportedOperationException();\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/PaginationInterceptor.java", "chunked_list": ["package com.github.deeround.jdbc.plus.Interceptor;\n\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.Dialect;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.Page;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.PageHelper;\nimport com.github.deeround.jdbc.plus.method.MethodActionInfo;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport com.github.deeround.jdbc.plus.method.MethodType;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.jdbc.core.JdbcTemplate;", "import org.springframework.dao.DataAccessException;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.PreparedStatementSetter;\nimport org.springframework.jdbc.core.ResultSetExtractor;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;", "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/19 9:30\n */\npublic class PaginationInterceptor implements IInterceptor {\n\n    @Override\n    public boolean supportMethod(final MethodInvocationInfo methodInfo) {\n", "    public boolean supportMethod(final MethodInvocationInfo methodInfo) {\n\n        if (!methodInfo.isSupport()) {\n            return false;\n        }\n\n        if (MethodType.QUERY.equals(methodInfo.getType())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override", "    public void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        Page<Object> localPage = PageHelper.getLocalPage();\n        if (localPage == null) {\n            return;\n        }\n\n        try {\n            MethodActionInfo actionInfo = methodInfo.getActionInfo();\n            Dialect dialect = PageHelper.getDialect(jdbcTemplate);\n            String sql = actionInfo.getSql();\n\n            //\u67e5\u8be2\u6c47\u603b", "            if (localPage.isCount() && methodInfo.getActionInfo().isReturnIsList()) {\n\n                if (actionInfo.isHasParameter()) {\n                    if (actionInfo.isParameterIsPss()) {\n                        Object cnt = jdbcTemplate.query(dialect.getCountSql(sql), (PreparedStatementSetter) methodInfo.getArgs()[actionInfo.getParameterIndex()], new ResultSetExtractor<Map>() {\n                            @Override\n                            public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                                while (rs.next()) {\n                                    Map<String, Object> map = new HashMap<>();\n                                    map.put(\"PG_COUNT\", rs.getLong(\"PG_COUNT\"));\n                                    return map;\n                                }\n                                return new HashMap<>();\n                            }\n                        }).get(\"PG_COUNT\");\n                        localPage.setTotal(Long.parseLong(cnt.toString()));\n                    } else {", "                        if (actionInfo.isHasParameterType()) {\n                            Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter(), actionInfo.getParameterType()).get(\"PG_COUNT\");\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        } else {\n                            Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        }\n                    }\n                } else {\n                    Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql)).get(\"PG_COUNT\");\n                    localPage.setTotal(Long.parseLong(cnt.toString()));\n                }\n            }\n\n            //\u751f\u6210\u5206\u9875SQL\n            sql = dialect.getPageSql(sql, localPage.getPageNum(), localPage.getPageSize());\n\n            methodInfo.resolveSql(sql);\n        } catch (Exception e) {\n            PageHelper.clearPage();\n            throw e;\n        }\n    }\n\n    @Override", "    public Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        Page<Object> localPage = PageHelper.getLocalPage();\n        if (localPage == null) {\n            return result;\n        }\n\n        try {\n            if (methodInfo.getActionInfo().isReturnIsList()) {\n                if (result != null) {\n                    localPage.addAll((Collection<?>) result);\n                }\n                return localPage;\n            } else {\n                return result;\n            }\n        } finally {\n            PageHelper.clearPage();\n        }\n    }\n}\n", "                if (result != null) {\n                    localPage.addAll((Collection<?>) result);\n                }\n                return localPage;\n            } else {\n                return result;\n            }\n        } finally {\n            PageHelper.clearPage();\n        }\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/BaseMultiTableInterceptor.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.Interceptor;\n\nimport com.github.deeround.jdbc.plus.util.CollectionUtils;", "\nimport com.github.deeround.jdbc.plus.util.CollectionUtils;\nimport lombok.extern.slf4j.Slf4j;\nimport net.sf.jsqlparser.expression.*;\nimport net.sf.jsqlparser.expression.operators.conditional.AndExpression;\nimport net.sf.jsqlparser.expression.operators.conditional.OrExpression;\nimport net.sf.jsqlparser.expression.operators.relational.ExistsExpression;\nimport net.sf.jsqlparser.expression.operators.relational.ExpressionList;\nimport net.sf.jsqlparser.expression.operators.relational.InExpression;\nimport net.sf.jsqlparser.schema.Table;", "import net.sf.jsqlparser.expression.operators.relational.InExpression;\nimport net.sf.jsqlparser.schema.Table;\nimport net.sf.jsqlparser.statement.select.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * \u591a\u8868\u6761\u4ef6\u5904\u7406\u57fa\u5bf9\u8c61\uff0c\u4ece\u539f\u6709\u7684 {@link TenantLineInterceptor} \u62e6\u622a\u5668\u4e2d\u63d0\u53d6\u51fa\u6765\n *", " * \u591a\u8868\u6761\u4ef6\u5904\u7406\u57fa\u5bf9\u8c61\uff0c\u4ece\u539f\u6709\u7684 {@link TenantLineInterceptor} \u62e6\u622a\u5668\u4e2d\u63d0\u53d6\u51fa\u6765\n *\n * @author houkunlin\n * @since 3.5.2\n */\n@Slf4j\npublic abstract class BaseMultiTableInterceptor extends JsqlParserSupport implements IInterceptor {\n\n    protected void processSelectBody(SelectBody selectBody, final String whereSegment) {\n        if (selectBody == null) {\n            return;\n        }", "        if (selectBody == null) {\n            return;\n        }\n        if (selectBody instanceof PlainSelect) {\n            this.processPlainSelect((PlainSelect) selectBody, whereSegment);\n        } else if (selectBody instanceof WithItem) {\n            WithItem withItem = (WithItem) selectBody;\n            this.processSelectBody(withItem.getSubSelect().getSelectBody(), whereSegment);\n        } else {\n            SetOperationList operationList = (SetOperationList) selectBody;\n            List<SelectBody> selectBodyList = operationList.getSelects();", "            if (CollectionUtils.isNotEmpty(selectBodyList)) {\n                selectBodyList.forEach(body -> this.processSelectBody(body, whereSegment));\n            }\n        }\n    }\n\n    /**\n     * delete update \u8bed\u53e5 where \u5904\u7406\n     */\n    protected Expression andExpression(Table table, Expression where, final String whereSegment) {\n        //\u83b7\u5f97where\u6761\u4ef6\u8868\u8fbe\u5f0f\n        final Expression expression = this.buildTableExpression(table, where, whereSegment);", "        if (expression == null) {\n            return where;\n        }\n        if (where != null) {\n            if (where instanceof OrExpression) {\n                return new AndExpression(new Parenthesis(where), expression);\n            } else {\n                return new AndExpression(where, expression);\n            }\n        }\n        return expression;\n    }\n\n    /**\n     * \u5904\u7406 PlainSelect\n     */\n    protected void processPlainSelect(final PlainSelect plainSelect, final String whereSegment) {\n        //#3087 github\n        List<SelectItem> selectItems = plainSelect.getSelectItems();", "        if (CollectionUtils.isNotEmpty(selectItems)) {\n            selectItems.forEach(selectItem -> this.processSelectItem(selectItem, whereSegment));\n        }\n\n        // \u5904\u7406 where \u4e2d\u7684\u5b50\u67e5\u8be2\n        Expression where = plainSelect.getWhere();\n        this.processWhereSubSelect(where, whereSegment);\n\n        // \u5904\u7406 fromItem\n        FromItem fromItem = plainSelect.getFromItem();\n        List<Table> list = this.processFromItem(fromItem, whereSegment);\n        List<Table> mainTables = new ArrayList<>(list);\n\n        // \u5904\u7406 join\n        List<Join> joins = plainSelect.getJoins();", "        if (CollectionUtils.isNotEmpty(joins)) {\n            mainTables = this.processJoins(mainTables, joins, whereSegment);\n        }\n\n        // \u5f53\u6709 mainTable \u65f6\uff0c\u8fdb\u884c where \u6761\u4ef6\u8ffd\u52a0\n        if (CollectionUtils.isNotEmpty(mainTables)) {\n            plainSelect.setWhere(this.builderExpression(where, mainTables, whereSegment));\n        }\n    }\n\n    private List<Table> processFromItem(FromItem fromItem, final String whereSegment) {\n        // \u5904\u7406\u62ec\u53f7\u62ec\u8d77\u6765\u7684\u8868\u8fbe\u5f0f", "        while (fromItem instanceof ParenthesisFromItem) {\n            fromItem = ((ParenthesisFromItem) fromItem).getFromItem();\n        }\n\n        List<Table> mainTables = new ArrayList<>();\n        // \u65e0 join \u65f6\u7684\u5904\u7406\u903b\u8f91\n        if (fromItem instanceof Table) {\n            Table fromTable = (Table) fromItem;\n            mainTables.add(fromTable);\n        } else if (fromItem instanceof SubJoin) {\n            // SubJoin \u7c7b\u578b\u5219\u8fd8\u9700\u8981\u6dfb\u52a0\u4e0a where \u6761\u4ef6\n            List<Table> tables = this.processSubJoin((SubJoin) fromItem, whereSegment);\n            mainTables.addAll(tables);\n        } else {\n            // \u5904\u7406\u4e0b fromItem\n            this.processOtherFromItem(fromItem, whereSegment);\n        }\n        return mainTables;\n    }\n\n    /**\n     * \u5904\u7406where\u6761\u4ef6\u5185\u7684\u5b50\u67e5\u8be2\n     * <p>\n     * \u652f\u6301\u5982\u4e0b:\n     * <ol>\n     *     <li>in</li>\n     *     <li>=</li>\n     *     <li>&gt;</li>\n     *     <li>&lt;</li>\n     *     <li>&gt;=</li>\n     *     <li>&lt;=</li>\n     *     <li>&lt;&gt;</li>\n     *     <li>EXISTS</li>\n     *     <li>NOT EXISTS</li>\n     * </ol>\n     * <p>\n     * \u524d\u63d0\u6761\u4ef6:\n     * 1. \u5b50\u67e5\u8be2\u5fc5\u987b\u653e\u5728\u5c0f\u62ec\u53f7\u4e2d\n     * 2. \u5b50\u67e5\u8be2\u4e00\u822c\u653e\u5728\u6bd4\u8f83\u64cd\u4f5c\u7b26\u7684\u53f3\u8fb9\n     *\n     * @param where where \u6761\u4ef6\n     */\n    protected void processWhereSubSelect(Expression where, final String whereSegment) {", "        } else if (fromItem instanceof SubJoin) {\n            // SubJoin \u7c7b\u578b\u5219\u8fd8\u9700\u8981\u6dfb\u52a0\u4e0a where \u6761\u4ef6\n            List<Table> tables = this.processSubJoin((SubJoin) fromItem, whereSegment);\n            mainTables.addAll(tables);\n        } else {\n            // \u5904\u7406\u4e0b fromItem\n            this.processOtherFromItem(fromItem, whereSegment);\n        }\n        return mainTables;\n    }\n\n    /**\n     * \u5904\u7406where\u6761\u4ef6\u5185\u7684\u5b50\u67e5\u8be2\n     * <p>\n     * \u652f\u6301\u5982\u4e0b:\n     * <ol>\n     *     <li>in</li>\n     *     <li>=</li>\n     *     <li>&gt;</li>\n     *     <li>&lt;</li>\n     *     <li>&gt;=</li>\n     *     <li>&lt;=</li>\n     *     <li>&lt;&gt;</li>\n     *     <li>EXISTS</li>\n     *     <li>NOT EXISTS</li>\n     * </ol>\n     * <p>\n     * \u524d\u63d0\u6761\u4ef6:\n     * 1. \u5b50\u67e5\u8be2\u5fc5\u987b\u653e\u5728\u5c0f\u62ec\u53f7\u4e2d\n     * 2. \u5b50\u67e5\u8be2\u4e00\u822c\u653e\u5728\u6bd4\u8f83\u64cd\u4f5c\u7b26\u7684\u53f3\u8fb9\n     *\n     * @param where where \u6761\u4ef6\n     */\n    protected void processWhereSubSelect(Expression where, final String whereSegment) {", "        if (where == null) {\n            return;\n        }\n        if (where instanceof FromItem) {\n            this.processOtherFromItem((FromItem) where, whereSegment);\n            return;\n        }\n        if (where.toString().indexOf(\"SELECT\") > 0) {\n            // \u6709\u5b50\u67e5\u8be2\n            if (where instanceof BinaryExpression) {\n                // \u6bd4\u8f83\u7b26\u53f7 , and , or , \u7b49\u7b49\n                BinaryExpression expression = (BinaryExpression) where;\n                this.processWhereSubSelect(expression.getLeftExpression(), whereSegment);\n                this.processWhereSubSelect(expression.getRightExpression(), whereSegment);", "            if (where instanceof BinaryExpression) {\n                // \u6bd4\u8f83\u7b26\u53f7 , and , or , \u7b49\u7b49\n                BinaryExpression expression = (BinaryExpression) where;\n                this.processWhereSubSelect(expression.getLeftExpression(), whereSegment);\n                this.processWhereSubSelect(expression.getRightExpression(), whereSegment);\n            } else if (where instanceof InExpression) {\n                // in\n                InExpression expression = (InExpression) where;\n                Expression inExpression = expression.getRightExpression();\n                if (inExpression instanceof SubSelect) {\n                    this.processSelectBody(((SubSelect) inExpression).getSelectBody(), whereSegment);\n                }", "                if (inExpression instanceof SubSelect) {\n                    this.processSelectBody(((SubSelect) inExpression).getSelectBody(), whereSegment);\n                }\n            } else if (where instanceof ExistsExpression) {\n                // exists\n                ExistsExpression expression = (ExistsExpression) where;\n                this.processWhereSubSelect(expression.getRightExpression(), whereSegment);\n            } else if (where instanceof NotExpression) {\n                // not exists\n                NotExpression expression = (NotExpression) where;\n                this.processWhereSubSelect(expression.getExpression(), whereSegment);", "            } else if (where instanceof Parenthesis) {\n                Parenthesis expression = (Parenthesis) where;\n                this.processWhereSubSelect(expression.getExpression(), whereSegment);\n            }\n        }\n    }\n\n    protected void processSelectItem(SelectItem selectItem, final String whereSegment) {\n        if (selectItem instanceof SelectExpressionItem) {\n            SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n            final Expression expression = selectExpressionItem.getExpression();", "        if (selectItem instanceof SelectExpressionItem) {\n            SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n            final Expression expression = selectExpressionItem.getExpression();\n            if (expression instanceof SubSelect) {\n                this.processSelectBody(((SubSelect) expression).getSelectBody(), whereSegment);\n            } else if (expression instanceof Function) {\n                this.processFunction((Function) expression, whereSegment);\n            }\n        }\n    }\n\n    /**\n     * \u5904\u7406\u51fd\u6570\n     * <p>\u652f\u6301: 1. select fun(args..) 2. select fun1(fun2(args..),args..)<p>\n     * <p> fixed gitee pulls/141</p>\n     *\n     * @param function\n     */\n    protected void processFunction(Function function, final String whereSegment) {\n        ExpressionList parameters = function.getParameters();", "        if (parameters != null) {\n            parameters.getExpressions().forEach(expression -> {\n                if (expression instanceof SubSelect) {\n                    this.processSelectBody(((SubSelect) expression).getSelectBody(), whereSegment);\n                } else if (expression instanceof Function) {\n                    this.processFunction((Function) expression, whereSegment);\n                }\n            });\n        }\n    }\n\n    /**\n     * \u5904\u7406\u5b50\u67e5\u8be2\u7b49\n     */\n    protected void processOtherFromItem(FromItem fromItem, final String whereSegment) {\n        // \u53bb\u9664\u62ec\u53f7", "        while (fromItem instanceof ParenthesisFromItem) {\n            fromItem = ((ParenthesisFromItem) fromItem).getFromItem();\n        }\n\n        if (fromItem instanceof SubSelect) {\n            SubSelect subSelect = (SubSelect) fromItem;\n            if (subSelect.getSelectBody() != null) {\n                this.processSelectBody(subSelect.getSelectBody(), whereSegment);\n            }\n        } else if (fromItem instanceof ValuesList) {\n            log.debug(\"Perform a subQuery, if you do not give us feedback\");", "        } else if (fromItem instanceof ValuesList) {\n            log.debug(\"Perform a subQuery, if you do not give us feedback\");\n        } else if (fromItem instanceof LateralSubSelect) {\n            LateralSubSelect lateralSubSelect = (LateralSubSelect) fromItem;\n            if (lateralSubSelect.getSubSelect() != null) {\n                SubSelect subSelect = lateralSubSelect.getSubSelect();\n                if (subSelect.getSelectBody() != null) {\n                    this.processSelectBody(subSelect.getSelectBody(), whereSegment);\n                }\n            }\n        }\n    }\n\n    /**\n     * \u5904\u7406 sub join\n     *\n     * @param subJoin subJoin\n     * @return Table subJoin \u4e2d\u7684\u4e3b\u8868\n     */\n    private List<Table> processSubJoin(SubJoin subJoin, final String whereSegment) {\n        List<Table> mainTables = new ArrayList<>();", "        if (subJoin.getJoinList() != null) {\n            List<Table> list = this.processFromItem(subJoin.getLeft(), whereSegment);\n            mainTables.addAll(list);\n            mainTables = this.processJoins(mainTables, subJoin.getJoinList(), whereSegment);\n        }\n        return mainTables;\n    }\n\n    /**\n     * \u5904\u7406 joins\n     *\n     * @param mainTables \u53ef\u4ee5\u4e3a null\n     * @param joins      join \u96c6\u5408\n     * @return List<Table> \u53f3\u8fde\u63a5\u67e5\u8be2\u7684 Table \u5217\u8868\n     */\n    private List<Table> processJoins(List<Table> mainTables, List<Join> joins, final String whereSegment) {\n        // join \u8868\u8fbe\u5f0f\u4e2d\u6700\u7ec8\u7684\u4e3b\u8868\n        Table mainTable = null;\n        // \u5f53\u524d join \u7684\u5de6\u8868\n        Table leftTable = null;\n", "        if (mainTables == null) {\n            mainTables = new ArrayList<>();\n        } else if (mainTables.size() == 1) {\n            mainTable = mainTables.get(0);\n            leftTable = mainTable;\n        }\n\n        //\u5bf9\u4e8e on \u8868\u8fbe\u5f0f\u5199\u5728\u6700\u540e\u7684 join\uff0c\u9700\u8981\u8bb0\u5f55\u4e0b\u524d\u9762\u591a\u4e2a on \u7684\u8868\u540d\n        Deque<List<Table>> onTableDeque = new LinkedList<>();\n        for (Join join : joins) {\n            // \u5904\u7406 on \u8868\u8fbe\u5f0f\n            FromItem joinItem = join.getRightItem();\n\n            // \u83b7\u53d6\u5f53\u524d join \u7684\u8868\uff0csubJoint \u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u5f20\u8868\n            List<Table> joinTables = null;", "        for (Join join : joins) {\n            // \u5904\u7406 on \u8868\u8fbe\u5f0f\n            FromItem joinItem = join.getRightItem();\n\n            // \u83b7\u53d6\u5f53\u524d join \u7684\u8868\uff0csubJoint \u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u5f20\u8868\n            List<Table> joinTables = null;\n            if (joinItem instanceof Table) {\n                joinTables = new ArrayList<>();\n                joinTables.add((Table) joinItem);\n            } else if (joinItem instanceof SubJoin) {\n                joinTables = this.processSubJoin((SubJoin) joinItem, whereSegment);\n            }\n", "            } else if (joinItem instanceof SubJoin) {\n                joinTables = this.processSubJoin((SubJoin) joinItem, whereSegment);\n            }\n\n            if (joinTables != null) {\n\n                // \u5982\u679c\u662f\u9690\u5f0f\u5185\u8fde\u63a5\n                if (join.isSimple()) {\n                    mainTables.addAll(joinTables);\n                    continue;\n                }\n\n                // \u5f53\u524d\u8868\u662f\u5426\u5ffd\u7565\n                Table joinTable = joinTables.get(0);\n\n                List<Table> onTables = null;\n                // \u5982\u679c\u4e0d\u8981\u5ffd\u7565\uff0c\u4e14\u662f\u53f3\u8fde\u63a5\uff0c\u5219\u8bb0\u5f55\u4e0b\u5f53\u524d\u8868", "                if (join.isRight()) {\n                    mainTable = joinTable;\n                    if (leftTable != null) {\n                        onTables = Collections.singletonList(leftTable);\n                    }\n                } else if (join.isInner()) {\n                    if (mainTable == null) {\n                        onTables = Collections.singletonList(joinTable);\n                    } else {\n                        onTables = Arrays.asList(mainTable, joinTable);\n                    }\n                    mainTable = null;\n                } else {\n                    onTables = Collections.singletonList(joinTable);\n                }\n\n                mainTables = new ArrayList<>();", "                if (mainTable != null) {\n                    mainTables.add(mainTable);\n                }\n\n                // \u83b7\u53d6 join \u5c3e\u7f00\u7684 on \u8868\u8fbe\u5f0f\u5217\u8868\n                Collection<Expression> originOnExpressions = join.getOnExpressions();\n                // \u6b63\u5e38 join on \u8868\u8fbe\u5f0f\u53ea\u6709\u4e00\u4e2a\uff0c\u7acb\u523b\u5904\u7406\n                if (originOnExpressions.size() == 1 && onTables != null) {\n                    List<Expression> onExpressions = new LinkedList<>();\n                    onExpressions.add(this.builderExpression(originOnExpressions.iterator().next(), onTables, whereSegment));\n                    join.setOnExpressions(onExpressions);\n                    leftTable = joinTable;\n                    continue;\n                }\n                // \u8868\u540d\u538b\u6808\uff0c\u5ffd\u7565\u7684\u8868\u538b\u5165 null\uff0c\u4ee5\u4fbf\u540e\u7eed\u4e0d\u5904\u7406\n                onTableDeque.push(onTables);\n                // \u5c3e\u7f00\u591a\u4e2a on \u8868\u8fbe\u5f0f\u7684\u65f6\u5019\u7edf\u4e00\u5904\u7406", "                if (originOnExpressions.size() > 1) {\n                    Collection<Expression> onExpressions = new LinkedList<>();\n                    for (Expression originOnExpression : originOnExpressions) {\n                        List<Table> currentTableList = onTableDeque.poll();\n                        if (CollectionUtils.isEmpty(currentTableList)) {\n                            onExpressions.add(originOnExpression);\n                        } else {\n                            onExpressions.add(this.builderExpression(originOnExpression, currentTableList, whereSegment));\n                        }\n                    }\n                    join.setOnExpressions(onExpressions);\n                }\n                leftTable = joinTable;\n            } else {\n                this.processOtherFromItem(joinItem, whereSegment);\n                leftTable = null;\n            }\n        }\n\n        return mainTables;\n    }\n\n    /**\n     * \u5904\u7406\u6761\u4ef6\n     */\n    protected Expression builderExpression(Expression currentExpression, List<Table> tables, final String whereSegment) {\n        // \u6ca1\u6709\u8868\u9700\u8981\u5904\u7406\u76f4\u63a5\u8fd4\u56de", "        if (CollectionUtils.isEmpty(tables)) {\n            return currentExpression;\n        }\n        // \u6784\u9020\u6bcf\u5f20\u8868\u7684\u6761\u4ef6\n        List<Expression> expressions = tables.stream()\n                .map(item -> this.buildTableExpression(item, currentExpression, whereSegment))\n                .filter(Objects::nonNull)\n                .collect(Collectors.toList());\n\n        // \u6ca1\u6709\u8868\u9700\u8981\u5904\u7406\u76f4\u63a5\u8fd4\u56de\n        if (CollectionUtils.isEmpty(expressions)) {\n            return currentExpression;\n        }\n\n        // \u6ce8\u5165\u7684\u8868\u8fbe\u5f0f\n        Expression injectExpression = expressions.get(0);\n        // \u5982\u679c\u6709\u591a\u8868\uff0c\u5219\u7528 and \u8fde\u63a5", "        if (CollectionUtils.isEmpty(expressions)) {\n            return currentExpression;\n        }\n\n        // \u6ce8\u5165\u7684\u8868\u8fbe\u5f0f\n        Expression injectExpression = expressions.get(0);\n        // \u5982\u679c\u6709\u591a\u8868\uff0c\u5219\u7528 and \u8fde\u63a5\n        if (expressions.size() > 1) {\n            for (int i = 1; i < expressions.size(); i++) {\n                injectExpression = new AndExpression(injectExpression, expressions.get(i));\n            }\n        }\n", "            for (int i = 1; i < expressions.size(); i++) {\n                injectExpression = new AndExpression(injectExpression, expressions.get(i));\n            }\n        }\n\n        if (currentExpression == null) {\n            return injectExpression;\n        }\n        if (currentExpression instanceof OrExpression) {\n            return new AndExpression(new Parenthesis(currentExpression), injectExpression);\n        } else {\n            return new AndExpression(currentExpression, injectExpression);\n        }\n    }\n\n    /**\n     * \u6784\u5efa\u6570\u636e\u5e93\u8868\u7684\u67e5\u8be2\u6761\u4ef6\n     *\n     * @param table        \u8868\u5bf9\u8c61\n     * @param where        \u5f53\u524dwhere\u6761\u4ef6\n     * @param whereSegment \u6240\u5c5eMapper\u5bf9\u8c61\u5168\u8def\u5f84\n     * @return \u9700\u8981\u62fc\u63a5\u7684\u65b0\u6761\u4ef6\uff08\u4e0d\u4f1a\u8986\u76d6\u539f\u6709\u7684where\u6761\u4ef6\uff0c\u53ea\u4f1a\u5728\u539f\u6709\u6761\u4ef6\u4e0a\u518d\u52a0\u6761\u4ef6\uff09\uff0c\u4e3a null \u5219\u4e0d\u52a0\u5165\u65b0\u7684\u6761\u4ef6\n     */", "        if (currentExpression instanceof OrExpression) {\n            return new AndExpression(new Parenthesis(currentExpression), injectExpression);\n        } else {\n            return new AndExpression(currentExpression, injectExpression);\n        }\n    }\n\n    /**\n     * \u6784\u5efa\u6570\u636e\u5e93\u8868\u7684\u67e5\u8be2\u6761\u4ef6\n     *\n     * @param table        \u8868\u5bf9\u8c61\n     * @param where        \u5f53\u524dwhere\u6761\u4ef6\n     * @param whereSegment \u6240\u5c5eMapper\u5bf9\u8c61\u5168\u8def\u5f84\n     * @return \u9700\u8981\u62fc\u63a5\u7684\u65b0\u6761\u4ef6\uff08\u4e0d\u4f1a\u8986\u76d6\u539f\u6709\u7684where\u6761\u4ef6\uff0c\u53ea\u4f1a\u5728\u539f\u6709\u6761\u4ef6\u4e0a\u518d\u52a0\u6761\u4ef6\uff09\uff0c\u4e3a null \u5219\u4e0d\u52a0\u5165\u65b0\u7684\u6761\u4ef6\n     */", "    public abstract Expression buildTableExpression(final Table table, final Expression where, final String whereSegment);\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/IInterceptor.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.Interceptor;\n\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;", "\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\n/**\n * @author miemie\n * @since 3.4.0\n */\npublic interface IInterceptor {\n\n    default boolean supportMethod(final MethodInvocationInfo methodInfo) {\n        return true;\n    }\n\n    default void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        // do nothing\n    }\n\n    default Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        // do nothing\n        return result;\n    }\n}\n", "public interface IInterceptor {\n\n    default boolean supportMethod(final MethodInvocationInfo methodInfo) {\n        return true;\n    }\n\n    default void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        // do nothing\n    }\n\n    default Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        // do nothing\n        return result;\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/DynamicTableNameInterceptor.java", "chunked_list": ["package com.github.deeround.jdbc.plus.Interceptor;/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport com.github.deeround.jdbc.plus.handler.TableNameHandler;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;", "import com.github.deeround.jdbc.plus.handler.TableNameHandler;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport com.github.deeround.jdbc.plus.method.MethodType;\nimport com.github.deeround.jdbc.plus.util.TableNameParser;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n", "\n\n/**\n * \u52a8\u6001\u8868\u540d\n *\n * @author wanghao\n */\npublic class DynamicTableNameInterceptor implements IInterceptor {\n    /**\n     * \u8868\u540d\u5904\u7406\u5668\uff0c\u662f\u5426\u5904\u7406\u8868\u540d\u7684\u60c5\u51b5\u90fd\u5728\u8be5\u5904\u7406\u5668\u4e2d\u81ea\u884c\u5224\u65ad\n     */\n    private TableNameHandler tableNameHandler;\n\n    public DynamicTableNameInterceptor(TableNameHandler tableNameHandler) {\n        this.tableNameHandler = tableNameHandler;\n    }\n\n    @Override", "    public boolean supportMethod(MethodInvocationInfo methodInfo) {\n\n        if (!methodInfo.isSupport()) {\n            return false;\n        }\n\n        if (MethodType.UPDATE.equals(methodInfo.getType()) || MethodType.QUERY.equals(methodInfo.getType())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override", "    public void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        if (methodInfo.getActionInfo() != null && methodInfo.getActionInfo().getBatchSql() != null) {\n            for (int i = 0; i < methodInfo.getActionInfo().getBatchSql().length; i++) {\n                methodInfo.resolveSql(i, this.changeTable(methodInfo.getActionInfo().getBatchSql()[i]));\n            }\n        }\n    }\n\n    protected String changeTable(String sql) {\n        TableNameParser parser = new TableNameParser(sql);\n        List<TableNameParser.SqlToken> names = new ArrayList<>();\n        parser.accept(names::add);\n        StringBuilder builder = new StringBuilder();\n        int last = 0;", "        for (TableNameParser.SqlToken name : names) {\n            int start = name.getStart();\n            if (start != last) {\n                builder.append(sql, last, start);\n                builder.append(this.tableNameHandler.dynamicTableName(sql, name.getValue()));\n            }\n            last = name.getEnd();\n        }\n        if (last != sql.length()) {\n            builder.append(sql.substring(last));\n        }\n        return builder.toString();\n    }\n}\n", "        if (last != sql.length()) {\n            builder.append(sql.substring(last));\n        }\n        return builder.toString();\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/TenantLineInterceptor.java", "chunked_list": ["/*\n * Copyright (c) 2011-2022, baomidou (jobob@qq.com).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.Interceptor;\n\n", "\n\nimport com.github.deeround.jdbc.plus.handler.TenantLineHandler;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport com.github.deeround.jdbc.plus.method.MethodType;\nimport com.github.deeround.jdbc.plus.util.CollectionUtils;\nimport com.github.deeround.jdbc.plus.util.ExceptionUtils;\nimport com.github.deeround.jdbc.plus.util.StringPool;\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.StringValue;", "import net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.StringValue;\nimport net.sf.jsqlparser.expression.operators.relational.EqualsTo;\nimport net.sf.jsqlparser.expression.operators.relational.ExpressionList;\nimport net.sf.jsqlparser.expression.operators.relational.ItemsList;\nimport net.sf.jsqlparser.expression.operators.relational.MultiExpressionList;\nimport net.sf.jsqlparser.schema.Column;\nimport net.sf.jsqlparser.schema.Table;\nimport net.sf.jsqlparser.statement.delete.Delete;\nimport net.sf.jsqlparser.statement.insert.Insert;", "import net.sf.jsqlparser.statement.delete.Delete;\nimport net.sf.jsqlparser.statement.insert.Insert;\nimport net.sf.jsqlparser.statement.select.*;\nimport net.sf.jsqlparser.statement.update.Update;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * @author hubin", "/**\n * @author hubin\n * @since 3.4.0\n */\npublic class TenantLineInterceptor extends BaseMultiTableInterceptor implements IInterceptor {\n\n    private final TenantLineHandler tenantLineHandler;\n\n    public TenantLineInterceptor(TenantLineHandler tenantLineHandler) {\n        this.tenantLineHandler = tenantLineHandler;\n    }\n\n    @Override", "    public boolean supportMethod(MethodInvocationInfo methodInfo) {\n\n        if (!methodInfo.isSupport()) {\n            return false;\n        }\n\n        if (MethodType.UPDATE.equals(methodInfo.getType()) || MethodType.QUERY.equals(methodInfo.getType())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override", "    public void beforePrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        if (methodInfo.getActionInfo() != null && methodInfo.getActionInfo().getBatchSql() != null) {\n            for (int i = 0; i < methodInfo.getActionInfo().getBatchSql().length; i++) {\n                methodInfo.resolveSql(i, this.parserMulti(methodInfo.getActionInfo().getBatchSql()[i], null));\n            }\n        }\n    }\n\n    @Override\n    public Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        return result;\n    }\n\n    @Override\n    protected void processSelect(Select select, int index, String sql, Object obj) {\n        final String whereSegment = (String) obj;\n        this.processSelectBody(select.getSelectBody(), whereSegment);\n        List<WithItem> withItemsList = select.getWithItemsList();", "    public Object beforeFinish(Object result, final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        return result;\n    }\n\n    @Override\n    protected void processSelect(Select select, int index, String sql, Object obj) {\n        final String whereSegment = (String) obj;\n        this.processSelectBody(select.getSelectBody(), whereSegment);\n        List<WithItem> withItemsList = select.getWithItemsList();\n        if (!CollectionUtils.isEmpty(withItemsList)) {\n            withItemsList.forEach(withItem -> this.processSelectBody(withItem, whereSegment));\n        }\n    }\n\n    @Override\n    protected void processInsert(Insert insert, int index, String sql, Object obj) {", "        if (!CollectionUtils.isEmpty(withItemsList)) {\n            withItemsList.forEach(withItem -> this.processSelectBody(withItem, whereSegment));\n        }\n    }\n\n    @Override\n    protected void processInsert(Insert insert, int index, String sql, Object obj) {\n        if (this.tenantLineHandler.ignoreTable(insert.getTable().getName())) {\n            // \u8fc7\u6ee4\u9000\u51fa\u6267\u884c\n            return;\n        }\n        List<Column> columns = insert.getColumns();", "        if (CollectionUtils.isEmpty(columns)) {\n            // \u9488\u5bf9\u4e0d\u7ed9\u5217\u540d\u7684insert \u4e0d\u5904\u7406\n            return;\n        }\n        String tenantIdColumn = this.tenantLineHandler.getTenantIdColumn();\n        if (this.tenantLineHandler.ignoreInsert(columns, tenantIdColumn)) {\n            // \u9488\u5bf9\u5df2\u7ed9\u51fa\u79df\u6237\u5217\u7684insert \u4e0d\u5904\u7406\n            return;\n        }\n        columns.add(new Column(tenantIdColumn));\n\n        // fixed gitee pulls/141 duplicate update\n        List<Expression> duplicateUpdateColumns = insert.getDuplicateUpdateExpressionList();", "        if (CollectionUtils.isNotEmpty(duplicateUpdateColumns)) {\n            EqualsTo equalsTo = new EqualsTo();\n            equalsTo.setLeftExpression(new StringValue(tenantIdColumn));\n            equalsTo.setRightExpression(this.tenantLineHandler.getTenantId());\n            duplicateUpdateColumns.add(equalsTo);\n        }\n\n        Select select = insert.getSelect();\n        if (select != null) {\n            this.processInsertSelect(select.getSelectBody(), (String) obj);\n        } else if (insert.getItemsList() != null) {\n            // fixed github pull/295\n            ItemsList itemsList = insert.getItemsList();\n            Expression tenantId = this.tenantLineHandler.getTenantId();", "        if (select != null) {\n            this.processInsertSelect(select.getSelectBody(), (String) obj);\n        } else if (insert.getItemsList() != null) {\n            // fixed github pull/295\n            ItemsList itemsList = insert.getItemsList();\n            Expression tenantId = this.tenantLineHandler.getTenantId();\n            if (itemsList instanceof MultiExpressionList) {\n                ((MultiExpressionList) itemsList).getExpressionLists().forEach(el -> el.getExpressions().add(tenantId));\n            } else {\n                ((ExpressionList) itemsList).getExpressions().add(tenantId);\n            }\n        } else {\n            throw ExceptionUtils.mpe(\"Failed to process multiple-table update, please exclude the tableName or statementId\");\n        }\n    }\n\n    /**\n     * update \u8bed\u53e5\u5904\u7406\n     */\n    @Override\n    protected void processUpdate(Update update, int index, String sql, Object obj) {\n        final Table table = update.getTable();", "        if (this.tenantLineHandler.ignoreTable(table.getName())) {\n            // \u8fc7\u6ee4\u9000\u51fa\u6267\u884c\n            return;\n        }\n        update.setWhere(this.andExpression(table, update.getWhere(), (String) obj));\n    }\n\n    /**\n     * delete \u8bed\u53e5\u5904\u7406\n     */\n    @Override\n    protected void processDelete(Delete delete, int index, String sql, Object obj) {", "        if (this.tenantLineHandler.ignoreTable(delete.getTable().getName())) {\n            // \u8fc7\u6ee4\u9000\u51fa\u6267\u884c\n            return;\n        }\n        delete.setWhere(this.andExpression(delete.getTable(), delete.getWhere(), (String) obj));\n    }\n\n    /**\n     * \u5904\u7406 insert into select\n     * <p>\n     * \u8fdb\u5165\u8fd9\u91cc\u8868\u793a\u9700\u8981 insert \u7684\u8868\u542f\u7528\u4e86\u591a\u79df\u6237,\u5219 select \u7684\u8868\u90fd\u542f\u52a8\u4e86\n     *\n     * @param selectBody SelectBody\n     */\n    protected void processInsertSelect(SelectBody selectBody, final String whereSegment) {\n        PlainSelect plainSelect = (PlainSelect) selectBody;\n        FromItem fromItem = plainSelect.getFromItem();", "        if (fromItem instanceof Table) {\n            // fixed gitee pulls/141 duplicate update\n            this.processPlainSelect(plainSelect, whereSegment);\n            this.appendSelectItem(plainSelect.getSelectItems());\n        } else if (fromItem instanceof SubSelect) {\n            SubSelect subSelect = (SubSelect) fromItem;\n            this.appendSelectItem(plainSelect.getSelectItems());\n            this.processInsertSelect(subSelect.getSelectBody(), whereSegment);\n        }\n    }\n\n    /**\n     * \u8ffd\u52a0 SelectItem\n     *\n     * @param selectItems SelectItem\n     */\n    protected void appendSelectItem(List<SelectItem> selectItems) {", "        if (CollectionUtils.isEmpty(selectItems)) {\n            return;\n        }\n        if (selectItems.size() == 1) {\n            SelectItem item = selectItems.get(0);\n            if (item instanceof AllColumns || item instanceof AllTableColumns) {\n                return;\n            }\n        }\n        selectItems.add(new SelectExpressionItem(new Column(this.tenantLineHandler.getTenantIdColumn())));\n    }\n\n    /**\n     * \u79df\u6237\u5b57\u6bb5\u522b\u540d\u8bbe\u7f6e\n     * <p>tenantId \u6216 tableAlias.tenantId</p>\n     *\n     * @param table \u8868\u5bf9\u8c61\n     * @return \u5b57\u6bb5\n     */\n    protected Column getAliasColumn(Table table) {\n        StringBuilder column = new StringBuilder();\n        // todo \u8be5\u8d77\u522b\u540d\u5c31\u8981\u8d77\u522b\u540d,\u7981\u6b62\u4fee\u6539\u6b64\u5904\u903b\u8f91", "        if (table.getAlias() != null) {\n            column.append(table.getAlias().getName()).append(StringPool.DOT);\n        }\n        column.append(this.tenantLineHandler.getTenantIdColumn());\n        return new Column(column.toString());\n    }\n\n    /**\n     * \u6784\u5efa\u79df\u6237\u6761\u4ef6\u8868\u8fbe\u5f0f\n     *\n     * @param table        \u8868\u5bf9\u8c61\n     * @param where        \u5f53\u524dwhere\u6761\u4ef6\n     * @param whereSegment \u6240\u5c5eMapper\u5bf9\u8c61\u5168\u8def\u5f84\uff08\u5728\u539f\u79df\u6237\u62e6\u622a\u5668\u529f\u80fd\u4e2d\uff0c\u8fd9\u4e2a\u53c2\u6570\u5e76\u4e0d\u9700\u8981\u53c2\u4e0e\u76f8\u5173\u5224\u65ad\uff09\n     * @return \u79df\u6237\u6761\u4ef6\u8868\u8fbe\u5f0f\n     * @see BaseMultiTableInterceptor#buildTableExpression(Table, Expression, String)\n     */\n    @Override", "    public Expression buildTableExpression(final Table table, final Expression where, final String whereSegment) {\n        if (this.tenantLineHandler.ignoreTable(table.getName())) {\n            return null;\n        }\n        return new EqualsTo(this.getAliasColumn(table), this.tenantLineHandler.getTenantId());\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/Dialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination;\n\n/**\n * \u6570\u636e\u5e93\u65b9\u8a00\uff0c\u9488\u5bf9\u4e0d\u540c\u6570\u636e\u5e93\u8fdb\u884c\u5b9e\u73b0\n *\n * @author liuzh\n */\npublic interface Dialect {\n\n    /**\n     * \u751f\u6210 count \u67e5\u8be2 sql\n     *\n     * @param sql \u7ed1\u5b9a SQL \u5bf9\u8c61\n     * @return\n     */\n    String getCountSql(String sql);\n\n    /**\n     * \u751f\u6210\u5206\u9875\u67e5\u8be2 sql\n     *\n     * @param sql      \u7ed1\u5b9a SQL \u5bf9\u8c61\n     * @param pageNum\n     * @param pageSize\n     * @return\n     */\n    String getPageSql(String sql, int pageNum, int pageSize);\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/PageHelper.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination;\n\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.dialect.MySqlDialect;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.dialect.OracleDialect;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.dialect.PostgreSqlDialect;\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.dialect.SqlServerDialect;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;", "import javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \u57fa\u7840\u5206\u9875\u65b9\u6cd5\n *", " * \u57fa\u7840\u5206\u9875\u65b9\u6cd5\n *\n * @author liuzh\n */\npublic abstract class PageHelper {\n    private static final ThreadLocal<Page> LOCAL_PAGE = ThreadLocal.withInitial(() -> null);\n    private static final boolean DEFAULT_COUNT = true;\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    /**\n     * \u8bbe\u7f6e Page \u53c2\u6570\n     *\n     * @param page\n     */", "    public static void setLocalPage(Page page) {\n        LOCAL_PAGE.set(page);\n    }\n\n    /**\n     * \u83b7\u53d6 Page \u53c2\u6570\n     *\n     * @return\n     */\n    public static <T> Page<T> getLocalPage() {\n        return LOCAL_PAGE.get();\n    }\n\n    /**\n     * \u79fb\u9664\u672c\u5730\u53d8\u91cf\n     */", "    public static void clearPage() {\n        LOCAL_PAGE.remove();\n    }\n\n    /**\n     * \u5f00\u59cb\u5206\u9875\n     *\n     * @param pageNum  \u9875\u7801\n     * @param pageSize \u6bcf\u9875\u663e\u793a\u6570\u91cf\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize) {\n        return startPage(pageNum, pageSize, DEFAULT_COUNT);\n    }\n\n    /**\n     * \u5f00\u59cb\u5206\u9875\n     *\n     * @param pageNum  \u9875\u7801\n     * @param pageSize \u6bcf\u9875\u663e\u793a\u6570\u91cf\n     * @param count    \u662f\u5426\u8fdb\u884ccount\u67e5\u8be2\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize, boolean count) {\n        return startPage(pageNum, pageSize, count, null, null);\n    }\n\n\n    /**\n     * \u5f00\u59cb\u5206\u9875\n     *\n     * @param pageNum      \u9875\u7801\n     * @param pageSize     \u6bcf\u9875\u663e\u793a\u6570\u91cf\n     * @param count        \u662f\u5426\u8fdb\u884ccount\u67e5\u8be2\n     * @param reasonable   \u5206\u9875\u5408\u7406\u5316,null\u65f6\u7528\u9ed8\u8ba4\u914d\u7f6e\n     * @param pageSizeZero true\u4e14pageSize=0\u65f6\u8fd4\u56de\u5168\u90e8\u7ed3\u679c\uff0cfalse\u65f6\u5206\u9875,null\u65f6\u7528\u9ed8\u8ba4\u914d\u7f6e\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) {\n        Page<E> page = new Page<E>(pageNum, pageSize, count, reasonable, pageSizeZero);\n        setLocalPage(page);\n        return page;\n    }\n\n\n    /**\n     * key:\u6570\u636e\u5e93\u522b\u540d\uff0cvalue\uff1a\u6570\u636e\u5e93\u65b9\u8a00\u5b9e\u73b0\u7c7bclass\n     */\n    private static final Map<String, Class> DIALECT_MAP = new HashMap<String, Class>();\n    /**\n     * key:\u6570\u636e\u5e93\u522b\u540d\uff0cvalue:\u6570\u636e\u5e93\u65b9\u8a00\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\n     */\n    private static final Map<String, Dialect> DIALECT_INSTANCE_MAP = new HashMap<String, Dialect>();\n\n    static {\n\n        registerDialectAlias(\"hsqldb\", PostgreSqlDialect.class);\n        registerDialectAlias(\"h2\", PostgreSqlDialect.class);\n        registerDialectAlias(\"postgresql\", PostgreSqlDialect.class);\n\n        registerDialectAlias(\"mysql\", MySqlDialect.class);\n        registerDialectAlias(\"mariadb\", MySqlDialect.class);\n        registerDialectAlias(\"sqlite\", MySqlDialect.class);\n\n        registerDialectAlias(\"oracle\", OracleDialect.class);\n\n        registerDialectAlias(\"sqlserver\", SqlServerDialect.class);\n        registerDialectAlias(\"sqlserver2012\", SqlServerDialect.class);\n    }\n", "    public static void registerDialectAlias(String alias, Class clazz) {\n        DIALECT_MAP.put(alias, clazz);\n    }\n\n    public static Dialect getDialect(JdbcTemplate jdbcTemplate) {\n        String dialectName = getDialectName(getUrl(getDataSource(jdbcTemplate)));\n        if (dialectName != null) {\n            if (DIALECT_INSTANCE_MAP.containsKey(dialectName)) {\n                return DIALECT_INSTANCE_MAP.get(dialectName);\n            }\n        }", "        if (dialectName != null && DIALECT_MAP.containsKey(dialectName)) {\n            lock.lock();\n            try {\n                Class dialectClass = null;\n                Dialect dialect = null;\n                try {\n                    dialectClass = DIALECT_MAP.get(dialectName);\n                    if (Dialect.class.isAssignableFrom(dialectClass)) {\n                        dialect = (Dialect) dialectClass.newInstance();\n                        DIALECT_INSTANCE_MAP.put(dialectName, dialect);\n                        return dialect;\n                    } else {\n                        throw new RuntimeException(\"Dialect class must be implemented \" + Dialect.class.getName() + \" interface\");\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(\"Initialize dialect class [\" + dialectClass + \"] error : \" + e.getMessage(), e);\n                }\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            throw new RuntimeException(\"Unsupported database : \" + dialectName);\n        }\n    }\n\n    private static DataSource getDataSource(JdbcTemplate jdbcTemplate) {\n        return jdbcTemplate.getDataSource();\n    }\n\n    private static String getUrl(DataSource dataSource) {\n        Connection conn = null;", "        try {\n            conn = dataSource.getConnection();\n            return conn.getMetaData().getURL();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    //ignore\n                }\n            }\n        }\n    }\n\n    private static String getDialectName(String url) {\n        url = url.toLowerCase();", "        for (String dialect : DIALECT_MAP.keySet()) {\n            if (url.contains(\":\" + dialect + \":\")) {\n                return dialect;\n            }\n        }\n        return null;\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/PageInfo.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * \u5bf9Page<E>\u7ed3\u679c\u8fdb\u884c\u5305\u88c5\n * <p/>\n * \u65b0\u589e\u5206\u9875\u7684\u591a\u9879\u5c5e\u6027\uff0c\u4e3b\u8981\u53c2\u8003:http://bbs.csdn.net/topics/360010907\n *", " * \u65b0\u589e\u5206\u9875\u7684\u591a\u9879\u5c5e\u6027\uff0c\u4e3b\u8981\u53c2\u8003:http://bbs.csdn.net/topics/360010907\n *\n * @author liuzh/abel533/isea533\n * @version 3.3.0\n * @since 3.2.2\n * \u9879\u76ee\u5730\u5740 : http://git.oschina.net/free/Mybatis_PageHelper\n */\npublic class PageInfo<T> extends PageSerializable<T> {\n    public static final int DEFAULT_NAVIGATE_PAGES = 8;\n    //\u5f53\u524d\u9875\n    private int pageNum;\n    //\u6bcf\u9875\u7684\u6570\u91cf\n    private int pageSize;\n    //\u5f53\u524d\u9875\u7684\u6570\u91cf\n    private int size;\n\n    //\u7531\u4e8estartRow\u548cendRow\u4e0d\u5e38\u7528\uff0c\u8fd9\u91cc\u8bf4\u4e2a\u5177\u4f53\u7684\u7528\u6cd5\n    //\u53ef\u4ee5\u5728\u9875\u9762\u4e2d\"\u663e\u793astartRow\u5230endRow \u5171size\u6761\u6570\u636e\"\n\n    //\u5f53\u524d\u9875\u9762\u7b2c\u4e00\u4e2a\u5143\u7d20\u5728\u6570\u636e\u5e93\u4e2d\u7684\u884c\u53f7\n    private long startRow;\n    //\u5f53\u524d\u9875\u9762\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5728\u6570\u636e\u5e93\u4e2d\u7684\u884c\u53f7\n    private long endRow;\n    //\u603b\u9875\u6570\n    private int pages;\n\n    //\u524d\u4e00\u9875\n    private int prePage;\n    //\u4e0b\u4e00\u9875\n    private int nextPage;\n\n    //\u662f\u5426\u4e3a\u7b2c\u4e00\u9875\n    private boolean isFirstPage = false;\n    //\u662f\u5426\u4e3a\u6700\u540e\u4e00\u9875\n    private boolean isLastPage = false;\n    //\u662f\u5426\u6709\u524d\u4e00\u9875\n    private boolean hasPreviousPage = false;\n    //\u662f\u5426\u6709\u4e0b\u4e00\u9875\n    private boolean hasNextPage = false;\n    //\u5bfc\u822a\u9875\u7801\u6570\n    private int navigatePages;\n    //\u6240\u6709\u5bfc\u822a\u9875\u53f7\n    private int[] navigatepageNums;\n    //\u5bfc\u822a\u6761\u4e0a\u7684\u7b2c\u4e00\u9875\n    private int navigateFirstPage;\n    //\u5bfc\u822a\u6761\u4e0a\u7684\u6700\u540e\u4e00\u9875\n    private int navigateLastPage;\n\n    public PageInfo() {\n    }\n\n    /**\n     * \u5305\u88c5Page\u5bf9\u8c61\n     *\n     * @param list\n     */\n    public PageInfo(List<T> list) {\n        this(list, DEFAULT_NAVIGATE_PAGES);\n    }\n\n    /**\n     * \u5305\u88c5Page\u5bf9\u8c61\n     *\n     * @param list          page\u7ed3\u679c\n     * @param navigatePages \u9875\u7801\u6570\u91cf\n     */\n    public PageInfo(List<T> list, int navigatePages) {\n        super(list);", "    public static final int DEFAULT_NAVIGATE_PAGES = 8;\n    //\u5f53\u524d\u9875\n    private int pageNum;\n    //\u6bcf\u9875\u7684\u6570\u91cf\n    private int pageSize;\n    //\u5f53\u524d\u9875\u7684\u6570\u91cf\n    private int size;\n\n    //\u7531\u4e8estartRow\u548cendRow\u4e0d\u5e38\u7528\uff0c\u8fd9\u91cc\u8bf4\u4e2a\u5177\u4f53\u7684\u7528\u6cd5\n    //\u53ef\u4ee5\u5728\u9875\u9762\u4e2d\"\u663e\u793astartRow\u5230endRow \u5171size\u6761\u6570\u636e\"\n\n    //\u5f53\u524d\u9875\u9762\u7b2c\u4e00\u4e2a\u5143\u7d20\u5728\u6570\u636e\u5e93\u4e2d\u7684\u884c\u53f7\n    private long startRow;\n    //\u5f53\u524d\u9875\u9762\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5728\u6570\u636e\u5e93\u4e2d\u7684\u884c\u53f7\n    private long endRow;\n    //\u603b\u9875\u6570\n    private int pages;\n\n    //\u524d\u4e00\u9875\n    private int prePage;\n    //\u4e0b\u4e00\u9875\n    private int nextPage;\n\n    //\u662f\u5426\u4e3a\u7b2c\u4e00\u9875\n    private boolean isFirstPage = false;\n    //\u662f\u5426\u4e3a\u6700\u540e\u4e00\u9875\n    private boolean isLastPage = false;\n    //\u662f\u5426\u6709\u524d\u4e00\u9875\n    private boolean hasPreviousPage = false;\n    //\u662f\u5426\u6709\u4e0b\u4e00\u9875\n    private boolean hasNextPage = false;\n    //\u5bfc\u822a\u9875\u7801\u6570\n    private int navigatePages;\n    //\u6240\u6709\u5bfc\u822a\u9875\u53f7\n    private int[] navigatepageNums;\n    //\u5bfc\u822a\u6761\u4e0a\u7684\u7b2c\u4e00\u9875\n    private int navigateFirstPage;\n    //\u5bfc\u822a\u6761\u4e0a\u7684\u6700\u540e\u4e00\u9875\n    private int navigateLastPage;\n\n    public PageInfo() {\n    }\n\n    /**\n     * \u5305\u88c5Page\u5bf9\u8c61\n     *\n     * @param list\n     */\n    public PageInfo(List<T> list) {\n        this(list, DEFAULT_NAVIGATE_PAGES);\n    }\n\n    /**\n     * \u5305\u88c5Page\u5bf9\u8c61\n     *\n     * @param list          page\u7ed3\u679c\n     * @param navigatePages \u9875\u7801\u6570\u91cf\n     */\n    public PageInfo(List<T> list, int navigatePages) {\n        super(list);", "        if (list instanceof Page) {\n            Page page = (Page) list;\n            this.pageNum = page.getPageNum();\n            this.pageSize = page.getPageSize();\n\n            this.pages = page.getPages();\n            this.size = page.size();\n            //\u7531\u4e8e\u7ed3\u679c\u662f>startRow\u7684\uff0c\u6240\u4ee5\u5b9e\u9645\u7684\u9700\u8981+1\n            if (this.size == 0) {\n                this.startRow = 0;\n                this.endRow = 0;\n            } else {\n                this.startRow = page.getStartRow() + 1;\n                //\u8ba1\u7b97\u5b9e\u9645\u7684endRow\uff08\u6700\u540e\u4e00\u9875\u7684\u65f6\u5019\u7279\u6b8a\uff09\n                this.endRow = this.startRow - 1 + this.size;\n            }", "            if (this.size == 0) {\n                this.startRow = 0;\n                this.endRow = 0;\n            } else {\n                this.startRow = page.getStartRow() + 1;\n                //\u8ba1\u7b97\u5b9e\u9645\u7684endRow\uff08\u6700\u540e\u4e00\u9875\u7684\u65f6\u5019\u7279\u6b8a\uff09\n                this.endRow = this.startRow - 1 + this.size;\n            }\n        } else if (list instanceof Collection) {\n            this.pageNum = 1;\n            this.pageSize = list.size();\n\n            this.pages = this.pageSize > 0 ? 1 : 0;\n            this.size = list.size();\n            this.startRow = 0;\n            this.endRow = list.size() > 0 ? list.size() - 1 : 0;\n        }", "        } else if (list instanceof Collection) {\n            this.pageNum = 1;\n            this.pageSize = list.size();\n\n            this.pages = this.pageSize > 0 ? 1 : 0;\n            this.size = list.size();\n            this.startRow = 0;\n            this.endRow = list.size() > 0 ? list.size() - 1 : 0;\n        }\n        if (list instanceof Collection) {\n            this.calcByNavigatePages(navigatePages);\n        }\n    }\n\n    public static <T> PageInfo<T> of(List<T> list) {\n        return new PageInfo<T>(list);\n    }\n\n    public static <T> PageInfo<T> of(List<T> list, int navigatePages) {\n        return new PageInfo<T>(list, navigatePages);\n    }\n", "        if (list instanceof Collection) {\n            this.calcByNavigatePages(navigatePages);\n        }\n    }\n\n    public static <T> PageInfo<T> of(List<T> list) {\n        return new PageInfo<T>(list);\n    }\n\n    public static <T> PageInfo<T> of(List<T> list, int navigatePages) {\n        return new PageInfo<T>(list, navigatePages);\n    }\n", "    public void calcByNavigatePages(int navigatePages) {\n        this.setNavigatePages(navigatePages);\n        //\u8ba1\u7b97\u5bfc\u822a\u9875\n        this.calcNavigatepageNums();\n        //\u8ba1\u7b97\u524d\u540e\u9875\uff0c\u7b2c\u4e00\u9875\uff0c\u6700\u540e\u4e00\u9875\n        this.calcPage();\n        //\u5224\u65ad\u9875\u9762\u8fb9\u754c\n        this.judgePageBoudary();\n    }\n\n    /**\n     * \u8ba1\u7b97\u5bfc\u822a\u9875\n     */\n    private void calcNavigatepageNums() {\n        //\u5f53\u603b\u9875\u6570\u5c0f\u4e8e\u6216\u7b49\u4e8e\u5bfc\u822a\u9875\u7801\u6570\u65f6", "        if (this.pages <= this.navigatePages) {\n            this.navigatepageNums = new int[this.pages];\n            for (int i = 0; i < this.pages; i++) {\n                this.navigatepageNums[i] = i + 1;\n            }\n        } else { //\u5f53\u603b\u9875\u6570\u5927\u4e8e\u5bfc\u822a\u9875\u7801\u6570\u65f6\n            this.navigatepageNums = new int[this.navigatePages];\n            int startNum = this.pageNum - this.navigatePages / 2;\n            int endNum = this.pageNum + this.navigatePages / 2;\n\n            if (startNum < 1) {\n                startNum = 1;\n                //(\u6700\u524dnavigatePages\u9875", "            if (startNum < 1) {\n                startNum = 1;\n                //(\u6700\u524dnavigatePages\u9875\n                for (int i = 0; i < this.navigatePages; i++) {\n                    this.navigatepageNums[i] = startNum++;\n                }\n            } else if (endNum > this.pages) {\n                endNum = this.pages;\n                //\u6700\u540enavigatePages\u9875\n                for (int i = this.navigatePages - 1; i >= 0; i--) {\n                    this.navigatepageNums[i] = endNum--;\n                }\n            } else {\n                //\u6240\u6709\u4e2d\u95f4\u9875", "                for (int i = this.navigatePages - 1; i >= 0; i--) {\n                    this.navigatepageNums[i] = endNum--;\n                }\n            } else {\n                //\u6240\u6709\u4e2d\u95f4\u9875\n                for (int i = 0; i < this.navigatePages; i++) {\n                    this.navigatepageNums[i] = startNum++;\n                }\n            }\n        }\n    }\n\n    /**\n     * \u8ba1\u7b97\u524d\u540e\u9875\uff0c\u7b2c\u4e00\u9875\uff0c\u6700\u540e\u4e00\u9875\n     */\n    private void calcPage() {", "        if (this.navigatepageNums != null && this.navigatepageNums.length > 0) {\n            this.navigateFirstPage = this.navigatepageNums[0];\n            this.navigateLastPage = this.navigatepageNums[this.navigatepageNums.length - 1];\n            if (this.pageNum > 1) {\n                this.prePage = this.pageNum - 1;\n            }\n            if (this.pageNum < this.pages) {\n                this.nextPage = this.pageNum + 1;\n            }\n        }\n    }\n\n    /**\n     * \u5224\u5b9a\u9875\u9762\u8fb9\u754c\n     */\n    private void judgePageBoudary() {\n        this.isFirstPage = this.pageNum == 1;\n        this.isLastPage = this.pageNum == this.pages || this.pages == 0;\n        this.hasPreviousPage = this.pageNum > 1;\n        this.hasNextPage = this.pageNum < this.pages;\n    }\n\n", "    public int getPageNum() {\n        return this.pageNum;\n    }\n\n    public void setPageNum(int pageNum) {\n        this.pageNum = pageNum;\n    }\n\n    public int getPageSize() {\n        return this.pageSize;\n    }\n", "    public int getPageSize() {\n        return this.pageSize;\n    }\n\n    public void setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n    }\n\n    public int getSize() {\n        return this.size;\n    }\n", "    public int getSize() {\n        return this.size;\n    }\n\n    public void setSize(int size) {\n        this.size = size;\n    }\n\n    public long getStartRow() {\n        return this.startRow;\n    }\n", "    public long getStartRow() {\n        return this.startRow;\n    }\n\n    public void setStartRow(long startRow) {\n        this.startRow = startRow;\n    }\n\n    public long getEndRow() {\n        return this.endRow;\n    }\n", "    public long getEndRow() {\n        return this.endRow;\n    }\n\n    public void setEndRow(long endRow) {\n        this.endRow = endRow;\n    }\n\n    public int getPages() {\n        return this.pages;\n    }\n", "    public int getPages() {\n        return this.pages;\n    }\n\n    public void setPages(int pages) {\n        this.pages = pages;\n    }\n\n    public int getPrePage() {\n        return this.prePage;\n    }\n", "    public int getPrePage() {\n        return this.prePage;\n    }\n\n    public void setPrePage(int prePage) {\n        this.prePage = prePage;\n    }\n\n    public int getNextPage() {\n        return this.nextPage;\n    }\n", "    public int getNextPage() {\n        return this.nextPage;\n    }\n\n    public void setNextPage(int nextPage) {\n        this.nextPage = nextPage;\n    }\n\n    public boolean isFirstPage() {\n        return this.isFirstPage;\n    }\n", "    public boolean isFirstPage() {\n        return this.isFirstPage;\n    }\n\n    public void setFirstPage(boolean firstPage) {\n        this.isFirstPage = firstPage;\n    }\n\n    public boolean isLastPage() {\n        return this.isLastPage;\n    }\n", "    public boolean isLastPage() {\n        return this.isLastPage;\n    }\n\n    public void setLastPage(boolean lastPage) {\n        this.isLastPage = lastPage;\n    }\n\n    public boolean isHasPreviousPage() {\n        return this.hasPreviousPage;\n    }\n", "    public boolean isHasPreviousPage() {\n        return this.hasPreviousPage;\n    }\n\n    public void setHasPreviousPage(boolean hasPreviousPage) {\n        this.hasPreviousPage = hasPreviousPage;\n    }\n\n    public boolean isHasNextPage() {\n        return this.hasNextPage;\n    }\n", "    public boolean isHasNextPage() {\n        return this.hasNextPage;\n    }\n\n    public void setHasNextPage(boolean hasNextPage) {\n        this.hasNextPage = hasNextPage;\n    }\n\n    public int getNavigatePages() {\n        return this.navigatePages;\n    }\n", "    public int getNavigatePages() {\n        return this.navigatePages;\n    }\n\n    public void setNavigatePages(int navigatePages) {\n        this.navigatePages = navigatePages;\n    }\n\n    public int[] getNavigatepageNums() {\n        return this.navigatepageNums;\n    }\n", "    public void setNavigatepageNums(int[] navigatepageNums) {\n        this.navigatepageNums = navigatepageNums;\n    }\n\n    public int getNavigateFirstPage() {\n        return this.navigateFirstPage;\n    }\n\n    public void setNavigateFirstPage(int navigateFirstPage) {\n        this.navigateFirstPage = navigateFirstPage;\n    }\n", "    public void setNavigateFirstPage(int navigateFirstPage) {\n        this.navigateFirstPage = navigateFirstPage;\n    }\n\n    public int getNavigateLastPage() {\n        return this.navigateLastPage;\n    }\n\n    public void setNavigateLastPage(int navigateLastPage) {\n        this.navigateLastPage = navigateLastPage;\n    }\n\n    @Override", "    public void setNavigateLastPage(int navigateLastPage) {\n        this.navigateLastPage = navigateLastPage;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"PageInfo{\");\n        sb.append(\"pageNum=\").append(this.pageNum);\n        sb.append(\", pageSize=\").append(this.pageSize);\n        sb.append(\", size=\").append(this.size);\n        sb.append(\", startRow=\").append(this.startRow);\n        sb.append(\", endRow=\").append(this.endRow);\n        sb.append(\", total=\").append(this.total);\n        sb.append(\", pages=\").append(this.pages);\n        sb.append(\", list=\").append(this.list);\n        sb.append(\", prePage=\").append(this.prePage);\n        sb.append(\", nextPage=\").append(this.nextPage);\n        sb.append(\", isFirstPage=\").append(this.isFirstPage);\n        sb.append(\", isLastPage=\").append(this.isLastPage);\n        sb.append(\", hasPreviousPage=\").append(this.hasPreviousPage);\n        sb.append(\", hasNextPage=\").append(this.hasNextPage);\n        sb.append(\", navigatePages=\").append(this.navigatePages);\n        sb.append(\", navigateFirstPage=\").append(this.navigateFirstPage);\n        sb.append(\", navigateLastPage=\").append(this.navigateLastPage);\n        sb.append(\", navigatepageNums=\");", "        if (this.navigatepageNums == null) {\n            sb.append(\"null\");\n        } else {\n            sb.append('[');\n            for (int i = 0; i < this.navigatepageNums.length; ++i) {\n                sb.append(i == 0 ? \"\" : \", \").append(this.navigatepageNums[i]);\n            }\n            sb.append(']');\n        }\n        sb.append('}');\n        return sb.toString();\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/Page.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination;\n\nimport java.io.Closeable;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Mybatis - \u5206\u9875\u5bf9\u8c61\n *", " * Mybatis - \u5206\u9875\u5bf9\u8c61\n *\n * @author liuzh/abel533/isea533\n * @version 3.6.0\n * \u9879\u76ee\u5730\u5740 : http://git.oschina.net/free/Mybatis_PageHelper\n */\npublic class Page<E> extends ArrayList<E> implements Serializable, Closeable {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * \u9875\u7801\uff0c\u4ece1\u5f00\u59cb\n     */\n    private int pageNum;\n    /**\n     * \u9875\u9762\u5927\u5c0f\n     */\n    private int pageSize;\n    /**\n     * \u8d77\u59cb\u884c\n     */\n    private long startRow;\n    /**\n     * \u672b\u884c\n     */\n    private long endRow;\n    /**\n     * \u603b\u6570\n     */\n    private long total;\n    /**\n     * \u603b\u9875\u6570\n     */\n    private int pages;\n    /**\n     * \u5305\u542bcount\u67e5\u8be2\n     */\n    private boolean count = true;\n    /**\n     * \u5206\u9875\u5408\u7406\u5316\n     */\n    private Boolean reasonable;\n    /**\n     * \u5f53\u8bbe\u7f6e\u4e3atrue\u7684\u65f6\u5019\uff0c\u5982\u679cpagesize\u8bbe\u7f6e\u4e3a0\uff08\u6216RowBounds\u7684limit=0\uff09\uff0c\u5c31\u4e0d\u6267\u884c\u5206\u9875\uff0c\u8fd4\u56de\u5168\u90e8\u7ed3\u679c\n     */\n    private Boolean pageSizeZero;\n\n    public Page() {\n        super();\n    }\n\n    public Page(int pageNum, int pageSize) {\n        this(pageNum, pageSize, true, null);\n    }\n\n    public Page(int pageNum, int pageSize, boolean count) {\n        this(pageNum, pageSize, count, null);\n    }\n\n    public Page(int pageNum, int pageSize, boolean count, Boolean reasonable) {\n        this(pageNum, pageSize, count, null, null);\n    }\n\n    public Page(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) {\n        super(0);", "        if (pageNum == 1 && pageSize == Integer.MAX_VALUE) {\n            this.pageSizeZero = true;\n            pageSize = 0;\n        }\n        this.pageNum = pageNum;\n        this.pageSize = pageSize;\n        this.count = count;\n        this.calculateStartAndEndRow();\n        this.setReasonable(reasonable);\n        this.setPageSizeZero(pageSizeZero);\n    }\n\n    public List<E> getResult() {\n        return this;\n    }\n", "    public int getPages() {\n        return this.pages;\n    }\n\n    public Page<E> setPages(int pages) {\n        this.pages = pages;\n        return this;\n    }\n\n    public long getEndRow() {\n        return this.endRow;\n    }\n\n    public Page<E> setEndRow(long endRow) {\n        this.endRow = endRow;\n        return this;\n    }\n", "    public long getEndRow() {\n        return this.endRow;\n    }\n\n    public Page<E> setEndRow(long endRow) {\n        this.endRow = endRow;\n        return this;\n    }\n\n    public int getPageNum() {\n        return this.pageNum;\n    }\n\n    public Page<E> setPageNum(int pageNum) {\n        //\u5206\u9875\u5408\u7406\u5316\uff0c\u9488\u5bf9\u4e0d\u5408\u7406\u7684\u9875\u7801\u81ea\u52a8\u5904\u7406\n        this.pageNum = ((this.reasonable != null && this.reasonable) && pageNum <= 0) ? 1 : pageNum;\n        return this;\n    }\n", "    public int getPageNum() {\n        return this.pageNum;\n    }\n\n    public Page<E> setPageNum(int pageNum) {\n        //\u5206\u9875\u5408\u7406\u5316\uff0c\u9488\u5bf9\u4e0d\u5408\u7406\u7684\u9875\u7801\u81ea\u52a8\u5904\u7406\n        this.pageNum = ((this.reasonable != null && this.reasonable) && pageNum <= 0) ? 1 : pageNum;\n        return this;\n    }\n\n    public int getPageSize() {\n        return this.pageSize;\n    }\n\n    public Page<E> setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n        return this;\n    }\n", "    public int getPageSize() {\n        return this.pageSize;\n    }\n\n    public Page<E> setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n        return this;\n    }\n\n    public long getStartRow() {\n        return this.startRow;\n    }\n\n    public Page<E> setStartRow(long startRow) {\n        this.startRow = startRow;\n        return this;\n    }\n", "    public long getStartRow() {\n        return this.startRow;\n    }\n\n    public Page<E> setStartRow(long startRow) {\n        this.startRow = startRow;\n        return this;\n    }\n\n    public long getTotal() {\n        return this.total;\n    }\n", "    public long getTotal() {\n        return this.total;\n    }\n\n    public void setTotal(long total) {\n        this.total = total;\n        if (total == -1) {\n            this.pages = 1;\n            return;\n        }\n        if (this.pageSize > 0) {\n            this.pages = (int) (total / this.pageSize + ((total % this.pageSize == 0) ? 0 : 1));\n        } else {\n            this.pages = 0;\n        }\n        //\u5206\u9875\u5408\u7406\u5316\uff0c\u9488\u5bf9\u4e0d\u5408\u7406\u7684\u9875\u7801\u81ea\u52a8\u5904\u7406", "        if (this.pageSize > 0) {\n            this.pages = (int) (total / this.pageSize + ((total % this.pageSize == 0) ? 0 : 1));\n        } else {\n            this.pages = 0;\n        }\n        //\u5206\u9875\u5408\u7406\u5316\uff0c\u9488\u5bf9\u4e0d\u5408\u7406\u7684\u9875\u7801\u81ea\u52a8\u5904\u7406\n        if ((this.reasonable != null && this.reasonable) && this.pageNum > this.pages) {\n            if (this.pages != 0) {\n                this.pageNum = this.pages;\n            }\n            this.calculateStartAndEndRow();\n        }\n    }\n", "    public Boolean getReasonable() {\n        return this.reasonable;\n    }\n\n    public Page<E> setReasonable(Boolean reasonable) {\n        if (reasonable == null) {\n            return this;\n        }\n        this.reasonable = reasonable;\n        //\u5206\u9875\u5408\u7406\u5316\uff0c\u9488\u5bf9\u4e0d\u5408\u7406\u7684\u9875\u7801\u81ea\u52a8\u5904\u7406\n        if (this.reasonable && this.pageNum <= 0) {\n            this.pageNum = 1;\n            this.calculateStartAndEndRow();\n        }\n        return this;\n    }\n", "        if (this.reasonable && this.pageNum <= 0) {\n            this.pageNum = 1;\n            this.calculateStartAndEndRow();\n        }\n        return this;\n    }\n\n    public Boolean getPageSizeZero() {\n        return this.pageSizeZero;\n    }\n\n    public Page<E> setPageSizeZero(Boolean pageSizeZero) {", "        if (this.pageSizeZero == null && pageSizeZero != null) {\n            this.pageSizeZero = pageSizeZero;\n        }\n        return this;\n    }\n\n    /**\n     * \u8ba1\u7b97\u8d77\u6b62\u884c\u53f7\n     */\n    private void calculateStartAndEndRow() {\n        this.startRow = this.pageNum > 0 ? (this.pageNum - 1) * this.pageSize : 0;\n        this.endRow = this.startRow + this.pageSize * (this.pageNum > 0 ? 1 : 0);\n    }\n", "    public boolean isCount() {\n        return this.count;\n    }\n\n    public Page<E> setCount(boolean count) {\n        this.count = count;\n        return this;\n    }\n\n    public PageInfo<E> toPageInfo() {\n        return new PageInfo<E>(this);\n    }\n\n    public PageSerializable<E> toPageSerializable() {\n        return new PageSerializable<E>(this);\n    }\n\n    @Override", "    public String toString() {\n        return \"Page{\" +\n                \"count=\" + this.count +\n                \", pageNum=\" + this.pageNum +\n                \", pageSize=\" + this.pageSize +\n                \", startRow=\" + this.startRow +\n                \", endRow=\" + this.endRow +\n                \", total=\" + this.total +\n                \", pages=\" + this.pages +\n                \", reasonable=\" + this.reasonable +\n                \", pageSizeZero=\" + this.pageSizeZero +\n                '}' + super.toString();\n    }\n\n    @Override", "    public void close() {\n        PageHelper.clearPage();\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/PageSerializable.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * @author liuzh\n */\npublic class PageSerializable<T> implements Serializable {\n    private static final long serialVersionUID = 1L;\n    //\u603b\u8bb0\u5f55\u6570\n    protected long total;\n    //\u7ed3\u679c\u96c6\n    protected List<T> list;\n\n    public PageSerializable() {\n    }\n\n    public PageSerializable(List<T> list) {\n        this.list = list;", "public class PageSerializable<T> implements Serializable {\n    private static final long serialVersionUID = 1L;\n    //\u603b\u8bb0\u5f55\u6570\n    protected long total;\n    //\u7ed3\u679c\u96c6\n    protected List<T> list;\n\n    public PageSerializable() {\n    }\n\n    public PageSerializable(List<T> list) {\n        this.list = list;", "        if (list instanceof Page) {\n            this.total = ((Page) list).getTotal();\n        } else {\n            this.total = list.size();\n        }\n    }\n\n    public static <T> PageSerializable<T> of(List<T> list) {\n        return new PageSerializable<T>(list);\n    }\n", "    public long getTotal() {\n        return this.total;\n    }\n\n    public void setTotal(long total) {\n        this.total = total;\n    }\n\n    public List<T> getList() {\n        return this.list;\n    }\n", "    public void setList(List<T> list) {\n        this.list = list;\n    }\n\n    @Override\n    public String toString() {\n        return \"PageSerializable{\" +\n                \"total=\" + this.total +\n                \", list=\" + this.list +\n                '}';\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/dialect/PostgreSqlDialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n\n/**\n * @author liuzh\n */\npublic class PostgreSqlDialect extends AbstractDialect {\n\n    @Override\n    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return sql + \" LIMIT \" + pageSize + \" OFFSET \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n", "    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return sql + \" LIMIT \" + pageSize + \" OFFSET \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/dialect/AbstractDialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n\nimport com.github.deeround.jdbc.plus.Interceptor.pagination.Dialect;\n\n/**\n * \u57fa\u4e8e CountSqlParser \u7684\u667a\u80fd Count \u67e5\u8be2\n *\n * @author liuzh\n */\npublic abstract class AbstractDialect implements Dialect {\n    @Override", " */\npublic abstract class AbstractDialect implements Dialect {\n    @Override\n    public String getCountSql(String sql) {\n        return \"SELECT COUNT(*) AS PG_COUNT FROM ( \" + sql + \" ) PG_TB \";\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/dialect/SqlServerDialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n\n/**\n * @author liuzh\n */\npublic class SqlServerDialect extends AbstractDialect {\n\n    @Override\n    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return \"SELECT * FROM (SELECT PG_TB.*,ROW_NUMBER() OVER( ORDER BY RAND()) PG_ROWNUM FROM ( \" + sql + \" ) PG_TB) PG_TB1 WHERE PG_ROWNUM <= \" + (pageNum * pageSize) + \" AND PG_ROWNUM > \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n", "    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return \"SELECT * FROM (SELECT PG_TB.*,ROW_NUMBER() OVER( ORDER BY RAND()) PG_ROWNUM FROM ( \" + sql + \" ) PG_TB) PG_TB1 WHERE PG_ROWNUM <= \" + (pageNum * pageSize) + \" AND PG_ROWNUM > \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/dialect/OracleDialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n\n/**\n * @author liuzh\n */\npublic class OracleDialect extends AbstractDialect {\n\n    @Override\n    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return \"SELECT * FROM ( SELECT PG_TB.*, ROWNUM PG_ROWNUM FROM ( \" + sql + \" ) PG_TB ) PG_TB1 WHERE PG_ROWNUM <= \" + (pageNum * pageSize) + \" AND PG_ROWNUM > \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n", "    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return \"SELECT * FROM ( SELECT PG_TB.*, ROWNUM PG_ROWNUM FROM ( \" + sql + \" ) PG_TB ) PG_TB1 WHERE PG_ROWNUM <= \" + (pageNum * pageSize) + \" AND PG_ROWNUM > \" + ((pageNum - 1) * pageSize) + \" \";\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/Interceptor/pagination/dialect/MySqlDialect.java", "chunked_list": ["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2017 abel533@gmail.com\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n", "package com.github.deeround.jdbc.plus.Interceptor.pagination.dialect;\n\n/**\n * @author liuzh\n */\npublic class MySqlDialect extends AbstractDialect {\n\n    @Override\n    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return sql + \" LIMIT \" + ((pageNum - 1) * pageSize) + \", \" + pageSize + \" \";\n    }\n\n}\n", "    public String getPageSql(String sql, int pageNum, int pageSize) {\n        return sql + \" LIMIT \" + ((pageNum - 1) * pageSize) + \", \" + pageSize + \" \";\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodActionType.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/17 9:23\n */\npublic enum MethodActionType {\n\n    /**\n     * \u672a\u77e5\u6267\u884c\u65b9\u6cd5\n     */\n    UNKNOWN,\n\n    /**\n     * \u52a8\u6001\u65b9\u6cd5\n     */\n    DYNAMIC,\n\n\n    /**\n     * int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss)\n     */\n    BATCHUPDATE_SQL_PSS,\n\n    /**\n     * int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n     * final ParameterizedPreparedStatementSetter<T> pss)\n     */\n    BATCHUPDATE_SQL_BATCHARGS_BATCHSIZE_PSS,\n\n    /**\n     * int[] batchUpdate(String sql, List<Object[]> batchArgs)\n     */\n    BATCHUPDATE_SQL_BATCHARGS,\n\n    /**\n     * int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)\n     */\n    BATCHUPDATE_SQL_BATCHARGS_ARGTYPES,\n\n    /**\n     * int[] batchUpdate(final String... sql)\n     */\n    BATCHUPDATE_SQL,\n\n\n    /**\n     * int update(final String sql)\n     */\n    UPDATE_SQL,\n\n    /**\n     * int update(String sql, @Nullable Object... args)\n     */\n    UPDATE_SQL_ARGS,\n\n    /**\n     * update(String sql, Object[] args, int[] argTypes)\n     */\n    UPDATE_SQL_ARGS_ARGTYPES,\n\n    /**\n     * int update(String sql, @Nullable PreparedStatementSetter pss)\n     */\n    UPDATE_SQL_PSS,\n\n\n    /**\n     * T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)\n     */\n    QUERY_SQL_ARGS_ARGTYPES_RSE,\n\n    /**\n     * void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)\n     */\n    QUERY_SQL_ARGS_ARGTYPES_RCH,\n\n    /**\n     * List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n     */\n    QUERY_SQL_ARGS_ARGTYPES_ROWMAPPER,\n\n    /**\n     * T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)\n     */\n    QUERY_SQL_ARGS_RSE,\n\n    /**\n     * void query(String sql, @Nullable Object[] args, RowCallbackHandler rch)\n     */\n    QUERY_SQL_ARGS_RCH,\n\n    /**\n     * List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n     */\n    QUERY_SQL_ARGS_ROWMAPPER,\n\n    /**\n     * T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)\n     */\n    QUERY_SQL_PSS_RSE,\n\n    /**\n     * void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)\n     */\n    QUERY_SQL_PSS_RCH,\n\n    /**\n     * List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n     */\n    QUERY_SQL_PSS_ROWMAPPER,\n\n    /**\n     * T query(final String sql, final ResultSetExtractor<T> rse)\n     */\n    QUERY_SQL_RSE,\n\n    /**\n     * T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)\n     */\n    QUERY_SQL_RSE_ARGS,\n\n    /**\n     * void query(String sql, RowCallbackHandler rch)\n     */\n    QUERY_SQL_RCH,\n\n    /**\n     * void query(String sql, RowCallbackHandler rch, @Nullable Object... args)\n     */\n    QUERY_SQL_RCH_ARGS,\n\n    /**\n     * List<T> query(String sql, RowMapper<T> rowMapper)\n     */\n    QUERY_SQL_ROWMAPPER,\n\n    /**\n     * List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    QUERY_SQL_ROWMAPPER_ARGS,\n\n\n    /**\n     * List<Map<String, Object>> queryForList(String sql)\n     */\n    QUERYFORLIST_SQL,\n\n    /**\n     * List<T> queryForList(String sql, Class<T> elementType)\n     */\n    QUERYFORLIST_SQL_ELEMENTTYPE,\n\n    /**\n     * List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)\n     */\n    QUERYFORLIST_SQL_ELEMENTTYPE_ARGS,\n\n    /**\n     * List<Map<String, Object>> queryForList(String sql, @Nullable Object... args)\n     */\n    QUERYFORLIST_SQL_ARGS,\n\n    /**\n     * List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType)\n     */\n    QUERYFORLIST_SQL_ARGS_ELEMENTTYPE,\n\n    /**\n     * List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes)\n     */\n    QUERYFORLIST_SQL_ARGS_ARGTYPES,\n\n    /**\n     * List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)\n     */\n    QUERYFORLIST_SQL_ARGS_ARGTYPES_ELEMENTTYPE,\n\n\n    /**\n     * Map<String, Object> queryForMap(String sql)\n     */\n    QUERYFORMAP_SQL,\n\n    /**\n     * Map<String, Object> queryForMap(String sql, @Nullable Object... args)\n     */\n    QUERYFORMAP_SQL_ARGS,\n\n    /**\n     * Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes)\n     */\n    QUERYFORMAP_SQL_ARGS_ARGTYPES,\n\n\n    /**\n     * T queryForObject(String sql, Class<T> requiredType)\n     */\n    QUERYFOROBJECT_SQL_REQUIREDTYPE,\n\n    /**\n     * T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)\n     */\n    QUERYFOROBJECT_SQL_REQUIREDTYPE_ARGS,\n\n    /**\n     * T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)\n     */\n    QUERYFOROBJECT_SQL_ARGS_REQUIREDTYPE,\n\n    /**\n     * T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n     */\n    QUERYFOROBJECT_SQL_ARGS_ARGTYPES_REQUIREDTYPE,\n\n    /**\n     * T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n     */\n    QUERYFOROBJECT_SQL_ARGS_ARGTYPES_ROWMAPPER,\n\n    /**\n     * T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n     */\n    QUERYFOROBJECT_SQL_ARGS_ROWMAPPER,\n\n    /**\n     * T queryForObject(String sql, RowMapper<T> rowMapper)\n     */\n    QUERYFOROBJECT_SQL_ROWMAPPER,\n\n    /**\n     * T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    QUERYFOROBJECT_SQL_ROWMAPPER_ARGS,\n\n\n    /**\n     * SqlRowSet queryForRowSet(String sql)\n     */\n    QUERYFORROWSET_SQL,\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, @Nullable Object... args)\n     */\n    QUERYFORROWSET_SQL_ARGS,\n\n    /**\n     * SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)\n     */\n    QUERYFORROWSET_SQL_ARGS_ARGTYPES,\n\n\n    /**\n     * Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n     */\n    QUERYFORSTREAM_SQL_PSS_ROWMAPPER,\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)\n     */\n    QUERYFORSTREAM_SQL_ROWMAPPER,\n\n    /**\n     * Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n     */\n    QUERYFORSTREAM_SQL_ROWMAPPER_ARGS,\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodType.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/20 16:47\n */\npublic enum MethodType {\n    /**\n     * \u672a\u77e5\u6267\u884c\u65b9\u6cd5\n     */\n    UNKNOWN,\n    /**\n     * \u65b0\u589e\u3001\u4fee\u6539\u3001\u5220\u9664 SQL\u8bed\u53e5\n     */\n    UPDATE,\n    /**\n     * \u67e5\u8be2 SQL\u8bed\u53e5\n     */\n    QUERY,\n    /**\n     * DDL\u3001\u5b58\u50a8\u8fc7\u7a0b SQL\u8bed\u53e5\n     */\n    EXECUTE\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodActionInfo.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\nimport lombok.Data;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.List;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/17 15:48", " * @author wanghao 913351190@qq.com\n * @create 2023/7/17 15:48\n */\n@Data\n@Slf4j\npublic class MethodActionInfo {\n\n    private MethodActionType actionType = MethodActionType.UNKNOWN;\n\n    //\u4ee5\u4e0b\u662f\u9488\u5bf9\u5165\u53c2-SQL\n\n\n    /**\n     * SQL\u8bed\u53e5\n     */\n//    private String sql;\n    /**\n     * \u6279\u91cfSQL\u8bed\u53e5\n     */\n    private String[] batchSql;\n    /**\n     * \u662f\u5426\u6279\u91cfSQL\u8bed\u53e5\n     */\n    private boolean sqlIsBatch;\n\n\n    //\u4ee5\u4e0b\u9488\u5bf9\u5165\u53c2-SQL\u5165\u53c2\n\n    /**\n     * \u662f\u5426\u6709\u5165\u53c2\n     */\n    private boolean hasParameter;\n    /**\n     * \u5165\u53c2\u662f\u5426\u662fpss\n     */\n    private boolean parameterIsPss;\n    /**\n     * \u5165\u53c2Object[]\n     */\n//    private Object[] parameter;\n    /**\n     * \u6279\u91cf\u5165\u53c2List<Object[]>\n     */\n    private List<Object[]> batchParameter;\n    /**\n     * \u53c2\u6570\u662f\u5426\u662f\u6279\u91cf\n     */\n    private boolean parameterIsBatch;\n    /**\n     * \u5165\u53c2\u7d22\u5f15\n     */\n    private int parameterIndex;\n    /**\n     * \u662f\u5426\u6709\u5165\u53c2\u7c7b\u578b\u5b9a\u4e49\n     */\n    private boolean hasParameterType;\n    /**\n     * \u5165\u53c2\u7c7b\u578b\u5b9a\u4e49\n     */\n    private int[] parameterType;\n    /**\n     * \u5165\u53c2\u7c7b\u578b\u5b9a\u4e49\u7d22\u5f15\n     */\n    private int parameterTypeIndex;\n", "    public String getSql() {\n        if (this.batchSql != null && this.batchSql.length > 0) {\n            return this.batchSql[0];\n        }\n        return null;\n    }\n\n    private void setSql(String sql) {\n    }\n\n    public Object[] getParameter() {", "        if (this.batchParameter != null && this.batchParameter.size() > 0) {\n            return this.batchParameter.get(0);\n        }\n        return null;\n    }\n\n    private void setParameter(Object[] parameter) {\n    }\n\n    //\u4ee5\u4e0b\u662f\u9488\u5bf9\u51fa\u53c2\u5206\u5206\u6790\n\n    /**\n     * \u662f\u5426\u6709\u8fd4\u56de\u503c\n     */\n    private boolean hasReturn;\n    /**\n     * \u8fd4\u56de\u503c\u7c7b\u578b\u662f\u5426\u662fLIST\n     */\n    private boolean returnIsList;\n\n    public MethodActionInfo(boolean parameterIsPss, int parameterIndex, int parameterTypeIndex,\n                            boolean hasReturn, boolean returnIsList) {\n        this.actionType = MethodActionType.DYNAMIC;//TODO \u5f85\u5b8c\u5584\n        this.parameterIsPss = parameterIsPss;\n        this.parameterIndex = parameterIndex;", "        if (parameterIndex >= 0) {\n            this.hasParameter = true;\n        }\n        this.parameterTypeIndex = parameterTypeIndex;\n        if (parameterTypeIndex >= 0) {\n            this.hasParameterType = true;\n        }\n        this.hasReturn = hasReturn;\n        this.returnIsList = returnIsList;\n    }\n\n    public MethodActionInfo(int parameterIndex,\n                            boolean hasReturn, boolean returnIsList) {\n        this(false, parameterIndex, -1,\n                hasReturn, returnIsList);\n    }\n\n    public MethodActionInfo(int parameterIndex,\n                            boolean sqlIsBatch, boolean parameterIsBatch,\n                            boolean hasReturn, boolean returnIsList) {\n        this(false, parameterIndex, -1,\n                hasReturn, returnIsList);\n\n        this.sqlIsBatch = sqlIsBatch;\n        this.parameterIsBatch = parameterIsBatch;\n    }\n\n    public MethodActionInfo() {\n        //\u4e0d\u652f\u6301\u65b9\u6cd5\u65f6\u4f7f\u7528\u65e0\u53c2\u6784\u9020\u51fd\u6570\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodActionRegister.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.jdbc.core.*;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * @author wanghao 913351190@qq.com", "/**\n * @author wanghao 913351190@qq.com\n * @create 2023/7/17 15:24\n */\n@Slf4j\npublic class MethodActionRegister {\n\n    private final static Map<Method, MethodActionInfo> Method_MAP = new HashMap<>();\n\n    static {\n        Class<JdbcTemplate> clazz = JdbcTemplate.class;\n\n        //int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss)\n        register(clazz, new MethodActionInfo(-1, true, false), \"batchUpdate\", String.class, BatchPreparedStatementSetter.class);\n        //int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize, final ParameterizedPreparedStatementSetter<T> pss)\n        register(clazz, new MethodActionInfo(-1, true, false), \"batchUpdate\", String.class, Collection.class, int.class, ParameterizedPreparedStatementSetter.class);\n        //int[] batchUpdate(String sql, List<Object[]> batchArgs)\n        register(clazz, new MethodActionInfo(1, false, true, true, false), \"batchUpdate\", String.class, List.class);\n        //int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)\n        register(clazz, new MethodActionInfo(1, false, true, true, false), \"batchUpdate\", String.class, List.class, int[].class);\n        //int[] batchUpdate(final String... sql)\n        register(clazz, new MethodActionInfo(-1, true, false, true, false), \"batchUpdate\", String[].class);\n\n\n        //int update(final String sql)\n        register(clazz, new MethodActionInfo(-1, true, false), \"update\", String.class);\n        //int update(String sql, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(1, true, false), \"update\", String.class, Object[].class);\n        //update(String sql, Object[] args, int[] argTypes)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"update\", String.class, Object[].class, int[].class);\n        //int update(String sql, @Nullable PreparedStatementSetter pss)\n        register(clazz, new MethodActionInfo(true, 1, -1, true, false), \"update\", String.class, PreparedStatementSetter.class);\n\n\n        //T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"query\", String.class, Object[].class, int[].class, ResultSetExtractor.class);\n        //void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)\n        register(clazz, new MethodActionInfo(false, 1, 2, false, false), \"query\", String.class, Object[].class, int[].class, RowCallbackHandler.class);\n        //List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, true), \"query\", String.class, Object[].class, int[].class, RowMapper.class);\n        //T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, false), \"query\", String.class, Object[].class, ResultSetExtractor.class);\n        //void query(String sql, @Nullable Object[] args, RowCallbackHandler rch)\n        register(clazz, new MethodActionInfo(false, 1, -1, false, false), \"query\", String.class, Object[].class, RowCallbackHandler.class);\n        //List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, true), \"query\", String.class, Object[].class, RowMapper.class);\n        //T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)\n        register(clazz, new MethodActionInfo(true, 1, -1, true, false), \"query\", String.class, PreparedStatementSetter.class, ResultSetExtractor.class);\n        //void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)\n        register(clazz, new MethodActionInfo(true, 1, -1, false, false), \"query\", String.class, PreparedStatementSetter.class, RowCallbackHandler.class);\n        //List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(true, 1, -1, true, true), \"query\", String.class, PreparedStatementSetter.class, RowMapper.class);\n        //T query(final String sql, final ResultSetExtractor<T> rse)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"query\", String.class, ResultSetExtractor.class);\n        //T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, false), \"query\", String.class, ResultSetExtractor.class, Object[].class);\n        //void query(String sql, RowCallbackHandler rch)\n        register(clazz, new MethodActionInfo(false, -1, -1, false, false), \"query\", String.class, RowCallbackHandler.class);\n        //void query(String sql, RowCallbackHandler rch, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, false, false), \"query\", String.class, RowCallbackHandler.class, Object[].class);\n        //List<T> query(String sql, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, true), \"query\", String.class, RowMapper.class);\n        //List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, true), \"query\", String.class, RowMapper.class, Object[].class);\n\n\n        //List<Map<String, Object>> queryForList(String sql)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, true), \"queryForList\", String.class);\n        //List<T> queryForList(String sql, Class<T> elementType)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, true), \"queryForList\", String.class, Class.class);\n        //List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, true), \"queryForList\", String.class, Class.class, Object[].class);\n        //List<Map<String, Object>> queryForList(String sql, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, true), \"queryForList\", String.class, Object[].class);\n        //List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, true), \"queryForList\", String.class, Object[].class, Class.class);\n        //List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, true), \"queryForList\", String.class, Object[].class, int[].class);\n        //List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, true), \"queryForList\", String.class, Object[].class, int[].class, Class.class);\n\n\n        //Map<String, Object> queryForMap(String sql)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"queryForMap\", String.class);\n        //Map<String, Object> queryForMap(String sql, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, false), \"queryForMap\", String.class, Object[].class);\n        //Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"queryForMap\", String.class, Object[].class, int[].class);\n\n\n        //T queryForObject(String sql, Class<T> requiredType)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"queryForObject\", String.class, Class.class);\n        //T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, false), \"queryForObject\", String.class, Class.class, Object[].class);\n        //T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, false), \"queryForObject\", String.class, Object[].class, Class.class);\n        //T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"queryForObject\", String.class, Object[].class, int[].class, Class.class);\n        //T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"queryForObject\", String.class, Object[].class, int[].class, RowMapper.class);\n        //T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, false), \"queryForObject\", String.class, Object[].class, RowMapper.class);\n        //T queryForObject(String sql, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"queryForObject\", String.class, RowMapper.class);\n        //T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, false), \"queryForObject\", String.class, RowMapper.class, Object[].class);\n\n\n        //SqlRowSet queryForRowSet(String sql)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"queryForRowSet\", String.class);\n        //SqlRowSet queryForRowSet(String sql, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 1, -1, true, false), \"queryForRowSet\", String.class, Object[].class);\n        //SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)\n        register(clazz, new MethodActionInfo(false, 1, 2, true, false), \"queryForRowSet\", String.class, Object[].class, int[].class);\n\n        \n        //Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(true, 1, -1, true, false), \"queryForStream\", String.class, PreparedStatementSetter.class, RowMapper.class);\n        //Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)\n        register(clazz, new MethodActionInfo(false, -1, -1, true, false), \"queryForStream\", String.class, RowMapper.class);\n        //Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)\n        register(clazz, new MethodActionInfo(false, 2, -1, true, false), \"queryForStream\", String.class, RowMapper.class, Object[].class);\n\n\n    }\n", "    public static MethodActionInfo getMethodActionInfo(Method method, Object[] args) {\n        if (Method_MAP.containsKey(method)) {\n            MethodActionInfo actionInfo = Method_MAP.get(method);\n\n            //SQL\u8bed\u53e5\n            if (actionInfo.isSqlIsBatch()) {\n                actionInfo.setBatchSql((String[]) args[0]);\n            } else {\n                actionInfo.setBatchSql(new String[]{(String) args[0]});\n            }\n            //SQL\u8bed\u53e5\u53c2\u6570", "            if (actionInfo.isHasParameter()) {\n                if (!actionInfo.isParameterIsPss()) {\n                    if (actionInfo.isParameterIsBatch()) {\n                        actionInfo.setBatchParameter((List<Object[]>) args[actionInfo.getParameterIndex()]);\n                    } else {\n                        List<Object[]> batchParameter = new ArrayList<>();\n                        batchParameter.add((Object[]) args[actionInfo.getParameterIndex()]);\n                        actionInfo.setBatchParameter(batchParameter);\n                    }\n                }\n                if (actionInfo.isHasParameterType()) {\n                    actionInfo.setParameterType((int[]) args[actionInfo.getParameterTypeIndex()]);\n                }\n            }\n\n            return actionInfo;\n\n        } else {\n            return new MethodActionInfo();\n        }\n    }\n", "                if (actionInfo.isHasParameterType()) {\n                    actionInfo.setParameterType((int[]) args[actionInfo.getParameterTypeIndex()]);\n                }\n            }\n\n            return actionInfo;\n\n        } else {\n            return new MethodActionInfo();\n        }\n    }\n", "    public static void register(Class<JdbcTemplate> clazz, MethodActionInfo actionInfo, String name, Class<?>... parameterTypes) {\n        try {\n            Method method = clazz.getMethod(name, parameterTypes);\n            Method_MAP.put(method, actionInfo);\n        } catch (NoSuchMethodException e) {\n            log.error(\"\u672a\u627e\u5230\u65b9\u6cd5\uff1aname={},parameterTypes={}\", name, parameterTypes, e);\n        }\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodInvocationInfo.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author wanghao 913351190@qq.com", "/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/23 14:24\n */\npublic class MethodInvocationInfo extends MethodInfo {\n\n    private boolean isSupport;\n\n    private final Object[] args;\n\n    private MethodType type;\n\n    private MethodActionInfo actionInfo;\n\n    private final Map<String, Object> userAttributes = new HashMap<>(0);\n\n    public MethodInvocationInfo(final Object[] args, Method method) {\n        super(method);\n        this.args = args;\n        this.type = MethodType.UNKNOWN;\n        this.isSupport = false;\n\n        this.resolveMethod();\n    }\n\n    public Object[] getArgs() {\n        return this.args;\n    }\n", "    public MethodType getType() {\n        return this.type;\n    }\n\n    public boolean isSupport() {\n        return this.isSupport;\n    }\n\n    public MethodActionInfo getActionInfo() {\n        return this.actionInfo;\n    }\n\n    public Map<String, Object> getUserAttributes() {\n        return this.userAttributes;\n    }\n", "    public MethodActionInfo getActionInfo() {\n        return this.actionInfo;\n    }\n\n    public Map<String, Object> getUserAttributes() {\n        return this.userAttributes;\n    }\n\n    public void putUserAttribute(String key, Object value) {\n        if (this.userAttributes != null) {\n            this.userAttributes.put(key, value);\n        }\n    }\n", "    public void putUserAttribute(String key, Object value) {\n        if (this.userAttributes != null) {\n            this.userAttributes.put(key, value);\n        }\n    }\n\n    public Object getUserAttribute(String key) {\n        if (this.userAttributes != null) {\n            return this.userAttributes.get(key);\n        }\n        return null;\n    }\n\n\n    //=================METHOD START================\n", "    public void resolveSql(String sql) {\n        this.resolveSql(new String[]{sql});\n    }\n\n    public void resolveSql(String[] batchSql) {\n        if (this.actionInfo != null) {\n            if (batchSql == null || batchSql.length == 0) {\n                throw new RuntimeException(\"batchSql\u4e0d\u80fd\u4e3a\u7a7a\");\n            }\n            this.actionInfo.setBatchSql(batchSql);\n", "            if (this.actionInfo.isSqlIsBatch()) {\n                this.args[0] = this.actionInfo.getBatchSql();\n            } else {\n                this.args[0] = this.actionInfo.getSql();\n            }\n\n        }\n    }\n\n    public void resolveSql(int i, String sql) {\n        if (this.actionInfo != null) {\n\n            this.actionInfo.getBatchSql()[i] = sql;\n", "    public void resolveSql(int i, String sql) {\n        if (this.actionInfo != null) {\n\n            this.actionInfo.getBatchSql()[i] = sql;\n\n            if (this.actionInfo.isSqlIsBatch()) {\n                this.args[0] = this.actionInfo.getBatchSql();\n            } else {\n                this.args[0] = this.actionInfo.getSql();\n            }\n\n        }\n    }\n", "    public void resolveParameter(Object[] parameter) {\n        List<Object[]> objects = new ArrayList<>();\n        objects.add(parameter);\n        this.resolveParameter(objects);\n    }\n\n    public void resolveParameter(List<Object[]> batchParameter) {\n        if (this.actionInfo != null) {\n            if (batchParameter == null || batchParameter.size() == 0) {\n                throw new RuntimeException(\"batchParameter\u4e0d\u80fd\u4e3a\u7a7a\");\n            }\n            this.actionInfo.setBatchParameter(batchParameter);\n", "            if (batchParameter == null || batchParameter.size() == 0) {\n                throw new RuntimeException(\"batchParameter\u4e0d\u80fd\u4e3a\u7a7a\");\n            }\n            this.actionInfo.setBatchParameter(batchParameter);\n\n            if (this.actionInfo.isHasParameter()) {\n                if (!this.actionInfo.isParameterIsPss()) {\n                    if (this.actionInfo.isParameterIsBatch()) {\n                        this.args[this.actionInfo.getParameterIndex()] = this.actionInfo.getBatchParameter();\n                    } else {\n                        this.args[this.actionInfo.getParameterIndex()] = this.actionInfo.getParameter();\n                    }\n                }\n            }\n        }\n    }\n\n    //=================METHOD END================\n\n\n    /**\n     * \u89e3\u6790Method\n     */\n    private void resolveMethod() {", "        if (this.getName().startsWith(\"execute\")) {\n            this.type = MethodType.EXECUTE;\n        } else if (this.getName().startsWith(\"batchUpdate\")) {\n            this.type = MethodType.UPDATE;\n        } else if (this.getName().startsWith(\"update\")) {\n            this.type = MethodType.UPDATE;\n        } else if (this.getName().startsWith(\"query\")) {\n            this.type = MethodType.QUERY;\n        }\n        this.actionInfo = MethodActionRegister.getMethodActionInfo(this.getMethod(), this.args);\n        if (this.actionInfo != null && !this.actionInfo.getActionType().equals(MethodActionType.UNKNOWN)) {\n            this.isSupport = true;\n        }\n    }\n\n}\n", "        if (this.actionInfo != null && !this.actionInfo.getActionType().equals(MethodActionType.UNKNOWN)) {\n            this.isSupport = true;\n        }\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/method/MethodInfo.java", "chunked_list": ["package com.github.deeround.jdbc.plus.method;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author wanghao 913351190@qq.com\n * @create 2023/4/20 16:53\n */\npublic class MethodInfo {\n\n    private Method method;\n\n    private String name;\n\n    private Class<?>[] parameterTypes;\n\n    private Class<?> returnType;\n", "public class MethodInfo {\n\n    private Method method;\n\n    private String name;\n\n    private Class<?>[] parameterTypes;\n\n    private Class<?> returnType;\n\n    public Method getMethod() {\n        return this.method;\n    }\n", "    public Method getMethod() {\n        return this.method;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return this.parameterTypes;\n    }\n\n    public Class<?> getReturnType() {\n        return this.returnType;\n    }\n\n    public MethodInfo(Method method) {\n        this.method = method;\n        this.name = method.getName();\n        this.parameterTypes = method.getParameterTypes();\n        this.returnType = method.getReturnType();\n    }\n\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/aop/JdbcTemplateMethodInterceptor.java", "chunked_list": ["/*\n * Copyright \u00a9 2018 organization baomidou\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.aop;\n\nimport com.github.deeround.jdbc.plus.Interceptor.IInterceptor;", "\nimport com.github.deeround.jdbc.plus.Interceptor.IInterceptor;\nimport com.github.deeround.jdbc.plus.method.MethodInvocationInfo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.springframework.aop.framework.ReflectiveMethodInvocation;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.lang.reflect.Method;", "\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\n\n@Slf4j\npublic class JdbcTemplateMethodInterceptor implements MethodInterceptor {\n\n    private final List<IInterceptor> interceptors;\n\n    public JdbcTemplateMethodInterceptor(List<IInterceptor> interceptors) {\n        this.interceptors = interceptors;\n    }\n\n    @Override", "    public Object invoke(MethodInvocation invocation) throws Throwable {\n        ReflectiveMethodInvocation methodInvocation = (ReflectiveMethodInvocation) invocation;\n\n        Object[] args = methodInvocation.getArguments();\n        Method method = methodInvocation.getMethod();\n        JdbcTemplate jdbcTemplate = (JdbcTemplate) methodInvocation.getThis();\n\n        final MethodInvocationInfo methodInfo = new MethodInvocationInfo(args, method);\n        log.debug(\"method==>name:{},actionType:{}\", methodInfo.getName(), methodInfo.getActionInfo().getActionType());\n        log.debug(\"origin sql==>{}\", this.toStr(methodInfo.getActionInfo().getBatchSql()));\n        log.debug(\"origin parameters==>{}\", this.toStr(methodInfo.getActionInfo().getBatchParameter()));\n\n        //\u903b\u8f91\u5904\u7406\uff08\u6838\u5fc3\u65b9\u6cd5\uff1a\u4e3b\u8981\u5904\u7406SQL\u548cSQL\u53c2\u6570\uff09", "        if (this.interceptors != null && this.interceptors.size() > 0) {\n            for (IInterceptor interceptor : this.interceptors) {\n                if (interceptor.supportMethod(methodInfo)) {\n                    interceptor.beforePrepare(methodInfo, jdbcTemplate);\n                    //\u63d2\u4ef6\u5141\u8bb8\u4fee\u6539\u539f\u59cbSQL\u4ee5\u53ca\u5165\u53c2\n                    if (methodInfo.getArgs() != null && methodInfo.getArgs().length > 0) {\n                        //\u56de\u5199\u53c2\u6570\n                        methodInvocation.setArguments(methodInfo.getArgs());\n                    }\n                }\n            }\n        }\n        log.debug(\"finish sql==>{}\", this.toStr(methodInfo.getActionInfo().getBatchSql()));\n        log.debug(\"finish parameters==>{}\", this.toStr(methodInfo.getActionInfo().getBatchParameter()));\n\n\n        Object result = methodInvocation.proceed();\n        log.debug(\"origin result==>{}\", result);\n\n        //\u903b\u8f91\u5904\u7406", "        if (this.interceptors != null && this.interceptors.size() > 0) {\n            for (int i = this.interceptors.size() - 1; i >= 0; i--) {\n                IInterceptor interceptor = this.interceptors.get(i);\n                if (interceptor.supportMethod(methodInfo)) {\n                    result = interceptor.beforeFinish(result, methodInfo, jdbcTemplate);\n                }\n            }\n        }\n        log.debug(\"finish result==>{}\", result);\n\n        return result;\n    }\n\n    private String toStr(Object[] objs) {", "        if (objs == null) {\n            return null;\n        }\n        return Arrays.toString(objs);\n    }\n\n    private String toStr(List<Object[]> list) {\n        if (list == null) {\n            return null;\n        }\n        StringBuilder str = new StringBuilder();\n        str.append(\"[\");", "        for (int i = 0; i < list.size(); i++) {\n            str.append(Arrays.toString(list.get(i)));\n            if (i < list.size() - 1) {\n                str.append(\",\");\n            }\n        }\n        return str.append(\"]\").toString();\n    }\n}\n"]}
{"filename": "jdbc-plus-spring-boot-starter/src/main/java/com/github/deeround/jdbc/plus/aop/JdbcTemplateMethodAdvisor.java", "chunked_list": ["/*\n * Copyright \u00a9 2018 organization baomidou\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.deeround.jdbc.plus.aop;\n\nimport org.aopalliance.aop.Advice;", "\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.support.AbstractPointcutAdvisor;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\n", "import org.springframework.beans.factory.BeanFactoryAware;\n\n/**\n * @author TaoYu\n * @since 1.2.0\n */\npublic class JdbcTemplateMethodAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n\n    private final Advice advice;\n\n    private final Pointcut pointcut;\n\n    public JdbcTemplateMethodAdvisor(MethodInterceptor advice) {\n        this.advice = advice;\n        this.pointcut = this.buildPointcut();\n    }\n\n    @Override", "    public Pointcut getPointcut() {\n        return this.pointcut;\n    }\n\n    @Override\n    public Advice getAdvice() {\n        return this.advice;\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {", "    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        if (this.advice instanceof BeanFactoryAware) {\n            ((BeanFactoryAware) this.advice).setBeanFactory(beanFactory);\n        }\n    }\n\n    private Pointcut buildPointcut() {\n        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n        pointcut.setExpression(\"execution(public * org.springframework.jdbc.core.JdbcTemplate.*(..))\");\n        return pointcut;\n    }\n}\n"]}
