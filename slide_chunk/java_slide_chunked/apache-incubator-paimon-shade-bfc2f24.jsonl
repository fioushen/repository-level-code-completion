{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/notice/NoticeParserTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.notice;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;", "import java.util.Arrays;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass NoticeParserTest {\n    @Test\n    void testParseNoticeFileCommonPath() {\n        final String module = \"some-module\";\n        final Dependency dependency1 =", "        final String module = \"some-module\";\n        final Dependency dependency1 =\n                Dependency.create(\"groupId1\", \"artifactId1\", \"version1\", null);\n        final Dependency dependency2 =\n                Dependency.create(\"groupId2\", \"artifactId2\", \"version2\", \"classifier2\");\n        final Dependency dependency3 =\n                Dependency.create(\"org.codehaus.woodstox\", \"stax2-api\", \"4.2.1\", null);\n        final List<String> noticeContents =\n                Arrays.asList(\n                        module,", "                Arrays.asList(\n                        module,\n                        \"\",\n                        \"Some text about the applicable license\",\n                        \"- groupId1:artifactId1:version1\",\n                        \"- groupId2:artifactId2:classifier2:version2\",\n                        \"- org.codehaus.woodstox:stax2-api:4.2.1 (https://github.com/FasterXML/stax2-api/tree/stax2-api-4.2.1)\",\n                        \"\",\n                        \"some epilogue\");\n", "                        \"some epilogue\");\n\n        assertThat(NoticeParser.parseNoticeFile(noticeContents))\n                .hasValueSatisfying(\n                        contents -> {\n                            assertThat(contents.getNoticeModuleName()).isEqualTo(module);\n                            assertThat(contents.getDeclaredDependencies())\n                                    .containsExactlyInAnyOrder(\n                                            dependency1, dependency2, dependency3);\n                        });", "                                            dependency1, dependency2, dependency3);\n                        });\n    }\n\n    @Test\n    void testParseNoticeFileBundlesPath() {\n        final String module = \"some-module\";\n        final Dependency dependency =\n                Dependency.create(\"groupId\", \"artifactId\", \"version\", \"classifier\");\n        final List<String> noticeContents =", "                Dependency.create(\"groupId\", \"artifactId\", \"version\", \"classifier\");\n        final List<String> noticeContents =\n                Arrays.asList(\n                        module, \"\", \"Something bundles \\\"groupId:artifactId:classifier:version\\\"\");\n\n        assertThat(NoticeParser.parseNoticeFile(noticeContents))\n                .hasValueSatisfying(\n                        contents -> {\n                            assertThat(contents.getNoticeModuleName()).isEqualTo(module);\n                            assertThat(contents.getDeclaredDependencies())", "                            assertThat(contents.getNoticeModuleName()).isEqualTo(module);\n                            assertThat(contents.getDeclaredDependencies())\n                                    .containsExactlyInAnyOrder(dependency);\n                        });\n    }\n\n    @Test\n    void testParseNoticeFileMalformedDependencyIgnored() {\n        final String module = \"some-module\";\n        final Dependency dependency = Dependency.create(\"groupId\", \"artifactId\", \"version\", null);", "        final String module = \"some-module\";\n        final Dependency dependency = Dependency.create(\"groupId\", \"artifactId\", \"version\", null);\n        final List<String> noticeContents = Arrays.asList(module, \"- \" + dependency, \"- a:b\");\n\n        assertThat(NoticeParser.parseNoticeFile(noticeContents))\n                .hasValueSatisfying(\n                        contents -> {\n                            assertThat(contents.getNoticeModuleName()).isEqualTo(module);\n                            assertThat(contents.getDeclaredDependencies())\n                                    .containsExactlyInAnyOrder(dependency);", "                            assertThat(contents.getDeclaredDependencies())\n                                    .containsExactlyInAnyOrder(dependency);\n                        });\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/shade/ShadeParserTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.shade;", "\npackage org.apache.paimon.tools.ci.utils.shade;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Stream;", "import java.util.Set;\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass ShadeParserTest {\n\n    private static Stream<String> getTestDependencyCopy() {\n        return Stream.of(\n                \"[INFO] --- maven-shade-plugin:3.2.0:shade (shade-paimon) @ m1 ---\",", "        return Stream.of(\n                \"[INFO] --- maven-shade-plugin:3.2.0:shade (shade-paimon) @ m1 ---\",\n                \"[INFO] Including external:dependency1:jar:2.1 in the shaded jar.\",\n                \"[INFO] Excluding external:dependency3:jar:2.3 from the shaded jar.\",\n                \"[INFO] Including external:dependency4:jar:classifier:2.4 in the shaded jar.\",\n                \"[INFO] Replacing original artifact with shaded artifact.\",\n                \"[INFO] Replacing /some/path/m1.jar with /some/path/m1-shaded.jar\",\n                \"[INFO]\",\n                \"[INFO] --- maven-shade-plugin:3.2.0:shade (shade-paimon) @ m2 ---\",\n                \"[INFO] Including internal:m1:jar:1.1 in the shaded jar.\",", "                \"[INFO] --- maven-shade-plugin:3.2.0:shade (shade-paimon) @ m2 ---\",\n                \"[INFO] Including internal:m1:jar:1.1 in the shaded jar.\",\n                \"[INFO] Replacing /some/path/m2.jar with /some/path/m2-shaded.jar\");\n    }\n\n    @Test\n    void testParsing() {\n        final Map<String, Set<Dependency>> dependenciesByModule =\n                ShadeParser.parseShadeOutput(getTestDependencyCopy());\n", "                ShadeParser.parseShadeOutput(getTestDependencyCopy());\n\n        assertThat(dependenciesByModule).containsOnlyKeys(\"m1\", \"m2\");\n        assertThat(dependenciesByModule.get(\"m1\"))\n                .containsExactlyInAnyOrder(\n                        Dependency.create(\"external\", \"dependency1\", \"2.1\", null),\n                        Dependency.create(\"external\", \"dependency4\", \"2.4\", \"classifier\"));\n        assertThat(dependenciesByModule.get(\"m2\"))\n                .containsExactlyInAnyOrder(Dependency.create(\"internal\", \"m1\", \"1.1\", null));\n    }", "                .containsExactlyInAnyOrder(Dependency.create(\"internal\", \"m1\", \"1.1\", null));\n    }\n\n    @Test\n    void testLineParsingGroupId() {\n        assertThat(\n                        ShadeParser.parseDependency(\n                                \"Including external:dependency1:jar:1.0 in the shaded jar.\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getGroupId()).isEqualTo(\"external\"));", "                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getGroupId()).isEqualTo(\"external\"));\n    }\n\n    @Test\n    void testLineParsingArtifactId() {\n        assertThat(\n                        ShadeParser.parseDependency(\n                                \"Including external:dependency1:jar:1.0 in the shaded jar.\"))\n                .hasValueSatisfying(", "                                \"Including external:dependency1:jar:1.0 in the shaded jar.\"))\n                .hasValueSatisfying(\n                        dependency ->\n                                assertThat(dependency.getArtifactId()).isEqualTo(\"dependency1\"));\n    }\n\n    @Test\n    void testLineParsingVersion() {\n        assertThat(\n                        ShadeParser.parseDependency(", "        assertThat(\n                        ShadeParser.parseDependency(\n                                \"Including external:dependency1:jar:1.0 in the shaded jar.\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getVersion()).isEqualTo(\"1.0\"));\n    }\n\n    @Test\n    void testLineParsingWithNonJarType() {\n        assertThat(", "    void testLineParsingWithNonJarType() {\n        assertThat(\n                        ShadeParser.parseDependency(\n                                \"Including external:dependency1:pom:1.0 in the shaded jar.\"))\n                .isPresent();\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/dependency/DependencyParserCopyTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.dependency;", "\npackage org.apache.paimon.tools.ci.utils.dependency;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Stream;", "import java.util.Set;\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/** Tests the parsing of {@code dependency:copy}. */\nclass DependencyParserCopyTest {\n\n    private static Stream<String> getTestDependencyCopy() {\n        return Stream.of(", "    private static Stream<String> getTestDependencyCopy() {\n        return Stream.of(\n                \"[INFO] --- maven-dependency-plugin:3.2.0:copy (copy) @ m1 ---\",\n                \"[INFO] Configured Artifact: external:dependency1:2.1:jar\",\n                \"[INFO] Configured Artifact: external:dependency4:classifier:2.4:jar\",\n                \"[INFO] Copying dependency1-2.1.jar to /some/path/dependency1-2.1.jar\",\n                \"[INFO] Copying dependency4-2.4.jar to /some/path/dependency4-2.4.jar\",\n                \"[INFO]\",\n                \"[INFO] --- maven-dependency-plugin:3.2.0:copy (copy) @ m2 ---\",\n                \"[INFO] Configured Artifact: internal:m1:1.1:jar\",", "                \"[INFO] --- maven-dependency-plugin:3.2.0:copy (copy) @ m2 ---\",\n                \"[INFO] Configured Artifact: internal:m1:1.1:jar\",\n                \"[INFO] Copying internal-1.1.jar to /some/path/m1-1.1.jar\");\n    }\n\n    @Test\n    void testCopyParsing() {\n        final Map<String, Set<Dependency>> dependenciesByModule =\n                DependencyParser.parseDependencyCopyOutput(getTestDependencyCopy());\n", "                DependencyParser.parseDependencyCopyOutput(getTestDependencyCopy());\n\n        assertThat(dependenciesByModule).containsOnlyKeys(\"m1\", \"m2\");\n        assertThat(dependenciesByModule.get(\"m1\"))\n                .containsExactlyInAnyOrder(\n                        Dependency.create(\"external\", \"dependency1\", \"2.1\", null),\n                        Dependency.create(\"external\", \"dependency4\", \"2.4\", \"classifier\"));\n        assertThat(dependenciesByModule.get(\"m2\"))\n                .containsExactlyInAnyOrder(Dependency.create(\"internal\", \"m1\", \"1.1\", null));\n    }", "                .containsExactlyInAnyOrder(Dependency.create(\"internal\", \"m1\", \"1.1\", null));\n    }\n\n    @Test\n    void testCopyLineParsingGroupId() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getGroupId()).isEqualTo(\"external\"));", "                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getGroupId()).isEqualTo(\"external\"));\n    }\n\n    @Test\n    void testCopyLineParsingArtifactId() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(", "                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(\n                        dependency ->\n                                assertThat(dependency.getArtifactId()).isEqualTo(\"dependency1\"));\n    }\n\n    @Test\n    void testCopyLineParsingVersion() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(", "        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getVersion()).isEqualTo(\"1.0\"));\n    }\n\n    @Test\n    void testCopyLineParsingScope() {\n        assertThat(", "    void testCopyLineParsingScope() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(dependency -> assertThat(dependency.getScope()).isEmpty());\n    }\n\n    @Test\n    void testCopyLineParsingOptional() {\n        assertThat(", "    void testCopyLineParsingOptional() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:jar\"))\n                .hasValueSatisfying(dependency -> assertThat(dependency.isOptional()).isEmpty());\n    }\n\n    @Test\n    void testCopyLineParsingWithNonJarType() {\n        assertThat(", "    void testCopyLineParsingWithNonJarType() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:1.0:pom\"))\n                .hasValue(Dependency.create(\"external\", \"dependency1\", \"1.0\", null));\n    }\n\n    @Test\n    void testCopyLineParsingClassifier() {\n        assertThat(", "    void testCopyLineParsingClassifier() {\n        assertThat(\n                        DependencyParser.parseCopyDependency(\n                                \"[INFO] Configured Artifact: external:dependency1:some_classifier:1.0:jar\"))\n                .hasValueSatisfying(\n                        dependency ->\n                                assertThat(dependency.getClassifier()).hasValue(\"some_classifier\"));\n    }\n}\n", "}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/dependency/DependencyParserTreeTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.dependency;", "\npackage org.apache.paimon.tools.ci.utils.dependency;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\nimport org.apache.paimon.tools.ci.utils.shared.DependencyTree;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Map;\nimport java.util.stream.Stream;", "import java.util.Map;\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/** Tests the parsing of {@code dependency:tree}. */\nclass DependencyParserTreeTest {\n\n    private static Stream<String> getTestDependencyTree() {\n        return Stream.of(", "    private static Stream<String> getTestDependencyTree() {\n        return Stream.of(\n                \"[INFO] --- maven-dependency-plugin:3.2.0:tree (default-cli) @ m1 ---\",\n                \"[INFO] internal:m1:jar:1.1\",\n                \"[INFO] +- external:dependency1:jar:2.1:compile\",\n                \"[INFO] |  +- external:dependency2:jar:2.2:compile (optional)\",\n                \"[INFO] |  |  \\\\- external:dependency3:jar:2.3:provided\",\n                \"[INFO] |  +- external:dependency4:jar:classifier:2.4:compile\",\n                \"[INFO]\",\n                \"[INFO] --- maven-dependency-plugin:3.2.0:tree (default-cli) @ m2 ---\",", "                \"[INFO]\",\n                \"[INFO] --- maven-dependency-plugin:3.2.0:tree (default-cli) @ m2 ---\",\n                \"[INFO] internal:m2:jar:1.2\",\n                \"[INFO] +- internal:m1:jar:1.1:compile\",\n                \"[INFO] |  +- external:dependency4:jar:2.4:compile\");\n    }\n\n    @Test\n    void testTreeParsing() {\n        final Map<String, DependencyTree> dependenciesByModule =", "    void testTreeParsing() {\n        final Map<String, DependencyTree> dependenciesByModule =\n                DependencyParser.parseDependencyTreeOutput(getTestDependencyTree());\n\n        assertThat(dependenciesByModule).containsOnlyKeys(\"m1\", \"m2\");\n        assertThat(dependenciesByModule.get(\"m1\").flatten())\n                .containsExactlyInAnyOrder(\n                        Dependency.create(\"external\", \"dependency1\", \"2.1\", null, \"compile\", false),\n                        Dependency.create(\"external\", \"dependency2\", \"2.2\", null, \"compile\", true),\n                        Dependency.create(", "                        Dependency.create(\"external\", \"dependency2\", \"2.2\", null, \"compile\", true),\n                        Dependency.create(\n                                \"external\", \"dependency3\", \"2.3\", null, \"provided\", false),\n                        Dependency.create(\n                                \"external\", \"dependency4\", \"2.4\", \"classifier\", \"compile\", false));\n        assertThat(dependenciesByModule.get(\"m2\").flatten())\n                .containsExactlyInAnyOrder(\n                        Dependency.create(\"internal\", \"m1\", \"1.1\", null, \"compile\", false),\n                        Dependency.create(\n                                \"external\", \"dependency4\", \"2.4\", null, \"compile\", false));", "                        Dependency.create(\n                                \"external\", \"dependency4\", \"2.4\", null, \"compile\", false));\n    }\n\n    @Test\n    void testTreeLineParsingGroupId() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))\n                .hasValueSatisfying(", "                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getGroupId()).isEqualTo(\"external\"));\n    }\n\n    @Test\n    void testTreeLineParsingArtifactId() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))", "                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))\n                .hasValueSatisfying(\n                        dependency ->\n                                assertThat(dependency.getArtifactId()).isEqualTo(\"dependency1\"));\n    }\n\n    @Test\n    void testTreeLineParsingVersion() {\n        assertThat(", "    void testTreeLineParsingVersion() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getVersion()).isEqualTo(\"1.0\"));\n    }\n\n    @Test\n    void testTreeLineParsingScope() {", "    @Test\n    void testTreeLineParsingScope() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:provided\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.getScope()).hasValue(\"provided\"));\n    }\n\n    @Test", "\n    @Test\n    void testTreeLineParsingWithNonJarType() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:pom:1.0:compile\"))\n                .hasValue(\n                        Dependency.create(\n                                \"external\", \"dependency1\", \"1.0\", null, \"compile\", false));\n    }", "                                \"external\", \"dependency1\", \"1.0\", null, \"compile\", false));\n    }\n\n    @Test\n    void testTreeLineParsingWithClassifier() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:some_classifier:1.0:compile\"))\n                .hasValue(\n                        Dependency.create(", "                .hasValue(\n                        Dependency.create(\n                                \"external\",\n                                \"dependency1\",\n                                \"1.0\",\n                                \"some_classifier\",\n                                \"compile\",\n                                false));\n    }\n", "    }\n\n    @Test\n    void testTreeLineParsingWithoutOptional() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.isOptional()).hasValue(false));\n    }", "                        dependency -> assertThat(dependency.isOptional()).hasValue(false));\n    }\n\n    @Test\n    void testTreeLineParsingWithOptional() {\n        assertThat(\n                        DependencyParser.parseTreeDependency(\n                                \"[INFO] +- external:dependency1:jar:1.0:compile (optional)\"))\n                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.isOptional()).hasValue(true));", "                .hasValueSatisfying(\n                        dependency -> assertThat(dependency.isOptional()).hasValue(true));\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/deploy/DeployParserTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.deploy;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n", "import static org.assertj.core.api.Assertions.assertThat;\n\nclass DeployParserTest {\n    @Test\n    void testParseDeployOutputDetectsDeployment() {\n        assertThat(\n                        DeployParser.parseDeployOutput(\n                                Stream.of(\n                                        \"[INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\",\n                                        \"[INFO] \")))", "                                        \"[INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\",\n                                        \"[INFO] \")))\n                .containsExactly(\"paimon-parent\");\n    }\n\n    @Test\n    void testParseDeployOutputDetectsDeploymentWithAltRepository() {\n        assertThat(\n                        DeployParser.parseDeployOutput(\n                                Stream.of(", "                        DeployParser.parseDeployOutput(\n                                Stream.of(\n                                        \"[INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\",\n                                        \"[INFO] Using alternate deployment repository.../tmp/paimon-validation-deployment\")))\n                .containsExactly(\"paimon-parent\");\n    }\n\n    @Test\n    void testParseDeployOutputDetectsSkippedDeployments() {\n        assertThat(", "    void testParseDeployOutputDetectsSkippedDeployments() {\n        assertThat(\n                        DeployParser.parseDeployOutput(\n                                Stream.of(\n                                        \"[INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\",\n                                        \"[INFO] Skipping artifact deployment\")))\n                .isEmpty();\n    }\n}\n", "}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/utils/shared/DependencyTreeTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.shared;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass DependencyTreeTest {\n    private static final Dependency DEPENDENCY =", "class DependencyTreeTest {\n    private static final Dependency DEPENDENCY =\n            Dependency.create(\"groupId\", \"artifactId\", \"version\", null);\n\n    @Test\n    void testDependencyKeyIncludesGroupId() {\n        testDependencyKeyInclusion(\n                Dependency.create(\n                        \"xxx\",\n                        DEPENDENCY.getArtifactId(),", "                        \"xxx\",\n                        DEPENDENCY.getArtifactId(),\n                        DEPENDENCY.getVersion(),\n                        DEPENDENCY.getClassifier().orElse(null)));\n    }\n\n    @Test\n    void testDependencyKeyIncludesArtifactId() {\n        testDependencyKeyInclusion(\n                Dependency.create(", "        testDependencyKeyInclusion(\n                Dependency.create(\n                        DEPENDENCY.getGroupId(),\n                        \"xxx\",\n                        DEPENDENCY.getVersion(),\n                        DEPENDENCY.getClassifier().orElse(null)));\n    }\n\n    @Test\n    void testDependencyKeyIncludesVersion() {", "    @Test\n    void testDependencyKeyIncludesVersion() {\n        testDependencyKeyInclusion(\n                Dependency.create(\n                        DEPENDENCY.getGroupId(),\n                        DEPENDENCY.getArtifactId(),\n                        \"xxx\",\n                        DEPENDENCY.getClassifier().orElse(null)));\n    }\n", "    }\n\n    @Test\n    void testDependencyKeyIncludesClassifier() {\n        testDependencyKeyInclusion(\n                Dependency.create(\n                        DEPENDENCY.getGroupId(),\n                        DEPENDENCY.getArtifactId(),\n                        DEPENDENCY.getVersion(),\n                        \"xxx\"));", "                        DEPENDENCY.getVersion(),\n                        \"xxx\"));\n    }\n\n    private static void testDependencyKeyInclusion(Dependency modifiedDependency) {\n        final DependencyTree dependencyTree = new DependencyTree();\n        dependencyTree.addDirectDependency(DEPENDENCY);\n        dependencyTree.addDirectDependency(modifiedDependency);\n\n        assertThat(dependencyTree.flatten()).containsExactly(DEPENDENCY, modifiedDependency);", "\n        assertThat(dependencyTree.flatten()).containsExactly(DEPENDENCY, modifiedDependency);\n    }\n\n    @Test\n    void testDependencyKeyIgnoresScopeAndOptionalFlag() {\n        final Dependency dependencyWithScopeAndOptionalFlag =\n                Dependency.create(\n                        DEPENDENCY.getGroupId(),\n                        DEPENDENCY.getArtifactId(),", "                        DEPENDENCY.getGroupId(),\n                        DEPENDENCY.getArtifactId(),\n                        DEPENDENCY.getVersion(),\n                        DEPENDENCY.getClassifier().orElse(null),\n                        \"compile\",\n                        true);\n\n        final DependencyTree dependencyTree = new DependencyTree();\n        dependencyTree.addDirectDependency(DEPENDENCY);\n        dependencyTree.addDirectDependency(dependencyWithScopeAndOptionalFlag);", "        dependencyTree.addDirectDependency(DEPENDENCY);\n        dependencyTree.addDirectDependency(dependencyWithScopeAndOptionalFlag);\n\n        assertThat(dependencyTree.flatten()).containsExactly(DEPENDENCY);\n        assertThat(dependencyTree.getPathTo(dependencyWithScopeAndOptionalFlag))\n                .containsExactly(DEPENDENCY);\n    }\n}\n", ""]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/licensecheck/NoticeFileCheckerTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.licensecheck;\n\nimport org.apache.paimon.tools.ci.utils.notice.NoticeContents;\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.util.*;", "import java.io.IOException;\nimport java.util.*;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass NoticeFileCheckerTest {\n    @Test\n    void testRunHappyPath() throws IOException {\n        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);", "        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n        final Set<String> deployedModules = Collections.singleton(moduleName);\n        final Optional<NoticeContents> noticeContents =\n                Optional.of(\n                        new NoticeContents(\n                                moduleName, Collections.singletonList(bundledDependency)));\n", "                                moduleName, Collections.singletonList(bundledDependency)));\n\n        assertThat(\n                        NoticeFileChecker.run(\n                                bundleDependencies,\n                                deployedModules,\n                                Collections.singletonMap(moduleName, noticeContents)))\n                .isEqualTo(0);\n    }\n", "    }\n\n    @Test\n    void testRunRejectsMissingNotice() throws IOException {\n        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n        final Set<String> deployedModules = Collections.singleton(moduleName);\n        final Optional<NoticeContents> missingNotice = Optional.empty();", "        final Set<String> deployedModules = Collections.singleton(moduleName);\n        final Optional<NoticeContents> missingNotice = Optional.empty();\n\n        assertThat(\n                        NoticeFileChecker.run(\n                                bundleDependencies,\n                                deployedModules,\n                                Collections.singletonMap(moduleName, missingNotice)))\n                .isEqualTo(1);\n    }", "                .isEqualTo(1);\n    }\n\n    @Test\n    void testRunRejectsIncorrectNotice() throws IOException {\n        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n        final Set<String> deployedModules = Collections.singleton(moduleName);", "        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n        final Set<String> deployedModules = Collections.singleton(moduleName);\n        final Optional<NoticeContents> emptyNotice =\n                Optional.of(new NoticeContents(moduleName, Collections.emptyList()));\n\n        assertThat(\n                        NoticeFileChecker.run(\n                                bundleDependencies,\n                                deployedModules,\n                                Collections.singletonMap(moduleName, emptyNotice)))", "                                deployedModules,\n                                Collections.singletonMap(moduleName, emptyNotice)))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRunSkipsNonDeployedModules() throws IOException {\n        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();", "        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n        final Set<String> deployedModules = Collections.emptySet();\n        // this would usually be a problem, but since the module is not deployed it's OK!\n        final Optional<NoticeContents> emptyNotice =\n                Optional.of(new NoticeContents(moduleName, Collections.emptyList()));\n\n        assertThat(\n                        NoticeFileChecker.run(", "        assertThat(\n                        NoticeFileChecker.run(\n                                bundleDependencies,\n                                deployedModules,\n                                Collections.singletonMap(moduleName, emptyNotice)))\n                .isEqualTo(0);\n    }\n\n    @Test\n    void testRunIncludesBundledNonDeployedModules() throws IOException {", "    @Test\n    void testRunIncludesBundledNonDeployedModules() throws IOException {\n        final Map<String, Set<Dependency>> bundledDependencies = new HashMap<>();\n        final Map<String, Optional<NoticeContents>> notices = new HashMap<>();\n\n        // a module that is not deployed but bundles another dependency with an empty NOTICE\n        final String nonDeployedModuleName = \"nonDeployed\";\n        final Dependency nonDeployedDependency =\n                Dependency.create(\"a\", nonDeployedModuleName, \"c\", null);\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);", "                Dependency.create(\"a\", nonDeployedModuleName, \"c\", null);\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        bundledDependencies.put(nonDeployedModuleName, Collections.singleton(bundledDependency));\n        // this would usually not be a problem, but since the module is not bundled it's not OK!\n        final Optional<NoticeContents> emptyNotice =\n                Optional.of(new NoticeContents(nonDeployedModuleName, Collections.emptyList()));\n        notices.put(nonDeployedModuleName, emptyNotice);\n\n        // a module that is deploys and bundles the above\n        final String bundlingModule = \"bundling\";", "        // a module that is deploys and bundles the above\n        final String bundlingModule = \"bundling\";\n        bundledDependencies.put(bundlingModule, Collections.singleton(nonDeployedDependency));\n        final Optional<NoticeContents> correctNotice =\n                Optional.of(\n                        new NoticeContents(\n                                bundlingModule, Collections.singletonList(nonDeployedDependency)));\n        notices.put(bundlingModule, correctNotice);\n\n        final Set<String> deployedModules = Collections.singleton(bundlingModule);", "\n        final Set<String> deployedModules = Collections.singleton(bundlingModule);\n\n        assertThat(NoticeFileChecker.run(bundledDependencies, deployedModules, notices))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testCheckNoticeFileHappyPath() {\n        final String moduleName = \"test\";", "    void testCheckNoticeFileHappyPath() {\n        final String moduleName = \"test\";\n        final Dependency bundledDependency = Dependency.create(\"a\", \"b\", \"c\", null);\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(moduleName, Collections.singleton(bundledDependency));\n\n        assertThat(\n                        NoticeFileChecker.checkNoticeFile(\n                                bundleDependencies,\n                                moduleName,", "                                bundleDependencies,\n                                moduleName,\n                                new NoticeContents(\n                                        moduleName, Collections.singletonList(bundledDependency))))\n                .isEmpty();\n    }\n\n    @Test\n    void testCheckNoticeFileRejectsEmptyFile() {\n        assertThat(NoticeFileChecker.checkNoticeFile(Collections.emptyMap(), \"test\", null))", "    void testCheckNoticeFileRejectsEmptyFile() {\n        assertThat(NoticeFileChecker.checkNoticeFile(Collections.emptyMap(), \"test\", null))\n                .containsOnlyKeys(NoticeFileChecker.Severity.CRITICAL);\n    }\n\n    @Test\n    void testCheckNoticeFileToleratesModuleNameMismatch() {\n        final String moduleName = \"test\";\n\n        assertThat(", "\n        assertThat(\n                        NoticeFileChecker.checkNoticeFile(\n                                Collections.emptyMap(),\n                                moduleName,\n                                new NoticeContents(moduleName + \"2\", Collections.emptyList())))\n                .containsOnlyKeys(NoticeFileChecker.Severity.TOLERATED);\n    }\n\n    @Test", "\n    @Test\n    void testCheckNoticeFileRejectsDuplicateLine() {\n        final String moduleName = \"test\";\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(\n                moduleName, Collections.singleton(Dependency.create(\"a\", \"b\", \"c\", null)));\n\n        assertThat(\n                        NoticeFileChecker.checkNoticeFile(", "        assertThat(\n                        NoticeFileChecker.checkNoticeFile(\n                                bundleDependencies,\n                                moduleName,\n                                new NoticeContents(\n                                        moduleName,\n                                        Arrays.asList(\n                                                Dependency.create(\"a\", \"b\", \"c\", null),\n                                                Dependency.create(\"a\", \"b\", \"c\", null)))))\n                .containsOnlyKeys(NoticeFileChecker.Severity.CRITICAL);", "                                                Dependency.create(\"a\", \"b\", \"c\", null)))))\n                .containsOnlyKeys(NoticeFileChecker.Severity.CRITICAL);\n    }\n\n    @Test\n    void testCheckNoticeFileRejectsMissingDependency() {\n        final String moduleName = \"test\";\n        final Map<String, Set<Dependency>> bundleDependencies = new HashMap<>();\n        bundleDependencies.put(\n                moduleName, Collections.singleton(Dependency.create(\"a\", \"b\", \"c\", null)));", "        bundleDependencies.put(\n                moduleName, Collections.singleton(Dependency.create(\"a\", \"b\", \"c\", null)));\n\n        assertThat(\n                        NoticeFileChecker.checkNoticeFile(\n                                bundleDependencies,\n                                moduleName,\n                                new NoticeContents(moduleName, Collections.emptyList())))\n                .containsOnlyKeys(NoticeFileChecker.Severity.CRITICAL);\n    }", "                .containsOnlyKeys(NoticeFileChecker.Severity.CRITICAL);\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/test/java/org/apache/paimon/tools/ci/licensecheck/JarFileCheckerTest.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.licensecheck;", "\npackage org.apache.paimon.tools.ci.licensecheck;\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.net.URI;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;", "import java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;", "import java.util.Map;\nimport java.util.UUID;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for the {@link JarFileChecker}.\n *\n * <p>For dev purposes, generate a deploy-directory with: mvn clean deploy\n * -DaltDeploymentRepository=snapshot-repo::default::file:/tmp/paimon-deployment -DskipTests", " * <p>For dev purposes, generate a deploy-directory with: mvn clean deploy\n * -DaltDeploymentRepository=snapshot-repo::default::file:/tmp/paimon-deployment -DskipTests\n * -Drat.skip and add a test checking that directory.\n */\nclass JarFileCheckerTest {\n\n    private static final List<String> VALID_NOTICE_PATH = Arrays.asList(\"META-INF\", \"NOTICE\");\n    private static final List<String> VALID_LICENSE_PATH = Arrays.asList(\"META-INF\", \"LICENSE\");\n\n    @Test", "\n    @Test\n    void testValidJarAccepted(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))", "                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))\n                .isEqualTo(0);\n    }\n\n    @Test\n    void testRejectedOnMissingNoticeFile(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(", "                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRejectedOnInvalidNoticeFile(@TempDir Path tempDir) throws Exception {", "    @Test\n    void testRejectedOnInvalidNoticeFile(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(INVALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))\n                .isEqualTo(1);", "                                                VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRejectedOnNoticeFileInRoot(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,", "                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_NOTICE_CONTENTS,\n                                                Arrays.asList(\"some_custom_notice\")))))\n                .isEqualTo(1);\n    }\n", "    }\n\n    @Test\n    void testRejectedOnMissingLicenseFile(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH))))\n                .isEqualTo(1);", "                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRejectedOnInvalidLicenseFile(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,", "                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(\n                                                INVALID_LICENSE_CONTENTS, VALID_LICENSE_PATH))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRejectedOnLicenseFileInRoot(@TempDir Path tempDir) throws Exception {", "    @Test\n    void testRejectedOnLicenseFileInRoot(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS,", "                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS,\n                                                Arrays.asList(\"some_custom_license\")))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testRejectedOnLicenseFileInSomeDirectory(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(", "        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS,\n                                                Arrays.asList(\n                                                        \"some\",", "                                                Arrays.asList(\n                                                        \"some\",\n                                                        \"directory\",\n                                                        \"some_custom_license\")))))\n                .isEqualTo(1);\n    }\n\n    @Disabled(\n            \"Currently not checked, but we may want to enforce this in the future to reduce ambiguity.\")\n    void testRejectedOnAdditionalLicenseFileInMetaInf(@TempDir Path tempDir) throws Exception {", "            \"Currently not checked, but we may want to enforce this in the future to reduce ambiguity.\")\n    void testRejectedOnAdditionalLicenseFileInMetaInf(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS,", "                                        Entry.fileEntry(\n                                                VALID_LICENSE_CONTENTS,\n                                                Arrays.asList(\"META-INF\", \"LICENSE.txt\")))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testIgnoreLicenseDirectories(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(", "        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.directoryEntry(\n                                                Arrays.asList(\"some\", \"license\", \"directory\")))))\n                .isEqualTo(0);\n    }", "                .isEqualTo(0);\n    }\n\n    @Test\n    void testIgnoreClassFiles(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),", "                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                \"content\",\n                                                Arrays.asList(\"SomeLicenseClass.class\")))))\n                .isEqualTo(0);\n    }\n\n    @Test", "\n    @Test\n    void testIgnoreFtlFiles(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(", "                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                \"content\", Arrays.asList(\"SomeLicenseFile.ftl\")))))\n                .isEqualTo(0);\n    }\n\n    @Test\n    void testIgnoreWebThirdPartyLicenses(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(", "        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                \"class contents\",\n                                                Arrays.asList(\"web\", \"3rdpartylicenses.txt\")))))\n                .isEqualTo(0);", "                                                Arrays.asList(\"web\", \"3rdpartylicenses.txt\")))))\n                .isEqualTo(0);\n    }\n\n    @Test\n    void testForbiddenLGPLongTextDetected(@TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,", "                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                \"some GNU Lesser General public License text\",\n                                                Collections.singletonList(\"some_file.txt\")))))\n                .isEqualTo(1);\n    }\n\n    @Test\n    void testForbiddenLGPMultiLineLongTextWithCommentAndLeadingWhitespaceDetected(\n            @TempDir Path tempDir) throws Exception {\n        assertThat(\n                        JarFileChecker.checkJar(\n                                createJar(\n                                        tempDir,\n                                        Entry.fileEntry(VALID_NOTICE_CONTENTS, VALID_NOTICE_PATH),\n                                        Entry.fileEntry(VALID_LICENSE_CONTENTS, VALID_LICENSE_PATH),\n                                        Entry.fileEntry(\n                                                \"some GNU Lesser General public \\n\\t\\t//#License text\",\n                                                Collections.singletonList(\"some_file.txt\")))))\n                .isEqualTo(1);\n    }\n", "    private static class Entry {\n        final String contents;\n        final List<String> path;\n        final boolean isDirectory;\n\n        public static Entry directoryEntry(List<String> path) {\n            return new Entry(\"\", path, true);\n        }\n\n        public static Entry fileEntry(String contents, List<String> path) {\n            return new Entry(contents, path, false);\n        }\n\n        private Entry(String contents, List<String> path, boolean isDirectory) {\n            this.contents = contents;\n            this.path = path;\n            this.isDirectory = isDirectory;\n        }\n    }\n\n    private static Path createJar(Path tempDir, Entry... entries) throws Exception {\n        final Path path = tempDir.resolve(UUID.randomUUID().toString() + \".jar\");\n\n        final URI uriWithoutScheme = path.toUri();\n\n        final URI uri =\n                new URI(\n                        \"jar:file\",\n                        uriWithoutScheme.getHost(),\n                        uriWithoutScheme.getPath(),\n                        uriWithoutScheme.getFragment());\n\n        // causes FileSystems#newFileSystem to automatically create a valid zip file\n        // this is easier than manually creating a valid empty zip file manually\n        final Map<String, String> env = new HashMap<>();\n        env.put(\"create\", \"true\");\n\n        try (FileSystem zip = FileSystems.newFileSystem(uri, env)) {\n            // shortcut to getting the single root\n            final Path root = zip.getPath(\"\").toAbsolutePath();", "        public static Entry fileEntry(String contents, List<String> path) {\n            return new Entry(contents, path, false);\n        }\n\n        private Entry(String contents, List<String> path, boolean isDirectory) {\n            this.contents = contents;\n            this.path = path;\n            this.isDirectory = isDirectory;\n        }\n    }\n\n    private static Path createJar(Path tempDir, Entry... entries) throws Exception {\n        final Path path = tempDir.resolve(UUID.randomUUID().toString() + \".jar\");\n\n        final URI uriWithoutScheme = path.toUri();\n\n        final URI uri =\n                new URI(\n                        \"jar:file\",\n                        uriWithoutScheme.getHost(),\n                        uriWithoutScheme.getPath(),\n                        uriWithoutScheme.getFragment());\n\n        // causes FileSystems#newFileSystem to automatically create a valid zip file\n        // this is easier than manually creating a valid empty zip file manually\n        final Map<String, String> env = new HashMap<>();\n        env.put(\"create\", \"true\");\n\n        try (FileSystem zip = FileSystems.newFileSystem(uri, env)) {\n            // shortcut to getting the single root\n            final Path root = zip.getPath(\"\").toAbsolutePath();", "            for (Entry entry : entries) {\n                final Path zipPath =\n                        root.resolve(\n                                zip.getPath(\n                                        entry.path.get(0),\n                                        entry.path\n                                                .subList(1, entry.path.size())\n                                                .toArray(new String[] {})));\n                if (entry.isDirectory) {\n                    Files.createDirectories(zipPath);\n                } else {\n                    Files.createDirectories(zipPath.getParent());\n                    Files.write(zipPath, entry.contents.getBytes());\n                }\n            }\n        }\n        return path;\n    }\n\n    private static final String INVALID_NOTICE_CONTENTS = \"\" + \"invalid\";\n\n    private static final String VALID_NOTICE_CONTENTS =\n            \"\"\n                    + \"Paimon : SomeModule\\n\"\n                    + \"Copyright 2014-2020 The Apache Software Foundation\\n\"\n                    + \"\\n\"\n                    + \"This product includes software developed at\\n\"\n                    + \"The Apache Software Foundation (http://www.apache.org/).\";\n\n    private static final String INVALID_LICENSE_CONTENTS = \"\" + \"invalid\";\n\n    private static final String VALID_LICENSE_CONTENTS =\n            \"\"\n                    + \"\\n\"\n                    + \"                                 Apache License\\n\"\n                    + \"                           Version 2.0, January 2004\\n\"\n                    + \"                        http://www.apache.org/licenses/\\n\"\n                    + \"\\n\"\n                    + \"   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\\n\"\n                    + \"\\n\"\n                    + \"   1. Definitions.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"License\\\" shall mean the terms and conditions for use, reproduction,\\n\"\n                    + \"      and distribution as defined by Sections 1 through 9 of this document.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Licensor\\\" shall mean the copyright owner or entity authorized by\\n\"\n                    + \"      the copyright owner that is granting the License.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Legal Entity\\\" shall mean the union of the acting entity and all\\n\"\n                    + \"      other entities that control, are controlled by, or are under common\\n\"\n                    + \"      control with that entity. For the purposes of this definition,\\n\"\n                    + \"      \\\"control\\\" means (i) the power, direct or indirect, to cause the\\n\"\n                    + \"      direction or management of such entity, whether by contract or\\n\"\n                    + \"      otherwise, or (ii) ownership of fifty percent (50%) or more of the\\n\"\n                    + \"      outstanding shares, or (iii) beneficial ownership of such entity.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"You\\\" (or \\\"Your\\\") shall mean an individual or Legal Entity\\n\"\n                    + \"      exercising permissions granted by this License.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Source\\\" form shall mean the preferred form for making modifications,\\n\"\n                    + \"      including but not limited to software source code, documentation\\n\"\n                    + \"      source, and configuration files.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Object\\\" form shall mean any form resulting from mechanical\\n\"\n                    + \"      transformation or translation of a Source form, including but\\n\"\n                    + \"      not limited to compiled object code, generated documentation,\\n\"\n                    + \"      and conversions to other media types.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Work\\\" shall mean the work of authorship, whether in Source or\\n\"\n                    + \"      Object form, made available under the License, as indicated by a\\n\"\n                    + \"      copyright notice that is included in or attached to the work\\n\"\n                    + \"      (an example is provided in the Appendix below).\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Derivative Works\\\" shall mean any work, whether in Source or Object\\n\"\n                    + \"      form, that is based on (or derived from) the Work and for which the\\n\"\n                    + \"      editorial revisions, annotations, elaborations, or other modifications\\n\"\n                    + \"      represent, as a whole, an original work of authorship. For the purposes\\n\"\n                    + \"      of this License, Derivative Works shall not include works that remain\\n\"\n                    + \"      separable from, or merely link (or bind by name) to the interfaces of,\\n\"\n                    + \"      the Work and Derivative Works thereof.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Contribution\\\" shall mean any work of authorship, including\\n\"\n                    + \"      the original version of the Work and any modifications or additions\\n\"\n                    + \"      to that Work or Derivative Works thereof, that is intentionally\\n\"\n                    + \"      submitted to Licensor for inclusion in the Work by the copyright owner\\n\"\n                    + \"      or by an individual or Legal Entity authorized to submit on behalf of\\n\"\n                    + \"      the copyright owner. For the purposes of this definition, \\\"submitted\\\"\\n\"\n                    + \"      means any form of electronic, verbal, or written communication sent\\n\"\n                    + \"      to the Licensor or its representatives, including but not limited to\\n\"\n                    + \"      communication on electronic mailing lists, source code control systems,\\n\"\n                    + \"      and issue tracking systems that are managed by, or on behalf of, the\\n\"\n                    + \"      Licensor for the purpose of discussing and improving the Work, but\\n\"\n                    + \"      excluding communication that is conspicuously marked or otherwise\\n\"\n                    + \"      designated in writing by the copyright owner as \\\"Not a Contribution.\\\"\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Contributor\\\" shall mean Licensor and any individual or Legal Entity\\n\"\n                    + \"      on behalf of whom a Contribution has been received by Licensor and\\n\"\n                    + \"      subsequently incorporated within the Work.\\n\"\n                    + \"\\n\"\n                    + \"   2. Grant of Copyright License. Subject to the terms and conditions of\\n\"\n                    + \"      this License, each Contributor hereby grants to You a perpetual,\\n\"\n                    + \"      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n\"\n                    + \"      copyright license to reproduce, prepare Derivative Works of,\\n\"\n                    + \"      publicly display, publicly perform, sublicense, and distribute the\\n\"\n                    + \"      Work and such Derivative Works in Source or Object form.\\n\"\n                    + \"\\n\"\n                    + \"   3. Grant of Patent License. Subject to the terms and conditions of\\n\"\n                    + \"      this License, each Contributor hereby grants to You a perpetual,\\n\"\n                    + \"      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n\"\n                    + \"      (except as stated in this section) patent license to make, have made,\\n\"\n                    + \"      use, offer to sell, sell, import, and otherwise transfer the Work,\\n\"\n                    + \"      where such license applies only to those patent claims licensable\\n\"\n                    + \"      by such Contributor that are necessarily infringed by their\\n\"\n                    + \"      Contribution(s) alone or by combination of their Contribution(s)\\n\"\n                    + \"      with the Work to which such Contribution(s) was submitted. If You\\n\"\n                    + \"      institute patent litigation against any entity (including a\\n\"\n                    + \"      cross-claim or counterclaim in a lawsuit) alleging that the Work\\n\"\n                    + \"      or a Contribution incorporated within the Work constitutes direct\\n\"\n                    + \"      or contributory patent infringement, then any patent licenses\\n\"\n                    + \"      granted to You under this License for that Work shall terminate\\n\"\n                    + \"      as of the date such litigation is filed.\\n\"\n                    + \"\\n\"\n                    + \"   4. Redistribution. You may reproduce and distribute copies of the\\n\"\n                    + \"      Work or Derivative Works thereof in any medium, with or without\\n\"\n                    + \"      modifications, and in Source or Object form, provided that You\\n\"\n                    + \"      meet the following conditions:\\n\"\n                    + \"\\n\"\n                    + \"      (a) You must give any other recipients of the Work or\\n\"\n                    + \"          Derivative Works a copy of this License; and\\n\"\n                    + \"\\n\"\n                    + \"      (b) You must cause any modified files to carry prominent notices\\n\"\n                    + \"          stating that You changed the files; and\\n\"\n                    + \"\\n\"\n                    + \"      (c) You must retain, in the Source form of any Derivative Works\\n\"\n                    + \"          that You distribute, all copyright, patent, trademark, and\\n\"\n                    + \"          attribution notices from the Source form of the Work,\\n\"\n                    + \"          excluding those notices that do not pertain to any part of\\n\"\n                    + \"          the Derivative Works; and\\n\"\n                    + \"\\n\"\n                    + \"      (d) If the Work includes a \\\"NOTICE\\\" text file as part of its\\n\"\n                    + \"          distribution, then any Derivative Works that You distribute must\\n\"\n                    + \"          include a readable copy of the attribution notices contained\\n\"\n                    + \"          within such NOTICE file, excluding those notices that do not\\n\"\n                    + \"          pertain to any part of the Derivative Works, in at least one\\n\"\n                    + \"          of the following places: within a NOTICE text file distributed\\n\"\n                    + \"          as part of the Derivative Works; within the Source form or\\n\"\n                    + \"          documentation, if provided along with the Derivative Works; or,\\n\"\n                    + \"          within a display generated by the Derivative Works, if and\\n\"\n                    + \"          wherever such third-party notices normally appear. The contents\\n\"\n                    + \"          of the NOTICE file are for informational purposes only and\\n\"\n                    + \"          do not modify the License. You may add Your own attribution\\n\"\n                    + \"          notices within Derivative Works that You distribute, alongside\\n\"\n                    + \"          or as an addendum to the NOTICE text from the Work, provided\\n\"\n                    + \"          that such additional attribution notices cannot be construed\\n\"\n                    + \"          as modifying the License.\\n\"\n                    + \"\\n\"\n                    + \"      You may add Your own copyright statement to Your modifications and\\n\"\n                    + \"      may provide additional or different license terms and conditions\\n\"\n                    + \"      for use, reproduction, or distribution of Your modifications, or\\n\"\n                    + \"      for any such Derivative Works as a whole, provided Your use,\\n\"\n                    + \"      reproduction, and distribution of the Work otherwise complies with\\n\"\n                    + \"      the conditions stated in this License.\\n\"\n                    + \"\\n\"\n                    + \"   5. Submission of Contributions. Unless You explicitly state otherwise,\\n\"\n                    + \"      any Contribution intentionally submitted for inclusion in the Work\\n\"\n                    + \"      by You to the Licensor shall be under the terms and conditions of\\n\"\n                    + \"      this License, without any additional terms or conditions.\\n\"\n                    + \"      Notwithstanding the above, nothing herein shall supersede or modify\\n\"\n                    + \"      the terms of any separate license agreement you may have executed\\n\"\n                    + \"      with Licensor regarding such Contributions.\\n\"\n                    + \"\\n\"\n                    + \"   6. Trademarks. This License does not grant permission to use the trade\\n\"\n                    + \"      names, trademarks, service marks, or product names of the Licensor,\\n\"\n                    + \"      except as required for reasonable and customary use in describing the\\n\"\n                    + \"      origin of the Work and reproducing the content of the NOTICE file.\\n\"\n                    + \"\\n\"\n                    + \"   7. Disclaimer of Warranty. Unless required by applicable law or\\n\"\n                    + \"      agreed to in writing, Licensor provides the Work (and each\\n\"\n                    + \"      Contributor provides its Contributions) on an \\\"AS IS\\\" BASIS,\\n\"\n                    + \"      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\\n\"\n                    + \"      implied, including, without limitation, any warranties or conditions\\n\"\n                    + \"      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\\n\"\n                    + \"      PARTICULAR PURPOSE. You are solely responsible for determining the\\n\"\n                    + \"      appropriateness of using or redistributing the Work and assume any\\n\"\n                    + \"      risks associated with Your exercise of permissions under this License.\\n\"\n                    + \"\\n\"\n                    + \"   8. Limitation of Liability. In no event and under no legal theory,\\n\"\n                    + \"      whether in tort (including negligence), contract, or otherwise,\\n\"\n                    + \"      unless required by applicable law (such as deliberate and grossly\\n\"\n                    + \"      negligent acts) or agreed to in writing, shall any Contributor be\\n\"\n                    + \"      liable to You for damages, including any direct, indirect, special,\\n\"\n                    + \"      incidental, or consequential damages of any character arising as a\\n\"\n                    + \"      result of this License or out of the use or inability to use the\\n\"\n                    + \"      Work (including but not limited to damages for loss of goodwill,\\n\"\n                    + \"      work stoppage, computer failure or malfunction, or any and all\\n\"\n                    + \"      other commercial damages or losses), even if such Contributor\\n\"\n                    + \"      has been advised of the possibility of such damages.\\n\"\n                    + \"\\n\"\n                    + \"   9. Accepting Warranty or Additional Liability. While redistributing\\n\"\n                    + \"      the Work or Derivative Works thereof, You may choose to offer,\\n\"\n                    + \"      and charge a fee for, acceptance of support, warranty, indemnity,\\n\"\n                    + \"      or other liability obligations and/or rights consistent with this\\n\"\n                    + \"      License. However, in accepting such obligations, You may act only\\n\"\n                    + \"      on Your own behalf and on Your sole responsibility, not on behalf\\n\"\n                    + \"      of any other Contributor, and only if You agree to indemnify,\\n\"\n                    + \"      defend, and hold each Contributor harmless for any liability\\n\"\n                    + \"      incurred by, or claims asserted against, such Contributor by reason\\n\"\n                    + \"      of your accepting any such warranty or additional liability.\\n\"\n                    + \"\\n\"\n                    + \"   END OF TERMS AND CONDITIONS\\n\"\n                    + \"\\n\"\n                    + \"   APPENDIX: How to apply the Apache License to your work.\\n\"\n                    + \"\\n\"\n                    + \"      To apply the Apache License to your work, attach the following\\n\"\n                    + \"      boilerplate notice, with the fields enclosed by brackets \\\"[]\\\"\\n\"\n                    + \"      replaced with your own identifying information. (Don't include\\n\"\n                    + \"      the brackets!)  The text should be enclosed in the appropriate\\n\"\n                    + \"      comment syntax for the file format. We also recommend that a\\n\"\n                    + \"      file or class name and description of purpose be included on the\\n\"\n                    + \"      same \\\"printed page\\\" as the copyright notice for easier\\n\"\n                    + \"      identification within third-party archives.\\n\"\n                    + \"\\n\"\n                    + \"   Copyright [yyyy] [name of copyright owner]\\n\"\n                    + \"\\n\"\n                    + \"   Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\"\n                    + \"   you may not use this file except in compliance with the License.\\n\"\n                    + \"   You may obtain a copy of the License at\\n\"\n                    + \"\\n\"\n                    + \"       http://www.apache.org/licenses/LICENSE-2.0\\n\"\n                    + \"\\n\"\n                    + \"   Unless required by applicable law or agreed to in writing, software\\n\"\n                    + \"   distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\"\n                    + \"   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\"\n                    + \"   See the License for the specific language governing permissions and\\n\"\n                    + \"   limitations under the License.\\n\";\n}\n", "                if (entry.isDirectory) {\n                    Files.createDirectories(zipPath);\n                } else {\n                    Files.createDirectories(zipPath.getParent());\n                    Files.write(zipPath, entry.contents.getBytes());\n                }\n            }\n        }\n        return path;\n    }\n\n    private static final String INVALID_NOTICE_CONTENTS = \"\" + \"invalid\";\n\n    private static final String VALID_NOTICE_CONTENTS =\n            \"\"\n                    + \"Paimon : SomeModule\\n\"\n                    + \"Copyright 2014-2020 The Apache Software Foundation\\n\"\n                    + \"\\n\"\n                    + \"This product includes software developed at\\n\"\n                    + \"The Apache Software Foundation (http://www.apache.org/).\";\n\n    private static final String INVALID_LICENSE_CONTENTS = \"\" + \"invalid\";\n\n    private static final String VALID_LICENSE_CONTENTS =\n            \"\"\n                    + \"\\n\"\n                    + \"                                 Apache License\\n\"\n                    + \"                           Version 2.0, January 2004\\n\"\n                    + \"                        http://www.apache.org/licenses/\\n\"\n                    + \"\\n\"\n                    + \"   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\\n\"\n                    + \"\\n\"\n                    + \"   1. Definitions.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"License\\\" shall mean the terms and conditions for use, reproduction,\\n\"\n                    + \"      and distribution as defined by Sections 1 through 9 of this document.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Licensor\\\" shall mean the copyright owner or entity authorized by\\n\"\n                    + \"      the copyright owner that is granting the License.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Legal Entity\\\" shall mean the union of the acting entity and all\\n\"\n                    + \"      other entities that control, are controlled by, or are under common\\n\"\n                    + \"      control with that entity. For the purposes of this definition,\\n\"\n                    + \"      \\\"control\\\" means (i) the power, direct or indirect, to cause the\\n\"\n                    + \"      direction or management of such entity, whether by contract or\\n\"\n                    + \"      otherwise, or (ii) ownership of fifty percent (50%) or more of the\\n\"\n                    + \"      outstanding shares, or (iii) beneficial ownership of such entity.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"You\\\" (or \\\"Your\\\") shall mean an individual or Legal Entity\\n\"\n                    + \"      exercising permissions granted by this License.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Source\\\" form shall mean the preferred form for making modifications,\\n\"\n                    + \"      including but not limited to software source code, documentation\\n\"\n                    + \"      source, and configuration files.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Object\\\" form shall mean any form resulting from mechanical\\n\"\n                    + \"      transformation or translation of a Source form, including but\\n\"\n                    + \"      not limited to compiled object code, generated documentation,\\n\"\n                    + \"      and conversions to other media types.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Work\\\" shall mean the work of authorship, whether in Source or\\n\"\n                    + \"      Object form, made available under the License, as indicated by a\\n\"\n                    + \"      copyright notice that is included in or attached to the work\\n\"\n                    + \"      (an example is provided in the Appendix below).\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Derivative Works\\\" shall mean any work, whether in Source or Object\\n\"\n                    + \"      form, that is based on (or derived from) the Work and for which the\\n\"\n                    + \"      editorial revisions, annotations, elaborations, or other modifications\\n\"\n                    + \"      represent, as a whole, an original work of authorship. For the purposes\\n\"\n                    + \"      of this License, Derivative Works shall not include works that remain\\n\"\n                    + \"      separable from, or merely link (or bind by name) to the interfaces of,\\n\"\n                    + \"      the Work and Derivative Works thereof.\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Contribution\\\" shall mean any work of authorship, including\\n\"\n                    + \"      the original version of the Work and any modifications or additions\\n\"\n                    + \"      to that Work or Derivative Works thereof, that is intentionally\\n\"\n                    + \"      submitted to Licensor for inclusion in the Work by the copyright owner\\n\"\n                    + \"      or by an individual or Legal Entity authorized to submit on behalf of\\n\"\n                    + \"      the copyright owner. For the purposes of this definition, \\\"submitted\\\"\\n\"\n                    + \"      means any form of electronic, verbal, or written communication sent\\n\"\n                    + \"      to the Licensor or its representatives, including but not limited to\\n\"\n                    + \"      communication on electronic mailing lists, source code control systems,\\n\"\n                    + \"      and issue tracking systems that are managed by, or on behalf of, the\\n\"\n                    + \"      Licensor for the purpose of discussing and improving the Work, but\\n\"\n                    + \"      excluding communication that is conspicuously marked or otherwise\\n\"\n                    + \"      designated in writing by the copyright owner as \\\"Not a Contribution.\\\"\\n\"\n                    + \"\\n\"\n                    + \"      \\\"Contributor\\\" shall mean Licensor and any individual or Legal Entity\\n\"\n                    + \"      on behalf of whom a Contribution has been received by Licensor and\\n\"\n                    + \"      subsequently incorporated within the Work.\\n\"\n                    + \"\\n\"\n                    + \"   2. Grant of Copyright License. Subject to the terms and conditions of\\n\"\n                    + \"      this License, each Contributor hereby grants to You a perpetual,\\n\"\n                    + \"      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n\"\n                    + \"      copyright license to reproduce, prepare Derivative Works of,\\n\"\n                    + \"      publicly display, publicly perform, sublicense, and distribute the\\n\"\n                    + \"      Work and such Derivative Works in Source or Object form.\\n\"\n                    + \"\\n\"\n                    + \"   3. Grant of Patent License. Subject to the terms and conditions of\\n\"\n                    + \"      this License, each Contributor hereby grants to You a perpetual,\\n\"\n                    + \"      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n\"\n                    + \"      (except as stated in this section) patent license to make, have made,\\n\"\n                    + \"      use, offer to sell, sell, import, and otherwise transfer the Work,\\n\"\n                    + \"      where such license applies only to those patent claims licensable\\n\"\n                    + \"      by such Contributor that are necessarily infringed by their\\n\"\n                    + \"      Contribution(s) alone or by combination of their Contribution(s)\\n\"\n                    + \"      with the Work to which such Contribution(s) was submitted. If You\\n\"\n                    + \"      institute patent litigation against any entity (including a\\n\"\n                    + \"      cross-claim or counterclaim in a lawsuit) alleging that the Work\\n\"\n                    + \"      or a Contribution incorporated within the Work constitutes direct\\n\"\n                    + \"      or contributory patent infringement, then any patent licenses\\n\"\n                    + \"      granted to You under this License for that Work shall terminate\\n\"\n                    + \"      as of the date such litigation is filed.\\n\"\n                    + \"\\n\"\n                    + \"   4. Redistribution. You may reproduce and distribute copies of the\\n\"\n                    + \"      Work or Derivative Works thereof in any medium, with or without\\n\"\n                    + \"      modifications, and in Source or Object form, provided that You\\n\"\n                    + \"      meet the following conditions:\\n\"\n                    + \"\\n\"\n                    + \"      (a) You must give any other recipients of the Work or\\n\"\n                    + \"          Derivative Works a copy of this License; and\\n\"\n                    + \"\\n\"\n                    + \"      (b) You must cause any modified files to carry prominent notices\\n\"\n                    + \"          stating that You changed the files; and\\n\"\n                    + \"\\n\"\n                    + \"      (c) You must retain, in the Source form of any Derivative Works\\n\"\n                    + \"          that You distribute, all copyright, patent, trademark, and\\n\"\n                    + \"          attribution notices from the Source form of the Work,\\n\"\n                    + \"          excluding those notices that do not pertain to any part of\\n\"\n                    + \"          the Derivative Works; and\\n\"\n                    + \"\\n\"\n                    + \"      (d) If the Work includes a \\\"NOTICE\\\" text file as part of its\\n\"\n                    + \"          distribution, then any Derivative Works that You distribute must\\n\"\n                    + \"          include a readable copy of the attribution notices contained\\n\"\n                    + \"          within such NOTICE file, excluding those notices that do not\\n\"\n                    + \"          pertain to any part of the Derivative Works, in at least one\\n\"\n                    + \"          of the following places: within a NOTICE text file distributed\\n\"\n                    + \"          as part of the Derivative Works; within the Source form or\\n\"\n                    + \"          documentation, if provided along with the Derivative Works; or,\\n\"\n                    + \"          within a display generated by the Derivative Works, if and\\n\"\n                    + \"          wherever such third-party notices normally appear. The contents\\n\"\n                    + \"          of the NOTICE file are for informational purposes only and\\n\"\n                    + \"          do not modify the License. You may add Your own attribution\\n\"\n                    + \"          notices within Derivative Works that You distribute, alongside\\n\"\n                    + \"          or as an addendum to the NOTICE text from the Work, provided\\n\"\n                    + \"          that such additional attribution notices cannot be construed\\n\"\n                    + \"          as modifying the License.\\n\"\n                    + \"\\n\"\n                    + \"      You may add Your own copyright statement to Your modifications and\\n\"\n                    + \"      may provide additional or different license terms and conditions\\n\"\n                    + \"      for use, reproduction, or distribution of Your modifications, or\\n\"\n                    + \"      for any such Derivative Works as a whole, provided Your use,\\n\"\n                    + \"      reproduction, and distribution of the Work otherwise complies with\\n\"\n                    + \"      the conditions stated in this License.\\n\"\n                    + \"\\n\"\n                    + \"   5. Submission of Contributions. Unless You explicitly state otherwise,\\n\"\n                    + \"      any Contribution intentionally submitted for inclusion in the Work\\n\"\n                    + \"      by You to the Licensor shall be under the terms and conditions of\\n\"\n                    + \"      this License, without any additional terms or conditions.\\n\"\n                    + \"      Notwithstanding the above, nothing herein shall supersede or modify\\n\"\n                    + \"      the terms of any separate license agreement you may have executed\\n\"\n                    + \"      with Licensor regarding such Contributions.\\n\"\n                    + \"\\n\"\n                    + \"   6. Trademarks. This License does not grant permission to use the trade\\n\"\n                    + \"      names, trademarks, service marks, or product names of the Licensor,\\n\"\n                    + \"      except as required for reasonable and customary use in describing the\\n\"\n                    + \"      origin of the Work and reproducing the content of the NOTICE file.\\n\"\n                    + \"\\n\"\n                    + \"   7. Disclaimer of Warranty. Unless required by applicable law or\\n\"\n                    + \"      agreed to in writing, Licensor provides the Work (and each\\n\"\n                    + \"      Contributor provides its Contributions) on an \\\"AS IS\\\" BASIS,\\n\"\n                    + \"      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\\n\"\n                    + \"      implied, including, without limitation, any warranties or conditions\\n\"\n                    + \"      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\\n\"\n                    + \"      PARTICULAR PURPOSE. You are solely responsible for determining the\\n\"\n                    + \"      appropriateness of using or redistributing the Work and assume any\\n\"\n                    + \"      risks associated with Your exercise of permissions under this License.\\n\"\n                    + \"\\n\"\n                    + \"   8. Limitation of Liability. In no event and under no legal theory,\\n\"\n                    + \"      whether in tort (including negligence), contract, or otherwise,\\n\"\n                    + \"      unless required by applicable law (such as deliberate and grossly\\n\"\n                    + \"      negligent acts) or agreed to in writing, shall any Contributor be\\n\"\n                    + \"      liable to You for damages, including any direct, indirect, special,\\n\"\n                    + \"      incidental, or consequential damages of any character arising as a\\n\"\n                    + \"      result of this License or out of the use or inability to use the\\n\"\n                    + \"      Work (including but not limited to damages for loss of goodwill,\\n\"\n                    + \"      work stoppage, computer failure or malfunction, or any and all\\n\"\n                    + \"      other commercial damages or losses), even if such Contributor\\n\"\n                    + \"      has been advised of the possibility of such damages.\\n\"\n                    + \"\\n\"\n                    + \"   9. Accepting Warranty or Additional Liability. While redistributing\\n\"\n                    + \"      the Work or Derivative Works thereof, You may choose to offer,\\n\"\n                    + \"      and charge a fee for, acceptance of support, warranty, indemnity,\\n\"\n                    + \"      or other liability obligations and/or rights consistent with this\\n\"\n                    + \"      License. However, in accepting such obligations, You may act only\\n\"\n                    + \"      on Your own behalf and on Your sole responsibility, not on behalf\\n\"\n                    + \"      of any other Contributor, and only if You agree to indemnify,\\n\"\n                    + \"      defend, and hold each Contributor harmless for any liability\\n\"\n                    + \"      incurred by, or claims asserted against, such Contributor by reason\\n\"\n                    + \"      of your accepting any such warranty or additional liability.\\n\"\n                    + \"\\n\"\n                    + \"   END OF TERMS AND CONDITIONS\\n\"\n                    + \"\\n\"\n                    + \"   APPENDIX: How to apply the Apache License to your work.\\n\"\n                    + \"\\n\"\n                    + \"      To apply the Apache License to your work, attach the following\\n\"\n                    + \"      boilerplate notice, with the fields enclosed by brackets \\\"[]\\\"\\n\"\n                    + \"      replaced with your own identifying information. (Don't include\\n\"\n                    + \"      the brackets!)  The text should be enclosed in the appropriate\\n\"\n                    + \"      comment syntax for the file format. We also recommend that a\\n\"\n                    + \"      file or class name and description of purpose be included on the\\n\"\n                    + \"      same \\\"printed page\\\" as the copyright notice for easier\\n\"\n                    + \"      identification within third-party archives.\\n\"\n                    + \"\\n\"\n                    + \"   Copyright [yyyy] [name of copyright owner]\\n\"\n                    + \"\\n\"\n                    + \"   Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\"\n                    + \"   you may not use this file except in compliance with the License.\\n\"\n                    + \"   You may obtain a copy of the License at\\n\"\n                    + \"\\n\"\n                    + \"       http://www.apache.org/licenses/LICENSE-2.0\\n\"\n                    + \"\\n\"\n                    + \"   Unless required by applicable law or agreed to in writing, software\\n\"\n                    + \"   distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\"\n                    + \"   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\"\n                    + \"   See the License for the specific language governing permissions and\\n\"\n                    + \"   limitations under the License.\\n\";\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/notice/NoticeParser.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.notice;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n", "import java.util.regex.Pattern;\n\n/** Parsing utils for NOTICE files. */\npublic class NoticeParser {\n\n    // \"- org.apache.htrace:htrace-core:3.1.0-incubating\"\n    private static final Pattern NOTICE_DEPENDENCY_PATTERN =\n            Pattern.compile(\n                    \"- \"\n                            + \"(?<groupId>[^ ]*?):\"\n                            + \"(?<artifactId>[^ ]*?):\"\n                            + \"(?:(?<classifier>[^ ]*?):)?\"\n                            + \"(?<version>[^ ]*?)\"\n                            + \"($| )\");\n    // \"This project bundles \"net.jcip:jcip-annotations:1.0\".\n    private static final Pattern NOTICE_BUNDLES_DEPENDENCY_PATTERN =\n            Pattern.compile(\n                    \".*bundles \\\"\"\n                            + \"(?<groupId>[^ ]*?):\"\n                            + \"(?<artifactId>[^ ]*?):\"\n                            + \"(?:(?<classifier>[^ ]*?):)?\"\n                            + \"(?<version>[^ ]*?)\"\n                            + \"\\\".*\");\n", "    public static Optional<NoticeContents> parseNoticeFile(Path noticeFile) throws IOException {\n        // 1st line contains module name\n        final List<String> noticeContents = Files.readAllLines(noticeFile);\n\n        return parseNoticeFile(noticeContents);\n    }\n\n    @VisibleForTesting\n    static Optional<NoticeContents> parseNoticeFile(List<String> noticeContents) {\n        if (noticeContents.isEmpty()) {\n            return Optional.empty();\n        }\n\n        final String noticeModuleName = noticeContents.get(0);\n\n        Collection<Dependency> declaredDependencies = new ArrayList<>();", "        if (noticeContents.isEmpty()) {\n            return Optional.empty();\n        }\n\n        final String noticeModuleName = noticeContents.get(0);\n\n        Collection<Dependency> declaredDependencies = new ArrayList<>();\n        for (String line : noticeContents) {\n            Optional<Dependency> dependency = tryParsing(NOTICE_DEPENDENCY_PATTERN, line);\n            if (!dependency.isPresent()) {\n                dependency = tryParsing(NOTICE_BUNDLES_DEPENDENCY_PATTERN, line);\n            }\n            dependency.ifPresent(declaredDependencies::add);\n        }\n\n        return Optional.of(new NoticeContents(noticeModuleName, declaredDependencies));\n    }\n\n    private static Optional<Dependency> tryParsing(Pattern pattern, String line) {\n        Matcher matcher = pattern.matcher(line);", "            if (!dependency.isPresent()) {\n                dependency = tryParsing(NOTICE_BUNDLES_DEPENDENCY_PATTERN, line);\n            }\n            dependency.ifPresent(declaredDependencies::add);\n        }\n\n        return Optional.of(new NoticeContents(noticeModuleName, declaredDependencies));\n    }\n\n    private static Optional<Dependency> tryParsing(Pattern pattern, String line) {\n        Matcher matcher = pattern.matcher(line);", "        if (matcher.find()) {\n            String groupId = matcher.group(\"groupId\");\n            String artifactId = matcher.group(\"artifactId\");\n            String version = matcher.group(\"version\");\n            String classifier = matcher.group(\"classifier\");\n            return Optional.of(Dependency.create(groupId, artifactId, version, classifier));\n        }\n        return Optional.empty();\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/notice/NoticeContents.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.notice;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport java.util.Collection;\n\n/** Represents the parsed contents of a NOTICE file. */\npublic class NoticeContents {\n    private final String noticeModuleName;\n    private final Collection<Dependency> declaredDependencies;\n\n    public NoticeContents(String noticeModuleName, Collection<Dependency> declaredDependencies) {\n        this.noticeModuleName = noticeModuleName;\n        this.declaredDependencies = declaredDependencies;\n    }\n", "/** Represents the parsed contents of a NOTICE file. */\npublic class NoticeContents {\n    private final String noticeModuleName;\n    private final Collection<Dependency> declaredDependencies;\n\n    public NoticeContents(String noticeModuleName, Collection<Dependency> declaredDependencies) {\n        this.noticeModuleName = noticeModuleName;\n        this.declaredDependencies = declaredDependencies;\n    }\n\n    public String getNoticeModuleName() {\n        return noticeModuleName;\n    }\n\n    public Collection<Dependency> getDeclaredDependencies() {\n        return declaredDependencies;\n    }\n}\n", "    public String getNoticeModuleName() {\n        return noticeModuleName;\n    }\n\n    public Collection<Dependency> getDeclaredDependencies() {\n        return declaredDependencies;\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/shade/ShadeParser.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.shade;", "\npackage org.apache.paimon.tools.ci.utils.shade;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\nimport org.apache.paimon.tools.ci.utils.shared.ParserUtils;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;", "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\n/** Utils for parsing the shade-plugin output. */\npublic final class ShadeParser {\n\n    private static final Pattern SHADE_NEXT_MODULE_PATTERN =\n            Pattern.compile(\n                    \".*:shade \\\\((?:shade-paimon|shade-dist|default)\\\\) @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    private static final Pattern SHADE_INCLUDE_MODULE_PATTERN =\n            Pattern.compile(\n                    \".* \"\n                            + \"(?<groupId>.*?):\"\n                            + \"(?<artifactId>.*?):\"\n                            + \"(?<type>.*?):\"\n                            + \"(?:(?<classifier>.*?):)?\"\n                            + \"(?<version>.*?)\"\n                            + \" in the shaded jar\");\n\n    /**\n     * Parses the output of a Maven build where {@code shade:shade} was used, and returns a set of\n     * bundled dependencies for each module.\n     *\n     * <p>The returned dependencies will NEVER contain the scope or optional flag.\n     *\n     * <p>This method only considers the {@code shade-paimon} and {@code shade-dist} executions,\n     * because all artifacts we produce that are either published or referenced are created by these\n     * executions. In other words, all artifacts from other executions are only used internally by\n     * the module that created them.\n     */", "    public static Map<String, Set<Dependency>> parseShadeOutput(Path buildOutput)\n            throws IOException {\n        try (Stream<String> lines = Files.lines(buildOutput)) {\n            return parseShadeOutput(lines);\n        }\n    }\n\n    @VisibleForTesting\n    static Map<String, Set<Dependency>> parseShadeOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                lines.filter(line -> !line.contains(\" Excluding \")),\n                SHADE_NEXT_MODULE_PATTERN,\n                ShadeParser::parseBlock);\n    }\n\n    private static Set<Dependency> parseBlock(Iterator<String> block) {\n        final Set<Dependency> dependencies = new LinkedHashSet<>();\n\n        Optional<Dependency> parsedDependency = parseDependency(block.next());", "        while (parsedDependency.isPresent()) {\n            dependencies.add(parsedDependency.get());\n\n            if (block.hasNext()) {\n                parsedDependency = parseDependency(block.next());\n            } else {\n                parsedDependency = Optional.empty();\n            }\n        }\n\n        return dependencies;\n    }\n\n    @VisibleForTesting\n    static Optional<Dependency> parseDependency(String line) {\n        Matcher dependencyMatcher = SHADE_INCLUDE_MODULE_PATTERN.matcher(line);", "        if (!dependencyMatcher.find()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(\n                Dependency.create(\n                        dependencyMatcher.group(\"groupId\"),\n                        dependencyMatcher.group(\"artifactId\"),\n                        dependencyMatcher.group(\"version\"),\n                        dependencyMatcher.group(\"classifier\")));\n    }\n\n    private ShadeParser() {}\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/dependency/DependencyParser.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.dependency;", "\npackage org.apache.paimon.tools.ci.utils.dependency;\n\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\nimport org.apache.paimon.tools.ci.utils.shared.DependencyTree;\nimport org.apache.paimon.tools.ci.utils.shared.ParserUtils;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.Stack;", "import java.util.Set;\nimport java.util.Stack;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\n/** Parsing utils for the Maven dependency plugin. */\npublic class DependencyParser {\n\n    private static final Pattern DEPENDENCY_COPY_NEXT_MODULE_PATTERN =\n            Pattern.compile(\n                    \".*maven-dependency-plugin:[^:]+:copy .* @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    private static final Pattern DEPENDENCY_TREE_NEXT_MODULE_PATTERN =\n            Pattern.compile(\n                    \".*maven-dependency-plugin:[^:]+:tree .* @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    /** See {@link DependencyParserTreeTest} for examples. */\n    private static final Pattern DEPENDENCY_TREE_ITEM_PATTERN =\n            Pattern.compile(\n                    \".* +\"\n                            + \"(?<groupId>.*?):\"\n                            + \"(?<artifactId>.*?):\"\n                            + \"(?<type>.*?):\"\n                            + \"(?:(?<classifier>.*?):)?\"\n                            + \"(?<version>.*?):\"\n                            + \"(?<scope>[^ ]*)\"\n                            + \"(?<optional> \\\\(optional\\\\))?\");\n\n    /** See {@link DependencyParserCopyTest} for examples. */\n    private static final Pattern DEPENDENCY_COPY_ITEM_PATTERN =\n            Pattern.compile(\n                    \".* Configured Artifact: +\"\n                            + \"(?<groupId>.*?):\"\n                            + \"(?<artifactId>.*?):\"\n                            + \"(?:(?<classifier>.*?):)?\"\n                            + \"(?<version>.*?):\"\n                            + \"(?:\\\\?:)?\" // unknown cause; e.g.: javax.xml.bind:jaxb-api:?:jar\n                            + \"(?<type>.*)\");\n\n    /**\n     * Parses the output of a Maven build where {@code dependency:copy} was used, and returns a set\n     * of copied dependencies for each module.\n     *\n     * <p>The returned dependencies will NEVER contain the scope or optional flag.\n     */", "public class DependencyParser {\n\n    private static final Pattern DEPENDENCY_COPY_NEXT_MODULE_PATTERN =\n            Pattern.compile(\n                    \".*maven-dependency-plugin:[^:]+:copy .* @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    private static final Pattern DEPENDENCY_TREE_NEXT_MODULE_PATTERN =\n            Pattern.compile(\n                    \".*maven-dependency-plugin:[^:]+:tree .* @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    /** See {@link DependencyParserTreeTest} for examples. */\n    private static final Pattern DEPENDENCY_TREE_ITEM_PATTERN =\n            Pattern.compile(\n                    \".* +\"\n                            + \"(?<groupId>.*?):\"\n                            + \"(?<artifactId>.*?):\"\n                            + \"(?<type>.*?):\"\n                            + \"(?:(?<classifier>.*?):)?\"\n                            + \"(?<version>.*?):\"\n                            + \"(?<scope>[^ ]*)\"\n                            + \"(?<optional> \\\\(optional\\\\))?\");\n\n    /** See {@link DependencyParserCopyTest} for examples. */\n    private static final Pattern DEPENDENCY_COPY_ITEM_PATTERN =\n            Pattern.compile(\n                    \".* Configured Artifact: +\"\n                            + \"(?<groupId>.*?):\"\n                            + \"(?<artifactId>.*?):\"\n                            + \"(?:(?<classifier>.*?):)?\"\n                            + \"(?<version>.*?):\"\n                            + \"(?:\\\\?:)?\" // unknown cause; e.g.: javax.xml.bind:jaxb-api:?:jar\n                            + \"(?<type>.*)\");\n\n    /**\n     * Parses the output of a Maven build where {@code dependency:copy} was used, and returns a set\n     * of copied dependencies for each module.\n     *\n     * <p>The returned dependencies will NEVER contain the scope or optional flag.\n     */", "    public static Map<String, Set<Dependency>> parseDependencyCopyOutput(Path buildOutput)\n            throws IOException {\n        return processLines(buildOutput, DependencyParser::parseDependencyCopyOutput);\n    }\n\n    /**\n     * Parses the output of a Maven build where {@code dependency:tree} was used, and returns a set\n     * of dependencies for each module.\n     */\n    public static Map<String, DependencyTree> parseDependencyTreeOutput(Path buildOutput)\n            throws IOException {\n        return processLines(buildOutput, DependencyParser::parseDependencyTreeOutput);\n    }\n\n    private static <X> X processLines(Path buildOutput, Function<Stream<String>, X> processor)\n            throws IOException {\n        try (Stream<String> lines = Files.lines(buildOutput)) {\n            return processor.apply(lines.filter(line -> line.contains(\"[INFO]\")));\n        }\n    }\n\n    @VisibleForTesting\n    static Map<String, Set<Dependency>> parseDependencyCopyOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                lines,\n                DEPENDENCY_COPY_NEXT_MODULE_PATTERN,\n                DependencyParser::parseCopyDependencyBlock);\n    }\n\n    @VisibleForTesting\n    static Map<String, DependencyTree> parseDependencyTreeOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                lines,\n                DEPENDENCY_TREE_NEXT_MODULE_PATTERN,\n                DependencyParser::parseTreeDependencyBlock);\n    }\n\n    private static Set<Dependency> parseCopyDependencyBlock(Iterator<String> block) {\n        final Set<Dependency> dependencies = new LinkedHashSet<>();\n\n        Optional<Dependency> parsedDependency = parseCopyDependency(block.next());", "    public static Map<String, DependencyTree> parseDependencyTreeOutput(Path buildOutput)\n            throws IOException {\n        return processLines(buildOutput, DependencyParser::parseDependencyTreeOutput);\n    }\n\n    private static <X> X processLines(Path buildOutput, Function<Stream<String>, X> processor)\n            throws IOException {\n        try (Stream<String> lines = Files.lines(buildOutput)) {\n            return processor.apply(lines.filter(line -> line.contains(\"[INFO]\")));\n        }\n    }\n\n    @VisibleForTesting\n    static Map<String, Set<Dependency>> parseDependencyCopyOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                lines,\n                DEPENDENCY_COPY_NEXT_MODULE_PATTERN,\n                DependencyParser::parseCopyDependencyBlock);\n    }\n\n    @VisibleForTesting\n    static Map<String, DependencyTree> parseDependencyTreeOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                lines,\n                DEPENDENCY_TREE_NEXT_MODULE_PATTERN,\n                DependencyParser::parseTreeDependencyBlock);\n    }\n\n    private static Set<Dependency> parseCopyDependencyBlock(Iterator<String> block) {\n        final Set<Dependency> dependencies = new LinkedHashSet<>();\n\n        Optional<Dependency> parsedDependency = parseCopyDependency(block.next());", "        while (parsedDependency.isPresent()) {\n            dependencies.add(parsedDependency.get());\n\n            if (block.hasNext()) {\n                parsedDependency = parseCopyDependency(block.next());\n            } else {\n                parsedDependency = Optional.empty();\n            }\n        }\n\n        return dependencies;\n    }\n\n    private static DependencyTree parseTreeDependencyBlock(Iterator<String> block) {\n        // discard one line, which only contains the current module name\n        block.next();\n", "        if (!block.hasNext()) {\n            throw new IllegalStateException(\"Expected more output from the dependency-plugin.\");\n        }\n\n        final DependencyTree dependencies = new DependencyTree();\n\n        final Stack<Dependency> parentStack = new Stack<>();\n        final Stack<Integer> treeDepthStack = new Stack<>();\n        String line = block.next();\n        Optional<Dependency> parsedDependency = parseTreeDependency(line);\n        while (parsedDependency.isPresent()) {\n            int treeDepth = getDepth(line);\n", "        while (parsedDependency.isPresent()) {\n            int treeDepth = getDepth(line);\n\n            while (!treeDepthStack.isEmpty() && treeDepth <= treeDepthStack.peek()) {\n                parentStack.pop();\n                treeDepthStack.pop();\n            }\n\n            final Dependency dependency = parsedDependency.get();\n\n            if (parentStack.isEmpty()) {\n                dependencies.addDirectDependency(dependency);\n            } else {\n                dependencies.addTransitiveDependencyTo(dependency, parentStack.peek());\n            }\n", "            if (parentStack.isEmpty()) {\n                dependencies.addDirectDependency(dependency);\n            } else {\n                dependencies.addTransitiveDependencyTo(dependency, parentStack.peek());\n            }\n\n            if (treeDepthStack.isEmpty() || treeDepth > treeDepthStack.peek()) {\n                treeDepthStack.push(treeDepth);\n                parentStack.push(dependency);\n            }\n", "            if (block.hasNext()) {\n                line = block.next();\n                parsedDependency = parseTreeDependency(line);\n            } else {\n                parsedDependency = Optional.empty();\n            }\n        }\n\n        return dependencies;\n    }\n\n    static Optional<Dependency> parseCopyDependency(String line) {\n        Matcher dependencyMatcher = DEPENDENCY_COPY_ITEM_PATTERN.matcher(line);", "        if (!dependencyMatcher.find()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(\n                Dependency.create(\n                        dependencyMatcher.group(\"groupId\"),\n                        dependencyMatcher.group(\"artifactId\"),\n                        dependencyMatcher.group(\"version\"),\n                        dependencyMatcher.group(\"classifier\")));\n    }\n\n    @VisibleForTesting\n    static Optional<Dependency> parseTreeDependency(String line) {\n        Matcher dependencyMatcher = DEPENDENCY_TREE_ITEM_PATTERN.matcher(line);", "        if (!dependencyMatcher.find()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(\n                Dependency.create(\n                        dependencyMatcher.group(\"groupId\"),\n                        dependencyMatcher.group(\"artifactId\"),\n                        dependencyMatcher.group(\"version\"),\n                        dependencyMatcher.group(\"classifier\"),\n                        dependencyMatcher.group(\"scope\"),\n                        dependencyMatcher.group(\"optional\") != null));\n    }\n\n    /**\n     * The depths returned by this method do NOT return a continuous sequence.\n     *\n     * <pre>\n     * +- org.apache.paimon:...\n     * |  +- org.apache.paimon:...\n     * |  |  \\- org.apache.paimon:...\n     * ...\n     * </pre>\n     */\n    private static int getDepth(String line) {\n        final int level = line.indexOf('+');", "        if (level != -1) {\n            return level;\n        }\n        return line.indexOf('\\\\');\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/deploy/DeployParser.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.utils.deploy;\n\nimport org.apache.paimon.tools.ci.utils.shared.ParserUtils;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.IOException;", "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n", "import java.util.stream.Stream;\n\n/** Parsing utils for the Maven deploy plugin. */\npublic class DeployParser {\n\n    // Examples:\n    //\n    // Deployment on CI with alternative repo\n    // [INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\n    // [INFO] Using alternate deployment repository.../tmp/paimon-validation-deployment\n    //\n    // Skipped deployment:\n    // [INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ paimon-parent ---\n    // [INFO] Skipping artifact deployment\n    private static final Pattern DEPLOY_MODULE_PATTERN =\n            Pattern.compile(\n                    \".maven-deploy-plugin:.*:deploy .* @ (?<module>[^ _]+)(?:_[0-9.]+)? --.*\");\n\n    /**\n     * Parses the output of a Maven build where {@code deploy:deploy} was used, and returns a set of\n     * deployed modules.\n     */", "    public static Set<String> parseDeployOutput(File buildResult) throws IOException {\n        try (Stream<String> linesStream = Files.lines(buildResult.toPath())) {\n            return parseDeployOutput(linesStream);\n        }\n    }\n\n    @VisibleForTesting\n    static Set<String> parseDeployOutput(Stream<String> lines) {\n        return ParserUtils.parsePluginOutput(\n                        lines, DEPLOY_MODULE_PATTERN, DeployParser::parseDeployBlock)\n                .entrySet().stream()\n                .filter(Map.Entry::getValue)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toSet());\n    }\n\n    private static boolean parseDeployBlock(Iterator<String> block) {\n        return block.hasNext() && !block.next().contains(\"Skipping artifact deployment\");\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/shared/ParserUtils.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.shared;", "\npackage org.apache.paimon.tools.ci.utils.shared;\n\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;", "import java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\n/** Parsing utils. */\npublic class ParserUtils {\n\n    /**\n     * Iterates over the given lines, identifying plugin execution blocks with the given pattern and\n     * parses the plugin output with the given parser.\n     *\n     * <p>This method assumes that the given pattern matches at most once for each module.\n     *\n     * <p>The given pattern must include a {@code module} group that captures the module that the\n     * plugin runs on (without the scala suffix!).\n     *\n     * @param lines maven output lines\n     * @param executionLinePattern pattern that matches plugin executions\n     * @param blockParser parser for the plugin block\n     * @return map containing the parser result for each module\n     * @param <D> block parser output\n     */\n    public static <D> Map<String, D> parsePluginOutput(\n            Stream<String> lines,\n            Pattern executionLinePattern,\n            Function<Iterator<String>, D> blockParser) {\n        final Map<String, D> result = new LinkedHashMap<>();\n\n        final Iterator<String> iterator = lines.iterator();\n", "        while (iterator.hasNext()) {\n            Matcher moduleMatcher = executionLinePattern.matcher(iterator.next());\n            while (!moduleMatcher.find()) {\n                if (iterator.hasNext()) {\n                    moduleMatcher = executionLinePattern.matcher(iterator.next());\n                } else {\n                    return result;\n                }\n            }\n            final String currentModule = moduleMatcher.group(\"module\");\n", "            if (!iterator.hasNext()) {\n                throw new IllegalStateException(\"Expected more output from the plugin.\");\n            }\n\n            result.put(currentModule, blockParser.apply(iterator));\n        }\n        return result;\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/shared/Dependency.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.shared;", "\npackage org.apache.paimon.tools.ci.utils.shared;\n\nimport javax.annotation.Nullable;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * Represents a dependency.\n *", " * Represents a dependency.\n *\n * <p>For some properties we return an {@link Optional}, for those that, depending on the plugin\n * goal, may not be determinable. For example, {@code dependency:copy} never prints the scope or\n * optional flag.\n */\npublic final class Dependency {\n\n    private final String groupId;\n    private final String artifactId;\n    private final String version;\n    @Nullable private final String classifier;\n    @Nullable private final String scope;\n    @Nullable private final Boolean isOptional;\n\n    private Dependency(\n            String groupId,\n            String artifactId,\n            String version,\n            @Nullable String classifier,\n            @Nullable String scope,\n            @Nullable Boolean isOptional) {\n        this.groupId = Objects.requireNonNull(groupId);\n        this.artifactId = Objects.requireNonNull(artifactId);\n        this.version = Objects.requireNonNull(version);\n        this.classifier = classifier;\n        this.scope = scope;\n        this.isOptional = isOptional;\n    }\n", "    public static Dependency create(\n            String groupId,\n            String artifactId,\n            String version,\n            String classifier,\n            String scope,\n            boolean isOptional) {\n        return new Dependency(\n                groupId,\n                artifactId,\n                version,\n                classifier,\n                Objects.requireNonNull(scope),\n                isOptional);\n    }\n", "    public static Dependency create(\n            String groupId, String artifactId, String version, String classifier) {\n        return new Dependency(groupId, artifactId, version, classifier, null, null);\n    }\n\n    public String getGroupId() {\n        return groupId;\n    }\n\n    public String getArtifactId() {\n        return artifactId;\n    }\n", "    public String getArtifactId() {\n        return artifactId;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public Optional<String> getClassifier() {\n        return Optional.ofNullable(classifier);\n    }\n\n    public Optional<String> getScope() {\n        return Optional.ofNullable(scope);\n    }\n\n    public Optional<Boolean> isOptional() {\n        return Optional.ofNullable(isOptional);\n    }\n\n    @Override", "    public String toString() {\n        return groupId\n                + \":\"\n                + artifactId\n                + \":\"\n                + version\n                + (classifier != null ? \":\" + classifier : \"\")\n                + (scope != null ? \":\" + scope : \"\")\n                + (isOptional != null && isOptional ? \" (optional)\" : \"\");\n    }\n\n    @Override", "    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Dependency that = (Dependency) o;\n        return Objects.equals(groupId, that.groupId)\n                && Objects.equals(artifactId, that.artifactId)\n                && Objects.equals(version, that.version)\n                && Objects.equals(classifier, that.classifier)\n                && Objects.equals(scope, that.scope)\n                && Objects.equals(isOptional, that.isOptional);\n    }\n\n    @Override", "    public int hashCode() {\n        return Objects.hash(groupId, artifactId, version, classifier, scope, isOptional);\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/utils/shared/DependencyTree.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.utils.shared;", "\npackage org.apache.paimon.tools.ci.utils.shared;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.graph.Traverser;\n\nimport javax.annotation.Nullable;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;", "import java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Represents a dependency tree.\n *", " * Represents a dependency tree.\n *\n * <p>Every dependency can only occur exactly once.\n */\npublic class DependencyTree {\n\n    private final Map<String, Node> lookup = new LinkedHashMap<>();\n    private final List<Node> directDependencies = new ArrayList<>();\n\n    public void addDirectDependency(Dependency dependency) {\n        final String key = getKey(dependency);", "    public void addDirectDependency(Dependency dependency) {\n        final String key = getKey(dependency);\n        if (lookup.containsKey(key)) {\n            return;\n        }\n        final Node node = new Node(dependency, null);\n\n        lookup.put(key, node);\n        directDependencies.add(node);\n    }\n", "    public void addTransitiveDependencyTo(Dependency transitiveDependency, Dependency parent) {\n        final String key = getKey(transitiveDependency);\n        if (lookup.containsKey(key)) {\n            return;\n        }\n        final Node node = lookup.get(getKey(parent)).addTransitiveDependency(transitiveDependency);\n\n        lookup.put(key, node);\n    }\n\n    private static final class Node {\n        private final Dependency dependency;\n        @Nullable private final Node parent;\n        private final List<Node> children = new ArrayList<>();\n\n        private Node(Dependency dependency, @Nullable Node parent) {\n            this.dependency = dependency;\n            this.parent = parent;\n        }\n", "        public Node addTransitiveDependency(Dependency dependency) {\n            final Node node = new Node(dependency, this);\n            this.children.add(node);\n            return node;\n        }\n\n        private boolean isRoot() {\n            return parent == null;\n        }\n    }\n\n    public List<Dependency> getPathTo(Dependency dependency) {\n        final LinkedList<Dependency> path = new LinkedList<>();\n\n        Node node = lookup.get(getKey(dependency));\n        path.addFirst(node.dependency);", "        while (!node.isRoot()) {\n            node = node.parent;\n            path.addFirst(node.dependency);\n        }\n\n        return path;\n    }\n\n    public Stream<Dependency> flatten() {\n        return StreamSupport.stream(\n                        Traverser.<Node>forTree(node -> node.children)\n                                .depthFirstPreOrder(directDependencies)\n                                .spliterator(),\n                        false)\n                .map(node -> node.dependency);\n    }\n\n    /**\n     * We don't use the {@link Dependency} as a key because we don't want lookups to be dependent on\n     * scope or the optional flag.\n     *\n     * @param dependency\n     * @return\n     */\n    @VisibleForTesting\n    static String getKey(Dependency dependency) {\n        return dependency.getGroupId()\n                + \":\"\n                + dependency.getArtifactId()\n                + \":\"\n                + dependency.getVersion()\n                + \":\"\n                + dependency.getClassifier().orElse(\"(no-classifier)\");\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/suffixcheck/ScalaSuffixChecker.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *", " *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.paimon.tools.ci.suffixcheck;", "\npackage org.apache.paimon.tools.ci.suffixcheck;\n\nimport org.apache.paimon.tools.ci.utils.dependency.DependencyParser;\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\nimport org.apache.paimon.tools.ci.utils.shared.DependencyTree;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n", "import org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;", "import java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n", "import java.util.stream.Stream;\n\n/** Utility for checking the presence/absence of scala-suffixes. */\npublic class ScalaSuffixChecker {\n    private static final Logger LOG = LoggerFactory.getLogger(ScalaSuffixChecker.class);\n\n    // [INFO] --- maven-dependency-plugin:3.1.1:tree (default-cli) @ paimon-annotations ---\n    private static final Pattern moduleNamePattern =\n            Pattern.compile(\".* --- maven-dependency-plugin.* @ (.*) ---.*\");\n\n    // [INFO] +- junit:junit:jar:4.13.2:test\n    // [INFO] |  \\- org.hamcrest:hamcrest-core:jar:1.3:test\n    // [INFO] \\- org.apache.logging.log4j:log4j-1.2-api:jar:2.14.1:test\n    private static final Pattern blockPattern = Pattern.compile(\".* [+|\\\\\\\\].*\");\n\n    // [INFO] +- org.scala-lang:scala-reflect:jar:2.11.12:test\n    private static final Pattern scalaSuffixPattern = Pattern.compile(\"_2.1[0-9]\");\n\n    private static final Set<String> EXCLUDED_MODULES =\n            new HashSet<>(\n                    Arrays.asList());\n", "    public static void main(String[] args) throws IOException {\n        if (args.length < 2) {\n            System.out.println(\"Usage: ScalaSuffixChecker <pathMavenBuildOutput> <pathPaimonRoot>\");\n            System.exit(1);\n        }\n\n        final Path mavenOutputPath = Paths.get(args[0]);\n        final Path paimonRootPath = Paths.get(args[1]);\n\n        final ParseResult parseResult = parseMavenOutput(mavenOutputPath);\n        if (parseResult.getCleanModules().isEmpty()) {\n            LOG.error(\"Parsing found 0 scala-free modules; the parsing is likely broken.\");\n            System.exit(1);\n        }", "        if (parseResult.getCleanModules().isEmpty()) {\n            LOG.error(\"Parsing found 0 scala-free modules; the parsing is likely broken.\");\n            System.exit(1);\n        }\n        if (parseResult.getInfectedModules().isEmpty()) {\n            LOG.error(\"Parsing found 0 scala-dependent modules; the parsing is likely broken.\");\n            System.exit(1);\n        }\n\n        final Collection<String> violations = checkScalaSuffixes(parseResult, paimonRootPath);\n", "        if (!violations.isEmpty()) {\n            LOG.error(\n                    \"Violations found:{}\",\n                    violations.stream().collect(Collectors.joining(\"\\n\\t\", \"\\n\\t\", \"\")));\n            System.exit(1);\n        }\n    }\n\n    private static ParseResult parseMavenOutput(final Path path) throws IOException {\n        final Set<String> cleanModules = new HashSet<>();\n        final Set<String> infectedModules = new HashSet<>();\n\n        final Map<String, DependencyTree> dependenciesByModule =\n                DependencyParser.parseDependencyTreeOutput(path);\n", "        for (String module : dependenciesByModule.keySet()) {\n            final String moduleName = stripScalaSuffix(module);\n            if (isExcluded(moduleName)) {\n                continue;\n            }\n            LOG.trace(\"Processing module '{}'.\", moduleName);\n\n            final List<Dependency> dependencies =\n                    dependenciesByModule.get(module).flatten().collect(Collectors.toList());\n\n            boolean infected = false;", "            for (Dependency dependency : dependencies) {\n                final boolean dependsOnScala = dependsOnScala(dependency);\n                final boolean isTestDependency = dependency.getScope().get().equals(\"test\");\n                final boolean isExcluded = isExcluded(dependency.getArtifactId());\n                LOG.trace(\"\\tdependency:{}\", dependency);\n                LOG.trace(\"\\t\\tdepends-on-scala:{}\", dependsOnScala);\n                LOG.trace(\"\\t\\tis-test-dependency:{}\", isTestDependency);\n                LOG.trace(\"\\t\\tis-excluded:{}\", isExcluded);\n                if (dependsOnScala && !isTestDependency && !isExcluded) {\n                    LOG.trace(\"\\t\\tOutbreak detected at {}!\", moduleName);\n                    infected = true;\n                }\n            }\n", "                if (dependsOnScala && !isTestDependency && !isExcluded) {\n                    LOG.trace(\"\\t\\tOutbreak detected at {}!\", moduleName);\n                    infected = true;\n                }\n            }\n\n            if (infected) {\n                infectedModules.add(moduleName);\n            } else {\n                cleanModules.add(moduleName);\n            }\n        }\n\n        return new ParseResult(cleanModules, infectedModules);\n    }\n\n    private static String stripScalaSuffix(final String moduleName) {\n        final int i = moduleName.indexOf(\"_2.\");\n        return i > 0 ? moduleName.substring(0, i) : moduleName;\n    }\n\n    private static boolean dependsOnScala(final Dependency dependency) {\n        return dependency.getGroupId().contains(\"org.scala-lang\")\n                || scalaSuffixPattern.matcher(dependency.getArtifactId()).find();\n    }\n\n    private static Collection<String> checkScalaSuffixes(\n            final ParseResult parseResult, Path paimonRootPath) throws IOException {\n        final Collection<String> violations = new ArrayList<>();\n\n        // exclude e2e modules and paimon-docs for convenience as they\n        // a) are not deployed during a release\n        // b) exist only for dev purposes\n        // c) no-one should depend on them\n        final Collection<String> excludedModules = new ArrayList<>();\n        excludedModules.add(\"paimon-docs\");\n        excludedModules.addAll(getEndToEndTestModules(paimonRootPath));\n", "        for (String excludedModule : excludedModules) {\n            parseResult.getCleanModules().remove(excludedModule);\n            parseResult.getInfectedModules().remove(excludedModule);\n        }\n\n        violations.addAll(checkCleanModules(parseResult.getCleanModules(), paimonRootPath));\n        violations.addAll(checkInfectedModules(parseResult.getInfectedModules(), paimonRootPath));\n\n        return violations;\n    }\n\n    private static Collection<String> getEndToEndTestModules(Path paimonRootPath)\n            throws IOException {\n        try (Stream<Path> pathStream =\n                Files.walk(paimonRootPath.resolve(\"paimon-e2e-tests\"), 5)) {\n            return pathStream\n                    .filter(path -> path.getFileName().toString().equals(\"pom.xml\"))\n                    .map(path -> path.getParent().getFileName().toString())\n                    .collect(Collectors.toList());\n        }\n    }\n\n    private static Collection<String> checkCleanModules(\n            Collection<String> modules, Path paimonRootPath) throws IOException {\n        return checkModules(\n                modules,\n                paimonRootPath,\n                \"_${scala.binary.version}\",\n                \"Scala-free module '%s' is referenced with scala suffix in '%s'.\");\n    }\n\n    private static Collection<String> checkInfectedModules(\n            Collection<String> modules, Path paimonRootPath) throws IOException {\n        return checkModules(\n                modules,\n                paimonRootPath,\n                \"\",\n                \"Scala-dependent module '%s' is referenced without scala suffix in '%s'.\");\n    }\n\n    private static Collection<String> checkModules(\n            Collection<String> modules,\n            Path paimonRootPath,\n            String moduleSuffix,\n            String violationTemplate)\n            throws IOException {\n\n        final ArrayList<String> sortedModules = new ArrayList<>(modules);\n        sortedModules.sort(String::compareTo);\n\n        final Collection<String> violations = new ArrayList<>();", "        for (String module : sortedModules) {\n            int numPreviousViolations = violations.size();\n            try (Stream<Path> pathStream = Files.walk(paimonRootPath, 3)) {\n                final List<Path> pomFiles =\n                        pathStream\n                                .filter(path -> path.getFileName().toString().equals(\"pom.xml\"))\n                                .collect(Collectors.toList());\n\n                for (Path pomFile : pomFiles) {\n                    try (Stream<String> lines = Files.lines(pomFile, StandardCharsets.UTF_8)) {\n                        final boolean existsCleanReference =\n                                lines.anyMatch(\n                                        line ->\n                                                line.contains(\n                                                        module + moduleSuffix + \"</artifactId>\"));\n", "                for (Path pomFile : pomFiles) {\n                    try (Stream<String> lines = Files.lines(pomFile, StandardCharsets.UTF_8)) {\n                        final boolean existsCleanReference =\n                                lines.anyMatch(\n                                        line ->\n                                                line.contains(\n                                                        module + moduleSuffix + \"</artifactId>\"));\n\n                        if (existsCleanReference) {\n                            violations.add(\n                                    String.format(\n                                            violationTemplate,\n                                            module,\n                                            paimonRootPath.relativize(pomFile)));\n                        }\n                    }\n                }\n            }", "                        if (existsCleanReference) {\n                            violations.add(\n                                    String.format(\n                                            violationTemplate,\n                                            module,\n                                            paimonRootPath.relativize(pomFile)));\n                        }\n                    }\n                }\n            }\n            if (numPreviousViolations == violations.size()) {\n                LOG.info(\"OK {}\", module);\n            }\n        }\n        return violations;\n    }\n\n    private static boolean isExcluded(String line) {\n        return EXCLUDED_MODULES.stream().anyMatch(line::contains);\n    }\n\n    private static class ParseResult {\n\n        private final Set<String> cleanModules;\n        private final Set<String> infectedModules;\n\n        private ParseResult(Set<String> cleanModules, Set<String> infectedModules) {\n            this.cleanModules = cleanModules;\n            this.infectedModules = infectedModules;\n        }\n\n        public Set<String> getCleanModules() {\n            return cleanModules;\n        }\n\n        public Set<String> getInfectedModules() {\n            return infectedModules;\n        }\n    }\n}\n", "            if (numPreviousViolations == violations.size()) {\n                LOG.info(\"OK {}\", module);\n            }\n        }\n        return violations;\n    }\n\n    private static boolean isExcluded(String line) {\n        return EXCLUDED_MODULES.stream().anyMatch(line::contains);\n    }\n\n    private static class ParseResult {\n\n        private final Set<String> cleanModules;\n        private final Set<String> infectedModules;\n\n        private ParseResult(Set<String> cleanModules, Set<String> infectedModules) {\n            this.cleanModules = cleanModules;\n            this.infectedModules = infectedModules;\n        }\n\n        public Set<String> getCleanModules() {\n            return cleanModules;\n        }\n\n        public Set<String> getInfectedModules() {\n            return infectedModules;\n        }\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/licensecheck/JarFileChecker.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.licensecheck;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.URI;", "import java.io.IOException;\nimport java.net.URI;\nimport java.nio.charset.MalformedInputException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.Collections;", "import java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/** Checks the Jar files created by the build process. */\npublic class JarFileChecker {\n    private static final Logger LOG = LoggerFactory.getLogger(JarFileChecker.class);\n", "/** Checks the Jar files created by the build process. */\npublic class JarFileChecker {\n    private static final Logger LOG = LoggerFactory.getLogger(JarFileChecker.class);\n\n    public static int checkPath(Path path) throws Exception {\n        List<Path> files = getBuildJars(path);\n        LOG.info(\"Checking directory {} with a total of {} jar files.\", path, files.size());\n\n        int severeIssues = 0;\n        for (Path file : files) {\n            severeIssues += checkJar(file);\n        }\n\n        return severeIssues;\n    }\n\n    private static List<Path> getBuildJars(Path path) throws IOException {\n        return Files.walk(path)\n                .filter(file -> file.toString().endsWith(\".jar\"))\n                .collect(Collectors.toList());\n    }\n\n    @VisibleForTesting\n    static int checkJar(Path file) throws Exception {\n        final URI uri = file.toUri();\n\n        int numSevereIssues = 0;\n        try (final FileSystem fileSystem =\n                FileSystems.newFileSystem(\n                        new URI(\"jar:file\", uri.getHost(), uri.getPath(), uri.getFragment()),\n                        Collections.emptyMap())) {", "        for (Path file : files) {\n            severeIssues += checkJar(file);\n        }\n\n        return severeIssues;\n    }\n\n    private static List<Path> getBuildJars(Path path) throws IOException {\n        return Files.walk(path)\n                .filter(file -> file.toString().endsWith(\".jar\"))\n                .collect(Collectors.toList());\n    }\n\n    @VisibleForTesting\n    static int checkJar(Path file) throws Exception {\n        final URI uri = file.toUri();\n\n        int numSevereIssues = 0;\n        try (final FileSystem fileSystem =\n                FileSystems.newFileSystem(\n                        new URI(\"jar:file\", uri.getHost(), uri.getPath(), uri.getFragment()),\n                        Collections.emptyMap())) {", "            if (isTestJarAndEmpty(file, fileSystem.getPath(\"/\"))) {\n                return 0;\n            }\n            if (!noticeFileExistsAndIsValid(fileSystem.getPath(\"META-INF\", \"NOTICE\"), file)) {\n                numSevereIssues++;\n            }\n            if (!licenseFileExistsAndIsValid(fileSystem.getPath(\"META-INF\", \"LICENSE\"), file)) {\n                numSevereIssues++;\n            }\n\n            numSevereIssues +=\n                    getNumLicenseFilesOutsideMetaInfDirectory(file, fileSystem.getPath(\"/\"));\n\n            numSevereIssues += getFilesWithIncompatibleLicenses(file, fileSystem.getPath(\"/\"));\n        }\n        return numSevereIssues;\n    }\n\n    private static boolean isTestJarAndEmpty(Path jar, Path jarRoot) throws IOException {", "        if (jar.getFileName().toString().endsWith(\"-tests.jar\")) {\n            try (Stream<Path> files = Files.walk(jarRoot)) {\n                long numClassFiles =\n                        files.filter(path -> !path.equals(jarRoot))\n                                .filter(path -> path.getFileName().toString().endsWith(\".class\"))\n                                .count();\n                if (numClassFiles == 0) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean noticeFileExistsAndIsValid(Path noticeFile, Path jar)\n            throws IOException {", "        if (!Files.exists(noticeFile)) {\n            LOG.error(\"Missing META-INF/NOTICE in {}\", jar);\n            return false;\n        }\n\n        final String noticeFileContents = readFile(noticeFile);\n        if (!noticeFileContents.contains(\"The Apache Software Foundation\")) {\n            LOG.error(\"The notice file in {} does not contain the expected entries.\", jar);\n            return false;\n        }\n\n        return true;\n    }\n\n    private static boolean licenseFileExistsAndIsValid(Path licenseFile, Path jar)\n            throws IOException {", "        if (!Files.exists(licenseFile)) {\n            LOG.error(\"Missing META-INF/LICENSE in {}\", jar);\n            return false;\n        }\n\n        final String licenseFileContents = readFile(licenseFile);\n        if (!licenseFileContents.contains(\"Apache License\")\n                || !licenseFileContents.contains(\"Version 2.0, January 2004\")) {\n            LOG.error(\"The license file in {} does not contain the expected entries.\", jar);\n            return false;\n        }\n\n        return true;\n    }\n\n    private static int getFilesWithIncompatibleLicenses(Path jar, Path jarRoot) throws IOException {\n        // patterns are based on https://www.apache.org/legal/resolved.html#category-x\n        return findNonBinaryFilesContainingText(\n                jar,\n                jarRoot,\n                asPatterns(\n                        \"Binary Code License\",\n                        \"Intel Simplified Software License\",\n                        \"JSR 275\",\n                        \"Microsoft Limited Public License\",\n                        \"Amazon Software License\",\n                        // Java SDK for Satori RTM license\n                        \"as necessary for your use of Satori services\",\n                        \"REDIS SOURCE AVAILABLE LICENSE\",\n                        \"Booz Allen Public License\",\n                        \"Confluent Community License Agreement Version 1.0\",\n                        // \u201cCommons Clause\u201d License Condition v1.0\n                        \"the License does not grant to you, the right to Sell the Software.\",\n                        \"Sun Community Source License Version 3.0\",\n                        \"GNU General Public License\",\n                        \"GNU Affero General Public License\",\n                        \"GNU Lesser General Public License\",\n                        \"Q Public License\",\n                        \"Sleepycat License\",\n                        \"Server Side Public License\",\n                        \"Code Project Open License\",\n                        // BSD 4-Clause\n                        \" All advertising materials mentioning features or use of this software must display the following acknowledgement\",\n                        // Facebook Patent clause v1\n                        \"The license granted hereunder will terminate, automatically and without notice, for anyone that makes any claim\",\n                        // Facebook Patent clause v2\n                        \"The license granted hereunder will terminate, automatically and without notice, if you (or any of your subsidiaries, corporate affiliates or agents) initiate directly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook\",\n                        \"Netscape Public License\",\n                        \"SOLIPSISTIC ECLIPSE PUBLIC LICENSE\",\n                        // DON'T BE A DICK PUBLIC LICENSE\n                        \"Do whatever you like with the original work, just don't be a dick.\",\n                        // JSON License\n                        \"The Software shall be used for Good, not Evil.\",\n                        // can sometimes be found in \"funny\" licenses\n                        \"Don\u2019t be evil\"));\n    }\n\n    private static Collection<Pattern> asPatterns(String... texts) {\n        return Stream.of(texts)\n                .map(JarFileChecker::asPatternWithPotentialLineBreaks)\n                .collect(Collectors.toList());\n    }\n\n    private static Pattern asPatternWithPotentialLineBreaks(String text) {\n        // allows word sequences to be separated by whitespace, line-breaks and comments(//, #)\n        return Pattern.compile(text.toLowerCase(Locale.ROOT).replaceAll(\" \", \" ?\\\\\\\\R?[\\\\\\\\s/#]*\"));\n    }\n\n    private static int findNonBinaryFilesContainingText(\n            Path jar, Path jarRoot, Collection<Pattern> forbidden) throws IOException {\n        try (Stream<Path> files = Files.walk(jarRoot)) {\n            return files.filter(path -> !path.equals(jarRoot))\n                    .filter(path -> !Files.isDirectory(path))\n                    .filter(JarFileChecker::isNoClassFile)\n                    // frequent false-positives due to dual-licensing; generated by maven\n                    .filter(path -> !getFileName(path).equals(\"dependencies\"))\n                    // false-positives due to dual-licensing; use startsWith to cover .txt/.md files\n                    .filter(path -> !getFileName(path).startsWith(\"license\"))\n                    // false-positives due to optional components; startsWith covers .txt/.md files\n                    .filter(path -> !getFileName(path).startsWith(\"notice\"))\n                    // dual-licensed under GPL 2 and CDDL 1.1\n                    // contained in hadoop/presto S3 FS and paimon-dist\n                    .filter(path -> !pathStartsWith(path, \"/META-INF/versions/11/javax/xml/bind\"))\n                    .filter(path -> !isJavaxManifest(jar, path))\n                    // dual-licensed under GPL 2 and EPL 2.0\n                    // contained in sql-avro-confluent-registry\n                    .filter(path -> !pathStartsWith(path, \"/org/glassfish/jersey/internal\"))\n                    .map(\n                            path -> {", "                                try {\n                                    final String fileContents;\n                                    try {\n                                        fileContents = readFile(path).toLowerCase(Locale.ROOT);\n                                    } catch (MalformedInputException mie) {\n                                        // binary file\n                                        return 0;\n                                    }\n\n                                    int violations = 0;\n                                    for (Pattern text : forbidden) {", "                                    for (Pattern text : forbidden) {\n                                        if (text.matcher(fileContents).find()) {\n                                            // do not count individual violations because it can be\n                                            // confusing when checking with aliases for the same\n                                            // license\n                                            violations = 1;\n                                            LOG.error(\n                                                    \"File '{}' in jar '{}' contains match with forbidden regex '{}'.\",\n                                                    path,\n                                                    jar,\n                                                    text);\n                                        }\n                                    }\n                                    return violations;\n                                } catch (IOException e) {\n                                    throw new RuntimeException(\n                                            String.format(\n                                                    \"Could not read contents of file '%s' in jar '%s'.\",\n                                                    path, jar),\n                                            e);\n                                }\n                            })\n                    .reduce(Integer::sum)\n                    .orElse(0);\n        }\n    }\n\n    private static int getNumLicenseFilesOutsideMetaInfDirectory(Path jar, Path jarRoot)\n            throws IOException {\n        try (Stream<Path> files = Files.walk(jarRoot)) {\n            /*\n             * LICENSE or NOTICE files found outside of the META-INF directory are most likely shading mistakes (we are including the files from other dependencies, thus providing an invalid LICENSE file)\n             *\n             * <p>In such a case, we recommend updating the shading exclusions, and adding the license file to META-INF/licenses.\n             */\n            final List<String> filesWithIssues =\n                    files.filter(path -> !path.equals(jarRoot))\n                            .filter(\n                                    path ->\n                                            getFileName(path).contains(\"license\")\n                                                    || getFileName(path).contains(\"notice\"))\n                            .filter(\n                                    path ->\n                                            !Files.isDirectory(\n                                                    path)) // ignore directories, e.g. \"license/\"\n                            .filter(JarFileChecker::isNoClassFile) // some class files contain\n                            // LICENSE in their name\n                            .filter(\n                                    path ->\n                                            !getFileName(path)\n                                                    .endsWith(\".ftl\")) // a false positive in\n                            // python\n                            .map(Path::toString)\n                            .filter(\n                                    path ->\n                                            !path.contains(\n                                                    \"META-INF\")) // license files in META-INF are\n                            // expected\n                            .filter(\n                                    path ->\n                                            !path.endsWith(\n                                                    \"web/3rdpartylicenses.txt\")) // a false positive\n                            // in\n                            // web\n                            .collect(Collectors.toList());", "            for (String fileWithIssue : filesWithIssues) {\n                LOG.error(\n                        \"Jar file {} contains a LICENSE file in an unexpected location: {}\",\n                        jar,\n                        fileWithIssue);\n            }\n            return filesWithIssues.size();\n        }\n    }\n\n    private static String getFileName(Path path) {\n        return path.getFileName().toString().toLowerCase();\n    }\n\n    private static boolean pathStartsWith(Path file, String path) {\n        return file.startsWith(file.getFileSystem().getPath(path));\n    }\n\n    private static boolean equals(Path file, String path) {\n        return file.equals(file.getFileSystem().getPath(path));\n    }\n\n    private static boolean isNoClassFile(Path file) {\n        return !getFileName(file).endsWith(\".class\");\n    }\n\n    private static boolean isJavaxManifest(Path jar, Path potentialManifestFile) {", "        try {\n            return equals(potentialManifestFile, \"/META-INF/versions/11/META-INF/MANIFEST.MF\")\n                    && readFile(potentialManifestFile).contains(\"Specification-Title: jaxb-api\");\n        } catch (IOException e) {\n            throw new RuntimeException(\n                    String.format(\n                            \"Error while reading file %s from jar %s.\", potentialManifestFile, jar),\n                    e);\n        }\n    }\n\n    private static String readFile(Path file) throws IOException {\n        return new String(Files.readAllBytes(file), StandardCharsets.UTF_8);\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/licensecheck/LicenseChecker.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.licensecheck;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.nio.file.Paths;\n", "import java.nio.file.Paths;\n\n/** Utility for checking all things related to License and Notice files. */\npublic class LicenseChecker {\n    // ---------------------------------------- Launcher ---------------------------------------- //\n\n    private static final Logger LOG = LoggerFactory.getLogger(LicenseChecker.class);\n\n    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.out.println(\n                    \"Usage: LicenseChecker <pathMavenBuildOutput> <pathPaimonRoot> <pathPaimonDeployed>\");\n            System.exit(1);\n        }\n        LOG.warn(\n                \"THIS UTILITY IS ONLY CHECKING FOR COMMON LICENSING MISTAKES. A MANUAL CHECK OF THE NOTICE FILES, DEPLOYED ARTIFACTS, ETC. IS STILL NEEDED!\");\n\n        int severeIssueCount = NoticeFileChecker.run(new File(args[0]), Paths.get(args[1]));\n\n        severeIssueCount += JarFileChecker.checkPath(Paths.get(args[2]));\n", "    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.out.println(\n                    \"Usage: LicenseChecker <pathMavenBuildOutput> <pathPaimonRoot> <pathPaimonDeployed>\");\n            System.exit(1);\n        }\n        LOG.warn(\n                \"THIS UTILITY IS ONLY CHECKING FOR COMMON LICENSING MISTAKES. A MANUAL CHECK OF THE NOTICE FILES, DEPLOYED ARTIFACTS, ETC. IS STILL NEEDED!\");\n\n        int severeIssueCount = NoticeFileChecker.run(new File(args[0]), Paths.get(args[1]));\n\n        severeIssueCount += JarFileChecker.checkPath(Paths.get(args[2]));\n", "        if (severeIssueCount > 0) {\n            LOG.warn(\"Found a total of {} severe license issues\", severeIssueCount);\n\n            System.exit(1);\n        }\n        LOG.info(\"License check completed without severe issues.\");\n    }\n}\n"]}
{"filename": "tools/ci/paimon-ci-tools/src/main/java/org/apache/paimon/tools/ci/licensecheck/NoticeFileChecker.java", "chunked_list": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0", " *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n", " */\n\npackage org.apache.paimon.tools.ci.licensecheck;\n\nimport org.apache.paimon.tools.ci.utils.dependency.DependencyParser;\nimport org.apache.paimon.tools.ci.utils.deploy.DeployParser;\nimport org.apache.paimon.tools.ci.utils.notice.NoticeContents;\nimport org.apache.paimon.tools.ci.utils.notice.NoticeParser;\nimport org.apache.paimon.tools.ci.utils.shade.ShadeParser;\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;", "import org.apache.paimon.tools.ci.utils.shade.ShadeParser;\nimport org.apache.paimon.tools.ci.utils.shared.Dependency;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.io.BufferedReader;\nimport java.io.File;", "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;", "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;", "import java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/** Utility class checking for proper NOTICE files based on the maven build output. */\npublic class NoticeFileChecker {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NoticeFileChecker.class);\n\n    private static final List<String> MODULES_DEFINING_EXCESS_DEPENDENCIES =\n            loadFromResources(\"modules-defining-excess-dependencies.modulelist\");\n\n    // Examples:\n    // \"- org.apache.htrace:htrace-core:3.1.0-incubating\"\n    // or\n    // \"This project bundles \"net.jcip:jcip-annotations:1.0\".\n    private static final Pattern NOTICE_DEPENDENCY_PATTERN =\n            Pattern.compile(\n                    \"- ([^ :]+):([^:]+):([^ ]+)($| )|.*bundles \\\"([^:]+):([^:]+):([^\\\"]+)\\\".*\");\n\n    static int run(File buildResult, Path root) throws IOException {\n        // parse included dependencies from build output\n        final Map<String, Set<Dependency>> modulesWithBundledDependencies =\n                combineAndFilterPaimonDependencies(\n                        ShadeParser.parseShadeOutput(buildResult.toPath()),\n                        DependencyParser.parseDependencyCopyOutput(buildResult.toPath()));\n\n        final Set<String> deployedModules = DeployParser.parseDeployOutput(buildResult);\n\n        LOG.info(\n                \"Extracted \"\n                        + deployedModules.size()\n                        + \" modules that were deployed and \"\n                        + modulesWithBundledDependencies.keySet().size()\n                        + \" modules which bundle dependencies with a total of \"\n                        + modulesWithBundledDependencies.values().size()\n                        + \" dependencies\");\n\n        // find modules producing a shaded-jar\n        List<Path> noticeFiles = findNoticeFiles(root);\n        LOG.info(\"Found {} NOTICE files to check\", noticeFiles.size());\n\n        final Map<String, Optional<NoticeContents>> moduleToNotice =\n                noticeFiles.stream()\n                        .collect(\n                                Collectors.toMap(\n                                        NoticeFileChecker::getModuleFromNoticeFile,\n                                        noticeFile -> {", "                                            try {\n                                                return NoticeParser.parseNoticeFile(noticeFile);\n                                            } catch (IOException e) {\n                                                // some machine issue\n                                                throw new RuntimeException(e);\n                                            }\n                                        }));\n\n        return run(modulesWithBundledDependencies, deployedModules, moduleToNotice);\n    }\n\n    @VisibleForTesting\n    static int run(\n            Map<String, Set<Dependency>> modulesWithBundledDependencies,\n            Set<String> deployedModules,\n            Map<String, Optional<NoticeContents>> noticeFiles)\n            throws IOException {\n        int severeIssueCount = 0;\n\n        final Set<String> modulesSkippingDeployment =\n                new HashSet<>(modulesWithBundledDependencies.keySet());\n        modulesSkippingDeployment.removeAll(deployedModules);\n\n        LOG.debug(\n                \"The following {} modules are skipping deployment: {}\",\n                modulesSkippingDeployment.size(),\n                modulesSkippingDeployment.stream()\n                        .sorted()\n                        .collect(Collectors.joining(\"\\n\\t\", \"\\n\\t\", \"\")));\n", "        for (String moduleSkippingDeployment : modulesSkippingDeployment) {\n            // TODO: this doesn't work for modules requiring a NOTICE that are bundled indirectly\n            // TODO: via another non-deployed module\n            boolean bundledByDeployedModule =\n                    modulesWithBundledDependencies.entrySet().stream()\n                            .filter(\n                                    entry ->\n                                            entry.getValue().stream()\n                                                    .map(Dependency::getArtifactId)\n                                                    .anyMatch(\n                                                            artifactId ->\n                                                                    artifactId.equals(\n                                                                            moduleSkippingDeployment)))\n                            .anyMatch(entry -> !modulesSkippingDeployment.contains(entry.getKey()));\n", "            if (!bundledByDeployedModule) {\n                modulesWithBundledDependencies.remove(moduleSkippingDeployment);\n            } else {\n                LOG.debug(\n                        \"Including module {} in license checks, despite not being deployed, because it is bundled by another deployed module.\",\n                        moduleSkippingDeployment);\n            }\n        }\n\n        // check that all required NOTICE files exists\n        severeIssueCount +=\n                ensureRequiredNoticeFiles(modulesWithBundledDependencies, noticeFiles.keySet());\n\n        // check each NOTICE file", "        for (Map.Entry<String, Optional<NoticeContents>> noticeFile : noticeFiles.entrySet()) {\n            severeIssueCount +=\n                    checkNoticeFileAndLogProblems(\n                            modulesWithBundledDependencies,\n                            noticeFile.getKey(),\n                            noticeFile.getValue().orElse(null));\n        }\n\n        return severeIssueCount;\n    }\n\n    private static Map<String, Set<Dependency>> combineAndFilterPaimonDependencies(\n            Map<String, Set<Dependency>> modulesWithBundledDependencies,\n            Map<String, Set<Dependency>> modulesWithCopiedDependencies) {\n\n        final Map<String, Set<Dependency>> combinedAndFiltered = new LinkedHashMap<>();\n\n        Stream.concat(\n                        modulesWithBundledDependencies.entrySet().stream(),\n                        modulesWithCopiedDependencies.entrySet().stream())\n                .forEach(\n                        (entry) -> {\n                            final Set<Dependency> dependencies =\n                                    combinedAndFiltered.computeIfAbsent(\n                                            entry.getKey(), ignored -> new LinkedHashSet<>());\n", "                            for (Dependency dependency : entry.getValue()) {\n                                if (!dependency.getGroupId().contains(\"org.apache.paimon\")) {\n                                    dependencies.add(dependency);\n                                }\n                            }\n                        });\n\n        return combinedAndFiltered;\n    }\n\n    private static int ensureRequiredNoticeFiles(\n            Map<String, Set<Dependency>> modulesWithShadedDependencies,\n            Collection<String> modulesWithNoticeFile) {\n        int severeIssueCount = 0;\n        Set<String> shadingModules = new HashSet<>(modulesWithShadedDependencies.keySet());\n        shadingModules.removeAll(modulesWithNoticeFile);", "        for (String moduleWithoutNotice : shadingModules) {\n            if (modulesWithShadedDependencies.get(moduleWithoutNotice).stream()\n                    .anyMatch(dependency -> !dependency.getGroupId().equals(\"org.apache.paimon\"))) {\n                LOG.error(\n                        \"Module {} is missing a NOTICE file. It has shaded dependencies: {}\",\n                        moduleWithoutNotice,\n                        modulesWithShadedDependencies.get(moduleWithoutNotice).stream()\n                                .map(Dependency::toString)\n                                .collect(Collectors.joining(\"\\n\\t\", \"\\n\\t\", \"\")));\n                severeIssueCount++;\n            }\n        }\n        return severeIssueCount;\n    }\n\n    private static String getModuleFromNoticeFile(Path noticeFile) {\n        Path moduleDirectory =\n                noticeFile\n                        .getParent() // META-INF\n                        .getParent() // resources\n                        .getParent() // main\n                        .getParent() // src\n                        .getParent(); // <-- module name\n        return moduleDirectory.getFileName().toString();\n    }\n\n    private static int checkNoticeFileAndLogProblems(\n            Map<String, Set<Dependency>> modulesWithShadedDependencies,\n            String moduleName,\n            @Nullable NoticeContents noticeContents)\n            throws IOException {\n\n        final Map<Severity, List<String>> problemsBySeverity =\n                checkNoticeFile(modulesWithShadedDependencies, moduleName, noticeContents);\n\n        final List<String> severeProblems =\n                problemsBySeverity.getOrDefault(Severity.CRITICAL, Collections.emptyList());\n", "        if (!problemsBySeverity.isEmpty()) {\n            final List<String> toleratedProblems =\n                    problemsBySeverity.getOrDefault(Severity.TOLERATED, Collections.emptyList());\n            final List<String> expectedProblems =\n                    problemsBySeverity.getOrDefault(Severity.SUPPRESSED, Collections.emptyList());\n\n            LOG.info(\n                    \"Problems were detected for a NOTICE file.\\n\" + \"\\t{}:\\n\" + \"{}{}{}\",\n                    moduleName,\n                    convertProblemsToIndentedString(\n                            severeProblems,\n                            \"These issue are legally problematic and MUST be fixed:\"),\n                    convertProblemsToIndentedString(\n                            toleratedProblems,\n                            \"These issues are mistakes that aren't legally problematic. They SHOULD be fixed at some point, but we don't have to:\"),\n                    convertProblemsToIndentedString(\n                            expectedProblems, \"These issues are assumed to be false-positives:\"));\n        }\n\n        return severeProblems.size();\n    }\n\n    @VisibleForTesting\n    static Map<Severity, List<String>> checkNoticeFile(\n            Map<String, Set<Dependency>> modulesWithShadedDependencies,\n            String moduleName,\n            @Nullable NoticeContents noticeContents) {\n\n        final Map<Severity, List<String>> problemsBySeverity = new HashMap<>();\n", "        if (noticeContents == null) {\n            addProblem(problemsBySeverity, Severity.CRITICAL, \"The NOTICE file was empty.\");\n        } else {\n            // first line must be the module name.\n            if (!noticeContents.getNoticeModuleName().equals(moduleName)) {\n                addProblem(\n                        problemsBySeverity,\n                        Severity.TOLERATED,\n                        String.format(\n                                \"First line does not start with module name. firstLine=%s\",\n                                noticeContents.getNoticeModuleName()));\n            }\n\n            // collect all declared dependencies from NOTICE file\n            Set<Dependency> declaredDependencies = new HashSet<>();", "            for (Dependency declaredDependency : noticeContents.getDeclaredDependencies()) {\n                if (!declaredDependencies.add(declaredDependency)) {\n                    addProblem(\n                            problemsBySeverity,\n                            Severity.CRITICAL,\n                            String.format(\"Dependency %s is declared twice.\", declaredDependency));\n                }\n            }\n\n            // find all dependencies missing from NOTICE file\n            Collection<Dependency> expectedDependencies =\n                    modulesWithShadedDependencies.getOrDefault(moduleName, Collections.emptySet())\n                            .stream()\n                            .filter(\n                                    dependency ->\n                                            !dependency.getGroupId().equals(\"org.apache.paimon\"))\n                            .collect(Collectors.toList());\n", "            for (Dependency expectedDependency : expectedDependencies) {\n                if (!declaredDependencies.contains(expectedDependency)) {\n                    addProblem(\n                            problemsBySeverity,\n                            Severity.CRITICAL,\n                            String.format(\"Dependency %s is not listed.\", expectedDependency));\n                }\n            }\n\n            boolean moduleDefinesExcessDependencies =\n                    MODULES_DEFINING_EXCESS_DEPENDENCIES.contains(moduleName);\n\n            // find all dependencies defined in NOTICE file, which were not expected", "            for (Dependency declaredDependency : declaredDependencies) {\n                if (!expectedDependencies.contains(declaredDependency)) {\n                    final Severity severity =\n                            moduleDefinesExcessDependencies\n                                    ? Severity.SUPPRESSED\n                                    : Severity.TOLERATED;\n                    addProblem(\n                            problemsBySeverity,\n                            severity,\n                            String.format(\n                                    \"Dependency %s is not bundled, but listed.\",\n                                    declaredDependency));\n                }\n            }\n        }\n\n        return problemsBySeverity;\n    }\n\n    private static void addProblem(\n            Map<Severity, List<String>> problemsBySeverity, Severity severity, String problem) {\n        problemsBySeverity.computeIfAbsent(severity, ignored -> new ArrayList<>()).add(problem);\n    }\n\n    @VisibleForTesting\n    enum Severity {\n        /** Issues that a legally problematic which must be fixed. */\n        CRITICAL,\n        /** Issues that affect the correctness but aren't legally problematic. */\n        TOLERATED,\n        /** Issues where we intentionally break the rules. */\n        SUPPRESSED\n    }\n\n    private static String convertProblemsToIndentedString(List<String> problems, String header) {\n        return problems.isEmpty()\n                ? \"\"\n                : problems.stream()\n                        .map(s -> \"\\t\\t\\t\" + s)\n                        .collect(Collectors.joining(\"\\n\", \"\\t\\t \" + header + \" \\n\", \"\\n\"));\n    }\n\n    private static List<Path> findNoticeFiles(Path root) throws IOException {\n        return Files.walk(root)\n                .filter(\n                        file -> {\n                            int nameCount = file.getNameCount();\n                            return file.getName(nameCount - 3).toString().equals(\"resources\")\n                                    && file.getName(nameCount - 2).toString().equals(\"META-INF\")\n                                    && file.getName(nameCount - 1).toString().equals(\"NOTICE\");\n                        })\n                .collect(Collectors.toList());\n    }\n\n    private static List<String> loadFromResources(String fileName) {", "        try {\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(\n                            new InputStreamReader(\n                                    Objects.requireNonNull(\n                                            NoticeFileChecker.class.getResourceAsStream(\n                                                    \"/\" + fileName))))) {\n\n                List<String> result =\n                        bufferedReader\n                                .lines()\n                                .filter(line -> !line.startsWith(\"#\") && !line.isEmpty())\n                                .collect(Collectors.toList());\n                LOG.debug(\"Loaded {} items from resource {}\", result.size(), fileName);\n                return result;\n            }\n        } catch (Throwable e) {\n            // wrap anything in a RuntimeException to be callable from the static initializer\n            throw new RuntimeException(\"Error while loading resource\", e);\n        }\n    }\n}\n"]}
