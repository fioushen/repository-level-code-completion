{"filename": "forge/src/main/java/org/geysermc/hydraulic/forge/HydraulicForgeMod.java", "chunked_list": ["package org.geysermc.hydraulic.forge;\n\nimport net.minecraftforge.event.server.ServerStartingEvent;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\nimport org.geysermc.hydraulic.Constants;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.forge.platform.HydraulicForgeBootstrap;\nimport org.geysermc.hydraulic.platform.HydraulicPlatform;\n", "import org.geysermc.hydraulic.platform.HydraulicPlatform;\n\n@Mod(Constants.MOD_ID)\npublic class HydraulicForgeMod {\n    private final HydraulicImpl hydraulic;\n\n    public HydraulicForgeMod() {\n        this.hydraulic = HydraulicImpl.load(HydraulicPlatform.FORGE, new HydraulicForgeBootstrap());\n\n        FMLJavaModLoadingContext.get().getModEventBus().addListener(this::onServerStarting);\n    }\n\n    private void onServerStarting(ServerStartingEvent event) {\n        this.hydraulic.onServerStarting(event.getServer());\n    }\n}\n"]}
{"filename": "forge/src/main/java/org/geysermc/hydraulic/forge/platform/HydraulicForgeBootstrap.java", "chunked_list": ["package org.geysermc.hydraulic.forge.platform;\n\nimport net.minecraftforge.fml.ModList;\nimport net.minecraftforge.fml.loading.FMLPaths;\nimport org.geysermc.hydraulic.platform.HydraulicBootstrap;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;", "\nimport java.nio.file.Path;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class HydraulicForgeBootstrap implements HydraulicBootstrap {\n\n    @Override\n    public @NotNull Set<ModInfo> mods() {\n        return ModList.get().getMods().stream().map(modInfo ->\n                new ModInfo(\n                        modInfo.getModId(),\n                        modInfo.getVersion().toString(),\n                        modInfo.getDisplayName(),\n                        modInfo.getOwningFile().getFile().getFilePath(),\n                        modInfo.getLogoFile().orElse(\"\")\n                )\n        ).collect(Collectors.toUnmodifiableSet());\n    }\n\n    @Override\n    public @Nullable ModInfo mod(@NotNull String modName) {\n        return ModList.get().getModContainerById(modName).map(container ->\n                new ModInfo(\n                        container.getModId(),\n                        container.getModInfo().getVersion().toString(),\n                        container.getModInfo().getDisplayName(),\n                        container.getModInfo().getOwningFile().getFile().getFilePath(),\n                        container.getModInfo().getLogoFile().orElse(\"\")\n                )\n        ).orElse(null);\n    }\n\n    @Override\n    public @NotNull Path dataFolder(@NotNull String modId) {\n        return FMLPaths.CONFIGDIR.get().resolve(modId);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/org/geysermc/hydraulic/fabric/HydraulicFabricMod.java", "chunked_list": ["package org.geysermc.hydraulic.fabric;\n\nimport net.fabricmc.api.ModInitializer;\nimport net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.fabric.platform.HydraulicFabricBootstrap;\nimport org.geysermc.hydraulic.platform.HydraulicPlatform;\n\npublic class HydraulicFabricMod implements ModInitializer {\n    private HydraulicImpl hydraulic;\n\n    @Override", "public class HydraulicFabricMod implements ModInitializer {\n    private HydraulicImpl hydraulic;\n\n    @Override\n    public void onInitialize() {\n        this.hydraulic = HydraulicImpl.load(HydraulicPlatform.FABRIC, new HydraulicFabricBootstrap());\n\n        ServerLifecycleEvents.SERVER_STARTING.register(this.hydraulic::onServerStarting);\n    }\n}\n"]}
{"filename": "fabric/src/main/java/org/geysermc/hydraulic/fabric/platform/HydraulicFabricBootstrap.java", "chunked_list": ["package org.geysermc.hydraulic.fabric.platform;\n\nimport net.fabricmc.loader.api.FabricLoader;\nimport net.fabricmc.loader.api.ModContainer;\nimport org.geysermc.hydraulic.platform.HydraulicBootstrap;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;", "\nimport java.nio.file.Path;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class HydraulicFabricBootstrap implements HydraulicBootstrap {\n\n    @Override\n    public @NotNull Set<ModInfo> mods() {\n        return FabricLoader.getInstance().getAllMods().stream().filter(container -> !ignoreMod(container)).map(container ->\n            new ModInfo(\n                    container.getMetadata().getId(),\n                    container.getMetadata().getVersion().getFriendlyString(),\n                    container.getMetadata().getName(),\n                    container.getRootPaths().get(0), // TODO: Multi-path support\n                    container.getMetadata().getIconPath(256).orElse(\"\")\n            )\n        ).collect(Collectors.toUnmodifiableSet());\n    }\n\n    /**\n     * Ignore mods that are not built in or sub-mods.\n     *\n     * @param container the mod container\n     * @return whether to ignore the mod\n     */\n    private boolean ignoreMod(ModContainer container) {\n        return (container.getMetadata().getId().startsWith(\"fabric\") && container.getMetadata().containsCustomValue(\"fabric-api:module-lifecycle\"))\n            || container.getMetadata().getId().equals(\"fabricloader\")\n            || container.getMetadata().getId().equals(\"fabric-api\")\n            || !container.getContainingMod().isEmpty();\n    }\n\n    @Override\n    public @Nullable ModInfo mod(@NotNull String modName) {\n        return FabricLoader.getInstance().getModContainer(modName).map(container ->\n                new ModInfo(\n                        container.getMetadata().getId(),\n                        container.getMetadata().getVersion().getFriendlyString(),\n                        container.getMetadata().getName(),\n                        container.getRootPaths().get(0), // TODO: Multi-path support\n                        container.getMetadata().getIconPath(256).orElse(\"\")\n                )\n        ).orElse(null);\n    }\n\n    @Override\n    public @NotNull Path dataFolder(@NotNull String modId) {\n        return FabricLoader.getInstance().getConfigDir().resolve(modId);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/Constants.java", "chunked_list": ["package org.geysermc.hydraulic;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\npublic class Constants {\n    public static final String MOD_ID = \"hydraulic\";\n    public static final String MOD_NAME = \"Hydraulic\";\n    public static final String VERSION = \"1.0.0-SNAPSHOT\";\n\n    public static final Gson GSON = new GsonBuilder()\n            .setPrettyPrinting()\n            .create();\n}\n", "    public static final String VERSION = \"1.0.0-SNAPSHOT\";\n\n    public static final Gson GSON = new GsonBuilder()\n            .setPrettyPrinting()\n            .create();\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/HydraulicImpl.java", "chunked_list": ["package org.geysermc.hydraulic;\n\nimport net.minecraft.server.MinecraftServer;\nimport org.geysermc.geyser.api.event.EventRegistrar;\nimport org.geysermc.hydraulic.pack.PackManager;\nimport org.geysermc.hydraulic.platform.HydraulicBootstrap;\nimport org.geysermc.hydraulic.platform.HydraulicPlatform;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.hydraulic.storage.ModStorage;\nimport org.jetbrains.annotations.NotNull;", "import org.geysermc.hydraulic.storage.ModStorage;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;", "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Main class of the Hydraulic mod.\n */\npublic class HydraulicImpl implements EventRegistrar {\n    private static final Logger LOGGER = LoggerFactory.getLogger(\"Hydraulic\");\n\n    private static HydraulicImpl instance;\n\n    private final HydraulicPlatform platform;\n    private final HydraulicBootstrap bootstrap;\n    private final PackManager packManager;\n\n    private final Map<String, ModStorage> modStorage = new HashMap<>();\n\n    private MinecraftServer server;\n\n    private HydraulicImpl(HydraulicPlatform platform, HydraulicBootstrap bootstrap) {\n        instance = this;\n\n        this.platform = platform;\n        this.bootstrap = bootstrap;\n        this.packManager = new PackManager(this);\n    }\n\n    /**\n     * Called when the server is starting.\n     *\n     * @param server the Minecraft server instance\n     */", "    public void onServerStarting(@NotNull MinecraftServer server) {\n        this.server = server;\n\n        this.packManager.initialize();\n    }\n\n    /**\n     * Gets all the mods loaded on this platform.\n     *\n     * @return the mods loaded on this platform\n     */\n    @NotNull\n    public Set<ModInfo> mods() {\n        return this.bootstrap.mods();\n    }\n\n    /**\n     * Gets the mod with the specified name, or null if not found.\n     *\n     * @param modName the name of the mod to get\n     * @return the mod with the specified name\n     */\n    @Nullable", "    public ModInfo mod(@NotNull String modName) {\n        return this.bootstrap.mod(modName);\n    }\n\n    /**\n     * Gets the Minecraft server instance.\n     *\n     * @return the Minecraft server instance\n     */\n    @NotNull\n    public MinecraftServer server() {\n        return this.server;\n    }\n\n    /**\n     * Gets the data folder directory of this platform.\n     *\n     * @return the data folder directory\n     */\n    @NotNull", "    public MinecraftServer server() {\n        return this.server;\n    }\n\n    /**\n     * Gets the data folder directory of this platform.\n     *\n     * @return the data folder directory\n     */\n    @NotNull\n    public Path dataFolder(@NotNull String modId) {\n        return this.bootstrap.dataFolder(modId);\n    }\n\n    /**\n     * Gets the mod storage for the specified mod.\n     *\n     * @param mod the mod\n     * @return the mod storage\n     */\n    @NotNull", "    public Path dataFolder(@NotNull String modId) {\n        return this.bootstrap.dataFolder(modId);\n    }\n\n    /**\n     * Gets the mod storage for the specified mod.\n     *\n     * @param mod the mod\n     * @return the mod storage\n     */\n    @NotNull", "    public ModStorage modStorage(@NotNull ModInfo mod) {\n        return this.modStorage.computeIfAbsent(mod.id(), e -> ModStorage.load(mod));\n    }\n\n    /**\n     * Loads Hydraulic.\n     *\n     * @param platform the platform Hydraulic is running on\n     * @param bootstrap the Hydraulic platform bootstrap\n     * @return the loaded Hydraulic instance\n     */\n    @NotNull", "    public static HydraulicImpl load(@NotNull HydraulicPlatform platform, @NotNull HydraulicBootstrap bootstrap) {\n        if (instance != null) {\n            throw new IllegalStateException(\"Singleton HydraulicImpl has already been loaded!\");\n        }\n\n        return new HydraulicImpl(platform, bootstrap);\n    }\n\n    /**\n     * Gets the Hydraulic instance.\n     *\n     * @return the Hydraulic instance\n     */\n    @NotNull", "    public static HydraulicImpl instance() {\n        if (instance == null) {\n            throw new IllegalStateException(\"Hydraulic has not been loaded!\");\n        }\n\n        return instance;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/item/CreativeMapping.java", "chunked_list": ["package org.geysermc.hydraulic.item;\n\nimport org.geysermc.geyser.api.util.CreativeCategory;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Represents a creative mapping for the creative\n * group and {@link CreativeCategory category}.\n */\npublic record CreativeMapping(@NotNull String creativeGroup, @NotNull CreativeCategory creativeCategory) {\n    public CreativeMapping(String creativeGroup) {\n        this(creativeGroup, CreativeCategory.ITEMS);\n    }\n\n    public CreativeMapping(CreativeCategory creativeCategory) {\n        this(switch (creativeCategory) {\n            case COMMANDS -> \"itemGroup.name.commands\";\n            case CONSTRUCTION -> \"itemGroup.name.construction\";\n            case EQUIPMENT -> \"itemGroup.name.equipment\";\n            case NATURE -> \"itemGroup.name.nature\";\n            case ITEMS, NONE -> \"itemGroup.name.items\";\n        }, creativeCategory);\n    }\n}\n", " */\npublic record CreativeMapping(@NotNull String creativeGroup, @NotNull CreativeCategory creativeCategory) {\n    public CreativeMapping(String creativeGroup) {\n        this(creativeGroup, CreativeCategory.ITEMS);\n    }\n\n    public CreativeMapping(CreativeCategory creativeCategory) {\n        this(switch (creativeCategory) {\n            case COMMANDS -> \"itemGroup.name.commands\";\n            case CONSTRUCTION -> \"itemGroup.name.construction\";\n            case EQUIPMENT -> \"itemGroup.name.equipment\";\n            case NATURE -> \"itemGroup.name.nature\";\n            case ITEMS, NONE -> \"itemGroup.name.items\";\n        }, creativeCategory);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/item/CreativeMappings.java", "chunked_list": ["package org.geysermc.hydraulic.item;\n\nimport net.minecraft.world.item.*;\nimport org.geysermc.geyser.api.item.custom.NonVanillaCustomItemData;\nimport org.geysermc.geyser.api.util.CreativeCategory;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**", "\n/**\n * Contains mappings for items to their creative groups and categories.\n */\npublic class CreativeMappings {\n    private static final Map<Class<? extends Item>, CreativeMapping> CREATIVE_MAPPINGS = new HashMap<>() {\n        {\n            put(ArmorItem.class, new CreativeMapping(CreativeCategory.EQUIPMENT));\n            put(ArrowItem.class, new CreativeMapping(\"itemGroup.name.arrow\", CreativeCategory.EQUIPMENT));\n            put(AxeItem.class, new CreativeMapping(\"itemGroup.name.axe\", CreativeCategory.EQUIPMENT));\n            put(BannerPatternItem.class, new CreativeMapping(\"itemGroup.name.banner_pattern\"));\n            put(BowItem.class, new CreativeMapping(CreativeCategory.EQUIPMENT));\n            put(HoeItem.class, new CreativeMapping(\"itemGroup.name.hoe\", CreativeCategory.EQUIPMENT));\n            put(HorseArmorItem.class, new CreativeMapping(\"itemGroup.name.horseArmor\", CreativeCategory.EQUIPMENT));\n            put(MinecartItem.class, new CreativeMapping(\"itemGroup.name.minecart\"));\n            put(PickaxeItem.class, new CreativeMapping(\"itemGroup.name.pickaxe\", CreativeCategory.EQUIPMENT));\n            put(RecordItem.class, new CreativeMapping(\"itemGroup.name.record\"));\n            put(ShearsItem.class, new CreativeMapping(CreativeCategory.EQUIPMENT));\n            put(ShovelItem.class, new CreativeMapping(\"itemGroup.name.shovel\", CreativeCategory.EQUIPMENT));\n            put(SpawnEggItem.class, new CreativeMapping(\"itemGroup.name.mobEgg\", CreativeCategory.NATURE));\n            put(SwordItem.class, new CreativeMapping(\"itemGroup.name.sword\", CreativeCategory.EQUIPMENT));\n\n            // Fallbacks for more base level classes\n            put(TieredItem.class, new CreativeMapping(CreativeCategory.EQUIPMENT));\n        }\n    };\n\n    static void setup(Item item, NonVanillaCustomItemData.Builder customItemBuilder) {\n        CreativeMapping mapping = CREATIVE_MAPPINGS.get(item.getClass());\n\n        // Try find any inheritance mappings", "        if (mapping == null) {\n            for (Map.Entry<Class<? extends Item>, CreativeMapping> entry : CREATIVE_MAPPINGS.entrySet()) {\n                if (entry.getKey().isAssignableFrom(item.getClass())) {\n                    mapping = entry.getValue();\n                    break;\n                }\n            }\n        }\n\n        if (mapping == null) {\n            return;\n        }\n\n        customItemBuilder.creativeGroup(mapping.creativeGroup()).creativeCategory(mapping.creativeCategory().id());\n    }\n}\n", "        if (mapping == null) {\n            return;\n        }\n\n        customItemBuilder.creativeGroup(mapping.creativeGroup()).creativeCategory(mapping.creativeCategory().id());\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/item/BowPackModule.java", "chunked_list": ["package org.geysermc.hydraulic.item;\n\nimport com.google.auto.service.AutoService;\nimport net.kyori.adventure.key.Key;\nimport net.minecraft.core.registries.BuiltInRegistries;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.world.item.BowItem;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.TexturePackModule;", "import org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.TexturePackModule;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.bedrock.resource.attachables.Attachable;\nimport org.geysermc.pack.bedrock.resource.attachables.Attachables;\nimport org.geysermc.pack.bedrock.resource.attachables.attachable.Description;\nimport org.geysermc.pack.bedrock.resource.attachables.attachable.description.Scripts;\nimport org.geysermc.pack.bedrock.resource.render_controllers.RenderControllers;\nimport org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.Arrays;", "import org.geysermc.pack.bedrock.resource.render_controllers.RenderControllers;\nimport org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.Arrays;\nimport org.geysermc.pack.converter.PackConversionContext;\nimport org.geysermc.pack.converter.data.TextureConversionData;\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.model.ItemOverride;\nimport team.unnamed.creative.model.ItemPredicate;\nimport team.unnamed.creative.model.Model;\nimport team.unnamed.creative.model.ModelTexture;", "import team.unnamed.creative.model.Model;\nimport team.unnamed.creative.model.ModelTexture;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@AutoService(PackModule.class)\npublic class BowPackModule extends TexturePackModule<BowPackModule> {\n    private static final Map<String, String> ATTACHABLE_MATERIALS = new HashMap<>() {\n        {\n            put(\"default\", \"entity_alphatest\");\n            put(\"enchanted\", \"entity_alphatest_glint\");\n        }\n    };\n    private static final Map<String, String> ATTACHABLE_GEOMETRY = new HashMap<>() {\n        {\n            put(\"default\", \"geometry.bow_standby\");\n            put(\"bow_pulling_0\", \"geometry.bow_pulling_0\");\n            put(\"bow_pulling_1\", \"geometry.bow_pulling_1\");\n            put(\"bow_pulling_2\", \"geometry.bow_pulling_2\");\n        }\n    };\n    private static final Map<String, String> ATTACHABLE_ANIMATIONS = new HashMap<>() {\n        {\n            put(\"wield\", \"animation.bow.wield\");\n            put(\"wield_first_person_pull\", \"animation.bow.wield_first_person_pull\");\n        }\n    };\n    private static final Scripts ATTACHABLE_SCRIPTS = new Scripts();\n\n    static {\n        ATTACHABLE_SCRIPTS.preAnimation(new String[] {\n            \"v.charge_amount = math.clamp((q.main_hand_item_max_duration - (q.main_hand_item_use_duration - q.frame_alpha + 1.0)) / 10.0, 0.0, 1.0f);\",\n            \"v.total_frames = 3;\",\n            \"v.step = v.total_frames / 120;\",\n            \"v.frame = query.is_using_item ? math.clamp((v.frame ?? 0) + v.step, 1, v.total_frames) : 0;\"\n        });\n        ATTACHABLE_SCRIPTS.animate(List.of(\n            Map.of(\"wield\", \"c.is_first_person\"),\n            Map.of(\"wield_first_person_pull\", \"query.main_hand_item_use_duration > 0.0f && c.is_first_person\")\n        ));\n    }\n\n    @Override", "public class BowPackModule extends TexturePackModule<BowPackModule> {\n    private static final Map<String, String> ATTACHABLE_MATERIALS = new HashMap<>() {\n        {\n            put(\"default\", \"entity_alphatest\");\n            put(\"enchanted\", \"entity_alphatest_glint\");\n        }\n    };\n    private static final Map<String, String> ATTACHABLE_GEOMETRY = new HashMap<>() {\n        {\n            put(\"default\", \"geometry.bow_standby\");\n            put(\"bow_pulling_0\", \"geometry.bow_pulling_0\");\n            put(\"bow_pulling_1\", \"geometry.bow_pulling_1\");\n            put(\"bow_pulling_2\", \"geometry.bow_pulling_2\");\n        }\n    };\n    private static final Map<String, String> ATTACHABLE_ANIMATIONS = new HashMap<>() {\n        {\n            put(\"wield\", \"animation.bow.wield\");\n            put(\"wield_first_person_pull\", \"animation.bow.wield_first_person_pull\");\n        }\n    };\n    private static final Scripts ATTACHABLE_SCRIPTS = new Scripts();\n\n    static {\n        ATTACHABLE_SCRIPTS.preAnimation(new String[] {\n            \"v.charge_amount = math.clamp((q.main_hand_item_max_duration - (q.main_hand_item_use_duration - q.frame_alpha + 1.0)) / 10.0, 0.0, 1.0f);\",\n            \"v.total_frames = 3;\",\n            \"v.step = v.total_frames / 120;\",\n            \"v.frame = query.is_using_item ? math.clamp((v.frame ?? 0) + v.step, 1, v.total_frames) : 0;\"\n        });\n        ATTACHABLE_SCRIPTS.animate(List.of(\n            Map.of(\"wield\", \"c.is_first_person\"),\n            Map.of(\"wield_first_person_pull\", \"query.main_hand_item_use_duration > 0.0f && c.is_first_person\")\n        ));\n    }\n\n    @Override", "    public void postConvert(PackConversionContext<TextureConversionData> packContext) {\n        ResourcePack assets = packContext.javaResourcePack();\n        BedrockResourcePack bedrockPack = packContext.bedrockResourcePack();\n\n        this.postProcess(context -> {\n            List<BowItem> bowItems = context.registryValues(Registries.ITEM).stream()\n                    .filter(item -> item instanceof BowItem)\n                    .map(item -> (BowItem) item)\n                    .toList();\n\n            LOGGER.info(\"Bows to convert: \" + bowItems.size() + \" in mod \" + context.mod().id());\n", "            for (BowItem bowItem : bowItems) {\n                ResourceLocation bowLocation = BuiltInRegistries.ITEM.getKey(bowItem);\n                Map<String, String> textures = new HashMap<>() {\n                    {\n                        put(\"enchanted\", \"textures/misc/enchanted_item_glint\");\n                    }\n                };\n\n                Model model = assets.model(Key.key(bowLocation.getNamespace(), \"item/\" + bowLocation.getPath()));\n                if (model == null || model.textures() == null) {\n                    LOGGER.warn(\"Bow {} has no model, skipping\", bowLocation);\n                    continue;\n                }\n\n                List<ModelTexture> layers = model.textures().layers();", "                if (model == null || model.textures() == null) {\n                    LOGGER.warn(\"Bow {} has no model, skipping\", bowLocation);\n                    continue;\n                }\n\n                List<ModelTexture> layers = model.textures().layers();\n                if (layers == null || layers.isEmpty()) {\n                    LOGGER.warn(\"Bow {} has no layer0 texture, skipping\", bowLocation);\n                    continue;\n                }\n\n                ModelTexture layer0 = layers.get(0);\n                String defaultOutputLoc = getOutputFromModel(context, layer0.key()).replace(\".png\", \"\");\n\n                textures.put(\"default\", defaultOutputLoc);\n", "                for (ItemOverride override : model.overrides()) {\n                    Model pullingModel = assets.model(override.model());\n                    if (pullingModel == null || pullingModel.textures() == null) {\n                        LOGGER.warn(\"Bow pulling model {} has no model, skipping\", override.model());\n                        continue;\n                    }\n\n                    List<ModelTexture> pullingLayers = pullingModel.textures().layers();\n                    if (pullingLayers == null || pullingLayers.isEmpty()) {\n                        LOGGER.warn(\"Bow pulling model {} has no layer0 texture, skipping\", override.model());\n                        continue;\n                    }\n\n                    ModelTexture pullingLayer0 = pullingLayers.get(0);\n                    String outputLoc = getOutputFromModel(context, pullingLayer0.key()).replace(\".png\", \"\");\n\n                    Map<String, Float> predicate = new HashMap<>();", "                    if (pullingLayers == null || pullingLayers.isEmpty()) {\n                        LOGGER.warn(\"Bow pulling model {} has no layer0 texture, skipping\", override.model());\n                        continue;\n                    }\n\n                    ModelTexture pullingLayer0 = pullingLayers.get(0);\n                    String outputLoc = getOutputFromModel(context, pullingLayer0.key()).replace(\".png\", \"\");\n\n                    Map<String, Float> predicate = new HashMap<>();\n                    for (ItemPredicate itemPredicate : override.predicate()) {\n                        if (itemPredicate.value() instanceof Number number) {\n                            predicate.put(itemPredicate.name(), number.floatValue());\n                        }\n                    }\n", "                    for (ItemPredicate itemPredicate : override.predicate()) {\n                        if (itemPredicate.value() instanceof Number number) {\n                            predicate.put(itemPredicate.name(), number.floatValue());\n                        }\n                    }\n\n                    if (!predicate.containsKey(\"pull\") || predicate.get(\"pull\") == 0f) {\n                        textures.put(\"bow_pulling_0\", outputLoc);\n                    } else if (predicate.get(\"pull\") == 0.65f) {\n                        textures.put(\"bow_pulling_1\", outputLoc);\n                    } else if (predicate.get(\"pull\") == 0.9f) {\n                        textures.put(\"bow_pulling_2\", outputLoc);\n                    }\n                }\n\n                Attachables armorAttachable = new Attachables();\n                armorAttachable.formatVersion(\"1.10.0\");\n\n                Description description = new Description();\n                description.identifier(bowLocation.toString());\n                description.materials(ATTACHABLE_MATERIALS);\n                description.geometry(ATTACHABLE_GEOMETRY);\n                description.animations(ATTACHABLE_ANIMATIONS);\n                description.scripts(ATTACHABLE_SCRIPTS);\n                description.renderControllers(new String[] {\"controller.render.bow_custom\"});\n\n                description.textures(textures);\n\n                Attachable attachable = new Attachable();\n                attachable.description(description);\n                armorAttachable.attachable(attachable);\n\n                bedrockPack.addAttachable(armorAttachable, \"attachables/\" + bowLocation.getPath() + \".json\");\n            }\n\n            RenderControllers renderController = new RenderControllers();\n            renderController.formatVersion(\"1.10.0\");\n\n            org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.RenderControllers bowCustomRenderController = new org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.RenderControllers();\n            bowCustomRenderController.arrays(new Arrays());\n\n            bowCustomRenderController.arrays().textures().put(\"array.bow_texture_frames\", new String[] {\n                    \"texture.default\",\n                    \"texture.bow_pulling_0\",\n                    \"texture.bow_pulling_1\",\n                    \"texture.bow_pulling_2\"\n            });\n\n            bowCustomRenderController.arrays().geometries().put(\"array.bow_geo_frames\", new String[] {\n                    \"geometry.default\",\n                    \"geometry.bow_pulling_0\",\n                    \"geometry.bow_pulling_1\",\n                    \"geometry.bow_pulling_2\"\n            });\n\n            bowCustomRenderController.geometry(\"array.bow_geo_frames[math.floor(v.frame)]\");\n            bowCustomRenderController.materials().add(Map.of(\"*\", \"variable.is_enchanted ? material.enchanted : material.default\"));\n            bowCustomRenderController.textures(new String[] {\n                    \"array.bow_texture_frames[math.floor(v.frame)]\",\n                    \"texture.enchanted\"\n            });\n\n            renderController.renderControllers().put(\"controller.render.bow_custom\", bowCustomRenderController);\n            bedrockPack.addRenderController(renderController, \"render_controllers/bow_custom.render_controllers.json\");\n        });\n    }\n\n    @Override", "                    } else if (predicate.get(\"pull\") == 0.65f) {\n                        textures.put(\"bow_pulling_1\", outputLoc);\n                    } else if (predicate.get(\"pull\") == 0.9f) {\n                        textures.put(\"bow_pulling_2\", outputLoc);\n                    }\n                }\n\n                Attachables armorAttachable = new Attachables();\n                armorAttachable.formatVersion(\"1.10.0\");\n\n                Description description = new Description();\n                description.identifier(bowLocation.toString());\n                description.materials(ATTACHABLE_MATERIALS);\n                description.geometry(ATTACHABLE_GEOMETRY);\n                description.animations(ATTACHABLE_ANIMATIONS);\n                description.scripts(ATTACHABLE_SCRIPTS);\n                description.renderControllers(new String[] {\"controller.render.bow_custom\"});\n\n                description.textures(textures);\n\n                Attachable attachable = new Attachable();\n                attachable.description(description);\n                armorAttachable.attachable(attachable);\n\n                bedrockPack.addAttachable(armorAttachable, \"attachables/\" + bowLocation.getPath() + \".json\");\n            }\n\n            RenderControllers renderController = new RenderControllers();\n            renderController.formatVersion(\"1.10.0\");\n\n            org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.RenderControllers bowCustomRenderController = new org.geysermc.pack.bedrock.resource.render_controllers.rendercontrollers.RenderControllers();\n            bowCustomRenderController.arrays(new Arrays());\n\n            bowCustomRenderController.arrays().textures().put(\"array.bow_texture_frames\", new String[] {\n                    \"texture.default\",\n                    \"texture.bow_pulling_0\",\n                    \"texture.bow_pulling_1\",\n                    \"texture.bow_pulling_2\"\n            });\n\n            bowCustomRenderController.arrays().geometries().put(\"array.bow_geo_frames\", new String[] {\n                    \"geometry.default\",\n                    \"geometry.bow_pulling_0\",\n                    \"geometry.bow_pulling_1\",\n                    \"geometry.bow_pulling_2\"\n            });\n\n            bowCustomRenderController.geometry(\"array.bow_geo_frames[math.floor(v.frame)]\");\n            bowCustomRenderController.materials().add(Map.of(\"*\", \"variable.is_enchanted ? material.enchanted : material.default\"));\n            bowCustomRenderController.textures(new String[] {\n                    \"array.bow_texture_frames[math.floor(v.frame)]\",\n                    \"texture.enchanted\"\n            });\n\n            renderController.renderControllers().put(\"controller.render.bow_custom\", bowCustomRenderController);\n            bedrockPack.addRenderController(renderController, \"render_controllers/bow_custom.render_controllers.json\");\n        });\n    }\n\n    @Override", "    public boolean test(@NotNull PackPostProcessContext<BowPackModule> context) {\n        return context.registryValues(Registries.ITEM).stream().anyMatch(item -> item instanceof BowItem);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/item/ArmorPackModule.java", "chunked_list": ["package org.geysermc.hydraulic.item;\n\nimport com.google.auto.service.AutoService;\nimport net.minecraft.core.registries.BuiltInRegistries;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.world.entity.EquipmentSlot;\nimport net.minecraft.world.item.ArmorItem;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;", "import org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.pack.bedrock.resource.attachables.Attachable;\nimport org.geysermc.pack.bedrock.resource.attachables.Attachables;\nimport org.geysermc.pack.bedrock.resource.attachables.attachable.Description;\nimport org.geysermc.pack.bedrock.resource.attachables.attachable.description.Scripts;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.HashMap;\nimport java.util.List;", "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@AutoService(PackModule.class)\npublic class ArmorPackModule extends PackModule<ArmorPackModule> {\n    private static final String BEDROCK_ARMOR_TEXTURE_LOCATION = \"textures/models/%s/armor/%s_layer_%s\";\n\n    private static final Map<String, String> ATTACHABLE_MATERIALS = new HashMap<>() {\n        {\n            put(\"default\", \"armor\");\n            put(\"enchanted\", \"armor_enchanted\");\n        }\n    };\n    private static final Scripts ATTACHABLE_SCRIPTS = new Scripts();\n\n    static {\n        ATTACHABLE_SCRIPTS.parentSetup(\"variable.chest_layer_visible = 0.0;\");\n    }\n\n    public ArmorPackModule() {\n        this.postProcess(this::postProcess);\n    }\n", "    public void postProcess(@NotNull PackPostProcessContext<ArmorPackModule> context) {\n        List<ArmorItem> armorItems = context.registryValues(Registries.ITEM).stream()\n                .filter(item -> item instanceof ArmorItem)\n                .map(item -> (ArmorItem) item)\n                .toList();\n\n        LOGGER.info(\"Armor to convert: \" + armorItems.size() + \" in mod \" + context.mod().id());\n\n        for (ArmorItem armorItem : armorItems) {\n            ResourceLocation armorItemLocation = BuiltInRegistries.ITEM.getKey(armorItem);\n\n            ResourceLocation armorTextureLocation = new ResourceLocation(armorItem.getMaterial().getName());\n\n            Attachables armorAttachable = new Attachables();\n            armorAttachable.formatVersion(\"1.10.0\");\n\n            Description description = new Description();\n            description.identifier(armorItemLocation.toString());\n            description.materials(ATTACHABLE_MATERIALS);\n            description.scripts(ATTACHABLE_SCRIPTS);\n            description.renderControllers(new String[] { \"controller.render.armor\" });\n\n            description.textures(new HashMap<>() {\n                {\n                    put(\"default\", String.format(BEDROCK_ARMOR_TEXTURE_LOCATION, context.mod().id(), armorTextureLocation.getPath(), (armorItem.getEquipmentSlot() == EquipmentSlot.LEGS ? 2 : 1)));\n                    put(\"enchanted\", \"textures/misc/enchanted_item_glint\");\n                }\n            });\n\n            String geometryType = \"\";\n            switch (armorItem.getEquipmentSlot()) {\n                case HEAD -> geometryType = \"helmet\";\n                case CHEST -> geometryType = \"chestplate\";\n                case LEGS -> geometryType = \"leggings\";\n                case FEET -> geometryType = \"boots\";\n            }\n\n            final String finalGeometryType = geometryType;\n            description.geometry(Map.of(\"default\", \"geometry.player.armor.\" + finalGeometryType));\n\n            Attachable attachable = new Attachable();\n            attachable.description(description);\n            armorAttachable.attachable(attachable);\n\n            context.pack().addAttachable(armorAttachable, \"attachables/\" + armorItemLocation.getPath() + \".json\");\n        }\n    }\n\n    @Override", "        for (ArmorItem armorItem : armorItems) {\n            ResourceLocation armorItemLocation = BuiltInRegistries.ITEM.getKey(armorItem);\n\n            ResourceLocation armorTextureLocation = new ResourceLocation(armorItem.getMaterial().getName());\n\n            Attachables armorAttachable = new Attachables();\n            armorAttachable.formatVersion(\"1.10.0\");\n\n            Description description = new Description();\n            description.identifier(armorItemLocation.toString());\n            description.materials(ATTACHABLE_MATERIALS);\n            description.scripts(ATTACHABLE_SCRIPTS);\n            description.renderControllers(new String[] { \"controller.render.armor\" });\n\n            description.textures(new HashMap<>() {\n                {\n                    put(\"default\", String.format(BEDROCK_ARMOR_TEXTURE_LOCATION, context.mod().id(), armorTextureLocation.getPath(), (armorItem.getEquipmentSlot() == EquipmentSlot.LEGS ? 2 : 1)));\n                    put(\"enchanted\", \"textures/misc/enchanted_item_glint\");\n                }\n            });\n\n            String geometryType = \"\";\n            switch (armorItem.getEquipmentSlot()) {\n                case HEAD -> geometryType = \"helmet\";\n                case CHEST -> geometryType = \"chestplate\";\n                case LEGS -> geometryType = \"leggings\";\n                case FEET -> geometryType = \"boots\";\n            }\n\n            final String finalGeometryType = geometryType;\n            description.geometry(Map.of(\"default\", \"geometry.player.armor.\" + finalGeometryType));\n\n            Attachable attachable = new Attachable();\n            attachable.description(description);\n            armorAttachable.attachable(attachable);\n\n            context.pack().addAttachable(armorAttachable, \"attachables/\" + armorItemLocation.getPath() + \".json\");\n        }\n    }\n\n    @Override", "    public boolean test(@NotNull PackPostProcessContext<ArmorPackModule> context) {\n        return context.registryValues(Registries.ITEM).stream().anyMatch(item -> item instanceof ArmorItem);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/item/ItemPackModule.java", "chunked_list": ["package org.geysermc.hydraulic.item;\n\nimport com.google.auto.service.AutoService;\nimport net.kyori.adventure.key.Key;\nimport net.minecraft.core.DefaultedRegistry;\nimport net.minecraft.core.registries.BuiltInRegistries;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.world.item.*;\nimport org.geysermc.geyser.api.event.lifecycle.GeyserDefineCustomItemsEvent;", "import net.minecraft.world.item.*;\nimport org.geysermc.geyser.api.event.lifecycle.GeyserDefineCustomItemsEvent;\nimport org.geysermc.geyser.api.item.custom.NonVanillaCustomItemData;\nimport org.geysermc.geyser.api.util.CreativeCategory;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.TexturePackModule;\nimport org.geysermc.hydraulic.pack.context.PackEventContext;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.converter.PackConversionContext;", "import org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.converter.PackConversionContext;\nimport org.geysermc.pack.converter.data.TextureConversionData;\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.model.Model;\nimport team.unnamed.creative.model.ModelTexture;\n\nimport java.util.List;\n", "import java.util.List;\n\n@AutoService(PackModule.class)\npublic class ItemPackModule extends TexturePackModule<ItemPackModule> {\n\n    public ItemPackModule() {\n        this.listenOn(GeyserDefineCustomItemsEvent.class, ItemPackModule::onDefineCustomItems);\n    }\n\n    @Override\n    public void postConvert(PackConversionContext<TextureConversionData> packContext) {\n        ResourcePack assets = packContext.javaResourcePack();\n        BedrockResourcePack bedrockPack = packContext.bedrockResourcePack();\n\n        this.postProcess(context -> {\n            List<Item> items = context.registryValues(Registries.ITEM);\n\n            LOGGER.info(\"Items to convert: \" + items.size() + \" in mod \" + context.mod().id());\n", "    public void postConvert(PackConversionContext<TextureConversionData> packContext) {\n        ResourcePack assets = packContext.javaResourcePack();\n        BedrockResourcePack bedrockPack = packContext.bedrockResourcePack();\n\n        this.postProcess(context -> {\n            List<Item> items = context.registryValues(Registries.ITEM);\n\n            LOGGER.info(\"Items to convert: \" + items.size() + \" in mod \" + context.mod().id());\n\n            for (Item item : items) {\n                ResourceLocation itemLocation = BuiltInRegistries.ITEM.getKey(item);\n\n                Model model = assets.model(Key.key(itemLocation.getNamespace(), \"item/\" + itemLocation.getPath()));", "            for (Item item : items) {\n                ResourceLocation itemLocation = BuiltInRegistries.ITEM.getKey(item);\n\n                Model model = assets.model(Key.key(itemLocation.getNamespace(), \"item/\" + itemLocation.getPath()));\n                if (model == null || model.textures() == null) {\n                    LOGGER.warn(\"Item {} has no model, skipping\", itemLocation);\n                    continue;\n                }\n\n                List<ModelTexture> layers = model.textures().layers();\n                if (layers == null || layers.isEmpty()) {\n                    LOGGER.warn(\"Item {} has no layer0 texture, skipping\", itemLocation);\n                    continue;\n                }\n\n                ModelTexture layer0 = layers.get(0);\n                String outputLoc = getOutputFromModel(context, layer0.key());\n                bedrockPack.addItemTexture(itemLocation.toString(), outputLoc.replace(\".png\", \"\"));\n            }\n        });\n    }\n\n    @Override", "                if (layers == null || layers.isEmpty()) {\n                    LOGGER.warn(\"Item {} has no layer0 texture, skipping\", itemLocation);\n                    continue;\n                }\n\n                ModelTexture layer0 = layers.get(0);\n                String outputLoc = getOutputFromModel(context, layer0.key());\n                bedrockPack.addItemTexture(itemLocation.toString(), outputLoc.replace(\".png\", \"\"));\n            }\n        });\n    }\n\n    @Override", "    public boolean test(@NotNull PackPostProcessContext<ItemPackModule> context) {\n        return context.registryValues(Registries.ITEM).size() > 0;\n    }\n\n    private static void onDefineCustomItems(PackEventContext<GeyserDefineCustomItemsEvent, ItemPackModule> context) {\n        GeyserDefineCustomItemsEvent event = context.event();\n        List<Item> items = context.registryValues(Registries.ITEM);\n\n        DefaultedRegistry<Item> registry = BuiltInRegistries.ITEM;\n        for (Item item : items) {\n            ResourceLocation itemLocation = registry.getKey(item);\n            NonVanillaCustomItemData.Builder customItemBuilder = NonVanillaCustomItemData.builder()\n                .name(itemLocation.getPath())\n                .displayName(\"%\" + item.getDescriptionId())\n                .identifier(itemLocation.toString())\n                .icon(itemLocation.toString())\n                .javaId(registry.getId(item))\n                .stackSize(item.getMaxStackSize())\n                .maxDamage(item.getMaxDamage())\n                .allowOffhand(true)\n                .creativeCategory(CreativeCategory.ITEMS.id())\n                .creativeGroup(\"itemGroup.name.items\")\n                .maxDamage(item.getMaxDamage())\n                .stackSize(item.getMaxStackSize());\n\n            // Enchantment glint by default", "        for (Item item : items) {\n            ResourceLocation itemLocation = registry.getKey(item);\n            NonVanillaCustomItemData.Builder customItemBuilder = NonVanillaCustomItemData.builder()\n                .name(itemLocation.getPath())\n                .displayName(\"%\" + item.getDescriptionId())\n                .identifier(itemLocation.toString())\n                .icon(itemLocation.toString())\n                .javaId(registry.getId(item))\n                .stackSize(item.getMaxStackSize())\n                .maxDamage(item.getMaxDamage())\n                .allowOffhand(true)\n                .creativeCategory(CreativeCategory.ITEMS.id())\n                .creativeGroup(\"itemGroup.name.items\")\n                .maxDamage(item.getMaxDamage())\n                .stackSize(item.getMaxStackSize());\n\n            // Enchantment glint by default", "            if (item.isFoil(item.getDefaultInstance())) {\n                customItemBuilder.foil(true);\n            }\n\n            if (item.isEdible()) {\n                customItemBuilder\n                        .creativeCategory(CreativeCategory.EQUIPMENT.id())\n                        .creativeGroup(\"itemGroup.name.miscFood\")\n                        .edible(true);\n\n                if (item.getFoodProperties() != null) {\n                    customItemBuilder\n                            .canAlwaysEat(item.getFoodProperties().canAlwaysEat());\n                }\n            }\n\n            CreativeMappings.setup(item, customItemBuilder);\n", "                if (item.getFoodProperties() != null) {\n                    customItemBuilder\n                            .canAlwaysEat(item.getFoodProperties().canAlwaysEat());\n                }\n            }\n\n            CreativeMappings.setup(item, customItemBuilder);\n\n            if (item instanceof ArmorItem armorItem) {\n                customItemBuilder.protectionValue(armorItem.getDefense());\n                switch (armorItem.getEquipmentSlot()) {\n                    case HEAD -> customItemBuilder.armorType(\"helmet\").creativeGroup(\"itemGroup.name.helmet\");\n                    case CHEST -> customItemBuilder.armorType(\"chestplate\").creativeGroup(\"itemGroup.name.chestplate\");\n                    case LEGS -> customItemBuilder.armorType(\"leggings\").creativeGroup(\"itemGroup.name.leggings\");\n                    case FEET -> customItemBuilder.armorType(\"boots\").creativeGroup(\"itemGroup.name.boots\");\n                }", "            if (item instanceof ArmorItem armorItem) {\n                customItemBuilder.protectionValue(armorItem.getDefense());\n                switch (armorItem.getEquipmentSlot()) {\n                    case HEAD -> customItemBuilder.armorType(\"helmet\").creativeGroup(\"itemGroup.name.helmet\");\n                    case CHEST -> customItemBuilder.armorType(\"chestplate\").creativeGroup(\"itemGroup.name.chestplate\");\n                    case LEGS -> customItemBuilder.armorType(\"leggings\").creativeGroup(\"itemGroup.name.leggings\");\n                    case FEET -> customItemBuilder.armorType(\"boots\").creativeGroup(\"itemGroup.name.boots\");\n                }\n            } else if (item instanceof TieredItem tieredItem) {\n                customItemBuilder.displayHandheld(true); // So we hold the tool right\n\n                // TODO Support custom tiers\n                customItemBuilder.toolTier(\"DIAMOND\");", "            } else if (item instanceof TieredItem tieredItem) {\n                customItemBuilder.displayHandheld(true); // So we hold the tool right\n\n                // TODO Support custom tiers\n                customItemBuilder.toolTier(\"DIAMOND\");\n                if (tieredItem.getTier() instanceof Tiers) {\n                    customItemBuilder.toolTier(tieredItem.getTier().toString());\n                }\n\n                if (item instanceof PickaxeItem) {\n                    customItemBuilder.toolType(\"pickaxe\");", "                if (item instanceof PickaxeItem) {\n                    customItemBuilder.toolType(\"pickaxe\");\n                } else if (item instanceof HoeItem) {\n                    customItemBuilder.toolType(\"hoe\");\n                } else if (item instanceof AxeItem) {\n                    customItemBuilder.toolType(\"axe\");\n                } else if (item instanceof ShovelItem) {\n                    customItemBuilder.toolType(\"shovel\");\n                } else if (item instanceof SwordItem) {\n                    customItemBuilder.toolType(\"sword\");\n                }", "                } else if (item instanceof SwordItem) {\n                    customItemBuilder.toolType(\"sword\");\n                }\n            } else if (item instanceof ShearsItem) {\n                customItemBuilder.toolType(\"shears\");\n            } else if (item instanceof BowItem) {\n                customItemBuilder.chargeable(true);\n            }\n\n            event.register(customItemBuilder.build());\n        }\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/PackModule.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport com.mojang.logging.LogUtils;\nimport org.geysermc.event.Event;\nimport org.geysermc.hydraulic.pack.context.PackEventContext;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.hydraulic.pack.context.PackPreProcessContext;\nimport org.jetbrains.annotations.NotNull;\nimport org.slf4j.Logger;\n", "import org.slf4j.Logger;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\n/**\n * Represents a pack module.", "/**\n * Represents a pack module.\n * <p>\n * Pack modules handle converting data from the Minecraft\n * server into a pack that the Bedrock client can understand.\n * <p>\n * These are split up based on each specific aspect of the pack,\n * such as blocks, items, entities, etc. Certain pack loaders\n * may have more complex behaviors, such as listening on certain\n * events inside to register needed data into Geyser, such as", " * may have more complex behaviors, such as listening on certain\n * events inside to register needed data into Geyser, such as\n * items.\n *\n * @param <T> the pack module\n */\npublic abstract class PackModule<T extends PackModule<T>> {\n    protected static Logger LOGGER = LogUtils.getLogger();\n\n    private final Map<Class<? extends Event>, List<Consumer<PackEventContext<?, T>>>> eventListeners = new HashMap<>();\n\n    private final List<Consumer<PackPreProcessContext<T>>> preProcessors = new ArrayList<>();\n    private final List<Consumer<PackPostProcessContext<T>>> postProcessors = new ArrayList<>();\n\n    /**\n     * Adds a pre processor to this pack module.\n     *\n     * @param preProcessor the pre processor\n     */", "    public final void preProcess(@NotNull Consumer<PackPreProcessContext<T>> preProcessor) {\n        this.preProcessors.add(preProcessor);\n    }\n\n    /**\n     * Adds a post processor to this pack module.\n     *\n     * @param postProcessor the post processor\n     */\n    public final void postProcess(@NotNull Consumer<PackPostProcessContext<T>> postProcessor) {\n        this.postProcessors.add(postProcessor);\n    }\n\n    /**\n     * Tests if this pack module should be used.\n     *\n     * @param context the context of the pack\n     * @return if this pack module should be used\n     */", "    public final void postProcess(@NotNull Consumer<PackPostProcessContext<T>> postProcessor) {\n        this.postProcessors.add(postProcessor);\n    }\n\n    /**\n     * Tests if this pack module should be used.\n     *\n     * @param context the context of the pack\n     * @return if this pack module should be used\n     */\n    public boolean test(@NotNull PackPostProcessContext<T> context) {\n        return true;\n    }\n\n    /**\n     * Listens on the given {@link Event event}.\n     *\n     * @param event the event to listen on\n     * @param eventConsumer the event consumer\n     * @param <E> the event type\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public <E extends Event> void listenOn(@NotNull Class<E> event, @NotNull Consumer<PackEventContext<E, T>> eventConsumer) {\n        this.eventListeners.computeIfAbsent(event, v -> new ArrayList<>()).add((Consumer) eventConsumer);\n    }\n\n    boolean hasPreProcessors() {\n        return !this.preProcessors.isEmpty();\n    }\n\n    void preProcess0(@NotNull PackPreProcessContext<T> context) {", "    public boolean test(@NotNull PackPostProcessContext<T> context) {\n        return true;\n    }\n\n    /**\n     * Listens on the given {@link Event event}.\n     *\n     * @param event the event to listen on\n     * @param eventConsumer the event consumer\n     * @param <E> the event type\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public <E extends Event> void listenOn(@NotNull Class<E> event, @NotNull Consumer<PackEventContext<E, T>> eventConsumer) {\n        this.eventListeners.computeIfAbsent(event, v -> new ArrayList<>()).add((Consumer) eventConsumer);\n    }\n\n    boolean hasPreProcessors() {\n        return !this.preProcessors.isEmpty();\n    }\n\n    void preProcess0(@NotNull PackPreProcessContext<T> context) {", "        for (Consumer<PackPreProcessContext<T>> preProcessor : this.preProcessors) {\n            try {\n                preProcessor.accept(context);\n            } catch (Throwable t) {\n                LOGGER.error(\"Error processing pre processor {}\", preProcessor, t);\n            }\n        }\n    }\n\n    void postProcess0(@NotNull PackPostProcessContext<T> context) {\n        for (Consumer<PackPostProcessContext<T>> postProcessor : this.postProcessors) {", "        for (Consumer<PackPostProcessContext<T>> postProcessor : this.postProcessors) {\n            try {\n                postProcessor.accept(context);\n            } catch (Throwable t) {\n                LOGGER.error(\"Error processing post processor {}\", postProcessor, t);\n            }\n        }\n    }\n\n    Map<Class<? extends Event>, List<Consumer<PackEventContext<?, T>>>> eventListeners() {\n        return this.eventListeners;\n    }\n\n    <E extends Event> void call(@NotNull Class<E> event, @NotNull PackEventContext<E, T> context) {", "        for (Map.Entry<Class<? extends Event>, List<Consumer<PackEventContext<?, T>>>> entry : this.eventListeners.entrySet()) {\n            if (!entry.getKey().isAssignableFrom(event)) {\n                continue;\n            }\n\n            List<Consumer<PackEventContext<?, T>>> listeners = entry.getValue();\n            for (Consumer<PackEventContext<?, T>> listener : listeners) {\n                try {\n                    listener.accept(context);\n                } catch (Throwable t) {\n                    LOGGER.error(\"Error processing event {}\", event, t);\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/PackManager.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport com.mojang.logging.LogUtils;\nimport org.geysermc.event.Event;\nimport org.geysermc.geyser.api.GeyserApi;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.hydraulic.pack.context.PackEventContext;\nimport org.geysermc.hydraulic.pack.context.PackPreProcessContext;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;", "import org.geysermc.hydraulic.pack.context.PackPreProcessContext;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.pack.converter.PackConverter;\nimport org.geysermc.pack.converter.converter.ActionListener;\nimport org.geysermc.pack.converter.converter.Converters;\nimport org.geysermc.pack.converter.data.ConversionData;\nimport org.geysermc.pack.converter.util.NioDirectoryFileTreeReader;\nimport org.jetbrains.annotations.NotNull;\nimport org.slf4j.Logger;\nimport team.unnamed.creative.ResourcePack;", "import org.slf4j.Logger;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.serialize.minecraft.MinecraftResourcePackReader;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.IdentityHashMap;\nimport java.util.List;", "import java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ServiceLoader;\nimport java.util.Set;\n\n/**\n * Manages packs within Hydraulic. Most of the pack conversion\n * management is done within this class, and it is also responsible\n * for loading the packs onto the server.", " * management is done within this class, and it is also responsible\n * for loading the packs onto the server.\n */\npublic class PackManager {\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    static final Set<String> IGNORED_MODS = Set.of(\n            \"minecraft\",\n            \"java\",\n            \"hydraulic\",\n            \"geyser-fabric\",\n            \"geyser-forge\",\n            \"floodgate\",\n            \"vanilla\"\n    );\n\n    private final HydraulicImpl hydraulic;\n    private final List<PackModule<?>> modules = new ArrayList<>();\n\n    public PackManager(HydraulicImpl hydraulic) {\n        this.hydraulic = hydraulic;\n    }\n\n    /**\n     * Initializes the pack manager.\n     */", "    public void initialize() {\n        for (PackModule<?> module : ServiceLoader.load(PackModule.class)) {\n            this.modules.add(module);\n\n            GeyserApi.api().eventBus().register(this.hydraulic, module);\n            module.eventListeners().forEach((eventClass, listeners) -> {\n                GeyserApi.api().eventBus().subscribe(this.hydraulic, eventClass, this::callEvents);\n            });\n\n            for (ModInfo mod : this.hydraulic.mods()) {\n                if (IGNORED_MODS.contains(mod.id())) {\n                    continue;\n                }\n", "            for (ModInfo mod : this.hydraulic.mods()) {\n                if (IGNORED_MODS.contains(mod.id())) {\n                    continue;\n                }\n\n                if (module.hasPreProcessors()) {\n                    try {\n                        ResourcePack pack = MinecraftResourcePackReader.minecraft().read(NioDirectoryFileTreeReader.read(mod.modPath()));\n\n                        PackPreProcessContext context = new PackPreProcessContext(this.hydraulic, mod, module, pack);\n                        module.preProcess0(context);\n                    } catch (Throwable t) {\n                        LOGGER.error(\"Failed to pre-process mod {} for module {}\", mod.id(), module.getClass().getSimpleName(), t);\n                    }\n                }\n            }\n        }\n\n        GeyserApi.api().eventBus().register(this.hydraulic, new PackListener(this.hydraulic, this));\n\n    }\n\n    /**\n     * Creates the pack for the given mod.\n     *\n     * @param mod the mod to create the pack for\n     * @param packPath the path to the pack\n     * @return {@code true} if the pack was created, {@code false} otherwise\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    boolean createPack(@NotNull ModInfo mod, @NotNull Path packPath) {\n        PackConverter converter = new PackConverter()\n                .logListener(new PackLogListener(LOGGER))\n                .converters(Converters.defaultConverters())\n                .input(mod.modPath(), false)\n                .output(packPath)\n                .textureSubdirectory(mod.id());\n\n        Map<Class<ConversionData>, List<ActionListener<ConversionData>>> actionListeners = new IdentityHashMap<>();", "        for (PackModule<?> module : this.modules) {\n            if (module instanceof ConvertablePackModule<?, ?> convertableModule) {\n                actionListeners.computeIfAbsent((Class<ConversionData>) convertableModule.conversionType(),\n                        e -> new ArrayList<>()).add((ConvertablePackModule<?, ConversionData>) convertableModule);\n            }\n        }\n\n        converter.actionListeners(actionListeners);\n        converter.postProcessor(pack -> {\n            for (PackModule<?> module : this.modules) {\n                PackPostProcessContext context = new PackPostProcessContext(this.hydraulic, mod, module, converter, pack, packPath);", "            for (PackModule<?> module : this.modules) {\n                PackPostProcessContext context = new PackPostProcessContext(this.hydraulic, mod, module, converter, pack, packPath);\n                if (!module.test(context)) {\n                    continue;\n                }\n\n                module.postProcess0(context);\n            }\n\n            // Set the pack name and description\n            pack.manifest().header().name(mod.name().trim() + \" Resource Pack\");\n            pack.manifest().header().description(\"Resource pack for mod \" + mod.name().trim());\n\n            // Copy the icon if it exists\n            // TODO Add a default icon?", "             if (!mod.iconPath().isEmpty()) {\n                 try {\n                     pack.icon(Files.readAllBytes(mod.modPath().resolve(mod.iconPath())));\n                 } catch (IOException ignored) { }\n             }\n        });\n\n        try {\n            converter.convert();\n        } catch (IOException ex) {\n            LOGGER.error(\"Failed to convert mod {} to pack\", mod.id(), ex);\n            return false;\n        }\n\n        // Now export the pack", "        try {\n            converter.pack();\n        } catch (IOException ex) {\n            LOGGER.error(\"Failed to export pack for mod {}\", mod.id(), ex);\n        }\n\n        return true;\n    }\n\n    private void callEvents(@NotNull Event event) {\n        for (ModInfo mod : this.hydraulic.mods()) {", "        for (ModInfo mod : this.hydraulic.mods()) {\n            if (IGNORED_MODS.contains(mod.id())) {\n                continue;\n            }\n\n            this.callEvent(mod, event);\n        }\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    private void callEvent(@NotNull ModInfo mod, @NotNull Event event) {", "        for (PackModule<?> module : this.modules) {\n            module.call(event.getClass(), new PackEventContext(this.hydraulic, mod, module, event));\n        }\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/TexturePackModule.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport net.kyori.adventure.key.Key;\nimport org.apache.commons.lang3.StringUtils;\nimport org.geysermc.hydraulic.pack.context.PackContext;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.hydraulic.util.Constants;\nimport org.geysermc.pack.converter.data.TextureConversionData;\nimport org.jetbrains.annotations.NotNull;\n\npublic abstract class TexturePackModule<T extends PackModule<T>> extends ConvertablePackModule<T, TextureConversionData> {\n\n    public TexturePackModule() {\n        super(TextureConversionData.class);\n    }\n\n    /**\n     * Gets the output location of the given key.\n     *\n     * @param packContext the pack context\n     * @param key the key\n     * @return the output location\n     */\n    protected static <T extends PackModule<T>> String getOutputFromModel(@NotNull PackContext<T> packContext, @NotNull Key key) {\n        String directory = StringUtils.substringBefore(key.value(), \"/\");\n        String remaining = StringUtils.substringAfter(key.value(), \"/\");\n        String finalDir = DIRECTORY_LOCATIONS.getOrDefault(directory, directory) + \"/\" + packContext.mod().id();\n\n        return String.format(Constants.BEDROCK_TEXTURE_LOCATION, finalDir + \"/\" + remaining);\n    }\n}\n", "import org.jetbrains.annotations.NotNull;\n\npublic abstract class TexturePackModule<T extends PackModule<T>> extends ConvertablePackModule<T, TextureConversionData> {\n\n    public TexturePackModule() {\n        super(TextureConversionData.class);\n    }\n\n    /**\n     * Gets the output location of the given key.\n     *\n     * @param packContext the pack context\n     * @param key the key\n     * @return the output location\n     */\n    protected static <T extends PackModule<T>> String getOutputFromModel(@NotNull PackContext<T> packContext, @NotNull Key key) {\n        String directory = StringUtils.substringBefore(key.value(), \"/\");\n        String remaining = StringUtils.substringAfter(key.value(), \"/\");\n        String finalDir = DIRECTORY_LOCATIONS.getOrDefault(directory, directory) + \"/\" + packContext.mod().id();\n\n        return String.format(Constants.BEDROCK_TEXTURE_LOCATION, finalDir + \"/\" + remaining);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/PackListener.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport com.mojang.logging.LogUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.geysermc.event.subscribe.Subscribe;\nimport org.geysermc.geyser.GeyserImpl;\nimport org.geysermc.geyser.api.event.lifecycle.GeyserLoadResourcePacksEvent;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.slf4j.Logger;", "import org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.slf4j.Logger;\n\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Listens for events related to packs.\n */\npublic class PackListener {\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    private final HydraulicImpl hydraulic;\n    private final PackManager manager;\n\n    public PackListener(HydraulicImpl hydraulic, PackManager manager) {\n        this.hydraulic = hydraulic;\n        this.manager = manager;\n    }\n\n    @Subscribe", " * Listens for events related to packs.\n */\npublic class PackListener {\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    private final HydraulicImpl hydraulic;\n    private final PackManager manager;\n\n    public PackListener(HydraulicImpl hydraulic, PackManager manager) {\n        this.hydraulic = hydraulic;\n        this.manager = manager;\n    }\n\n    @Subscribe", "    public void onLoadResourcePacks(GeyserLoadResourcePacksEvent event) {\n        // TODO: Add this to Geyser API\n        Path packsPath = GeyserImpl.getInstance().getBootstrap().getConfigFolder().resolve(\"packs\");\n\n        Map<String, Pair<ModInfo, Path>> packsToLoad = new HashMap<>();\n        for (ModInfo mod : this.hydraulic.mods()) {\n            if (PackManager.IGNORED_MODS.contains(mod.id())) {\n                continue;\n            }\n\n            Path packPath = packsPath.resolve(mod.id() + \".zip\");", "            if (!event.resourcePacks().contains(packPath)) {\n                packsToLoad.put(mod.id(), Pair.of(mod, packPath));\n            }\n        }\n\n        if (packsToLoad.isEmpty()) {\n            return;\n        }\n\n        LOGGER.info(\"Found {} packs to convert!\", packsToLoad.size());\n", "        for (Map.Entry<String, Pair<ModInfo, Path>> entry : packsToLoad.entrySet()) {\n            try {\n                if (this.manager.createPack(entry.getValue().getLeft(), entry.getValue().getRight())) {\n                    event.resourcePacks().add(entry.getValue().getRight());\n                }\n            } catch (Throwable t) {\n                LOGGER.error(\"Failed to convert pack for mod {}\", entry.getKey(), t);\n            }\n        }\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/PackLogListener.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport org.geysermc.pack.converter.util.LogListener;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\n\npublic class PackLogListener implements LogListener {\n    private final Logger logger;\n\n    public PackLogListener(Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override", "    public void debug(@NotNull String s) {\n        this.logger.debug(s);\n    }\n\n    @Override\n    public void info(@NotNull String s) {\n        this.logger.info(s);\n    }\n\n    @Override\n    public void warn(@NotNull String s) {\n        this.logger.warn(s);\n    }\n\n    @Override", "    public void warn(@NotNull String s) {\n        this.logger.warn(s);\n    }\n\n    @Override\n    public void error(@NotNull String s) {\n        this.logger.error(s);\n    }\n\n    @Override\n    public void error(@NotNull String s, @Nullable Throwable throwable) {\n        this.logger.error(s, throwable);\n    }\n}\n", "    public void error(@NotNull String s, @Nullable Throwable throwable) {\n        this.logger.error(s, throwable);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/ConvertablePackModule.java", "chunked_list": ["package org.geysermc.hydraulic.pack;\n\nimport org.geysermc.pack.converter.converter.ActionListener;\nimport org.geysermc.pack.converter.data.ConversionData;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Map;\n\n/**\n * Represents a pack module which listens for more complex", "/**\n * Represents a pack module which listens for more complex\n * behavior from the pack converter.\n *\n * @param <T> the pack module\n * @param <C> the conversion data\n */\npublic abstract class ConvertablePackModule<T extends PackModule<T>, C extends ConversionData> extends PackModule<T> implements ActionListener<C> {\n    protected static final Map<String, String> DIRECTORY_LOCATIONS = Map.of(\n            \"block\", \"blocks\",\n            \"item\", \"items\"\n    );\n\n    private final Class<C> conversionType;\n\n    public ConvertablePackModule(@NotNull Class<C> conversionType) {\n        this.conversionType = conversionType;\n    }\n\n    /**\n     * Gets the conversion type of this pack module.\n     *\n     * @return the conversion type\n     */", "    public final Class<C> conversionType() {\n        return this.conversionType;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/context/PackPreProcessContext.java", "chunked_list": ["package org.geysermc.hydraulic.pack.context;\n\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.ResourcePack;\n\nimport java.nio.file.Path;\n", "import java.nio.file.Path;\n\n/**\n * Represents the context of a pack before it has\n * been created.\n *\n * @param <T> the module type\n */\npublic class PackPreProcessContext<T extends PackModule<T>> extends PackContext<T> {\n    private final ResourcePack pack;\n\n    public PackPreProcessContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module, @NotNull ResourcePack pack) {\n        super(hydraulic, mod, module);\n\n        this.pack = pack;\n    }\n\n    /**\n     * Gets the pack.\n     *\n     * @return the pack\n     */\n    @NotNull", "public class PackPreProcessContext<T extends PackModule<T>> extends PackContext<T> {\n    private final ResourcePack pack;\n\n    public PackPreProcessContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module, @NotNull ResourcePack pack) {\n        super(hydraulic, mod, module);\n\n        this.pack = pack;\n    }\n\n    /**\n     * Gets the pack.\n     *\n     * @return the pack\n     */\n    @NotNull", "    public ResourcePack pack() {\n        return this.pack;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/context/PackPostProcessContext.java", "chunked_list": ["package org.geysermc.hydraulic.pack.context;\n\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.converter.PackConverter;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.nio.file.Path;", "\nimport java.nio.file.Path;\n\n/**\n * Represents the context of a pack after it has\n * been created.\n *\n * @param <T> the module type\n */\npublic class PackPostProcessContext<T extends PackModule<T>> extends PackContext<T> {\n    private final PackConverter converter;\n    private final BedrockResourcePack pack;\n    private final Path path;\n\n    public PackPostProcessContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module, @NotNull PackConverter converter, @NotNull BedrockResourcePack pack, @NotNull Path path) {\n        super(hydraulic, mod, module);\n\n        this.converter = converter;\n        this.pack = pack;\n        this.path = path;\n    }\n\n    /**\n     * Gets the pack converter.\n     *\n     * @return the pack converter\n     */\n    @NotNull", " */\npublic class PackPostProcessContext<T extends PackModule<T>> extends PackContext<T> {\n    private final PackConverter converter;\n    private final BedrockResourcePack pack;\n    private final Path path;\n\n    public PackPostProcessContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module, @NotNull PackConverter converter, @NotNull BedrockResourcePack pack, @NotNull Path path) {\n        super(hydraulic, mod, module);\n\n        this.converter = converter;\n        this.pack = pack;\n        this.path = path;\n    }\n\n    /**\n     * Gets the pack converter.\n     *\n     * @return the pack converter\n     */\n    @NotNull", "    public PackConverter converter() {\n        return this.converter;\n    }\n\n    /**\n     * Gets the pack.\n     *\n     * @return the pack\n     */\n    @NotNull\n    public BedrockResourcePack pack() {\n        return this.pack;\n    }\n\n    /**\n     * Gets the path to the pack.\n     *\n     * @return the path to the pack\n     */\n    @NotNull", "    public BedrockResourcePack pack() {\n        return this.pack;\n    }\n\n    /**\n     * Gets the path to the pack.\n     *\n     * @return the path to the pack\n     */\n    @NotNull\n    public Path path() {\n        return this.path;\n    }\n}\n", "    public Path path() {\n        return this.path;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/context/PackContext.java", "chunked_list": ["package org.geysermc.hydraulic.pack.context;\n\nimport net.minecraft.core.Registry;\nimport net.minecraft.resources.ResourceKey;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.hydraulic.storage.ModStorage;\nimport org.jetbrains.annotations.NotNull;\n", "import org.jetbrains.annotations.NotNull;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents the context of a pack.\n *\n * @param <T> the module type\n */\npublic class PackContext<T extends PackModule<T>> {\n    private final HydraulicImpl hydraulic;\n    private final ModInfo mod;\n    private final T module;\n\n    public PackContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module) {\n        this.hydraulic = hydraulic;\n        this.mod = mod;\n        this.module = module;\n    }\n\n    /**\n     * Gets the mod that owns this pack.\n     *\n     * @return the mod that owns this pack\n     */\n    @NotNull", " * @param <T> the module type\n */\npublic class PackContext<T extends PackModule<T>> {\n    private final HydraulicImpl hydraulic;\n    private final ModInfo mod;\n    private final T module;\n\n    public PackContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module) {\n        this.hydraulic = hydraulic;\n        this.mod = mod;\n        this.module = module;\n    }\n\n    /**\n     * Gets the mod that owns this pack.\n     *\n     * @return the mod that owns this pack\n     */\n    @NotNull", "    public ModInfo mod() {\n        return this.mod;\n    }\n\n    /**\n     * Gets the storage for the mod that owns this pack.\n     *\n     * @return the storage for the mod that owns this pack\n     */\n    @NotNull\n    public ModStorage storage() {\n        return this.hydraulic.modStorage(this.mod);\n    }\n\n    /**\n     * Gets the module that this context is part of.\n     *\n     * @return the module that this context is part of\n     */\n    @NotNull", "    public ModStorage storage() {\n        return this.hydraulic.modStorage(this.mod);\n    }\n\n    /**\n     * Gets the module that this context is part of.\n     *\n     * @return the module that this context is part of\n     */\n    @NotNull\n    public T module() {\n        return this.module;\n    }\n\n    /**\n     * Gets the values from the specified {@link Registry registry}\n     * that are relevant for the {@link ModInfo mod} this pack is\n     * part of.\n     *\n     * @param key the key of the registry to get the values from\n     * @return the values from the specified registry that are relevant for this mod\n     * @param <V> the type of the registry\n     */\n    @NotNull\n    public <V> List<V> registryValues(@NotNull ResourceKey<Registry<V>> key) {\n        Registry<V> registry = this.hydraulic.server().registryAccess().registryOrThrow(key);\n        return registry.entrySet().stream()\n                .filter(entry -> entry.getKey().location().getNamespace().equals(this.mod.id()))\n                .map(Map.Entry::getValue)\n                .toList();\n    }\n}\n\n", "    public T module() {\n        return this.module;\n    }\n\n    /**\n     * Gets the values from the specified {@link Registry registry}\n     * that are relevant for the {@link ModInfo mod} this pack is\n     * part of.\n     *\n     * @param key the key of the registry to get the values from\n     * @return the values from the specified registry that are relevant for this mod\n     * @param <V> the type of the registry\n     */\n    @NotNull\n    public <V> List<V> registryValues(@NotNull ResourceKey<Registry<V>> key) {\n        Registry<V> registry = this.hydraulic.server().registryAccess().registryOrThrow(key);\n        return registry.entrySet().stream()\n                .filter(entry -> entry.getKey().location().getNamespace().equals(this.mod.id()))\n                .map(Map.Entry::getValue)\n                .toList();\n    }\n}\n\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/pack/context/PackEventContext.java", "chunked_list": ["package org.geysermc.hydraulic.pack.context;\n\nimport org.geysermc.event.Event;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Represents the context of a pack for an event.", "/**\n * Represents the context of a pack for an event.\n *\n * @param <T> the module type\n */\npublic class PackEventContext<E extends Event, T extends PackModule<T>> extends PackContext<T> {\n    private final E event;\n\n    public PackEventContext(@NotNull HydraulicImpl hydraulic, @NotNull ModInfo mod, @NotNull T module, @NotNull E event) {\n        super(hydraulic, mod, module);\n\n        this.event = event;\n    }\n\n    /**\n     * Gets the event that this context is part of.\n     *\n     * @return the event that this context is part of\n     */\n    @NotNull", "    public E event() {\n        return this.event;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/platform/HydraulicBootstrap.java", "chunked_list": ["package org.geysermc.hydraulic.platform;\n\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.nio.file.Path;\nimport java.util.Set;\n\n/**", "\n/**\n * Represents the bootstrap of a platform.\n */\npublic interface HydraulicBootstrap {\n\n    /**\n     * Gets all the mods loaded on this platform.\n     *\n     * @return the mods loaded on this platform\n     */\n    @NotNull\n    Set<ModInfo> mods();\n\n    /**\n     * Gets the mod with the specified name, or null if not found.\n     *\n     * @param modName the name of the mod to get\n     * @return the mod with the specified name\n     */\n    @Nullable\n    ModInfo mod(@NotNull String modName);\n\n    /**\n     * Gets the data folder directory of this platform.\n     *\n     * @return the data folder directory\n     */\n    @NotNull\n    Path dataFolder(@NotNull String modId);\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/platform/HydraulicPlatform.java", "chunked_list": ["package org.geysermc.hydraulic.platform;\n\npublic enum HydraulicPlatform {\n    FABRIC(\"Fabric\"),\n    FORGE(\"Forge\");\n\n    private final String platformName;\n\n    HydraulicPlatform(String platformName) {\n        this.platformName = platformName;\n    }\n", "    public String platformName() {\n        return this.platformName;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/platform/mod/ModInfo.java", "chunked_list": ["package org.geysermc.hydraulic.platform.mod;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.nio.file.Path;\n\n/**\n * Represents info about a mod.\n *\n * @param id the mod's ID", " *\n * @param id the mod's ID\n * @param version the mod's version\n * @param name the mod's name\n * @param modPath the mod's path\n */\npublic record ModInfo(\n        @NotNull String id,\n        @NotNull String version,\n        @NotNull String name,\n        @NotNull Path modPath,\n        @NotNull String iconPath\n) {\n}"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/storage/ModStorage.java", "chunked_list": ["package org.geysermc.hydraulic.storage;\n\nimport com.mojang.logging.LogUtils;\nimport org.geysermc.hydraulic.Constants;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.block.Materials;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.jetbrains.annotations.NotNull;\nimport org.slf4j.Logger;\n", "import org.slf4j.Logger;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\n/**\n * Stores data relevant to a mod.", "/**\n * Stores data relevant to a mod.\n */\npublic class ModStorage {\n    private static final Logger LOGGER = LogUtils.getLogger();\n\n    private ModInfo mod;\n    private Materials materials = new Materials();\n\n    private ModStorage(@NotNull ModInfo mod) {\n        this.mod = mod;\n    }\n\n    /**\n     * Gets the materials for this mod.\n     *\n     * @return the materials\n     */\n    @NotNull", "    public Materials materials() {\n        return this.materials;\n    }\n\n    /**\n     * Sets the materials for this mod.\n     *\n     * @param materials the materials\n     */\n    public void materials(@NotNull Materials materials) {\n        this.materials = materials;\n    }\n\n    /**\n     * Saves the mod storage.\n     */", "    public void materials(@NotNull Materials materials) {\n        this.materials = materials;\n    }\n\n    /**\n     * Saves the mod storage.\n     */\n    public void save() {\n        try {\n            Path path = storagePath(this.mod);\n            if (Files.notExists(path)) {\n                Files.createDirectories(path);\n            }\n\n            try (BufferedWriter writer = Files.newBufferedWriter(path.resolve(\"materials.json\"))) {\n                Constants.GSON.toJson(this.materials, writer);\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to save mod storage for {}\", this.mod.id());\n        }\n    }\n\n    /**\n     * Loads the mod storage for the given mod.\n     *\n     * @param mod the mod\n     * @return the mod storage\n     */", "        try {\n            Path path = storagePath(this.mod);\n            if (Files.notExists(path)) {\n                Files.createDirectories(path);\n            }\n\n            try (BufferedWriter writer = Files.newBufferedWriter(path.resolve(\"materials.json\"))) {\n                Constants.GSON.toJson(this.materials, writer);\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to save mod storage for {}\", this.mod.id());\n        }\n    }\n\n    /**\n     * Loads the mod storage for the given mod.\n     *\n     * @param mod the mod\n     * @return the mod storage\n     */", "    public static ModStorage load(@NotNull ModInfo mod) {\n        Path path = storagePath(mod);\n        if (Files.notExists(path)) {\n            return new ModStorage(mod);\n        }\n\n        try {\n            try (BufferedReader reader = Files.newBufferedReader(path.resolve(\"materials.json\"))) {\n                ModStorage storage = Constants.GSON.fromJson(reader, ModStorage.class);\n                storage.mod = mod;\n                return storage;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to load mod storage for {}\", mod.id());\n            return new ModStorage(mod);\n        }\n    }\n\n    private static Path storagePath(@NotNull ModInfo mod) {\n        return HydraulicImpl.instance().dataFolder(Constants.MOD_ID)\n                .resolve(\"storage\")\n                .resolve(mod.id());\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/util/Constants.java", "chunked_list": ["package org.geysermc.hydraulic.util;\n\npublic class Constants {\n    public static final String JAVA_TEXTURE_LOCATION = \"assets/%s/textures/%s.png\";\n    public static final String JAVA_ITEM_MODEL_LOCATION = \"assets/%s/models/item/%s.json\";\n\n    public static final String BEDROCK_TEXTURE_LOCATION = \"textures/%s.png\";\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/util/PackUtil.java", "chunked_list": ["package org.geysermc.hydraulic.util;\n\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.bedrock.resource.Manifest;\nimport org.geysermc.pack.bedrock.resource.manifest.Header;\nimport org.geysermc.pack.bedrock.resource.manifest.Modules;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.nio.file.Path;", "\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * Utility class for packs.\n */\npublic class PackUtil {\n    private static final int FORMAT_VERSION = 2;\n\n    /**\n     * Initializes a resource pack for the specified mod.\n     *\n     * @param mod the mod to initialize the resource pack for\n     * @return the initialized resource pack\n     */", "public class PackUtil {\n    private static final int FORMAT_VERSION = 2;\n\n    /**\n     * Initializes a resource pack for the specified mod.\n     *\n     * @param mod the mod to initialize the resource pack for\n     * @return the initialized resource pack\n     */\n    public static BedrockResourcePack initializeForMod(@NotNull ModInfo mod, @NotNull Path packPack) {\n        Manifest manifest = new Manifest();\n        manifest.formatVersion(FORMAT_VERSION);\n\n        Header header = new Header();\n        header.description(\"Resource pack for mod \" + mod.name());\n        header.name(mod.name() + \" Resource Pack\");\n        header.version(new float[] { 1, 0, 0 });\n        header.minEngineVersion(new float[] { 1, 16, 0 });\n        header.uuid(UUID.randomUUID().toString());\n\n        manifest.header(header);\n\n        Modules module = new Modules();\n        module.description(\"Resource pack for mod \" + mod.name());\n        module.type(\"resources\");\n        module.uuid(UUID.randomUUID().toString());\n        module.version(new float[] { 1, 0, 0 });\n\n        manifest.modules(List.of(module));\n\n        BedrockResourcePack pack = new BedrockResourcePack(packPack);\n        pack.manifest(manifest);\n        return pack;\n    }\n}\n", "    public static BedrockResourcePack initializeForMod(@NotNull ModInfo mod, @NotNull Path packPack) {\n        Manifest manifest = new Manifest();\n        manifest.formatVersion(FORMAT_VERSION);\n\n        Header header = new Header();\n        header.description(\"Resource pack for mod \" + mod.name());\n        header.name(mod.name() + \" Resource Pack\");\n        header.version(new float[] { 1, 0, 0 });\n        header.minEngineVersion(new float[] { 1, 16, 0 });\n        header.uuid(UUID.randomUUID().toString());\n\n        manifest.header(header);\n\n        Modules module = new Modules();\n        module.description(\"Resource pack for mod \" + mod.name());\n        module.type(\"resources\");\n        module.uuid(UUID.randomUUID().toString());\n        module.version(new float[] { 1, 0, 0 });\n\n        manifest.modules(List.of(module));\n\n        BedrockResourcePack pack = new BedrockResourcePack(packPack);\n        pack.manifest(manifest);\n        return pack;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/mixin/ext/ItemTranslatorMixin.java", "chunked_list": ["package org.geysermc.hydraulic.mixin.ext;\n\nimport com.github.steveice10.opennbt.tag.builtin.CompoundTag;\nimport com.github.steveice10.opennbt.tag.builtin.ListTag;\nimport com.github.steveice10.opennbt.tag.builtin.StringTag;\nimport org.cloudburstmc.protocol.bedrock.data.inventory.ItemData;\nimport org.geysermc.geyser.item.type.Item;\nimport org.geysermc.geyser.registry.type.ItemMapping;\nimport org.geysermc.geyser.session.GeyserSession;\nimport org.geysermc.geyser.translator.inventory.item.ItemTranslator;", "import org.geysermc.geyser.session.GeyserSession;\nimport org.geysermc.geyser.translator.inventory.item.ItemTranslator;\nimport org.geysermc.hydraulic.HydraulicImpl;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.ModifyVariable;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\nimport org.spongepowered.asm.mixin.injection.callback.LocalCapture;", "import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\nimport org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n\n@Mixin(value = ItemTranslator.class, remap = false)\npublic class ItemTranslatorMixin {\n\n    @Inject(\n            method = \"translateDisplayProperties(Lorg/geysermc/geyser/session/GeyserSession;Lcom/github/steveice10/opennbt/tag/builtin/CompoundTag;Lorg/geysermc/geyser/registry/type/ItemMapping;C)Lcom/github/steveice10/opennbt/tag/builtin/CompoundTag;\",\n            at = @At(\"RETURN\"),\n            cancellable = true\n    )\n    private static void translateDisplayProperties(GeyserSession session, CompoundTag tag, ItemMapping mapping, char translationColor, CallbackInfoReturnable<CompoundTag> ci) {\n        CompoundTag newNbt = tag;", "        if (newNbt == null) {\n            newNbt = new CompoundTag(\"nbt\");\n            CompoundTag display = new CompoundTag(\"display\");\n            display.put(new ListTag(\"Lore\"));\n            newNbt.put(display);\n        }\n\n        CompoundTag compoundTag = newNbt.get(\"display\");\n        if (compoundTag == null) {\n            compoundTag = new CompoundTag(\"display\");\n        }\n        ListTag listTag = compoundTag.get(\"Lore\");\n", "        if (compoundTag == null) {\n            compoundTag = new CompoundTag(\"display\");\n        }\n        ListTag listTag = compoundTag.get(\"Lore\");\n\n        if (listTag == null) {\n            listTag = new ListTag(\"Lore\");\n        }\n\n        String identifier = mapping.getJavaItem().javaIdentifier();\n\n        // Get the mod name from the identifier\n        String modId = identifier.substring(0, identifier.indexOf(\":\"));\n        ModInfo mod = HydraulicImpl.instance().mod(modId);\n        String modName = \"Minecraft\";", "        if (mod != null) {\n            modName = mod.name();\n        }\n\n        listTag.add(new StringTag(\"\", \"\u00a7r\u00a79\u00a7o\" + modName));\n        compoundTag.put(listTag);\n        newNbt.put(compoundTag);\n\n        ci.setReturnValue(newNbt);\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/mixin/ext/ElementFaceMixin.java", "chunked_list": ["package org.geysermc.hydraulic.mixin.ext;\n\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Overwrite;\nimport team.unnamed.creative.model.ElementFace;\n\n@Mixin(value = ElementFace.class, remap = false)\npublic class ElementFaceMixin {\n\n    /**\n     * Overwrites the validateUVComponentInRange method\n     * to not throw an exception when the UV component is out of range.\n     * <p>\n     * Many mods use UV components out of range, and some data\n     * is handled specifically inside the mod's client jar.\n     * <p>\n     * Since we don't care about the range, we can just ignore it\n     * if it's invalid, rather than just erroring and not converting the\n     * rest of the mod's data.\n     *\n     * @author Redned\n     * @reason unneeded on Bedrock\n     */\n    @Overwrite(remap = false)\n    private void validateUVComponentInRange(float value, String name) {\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/block/BlockPackModule.java", "chunked_list": ["package org.geysermc.hydraulic.block;\n\nimport com.google.auto.service.AutoService;\nimport net.kyori.adventure.key.Key;\nimport net.minecraft.commands.arguments.blocks.BlockStateParser;\nimport net.minecraft.core.DefaultedRegistry;\nimport net.minecraft.core.registries.BuiltInRegistries;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.util.StringRepresentable;", "import net.minecraft.resources.ResourceLocation;\nimport net.minecraft.util.StringRepresentable;\nimport net.minecraft.world.level.block.Block;\nimport net.minecraft.world.level.block.state.BlockState;\nimport net.minecraft.world.level.block.state.properties.BlockStateProperties;\nimport net.minecraft.world.level.block.state.properties.BooleanProperty;\nimport net.minecraft.world.level.block.state.properties.EnumProperty;\nimport net.minecraft.world.level.block.state.properties.IntegerProperty;\nimport net.minecraft.world.level.block.state.properties.Property;\nimport org.geysermc.geyser.api.block.custom.CustomBlockData;", "import net.minecraft.world.level.block.state.properties.Property;\nimport org.geysermc.geyser.api.block.custom.CustomBlockData;\nimport org.geysermc.geyser.api.block.custom.CustomBlockPermutation;\nimport org.geysermc.geyser.api.block.custom.CustomBlockState;\nimport org.geysermc.geyser.api.block.custom.NonVanillaCustomBlockData;\nimport org.geysermc.geyser.api.block.custom.component.BoxComponent;\nimport org.geysermc.geyser.api.block.custom.component.CustomBlockComponents;\nimport org.geysermc.geyser.api.block.custom.component.GeometryComponent;\nimport org.geysermc.geyser.api.block.custom.component.MaterialInstance;\nimport org.geysermc.geyser.api.block.custom.component.TransformationComponent;", "import org.geysermc.geyser.api.block.custom.component.MaterialInstance;\nimport org.geysermc.geyser.api.block.custom.component.TransformationComponent;\nimport org.geysermc.geyser.api.block.custom.nonvanilla.JavaBlockState;\nimport org.geysermc.geyser.api.block.custom.nonvanilla.JavaBoundingBox;\nimport org.geysermc.geyser.api.event.lifecycle.GeyserDefineCustomBlocksEvent;\nimport org.geysermc.geyser.api.util.CreativeCategory;\nimport org.geysermc.geyser.level.physics.PistonBehavior;\nimport org.geysermc.hydraulic.pack.ConvertablePackModule;\nimport org.geysermc.hydraulic.pack.PackLogListener;\nimport org.geysermc.hydraulic.pack.PackModule;", "import org.geysermc.hydraulic.pack.PackLogListener;\nimport org.geysermc.hydraulic.pack.PackModule;\nimport org.geysermc.hydraulic.pack.context.PackEventContext;\nimport org.geysermc.hydraulic.pack.context.PackPostProcessContext;\nimport org.geysermc.hydraulic.platform.mod.ModInfo;\nimport org.geysermc.hydraulic.storage.ModStorage;\nimport org.geysermc.hydraulic.util.Constants;\nimport org.geysermc.pack.bedrock.resource.BedrockResourcePack;\nimport org.geysermc.pack.converter.PackConversionContext;\nimport org.geysermc.pack.converter.converter.model.ModelStitcher;", "import org.geysermc.pack.converter.PackConversionContext;\nimport org.geysermc.pack.converter.converter.model.ModelStitcher;\nimport org.geysermc.pack.converter.converter.texture.TextureMappings;\nimport org.geysermc.pack.converter.data.ModelConversionData;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.blockstate.MultiVariant;\nimport team.unnamed.creative.blockstate.Variant;\nimport team.unnamed.creative.model.Model;", "import team.unnamed.creative.blockstate.Variant;\nimport team.unnamed.creative.model.Model;\nimport team.unnamed.creative.model.ModelTexture;\nimport team.unnamed.creative.model.ModelTextures;\nimport team.unnamed.creative.texture.Texture;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;", "import java.util.List;\nimport java.util.Map;\n\n@AutoService(PackModule.class)\npublic class BlockPackModule extends ConvertablePackModule<BlockPackModule, ModelConversionData> {\n    private static final Key UNIT_CUBE_KEY = Key.key(\"block/cube_all\");\n    private static final String STATE_CONDITION = \"query.block_property('%s') == %s\";\n\n    private final Map<String, StateDefinition> blockStates = new HashMap<>();\n\n    public BlockPackModule() {\n        super(ModelConversionData.class);\n\n        this.listenOn(GeyserDefineCustomBlocksEvent.class, this::onDefineCustomBlocks);\n\n        this.preProcess(context -> {\n            ResourcePack assets = context.pack();", "            for (team.unnamed.creative.blockstate.BlockState blockState : assets.blockStates()) {\n                this.blockStates.put(blockState.key().toString(), new StateDefinition(blockState, context.pack()));\n            }\n\n            ModStorage storage = context.storage();\n            if (storage.materials().materials().isEmpty()) {\n                ModelStitcher.Provider provider = ModelStitcher.vanillaProvider(assets, new PackLogListener(LOGGER));\n\n                Materials materials = new Materials();\n                for (Model model : assets.models()) {\n                    Model stitchedModel = new ModelStitcher(provider, model).stitch();", "                for (Model model : assets.models()) {\n                    Model stitchedModel = new ModelStitcher(provider, model).stitch();\n                    if (stitchedModel == null) {\n                        LOGGER.warn(\"Could not find a stitched model for block {}\", model.key());\n                        continue;\n                    }\n\n                    Map<String, String> textures = new HashMap<>();\n                    Map<String, ModelTexture> modelTextures = getTextures(model.textures());\n                    for (Map.Entry<String, ModelTexture> entry : modelTextures.entrySet()) {\n                        ModelTexture modelTexture = getModelTexture(modelTextures, entry.getKey());", "                    for (Map.Entry<String, ModelTexture> entry : modelTextures.entrySet()) {\n                        ModelTexture modelTexture = getModelTexture(modelTextures, entry.getKey());\n                        if (modelTexture == null || modelTexture.key() == null) {\n                            // LOGGER.warn(\"Could not find a texture for key {} in model {}\", entry.getKey(), model.key());\n                            continue;\n                        }\n\n                        textures.put(entry.getKey(), modelTexture.key().toString());\n                    }\n\n                    Materials.Material material = new Materials.Material(textures);\n                    materials.addMaterial(model.key().toString(), material);\n                }\n\n                storage.materials(materials);\n                storage.save();\n            }\n        });\n    }\n\n    @Override", "    public void postConvert(PackConversionContext<ModelConversionData> packContext) {\n        ResourcePack assets = packContext.javaResourcePack();\n        BedrockResourcePack bedrockPack = packContext.bedrockResourcePack();\n\n        this.postProcess(context -> {\n            for (Texture texture : assets.textures()) {\n                Key key = texture.key();\n                String value = key.value();\n\n                if (value.startsWith(\"block/\")) {\n                    String cleanPath = value.replace(\"block/\", \"\").replace(\".png\", \"\");\n\n                    String outputLoc = String.format(Constants.BEDROCK_TEXTURE_LOCATION, \"blocks/\" + context.mod().id() + \"/\" + cleanPath).replace(\".png\", \"\");\n                    bedrockPack.addBlockTexture(key.namespace() + \":\" + cleanPath, outputLoc);\n                }\n            }\n        });\n    }\n\n    @Override", "                if (value.startsWith(\"block/\")) {\n                    String cleanPath = value.replace(\"block/\", \"\").replace(\".png\", \"\");\n\n                    String outputLoc = String.format(Constants.BEDROCK_TEXTURE_LOCATION, \"blocks/\" + context.mod().id() + \"/\" + cleanPath).replace(\".png\", \"\");\n                    bedrockPack.addBlockTexture(key.namespace() + \":\" + cleanPath, outputLoc);\n                }\n            }\n        });\n    }\n\n    @Override", "    public boolean test(@NotNull PackPostProcessContext<BlockPackModule> context) {\n        return context.registryValues(Registries.BLOCK).size() > 0;\n    }\n\n    private void onDefineCustomBlocks(PackEventContext<GeyserDefineCustomBlocksEvent, BlockPackModule> context) {\n        GeyserDefineCustomBlocksEvent event = context.event();\n        List<Block> blocks = context.registryValues(Registries.BLOCK);\n\n        DefaultedRegistry<Block> registry = BuiltInRegistries.BLOCK;\n        for (Block block : blocks) {\n            ResourceLocation blockLocation = registry.getKey(block);\n            CustomBlockData.Builder builder = NonVanillaCustomBlockData.builder()\n                    .name(blockLocation.getPath())\n                    .namespace(blockLocation.getNamespace())\n                    .includedInCreativeInventory(true)\n                    .creativeGroup(\"itemGroup.name.items\")\n                    .creativeCategory(CreativeCategory.ITEMS);\n", "        for (Block block : blocks) {\n            ResourceLocation blockLocation = registry.getKey(block);\n            CustomBlockData.Builder builder = NonVanillaCustomBlockData.builder()\n                    .name(blockLocation.getPath())\n                    .namespace(blockLocation.getNamespace())\n                    .includedInCreativeInventory(true)\n                    .creativeGroup(\"itemGroup.name.items\")\n                    .creativeCategory(CreativeCategory.ITEMS);\n\n            for (Property<?> property : block.getStateDefinition().getProperties()) {\n                if (property instanceof IntegerProperty intProperty) {\n                    builder.intProperty(property.getName(), List.copyOf(intProperty.getPossibleValues()));", "            for (Property<?> property : block.getStateDefinition().getProperties()) {\n                if (property instanceof IntegerProperty intProperty) {\n                    builder.intProperty(property.getName(), List.copyOf(intProperty.getPossibleValues()));\n                } else if (property instanceof BooleanProperty) {\n                    builder.booleanProperty(property.getName());\n                } else if (property instanceof EnumProperty<?> enumProperty) {\n                    builder.stringProperty(enumProperty.getName(), enumProperty.getPossibleValues().stream().map(StringRepresentable::getSerializedName).toList());\n                } else {\n                    throw new IllegalArgumentException(\"Unknown property type: \" + property.getClass().getName());\n                }\n            }\n\n            List<CustomBlockPermutation> permutations = new ArrayList<>();\n            CustomBlockComponents.Builder baseComponentBuilder = CustomBlockComponents.builder();", "            for (BlockState state : block.getStateDefinition().getPossibleStates()) {\n                ModelDefinition definition = getModel(context.mod(), blockLocation, state);\n                if (definition != null) {\n                    Model model = definition.model();\n                    Key key = model.key();\n\n                    CustomBlockComponents.Builder componentsBuilder = CustomBlockComponents.builder()\n                            .materialInstance(\"*\", MaterialInstance.builder()\n                                    .texture(getTextureName(key.toString()))\n                                    .renderMethod(\"alpha_test\")\n                                    .faceDimming(true)\n                                    .ambientOcclusion(model.ambientOcclusion())\n                                    .build())\n                            .transformation(new TransformationComponent(\n                                    definition.variant().x(), // Rotation X\n                                    definition.variant().y(), // Rotation Y\n                                    0, // Rotation Z\n                                    1, // Scale X\n                                    1, // Scale Y\n                                    1, // Scale Z\n                                    0, // Translation X\n                                    0, // Translation Y\n                                    0 // Translation Z\n                            ));\n", "                    if (!UNIT_CUBE_KEY.equals(model.parent())) {\n                        String namespace = key.namespace();\n                        String value = key.value();\n\n                        String fileName = value.substring(value.lastIndexOf('/') + 1);\n                        String geoName = (namespace.equals(Key.MINECRAFT_NAMESPACE) ? \"\" : namespace + \".\") + fileName;\n\n                        componentsBuilder.geometry(GeometryComponent.builder()\n                                .identifier(\"geometry.\" + geoName)\n                                .build());\n                    } else {\n                        componentsBuilder.unitCube(true);\n                    }\n\n                    Materials materials = context.storage().materials();\n                    Materials.Material material = materials.material(model.key().toString());", "                    if (material != null) {\n                        for (Map.Entry<String, String> entry : material.textures().entrySet()) {\n                            baseComponentBuilder.materialInstance(entry.getKey(), MaterialInstance.builder()\n                                            .texture(getTextureName(entry.getValue()))\n                                            .renderMethod(\"alpha_test\")\n                                            .faceDimming(true)\n                                            .ambientOcclusion(model.ambientOcclusion())\n                                    .build());\n                        }\n                    } else {\n                        LOGGER.warn(\"Could not find material for block {}\", model.key());\n                    }\n\n                    // No properties exist on this state, so there's only one\n                    // blockstate that can exist. Update the base builder so that\n                    // the code that creates the component for the base block\n                    // persists everything we did above", "                    if (state.getProperties().isEmpty()) {\n                        baseComponentBuilder = componentsBuilder;\n                        continue;\n                    }\n\n                    List<String> conditions = new ArrayList<>();\n                    for (Property<?> property : state.getProperties()) {\n                        String propValue = state.getValue(property).toString();\n                        if (property instanceof EnumProperty<?>) {\n                            propValue = \"'\" + propValue + \"'\";\n                        }\n\n                        conditions.add(String.format(STATE_CONDITION, property.getName(), propValue));\n                    }\n\n                    String condition = String.join(\" && \", conditions);\n                    permutations.add(new CustomBlockPermutation(componentsBuilder.build(), condition));\n                }\n            }\n\n            builder.permutations(permutations);\n\n            CustomBlockComponents.Builder componentsBuilder = baseComponentBuilder\n                    .displayName(\"%\" + block.getDescriptionId())\n                    .friction(block.getFriction())\n                    .destructibleByMining(block.defaultDestroyTime()) // TODO: Check\n                    // .unitCube(true) // TODO: Geometry conversion\n                    .selectionBox(BoxComponent.fullBox()) // TODO: Shapes\n                    .collisionBox(BoxComponent.fullBox()) // TODO: Shapes\n                    .materialInstance(\"*\", MaterialInstance.builder()\n                            .texture(blockLocation.toString())\n                            .renderMethod(\"alpha_test\")\n                            .faceDimming(true)\n                            .ambientOcclusion(true)\n                            .build());\n\n            builder.components(componentsBuilder.build());\n\n            CustomBlockData blockData = builder.build();\n            event.register(blockData);\n\n            int blockId = registry.getId(block);", "                        if (property instanceof EnumProperty<?>) {\n                            propValue = \"'\" + propValue + \"'\";\n                        }\n\n                        conditions.add(String.format(STATE_CONDITION, property.getName(), propValue));\n                    }\n\n                    String condition = String.join(\" && \", conditions);\n                    permutations.add(new CustomBlockPermutation(componentsBuilder.build(), condition));\n                }\n            }\n\n            builder.permutations(permutations);\n\n            CustomBlockComponents.Builder componentsBuilder = baseComponentBuilder\n                    .displayName(\"%\" + block.getDescriptionId())\n                    .friction(block.getFriction())\n                    .destructibleByMining(block.defaultDestroyTime()) // TODO: Check\n                    // .unitCube(true) // TODO: Geometry conversion\n                    .selectionBox(BoxComponent.fullBox()) // TODO: Shapes\n                    .collisionBox(BoxComponent.fullBox()) // TODO: Shapes\n                    .materialInstance(\"*\", MaterialInstance.builder()\n                            .texture(blockLocation.toString())\n                            .renderMethod(\"alpha_test\")\n                            .faceDimming(true)\n                            .ambientOcclusion(true)\n                            .build());\n\n            builder.components(componentsBuilder.build());\n\n            CustomBlockData blockData = builder.build();\n            event.register(blockData);\n\n            int blockId = registry.getId(block);", "            for (BlockState state : block.getStateDefinition().getPossibleStates()) {\n                CustomBlockState.Builder stateBuilder = blockData.blockStateBuilder();\n                for (Property<?> property : state.getProperties()) {\n                    if (property instanceof IntegerProperty intProperty) {\n                        stateBuilder.intProperty(property.getName(), state.getValue(intProperty));\n                    } else if (property instanceof BooleanProperty booleanProperty) {\n                        stateBuilder.booleanProperty(property.getName(), state.getValue(booleanProperty));\n                    } else if (property instanceof EnumProperty<?> enumProperty) {\n                        stateBuilder.stringProperty(enumProperty.getName(), state.getValue(enumProperty).getSerializedName());\n                    } else {\n                        throw new IllegalArgumentException(\"Unknown property type: \" + property.getClass().getName());\n                    }\n                }\n\n                PistonBehavior pistonBehavior = switch (state.getPistonPushReaction()) {\n                    case BLOCK -> PistonBehavior.BLOCK;\n                    case DESTROY -> PistonBehavior.DESTROY;\n                    case PUSH_ONLY -> PistonBehavior.PUSH_ONLY;\n                    default -> PistonBehavior.NORMAL;\n                };\n\n                CustomBlockState customBlockState = stateBuilder.build();\n                event.registerOverride(JavaBlockState.builder()\n                                .identifier(BlockStateParser.serialize(state))\n                                .javaId(Block.getId(state))\n                                .blockHardness(block.defaultDestroyTime()) // TODO: Check\n                                .hasBlockEntity(state.hasBlockEntity())\n                                .waterlogged(state.hasProperty(BlockStateProperties.WATERLOGGED) && state.getValue(BlockStateProperties.WATERLOGGED))\n                                .collision(new JavaBoundingBox[0]) // TODO: VoxelShape -> BoundingBox\n                                .stateGroupId(blockId)\n                                .pistonBehavior(pistonBehavior.name())\n                                .build(),\n                        customBlockState\n                );\n            }\n        }\n    }\n\n    @Nullable\n    private ModelDefinition getModel(@NotNull ModInfo mod, @NotNull ResourceLocation blockLocation, @NotNull BlockState state) {\n        StateDefinition definition = this.blockStates.get(blockLocation.toString());", "        if (definition == null) {\n            LOGGER.warn(\"Missing blockstate for block {}\", blockLocation);\n            return null;\n        }\n\n        team.unnamed.creative.blockstate.BlockState packState = definition.state();\n\n        // Check if we have a variant match\n        MultiVariant multiVariant = matchState(state, packState.variants());\n        if (multiVariant == null || multiVariant.variants().isEmpty()) {\n            // No variant, check if we have a default\n            multiVariant = packState.variants().get(\"\");\n        }\n\n        // We have a match! Now we need to find the model", "        if (multiVariant == null || multiVariant.variants().isEmpty()) {\n            // No variant, check if we have a default\n            multiVariant = packState.variants().get(\"\");\n        }\n\n        // We have a match! Now we need to find the model\n        if (multiVariant != null && !multiVariant.variants().isEmpty()) {\n            // TODO: Handle multiple variants?\n            Variant variant = multiVariant.variants().get(0);\n            Key modelKey = variant.model();\n\n            Model model = definition.pack().model(modelKey);", "            if (model == null) {\n                LOGGER.warn(\"Missing model {} for block {}\", modelKey, blockLocation);\n            } else {\n                return new ModelDefinition(model, variant);\n            }\n        }\n\n        // TODO: Multipart states\n\n        return null;\n    }\n\n    private static String getTextureName(@NotNull String modelName) {", "        if (modelName.startsWith(Key.MINECRAFT_NAMESPACE)) {\n            String modelValue = modelName.split(\":\")[1];\n            String type = modelValue.substring(0, modelValue.indexOf(\"/\"));\n            String value = modelValue.substring(modelValue.indexOf(\"/\") + 1);\n\n            // Need to use the Bedrock value for vanilla textures\n            Map<String, String> textures = TextureMappings.textureMappings().textures(type);\n            if (textures != null) {\n                return textures.getOrDefault(value, value);\n            }\n\n            return value;\n        }\n\n        return modelName.replace(\"block/\", \"\").replace(\"item/\", \"\");\n    }\n\n    private static MultiVariant matchState(@NotNull BlockState state, @NotNull Map<String, MultiVariant> variants) {\n        List<String> properties = new ArrayList<>();", "        for (Property<?> property : state.getProperties()) {\n            properties.add(property.getName() + \"=\" + state.getValue(property));\n        }\n\n        for (Map.Entry<String, MultiVariant> entry : variants.entrySet()) {\n            String variant = entry.getKey();\n\n            String[] property = variant.split(\",\");\n            boolean match = true;\n            for (String prop : property) {\n                if (!properties.contains(prop)) {\n                    match = false;\n                    break;\n                }\n            }\n", "            for (String prop : property) {\n                if (!properties.contains(prop)) {\n                    match = false;\n                    break;\n                }\n            }\n\n            if (match) {\n                return entry.getValue();\n            }\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private static ModelTexture getModelTexture(@NotNull Map<String, ModelTexture> textures, @NotNull String key) {\n        // Texture references the value of another texture\n        ModelTexture value = textures.get(key);", "        if (value != null && value.reference() != null) {\n            return getModelTexture(textures, value.reference());\n        }\n\n        return value;\n    }\n\n    private static Map<String, ModelTexture> getTextures(@NotNull ModelTextures modelTextures) {\n        Map<String, ModelTexture> textures = new HashMap<>();\n        textures.putAll(modelTextures.variables());\n        textures.put(\"particle\", modelTextures.particle());", "        for (int i = 0; i < modelTextures.layers().size(); i++) {\n            textures.put(\"layer\" + i, modelTextures.layers().get(i));\n        }\n\n        return textures;\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/block/ModelDefinition.java", "chunked_list": ["package org.geysermc.hydraulic.block;\n\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.blockstate.Variant;\nimport team.unnamed.creative.model.Model;\n\npublic record ModelDefinition(\n        @NotNull Model model,\n        @NotNull Variant variant\n) {\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/block/Materials.java", "chunked_list": ["package org.geysermc.hydraulic.block;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**", "\n/**\n * Represents data relating to Materials.\n */\npublic class Materials {\n    private final Map<String, Material> materials = new HashMap<>();\n\n    /**\n     * Add a material to the map.\n     *\n     * @param identifier the identifier of the material\n     * @param material the material\n     */", "    public void addMaterial(@NotNull String identifier, @NotNull Material material) {\n        this.materials.put(identifier, material);\n    }\n\n    /**\n     * Get a material by its identifier.\n     *\n     * @param identifier the identifier of the material\n     * @return the material\n     */\n    @Nullable", "    public Material material(@NotNull String identifier) {\n        return this.materials.get(identifier);\n    }\n\n    /**\n     * Gets all the materials.\n     *\n     * @return all the materials\n     */\n    @NotNull\n    public Map<String, Material> materials() {\n        return Collections.unmodifiableMap(this.materials);\n    }\n", "    public static class Material {\n        private final Map<String, String> textures;\n\n        public Material(@NotNull Map<String, String> textures) {\n            this.textures = textures;\n        }\n\n        @NotNull\n        public Map<String, String> textures() {\n            return this.textures;\n        }\n    }\n}\n"]}
{"filename": "shared/src/main/java/org/geysermc/hydraulic/block/StateDefinition.java", "chunked_list": ["package org.geysermc.hydraulic.block;\n\nimport org.jetbrains.annotations.NotNull;\nimport team.unnamed.creative.ResourcePack;\nimport team.unnamed.creative.blockstate.BlockState;\n\npublic record StateDefinition(\n        @NotNull BlockState state,\n        @NotNull ResourcePack pack\n) {\n}"]}
