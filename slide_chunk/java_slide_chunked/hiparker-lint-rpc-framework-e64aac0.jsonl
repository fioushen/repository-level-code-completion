{"filename": "lint-rpc-spi/lint-rpc-spi-provide-local/src/main/java/com/lint/rpc/common/spi/impl/LocalProvideService.java", "chunked_list": ["package com.lint.rpc.common.spi.impl;\n\nimport com.lint.rpc.common.spi.IProvideService;\n\nimport java.net.InetSocketAddress;\nimport java.util.*;\n\npublic class LocalProvideService implements IProvideService {\n\n    @Override\n    public String getType() {\n        return \"local\";\n    }\n\n    @Override\n    public Map<String, LinkedHashSet<InetSocketAddress>> getProvide() {\n        LinkedHashSet<InetSocketAddress> set1 = new LinkedHashSet<>();\n        set1.add(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n\n        LinkedHashSet<InetSocketAddress> set2 = new LinkedHashSet<>();\n        set2.add(new InetSocketAddress(\"127.0.0.1\", 9090));\n\n        Map<String, LinkedHashSet<InetSocketAddress>> map = new HashMap<>();\n        map.put(\"provide1\", set1);\n        map.put(\"provide2\", set2);\n        return map;\n    }\n}\n", "    public String getType() {\n        return \"local\";\n    }\n\n    @Override\n    public Map<String, LinkedHashSet<InetSocketAddress>> getProvide() {\n        LinkedHashSet<InetSocketAddress> set1 = new LinkedHashSet<>();\n        set1.add(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n\n        LinkedHashSet<InetSocketAddress> set2 = new LinkedHashSet<>();\n        set2.add(new InetSocketAddress(\"127.0.0.1\", 9090));\n\n        Map<String, LinkedHashSet<InetSocketAddress>> map = new HashMap<>();\n        map.put(\"provide1\", set1);\n        map.put(\"provide2\", set2);\n        return map;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-spi/src/main/java/com/lint/rpc/common/spi/IProvideService.java", "chunked_list": ["package com.lint.rpc.common.spi;\n\nimport java.net.InetSocketAddress;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\n\n/**\n * SPI \u63a5\u53e3 \u53ef\u652f\u6301\u591a\u79cd provide \u65b9\u5f0f\n * 1. \u76f4\u63a5\u5217\u8868\n * 2. Nacos", " * 1. \u76f4\u63a5\u5217\u8868\n * 2. Nacos\n * 3. ...\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 3:59 PM\n **/\npublic interface IProvideService {\n\n    String getType();\n\n    Map<String, LinkedHashSet<InetSocketAddress>> getProvide();\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-spi/src/main/java/com/lint/rpc/common/spi/LintService.java", "chunked_list": ["package com.lint.rpc.common.spi;\n\n/**\n * SPI \u57fa\u7c7b \u7528\u4e8e\u8bc6\u522b\u5b50\u7c7b\n */\npublic interface LintService {\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/LintConf.java", "chunked_list": ["package com.lint.rpc.common;\n\npublic class LintConf {\n\n    /**\n     * \u5ba2\u6237\u7aef\u6700\u5927\u8fde\u63a5\u6570\u91cf\n     */\n    private byte clientMaxConnCount = 1;\n\n    /**\n     * \u52a0\u8f7d provide spi \u5217\u8868\u7c7b\u578b\n     * \u5982 local nacos \u7b49\n     */\n    private String provideSpiType;\n\n    /**\n     * \u5ba2\u6237\u7aef\u6700\u5927\u8bf7\u6c42\u7b49\u5f85\u65f6\u95f4\n     */\n    private int requestWaitTimeBySeconds = 60;\n\n", "    public byte getClientMaxConnCount() {\n        return clientMaxConnCount;\n    }\n\n    public LintConf setClientMaxConnCount(byte clientMaxConnCount) {\n        this.clientMaxConnCount = clientMaxConnCount;\n        return this;\n    }\n\n    public String getProvideSpiType() {\n        return provideSpiType;\n    }\n", "    public String getProvideSpiType() {\n        return provideSpiType;\n    }\n\n    public LintConf setProvideSpiType(String provideSpiType) {\n        this.provideSpiType = provideSpiType;\n        return this;\n    }\n\n    public int getRequestWaitTimeBySeconds() {\n        return requestWaitTimeBySeconds;\n    }\n", "    public int getRequestWaitTimeBySeconds() {\n        return requestWaitTimeBySeconds;\n    }\n\n    public LintConf setRequestWaitTimeBySeconds(int requestWaitTimeBySeconds) {\n        this.requestWaitTimeBySeconds = requestWaitTimeBySeconds;\n        return this;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/pool/CountDownLatchPool.java", "chunked_list": ["package com.lint.rpc.common.pool;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * \u8bf7\u6c42\u95e8\u95e9\u6c60\n *", " * \u8bf7\u6c42\u95e8\u95e9\u6c60\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM\n **/\npublic final class CountDownLatchPool {\n\n    private static final int TIME_OUT = 60;\n    private static final Map<Long, CountDownLatch> MSG_POOL_MAP = new ConcurrentHashMap<>();\n\n    public static void put(long requestId, CountDownLatch countDownLatch){\n        MSG_POOL_MAP.putIfAbsent(requestId, countDownLatch);\n    }\n", "    public static void put(long requestId, CountDownLatch countDownLatch){\n        MSG_POOL_MAP.putIfAbsent(requestId, countDownLatch);\n    }\n\n    public static void await(long requestId){\n        try {\n            CountDownLatch countDownLatch = new CountDownLatch(1);\n            // \u8d85\u65f6\u81ea\u52a8\u91ca\u653e\n            MSG_POOL_MAP.putIfAbsent(requestId, countDownLatch);\n            countDownLatch.await(TIME_OUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n", "    public static void await(long requestId, int timeoutSeconds){\n        try {\n            if(timeoutSeconds < 0){\n                timeoutSeconds = 0;\n            }\n            CountDownLatch countDownLatch = new CountDownLatch(1);\n            // \u8d85\u65f6\u81ea\u52a8\u91ca\u653e\n            MSG_POOL_MAP.putIfAbsent(requestId, countDownLatch);\n            countDownLatch.await(timeoutSeconds, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n", "    public static void countDown(long requestId){\n        // \u8d85\u65f6\u81ea\u52a8\u91ca\u653e\n        CountDownLatch countDownLatch = free(requestId);\n        if(null != countDownLatch){\n            countDownLatch.countDown();\n        }\n    }\n\n    public static CountDownLatch free(long requestId){\n        // \u56de\u6536\n        return MSG_POOL_MAP.remove(requestId);\n    }\n\n    private CountDownLatchPool(){}\n}\n", "    public static CountDownLatch free(long requestId){\n        // \u56de\u6536\n        return MSG_POOL_MAP.remove(requestId);\n    }\n\n    private CountDownLatchPool(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/pool/ConfPool.java", "chunked_list": ["package com.lint.rpc.common.pool;\n\nimport com.lint.rpc.common.LintConf;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * \u914d\u7f6e\u6c60\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM", " * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM\n **/\npublic final class ConfPool {\n\n    private static final AtomicReference<LintConf> LINT_CONF_ATOMIC_REFERENCE = new AtomicReference<>();\n\n    public LintConf init(final LintConf conf){\n        if(null == LINT_CONF_ATOMIC_REFERENCE.get()){\n            synchronized(ConfPool.class) {\n                if (null == LINT_CONF_ATOMIC_REFERENCE.get()) {\n                    return LINT_CONF_ATOMIC_REFERENCE.getAndSet(conf);\n                }\n            }\n        }\n        return LINT_CONF_ATOMIC_REFERENCE.get();\n    }\n", "        if(null == LINT_CONF_ATOMIC_REFERENCE.get()){\n            synchronized(ConfPool.class) {\n                if (null == LINT_CONF_ATOMIC_REFERENCE.get()) {\n                    return LINT_CONF_ATOMIC_REFERENCE.getAndSet(conf);\n                }\n            }\n        }\n        return LINT_CONF_ATOMIC_REFERENCE.get();\n    }\n\n    public LintConf get(){\n        return LINT_CONF_ATOMIC_REFERENCE.get();\n    }\n\n\n    private static class LazyHolder {\n        private static final ConfPool INSTANCE = new ConfPool();\n    }\n", "    public LintConf get(){\n        return LINT_CONF_ATOMIC_REFERENCE.get();\n    }\n\n\n    private static class LazyHolder {\n        private static final ConfPool INSTANCE = new ConfPool();\n    }\n\n    public static ConfPool getInstance() {\n        return ConfPool.LazyHolder.INSTANCE;\n    }\n\n    private ConfPool(){}\n}\n", "    public static ConfPool getInstance() {\n        return ConfPool.LazyHolder.INSTANCE;\n    }\n\n    private ConfPool(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/pool/MsgPool.java", "chunked_list": ["package com.lint.rpc.common.pool;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * \u6d88\u606f\u6c60\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM", " * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM\n **/\npublic final class MsgPool {\n\n    private static final Map<Long, Object> MSG_POOL_MAP = new ConcurrentHashMap<>();\n\n    public static void put(long requestId, Object msg){\n        if(null == msg){\n            return;\n        }\n        MSG_POOL_MAP.putIfAbsent(requestId, msg);\n    }\n", "        if(null == msg){\n            return;\n        }\n        MSG_POOL_MAP.putIfAbsent(requestId, msg);\n    }\n\n    public static Object get(long requestId){\n        return MSG_POOL_MAP.get(requestId);\n    }\n\n    public static Object getAndRemove(long requestId){\n        return MSG_POOL_MAP.remove(requestId);\n    }\n\n    private MsgPool(){}\n}\n", "    public static Object getAndRemove(long requestId){\n        return MSG_POOL_MAP.remove(requestId);\n    }\n\n    private MsgPool(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/pool/ClientPool.java", "chunked_list": ["package com.lint.rpc.common.pool;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.balance.ILoadBalancePolicy;\nimport com.lint.rpc.common.service.ProvideSpi;\nimport com.lint.rpc.common.transport.ClientFactory;\nimport com.lint.rpc.common.transport.NettyClient;\nimport com.lint.rpc.common.transport.NettyConf;\nimport java.net.InetSocketAddress;\nimport java.util.*;", "import java.net.InetSocketAddress;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \u5ba2\u6237\u7aef\u8fde\u63a5\u6c60\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 7:38 PM", " * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 7:38 PM\n **/\npublic final class ClientPool {\n\n    // serviceName \u4e3a\u670d\u52a1\u540d\n    // hostname+port \u4e3a\u7ec4\u540d\n    // \u8fde\u63a5\u6c60\n    private final Map<String, LinkedHashSet<NettyClient>> groupPool = new ConcurrentHashMap<>();\n    private final Map<String, LinkedHashSet<String>> servicePool = new ConcurrentHashMap<>();\n    private final ReentrantLock rLock = new ReentrantLock();\n", "    public NettyClient get(String serviceName, ILoadBalancePolicy loadBalancePolicy){\n        ConfPool confPool = ConfPool.getInstance();\n        LintConf lintConf = confPool.get();\n        ProvideSpi provideSpi = ProvideSpi.getInstance();\n        LinkedHashSet<InetSocketAddress> addressSet =\n                provideSpi.getAddressByServiceName(serviceName);\n        if(null == addressSet){\n            return null;\n        }\n\n        LinkedHashSet<String> groupNameSet = servicePool.get(serviceName);", "        if(null == groupNameSet || groupNameSet.isEmpty()){\n            try {\n                rLock.lock();\n                groupNameSet = servicePool.get(serviceName);\n                if(null == groupNameSet || groupNameSet.isEmpty()){\n                    int clientIndex = loadBalancePolicy.getClientIndex(addressSet.size());\n                    InetSocketAddress inetSocketAddress =\n                            linkedHashSetGetByIndex(addressSet, clientIndex);\n\n                    NettyClient ch = createClient(serviceName, inetSocketAddress);\n                    return put(serviceName, ch);\n                }\n            }finally {\n                rLock.unlock();\n            }\n        }\n\n\n        NettyClient ch = null;\n        // \u5982\u679c\u4e0d\u76f8\u7b49 \u4f18\u5148\u4f7f\u7528\u4e3a\u5f00\u8f9f\u7684\u65b0\u94fe\u63a5", "        if(groupNameSet.size() != addressSet.size()){\n            try {\n                rLock.lock();\n                if(groupNameSet.size() != addressSet.size()) {\n                    InetSocketAddress address = null;\n                    Iterator<InetSocketAddress> iterator = addressSet.stream().iterator();\n                    while (iterator.hasNext()){\n                        address = iterator.next();\n                        String groupName = getGroupName(address);\n\n                        boolean contains = groupNameSet.contains(groupName);", "                        if(!contains){\n                            break;\n                        }\n                    }\n\n                    ch = createClient(serviceName, address);\n                    if(ch != null){\n                        return put(serviceName, ch);\n                    }\n                }\n            }finally {\n                rLock.unlock();\n            }\n        }\n\n        // \u5982\u679c\u4e0a\u8ff0\u64cd\u4f5c ch == null \u6216\u8005 group\u76f8\u7b49 \u90a3\u5c31\u51c6\u5907 \u4ece\u73b0\u6709\u961f\u5217\u4e2d\u9009\u62e9\u4e00\u4f4d\u8fde\u63a5\n        int groupIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());\n        String groupName = linkedHashSetGetByIndex(groupNameSet, groupIndex);\n        LinkedHashSet<NettyClient> ncSet = groupPool.get(groupName);", "        if(null != ncSet){\n            // \u5982\u679c\u5f53\u524d\u5f00\u8f9f\u7684\u8fde\u63a5\u6570 \u8fd8\u672a\u8fbe\u5230\u81ea\u5b9a\u4e49\u914d\u7f6e\u7684\u6700\u5927\u503c \u5219\u7ee7\u7eed\u5f00\u8f9f\u8fde\u63a5\n            if(ncSet.size() < lintConf.getClientMaxConnCount()){\n                try {\n                    rLock.lock();\n                    if(ncSet.size() < lintConf.getClientMaxConnCount()){\n                        String[] address = groupName.split(\":\");\n                        InetSocketAddress inetSocketAddress = new InetSocketAddress(\n                                address[0], Integer.parseInt(address[1]));\n                        ch = createClient(serviceName, inetSocketAddress);\n                        return put(serviceName, ch);\n                    }\n                }finally {\n                    rLock.unlock();\n                }\n            }\n            int chIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());\n            ch = linkedHashSetGetByIndex(ncSet, chIndex);\n        }\n        return ch;\n    }\n\n    private NettyClient put(\n            String serviceName, NettyClient nc){", "        if(null == nc){\n            return null;\n        }\n        int lockCount = 0;\n        try {\n            Set<String> groupSet = servicePool.get(serviceName);\n            if(null == groupSet){\n                rLock.lock();\n                lockCount++;\n                groupSet = servicePool.computeIfAbsent(serviceName, k -> new LinkedHashSet<>());\n            }\n\n            NettyConf conf = nc.getConf();\n\n            String groupName = getGroupName(conf.getAddress());\n\n            Set<NettyClient> nettyClientSet = groupPool.get(groupName);", "            if(null == nettyClientSet){\n                rLock.lock();\n                lockCount++;\n                nettyClientSet = groupPool.computeIfAbsent(groupName, k -> new LinkedHashSet<>());\n            }\n\n            rLock.lock();\n            lockCount++;\n            if(nettyClientSet.isEmpty()){\n                groupSet.add(groupName);\n            }\n            nettyClientSet.add(nc);\n        }finally {", "            if(nettyClientSet.isEmpty()){\n                groupSet.add(groupName);\n            }\n            nettyClientSet.add(nc);\n        }finally {\n            if(lockCount > 0){\n                for (int i = 0; i < lockCount; i++) {\n                    rLock.unlock();\n                }\n            }\n        }\n        return nc;\n    }\n\n\n    private NettyClient createClient(String serviceName, InetSocketAddress address){\n        NettyConf conf = new NettyConf();\n        conf.setAddress(address);\n        conf.setCloseCallback((c)->{", "            try {\n                rLock.lock();\n                String groupName = getGroupName(address);\n                Set<NettyClient> nettyClients = groupPool.get(groupName);\n                nettyClients.remove(c);\n                if(nettyClients.isEmpty()){\n                    groupPool.remove(groupName);\n                    Set<String> groupSet = servicePool.get(serviceName);\n                    groupSet.remove(groupName);\n                    if(groupSet.isEmpty()){\n                        servicePool.remove(serviceName);\n                    }\n                }\n            }finally {\n                rLock.unlock();\n            }\n        });\n        ClientFactory factory = ClientFactory.getInstance();\n        return factory.create(conf);\n    }\n\n    private String getGroupName(InetSocketAddress address){\n        String hostName = address.getHostName();\n        int port = address.getPort();\n        return hostName+\":\"+port;\n    }\n\n    private <T> T linkedHashSetGetByIndex(LinkedHashSet<T> linkedHashSet, int index){", "                    if(groupSet.isEmpty()){\n                        servicePool.remove(serviceName);\n                    }\n                }\n            }finally {\n                rLock.unlock();\n            }\n        });\n        ClientFactory factory = ClientFactory.getInstance();\n        return factory.create(conf);\n    }\n\n    private String getGroupName(InetSocketAddress address){\n        String hostName = address.getHostName();\n        int port = address.getPort();\n        return hostName+\":\"+port;\n    }\n\n    private <T> T linkedHashSetGetByIndex(LinkedHashSet<T> linkedHashSet, int index){", "        if(null == linkedHashSet){\n            return null;\n        }\n        T t = null;\n        int chCurrIndex = 0;\n        Iterator<T> chIterator = linkedHashSet.stream().iterator();\n        while (chIterator.hasNext() && chCurrIndex++ <= index){\n            t = chIterator.next();\n        }\n        return t;\n    }\n\n    private static class LazyHolder {\n        private static final ClientPool INSTANCE = new ClientPool();\n    }\n", "    public static ClientPool getInstance() {\n        return ClientPool.LazyHolder.INSTANCE;\n    }\n\n    private ClientPool(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/pool/ProxyPool.java", "chunked_list": ["package com.lint.rpc.common.pool;\n\nimport com.lint.rpc.common.proxy.RpcProxy;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic final class ProxyPool {\n\n    private static final Map<Class<?>, Object> PROXY_MAP = new ConcurrentHashMap<>();\n\n    public static <T>T getProxyGet(Class<T> interfaceClazz){\n        Object provideInterface = PROXY_MAP\n                .computeIfAbsent(interfaceClazz, k -> RpcProxy.proxyGet(interfaceClazz));\n        return (T) provideInterface;\n    }\n\n    private ProxyPool(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/proxy/RpcInvocationHandler.java", "chunked_list": ["package com.lint.rpc.common.proxy;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.annotation.RpcClient;\nimport com.lint.rpc.common.pool.ConfPool;\nimport com.lint.rpc.common.pool.CountDownLatchPool;\nimport com.lint.rpc.common.pool.MsgPool;\nimport com.lint.rpc.common.enums.RpcMsg;\nimport com.lint.rpc.common.exception.RpcException;\nimport com.lint.rpc.common.balance.LoadBalancePolicyFactory;", "import com.lint.rpc.common.exception.RpcException;\nimport com.lint.rpc.common.balance.LoadBalancePolicyFactory;\nimport com.lint.rpc.common.protocol.RequestBody;\nimport com.lint.rpc.common.protocol.RequestContent;\nimport com.lint.rpc.common.protocol.RequestHeader;\nimport com.lint.rpc.common.transport.NettyClient;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n", "import java.lang.reflect.Method;\n\n/**\n * Rpc \u4ee3\u7406\u6267\u884c\u7c7b\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:53 AM\n **/\npublic class RpcInvocationHandler implements InvocationHandler {\n\n    private final Class<?> interfaceInfo;\n\n    public RpcInvocationHandler(Class<?> interfaceInfo){\n        this.interfaceInfo = interfaceInfo;\n    }\n\n    @Override", "public class RpcInvocationHandler implements InvocationHandler {\n\n    private final Class<?> interfaceInfo;\n\n    public RpcInvocationHandler(Class<?> interfaceInfo){\n        this.interfaceInfo = interfaceInfo;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) {\n        long startTime = System.currentTimeMillis();\n        RpcClient annotation = interfaceInfo.getAnnotation(RpcClient.class);\n\n        String methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        RequestBody requestBody = new RequestBody();\n        requestBody.setName(annotation.name());\n        requestBody.setMethodName(methodName);\n        requestBody.setParameterTypes(parameterTypes);\n        requestBody.setArgs(args);\n        RequestHeader requestHeader = new RequestHeader(requestBody.toBytesArray());\n        requestHeader.setVersion(annotation.version());\n\n        RequestContent requestContent = new RequestContent();\n        requestContent.setRequestHeader(requestHeader);\n        requestContent.setRequestBody(requestBody);\n\n        LoadBalancePolicyFactory loadBalancePolicyFactory = LoadBalancePolicyFactory.getInstance();\n        NettyClient nc = loadBalancePolicyFactory\n                .getClient(interfaceInfo);\n\n\n        Object responseMsg = null;", "    public Object invoke(Object proxy, Method method, Object[] args) {\n        long startTime = System.currentTimeMillis();\n        RpcClient annotation = interfaceInfo.getAnnotation(RpcClient.class);\n\n        String methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        RequestBody requestBody = new RequestBody();\n        requestBody.setName(annotation.name());\n        requestBody.setMethodName(methodName);\n        requestBody.setParameterTypes(parameterTypes);\n        requestBody.setArgs(args);\n        RequestHeader requestHeader = new RequestHeader(requestBody.toBytesArray());\n        requestHeader.setVersion(annotation.version());\n\n        RequestContent requestContent = new RequestContent();\n        requestContent.setRequestHeader(requestHeader);\n        requestContent.setRequestBody(requestBody);\n\n        LoadBalancePolicyFactory loadBalancePolicyFactory = LoadBalancePolicyFactory.getInstance();\n        NettyClient nc = loadBalancePolicyFactory\n                .getClient(interfaceInfo);\n\n\n        Object responseMsg = null;", "        try {\n            boolean sendFlag = nc.sendMsg(requestContent);\n            if(!sendFlag){\n                // \u65e0\u6cd5\u5efa\u7acb\u8fde\u63a5\n                throw new RpcException(RpcMsg.EXCEPTION_NOT_CONNECTION);\n            }\n\n            // \u5982\u679c\u65e0\u8fd4\u56de\u503c \u5219\u76f4\u63a5\u9000\u51fa\n            if(method.getReturnType().equals(Void.TYPE)){\n                return responseMsg;\n            }\n\n            ConfPool confPool = ConfPool.getInstance();\n            LintConf lintConf = confPool.get();\n\n            // \u9501\u5b9a\u7ebf\u7a0b \u5e76\u7b49\u5f85 60\u79d2\uff0c\u5982\u679c\u6709\u7ed3\u679c\u4f1a\u76f4\u63a5\u8fd4\u56de\n            CountDownLatchPool.await(\n                    requestHeader.getRequestId(), lintConf.getRequestWaitTimeBySeconds());\n\n            // \u6d88\u606f\u6c60\u67e5\u8be2\u6570\u636e \u5982\u679c\u67e5\u5230\u5219\u5e8f\u5217\u5316\u8fd4\u56de \uff0c\u8d85\u65f6\u5219\u8fd4\u56de\u8d85\u65f6 \u6216\u8005 \u8c03\u7528\u515c\u5e95\u8865\u507f\n            responseMsg = MsgPool.getAndRemove(requestHeader.getRequestId());", "            if(method.getReturnType().equals(Void.TYPE)){\n                return responseMsg;\n            }\n\n            ConfPool confPool = ConfPool.getInstance();\n            LintConf lintConf = confPool.get();\n\n            // \u9501\u5b9a\u7ebf\u7a0b \u5e76\u7b49\u5f85 60\u79d2\uff0c\u5982\u679c\u6709\u7ed3\u679c\u4f1a\u76f4\u63a5\u8fd4\u56de\n            CountDownLatchPool.await(\n                    requestHeader.getRequestId(), lintConf.getRequestWaitTimeBySeconds());\n\n            // \u6d88\u606f\u6c60\u67e5\u8be2\u6570\u636e \u5982\u679c\u67e5\u5230\u5219\u5e8f\u5217\u5316\u8fd4\u56de \uff0c\u8d85\u65f6\u5219\u8fd4\u56de\u8d85\u65f6 \u6216\u8005 \u8c03\u7528\u515c\u5e95\u8865\u507f\n            responseMsg = MsgPool.getAndRemove(requestHeader.getRequestId());", "            if(null == responseMsg){\n                // \u8bf7\u6c42\u8d85\u65f6\n                throw new RpcException(RpcMsg.EXCEPTION_TIMEOUT);\n            }\n        }catch (RpcException re){\n            re.printStackTrace();\n        }finally {\n            CountDownLatchPool.free(requestHeader.getRequestId());\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Invoke \"+interfaceInfo.getName()+\n                \"(\"+annotation.name()+\":\"+annotation.version()+\n                \")  used >>> \" + (endTime - startTime) + \" ms\uff01\");\n        // \u5e8f\u5217\u5316\u5904\u7406\n        return responseMsg;\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/proxy/RpcProxy.java", "chunked_list": ["package com.lint.rpc.common.proxy;\n\nimport com.lint.rpc.common.annotation.RpcClient;\n\nimport java.lang.reflect.Proxy;\n\n/**\n * \u4ee3\u7406\u7c7b\n *\n * @author \u5468\u9e4f\u7a0b", " *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:47 AM\n **/\npublic final class RpcProxy {\n\n    public static <T> T proxyGet(Class<T> interfaceInfo){\n        if(null == interfaceInfo){\n            return null;\n        }\n\n        RpcClient annotation = interfaceInfo.getAnnotation(RpcClient.class);", "        if(null == annotation){\n            return null;\n        }\n\n        ClassLoader classLoader = interfaceInfo.getClassLoader();\n        Class<?>[] methodArray = {interfaceInfo};\n\n        return (T) Proxy.newProxyInstance(classLoader, methodArray, new RpcInvocationHandler(interfaceInfo));\n    }\n\n    private RpcProxy(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/protocol/RequestBody.java", "chunked_list": ["package com.lint.rpc.common.protocol;\n\nimport com.lint.rpc.common.util.ByteUtil;\n\nimport java.io.Serializable;\n\n/**\n * \u8bf7\u6c42\u5934\n *\n * @author \u5468\u9e4f\u7a0b", " *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:26 AM\n **/\npublic class RequestBody implements Serializable {\n\n    private String name;\n    private String methodName;\n    private Class<?>[] parameterTypes;\n    private Object[] args;\n    //\u8fd4\u56de\u7684\u6570\u636e\n    private Object res;\n\n\n    public byte[] toBytesArray(){\n        return ByteUtil.toByteArray(this);\n    }\n", "    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n", "    public String getMethodName() {\n        return methodName;\n    }\n\n    public void setMethodName(String methodName) {\n        this.methodName = methodName;\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return parameterTypes;\n    }\n", "    public void setParameterTypes(Class<?>[] parameterTypes) {\n        this.parameterTypes = parameterTypes;\n    }\n\n    public Object[] getArgs() {\n        return args;\n    }\n\n    public void setArgs(Object[] args) {\n        this.args = args;\n    }\n", "    public void setArgs(Object[] args) {\n        this.args = args;\n    }\n\n    public Object getRes() {\n        return res;\n    }\n\n    public void setRes(Object res) {\n        this.res = res;\n    }\n}\n", "    public void setRes(Object res) {\n        this.res = res;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/protocol/RequestHeader.java", "chunked_list": ["package com.lint.rpc.common.protocol;\n\nimport com.lint.rpc.common.util.ByteUtil;\n\nimport java.io.Serializable;\nimport java.util.UUID;\n\n/**\n * \u8bf7\u6c42\u5934\n *", " * \u8bf7\u6c42\u5934\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:26 AM\n **/\npublic class RequestHeader implements Serializable {\n\n    /** \u6807\u8bc6 */\n    private int flag;\n\n    /** \u8bf7\u6c42ID */\n    private long requestId;\n\n    /** \u957f\u5ea6 */\n    private int length;\n\n    public RequestHeader(byte[] requestBodyBytes){\n        requestId = Math.abs(UUID.randomUUID().getLeastSignificantBits());\n        length = requestBodyBytes.length;\n    }\n", "    public void setVersion(byte version){\n        flag ^= version;\n    }\n\n    public byte getVersion(){\n        return (byte)((flag << 24) >> 24);\n    }\n\n    public byte[] toBytesArray(){\n        return ByteUtil.toByteArray(this);\n    }\n", "    public int getFlag() {\n        return flag;\n    }\n\n    public void setFlag(int flag) {\n        this.flag = flag;\n    }\n\n    public long getRequestId() {\n        return requestId;\n    }\n", "    public long getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(long requestId) {\n        this.requestId = requestId;\n    }\n\n    public int getLength() {\n        return length;\n    }\n", "    public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/protocol/RequestContent.java", "chunked_list": ["package com.lint.rpc.common.protocol;\n\nimport java.io.Serializable;\n\n/**\n * \u7efc\u5408\u4f53\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:26 AM\n **/\npublic class RequestContent implements Serializable {\n\n    private RequestHeader requestHeader;\n\n    private RequestBody requestBody;\n", " * @date 2023-05-26 11:26 AM\n **/\npublic class RequestContent implements Serializable {\n\n    private RequestHeader requestHeader;\n\n    private RequestBody requestBody;\n\n    public RequestHeader getRequestHeader() {\n        return requestHeader;\n    }\n", "    public RequestHeader getRequestHeader() {\n        return requestHeader;\n    }\n\n    public void setRequestHeader(RequestHeader requestHeader) {\n        this.requestHeader = requestHeader;\n    }\n\n    public RequestBody getRequestBody() {\n        return requestBody;\n    }\n", "    public RequestBody getRequestBody() {\n        return requestBody;\n    }\n\n    public void setRequestBody(RequestBody requestBody) {\n        this.requestBody = requestBody;\n    }\n\n    public void free() {\n        requestHeader = null;\n        requestBody = null;\n    }\n\n}\n", "    public void free() {\n        requestHeader = null;\n        requestBody = null;\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/thread/ExecuteThread.java", "chunked_list": ["package com.lint.rpc.common.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic final class ExecuteThread {\n\n    private final int cpuCount = Runtime.getRuntime().availableProcessors();\n    private final ExecutorService executorService = new ThreadPoolExecutor(\n            getThreadCoreCount(getThreadMaxCount(cpuCount)),\n            getThreadMaxCount(cpuCount),\n            60, TimeUnit.SECONDS,\n            new LinkedBlockingDeque<>(1024),\n            new ThreadPoolExecutor.CallerRunsPolicy());\n\n", "    public void execute(Runnable r){\n        try {\n            executorService.execute(new ThreadWrapper(r));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    private int getThreadCoreCount(int threadCoreCount){\n        int coreCount = threadCoreCount >> 1;\n        return Math.max(coreCount, 1);\n    }\n\n    private int getThreadMaxCount(int cpuCount){\n        int threadCoreCount = cpuCount > 2\n                ?  cpuCount - 1\n                : cpuCount;\n        return Math.max(threadCoreCount, 1);\n    }\n", "    public static class ThreadWrapper implements Runnable {\n\n        private final Runnable r;\n\n        public ThreadWrapper(Runnable r){\n            this.r = r;\n        }\n\n        @Override\n        public void run() {\n            try {\n                r.run();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class LazyHolder {\n        private static final ExecuteThread INSTANCE = new ExecuteThread();\n    }\n", "        public void run() {\n            try {\n                r.run();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class LazyHolder {\n        private static final ExecuteThread INSTANCE = new ExecuteThread();\n    }\n", "    public static ExecuteThread getInstance() {\n        return ExecuteThread.LazyHolder.INSTANCE;\n    }\n\n    private ExecuteThread(){}\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/util/ByteUtil.java", "chunked_list": ["package com.lint.rpc.common.util;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\n/**\n * \u4e8c\u8fdb\u5236\u8f6c\u5316\n *\n * @author \u5468\u9e4f\u7a0b", " *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 11:45 AM\n **/\npublic final class ByteUtil {\n\n    public static byte[] toByteArray(Object obj){\n        if(obj == null){\n            return new byte[0];\n        }\n\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] bytes = null;", "        try {\n            oos = new ObjectOutputStream(out);\n            oos.writeObject(obj);\n            bytes = out.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                out.reset();\n                out.close();\n                if(null != oos){\n                    oos.reset();\n                    oos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return bytes;\n    }\n\n    private ByteUtil(){}\n\n}\n", "                if(null != oos){\n                    oos.reset();\n                    oos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return bytes;\n    }\n\n    private ByteUtil(){}\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/bootstrap/LintRpcClientApplication.java", "chunked_list": ["package com.lint.rpc.common.bootstrap;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.enums.RpcMsg;\nimport com.lint.rpc.common.exception.RpcException;\nimport com.lint.rpc.common.pool.ConfPool;\nimport com.lint.rpc.common.service.ProvideSpi;\n\n/**\n * Lint RPC \u542f\u52a8\u5668", "/**\n * Lint RPC \u542f\u52a8\u5668\n */\npublic class LintRpcClientApplication {\n\n    public static void run(LintConf conf, Class<?> baseClazz){\n        if (null == conf\n                || null == conf.getProvideSpiType() || \"\".equals(conf.getProvideSpiType())){\n            throw new RpcException(RpcMsg.EXCEPTION_NOT_SET_CONF);\n        }\n\n        // 1. \u52a0\u8f7d\u5168\u5c40\u914d\u7f6e\n        ConfPool confPool = ConfPool.getInstance();\n        confPool.init(conf);\n\n        // 2. \u52a0\u8f7dSPI \u5e76\u521d\u59cb\u5316\n        ProvideSpi provideSpi = ProvideSpi.getInstance();\n        provideSpi.init();\n\n        // TODO baseClazz \u540e\u5e8f\u6269\u5c55\u4e00\u4e0b\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/bootstrap/LintRpcServerApplication.java", "chunked_list": ["package com.lint.rpc.common.bootstrap;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.enums.RpcMsg;\nimport com.lint.rpc.common.exception.RpcException;\nimport com.lint.rpc.common.pool.ConfPool;\nimport com.lint.rpc.common.service.ProvideServiceSpi;\nimport com.lint.rpc.common.service.ProvideSpi;\nimport com.lint.rpc.common.transport.NettyServer;\nimport com.lint.rpc.common.transport.NettyServerConf;", "import com.lint.rpc.common.transport.NettyServer;\nimport com.lint.rpc.common.transport.NettyServerConf;\n\n/**\n * Lint RPC \u542f\u52a8\u5668\n */\npublic class LintRpcServerApplication {\n\n    public static void run(int port, LintConf conf, Class<?> baseClazz){\n        if (null == conf\n                || null == conf.getProvideSpiType() || \"\".equals(conf.getProvideSpiType())){\n            throw new RpcException(RpcMsg.EXCEPTION_NOT_SET_CONF);\n        }\n\n        // 1. \u52a0\u8f7d\u5168\u5c40\u914d\u7f6e\n        ConfPool confPool = ConfPool.getInstance();\n        confPool.init(conf);\n\n        // 2. \u52a0\u8f7dSPI \u5e76\u521d\u59cb\u5316\n        ProvideSpi provideSpi = ProvideSpi.getInstance();\n        provideSpi.init();\n\n        // 3. \u52a0\u8f7d\u670d\u52a1\u7aefSPI\n        ProvideServiceSpi provideServiceSpi = ProvideServiceSpi.getInstance();\n        provideServiceSpi.init();\n\n        // TODO baseClazz \u540e\u5e8f\u6269\u5c55\u4e00\u4e0b\n\n        // 4. \u542f\u52a8\u670d\u52a1\u7aef\n        NettyServerConf nettyServerConf = new NettyServerConf();\n        nettyServerConf.setPort(port);\n        NettyServer server = new NettyServer(nettyServerConf);\n        server.init();\n    }\n\n}\n", "    public static void run(int port, LintConf conf, Class<?> baseClazz){\n        if (null == conf\n                || null == conf.getProvideSpiType() || \"\".equals(conf.getProvideSpiType())){\n            throw new RpcException(RpcMsg.EXCEPTION_NOT_SET_CONF);\n        }\n\n        // 1. \u52a0\u8f7d\u5168\u5c40\u914d\u7f6e\n        ConfPool confPool = ConfPool.getInstance();\n        confPool.init(conf);\n\n        // 2. \u52a0\u8f7dSPI \u5e76\u521d\u59cb\u5316\n        ProvideSpi provideSpi = ProvideSpi.getInstance();\n        provideSpi.init();\n\n        // 3. \u52a0\u8f7d\u670d\u52a1\u7aefSPI\n        ProvideServiceSpi provideServiceSpi = ProvideServiceSpi.getInstance();\n        provideServiceSpi.init();\n\n        // TODO baseClazz \u540e\u5e8f\u6269\u5c55\u4e00\u4e0b\n\n        // 4. \u542f\u52a8\u670d\u52a1\u7aef\n        NettyServerConf nettyServerConf = new NettyServerConf();\n        nettyServerConf.setPort(port);\n        NettyServer server = new NettyServer(nettyServerConf);\n        server.init();\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/enums/RpcMsg.java", "chunked_list": ["/**\n * Copyright 2020 OPSLI \u5feb\u901f\u5f00\u53d1\u5e73\u53f0 https://www.opsli.com\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software", " * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.lint.rpc.common.enums;\n\n/**", "\n/**\n * \u6838\u5fc3\u7c7b - \u6d88\u606f\n *\n * @author Parker\n * @date 2020-09-13 19:41\n */\npublic enum RpcMsg implements BaseMsg {\n\n    /** \u672a\u8bbe\u7f6e\u914d\u7f6e */\n    EXCEPTION_NOT_SET_CONF(2,\"The producer spi type is not set in the configuration or is specified in the configuration\"),\n    /** \u670d\u52a1\u672a\u542f\u52a8 */\n    EXCEPTION_SERVICE_NOT_STARTED(2,\"Service not started\"),\n\n\n    /** \u8bf7\u6c42\u8d85\u65f6 */\n    EXCEPTION_TIMEOUT(408,\"Request timeout\"),\n    /** \u65e0\u6cd5\u5efa\u7acb\u8fde\u63a5 */\n    EXCEPTION_NOT_CONNECTION(501,\"Unable to establish connection\"),\n    /** \u8bf7\u6c42\u9519\u8bef */\n    EXCEPTION_ERROR(500,\"Request error\"),\n\n\n    ;\n\n    private final int code;\n    private final String message;\n\n    RpcMsg(int code, String message){\n        this.code = code;\n        this.message = message;\n    }\n\n    @Override", "    public Integer getCode() {\n        return this.code;\n    }\n\n    @Override\n    public String getMessage() {\n        return this.message;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/enums/BaseMsg.java", "chunked_list": ["/**\n * Copyright 2020 OPSLI \u5feb\u901f\u5f00\u53d1\u5e73\u53f0 https://www.opsli.com\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software", " * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.lint.rpc.common.enums;\n\n/**", "\n/**\n * \u603b\u6d88\u606f\u7c7b \u7528\u6765\u5b58\u653e\u6d88\u606f\n * opsli\u5c06\u6d88\u606f\u5168\u90e8\u63d0\u53d6\u51fa\u81f3\u4e00\u4e2a\u603b\u6587\u4ef6\n *\n * @author Parker\n * @date 2020-09-22 17:07\n */\npublic interface BaseMsg {\n\n    /**\n     * \u83b7\u53d6\u6d88\u606f\u7684\u72b6\u6001\u7801\n     */\n    Integer getCode();\n\n    /**\n     * \u83b7\u53d6\u6d88\u606f\u63d0\u793a\u4fe1\u606f\n     */\n    String getMessage();\n\n}\n", "public interface BaseMsg {\n\n    /**\n     * \u83b7\u53d6\u6d88\u606f\u7684\u72b6\u6001\u7801\n     */\n    Integer getCode();\n\n    /**\n     * \u83b7\u53d6\u6d88\u606f\u63d0\u793a\u4fe1\u606f\n     */\n    String getMessage();\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/exception/RpcException.java", "chunked_list": ["package com.lint.rpc.common.exception;\n\n\nimport com.lint.rpc.common.enums.BaseMsg;\n\n/**\n * \u6846\u67b6\u670d\u52a1\u5f02\u5e38\n *\n * @author Parker\n * @date 2020-09-13 19:41", " * @author Parker\n * @date 2020-09-13 19:41\n */\npublic class RpcException extends RuntimeException{\n\n    private Integer code;\n\n    private String errorMessage;\n\n    public RpcException(Integer code, String errorMessage) {\n        super(errorMessage);\n        this.code = code;\n        this.errorMessage = errorMessage;\n    }\n\n    public RpcException(Integer code, String errorMessage, Throwable e) {\n        super(errorMessage, e);\n        this.code = code;\n        this.errorMessage = errorMessage;\n    }\n\n    public RpcException(BaseMsg msg) {\n        super(msg.getMessage());\n        this.code = msg.getCode();\n        this.errorMessage = msg.getMessage();\n    }\n\n    public RpcException(BaseMsg msg, Throwable e) {\n        super(msg.getMessage(), e);\n        this.code = msg.getCode();\n        this.errorMessage = msg.getMessage();\n    }\n", "    public Integer getCode() {\n        return code;\n    }\n\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n\n    public String getErrorMessage() {\n        return errorMessage;\n    }\n", "    public String getErrorMessage() {\n        return errorMessage;\n    }\n\n    public void setErrorMessage(String errorMessage) {\n        this.errorMessage = errorMessage;\n    }\n\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/NettyServer.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport com.lint.rpc.common.enums.RpcMsg;\nimport com.lint.rpc.common.exception.RpcException;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;", "import io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\n/**\n * Netty \u670d\u52a1\u7aef\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM\n **/\npublic class NettyServer {\n\n    private final NettyServerConf conf;\n\n    public NettyServer(NettyServerConf conf){\n        this.conf = conf;\n    }\n", " * @date 2023-05-26 12:45 PM\n **/\npublic class NettyServer {\n\n    private final NettyServerConf conf;\n\n    public NettyServer(NettyServerConf conf){\n        this.conf = conf;\n    }\n\n    public NettyServerConf getConf() {\n        return conf;\n    }\n", "    public NettyServerConf getConf() {\n        return conf;\n    }\n\n    public void init(){\n        int cpuCount = Runtime.getRuntime().availableProcessors();\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup(getThreadMaxCount(cpuCount));\n        ServerBootstrap bs = new ServerBootstrap();\n        ChannelFuture bind = bs.channel(NioServerSocketChannel.class)\n                .group(bossGroup, workerGroup)\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        p.addLast(new InternalServerMsgCodec());\n                        p.addLast(new ServerChannelHandler());\n                    }\n                })\n                .bind(conf.getPort());\n", "        try {\n            System.out.println(\"Lint Server port: \" + conf.getPort());\n            ChannelFuture f = bind.sync();\n            if (!f.isSuccess()) {\n                throw new RpcException(RpcMsg.EXCEPTION_SERVICE_NOT_STARTED);\n            }\n\n            bind.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private int getThreadMaxCount(int cpuCount){\n        int threadCoreCount = cpuCount > 2\n                ?  cpuCount - 1\n                : cpuCount;\n        return Math.max(threadCoreCount, 1);\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/ExceptionCaughtHandler.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n\n/**\n * \u5f02\u5e38\u5904\u7406\u5668\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 19:34:12", " * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 19:34:12\n */\npublic class ExceptionCaughtHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/NettyServerConf.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\n\npublic class NettyServerConf {\n\n    private int port;\n\n\n    public int getPort() {\n        return port;\n    }\n", "    public int getPort() {\n        return port;\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/NettyConf.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport java.net.InetSocketAddress;\nimport java.util.function.Consumer;\n\npublic class NettyConf {\n\n    private InetSocketAddress address;\n\n    private Consumer<NettyClient> closeCallback;\n\n", "    public InetSocketAddress getAddress() {\n        return address;\n    }\n\n    public void setAddress(InetSocketAddress address) {\n        this.address = address;\n    }\n\n    public Consumer<NettyClient> getCloseCallback() {\n        return closeCallback;\n    }\n", "    public void setCloseCallback(Consumer<NettyClient> closeCallback) {\n        this.closeCallback = closeCallback;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/InternalServerMsgCodec.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport com.lint.rpc.common.protocol.RequestBody;\nimport com.lint.rpc.common.protocol.RequestContent;\nimport com.lint.rpc.common.protocol.RequestHeader;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.CombinedChannelDuplexHandler;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.MessageToByteEncoder;", "import io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.MessageToByteEncoder;\n\nimport java.io.*;\nimport java.util.List;\n\n/**\n * \u5185\u90e8\u670d\u52a1\u5668\u6d88\u606f\u7f16\u89e3\u7801\u5668\n *\n * @author \u5468\u9e4f\u7a0b", " *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 19:34:07\n */\npublic final class InternalServerMsgCodec extends\n        CombinedChannelDuplexHandler<InternalServerMsgCodec.Decoder, InternalServerMsgCodec.Encoder> {\n\n    /**\n     * \u7c7b\u9ed8\u8ba4\u6784\u9020\u5668\n     */\n    public InternalServerMsgCodec() {\n        super.init(new Decoder(), new Encoder());\n    }\n\n\n    /**\n     * \u6d88\u606f\u89e3\u7801\u5668\n     */\n    static final class Decoder extends ByteToMessageDecoder {\n\n        private static final int HEAD_LENGTH = 107;\n\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf buff, List<Object> out) {\n            // \u5982\u679c\u6d88\u606f\u4e0d\u6ee1\u8db3\u4e0a\u9762\u8fd9\u4e2a\u4e24\u4e2a\u6761\u4ef6 \u76f4\u63a5\u4e0d\u5904\u7406", "            if(buff.readableBytes() < HEAD_LENGTH){\n                return;\n            }\n\n            // \u6807\u8bb0\u8bfb\u53d6\u4f4d\u7f6e\n            buff.markReaderIndex();\n\n            byte[] headByteArray = new byte[HEAD_LENGTH];\n            buff.readBytes(headByteArray);\n\n            RequestHeader requestHeader = null;\n            try(ByteArrayInputStream in = new ByteArrayInputStream(headByteArray);\n                ObjectInputStream ois = new ObjectInputStream(in);\n                ) {\n\n                requestHeader = (RequestHeader) ois.readObject();\n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n\n            // \u5982\u679c\u6d88\u606f\u4f53\u957f\u5ea6\u4e0d\u591f \u76f4\u63a5\u9000\u51fa", "            if(null == requestHeader ||\n                    buff.readableBytes() < requestHeader.getLength()){\n                // \u56de\u5230\u6807\u8bb0\u8bfb\u53d6\u4f4d\u7f6e\n                // \u4ec0\u4e48\u65f6\u5019 \u6d88\u606f\u8bfb\u5168\u4e86 \u4ec0\u4e48\u65f6\u5019\u518d\u7ee7\u7eed\u5f80\u540e\u6267\u884c\n                buff.resetReaderIndex();\n                return;\n            }\n\n            byte[] bodyByteArray = new byte[requestHeader.getLength()];\n            buff.readBytes(bodyByteArray);\n            RequestBody requestBody;\n            try(ByteArrayInputStream in = new ByteArrayInputStream(bodyByteArray);\n                ObjectInputStream ois = new ObjectInputStream(in);\n            ) {\n                requestBody = (RequestBody) ois.readObject();\n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n                requestBody = new RequestBody();\n            }\n\n//            System.out.println(\"\u6536\u5230\u6d88\u606f => \" +\n//                    \"requestId = \"+requestHeader.getRequestId() +\n//                    \", flag = \"+requestHeader.getFlag()+\n//                    \", bodyName = \"+requestBody.getName()+\n//                    \", bodyMethodName = \"+requestBody.getMethodName());\n\n            RequestContent requestContent = new RequestContent();\n            requestContent.setRequestHeader(requestHeader);\n            requestContent.setRequestBody(requestBody);\n\n            // \u51fa\u53d1\u6d88\u606f\u8bfb\u53d6\u4e8b\u4ef6\n            ctx.fireChannelRead(requestContent);\n        }\n    }\n\n    /**\n     * \u6d88\u606f\u7f16\u7801\u5668\n     */\n    static final class Encoder extends MessageToByteEncoder<RequestContent> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, RequestContent innerMsg, ByteBuf byteBuf) {\n            // \u5199\u51fahead\n            byteBuf.writeBytes(innerMsg.getRequestHeader().toBytesArray());\n            // \u5199\u51fabody\n            byteBuf.writeBytes(innerMsg.getRequestBody().toBytesArray());\n            // \u91ca\u653e\u5185\u5b58\n            innerMsg.free();\n        }\n    }\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/ClientFactory.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\n\n/**\n * \u83b7\u53d6 client\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 3:59 PM\n **/\npublic class ClientFactory {\n\n", " **/\npublic class ClientFactory {\n\n\n    public NettyClient create(NettyConf nettyConf){\n        return new NettyClient(nettyConf);\n    }\n\n    private static class LazyHolder {\n        private static final ClientFactory INSTANCE = new ClientFactory();\n    }\n", "    public static ClientFactory getInstance() {\n        return ClientFactory.LazyHolder.INSTANCE;\n    }\n\n    private ClientFactory(){}\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/NettyClient.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\nimport java.net.InetSocketAddress;", "\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.function.Consumer;\n\n/**\n * Netty \u5ba2\u6237\u7aef", "/**\n * Netty \u5ba2\u6237\u7aef\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 12:45 PM\n **/\npublic class NettyClient {\n\n    private final NettyConf conf;\n    private volatile NioSocketChannel ch;\n\n    public NettyClient(NettyConf conf){\n        this.conf = conf;\n    }\n", "    public boolean sendMsg(Object msg){\n        if(ch == null){\n            synchronized (this){\n                if(ch == null){\n                    this.connect();\n                }\n            }\n        }\n\n        if(ch == null){\n            return false;\n        }", "        if(ch == null){\n            return false;\n        }\n        try {\n            ch.writeAndFlush(msg).sync();\n            return true;\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "    public NettyConf getConf() {\n        return conf;\n    }\n\n    private void connect(){\n        if(null == conf.getAddress()){\n            return;\n        }\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        Bootstrap bs = new Bootstrap();\n        bs.group(workGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new InternalServerMsgCodec());\n                        pipeline.addLast(new ClientChannelHandler());\n                    }\n                });", "        try {\n            ChannelFuture f = bs.connect(conf.getAddress()).sync();\n            if (!f.isSuccess()) {\n                return;\n            }\n\n            ch = (NioSocketChannel) f.channel();\n            ch.closeFuture().addListener(this::onLoseConnect);\n\n            System.out.println(\">>> \u8fde\u63a5\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u6210\u529f! \"+conf.getAddress()+\" <<<\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * \u5f53\u5931\u53bb\u8fde\u63a5\u65f6\n     *\n     * @param f \u9884\u671f\n     */\n    private void onLoseConnect(Future<?> f) {\n        System.out.println(\"\u7cfb\u7edf\u901a\u77e5 - \u6ce8\u610f: \u670d\u52a1\u5668\u8fde\u63a5\u5173\u95ed! >>> \" + conf.getAddress());\n        this.ch = null;\n        final Consumer<NettyClient> closeCallback = conf.getCloseCallback();", "        if(null != closeCallback){\n            closeCallback.accept(this);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(conf.getAddress().getHostName(), conf.getAddress().getPort());\n    }\n\n    @Override", "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()){\n            return false;\n        }\n\n        NettyConf selfConf = this.getConf();\n        NettyClient client = (NettyClient) obj;\n        NettyConf clientConf = client.getConf();\n\n        return selfConf.getAddress().getHostName().equals(clientConf.getAddress().getHostName())\n                && selfConf.getAddress().getPort() == clientConf.getAddress().getPort();\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/ClientChannelHandler.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport com.lint.rpc.common.pool.CountDownLatchPool;\nimport com.lint.rpc.common.pool.MsgPool;\nimport com.lint.rpc.common.protocol.RequestBody;\nimport com.lint.rpc.common.protocol.RequestContent;\nimport com.lint.rpc.common.protocol.RequestHeader;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n", "import io.netty.channel.ChannelInboundHandlerAdapter;\n\n\npublic class ClientChannelHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        if(!(msg instanceof RequestContent)){\n            return;\n        }\n\n        //System.out.println(\"\u5ba2\u6237\u7aef\u5904\u7406\u6570\u636e......\");\n\n        RequestContent content = (RequestContent) msg;\n        RequestHeader requestHeader = content.getRequestHeader();\n        RequestBody requestBody = content.getRequestBody();\n\n        MsgPool.put(requestHeader.getRequestId(), requestBody.getRes());\n        CountDownLatchPool.countDown(requestHeader.getRequestId());\n    }\n\n\n}"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/transport/ServerChannelHandler.java", "chunked_list": ["package com.lint.rpc.common.transport;\n\nimport com.lint.rpc.common.protocol.RequestBody;\nimport com.lint.rpc.common.protocol.RequestContent;\nimport com.lint.rpc.common.protocol.RequestHeader;\nimport com.lint.rpc.common.service.ProvideServiceSpi;\nimport com.lint.rpc.common.spi.LintService;\nimport com.lint.rpc.common.thread.ExecuteThread;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;", "import io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport java.lang.reflect.Method;\n\npublic class ServerChannelHandler extends ChannelInboundHandlerAdapter {\n\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        if(!(msg instanceof RequestContent)){\n            return;\n        }\n\n        //System.out.println(Thread.currentThread().getName() + \" \u670d\u52a1\u7aef\u5904\u7406\u6570\u636e......\");\n\n        RequestContent content = (RequestContent) msg;\n        RequestHeader requestHeader = content.getRequestHeader();\n        RequestBody requestBody = content.getRequestBody();\n\n        // \u672c\u8eab\u53ef\u4ee5\u53d7\u5230 NettyEventLoop\u7ebf\u7a0b \u8fdb\u884c\u591a\u7ebf\u7a0b\u6267\u884c\n        ProvideServiceSpi spi = ProvideServiceSpi.getInstance();\n        LintService service = spi.getService(requestBody.getName(), requestHeader.getVersion());", "    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        if(!(msg instanceof RequestContent)){\n            return;\n        }\n\n        //System.out.println(Thread.currentThread().getName() + \" \u670d\u52a1\u7aef\u5904\u7406\u6570\u636e......\");\n\n        RequestContent content = (RequestContent) msg;\n        RequestHeader requestHeader = content.getRequestHeader();\n        RequestBody requestBody = content.getRequestBody();\n\n        // \u672c\u8eab\u53ef\u4ee5\u53d7\u5230 NettyEventLoop\u7ebf\u7a0b \u8fdb\u884c\u591a\u7ebf\u7a0b\u6267\u884c\n        ProvideServiceSpi spi = ProvideServiceSpi.getInstance();\n        LintService service = spi.getService(requestBody.getName(), requestHeader.getVersion());", "        if(null == service){\n            return;\n        }\n\n        try {\n            Method method = service.getClass().getMethod(requestBody.getMethodName());\n            Object res = method.invoke(service, requestBody.getArgs());\n            requestBody.setRes(res);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n        requestHeader.setLength(requestBody.toBytesArray().length);\n        ctx.channel().writeAndFlush(content);\n\n        // \u8f6c\u591a\u7ebf\u7a0b\u5904\u7406\n//        ExecuteThread et = ExecuteThread.getInstance();\n//        et.execute(()->{\n//            ProvideServiceSpi spi = ProvideServiceSpi.getInstance();\n//            LintService service = spi.getService(requestBody.getName(), requestHeader.getVersion());", "//            if(null == service){\n//                return;\n//            }\n//\n//            try {\n//                Method method = service.getClass().getMethod(requestBody.getMethodName());\n//                Object res = method.invoke(service, requestBody.getArgs());\n//                requestBody.setRes(res);\n//            }catch (Exception e){\n//                e.printStackTrace();\n//            }\n//\n//            requestHeader.setLength(requestBody.toBytesArray().length);\n//            ctx.channel().writeAndFlush(content);\n//        });\n    }\n}"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/service/ProvideServiceSpi.java", "chunked_list": ["package com.lint.rpc.common.service;\n\nimport com.lint.rpc.common.annotation.RpcService;\nimport com.lint.rpc.common.spi.LintService;\n\nimport java.util.Map;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic final class ProvideServiceSpi {\n\n\n    private final Map<String, LintService> serviceMap = new ConcurrentHashMap<>();\n\n    private volatile boolean isInit = false;\n", "\npublic final class ProvideServiceSpi {\n\n\n    private final Map<String, LintService> serviceMap = new ConcurrentHashMap<>();\n\n    private volatile boolean isInit = false;\n\n    public void init(){\n        if(!isInit){\n            synchronized (this){", "    public void init(){\n        if(!isInit){\n            synchronized (this){\n                if(!isInit){\n                    ServiceLoader<LintService> loader = ServiceLoader.load(LintService.class);\n                    for (LintService ls : loader) {\n                        RpcService annotation = ls.getClass().getAnnotation(RpcService.class);\n                        if(null == annotation){\n                            System.out.println(\n                                    \"warning spi class not found @RpcService >>> \" +\n                                    ls.getClass().getName());\n                            continue;\n                        }\n\n\n                        serviceMap.putIfAbsent(annotation.name()+\":\"+annotation.version(), ls);\n                    }\n                    isInit = true;\n                }\n            }\n        }\n    }\n", "    public LintService getService(String serviceName, short version){\n        return serviceMap.get(serviceName+\":\"+version);\n    }\n\n\n    private static class LazyHolder {\n        private static final ProvideServiceSpi INSTANCE = new ProvideServiceSpi();\n    }\n\n    public static ProvideServiceSpi getInstance() {\n        return LazyHolder.INSTANCE;\n    }\n\n    private ProvideServiceSpi(){}\n\n}\n", "    public static ProvideServiceSpi getInstance() {\n        return LazyHolder.INSTANCE;\n    }\n\n    private ProvideServiceSpi(){}\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/service/ProvideSpi.java", "chunked_list": ["package com.lint.rpc.common.service;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.pool.ConfPool;\nimport com.lint.rpc.common.spi.IProvideService;\n\nimport java.net.InetSocketAddress;\nimport java.util.LinkedHashSet;\nimport java.util.ServiceLoader;\n\npublic final class ProvideSpi {\n\n    private IProvideService provideService = null;\n\n    private volatile boolean isInit = false;\n", "import java.util.ServiceLoader;\n\npublic final class ProvideSpi {\n\n    private IProvideService provideService = null;\n\n    private volatile boolean isInit = false;\n\n    public void init(){\n        if(!isInit){\n            synchronized (this){", "    public void init(){\n        if(!isInit){\n            synchronized (this){\n                if(!isInit){\n                    ConfPool confPool = ConfPool.getInstance();\n                    LintConf lintConf = confPool.get();\n                    ServiceLoader<IProvideService> loader = ServiceLoader.load(IProvideService.class);\n                    for (IProvideService ps : loader) {\n                        if (!lintConf.getProvideSpiType().equals(ps.getType())) {\n                            continue;\n                        }\n\n                        provideService = ps;\n                        break;\n                    }\n                    isInit = true;\n                }\n            }\n        }\n    }\n\n    public LinkedHashSet<InetSocketAddress> getAddressByServiceName(String serviceName){", "                        if (!lintConf.getProvideSpiType().equals(ps.getType())) {\n                            continue;\n                        }\n\n                        provideService = ps;\n                        break;\n                    }\n                    isInit = true;\n                }\n            }\n        }\n    }\n\n    public LinkedHashSet<InetSocketAddress> getAddressByServiceName(String serviceName){", "        if(null == provideService || null == provideService.getProvide()){\n            return null;\n        }\n        return provideService.getProvide().get(serviceName);\n    }\n\n\n    private static class LazyHolder {\n        private static final ProvideSpi INSTANCE = new ProvideSpi();\n    }\n", "    public static ProvideSpi getInstance() {\n        return ProvideSpi.LazyHolder.INSTANCE;\n    }\n\n    private ProvideSpi(){}\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/annotation/RpcService.java", "chunked_list": ["package com.lint.rpc.common.annotation;\n\nimport java.lang.annotation.*;\n\n/**\n * RPC Provide \u670d\u52a1\u7aef\u6ce8\u89e3\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:04 AM\n **/", " * @date 2023-05-26 10:04 AM\n **/\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RpcService {\n\n    /** \u8d1f\u8f7d\u670d\u52a1\u540d */\n    String name();\n", "    String name();\n\n    /** \u8d1f\u8f7d\u670d\u52a1\u7248\u672c */\n    byte version();\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/annotation/RpcClient.java", "chunked_list": ["package com.lint.rpc.common.annotation;\n\nimport com.lint.rpc.common.balance.ILoadBalancePolicy;\nimport com.lint.rpc.common.balance.RoundLoadBalance;\n\nimport java.lang.annotation.*;\n\n/**\n * RPC Consumer \u5ba2\u6237\u7aef\u6ce8\u89e3\n *", " * RPC Consumer \u5ba2\u6237\u7aef\u6ce8\u89e3\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:04 AM\n **/\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RpcClient {\n", "public @interface RpcClient {\n\n    /** \u8d1f\u8f7d\u670d\u52a1\u540d */\n    String name();\n\n    /** \u8d1f\u8f7d\u670d\u52a1\u7248\u672c */\n    byte version();\n\n    /** \u8d1f\u8f7d\u7b56\u7565 */\n    Class<? extends ILoadBalancePolicy> loadBalancePolicy() default RoundLoadBalance.class;", "    /** \u8d1f\u8f7d\u7b56\u7565 */\n    Class<? extends ILoadBalancePolicy> loadBalancePolicy() default RoundLoadBalance.class;\n\n    /** \u62d2\u7edd\u7b56\u7565 */\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/balance/RoundLoadBalance.java", "chunked_list": ["package com.lint.rpc.common.balance;\n\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * \u8f6e\u5de1\u8d1f\u8f7d\u7b56\u7565\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:12 AM", " * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:12 AM\n **/\npublic class RoundLoadBalance implements ILoadBalancePolicy{\n\n    private final AtomicInteger loopFlag = new AtomicInteger(0);\n\n    @Override\n    public int getClientIndex(int size) {\n        if(size <= 0){\n            return -1;\n        }\n\n        return size != 1\n                // random bound \u4e0a\u754c\u4e0d\u5305\u62ec \u9700\u8981+1\n                ? loopFlag.incrementAndGet() % size\n                : size;\n    }\n\n\n\n    /**\n     * \u5b9e\u9a8c atomicInteger \u4f1a\u4e0d\u4f1a \u5faa\u73af\u8f6c\u6362\n     */", "    public int getClientIndex(int size) {\n        if(size <= 0){\n            return -1;\n        }\n\n        return size != 1\n                // random bound \u4e0a\u754c\u4e0d\u5305\u62ec \u9700\u8981+1\n                ? loopFlag.incrementAndGet() % size\n                : size;\n    }\n\n\n\n    /**\n     * \u5b9e\u9a8c atomicInteger \u4f1a\u4e0d\u4f1a \u5faa\u73af\u8f6c\u6362\n     */", "//    public static void main(String[] args) {\n//        int base = 2 << 6;\n//        boolean flag = false;\n//        for(;;){\n//            int i = atomicInteger.decrementAndGet();\n//            int index = atomicInteger.decrementAndGet() & base-1;\n//            if(i < 0 && !flag ){\n//                System.out.println(index + \"----\" + i);\n//                flag = true;\n//            }\n//            if(i > 0 && flag ){\n//                System.out.println(index + \"----\" + i);\n//                flag = false;\n//            }\n//        }\n//    }\n}\n", "//            if(i > 0 && flag ){\n//                System.out.println(index + \"----\" + i);\n//                flag = false;\n//            }\n//        }\n//    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/balance/ILoadBalancePolicy.java", "chunked_list": ["package com.lint.rpc.common.balance;\n\n/**\n * \u8d1f\u8f7d\u7b56\u7565\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:10 AM\n **/\npublic interface ILoadBalancePolicy {\n\n    /**\n     * \u83b7\u53d6\u5ba2\u6237\u7aef\n     */\n    int getClientIndex(int size);\n\n}\n", "public interface ILoadBalancePolicy {\n\n    /**\n     * \u83b7\u53d6\u5ba2\u6237\u7aef\n     */\n    int getClientIndex(int size);\n\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/balance/RandomLoadBalance.java", "chunked_list": ["package com.lint.rpc.common.balance;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\n/**\n * \u968f\u673a\u8d1f\u8f7d\u7b56\u7565\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:12 AM\n **/\npublic class RandomLoadBalance implements ILoadBalancePolicy{\n\n    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n\n    @Override", " * @date 2023-05-26 10:12 AM\n **/\npublic class RandomLoadBalance implements ILoadBalancePolicy{\n\n    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n\n    @Override\n    public int getClientIndex(int size) {\n        if(size <= 0){\n            return -1;\n        }\n\n        return size != 1\n                // random bound \u4e0a\u754c\u4e0d\u5305\u62ec \u9700\u8981+1\n                ? random.nextInt(size+1)\n                : size;\n    }\n}\n", "        if(size <= 0){\n            return -1;\n        }\n\n        return size != 1\n                // random bound \u4e0a\u754c\u4e0d\u5305\u62ec \u9700\u8981+1\n                ? random.nextInt(size+1)\n                : size;\n    }\n}\n"]}
{"filename": "lint-rpc-support/lint-rpc-support-common/src/main/java/com/lint/rpc/common/balance/LoadBalancePolicyFactory.java", "chunked_list": ["package com.lint.rpc.common.balance;\n\nimport com.lint.rpc.common.annotation.RpcClient;\nimport com.lint.rpc.common.pool.ClientPool;\nimport com.lint.rpc.common.transport.NettyClient;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**", "\n/**\n * \u8d1f\u8f7d\u7b56\u7565\u5355\u4f8b\u5de5\u5382\n *\n * @author \u5468\u9e4f\u7a0b\n * @date 2023-05-26 10:53 AM\n **/\npublic class LoadBalancePolicyFactory {\n\n\n    private final Object lock = new Object();\n    private final Map<Class<? extends ILoadBalancePolicy>,  ILoadBalancePolicy>\n            loadBalancePolicyMap = new ConcurrentHashMap<>();\n\n", "    public NettyClient getClient(Class<?> interfaceClazz) {\n        RpcClient rpcClientAnnotation = interfaceClazz.getAnnotation(RpcClient.class);\n        ILoadBalancePolicy loadBalancePolicy = getLoadBalancePolicy(rpcClientAnnotation.loadBalancePolicy());\n        if(null == loadBalancePolicy){\n            return null;\n        }\n\n        ClientPool pool = ClientPool.getInstance();\n        // \u9009\u62e9\u5ba2\u6237\u7aef\n        return pool.get(rpcClientAnnotation.name(), loadBalancePolicy);\n    }\n\n\n    private ILoadBalancePolicy getLoadBalancePolicy(\n            Class<? extends ILoadBalancePolicy> loadBalancePolicyClazz){\n        ILoadBalancePolicy loadBalancePolicy = loadBalancePolicyMap.get(loadBalancePolicyClazz);", "        if(null != loadBalancePolicy){\n            return loadBalancePolicy;\n        }\n\n        // DCL\n        synchronized (lock){\n            loadBalancePolicy = loadBalancePolicyMap.get(loadBalancePolicyClazz);\n            if(null != loadBalancePolicy){\n                return loadBalancePolicy;\n            }\n", "            try {\n                loadBalancePolicy = loadBalancePolicyClazz.newInstance();\n                loadBalancePolicyMap.putIfAbsent(loadBalancePolicyClazz, loadBalancePolicy);\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n            return loadBalancePolicy;\n        }\n    }\n\n    private LoadBalancePolicyFactory(){}\n\n    private static class LazyHolder {\n        private static final LoadBalancePolicyFactory INSTANCE = new LoadBalancePolicyFactory();\n    }\n", "    public static LoadBalancePolicyFactory getInstance() {\n        return LazyHolder.INSTANCE;\n    }\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-spi/src/main/java/com/lint/rpc/demo/spi/ProvideEatInterface.java", "chunked_list": ["package com.lint.rpc.demo.spi;\n\nimport com.lint.rpc.common.spi.LintService;\n\npublic interface ProvideEatInterface extends LintService {\n\n    String choose();\n\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-spi/src/main/java/com/lint/rpc/demo/spi/ProvideDrinkInterface.java", "chunked_list": ["package com.lint.rpc.demo.spi;\n\nimport com.lint.rpc.common.spi.LintService;\n\nimport java.util.List;\n\npublic interface ProvideDrinkInterface extends LintService {\n\n    String choose();\n\n    List<String> getDrinkListAll();\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-provide2/src/main/java/com/lint/rpc/demo/provide/Provide2Application.java", "chunked_list": ["package com.lint.rpc.demo.provide;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.bootstrap.LintRpcServerApplication;\n\npublic class Provide2Application {\n\n    public static void main(String[] args) {\n        LintConf conf = new LintConf().setProvideSpiType(\"local\");\n        LintRpcServerApplication.run(9090, conf, Provide2Application.class);\n    }\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-provide2/src/main/java/com/lint/rpc/demo/provide/service/ProvideDrinkImpl.java", "chunked_list": ["package com.lint.rpc.demo.provide.service;\n\nimport com.lint.rpc.common.annotation.RpcService;\nimport com.lint.rpc.demo.spi.ProvideDrinkInterface;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n", "import java.util.Random;\n\n@RpcService(name = \"provide2\", version = 1)\npublic class ProvideDrinkImpl implements ProvideDrinkInterface {\n\n    private final static String[] drink = {\"coffee\", \"tea\", \"soda\", \"milk\"};\n\n    private final Random random = new Random();\n\n    @Override\n    public String choose() {\n        return drink[random.nextInt(drink.length)];\n    }\n\n    @Override\n    public List<String> getDrinkListAll() {\n        return new ArrayList<>(Arrays.asList(drink));\n    }\n}\n", "    public String choose() {\n        return drink[random.nextInt(drink.length)];\n    }\n\n    @Override\n    public List<String> getDrinkListAll() {\n        return new ArrayList<>(Arrays.asList(drink));\n    }\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-provide1/src/main/java/com/lint/rpc/demo/provide/Provide1Application.java", "chunked_list": ["package com.lint.rpc.demo.provide;\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.bootstrap.LintRpcServerApplication;\n\npublic class Provide1Application {\n\n    public static void main(String[] args) {\n        LintConf conf = new LintConf().setProvideSpiType(\"local\");\n        LintRpcServerApplication.run(8080, conf, Provide1Application.class);\n    }\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-provide1/src/main/java/com/lint/rpc/demo/provide/proxy/ProvideDrinkInterfaceSpi.java", "chunked_list": ["package com.lint.rpc.demo.provide.proxy;\n\nimport com.lint.rpc.common.annotation.RpcClient;\nimport com.lint.rpc.demo.spi.ProvideDrinkInterface;\n\n@RpcClient(name = \"provide2\", version = 1)\npublic interface ProvideDrinkInterfaceSpi extends ProvideDrinkInterface {\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-provide1/src/main/java/com/lint/rpc/demo/provide/service/ProvideEatImpl.java", "chunked_list": ["package com.lint.rpc.demo.provide.service;\n\nimport com.lint.rpc.common.annotation.RpcService;\nimport com.lint.rpc.common.pool.ProxyPool;\nimport com.lint.rpc.demo.provide.proxy.ProvideDrinkInterfaceSpi;\nimport com.lint.rpc.demo.spi.ProvideEatInterface;\n\nimport java.util.Random;\n\n@RpcService(name = \"provide1\", version = 1)\npublic class ProvideEatImpl implements ProvideEatInterface {\n\n    private final static String[] food = {\"tomato\", \"pineapple\", \"banana\"};\n\n    private final Random random = new Random();\n\n//    @Override", "\n@RpcService(name = \"provide1\", version = 1)\npublic class ProvideEatImpl implements ProvideEatInterface {\n\n    private final static String[] food = {\"tomato\", \"pineapple\", \"banana\"};\n\n    private final Random random = new Random();\n\n//    @Override\n//    public String choose() {\n//        return food[random.nextInt(food.length)];\n//    }\n\n    @Override", "//    public String choose() {\n//        return food[random.nextInt(food.length)];\n//    }\n\n    @Override\n    public String choose() {\n        String f = food[random.nextInt(food.length)];\n        ProvideDrinkInterfaceSpi proxyGet = ProxyPool.getProxyGet(ProvideDrinkInterfaceSpi.class);\n        if(null != proxyGet){\n            String d = proxyGet.choose();\n            return \"[ eta -> \"+f+\" And drink -> \"+d+\"]\";\n        }else {\n            return food[random.nextInt(food.length)];\n        }\n    }\n}\n", "        if(null != proxyGet){\n            String d = proxyGet.choose();\n            return \"[ eta -> \"+f+\" And drink -> \"+d+\"]\";\n        }else {\n            return food[random.nextInt(food.length)];\n        }\n    }\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-consumer/src/main/java/com/lint/rpc/demo/consumer/ConsumerApplication.java", "chunked_list": ["package com.lint.rpc.demo.consumer;\n\n\nimport com.lint.rpc.common.LintConf;\nimport com.lint.rpc.common.bootstrap.LintRpcClientApplication;\nimport com.lint.rpc.common.pool.ProxyPool;\nimport com.lint.rpc.demo.consumer.proxy.ProvideDrinkInterfaceSpi;\nimport com.lint.rpc.demo.consumer.proxy.ProvideEatInterfaceSpi;\n\nimport java.io.IOException;", "\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConsumerApplication {\n", "\npublic class ConsumerApplication {\n\n    public static void main(String[] args) throws IOException {\n        LintConf conf = new LintConf().setProvideSpiType(\"local\").setClientMaxConnCount((byte)3);\n        LintRpcClientApplication.run(conf, ConsumerApplication.class);\n\n        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);\n        System.out.println(\"schedule \u65b9\u6cd5\u6dfb\u52a0\u4efb\u52a1\uff1a\" + LocalDateTime.now());\n        threadPool.scheduleAtFixedRate(() -> {\n            CountDownLatch c = new CountDownLatch(20);\n            // \u62df\u5e76\u53d1\u8bf7\u6c42", "            for (int i = 0; i < c.getCount(); i++) {\n                new Thread(()->{\n                    // \u8c03\u7528\u94fe\u8def1 \u751f\u4ea7\u80051 -> \u751f\u4ea7\u80052 \uff0c \u8f93\u51fa\u5408\u5e76\u7ed3\u679c\n                    ProvideEatInterfaceSpi provide1 =\n                            ProxyPool.getProxyGet(ProvideEatInterfaceSpi.class);\n                    // \u8c03\u7528\u94fe\u8def2 \u751f\u4ea7\u8fd92 \uff0c\u8f93\u51fa\u4e00\u4e2aList\u96c6\u5408\n                    ProvideDrinkInterfaceSpi provide2 =\n                            ProxyPool.getProxyGet(ProvideDrinkInterfaceSpi.class);\n                    String choose = provide1.choose();\n\n                    StringBuilder sb = new StringBuilder();\n                    List<String> drinkListAll = provide2.getDrinkListAll();", "                    for (String s : drinkListAll) {\n                        sb.append(s).append(\" \");\n                    }\n\n                    System.out.println(Thread.currentThread().getName()+\n                            \" choose >>> \"+choose +\" ---- drinkListAll >>> \"+sb.toString());\n                    c.countDown();\n                }).start();\n            }\n            try {\n                c.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\");\n        }, 0,20, TimeUnit.SECONDS); // 3s \u4e4b\u540e\u6267\u884c\n\n        System.in.read();\n    }\n\n}\n", "            try {\n                c.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\");\n        }, 0,20, TimeUnit.SECONDS); // 3s \u4e4b\u540e\u6267\u884c\n\n        System.in.read();\n    }\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-consumer/src/main/java/com/lint/rpc/demo/consumer/proxy/ProvideEatInterfaceSpi.java", "chunked_list": ["package com.lint.rpc.demo.consumer.proxy;\n\nimport com.lint.rpc.common.annotation.RpcClient;\nimport com.lint.rpc.demo.spi.ProvideEatInterface;\n\n@RpcClient(name = \"provide1\", version = 1)\npublic interface ProvideEatInterfaceSpi extends ProvideEatInterface {\n\n}\n"]}
{"filename": "lint-rpc-demo/lint-rpc-demo-consumer/src/main/java/com/lint/rpc/demo/consumer/proxy/ProvideDrinkInterfaceSpi.java", "chunked_list": ["package com.lint.rpc.demo.consumer.proxy;\n\nimport com.lint.rpc.common.annotation.RpcClient;\nimport com.lint.rpc.demo.spi.ProvideDrinkInterface;\n\n@RpcClient(name = \"provide2\", version = 1)\npublic interface ProvideDrinkInterfaceSpi extends ProvideDrinkInterface {\n\n}\n"]}
