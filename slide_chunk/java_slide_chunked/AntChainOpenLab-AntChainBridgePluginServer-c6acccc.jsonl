{"filename": "ps-bootstrap/src/test/java/com/alipay/antchain/bridge/pluginserver/AntChainBridgePluginServerApplicationTests.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver;\n", "package com.alipay.antchain.bridge.pluginserver;\n\nimport cn.hutool.core.collection.ListUtil;\nimport cn.hutool.crypto.digest.DigestUtil;\nimport com.alipay.antchain.bridge.commons.bbc.AbstractBBCContext;\nimport com.alipay.antchain.bridge.commons.bbc.DefaultBBCContext;\nimport com.alipay.antchain.bridge.commons.bbc.syscontract.ContractStatusEnum;\nimport com.alipay.antchain.bridge.commons.bbc.syscontract.SDPContract;\nimport com.alipay.antchain.bridge.pluginserver.AntChainBridgePluginServerApplication;\nimport com.alipay.antchain.bridge.pluginserver.server.CrossChainServiceImpl;", "import com.alipay.antchain.bridge.pluginserver.AntChainBridgePluginServerApplication;\nimport com.alipay.antchain.bridge.pluginserver.server.CrossChainServiceImpl;\nimport com.alipay.antchain.bridge.pluginserver.server.ResponseBuilder;\nimport com.alipay.antchain.bridge.pluginserver.service.*;\nimport com.alipay.antchain.bridge.pluginserver.service.*;\nimport com.google.protobuf.ByteString;\nimport io.grpc.stub.StreamObserver;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.springframework.beans.factory.annotation.Autowired;", "import org.mockito.Mockito;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.DirtiesContext;\n\nimport java.util.HashMap;\n\n@SpringBootTest(classes = AntChainBridgePluginServerApplication.class, webEnvironment = SpringBootTest.WebEnvironment.NONE)\nclass AntChainBridgePluginServerApplicationTests {\n", "class AntChainBridgePluginServerApplicationTests {\n\n    private static final String TEST_PRODUCT = \"testchain\";\n    private static final String TEST_PRODUCT1 = \"testchain1\";\n    private static final String TEST_DOMAIN = \"domain\";\n\n    @Autowired\n    private CrossChainServiceImpl crossChainService;\n\n    private StreamObserver<Response> responseStreamObserver;", "\n    private StreamObserver<Response> responseStreamObserver;\n\n    @Test\n    @DirtiesContext\n    public void testHeartbeat() {\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n\n        Empty heartbeatReq = Empty.newBuilder().build();\n\n        crossChainService.heartbeat(heartbeatReq, responseStreamObserver);\n\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildHeartbeatSuccessResp(\n                HeartbeatResponse.newBuilder()\n                        .addAllDomains(ListUtil.toList())\n                        .addAllProducts(ListUtil.toList(TEST_PRODUCT))\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testIfProductSupport(){\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n\n        IfProductSupportRequest ifProductSupportRequest = IfProductSupportRequest.newBuilder()\n                .addAllProducts(ListUtil.toList(TEST_PRODUCT, TEST_PRODUCT1)).build();\n\n        crossChainService.ifProductSupport(ifProductSupportRequest, responseStreamObserver);\n\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildIfProductSupportSuccessResp(\n                IfProductSupportResponse.newBuilder().putAllResults(new HashMap<String, Boolean>(){{\n                    put(TEST_PRODUCT, true);\n                    put(TEST_PRODUCT1, false);\n                }})\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testIfDomainAlive(){\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n\n        IfDomainAliveRequest ifDomainAliveRequest = IfDomainAliveRequest.newBuilder()\n                        .addAllDomains(ListUtil.toList(TEST_DOMAIN)).build();\n\n        crossChainService.ifDomainAlive(ifDomainAliveRequest, responseStreamObserver);\n\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildIfDomainAliveSuccessResp(\n                IfDomainAliveResponse.newBuilder().putAllResults(new HashMap<String, Boolean>(){{\n                    put(TEST_DOMAIN,false);\n                }})\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testBBCCallStartReq() {\n        CallBBCRequest callBBCRequest;\n\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        AbstractBBCContext mockDeployedCtx = mockDeployedCtx();\n\n        // start up (create and startup)\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_Shutdown(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // shut down\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setShutdownReq(ShutdownRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver)\n                .onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // start up (startup after shutdowm)\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_GetContext(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // get context\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setGetContextReq(GetContextRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setGetContextResp(GetContextResponse.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes())))\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_SetupSDPMessageContract(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // set up sdp contract\n        AbstractBBCContext mockDeployedCtx = mockDeployedCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setSetupSDPMessageContractReq(SetupSDPMessageContractRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setSetupSDPResp(SetupSDPMessageContractResponse.newBuilder()\n                        .setSdpContract(\n                                SDPMessageContract.newBuilder()\n                                        .setContractAddress(mockDeployedCtx.getSdpContract().getContractAddress())\n                                        .setStatusValue(mockDeployedCtx.getSdpContract().getStatus().ordinal())\n                        )\n                )\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_SetupAuthMessageContract(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // set up am contract\n        AbstractBBCContext mockDeployedCtx = mockDeployedCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setSetupAuthMessageContractReq(SetupAuthMessageContractRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setSetupAMResp(SetupAuthMessageContractResponse.newBuilder()\n                        .setAmContract(\n                                AuthMessageContract.newBuilder()\n                                        .setContractAddress(mockDeployedCtx.getAuthMessageContract().getContractAddress())\n                                        .setStatusValue(mockDeployedCtx.getAuthMessageContract().getStatus().ordinal())\n                        )\n                )));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_SetProtocol(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // set protocol\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setSetProtocolReq(SetProtocolRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_SetAmContract(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // set am\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setSetAmContractReq(SetAmContractRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_RelayAuthMessage(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // relayer am msg\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setRelayAuthMessageReq(\n                        RelayAuthMessageRequest.newBuilder().setRawMessage(ByteString.copyFrom(\"msg\".getBytes()))\n                ).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setRelayAuthMessageResponse(RelayAuthMessageResponse.newBuilder()\n                        .setReceipt(CrossChainMessageReceipt.newBuilder()\n                                .setTxhash(mockRet().getTxhash())\n                                .setConfirmed(mockRet().isConfirmed())\n                                .setSuccessful(mockRet().isSuccessful())\n                                .setErrorMsg(mockRet().getErrorMsg())\n                        )\n                )));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_ReadCrossChainMessageReceipt(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // read crosschain msg receipt\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setReadCrossChainMessageReceiptReq(\n                        ReadCrossChainMessageReceiptRequest.newBuilder().setTxhash(mockRet().getTxhash())\n                ).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setReadCrossChainMessageReceiptResp(\n                        ReadCrossChainMessageReceiptResponse.newBuilder()\n                                .setReceipt(\n                                        CrossChainMessageReceipt.newBuilder()\n                                                .setTxhash(mockRet().getTxhash())\n                                                .setConfirmed(mockRet().isConfirmed())\n                                                .setSuccessful(mockRet().isSuccessful())\n                                                .setErrorMsg(mockRet().getErrorMsg())\n                                )\n                )\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_ReadCrossChainMessagesByHeight(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // ReadCrossChainMessagesByHeight\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setReadCrossChainMessagesByHeightReq(\n                        ReadCrossChainMessagesByHeightRequest.newBuilder().setHeight(0)\n                ).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(Mockito.any());\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_QuerySDPMessageSeq(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // QuerySDPMessageSeq\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setQuerySDPMessageSeqReq(QuerySDPMessageSeqRequest.newBuilder()\n                ).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                .setQuerySDPMsgSeqResp(QuerySDPMessageSeqResponse.newBuilder()\n                        .setSequence(0)\n                )\n        ));\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void test_BBCCall_QueryLatestHeightRequest(){\n        CallBBCRequest callBBCRequest;\n\n        // start up (create and startup)\n        AbstractBBCContext mockInitCtx = mockInitCtx();\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockInitCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // QueryLatestHeightRequest\n        callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(TEST_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setQueryLatestHeightReq(QueryLatestHeightRequest.newBuilder()).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(Mockito.any());\n        Mockito.verify(responseStreamObserver).onCompleted();\n    }\n\n    // mock data ======================================================\n    // ================================================================\n    // ================================================================\n", "    public static AbstractBBCContext mockInitCtx() {\n        DefaultBBCContext ctx = new DefaultBBCContext();\n\n        com.alipay.antchain.bridge.commons.bbc.syscontract.AuthMessageContract am = new com.alipay.antchain.bridge.commons.bbc.syscontract.AuthMessageContract();\n        am.setContractAddress(\"am\");\n        am.setStatus(ContractStatusEnum.INIT);\n\n        SDPContract sdp = new SDPContract();\n        sdp.setContractAddress(\"sdp\");\n        sdp.setStatus(ContractStatusEnum.INIT);\n\n        ctx.setAuthMessageContract(am);\n        ctx.setSdpContract(sdp);\n        ctx.setConfForBlockchainClient(\"bbcConf\".getBytes());\n        return ctx;\n    }\n\n    private AbstractBBCContext mockDeployedCtx() {\n        DefaultBBCContext ctx = new DefaultBBCContext();\n\n        com.alipay.antchain.bridge.commons.bbc.syscontract.AuthMessageContract am = new com.alipay.antchain.bridge.commons.bbc.syscontract.AuthMessageContract();\n        am.setContractAddress(\"am\");\n        am.setStatus(ContractStatusEnum.CONTRACT_DEPLOYED);\n\n        SDPContract sdp = new SDPContract();\n        sdp.setContractAddress(\"sdp\");\n        sdp.setStatus(ContractStatusEnum.CONTRACT_DEPLOYED);\n\n        ctx.setAuthMessageContract(am);\n        ctx.setSdpContract(sdp);\n        ctx.setConfForBlockchainClient(\"bbcConf\".getBytes());\n        return ctx;\n    }\n\n    private com.alipay.antchain.bridge.commons.core.base.CrossChainMessageReceipt mockRet(){\n        com.alipay.antchain.bridge.commons.core.base.CrossChainMessageReceipt ret = new com.alipay.antchain.bridge.commons.core.base.CrossChainMessageReceipt();\n        ret.setTxhash(DigestUtil.sha256Hex(\"txhash\"));\n        ret.setConfirmed(true);\n        ret.setSuccessful(true);\n        ret.setErrorMsg(\"\");\n        return ret;\n    }\n\n}\n"]}
{"filename": "ps-bootstrap/src/test/java/com/alipay/antchain/bridge/pluginserver/AntChainBridgePluginManagementApplicationTests.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver;\n", "package com.alipay.antchain.bridge.pluginserver;\n\nimport cn.hutool.core.collection.ListUtil;\nimport com.alipay.antchain.bridge.commons.bbc.AbstractBBCContext;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;\nimport com.alipay.antchain.bridge.pluginserver.server.CrossChainServiceImpl;\nimport com.alipay.antchain.bridge.pluginserver.server.PluginManagementServiceImpl;\nimport com.alipay.antchain.bridge.pluginserver.server.ResponseBuilder;\nimport com.alipay.antchain.bridge.pluginserver.server.exception.ServerErrorCodeEnum;\nimport com.alipay.antchain.bridge.pluginserver.service.CallBBCRequest;", "import com.alipay.antchain.bridge.pluginserver.server.exception.ServerErrorCodeEnum;\nimport com.alipay.antchain.bridge.pluginserver.service.CallBBCRequest;\nimport com.alipay.antchain.bridge.pluginserver.service.CallBBCResponse;\nimport com.alipay.antchain.bridge.pluginserver.service.Response;\nimport com.alipay.antchain.bridge.pluginserver.service.StartUpRequest;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;\nimport com.google.protobuf.ByteString;\nimport io.grpc.stub.StreamObserver;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;", "import org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.DirtiesContext;\n\nimport java.nio.file.Paths;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;", "import java.util.HashMap;\nimport java.util.stream.Collectors;\n\n@SpringBootTest(classes = AntChainBridgePluginServerApplication.class, webEnvironment = SpringBootTest.WebEnvironment.NONE)\nclass AntChainBridgePluginManagementApplicationTests {\n\n    private static final String DEFAULT_PRODUCT = \"testchain\";\n    private static final String TEST_PRODUCT = \"testchain1\";\n    private static final String TEST_DOMAIN = \"domain\";\n", "    private static final String TEST_DOMAIN = \"domain\";\n\n    private static final String TEST_PLUGIN_PATH = Paths.get(\"src/test/resources/testPlugins/plugin-testchain1-0.1-SNAPSHOT-plugin.jar\").toAbsolutePath().toString();\n\n    @Autowired\n    private PluginManagementServiceImpl pluginManagementService;\n\n    @Autowired\n    private CrossChainServiceImpl crossChainService;\n", "    private CrossChainServiceImpl crossChainService;\n\n    private StreamObserver<ManageResponse> mngResponseStreamObserver;\n\n    private StreamObserver<Response> responseStreamObserver;\n\n    @Test\n    @DirtiesContext\n    public void testManageLoadAndStartPluginsReq() {\n        PluginManageRequest pluginManageRequest;\n\n        // 1. load plugins\uff08\u63a5\u53e3\u53ef\u4ee5\u6b63\u5e38\u8c03\u7528\uff0c\u4f46\u662f\u4f1a\u6253\u5370\u91cd\u590d\u52a0\u8f7d\u7684\u5f02\u5e38\u4fe1\u606f\uff0c\u8fd9\u662f\u56e0\u4e3a\u670d\u52a1\u542f\u52a8\u65f6\u9ed8\u8ba4\u5df2\u7ecf\u6267\u884c\u8fc7loadplugins\uff09\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.LOAD_PLUGINS).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 2. start plugins\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGINS).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testManageLoadAndStartPluginsReq() {\n        PluginManageRequest pluginManageRequest;\n\n        // 1. load plugins\uff08\u63a5\u53e3\u53ef\u4ee5\u6b63\u5e38\u8c03\u7528\uff0c\u4f46\u662f\u4f1a\u6253\u5370\u91cd\u590d\u52a0\u8f7d\u7684\u5f02\u5e38\u4fe1\u606f\uff0c\u8fd9\u662f\u56e0\u4e3a\u670d\u52a1\u542f\u52a8\u65f6\u9ed8\u8ba4\u5df2\u7ecf\u6267\u884c\u8fc7loadplugins\uff09\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.LOAD_PLUGINS).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 2. start plugins\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGINS).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testManagePluginReq() {\n        PluginManageRequest pluginManageRequest;\n\n        // 1. load plugin\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.LOAD_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 2. start plugin\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 3. stop plugin\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.STOP_PLUGIN)\n                .setProduct(TEST_PRODUCT).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 4. start plugin from stop\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGIN_FROM_STOP)\n                .setProduct(TEST_PRODUCT).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 5. stop plugin and reload plugin\n        // 5.1 stop\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.STOP_PLUGIN)\n                .setProduct(TEST_PRODUCT).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n        // 5.2 reload plugin\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.RELOAD_PLUGIN)\n                .setProduct(TEST_PRODUCT).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 6. stop plugin and reload plugin in new path\n        // 6.1 stop plugin\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.STOP_PLUGIN)\n                .setProduct(TEST_PRODUCT).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 6.2 reload plugin in new path\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.RELOAD_PLUGIN_IN_NEW_PATH)\n                .setProduct(TEST_PRODUCT)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testPluginQueryReq() {\n        PluginManageRequest pluginManageRequest;\n\n        // 1. All plugins in the default path are automatically loaded when the service starts\n\n        // 2. has plugin\n        HasPluginsRequest hasPluginsRequest = HasPluginsRequest.newBuilder()\n                .addAllProducts(ListUtil.toList(DEFAULT_PRODUCT, TEST_PRODUCT)).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.hasPlugins(hasPluginsRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildHasPluginsResp(\n                HasPluginsResp.newBuilder().putAllResults(new HashMap<String, Boolean>() {{\n                    put(DEFAULT_PRODUCT, true);\n                    put(TEST_PRODUCT, false);\n                }})\n        ));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 3. load and start test plugin\n        // 3.1 load\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.LOAD_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n        // 3.2 start\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 4. all plugin\n        AllPluginsRequest allPluginsRequest = AllPluginsRequest.newBuilder().build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.allPlugins(allPluginsRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildAllPluginsResp(\n                AllPluginsResp.newBuilder().addAllProducts(ListUtil.toList(TEST_PRODUCT, DEFAULT_PRODUCT).stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()))\n        ));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 5. has domain\n        HasDomainsRequest hasDomainsRequest = HasDomainsRequest.newBuilder()\n                .addAllDomains(ListUtil.toList(TEST_DOMAIN)).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.hasDomains(hasDomainsRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildHasDomainsResp(\n                HasDomainsResp.newBuilder().putAllResults(new HashMap<String, Boolean>() {{\n                    put(TEST_DOMAIN, false);\n                }})\n        ));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 6. all domain\n        AllDomainsRequest allDomainsRequest = AllDomainsRequest.newBuilder().build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.allDomains(allDomainsRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildAllDomainsResp(\n                AllDomainsResp.newBuilder().addAllDomains(ListUtil.toList())\n        ));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 7. create service with test domain\n        AbstractBBCContext mockCtx = AntChainBridgePluginServerApplicationTests.mockInitCtx();\n        CallBBCRequest callBBCRequest = CallBBCRequest.newBuilder()\n                .setProduct(DEFAULT_PRODUCT)\n                .setDomain(TEST_DOMAIN)\n                .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFrom(mockCtx.encodeToBytes()))).build();\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(callBBCRequest, responseStreamObserver);\n        Mockito.verify(responseStreamObserver).onNext(ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()));\n        Mockito.verify(responseStreamObserver).onCompleted();\n\n        // 8. all domain\n        allDomainsRequest = AllDomainsRequest.newBuilder().build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.allDomains(allDomainsRequest, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildAllDomainsResp(\n                AllDomainsResp.newBuilder().addAllDomains(ListUtil.toList(TEST_DOMAIN).stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()))\n        ));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n    }\n\n    @Test\n    @DirtiesContext", "    public void testRestartBBC() {\n        // 1. failed to restart a domain or product not exist\n        RestartBBCRequest request = RestartBBCRequest.newBuilder()\n                .setDomain(\"domain\")\n                .setProduct(\"product\")\n                .build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.restartBBC(request, mngResponseStreamObserver);\n        Mockito.verify(mngResponseStreamObserver)\n                .onNext(ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"product not found\"));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n\n        // 2. green case\n        PluginManageRequest pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.LOAD_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n        pluginManageRequest = PluginManageRequest.newBuilder()\n                .setType(PluginManageRequest.Type.START_PLUGIN)\n                .setPath(TEST_PLUGIN_PATH).build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.managePlugin(pluginManageRequest, mngResponseStreamObserver);\n\n        responseStreamObserver = Mockito.mock(StreamObserver.class);\n        crossChainService.bbcCall(\n                CallBBCRequest.newBuilder()\n                        .setDomain(\"domain\")\n                        .setProduct(\"testchain\")\n                        .setStartUpReq(StartUpRequest.newBuilder().setRawContext(ByteString.copyFromUtf8(\"{\\\"raw_conf\\\": \\\"\\\"}\")))\n                        .build(),\n                responseStreamObserver\n        );\n\n        request = RestartBBCRequest.newBuilder()\n                .setDomain(\"domain\")\n                .setProduct(\"testchain\")\n                .build();\n        mngResponseStreamObserver = Mockito.mock(StreamObserver.class);\n        pluginManagementService.restartBBC(request, mngResponseStreamObserver);\n\n        Mockito.verify(mngResponseStreamObserver).onNext(ResponseBuilder.buildRestartBBCResp(RestartBBCResp.newBuilder()));\n        Mockito.verify(mngResponseStreamObserver).onCompleted();\n    }\n}\n"]}
{"filename": "ps-bootstrap/src/main/java/com/alipay/antchain/bridge/pluginserver/AntChainBridgePluginServerApplication.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver;\n", "package com.alipay.antchain.bridge.pluginserver;\n\nimport org.springframework.boot.WebApplicationType;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.builder.SpringApplicationBuilder;\n\n@SpringBootApplication(scanBasePackages = {\"com.alipay.antchain.bridge.pluginserver\"})\npublic class AntChainBridgePluginServerApplication {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(AntChainBridgePluginServerApplication.class)\n                .web(WebApplicationType.NONE)\n                .run(args);\n    }\n}\n", "    public static void main(String[] args) {\n        new SpringApplicationBuilder(AntChainBridgePluginServerApplication.class)\n                .web(WebApplicationType.NONE)\n                .run(args);\n    }\n}\n"]}
{"filename": "ps-bootstrap/src/main/java/com/alipay/antchain/bridge/pluginserver/config/PluginManagerConfiguration.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.config;\n", "package com.alipay.antchain.bridge.pluginserver.config;\n\nimport cn.hutool.core.collection.ListUtil;\nimport cn.hutool.core.util.StrUtil;\nimport com.alipay.antchain.bridge.pluginserver.pluginmanager.IPluginManagerWrapper;\nimport com.alipay.antchain.bridge.pluginserver.pluginmanager.PluginManagerWrapperImpl;\nimport com.alipay.antchain.bridge.pluginserver.server.PluginManagementServiceImpl;\nimport io.grpc.Server;\nimport io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\nimport lombok.extern.slf4j.Slf4j;", "import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.ClassLoadingStrategy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.io.IOException;\nimport java.net.InetAddress;", "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n@Configuration\n@Slf4j\npublic class PluginManagerConfiguration {\n    @Value(\"${pluginserver.plugin.repo}\")\n    private String pluginPath;\n\n    @Value(\"${pluginserver.plugin.policy.classloader.resource.ban-with-prefix.APPLICATION}\")\n    private String[] resourceBannedPrefixOnAppLevel;\n\n    @Value(\"${pluginserver.managerserver.host}\")\n    private String managementHost;\n\n    @Bean", "@Configuration\n@Slf4j\npublic class PluginManagerConfiguration {\n    @Value(\"${pluginserver.plugin.repo}\")\n    private String pluginPath;\n\n    @Value(\"${pluginserver.plugin.policy.classloader.resource.ban-with-prefix.APPLICATION}\")\n    private String[] resourceBannedPrefixOnAppLevel;\n\n    @Value(\"${pluginserver.managerserver.host}\")\n    private String managementHost;\n\n    @Bean", "    public IPluginManagerWrapper pluginManagerWrapper() {\n        return new PluginManagerWrapperImpl(\n                pluginPath,\n                convertPathPrefixBannedMap(resourceBannedPrefixOnAppLevel)\n        );\n    }\n\n    private Map<ClassLoadingStrategy.Source, Set<String>> convertPathPrefixBannedMap(\n            String[] resourceBannedPrefixOnAppLevel\n    ) {\n        Map<ClassLoadingStrategy.Source, Set<String>> result = new HashMap<>();\n\n        Set<String> appSet = new HashSet<>(ListUtil.of(resourceBannedPrefixOnAppLevel));\n        result.put(ClassLoadingStrategy.Source.APPLICATION, appSet);\n\n        return result;\n    }\n\n    @Value(\"${pluginserver.managerserver.port}\")\n    private String pluginServerMgrPort;\n\n    @Bean", "    public Server pluginMgrServer(@Autowired PluginManagementServiceImpl pluginManagementService) throws IOException {\n        log.info(\"Starting plugin managing server on port \" + pluginServerMgrPort);\n        return NettyServerBuilder.forAddress(\n                        new InetSocketAddress(\n                                StrUtil.isEmpty(managementHost) ? InetAddress.getLoopbackAddress() : InetAddress.getByName(managementHost),\n                                Integer.parseInt(pluginServerMgrPort)\n                        )\n                ).addService(pluginManagementService)\n                .build()\n                .start();\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/ArgsConstraint.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ArgsConstraint {", "@Retention(RetentionPolicy.RUNTIME)\npublic @interface ArgsConstraint {\n\n    String name() default \"\";\n\n    String[] constraints() default \"\";\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/NamespaceManagerImpl.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NamespaceManagerImpl implements NamespaceManager {\n\n    private final List<CommandNamespace> commandNamespaces = new ArrayList<>();\n\n    public NamespaceManagerImpl() {\n        addNamespace(new ManagementCommandNamespace());\n    }\n\n    @Override", "    public void addNamespace(CommandNamespace commandNamespace) {\n        this.commandNamespaces.add(commandNamespace);\n    }\n\n    @Override\n    public List<CommandNamespace> getCommandNamespaces() {\n        return commandNamespaces;\n    }\n\n    @Override\n    public String dump() {\n        StringBuilder builder = new StringBuilder();\n        commandNamespaces.forEach(\n                commandNamespace -> {\n                    builder.append(\"\\n\").append(commandNamespace.name());\n                    commandNamespace.getCommands().forEach(\n                            (cmdName, cmd) -> {\n                                builder.append(\"\\n\\t.\").append(cmdName);", "    public String dump() {\n        StringBuilder builder = new StringBuilder();\n        commandNamespaces.forEach(\n                commandNamespace -> {\n                    builder.append(\"\\n\").append(commandNamespace.name());\n                    commandNamespace.getCommands().forEach(\n                            (cmdName, cmd) -> {\n                                builder.append(\"\\n\\t.\").append(cmdName);\n                                if (!cmd.getArgs().isEmpty()) {\n                                    builder.append(\"(\");\n                                    cmd.getArgs().forEach(\n                                            arg -> {\n                                                builder.append(arg.getName()).append(\",\");\n                                            }\n                                    );\n                                    builder.deleteCharAt(builder.length() - 1);\n                                    builder.append(\")\");\n                                } else {\n                                    builder.append(\"()\");\n                                }\n                            }\n                    );\n                }\n        );\n\n        return builder.append(\"\\n\\n\").toString();\n    }\n}\n", "                                if (!cmd.getArgs().isEmpty()) {\n                                    builder.append(\"(\");\n                                    cmd.getArgs().forEach(\n                                            arg -> {\n                                                builder.append(arg.getName()).append(\",\");\n                                            }\n                                    );\n                                    builder.deleteCharAt(builder.length() - 1);\n                                    builder.append(\")\");\n                                } else {\n                                    builder.append(\"()\");\n                                }\n                            }\n                    );\n                }\n        );\n\n        return builder.append(\"\\n\\n\").toString();\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/NamespaceManager.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.util.List;\n\npublic interface NamespaceManager {\n\n    /**\n     * \u6dfb\u52a0namespace\n     *\n     * @param commandNamespace\n     */\n    void addNamespace(CommandNamespace commandNamespace);\n\n    /**\n     * \u83b7\u53d6\u6240\u6709namespace\n     *\n     * @return\n     */\n    List<CommandNamespace> getCommandNamespaces();\n\n    /**\n     * namespace\u5feb\u7167\n     *\n     * @return\n     */\n    String dump();\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/CommandHandler.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\n@FunctionalInterface\npublic interface CommandHandler {\n\n    /**\n     * \u6267\u884c\u547d\u4ee4\n     *\n     * @param namespace \u547d\u4ee4\u7a7a\u95f4\n     * @param command   \u547d\u4ee4\n     * @param params    \u6267\u884c\u53c2\u6570\n     * @return\n     */\n    Object execute(String namespace, String command, String... params);\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/ManagementCommandNamespace.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport com.alipay.antchain.bridge.pluginserver.cli.shell.GroovyScriptCommandNamespace;\n\npublic class ManagementCommandNamespace extends GroovyScriptCommandNamespace {\n    @Override\n    public String name() {\n        return \"manage\";\n    }\n\n    Object loadPlugins() {\n        return queryAPI(\"loadPlugins\");\n    }\n\n    Object startPlugins() {\n        return queryAPI(\"startPlugins\");\n    }\n\n    Object loadPlugin(\n            @ArgsConstraint(name = \"path\") String path\n    ) {\n        return queryAPI(\"loadPlugin\", path);\n    }\n\n    Object startPlugin(\n            @ArgsConstraint(name = \"path\") String path\n    ) {\n        return queryAPI(\"startPlugin\", path);\n    }\n\n    Object stopPlugin(\n            @ArgsConstraint(name = \"product\") String product\n    ) {\n        return queryAPI(\"stopPlugin\", product);\n    }\n\n    Object startPluginFromStop(\n            @ArgsConstraint(name = \"product\") String product\n    ) {\n        return queryAPI(\"startPluginFromStop\", product);\n    }\n\n    Object reloadPlugin(\n            @ArgsConstraint(name = \"product\") String product\n    ) {\n        return queryAPI(\"reloadPlugin\", product);\n    }\n\n    Object reloadPluginInNewPath(\n            @ArgsConstraint(name = \"product\") String product,\n            @ArgsConstraint(name = \"path\") String path\n    ) {\n        return queryAPI(\"reloadPluginInNewPath\", product, path);\n    }\n\n    Object hasPlugins(\n            @ArgsConstraint(name = \"products...\") String... products\n    ) {\n        return queryAPI(\"hasPlugins\", products);\n    }\n\n    Object allPlugins() {\n        return queryAPI(\"allPlugins\");\n    }\n\n    Object hasDomains(\n            @ArgsConstraint(name = \"domains...\") String... domains\n    ) {\n        return queryAPI(\"hasDomains\", domains);\n    }\n\n    Object allDomains() {\n        return queryAPI(\"allDomains\");\n    }\n\n    Object restartBBC(\n            @ArgsConstraint(name = \"product\") String product,\n            @ArgsConstraint(name = \"domain\") String domain\n    ) {\n        return queryAPI(\"restartBBC\", product, domain);\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/Command.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Command {\n\n    /**\n     * \u547d\u4ee4\u540d\u79f0\n     */\n    private String name;\n\n    /**\n     * \u547d\u4ee4\u53c2\u6570\u63cf\u8ff0\n     */\n    private List<Arg> args = new ArrayList<>();\n\n    /**\n     * \u4f7f\u7528\u547d\u4ee4\u540d\u79f0\u6784\u9020\u547d\u4ee4\n     *\n     * @param name\n     */\n    public Command(String name) {\n        this.name = name;\n    }\n\n    /**\n     * \u6dfb\u52a0\u53c2\u6570\n     *\n     * @param argName    \u53c2\u6570\u540d\u79f0\n     * @param constraints \u53c2\u6570\u53d6\u503c\u7ea6\u675f\n     */", "    public void addArgs(String argName, String type, List<String> constraints) {\n\n        Arg item = new Arg();\n        item.name = argName;\n        item.type = type;\n        item.constraints = constraints;\n\n        this.args.add(item);\n    }\n\n    /**\n     * Getter method for property <tt>name.</tt>.\n     *\n     * @return property value of name.\n     */", "    public String getName() {\n        return name;\n    }\n\n    /**\n     * Getter method for property <tt>args.</tt>.\n     *\n     * @return property value of args.\n     */\n    public List<Arg> getArgs() {\n        return args;\n    }\n\n    /**\n     * \u53c2\u6570\u63cf\u8ff0\u7c7b\n     */", "    public static class Arg {\n        private String name;\n        private String type;\n        private List<String> constraints;\n\n        /**\n         * Getter method for property <tt>name.</tt>.\n         *\n         * @return property value of name.\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * Getter method for property <tt>constraints.</tt>.\n         *\n         * @return property value of constraints.\n         */\n        public List<String> getConstraints() {\n            return constraints;\n        }\n\n        /**\n         * Getter method for property <tt>type.</tt>.\n         *\n         * @return property value of type.\n         */", "        public String getName() {\n            return name;\n        }\n\n        /**\n         * Getter method for property <tt>constraints.</tt>.\n         *\n         * @return property value of constraints.\n         */\n        public List<String> getConstraints() {\n            return constraints;\n        }\n\n        /**\n         * Getter method for property <tt>type.</tt>.\n         *\n         * @return property value of type.\n         */", "        public String getType() {\n            return type;\n        }\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/CommandNamespace.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.util.Map;\n\n/**\n * \u547d\u4ee4\u547d\u540d\u7a7a\u95f4\n */\npublic interface CommandNamespace {\n\n    /**\n     * \u547d\u540d\u7a7a\u95f4\u540d\u79f0\n     *\n     * @return\n     */", "    public String name();\n\n    /**\n     * \u83b7\u53d6\u547d\u4ee4\u547d\u540d\u7a7a\u95f4\u4e0b\u6240\u6709\u547d\u4ee4\n     *\n     * @return\n     */\n    public Map<String, Command> getCommands();\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/command/CommandNamespaceImpl.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.command;\n", "package com.alipay.antchain.bridge.pluginserver.cli.command;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommandNamespaceImpl implements CommandNamespace {\n    /**\n     * \u547d\u4ee4\u96c6\u5408\n     */\n    private final Map<String, Command> commands = new HashMap<>();\n\n    /**\n     * \u547d\u540d\u7a7a\u95f4\u540d\u79f0\n     *\n     * @return\n     */\n    @Override", "    public String name() {\n        return null;\n    }\n\n    /**\n     * \u5f80\u547d\u540d\u7a7a\u95f4\u6dfb\u52a0\u4e00\u4e2a\u547d\u4ee4\n     *\n     * @param cmd\n     */\n    public void addCommand(Command cmd) {\n        commands.put(cmd.getName(), cmd);\n    }\n\n    /**\n     * \u83b7\u53d6\u547d\u540d\u7a7a\u95f4\u4e0b\u6240\u6709\u547d\u4ee4\n     *\n     * @return\n     */\n    public Map<String, Command> getCommands() {\n        return commands;\n    }\n}\n", "    public void addCommand(Command cmd) {\n        commands.put(cmd.getName(), cmd);\n    }\n\n    /**\n     * \u83b7\u53d6\u547d\u540d\u7a7a\u95f4\u4e0b\u6240\u6709\u547d\u4ee4\n     *\n     * @return\n     */\n    public Map<String, Command> getCommands() {\n        return commands;\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/PromptCompleter.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.alipay.antchain.bridge.pluginserver.cli.command.CommandNamespace;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.NamespaceManager;\nimport org.jline.reader.Candidate;\nimport org.jline.reader.Completer;\nimport org.jline.reader.LineReader;", "import org.jline.reader.Completer;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.ParsedLine;\n\npublic class PromptCompleter implements Completer {\n\n    private List<CommandNamespace> namespaces = new ArrayList<>();\n\n    private List<String> reservedWords = new ArrayList<>();\n\n    /**\n     * \u6dfb\u52a0namespace\n     *\n     * @param namespaceManager\n     */", "    public void addNamespace(NamespaceManager namespaceManager) {\n\n        namespaces.addAll(namespaceManager.getCommandNamespaces());\n    }\n\n    /**\n     * \u6dfb\u52a0\u4fdd\u7559\u5b57\n     *\n     * @param reservedWord\n     */\n    public void addReservedWord(String reservedWord) {\n        this.reservedWords.add(reservedWord);\n    }\n\n    @Override", "    public void addReservedWord(String reservedWord) {\n        this.reservedWords.add(reservedWord);\n    }\n\n    @Override\n    public void complete(LineReader lineReader, ParsedLine commandLine, List<Candidate> candidates) {\n        assert commandLine != null;\n        assert candidates != null;\n\n        String buffer = commandLine.line().substring(0, commandLine.cursor());\n\n        //\u5982\u679c\u672a\u8f93\u5165.\u7b26\u53f7,\u5219\u8865\u5168\u4fdd\u7559\u5b57\u4e0e\u547d\u4ee4", "        if (!buffer.contains(\".\")) {\n\n            // \u8865\u5168\u4fdd\u7559\u5b57\n            reservedWords.forEach(reservedWord -> {\n                if (!buffer.isEmpty() && !reservedWord.startsWith(buffer)) {\n                    return;\n                }\n\n                candidates.add(new Candidate(reservedWord, reservedWord, null, null, null, null, true));\n            });\n\n            // \u8865\u5168\u547d\u4ee4\n            namespaces.forEach(namespace -> {\n", "                if (!buffer.isEmpty() && !namespace.name().startsWith(buffer)) {\n                    return;\n                }\n\n                StringBuilder sb = new StringBuilder(namespace.name());\n                namespace.getCommands().forEach((cmdName, cmd) -> {\n\n                    sb.append(\"\\n\\t.\").append(cmdName);\n                    if (!cmd.getArgs().isEmpty()) {\n                        sb.append(\"(\");\n                        cmd.getArgs().forEach(arg -> {\n                            sb.append(\"String \").append(arg.getName()).append(\",\");\n                        });\n                        sb.deleteCharAt(sb.length() - 1);\n                        sb.append(\")\");\n\n                    } else {\n                        sb.append(\"()\");\n                    }\n                });\n\n                candidates.add(new Candidate(namespace.name() + \".\", namespace.name(), null, null, null, null, true));\n            });", "                    if (!cmd.getArgs().isEmpty()) {\n                        sb.append(\"(\");\n                        cmd.getArgs().forEach(arg -> {\n                            sb.append(\"String \").append(arg.getName()).append(\",\");\n                        });\n                        sb.deleteCharAt(sb.length() - 1);\n                        sb.append(\")\");\n\n                    } else {\n                        sb.append(\"()\");\n                    }\n                });\n\n                candidates.add(new Candidate(namespace.name() + \".\", namespace.name(), null, null, null, null, true));\n            });", "        } else if (buffer.contains(\"(\")) {// \u5df2\u8f93\u5165\u5b8c\u6574\u7684\u547d\u4ee4(\u5224\u65ad\u662f\u5426\u5df2\u8f93\u5165\"(\"\u7b26\u53f7),\u5219\u8865\u5168\u8be6\u7ec6\u7684\u53c2\u6570\u5b57\u6bb5\n\n            String[] buf = buffer.split(\"\\\\.\");\n\n            namespaces.forEach(namespace -> {\n\n                if (!namespace.name().equals(buf[0])) {\n                    return;\n                }\n                namespace.getCommands().forEach((cmdName, cmd) -> {\n\n                    String command = buf[1].split(\"\\\\(\")[0];\n", "                    if (cmdName.equals(command)) {\n\n                        StringBuilder sb = new StringBuilder(cmdName);\n                        if (!cmd.getArgs().isEmpty()) {\n                            sb.append(\"(\");\n                            cmd.getArgs().forEach(arg -> {\n                                sb.append(\"\\n    \").append(arg.getType()).append(\" \").append(arg.getName()).append(\" \");\n\n                                if (!arg.getConstraints().isEmpty()) {\n                                    sb.append(\" //\");\n                                    arg.getConstraints().forEach(contraint -> {\n                                        sb.append(contraint).append(\",\");\n                                    });\n                                    sb.deleteCharAt(sb.length() - 1);\n                                }\n                            });\n                            sb.append(\"\\n)\");\n\n                            candidates.add(\n                                new Candidate(buffer, sb.toString(), null, null, null,\n                                    null, true));\n                        } else {\n                            sb.append(\"()\");\n                            candidates.add(\n                                new Candidate(namespace.name() + \".\" + cmdName + \"()\", sb.toString(), null, null, null,\n                                    null, true));\n                        }\n                    }\n                });\n            });\n        } else { //\u5df2\u8f93\u5165.\u7b26\u53f7,\u5219\u8865\u5168\u5339\u914d\u547d\u4ee4\n            String[] buf = buffer.split(\"\\\\.\");\n\n            namespaces.forEach(namespace -> {\n", "                                if (!arg.getConstraints().isEmpty()) {\n                                    sb.append(\" //\");\n                                    arg.getConstraints().forEach(contraint -> {\n                                        sb.append(contraint).append(\",\");\n                                    });\n                                    sb.deleteCharAt(sb.length() - 1);\n                                }\n                            });\n                            sb.append(\"\\n)\");\n\n                            candidates.add(\n                                new Candidate(buffer, sb.toString(), null, null, null,\n                                    null, true));\n                        } else {\n                            sb.append(\"()\");\n                            candidates.add(\n                                new Candidate(namespace.name() + \".\" + cmdName + \"()\", sb.toString(), null, null, null,\n                                    null, true));\n                        }\n                    }\n                });\n            });\n        } else { //\u5df2\u8f93\u5165.\u7b26\u53f7,\u5219\u8865\u5168\u5339\u914d\u547d\u4ee4\n            String[] buf = buffer.split(\"\\\\.\");\n\n            namespaces.forEach(namespace -> {\n", "                if (!namespace.name().equals(buf[0])) {\n                    return;\n                }\n\n                long matchCount = namespace.getCommands().keySet().stream().filter(\n                    cmdName -> cmdName.startsWith(buf.length <= 1 ? \"\" : buf[1])).count();\n\n                namespace.getCommands().forEach((cmdName, cmd) -> {\n\n                    if (cmdName.startsWith(buf.length <= 1 ? \"\" : buf[1])) {\n\n                        StringBuilder sb = new StringBuilder(cmdName);", "                    if (cmdName.startsWith(buf.length <= 1 ? \"\" : buf[1])) {\n\n                        StringBuilder sb = new StringBuilder(cmdName);\n                        if (cmd.getArgs().isEmpty()) {\n                            sb.append(\"()\");\n                            candidates.add(\n                                new Candidate(namespace.name() + \".\" + cmdName + \"()\", sb.toString(), null, null, null,\n                                    null, true));\n\n                        } else if (matchCount == 1) {\n                            sb.append(\"(\");\n                            cmd.getArgs().forEach(arg -> {\n                                sb.append(\"\\n    \").append(arg.getType()).append(\" \").append(arg.getName()).append(\" \");\n", "                        } else if (matchCount == 1) {\n                            sb.append(\"(\");\n                            cmd.getArgs().forEach(arg -> {\n                                sb.append(\"\\n    \").append(arg.getType()).append(\" \").append(arg.getName()).append(\" \");\n\n                                if (!arg.getConstraints().isEmpty()) {\n                                    sb.append(\" //\");\n                                    arg.getConstraints().forEach(contraint -> {\n                                        sb.append(contraint).append(\",\");\n                                    });\n                                    sb.deleteCharAt(sb.length() - 1);\n                                }\n                            });\n                            sb.append(\"\\n)\");\n\n                            candidates.add(\n                                new Candidate(namespace.name() + \".\" + cmdName + \"(\", sb.toString(), null, null, null,\n                                    null, true));\n                        } else {\n                            sb.append(\"(\");\n                            cmd.getArgs().forEach(arg -> {\n                                sb.append(arg.getType() + \" \" + arg.getName()).append(\",\");\n                            });\n                            sb.deleteCharAt(sb.length() - 1);\n                            sb.append(\")\");\n\n                            candidates.add(\n                                new Candidate(namespace.name() + \".\" + cmdName + \"(\", sb.toString(), null, null, null,\n                                    null, true));\n                        }\n                    }\n                });\n            });\n        }\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/ReservedWord.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\n@FunctionalInterface\npublic interface ReservedWord {\n\n    void execute();\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/GlLineReader.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n", "import java.util.stream.Collectors;\n\nimport org.jline.reader.Binding;\nimport org.jline.reader.Candidate;\nimport org.jline.reader.ParsedLine;\nimport org.jline.reader.Parser.ParseContext;\nimport org.jline.reader.Reference;\nimport org.jline.reader.impl.LineReaderImpl;\nimport org.jline.reader.impl.ReaderUtils;\nimport org.jline.terminal.Terminal;", "import org.jline.reader.impl.ReaderUtils;\nimport org.jline.terminal.Terminal;\nimport org.jline.utils.AttributedString;\nimport org.jline.utils.Levenshtein;\nimport org.jline.utils.Log;\n\npublic class GlLineReader extends LineReaderImpl {\n\n    public GlLineReader(Terminal terminal) throws IOException {\n        super(terminal);\n    }\n\n    public GlLineReader(Terminal terminal, String appName) throws IOException {\n        super(terminal, appName);\n    }\n\n    public GlLineReader(Terminal terminal, String appName, Map<String, Object> variables) {\n        super(terminal, appName, variables);\n    }\n\n    @Override\n    protected boolean insertTab() {\n        return isSet(Option.INSERT_TAB) && false;\n    }\n\n    @Override\n    protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {\n        // Try to expand history first\n        // If there is actually an expansion, bail out now", "        try {\n            if (expandHistory()) {\n                return true;\n            }\n        } catch (Exception e) {\n            Log.info(\"Error while expanding history\", e);\n            return false;\n        }\n\n        // Parse the command line\n        ParsedLine line;", "        try {\n            line = parser.parse(buf.toString(), buf.cursor(), ParseContext.COMPLETE);\n        } catch (Exception e) {\n            Log.info(\"Error while parsing line\", e);\n            return false;\n        }\n\n        // Find completion candidates\n        List<Candidate> candidates = new ArrayList<>();\n        try {\n            if (completer != null) {\n                completer.complete(this, line, candidates);\n            }\n        } catch (Exception e) {\n            Log.info(\"Error while finding completion candidates\", e);\n            return false;\n        }\n", "        try {\n            if (completer != null) {\n                completer.complete(this, line, candidates);\n            }\n        } catch (Exception e) {\n            Log.info(\"Error while finding completion candidates\", e);\n            return false;\n        }\n\n        if (lst == CompletionType.ExpandComplete || lst == CompletionType.Expand) {\n            String w = expander.expandVar(line.word());", "        if (lst == CompletionType.ExpandComplete || lst == CompletionType.Expand) {\n            String w = expander.expandVar(line.word());\n            if (!line.word().equals(w)) {\n                if (prefix) {\n                    buf.backspace(line.wordCursor());\n                } else {\n                    buf.move(line.word().length() - line.wordCursor());\n                    buf.backspace(line.word().length());\n                }\n                buf.write(w);\n                return true;\n            }", "            if (lst == CompletionType.Expand) {\n                return false;\n            } else {\n                lst = CompletionType.Complete;\n            }\n        }\n\n        boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);\n        int errors = getInt(ERRORS, DEFAULT_ERRORS);\n\n        // Build a list of sorted candidates\n        NavigableMap<String, List<Candidate>> sortedCandidates =\n            new TreeMap<>(caseInsensitive ? String.CASE_INSENSITIVE_ORDER : null);", "        for (Candidate cand : candidates) {\n            sortedCandidates\n                .computeIfAbsent(AttributedString.fromAnsi(cand.value()).toString(), s -> new ArrayList<>())\n                .add(cand);\n        }\n\n        // Find matchers\n        // TODO: glob completion\n        List<Function<Map<String, List<Candidate>>,\n            Map<String, List<Candidate>>>> matchers;\n        Predicate<String> exact;", "        if (prefix) {\n            String wp = line.word().substring(0, line.wordCursor());\n            matchers = Arrays.asList(\n                simpleMatcher(s -> s.startsWith(wp)),\n                simpleMatcher(s -> s.contains(wp)),\n                typoMatcher(wp, errors)\n            );\n            exact = s -> s.equals(wp);\n        } else if (isSet(Option.COMPLETE_IN_WORD)) {\n            String wd = line.word();\n            String wp = wd.substring(0, line.wordCursor());\n            String ws = wd.substring(line.wordCursor());\n            Pattern p1 = Pattern.compile(Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n            Pattern p2 = Pattern.compile(\".*\" + Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n            matchers = Arrays.asList(\n                simpleMatcher(s -> p1.matcher(s).matches()),\n                simpleMatcher(s -> p2.matcher(s).matches()),\n                typoMatcher(wd, errors)\n            );\n            exact = s -> s.equals(wd);\n        } else {\n            String wd = line.word();\n            matchers = Arrays.asList(\n                simpleMatcher(s -> s.startsWith(wd)),\n                simpleMatcher(s -> s.contains(wd)),\n                typoMatcher(wd, errors)\n            );\n            exact = s -> s.equals(wd);\n        }\n        // Find matching candidates\n        Map<String, List<Candidate>> matching = Collections.emptyMap();", "        } else if (isSet(Option.COMPLETE_IN_WORD)) {\n            String wd = line.word();\n            String wp = wd.substring(0, line.wordCursor());\n            String ws = wd.substring(line.wordCursor());\n            Pattern p1 = Pattern.compile(Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n            Pattern p2 = Pattern.compile(\".*\" + Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n            matchers = Arrays.asList(\n                simpleMatcher(s -> p1.matcher(s).matches()),\n                simpleMatcher(s -> p2.matcher(s).matches()),\n                typoMatcher(wd, errors)\n            );\n            exact = s -> s.equals(wd);\n        } else {\n            String wd = line.word();\n            matchers = Arrays.asList(\n                simpleMatcher(s -> s.startsWith(wd)),\n                simpleMatcher(s -> s.contains(wd)),\n                typoMatcher(wd, errors)\n            );\n            exact = s -> s.equals(wd);\n        }\n        // Find matching candidates\n        Map<String, List<Candidate>> matching = Collections.emptyMap();", "        for (Function<Map<String, List<Candidate>>,\n            Map<String, List<Candidate>>> matcher : matchers) {\n            matching = matcher.apply(sortedCandidates);\n            if (!matching.isEmpty()) {\n                break;\n            }\n        }\n\n        // If we have no matches, bail out\n        if (matching.isEmpty()) {\n            return false;\n        }\n\n        // If we only need to display the list, do it now", "        if (matching.isEmpty()) {\n            return false;\n        }\n\n        // If we only need to display the list, do it now\n        if (lst == CompletionType.List) {\n            List<Candidate> possible = matching.entrySet().stream()\n                .flatMap(e -> e.getValue().stream())\n                .collect(Collectors.toList());\n            doList(possible, line.word(), false);\n            return !possible.isEmpty();\n        }\n\n        // Check if there's a single possible match\n        Candidate completion = null;\n        // If there's a single possible completion", "        if (matching.size() == 1) {\n            completion = matching.values().stream().flatMap(Collection::stream)\n                .findFirst().orElse(null);\n        }\n        // Or if RECOGNIZE_EXACT is set, try to find an exact match\n        else if (isSet(Option.RECOGNIZE_EXACT)) {\n            completion = matching.values().stream().flatMap(Collection::stream)\n                .filter(Candidate::complete)\n                .filter(c -> exact.test(c.value()))\n                .findFirst().orElse(null);\n        }\n        // Complete and exit", "        if (completion != null && !completion.value().isEmpty()) {\n            if (prefix) {\n                buf.backspace(line.wordCursor());\n            } else {\n                buf.move(line.line().length() - line.cursor());\n                buf.backspace(line.line().length());\n            }\n            buf.write(completion.value());\n            if (completion.suffix() != null) {\n                redisplay();\n\n                Binding op = readBinding(getKeys());", "            if (completion.suffix() != null) {\n                redisplay();\n\n                Binding op = readBinding(getKeys());\n                if (op != null) {\n                    String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);\n                    String ref = op instanceof Reference ? ((Reference)op).name() : null;\n                    if (SELF_INSERT.equals(ref) && chars.indexOf(getLastBinding().charAt(0)) >= 0\n                        || ACCEPT_LINE.equals(ref)) {\n                        buf.backspace(completion.suffix().length());\n                        if (getLastBinding().charAt(0) != ' ') {\n                            buf.write(' ');\n                        }\n                    }\n                    pushBackBinding(true);\n                }\n            }\n\n            List<Candidate> possible = matching.entrySet().stream()\n                .flatMap(e -> e.getValue().stream())\n                .collect(Collectors.toList());\n", "                        if (getLastBinding().charAt(0) != ' ') {\n                            buf.write(' ');\n                        }\n                    }\n                    pushBackBinding(true);\n                }\n            }\n\n            List<Candidate> possible = matching.entrySet().stream()\n                .flatMap(e -> e.getValue().stream())\n                .collect(Collectors.toList());\n", "            if (isSet(Option.AUTO_LIST)) {\n                if (!doList(possible, line.word(), true)) {\n                    return true;\n                }\n            }\n\n            return true;\n        }\n\n        List<Candidate> possible = matching.entrySet().stream()\n            .flatMap(e -> e.getValue().stream())\n            .collect(Collectors.toList());\n", "        if (useMenu) {\n            buf.move(line.word().length() - line.wordCursor());\n            buf.backspace(line.word().length());\n            doMenu(possible, line.word());\n            return true;\n        }\n\n        // Find current word and move to end\n        String current;\n        if (prefix) {\n            current = line.word().substring(0, line.wordCursor());\n        } else {\n            current = line.word();\n            buf.move(current.length() - line.wordCursor());\n        }\n        // Now, we need to find the unambiguous completion\n        // TODO: need to find common suffix\n        String commonPrefix = null;", "        if (prefix) {\n            current = line.word().substring(0, line.wordCursor());\n        } else {\n            current = line.word();\n            buf.move(current.length() - line.wordCursor());\n        }\n        // Now, we need to find the unambiguous completion\n        // TODO: need to find common suffix\n        String commonPrefix = null;\n        for (String key : matching.keySet()) {\n            commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);\n        }\n        boolean hasUnambiguous = commonPrefix.startsWith(current) && !commonPrefix.equals(current);\n", "        for (String key : matching.keySet()) {\n            commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);\n        }\n        boolean hasUnambiguous = commonPrefix.startsWith(current) && !commonPrefix.equals(current);\n\n        if (hasUnambiguous) {\n            buf.backspace(current.length());\n            buf.write(commonPrefix);\n            current = commonPrefix;\n            if ((!isSet(Option.AUTO_LIST) && isSet(Option.AUTO_MENU))\n                || (isSet(Option.AUTO_LIST) && isSet(Option.LIST_AMBIGUOUS))) {", "            if ((!isSet(Option.AUTO_LIST) && isSet(Option.AUTO_MENU))\n                || (isSet(Option.AUTO_LIST) && isSet(Option.LIST_AMBIGUOUS))) {\n                if (!nextBindingIsComplete()) {\n                    return true;\n                }\n            }\n        }\n        if (isSet(Option.AUTO_LIST)) {\n            if (!doList(possible, current, true)) {\n                return true;\n            }\n        }", "            if (!doList(possible, current, true)) {\n                return true;\n            }\n        }\n        if (isSet(Option.AUTO_MENU)) {\n            buf.backspace(current.length());\n            doMenu(possible, line.word());\n        }\n        return true;\n    }\n\n    int getInt(String name, int def) {\n        return ReaderUtils.getInt(this, name, def);\n    }\n\n    private String getCommonStart(String str1, String str2, boolean caseInsensitive) {\n        int[] s1 = str1.codePoints().toArray();\n        int[] s2 = str2.codePoints().toArray();\n        int len = 0;", "        while (len < Math.min(s1.length, s2.length)) {\n            int ch1 = s1[len];\n            int ch2 = s2[len];\n            if (ch1 != ch2 && caseInsensitive) {\n                ch1 = Character.toUpperCase(ch1);\n                ch2 = Character.toUpperCase(ch2);\n                if (ch1 != ch2) {\n                    ch1 = Character.toLowerCase(ch1);\n                    ch2 = Character.toLowerCase(ch2);\n                }\n            }", "            if (ch1 != ch2) {\n                break;\n            }\n            len++;\n        }\n        return new String(s1, 0, len);\n    }\n\n    private void pushBackBinding(boolean skip) {\n        String s = getLastBinding();\n        if (s != null) {\n            bindingReader.runMacro(s);\n            skipRedisplay = skip;\n        }\n    }\n\n    String getString(String name, String def) {\n        return ReaderUtils.getString(this, name, def);\n    }\n\n    private Function<Map<String, List<Candidate>>,\n        Map<String, List<Candidate>>> simpleMatcher(Predicate<String> pred) {\n        return m -> m.entrySet().stream()\n            .filter(e -> pred.test(e.getKey()))\n            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n    }\n\n    private Function<Map<String, List<Candidate>>,\n        Map<String, List<Candidate>>> typoMatcher(String word, int errors) {\n        return m -> {\n            Map<String, List<Candidate>> map = m.entrySet().stream()\n                .filter(e -> distance(word, e.getKey()) < errors)\n                .collect(Collectors.toMap(Entry::getKey, Entry::getValue));", "        if (s != null) {\n            bindingReader.runMacro(s);\n            skipRedisplay = skip;\n        }\n    }\n\n    String getString(String name, String def) {\n        return ReaderUtils.getString(this, name, def);\n    }\n\n    private Function<Map<String, List<Candidate>>,\n        Map<String, List<Candidate>>> simpleMatcher(Predicate<String> pred) {\n        return m -> m.entrySet().stream()\n            .filter(e -> pred.test(e.getKey()))\n            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n    }\n\n    private Function<Map<String, List<Candidate>>,\n        Map<String, List<Candidate>>> typoMatcher(String word, int errors) {\n        return m -> {\n            Map<String, List<Candidate>> map = m.entrySet().stream()\n                .filter(e -> distance(word, e.getKey()) < errors)\n                .collect(Collectors.toMap(Entry::getKey, Entry::getValue));", "            if (map.size() > 1) {\n                map.computeIfAbsent(word, w -> new ArrayList<>())\n                    .add(new Candidate(word, word, \"original\", null, null, null, false));\n            }\n            return map;\n        };\n    }\n\n    private int distance(String word, String cand) {\n        if (word.length() < cand.length()) {\n            int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));\n            int d2 = Levenshtein.distance(word, cand);\n            return Math.min(d1, d2);\n        } else {\n            return Levenshtein.distance(word, cand);\n        }\n    }\n\n}\n", "        if (word.length() < cand.length()) {\n            int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));\n            int d2 = Levenshtein.distance(word, cand);\n            return Math.min(d1, d2);\n        } else {\n            return Levenshtein.distance(word, cand);\n        }\n    }\n\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/GroovyScriptCommandNamespace.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport cn.hutool.core.collection.ListUtil;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.ArgsConstraint;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.Command;", "import com.alipay.antchain.bridge.pluginserver.cli.command.ArgsConstraint;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.Command;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.CommandNamespaceImpl;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.PluginManageRequest;\nimport com.google.common.collect.Lists;\n\npublic abstract class GroovyScriptCommandNamespace extends CommandNamespaceImpl {\n\n    private static final String COMMAND_NAMESPACE_NAME = \"name\";\n\n    /**\n     * \u547d\u540d\u7a7a\u95f4\u540d\u79f0\u7531\u5b50\u7c7b\u5b9e\u73b0\n     *\n     * @return\n     */\n    @Override", "    public abstract String name();\n\n    public GroovyScriptCommandNamespace() {\n        super();\n        loadCommand();\n    }\n\n    /**\n     * \u521d\u59cb\u5316:\u52a0\u8f7dcommand,\u9ed8\u8ba4\u5c06\u5b50\u7c7b\u6240\u6709\u65b9\u6cd5\u89e3\u6790\u4e3a\u547d\u4ee4\n     */\n    public void loadCommand() {\n\n        Method[] methods = this.getClass().getDeclaredMethods();\n\n        Stream.of(methods).forEach(method -> {\n", "    public void loadCommand() {\n\n        Method[] methods = this.getClass().getDeclaredMethods();\n\n        Stream.of(methods).forEach(method -> {\n\n            if (COMMAND_NAMESPACE_NAME.equals(method.getName())) {\n                return;\n            }\n\n            Command cmd = new Command(method.getName());\n\n            Parameter[] params = method.getParameters();\n", "            for (Parameter param : params) {\n\n                String argName = param.getName();\n                List<String> constraints = Lists.newArrayList();\n\n                ArgsConstraint argsConstraint = param.getAnnotation(ArgsConstraint.class);\n\n                if (null != argsConstraint) {\n                    if (null != argsConstraint.name() && !\"\".equals(argsConstraint.name().trim())) {\n                        argName = argsConstraint.name().trim();\n                    }", "                    if (null != argsConstraint.name() && !\"\".equals(argsConstraint.name().trim())) {\n                        argName = argsConstraint.name().trim();\n                    }\n                    if (null != argsConstraint.constraints()) {\n                        Stream.of(argsConstraint.constraints()).filter(\n                                constraint -> null != constraint && !\"\".equals(constraint.trim())).forEach(\n                                constraint -> constraints.add(constraint));\n                    }\n                }\n\n                cmd.addArgs(argName, param.getType().getSimpleName(), constraints);\n            }\n            addCommand(cmd);\n        });\n    }\n\n    protected String queryAPI(String command, Object... args) {\n", "        if (args != null) {\n            String[] strArgs = new String[args.length];\n            for (int i = 0; i < args.length; ++i) {\n                strArgs[i] = args[i].toString();\n            }\n\n            return queryAPI(command, strArgs);\n        } else {\n\n            return queryAPI(command);\n        }\n    }\n\n    /**\n     * \u67e5\u8be2api,\u4f9b\u5b50\u7c7b\u547d\u4ee4\u6267\u884c\u4f7f\u7528\n     *\n     * @param command\n     * @param args\n     * @return\n     */\n    protected String queryAPI(String command, String... args) {\n\n        switch (command) {\n            case \"loadPlugins\":\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.LOAD_PLUGINS,\n                        \"\", \"\"\n                );\n            case \"startPlugins\":\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.START_PLUGINS,\n                        \"\", \"\"\n                );\n            case \"reloadPlugin\":", "                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.RELOAD_PLUGIN,\n                        args[0], \"\"\n                );\n            case \"reloadPluginInNewPath\":\n                if (args.length != 2) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.RELOAD_PLUGIN_IN_NEW_PATH,\n                        args[0], args[1]\n                );\n            case \"startPlugin\":", "                if (args.length != 2) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.RELOAD_PLUGIN_IN_NEW_PATH,\n                        args[0], args[1]\n                );\n            case \"startPlugin\":\n                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.START_PLUGIN,\n                        \"\", args[0]\n                );\n            case \"stopPlugin\":", "                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.START_PLUGIN,\n                        \"\", args[0]\n                );\n            case \"stopPlugin\":\n                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.STOP_PLUGIN,\n                        args[0], \"\"\n                );\n            case \"loadPlugin\":", "                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.STOP_PLUGIN,\n                        args[0], \"\"\n                );\n            case \"loadPlugin\":\n                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.LOAD_PLUGIN,\n                        \"\", args[0]\n                );\n            case \"startPluginFromStop\":", "                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.LOAD_PLUGIN,\n                        \"\", args[0]\n                );\n            case \"startPluginFromStop\":\n                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.START_PLUGIN_FROM_STOP,\n                        args[0], \"\"\n                );\n            case \"hasPlugins\":", "                if (args.length != 1) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().managePlugin(\n                        PluginManageRequest.Type.START_PLUGIN_FROM_STOP,\n                        args[0], \"\"\n                );\n            case \"hasPlugins\":\n                if (args.length == 0) {\n                    return \"zero arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().hasPlugins(ListUtil.toList(args));\n            case \"allPlugins\":", "                if (args.length == 0) {\n                    return \"zero arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().hasPlugins(ListUtil.toList(args));\n            case \"allPlugins\":\n                if (args.length != 0) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().getAllPlugins();\n            case \"hasDomains\":\n                if (args.length == 0) {\n                    return \"zero arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().hasDomains(ListUtil.toList(args));\n            case \"allDomains\":", "                if (args.length == 0) {\n                    return \"zero arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().hasDomains(ListUtil.toList(args));\n            case \"allDomains\":\n                if (args.length != 0) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().getAllDomains();\n            case \"restartBBC\":\n                if (args.length != 2) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().restartBBC(args[0], args[1]);\n            default:\n                return \"wrong command \" + command;\n        }\n    }\n\n    protected void print(String result) {\n        Shell.RUNTIME.getPrinter().println(result);\n    }\n}\n", "                if (args.length != 2) {\n                    return \"wrong length of arguments\";\n                }\n                return Shell.RUNTIME.getGrpcClient().restartBBC(args[0], args[1]);\n            default:\n                return \"wrong command \" + command;\n        }\n    }\n\n    protected void print(String result) {\n        Shell.RUNTIME.getPrinter().println(result);\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/Launcher.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\n\nimport cn.hutool.core.io.resource.ResourceUtil;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.NamespaceManager;\nimport com.alipay.antchain.bridge.pluginserver.cli.command.NamespaceManagerImpl;\nimport com.alipay.antchain.bridge.pluginserver.cli.core.ManagementGrpcClient;\nimport org.apache.commons.cli.*;", "import com.alipay.antchain.bridge.pluginserver.cli.core.ManagementGrpcClient;\nimport org.apache.commons.cli.*;\n\npublic class Launcher {\n    private static final String OP_HELP = \"h\";\n    private static final String OP_VERSION = \"v\";\n    private static final String OP_PORT = \"p\";\n    private static final String OP_CMD = \"c\";\n    private static final String OP_FILE = \"f\";\n\n    private static final String OP_HOST = \"H\";\n\n    private static final Options options;\n\n    static {\n        options = new Options();\n        options.addOption(OP_HELP, \"help\", false, \"print help info\");\n        options.addOption(OP_VERSION, \"version\", false, \"print version info\");\n        options.addOption(OP_PORT, \"port\", true, \"management server port\");\n        options.addOption(OP_CMD, \"command\", true, \"execute the command\");\n        options.addOption(OP_FILE, \"file\", true, \"execute multiple commands in the file\");\n        options.addOption(OP_HOST, \"host\", true, \"set the host\");\n    }\n", "    public static void main(String[] args) throws ParseException {\n\n        CommandLineParser parser = new DefaultParser();\n        CommandLine cmd = parser.parse(options, args);\n\n        if (cmd.hasOption(OP_HELP)) {\n            HelpFormatter helpFormatter = new HelpFormatter();\n            helpFormatter.printHelp(\"plugin server CLI\", options);\n            return;\n        }\n", "        if (cmd.hasOption(OP_VERSION)) {\n            System.out.printf(\"cli version : %s\\n\", getVersion());\n            return;\n        }\n\n        int port = 9091;\n        if (cmd.hasOption(OP_PORT)) {\n            port = Integer.parseInt(cmd.getOptionValue(OP_PORT));\n        }\n\n        // new namespace\n        NamespaceManager namespaceManager = new NamespaceManagerImpl();\n\n        // new shellProvider\n        ShellProvider shellProvider = new GroovyShellProvider(namespaceManager);\n\n        // new promptCompleter\n        PromptCompleter promptCompleter = new PromptCompleter();\n        promptCompleter.addNamespace(namespaceManager);\n\n        // new grpcClient\n        String host = \"localhost\";", "        if (cmd.hasOption(OP_HOST)) {\n            host = cmd.getOptionValue(OP_HOST);\n        }\n        ManagementGrpcClient grpcClient = new ManagementGrpcClient(host, port);\n\n        if (!grpcClient.checkServerStatus()) {\n            System.out.printf(\"start failed, can't connect to local server port: %d\\n\", port);\n            return;\n        }\n\n        // new shell\n        Shell shell = new Shell(shellProvider, promptCompleter, grpcClient, namespaceManager);\n", "        if (cmd.hasOption(OP_CMD)) {\n            String command = cmd.getOptionValue(OP_CMD);\n\n            try {\n                String result = shell.execute(command);\n                System.out.println(result);\n            } catch (Exception e) {\n                System.out.printf(\"illegal command [ %s ], execute failed\\n\", command);\n            }\n            return;\n        }\n", "        if (cmd.hasOption(OP_FILE)) {\n            String filePath = cmd.getOptionValue(OP_FILE);\n\n            String command = \"\";\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filePath))));\n\n                command = reader.readLine();\n                StringBuilder resultBuilder = new StringBuilder();\n                while (null != command) {\n                    try {\n                        String result = shell.execute(command);\n                        resultBuilder.append(result).append(\"\\n\");\n                    } catch (Exception e) {\n                        resultBuilder.append(\"error\\n\");\n                    }\n                    command = reader.readLine();\n                }\n\n                System.out.println(resultBuilder);\n\n            } catch (FileNotFoundException e) {\n                System.out.printf(\"error: file %s not found\\n\", filePath);\n            } catch (IOException e) {\n                System.out.println(\"error: io exception\");\n                e.printStackTrace();\n            } catch (Exception e) {\n                System.out.printf(\"illegal command [ %s ], execute failed\\n\", command);\n                e.printStackTrace();\n            }\n\n            return;\n        }\n\n        shell.start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(shell::stop));\n    }\n", "                while (null != command) {\n                    try {\n                        String result = shell.execute(command);\n                        resultBuilder.append(result).append(\"\\n\");\n                    } catch (Exception e) {\n                        resultBuilder.append(\"error\\n\");\n                    }\n                    command = reader.readLine();\n                }\n\n                System.out.println(resultBuilder);\n\n            } catch (FileNotFoundException e) {\n                System.out.printf(\"error: file %s not found\\n\", filePath);\n            } catch (IOException e) {\n                System.out.println(\"error: io exception\");\n                e.printStackTrace();\n            } catch (Exception e) {\n                System.out.printf(\"illegal command [ %s ], execute failed\\n\", command);\n                e.printStackTrace();\n            }\n\n            return;\n        }\n\n        shell.start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(shell::stop));\n    }\n", "    public static String getVersion() {\n        return ResourceUtil.readStr(\"VERSION\", Charset.defaultCharset());\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/JsonUtil.java", "chunked_list": ["\n/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;", "\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n\npublic class JsonUtil {\n    /**\n     * \u5f97\u5230\u683c\u5f0f\u5316json\u6570\u636e  \u9000\u683c\u7528\\t \u6362\u884c\u7528\\r\n     */\n    public static String format(String jsonStr) {\n        int level = 0;\n        StringBuffer jsonForMatStr = new StringBuffer();\n        for (int i = 0; i < jsonStr.length(); i++) {\n            char c = jsonStr.charAt(i);", "        for (int i = 0; i < jsonStr.length(); i++) {\n            char c = jsonStr.charAt(i);\n            if (level > 0 && '\\n' == jsonForMatStr.charAt(jsonForMatStr.length() - 1)) {\n                jsonForMatStr.append(getLevelStr(level));\n            }\n            switch (c) {\n                case '{':\n                case '[':\n                    jsonForMatStr.append(c + \"\\n\");\n                    level++;\n                    break;\n                case ',':\n                    jsonForMatStr.append(c + \"\\n\");\n                    break;\n                case '}':\n                case ']':\n                    jsonForMatStr.append(\"\\n\");\n                    level--;\n                    jsonForMatStr.append(getLevelStr(level));\n                    jsonForMatStr.append(c);\n                    break;\n                default:\n                    jsonForMatStr.append(c);\n                    break;\n            }\n        }\n\n        return jsonForMatStr.toString();\n\n    }\n\n    private static String getLevelStr(int level) {\n        StringBuffer levelStr = new StringBuffer();", "        for (int levelI = 0; levelI < level; levelI++) {\n            levelStr.append(\"\\t\");\n        }\n        return levelStr.toString();\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/ShellProvider.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n\npublic interface ShellProvider {\n\n    /**\n     * \u6267\u884c\u547d\u4ee4\n     *\n     * @param cmd\n     */\n    String execute(String cmd);\n\n    /**\n     * shutdown\n     */\n    void shutdown();\n}\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\npublic interface ShellProvider {\n\n    /**\n     * \u6267\u884c\u547d\u4ee4\n     *\n     * @param cmd\n     */\n    String execute(String cmd);\n\n    /**\n     * shutdown\n     */\n    void shutdown();\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/GroovyShellProvider.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.beans.Introspector;\n\nimport com.alipay.antchain.bridge.pluginserver.cli.command.NamespaceManager;\nimport groovy.lang.GroovyShell;\nimport groovy.lang.Script;\nimport org.codehaus.groovy.reflection.ClassInfo;\nimport org.codehaus.groovy.runtime.InvokerHelper;\n\npublic class GroovyShellProvider extends GroovyShell implements ShellProvider {\n\n    private NamespaceManager namespaceManager;\n\n    public GroovyShellProvider(NamespaceManager namespaceManager) {\n        this.namespaceManager = namespaceManager;\n\n        // init GroovyShell\n        this.namespaceManager.getCommandNamespaces().forEach(namespace -> {\n\n            // only load GroovyScriptCommandNamespace", "import org.codehaus.groovy.runtime.InvokerHelper;\n\npublic class GroovyShellProvider extends GroovyShell implements ShellProvider {\n\n    private NamespaceManager namespaceManager;\n\n    public GroovyShellProvider(NamespaceManager namespaceManager) {\n        this.namespaceManager = namespaceManager;\n\n        // init GroovyShell\n        this.namespaceManager.getCommandNamespaces().forEach(namespace -> {\n\n            // only load GroovyScriptCommandNamespace", "            if (namespace instanceof GroovyScriptCommandNamespace) {\n                this.setVariable(namespace.name(), namespace);\n            }\n        });\n    }\n\n    private int cleanCount = 0;\n\n    private static int CLEAN_PERIOD = 20;\n\n    @Override", "    public String execute(String cmd) {\n        Script shell = this.parse(cmd);\n        Object scriptObject = InvokerHelper.createScript(shell.getClass(), this.getContext()).run();\n\n        // \u5468\u671f\u6e05\u9664\u7f13\u5b58\uff0c\u9632\u6b62OOM\n        if((++cleanCount) % CLEAN_PERIOD == 0) {\n            getClassLoader().clearCache();\n            ClassInfo.clearModifiedExpandos();\n            Introspector.flushCaches();\n        }\n\n        // execute by groovy script\n        return scriptObject.toString();\n    }\n\n    @Override", "    public void shutdown() {\n        // nothing\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/shell/Shell.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.shell;\n", "package com.alipay.antchain.bridge.pluginserver.cli.shell;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantLock;\n", "import java.util.concurrent.locks.ReentrantLock;\n\nimport com.alipay.antchain.bridge.pluginserver.cli.command.NamespaceManager;\nimport com.alipay.antchain.bridge.pluginserver.cli.core.ManagementGrpcClient;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReader.Option;\nimport org.jline.reader.impl.history.DefaultHistory;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\npublic class Shell {\n\n    private static final String PROMPT = \"\\033[0;37mps> \\033[0m\";\n\n    private final NamespaceManager namespaceManager;\n\n    private Terminal terminal;\n\n    private GlLineReader reader;\n\n    private final Map<String, ReservedWord> reservedWord = new HashMap<>();\n\n    private AtomicBoolean loopRunning = new AtomicBoolean(false);\n\n    private final ReentrantLock shellLock = new ReentrantLock();\n\n    private final PromptCompleter completer;\n\n    private final ShellProvider shellProvider;\n", "import org.jline.terminal.TerminalBuilder;\n\npublic class Shell {\n\n    private static final String PROMPT = \"\\033[0;37mps> \\033[0m\";\n\n    private final NamespaceManager namespaceManager;\n\n    private Terminal terminal;\n\n    private GlLineReader reader;\n\n    private final Map<String, ReservedWord> reservedWord = new HashMap<>();\n\n    private AtomicBoolean loopRunning = new AtomicBoolean(false);\n\n    private final ReentrantLock shellLock = new ReentrantLock();\n\n    private final PromptCompleter completer;\n\n    private final ShellProvider shellProvider;\n", "    public final static Runtime RUNTIME = new Runtime();\n\n    public Shell(ShellProvider shellProvider, PromptCompleter completer, ManagementGrpcClient grpcClient,\n                 NamespaceManager namespaceManager) {\n\n        // \u4e0d\u53ef\u6269\u5c55\u53c2\u6570\u521d\u59cb\u5316\n        init();\n\n        // \u6269\u5c55\u521d\u59cb\u5316\n        this.shellProvider = shellProvider;\n        this.namespaceManager = namespaceManager;\n\n        this.completer = completer;\n        this.reservedWord.keySet().forEach(reservedWord -> this.completer.addReservedWord(reservedWord));\n\n        reader.setCompleter(completer);\n\n        // \u8fd0\u884c\u65f6\u8bbe\u7f6e\n        RUNTIME.setGrpcClient(grpcClient);\n    }\n\n    void init() {\n        // init term", "        try {\n            terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n        } catch (IOException e) {\n            throw new RuntimeException(\"can't open system stream\");\n        }\n\n        // set printer\n        RUNTIME.setPrinter(terminal.writer());\n\n        // init linereader\n        reader = new GlLineReader(terminal, \"mychain-gl\", new HashMap<>());\n\n        reader.setVariable(LineReader.HISTORY_FILE, Paths.get(\"./clihistory.tmp\"));\n        reader.setHistory(new DefaultHistory(reader));\n\n        reader.unsetOpt(Option.MENU_COMPLETE);\n        reader.setOpt(Option.AUTO_LIST);\n        reader.unsetOpt(Option.AUTO_MENU);\n\n\n        // init shell commands\n        initReservedWord();\n    }\n", "    public void start() {\n\n        try {\n            if (shellLock.tryLock()) {\n\n                if (loopRunning.get()) {\n                    return;\n                }\n\n                loopRunning.set(true);\n\n                welcome();\n\n                new Thread(() -> {\n                    // start loop", "                    while (loopRunning.get()) {\n                        String cmd = reader.readLine(PROMPT);\n\n                        if (null == cmd || cmd.isEmpty()) {\n                            continue;\n                        }\n\n                        try {\n                            if (reservedWord.containsKey(cmd.trim())) {\n\n                                reservedWord.get(cmd.trim()).execute();\n                                continue;\n                            }\n\n                            String result = this.shellProvider.execute(cmd);", "                            if (reservedWord.containsKey(cmd.trim())) {\n\n                                reservedWord.get(cmd.trim()).execute();\n                                continue;\n                            }\n\n                            String result = this.shellProvider.execute(cmd);\n                            if (null != result) {\n                                if (result.startsWith(\"{\") || result.startsWith(\"[\")) {\n                                    RUNTIME.getPrinter().println(JsonUtil.format(result));\n                                } else {\n                                    RUNTIME.getPrinter().println(result);\n                                }\n\n                            }\n                        } catch (Exception e) {\n                            RUNTIME.getPrinter().println(\"shell evaluate fail:\" + e.getMessage());\n                        }\n                    }\n                }, \"shell_thread\").start();\n\n            }\n        } finally {\n            shellLock.unlock();\n        }\n    }\n", "                                if (result.startsWith(\"{\") || result.startsWith(\"[\")) {\n                                    RUNTIME.getPrinter().println(JsonUtil.format(result));\n                                } else {\n                                    RUNTIME.getPrinter().println(result);\n                                }\n\n                            }\n                        } catch (Exception e) {\n                            RUNTIME.getPrinter().println(\"shell evaluate fail:\" + e.getMessage());\n                        }\n                    }\n                }, \"shell_thread\").start();\n\n            }\n        } finally {\n            shellLock.unlock();\n        }\n    }\n", "    public String execute(String cmd) {\n        return this.shellProvider.execute(cmd);\n    }\n\n    public void stop() {\n\n        loopRunning.set(false);\n        try {\n            if (null != RUNTIME.getGrpcClient()) {\n                RUNTIME.getGrpcClient().shutdown();\n            }\n        } catch (InterruptedException e) {\n            // not process\n        }\n    }\n\n    protected void initReservedWord() {\n        this.reservedWord.put(\"exit\", this::exit);\n        this.reservedWord.put(\"help\", this::help);\n    }\n\n    protected void exit() {\n        stop();\n    }\n\n    protected void help() {\n        RUNTIME.getPrinter().print(namespaceManager.dump());\n    }\n\n    protected void welcome() {\n        RUNTIME.printer.println(\n                \"    ___            __   ______ __            _           ____         _      __\\n\" +\n                \"   /   |   ____   / /_ / ____// /_   ____ _ (_)____     / __ ) _____ (_)____/ /____ _ ___\\n\" +\n                \"  / /| |  / __ \\\\ / __// /    / __ \\\\ / __ `// // __ \\\\   / __  |/ ___// // __  // __ `// _ \\\\\\n\" +\n                \" / ___ | / / / // /_ / /___ / / / // /_/ // // / / /  / /_/ // /   / // /_/ // /_/ //  __/\\n\" +\n                \"/_/  |_|/_/ /_/ \\\\__/ \\\\____//_/ /_/ \\\\__,_//_//_/ /_/  /_____//_/   /_/ \\\\__,_/ \\\\__, / \\\\___/\\n\" +\n                \"                                                                            /____/        \\n\" +\n                \"                          PLUGIN SERVER CLI \" + Launcher.getVersion()\n        );\n        RUNTIME.printer.println(\"\\n>>> type help to see all commands...\");\n    }\n", "            if (null != RUNTIME.getGrpcClient()) {\n                RUNTIME.getGrpcClient().shutdown();\n            }\n        } catch (InterruptedException e) {\n            // not process\n        }\n    }\n\n    protected void initReservedWord() {\n        this.reservedWord.put(\"exit\", this::exit);\n        this.reservedWord.put(\"help\", this::help);\n    }\n\n    protected void exit() {\n        stop();\n    }\n\n    protected void help() {\n        RUNTIME.getPrinter().print(namespaceManager.dump());\n    }\n\n    protected void welcome() {\n        RUNTIME.printer.println(\n                \"    ___            __   ______ __            _           ____         _      __\\n\" +\n                \"   /   |   ____   / /_ / ____// /_   ____ _ (_)____     / __ ) _____ (_)____/ /____ _ ___\\n\" +\n                \"  / /| |  / __ \\\\ / __// /    / __ \\\\ / __ `// // __ \\\\   / __  |/ ___// // __  // __ `// _ \\\\\\n\" +\n                \" / ___ | / / / // /_ / /___ / / / // /_/ // // / / /  / /_/ // /   / // /_/ // /_/ //  __/\\n\" +\n                \"/_/  |_|/_/ /_/ \\\\__/ \\\\____//_/ /_/ \\\\__,_//_//_/ /_/  /_____//_/   /_/ \\\\__,_/ \\\\__, / \\\\___/\\n\" +\n                \"                                                                            /____/        \\n\" +\n                \"                          PLUGIN SERVER CLI \" + Launcher.getVersion()\n        );\n        RUNTIME.printer.println(\"\\n>>> type help to see all commands...\");\n    }\n", "    public static class Runtime {\n\n        private PrintWriter printer;\n\n        private ManagementGrpcClient grpcClient;\n\n        void setPrinter(PrintWriter printer) {\n\n            this.printer = printer;\n        }\n\n        void setGrpcClient(ManagementGrpcClient grpcClient) {\n            this.grpcClient = grpcClient;\n        }\n", "        public PrintWriter getPrinter() {\n            return printer;\n        }\n\n        public ManagementGrpcClient getGrpcClient() {\n            return grpcClient;\n        }\n\n    }\n}\n"]}
{"filename": "ps-cli/src/main/java/com/alipay/antchain/bridge/pluginserver/cli/core/ManagementGrpcClient.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.cli.core;\n", "package com.alipay.antchain.bridge.pluginserver.cli.core;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport cn.hutool.core.collection.CollUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;", "import com.alibaba.fastjson.JSON;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\n\npublic class ManagementGrpcClient {\n\n    private final ManagedChannel channel;\n    private ManagementServiceGrpc.ManagementServiceBlockingStub blockingStub;\n\n    private final String host;\n\n    private final int port;\n\n    public ManagementGrpcClient(int port) {\n        this(\"127.0.0.1\", port);\n    }\n\n    public ManagementGrpcClient(String host, int port) {\n        this.port = port;\n        this.host = host;\n        this.channel = ManagedChannelBuilder.forAddress(this.host, this.port)\n                .usePlaintext()\n                .build();\n        this.blockingStub = ManagementServiceGrpc.newBlockingStub(channel);\n    }\n", "    public boolean checkServerStatus() {\n        try {\n            Socket socket = new Socket(host, port);\n            socket.close();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public void shutdown() throws InterruptedException {\n        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n", "    public void shutdown() throws InterruptedException {\n        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n\n    public String managePlugin(PluginManageRequest.Type type, String product, String path) {\n        ManageResponse response = this.blockingStub.managePlugin(\n                PluginManageRequest.newBuilder()\n                        .setType(type)\n                        .setPath(path)\n                        .setProduct(product)\n                        .build()\n        );\n        return response.getCode() == 0 ? \"success\" : \"failed with msg: \" + response.getErrorMsg();\n    }\n", "    public String hasPlugins(List<String> productList) {\n        ManageResponse response = this.blockingStub.hasPlugins(\n                HasPluginsRequest.newBuilder()\n                        .addAllProducts(productList)\n                        .build()\n        );\n        if (response.getCode() != 0) {\n            return \"failed with msg: \" + response.getErrorMsg();\n        }\n\n        return JSON.toJSONString(response.getHasPluginsResp().getResultsMap());\n    }\n", "    public String getAllPlugins() {\n        ManageResponse response = this.blockingStub.allPlugins(AllPluginsRequest.newBuilder().build());\n        if (response.getCode() != 0) {\n            return \"failed with msg: \" + response.getErrorMsg();\n        }\n\n        return CollUtil.join(response.getAllPluginsResp().getProductsList(), \", \");\n    }\n\n    public String hasDomains(List<String> domains) {\n        ManageResponse response = this.blockingStub.hasDomains(\n                HasDomainsRequest.newBuilder()\n                        .addAllDomains(domains)\n                        .build()\n        );", "    public String hasDomains(List<String> domains) {\n        ManageResponse response = this.blockingStub.hasDomains(\n                HasDomainsRequest.newBuilder()\n                        .addAllDomains(domains)\n                        .build()\n        );\n        if (response.getCode() != 0) {\n            return \"failed with msg: \" + response.getErrorMsg();\n        }\n\n        return JSON.toJSONString(response.getHasDomainsResp().getResultsMap());\n    }\n", "    public String getAllDomains() {\n        ManageResponse response = this.blockingStub.allDomains(AllDomainsRequest.newBuilder().build());\n        if (response.getCode() != 0) {\n            return \"failed with msg: \" + response.getErrorMsg();\n        }\n\n        return CollUtil.join(response.getAllDomainsResp().getDomainsList(), \", \");\n    }\n\n    public String restartBBC(String product, String domain) {\n        ManageResponse response = this.blockingStub.restartBBC(\n                RestartBBCRequest.newBuilder()\n                        .setProduct(product)\n                        .setDomain(domain)\n                        .build()\n        );", "    public String restartBBC(String product, String domain) {\n        ManageResponse response = this.blockingStub.restartBBC(\n                RestartBBCRequest.newBuilder()\n                        .setProduct(product)\n                        .setDomain(domain)\n                        .build()\n        );\n        if (response.getCode() != 0) {\n            return \"failed with msg: \" + response.getErrorMsg();\n        }\n        return \"success\";\n    }\n}\n"]}
{"filename": "ps-server/src/main/java/com/alipay/antchain/bridge/pluginserver/server/ResponseBuilder.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.server;\n", "package com.alipay.antchain.bridge.pluginserver.server;\n\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;\nimport com.alipay.antchain.bridge.pluginserver.server.exception.ServerErrorCodeEnum;\nimport com.alipay.antchain.bridge.pluginserver.service.*;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class ResponseBuilder {\n\n    public static Response buildBBCSuccessResp(CallBBCResponse.Builder respBuilder) {\n        log.debug(\"call bbc service response success\");\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setBbcResp(respBuilder).build();\n    }\n", "public class ResponseBuilder {\n\n    public static Response buildBBCSuccessResp(CallBBCResponse.Builder respBuilder) {\n        log.debug(\"call bbc service response success\");\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setBbcResp(respBuilder).build();\n    }\n", "    public static Response buildHeartbeatSuccessResp(HeartbeatResponse.Builder respBuilder) {\n        log.debug(\"HeartbeatResponse, domains: {}, product: {}\", respBuilder.getDomainsList(), respBuilder.getProductsList());\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setHeartbeatResp(respBuilder).build();\n    }\n\n    public static Response buildIfProductSupportSuccessResp(IfProductSupportResponse.Builder respBuilder) {\n        log.debug(\"IfProductSupportResponse: {}\", respBuilder.getResults());\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setIfProductSupportResp(respBuilder).build();\n    }\n", "    public static Response buildIfProductSupportSuccessResp(IfProductSupportResponse.Builder respBuilder) {\n        log.debug(\"IfProductSupportResponse: {}\", respBuilder.getResults());\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setIfProductSupportResp(respBuilder).build();\n    }\n\n    public static Response buildIfDomainAliveSuccessResp(IfDomainAliveResponse.Builder respBuilder) {\n        log.debug(\"IfDomainAliveResponse: {}\", respBuilder.getResults());\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setIfDomainAliveResp(respBuilder).build();\n    }\n", "    public static Response buildIfDomainAliveSuccessResp(IfDomainAliveResponse.Builder respBuilder) {\n        log.debug(\"IfDomainAliveResponse: {}\", respBuilder.getResults());\n\n        return Response.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setIfDomainAliveResp(respBuilder).build();\n    }\n\n    public static Response buildFailResp(ServerErrorCodeEnum errorCodeEnum) {\n\n        return Response.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(errorCodeEnum.getShortMsg()).build();\n    }\n", "    public static Response buildFailResp(ServerErrorCodeEnum errorCodeEnum) {\n\n        return Response.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(errorCodeEnum.getShortMsg()).build();\n    }\n\n    public static Response buildFailResp(ServerErrorCodeEnum errorCodeEnum, String longMsg) {\n\n        return Response.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(longMsg).build();\n    }\n\n    // ManageResponse builder ======================================\n", "    public static ManageResponse buildPluginManageSuccessResp(PluginManageResp.Builder respBuilder) {\n        log.debug(\"plugin manage response success\");\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setPluginManageResp(respBuilder).build();\n    }\n\n    public static ManageResponse buildHasPluginsResp(HasPluginsResp.Builder respBuilder) {\n        log.debug(\"HasPluginsResponse: {}\", respBuilder.getResults());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setHasPluginsResp(respBuilder).build();\n    }\n", "    public static ManageResponse buildHasPluginsResp(HasPluginsResp.Builder respBuilder) {\n        log.debug(\"HasPluginsResponse: {}\", respBuilder.getResults());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setHasPluginsResp(respBuilder).build();\n    }\n\n    public static ManageResponse buildAllPluginsResp(AllPluginsResp.Builder respBuilder) {\n        log.debug(\"AllPluginResponse: {}\", respBuilder.getProductsList());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setAllPluginsResp(respBuilder).build();\n    }\n", "    public static ManageResponse buildAllPluginsResp(AllPluginsResp.Builder respBuilder) {\n        log.debug(\"AllPluginResponse: {}\", respBuilder.getProductsList());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setAllPluginsResp(respBuilder).build();\n    }\n\n    public static ManageResponse buildHasDomainsResp(HasDomainsResp.Builder respBuilder) {\n        log.debug(\"HasDomainsResponse: {}\", respBuilder.getResults());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setHasDomainsResp(respBuilder).build();\n    }\n", "    public static ManageResponse buildHasDomainsResp(HasDomainsResp.Builder respBuilder) {\n        log.debug(\"HasDomainsResponse: {}\", respBuilder.getResults());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setHasDomainsResp(respBuilder).build();\n    }\n\n    public static ManageResponse buildAllDomainsResp(AllDomainsResp.Builder respBuilder) {\n        log.debug(\"AllDomainsResponse: {}\", respBuilder.getDomainsList());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setAllDomainsResp(respBuilder).build();\n    }\n", "    public static ManageResponse buildAllDomainsResp(AllDomainsResp.Builder respBuilder) {\n        log.debug(\"AllDomainsResponse: {}\", respBuilder.getDomainsList());\n\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setAllDomainsResp(respBuilder).build();\n    }\n\n    public static ManageResponse buildRestartBBCResp(RestartBBCResp.Builder respBuilder) {\n        log.debug(\"restart bbc service success\");\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setRestartBBCResp(respBuilder)\n                .build();\n    }\n", "    public static ManageResponse buildRestartBBCResp(RestartBBCResp.Builder respBuilder) {\n        log.debug(\"restart bbc service success\");\n        return ManageResponse.newBuilder()\n                .setCode(ServerErrorCodeEnum.SUCCESS.getErrorCode())\n                .setErrorMsg(ServerErrorCodeEnum.SUCCESS.getShortMsg())\n                .setRestartBBCResp(respBuilder)\n                .build();\n    }\n\n    public static ManageResponse buildFailManageResp(ServerErrorCodeEnum errorCodeEnum) {\n\n        return ManageResponse.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(errorCodeEnum.getShortMsg()).build();\n    }\n", "    public static ManageResponse buildFailManageResp(ServerErrorCodeEnum errorCodeEnum) {\n\n        return ManageResponse.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(errorCodeEnum.getShortMsg()).build();\n    }\n\n    public static ManageResponse buildFailManageResp(ServerErrorCodeEnum errorCodeEnum, String longMsg) {\n\n        return ManageResponse.newBuilder()\n                .setCode(errorCodeEnum.getErrorCode())\n                .setErrorMsg(longMsg).build();\n    }\n}\n"]}
{"filename": "ps-server/src/main/java/com/alipay/antchain/bridge/pluginserver/server/CrossChainServiceImpl.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.server;\n", "package com.alipay.antchain.bridge.pluginserver.server;\n\nimport cn.hutool.core.util.ObjectUtil;\nimport cn.hutool.core.util.StrUtil;\nimport com.alipay.antchain.bridge.commons.bbc.AbstractBBCContext;\nimport com.alipay.antchain.bridge.commons.bbc.DefaultBBCContext;\nimport com.alipay.antchain.bridge.commons.bbc.syscontract.SDPContract;\nimport com.alipay.antchain.bridge.commons.core.base.CrossChainMessageReceipt;\nimport com.alipay.antchain.bridge.plugins.spi.bbc.IBBCService;\nimport com.alipay.antchain.bridge.pluginserver.pluginmanager.IPluginManagerWrapper;", "import com.alipay.antchain.bridge.plugins.spi.bbc.IBBCService;\nimport com.alipay.antchain.bridge.pluginserver.pluginmanager.IPluginManagerWrapper;\nimport com.alipay.antchain.bridge.pluginserver.server.exception.ServerErrorCodeEnum;\nimport com.alipay.antchain.bridge.pluginserver.service.*;\nimport com.google.protobuf.ByteString;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\nimport net.devh.boot.grpc.server.service.GrpcService;\nimport org.springframework.beans.factory.annotation.Autowired;\n", "import org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.stream.Collectors;\nimport javax.annotation.Resource;\n\n@GrpcService\n@Slf4j\npublic class CrossChainServiceImpl extends CrossChainServiceGrpc.CrossChainServiceImplBase {\n    @Resource\n    private IPluginManagerWrapper pluginManagerWrapper;\n\n    @Override", "    public void heartbeat(Empty request, StreamObserver<Response> responseObserver) {\n        log.info(\"heartbeat from relayer\");\n        responseObserver.onNext(\n                ResponseBuilder.buildHeartbeatSuccessResp(\n                        HeartbeatResponse.newBuilder()\n                                .addAllDomains(pluginManagerWrapper.allRunningDomains())\n                                .addAllProducts(pluginManagerWrapper.allSupportProducts())\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    @Override", "    public void ifProductSupport(IfProductSupportRequest request, StreamObserver<Response> responseObserver) {\n        responseObserver.onNext(\n                ResponseBuilder.buildIfProductSupportSuccessResp(\n                        IfProductSupportResponse.newBuilder()\n                                .putAllResults(request.getProductsList().stream().distinct().collect(Collectors.toMap(p -> p, p -> pluginManagerWrapper.hasPlugin(p))))\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    @Override", "    public void ifDomainAlive(IfDomainAliveRequest request, StreamObserver<Response> responseObserver) {\n        responseObserver.onNext(\n                ResponseBuilder.buildIfDomainAliveSuccessResp(\n                        IfDomainAliveResponse.newBuilder()\n                                .putAllResults(request.getDomainsList().stream().distinct().collect(Collectors.toMap(d -> d, d -> pluginManagerWrapper.hasDomain(d))))\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    @Override", "    public void bbcCall(CallBBCRequest request, StreamObserver<Response> responseObserver) {\n        String product = request.getProduct();\n        String domain = request.getDomain();\n        if (CallBBCRequest.RequestCase.QUERYLATESTHEIGHTREQ == request.getRequestCase()) {\n            log.debug(\"BBCCall [product: {}, domain: {}, request: {}]\", product, domain, request.getRequestCase());\n        } else {\n            log.info(\"BBCCall [product: {}, domain: {}, request: {}]\", product, domain, request.getRequestCase());\n        }\n\n        Response resp;\n\n        // 1. Startup request needs to be handled separately\uff0c because it may need create a service first.", "        if (request.hasStartUpReq()) {\n            responseObserver.onNext(handleStartUp(product, domain, request.getStartUpReq()));\n            responseObserver.onCompleted();\n            return;\n        }\n\n        if (!pluginManagerWrapper.hasPlugin(product)) {\n            responseObserver.onNext(ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_PLUGIN_NOT_SUPPORT, \"product not supported\"));\n            responseObserver.onCompleted();\n            return;\n        }\n", "        if (!pluginManagerWrapper.hasDomain(domain)) {\n            responseObserver.onNext(ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_OBJECT_NOT_STARTED, \"call startup plz\"));\n            responseObserver.onCompleted();\n            return;\n        }\n\n        // 2. Other bbc requests need to be processed based on an existing service.\n        IBBCService bbcService;\n        try {\n            bbcService = pluginManagerWrapper.getBBCService(product, domain);\n            if (ObjectUtil.isNull(bbcService)) {\n                throw new RuntimeException(\"null bbc service object\");\n            }\n        } catch (Exception e){\n            log.error(\"BBCCall fail when getting the bbc object [product: {}, domain: {}, request: {}, errorCode: {}, errorMsg: {}]\",\n                    product, domain, request.getRequestCase(), ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getShortMsg(), e);\n            responseObserver.onNext(ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR, e.toString()));\n            responseObserver.onCompleted();\n            return;\n        }\n\n        // 3. Other bbc requests handler.\n        switch (request.getRequestCase()){\n            case SHUTDOWNREQ:\n                resp = handleShutDown(bbcService, product, domain);\n                break;\n            case GETCONTEXTREQ:\n                resp = handleGetContext(bbcService, product, domain);\n                break;\n            case SETUPSDPMESSAGECONTRACTREQ:\n                resp = handleSetupSDPMessageContract(bbcService, product, domain);\n                break;\n            case SETUPAUTHMESSAGECONTRACTREQ:\n                resp = handleSetupAuthMessageContract(bbcService, product, domain);\n                break;\n            case SETPROTOCOLREQ:\n                resp = handleSetProtocol(bbcService, request.getSetProtocolReq(), product, domain);\n                break;\n            case SETAMCONTRACTREQ:\n                resp = handleSetAmContract(bbcService, request.getSetAmContractReq(), product, domain);\n                break;\n            case RELAYAUTHMESSAGEREQ:\n                resp = handleRelayAuthMessage(bbcService, request.getRelayAuthMessageReq(), product, domain);\n                break;\n            case READCROSSCHAINMESSAGERECEIPTREQ:\n                resp = handleReadCrossChainMessageReceiptRequest(bbcService, request.getReadCrossChainMessageReceiptReq(), product, domain);\n                break;\n            case READCROSSCHAINMESSAGESBYHEIGHTREQ:\n                resp = handleReadCrossChainMessagesByHeight(bbcService, request.getReadCrossChainMessagesByHeightReq(), product, domain);\n                break;\n            case QUERYSDPMESSAGESEQREQ:\n                resp = handleQuerySDPMessageSeq(bbcService, request.getQuerySDPMessageSeqReq(), product, domain);\n                break;\n            case QUERYLATESTHEIGHTREQ:\n                resp = handleQueryLatestHeight(bbcService, product, domain);\n                break;\n            case SETLOCALDOMAINREQ:\n                resp = handleSetLocalDomain(bbcService, request.getSetLocalDomainReq(), product, domain);\n                break;\n            default:\n                log.error(\"BBCCall fail [product: {}, domain: {}, request: {}, errorCode: {}, errorMsg: {}]\", product, domain, request.getRequestCase(), ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR.getErrorCode(), ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR.getShortMsg());\n                resp = ResponseBuilder.buildFailResp(ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR);\n                break;\n        }\n\n        responseObserver.onNext(resp);\n        responseObserver.onCompleted();\n    }\n\n    private Response handleStartUp(String product, String domain, StartUpRequest request) {\n        IBBCService bbcService;\n\n        // 1. get service", "        try {\n            bbcService = pluginManagerWrapper.getBBCService(product, domain);\n            if (ObjectUtil.isNull(bbcService)) {\n                throw new RuntimeException(\"null bbc service object\");\n            }\n        } catch (Exception e){\n            log.error(\"BBCCall fail when getting the bbc object [product: {}, domain: {}, request: {}, errorCode: {}, errorMsg: {}]\",\n                    product, domain, request.getRequestCase(), ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getShortMsg(), e);\n            responseObserver.onNext(ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR, e.toString()));\n            responseObserver.onCompleted();\n            return;\n        }\n\n        // 3. Other bbc requests handler.\n        switch (request.getRequestCase()){\n            case SHUTDOWNREQ:\n                resp = handleShutDown(bbcService, product, domain);\n                break;\n            case GETCONTEXTREQ:\n                resp = handleGetContext(bbcService, product, domain);\n                break;\n            case SETUPSDPMESSAGECONTRACTREQ:\n                resp = handleSetupSDPMessageContract(bbcService, product, domain);\n                break;\n            case SETUPAUTHMESSAGECONTRACTREQ:\n                resp = handleSetupAuthMessageContract(bbcService, product, domain);\n                break;\n            case SETPROTOCOLREQ:\n                resp = handleSetProtocol(bbcService, request.getSetProtocolReq(), product, domain);\n                break;\n            case SETAMCONTRACTREQ:\n                resp = handleSetAmContract(bbcService, request.getSetAmContractReq(), product, domain);\n                break;\n            case RELAYAUTHMESSAGEREQ:\n                resp = handleRelayAuthMessage(bbcService, request.getRelayAuthMessageReq(), product, domain);\n                break;\n            case READCROSSCHAINMESSAGERECEIPTREQ:\n                resp = handleReadCrossChainMessageReceiptRequest(bbcService, request.getReadCrossChainMessageReceiptReq(), product, domain);\n                break;\n            case READCROSSCHAINMESSAGESBYHEIGHTREQ:\n                resp = handleReadCrossChainMessagesByHeight(bbcService, request.getReadCrossChainMessagesByHeightReq(), product, domain);\n                break;\n            case QUERYSDPMESSAGESEQREQ:\n                resp = handleQuerySDPMessageSeq(bbcService, request.getQuerySDPMessageSeqReq(), product, domain);\n                break;\n            case QUERYLATESTHEIGHTREQ:\n                resp = handleQueryLatestHeight(bbcService, product, domain);\n                break;\n            case SETLOCALDOMAINREQ:\n                resp = handleSetLocalDomain(bbcService, request.getSetLocalDomainReq(), product, domain);\n                break;\n            default:\n                log.error(\"BBCCall fail [product: {}, domain: {}, request: {}, errorCode: {}, errorMsg: {}]\", product, domain, request.getRequestCase(), ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR.getErrorCode(), ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR.getShortMsg());\n                resp = ResponseBuilder.buildFailResp(ServerErrorCodeEnum.UNSUPPORT_BBC_REQUEST_ERROR);\n                break;\n        }\n\n        responseObserver.onNext(resp);\n        responseObserver.onCompleted();\n    }\n\n    private Response handleStartUp(String product, String domain, StartUpRequest request) {\n        IBBCService bbcService;\n\n        // 1. get service", "        if(pluginManagerWrapper.hasDomain(domain)){\n            log.info(\"get service for blockchain ( product: {} , domain: {} )\", product, domain);\n            try {\n                bbcService = pluginManagerWrapper.getBBCService(product, domain);\n            } catch (Exception e){\n                log.error(\"BBCCall(handleStartUp) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR.getShortMsg(), e);\n                return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_GET_SERVICE_ERROR, e.toString());\n            }\n        } else {\n            log.info(\"create service for blockchain ( product: {} , domain: {} )\", product, domain);\n            try{\n                bbcService = pluginManagerWrapper.createBBCService(product, domain);\n            } catch (Exception e){\n                log.error(\"BBCCall(handleStartUp) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_CREATE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_CREATE_ERROR.getShortMsg(), e);\n                return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_CREATE_ERROR, e.toString());\n            }\n        }\n\n        log.info(\"startup service for blockchain ( product: {} , domain: {} )\", product, domain);\n        // 2. start service", "            try{\n                bbcService = pluginManagerWrapper.createBBCService(product, domain);\n            } catch (Exception e){\n                log.error(\"BBCCall(handleStartUp) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_CREATE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_CREATE_ERROR.getShortMsg(), e);\n                return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_CREATE_ERROR, e.toString());\n            }\n        }\n\n        log.info(\"startup service for blockchain ( product: {} , domain: {} )\", product, domain);\n        // 2. start service\n        try{\n            DefaultBBCContext ctx = new DefaultBBCContext();\n            ctx.decodeFromBytes(request.getRawContext().toByteArray());\n            bbcService.startup(ctx);\n\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e){\n            log.error(\"BBCCall(handleStartUp) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_STARTUP_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_STARTUP_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_STARTUP_ERROR, e.toString());\n        }\n    }\n\n    private Response handleShutDown(IBBCService bbcService, String product, String domain) {", "        try{\n            DefaultBBCContext ctx = new DefaultBBCContext();\n            ctx.decodeFromBytes(request.getRawContext().toByteArray());\n            bbcService.startup(ctx);\n\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e){\n            log.error(\"BBCCall(handleStartUp) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_STARTUP_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_STARTUP_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_STARTUP_ERROR, e.toString());\n        }\n    }\n\n    private Response handleShutDown(IBBCService bbcService, String product, String domain) {", "        try {\n            bbcService.shutdown();\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e){\n            log.error(\"BBCCall(handleShutDown) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SHUTDOWN_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SHUTDOWN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SHUTDOWN_ERROR, e.toString());\n        }\n    }\n\n    private Response handleGetContext(IBBCService bbcService, String product, String domain) {\n        try {\n            AbstractBBCContext ctx = bbcService.getContext();\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setGetContextResp(GetContextResponse.newBuilder()\n                            .setRawContext(ByteString.copyFrom(ctx.encodeToBytes()))\n                    )\n            );\n        } catch (Exception e){\n            log.error(\"BBCCall(handleGetContext) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetupSDPMessageContract(IBBCService bbcService, String product, String domain) {", "        try {\n            AbstractBBCContext ctx = bbcService.getContext();\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setGetContextResp(GetContextResponse.newBuilder()\n                            .setRawContext(ByteString.copyFrom(ctx.encodeToBytes()))\n                    )\n            );\n        } catch (Exception e){\n            log.error(\"BBCCall(handleGetContext) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_GETCONTEXT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetupSDPMessageContract(IBBCService bbcService, String product, String domain) {", "        try {\n            bbcService.setupSDPMessageContract();\n            SDPContract sdp = bbcService.getContext().getSdpContract();\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setSetupSDPResp(SetupSDPMessageContractResponse.newBuilder()\n                            .setSdpContract(\n                                    SDPMessageContract.newBuilder()\n                                            .setContractAddress(sdp.getContractAddress())\n                                            .setStatusValue(sdp.getStatus().ordinal())\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleSetupSDPMessageContract) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SETUPSDPMESSAGECONTRACT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SETUPSDPMESSAGECONTRACT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETUPSDPMESSAGECONTRACT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetupAuthMessageContract(IBBCService bbcService, String product, String domain) {", "        try {\n            bbcService.setupAuthMessageContract();\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setSetupAMResp(SetupAuthMessageContractResponse.newBuilder()\n                            .setAmContract(\n                                    AuthMessageContract.newBuilder()\n                                            .setContractAddress(bbcService.getContext().getAuthMessageContract().getContractAddress())\n                                            .setStatusValue(bbcService.getContext().getAuthMessageContract().getStatus().ordinal())\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleSetupAuthMessageContract) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SETUPAUTHMESSAGECONTRACT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SETUPAUTHMESSAGECONTRACT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETUPAUTHMESSAGECONTRACT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetProtocol(IBBCService bbcService, SetProtocolRequest request, String product, String domain) {", "        try {\n            bbcService.setProtocol(request.getProtocolAddress(), request.getProtocolType());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleSetProtocol) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SETPROTOCOL_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SETPROTOCOL_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETPROTOCOL_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetAmContract(IBBCService bbcService, SetAmContractRequest request, String product, String domain) {\n        try {\n            bbcService.setAmContract(request.getContractAddress());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleSetAmContract) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleRelayAuthMessage(IBBCService bbcService, RelayAuthMessageRequest request, String product, String domain) {", "        try {\n            bbcService.setAmContract(request.getContractAddress());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleSetAmContract) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETAMCONTRACT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleRelayAuthMessage(IBBCService bbcService, RelayAuthMessageRequest request, String product, String domain) {\n        try {\n            CrossChainMessageReceipt ret = bbcService.relayAuthMessage(request.getRawMessage().toByteArray());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setRelayAuthMessageResponse(RelayAuthMessageResponse.newBuilder()\n                            .setReceipt(com.alipay.antchain.bridge.pluginserver.service.CrossChainMessageReceipt.newBuilder()\n                                    .setTxhash(ObjectUtil.defaultIfNull(ret.getTxhash(), \"\"))\n                                    .setConfirmed(ret.isConfirmed())\n                                    .setSuccessful(ret.isSuccessful())\n                                    .setErrorMsg(ObjectUtil.defaultIfNull(ret.getErrorMsg(), \"\"))\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleRelayAuthMessage) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR, e.toString());\n        }\n    }\n\n    private Response handleReadCrossChainMessageReceiptRequest(IBBCService bbcService, ReadCrossChainMessageReceiptRequest request, String product, String domain) {", "        try {\n            CrossChainMessageReceipt ret = bbcService.relayAuthMessage(request.getRawMessage().toByteArray());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setRelayAuthMessageResponse(RelayAuthMessageResponse.newBuilder()\n                            .setReceipt(com.alipay.antchain.bridge.pluginserver.service.CrossChainMessageReceipt.newBuilder()\n                                    .setTxhash(ObjectUtil.defaultIfNull(ret.getTxhash(), \"\"))\n                                    .setConfirmed(ret.isConfirmed())\n                                    .setSuccessful(ret.isSuccessful())\n                                    .setErrorMsg(ObjectUtil.defaultIfNull(ret.getErrorMsg(), \"\"))\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleRelayAuthMessage) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_RELAYAUTHMESSAGE_ERROR, e.toString());\n        }\n    }\n\n    private Response handleReadCrossChainMessageReceiptRequest(IBBCService bbcService, ReadCrossChainMessageReceiptRequest request, String product, String domain) {", "        try {\n            CrossChainMessageReceipt receipt = bbcService.readCrossChainMessageReceipt(request.getTxhash());\n            if (ObjectUtil.isNull(receipt)) {\n                throw new RuntimeException(\"empty receipt for tx \" + request.getTxhash());\n            }\n\n            return ResponseBuilder.buildBBCSuccessResp(\n                    CallBBCResponse.newBuilder().setReadCrossChainMessageReceiptResp(\n                            ReadCrossChainMessageReceiptResponse.newBuilder()\n                                    .setReceipt(\n                                            com.alipay.antchain.bridge.pluginserver.service.CrossChainMessageReceipt.newBuilder()\n                                                    .setConfirmed(receipt.isConfirmed())\n                                                    .setSuccessful(receipt.isSuccessful())\n                                                    .setTxhash(StrUtil.nullToDefault(receipt.getTxhash(), \"\"))\n                                                    .setErrorMsg(StrUtil.nullToDefault(receipt.getErrorMsg(), \"\"))\n                                    )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleIsCrossChainMessageConfirmed) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_READ_CCMSG_RET_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_READ_CCMSG_RET_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_READ_CCMSG_RET_ERROR, e.toString());\n        }\n    }\n\n    private Response handleReadCrossChainMessagesByHeight(IBBCService bbcService, ReadCrossChainMessagesByHeightRequest request, String product, String domain) {", "        try {\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setReadCrossChainMessagesByHeightResp(ReadCrossChainMessagesByHeightResponse.newBuilder()\n                            .addAllMessageList(\n                                    bbcService.readCrossChainMessagesByHeight(request.getHeight()).stream()\n                                            .map(m -> CrossChainMessage.newBuilder()\n                                                    .setType(CrossChainMessageType.forNumber(m.getType().ordinal()))\n                                                    .setMessage(ByteString.copyFrom(m.getMessage()))\n                                                    .setProvableData(ProvableLedgerData.newBuilder()\n                                                            .setHeight(m.getProvableData().getHeight())\n                                                            .setLedgerData(ByteString.copyFrom(\n                                                                    ObjectUtil.defaultIfNull(m.getProvableData().getLedgerData(), new byte[]{})\n                                                            )).setProof(ByteString.copyFrom(\n                                                                    ObjectUtil.defaultIfNull(m.getProvableData().getProof(), new byte[]{})\n                                                            )).setBlockHash(ByteString.copyFrom(\n                                                                    ObjectUtil.defaultIfNull(m.getProvableData().getBlockHash(), new byte[]{})\n                                                            )).setTimestamp(m.getProvableData().getTimestamp())\n                                                    ).build()\n                                            ).collect(Collectors.toList())\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleReadCrossChainMessagesByHeight) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_READCROSSCHAINMESSAGESBYHEIGHT_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_READCROSSCHAINMESSAGESBYHEIGHT_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_READCROSSCHAINMESSAGESBYHEIGHT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleQuerySDPMessageSeq(IBBCService bbcService, QuerySDPMessageSeqRequest request, String product, String domain) {", "        try {\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setQuerySDPMsgSeqResp(QuerySDPMessageSeqResponse.newBuilder()\n                            .setSequence(\n                                    bbcService.querySDPMessageSeq(\n                                            request.getSenderDomain(),\n                                            request.getFromAddress(),\n                                            request.getReceiverDomain(),\n                                            request.getToAddress()\n                                    )\n                            )\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\"BBCCall(handleQuerySDPMessageSeq) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\", product, domain, ServerErrorCodeEnum.BBC_QUERYSDPMESSAGESEQ_ERROR.getErrorCode(), ServerErrorCodeEnum.BBC_QUERYSDPMESSAGESEQ_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_QUERYSDPMESSAGESEQ_ERROR, e.toString());\n        }\n    }\n\n    private Response handleQueryLatestHeight(IBBCService bbcService, String product, String domain) {", "        try {\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder()\n                    .setQueryLatestHeightResponse(QueryLatestHeightResponse.newBuilder()\n                            .setHeight(bbcService.queryLatestHeight())\n                    )\n            );\n        } catch (Exception e) {\n            log.error(\n                    \"BBCCall(handleQueryLatestHeight) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\",\n                    product, domain,\n                    ServerErrorCodeEnum.BBC_QUERYLATESTHEIGHT_ERROR.getErrorCode(),\n                    ServerErrorCodeEnum.BBC_QUERYLATESTHEIGHT_ERROR.getShortMsg(),\n                    e\n            );\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_QUERYLATESTHEIGHT_ERROR, e.toString());\n        }\n    }\n\n    private Response handleSetLocalDomain(IBBCService bbcService, SetLocalDomainRequest request, String product, String domain) {", "        try {\n            bbcService.setLocalDomain(request.getDomain());\n            return ResponseBuilder.buildBBCSuccessResp(CallBBCResponse.newBuilder());\n        } catch (Exception e) {\n            log.error(\n                    \"BBCCall(handleSetLocalDomain) fail [product: {}, domain: {}, errorCode: {}, errorMsg: {}]\",\n                    product, domain,\n                    ServerErrorCodeEnum.BBC_SETLOCALDOMAIN_ERROR.getErrorCode(),\n                    ServerErrorCodeEnum.BBC_SETLOCALDOMAIN_ERROR.getShortMsg(),\n                    e\n            );\n            return ResponseBuilder.buildFailResp(ServerErrorCodeEnum.BBC_SETLOCALDOMAIN_ERROR, e.toString());\n        }\n    }\n}\n"]}
{"filename": "ps-server/src/main/java/com/alipay/antchain/bridge/pluginserver/server/PluginManagementServiceImpl.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.server;\n", "package com.alipay.antchain.bridge.pluginserver.server;\n\nimport cn.hutool.core.util.ObjectUtil;\nimport com.alipay.antchain.bridge.plugins.spi.bbc.IBBCService;\nimport com.alipay.antchain.bridge.pluginserver.managementservice.*;\nimport com.alipay.antchain.bridge.pluginserver.pluginmanager.IPluginManagerWrapper;\nimport com.alipay.antchain.bridge.pluginserver.server.exception.ServerErrorCodeEnum;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;", "import lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Comparator;\nimport java.util.stream.Collectors;\n\n@Component\n@Slf4j\npublic class PluginManagementServiceImpl extends ManagementServiceGrpc.ManagementServiceImplBase {\n    @Autowired\n    private IPluginManagerWrapper pluginManagerWrapper;\n\n    /**\n     * <pre>\n     * maintenance personnel may invoke this interface to load, unload, start, and stop plugins\n     * </pre>\n     */", "@Slf4j\npublic class PluginManagementServiceImpl extends ManagementServiceGrpc.ManagementServiceImplBase {\n    @Autowired\n    private IPluginManagerWrapper pluginManagerWrapper;\n\n    /**\n     * <pre>\n     * maintenance personnel may invoke this interface to load, unload, start, and stop plugins\n     * </pre>\n     */\n    public void managePlugin(PluginManageRequest request, StreamObserver<ManageResponse> responseObserver) {\n        String path = request.getPath();\n        String product = request.getProduct();\n        log.info(\"ManageRequest [path: {}, product: {}, request: {}]\", path, product, request.getType());\n\n        ManageResponse resp;\n\n        switch (request.getType()){\n            case LOAD_PLUGINS:\n                resp = handleLoadPlugins();\n                break;\n            case START_PLUGINS:\n                resp = handleStartPlugins();\n                break;\n            case LOAD_PLUGIN:\n                resp = handleLoadPlugin(path);\n                break;\n            case START_PLUGIN:\n                resp = handleStartPlugin(path);\n                break;\n            case STOP_PLUGIN:\n                resp = handleStopPlugin(product);\n                break;\n            case START_PLUGIN_FROM_STOP:\n                resp = handleStartPluginFromStop(product);\n                break;\n            case RELOAD_PLUGIN:\n                resp = handleReloadPlugin(product);\n                break;\n            case RELOAD_PLUGIN_IN_NEW_PATH:\n                resp = handleReloadPluginInNewPath(product, path);\n                break;\n            default:\n                log.error(\"managePlugin fail [path: {}, product: {}, request: {}, errorCode: {}, errorMsg: {}]\", path, product, request.getType(), ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR.getErrorCode(), ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR.getShortMsg());\n                resp = ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR);\n                break;\n        }\n\n        responseObserver.onNext(resp);\n        responseObserver.onCompleted();\n    }\n\n    private ManageResponse handleLoadPlugins() {", "    public void managePlugin(PluginManageRequest request, StreamObserver<ManageResponse> responseObserver) {\n        String path = request.getPath();\n        String product = request.getProduct();\n        log.info(\"ManageRequest [path: {}, product: {}, request: {}]\", path, product, request.getType());\n\n        ManageResponse resp;\n\n        switch (request.getType()){\n            case LOAD_PLUGINS:\n                resp = handleLoadPlugins();\n                break;\n            case START_PLUGINS:\n                resp = handleStartPlugins();\n                break;\n            case LOAD_PLUGIN:\n                resp = handleLoadPlugin(path);\n                break;\n            case START_PLUGIN:\n                resp = handleStartPlugin(path);\n                break;\n            case STOP_PLUGIN:\n                resp = handleStopPlugin(product);\n                break;\n            case START_PLUGIN_FROM_STOP:\n                resp = handleStartPluginFromStop(product);\n                break;\n            case RELOAD_PLUGIN:\n                resp = handleReloadPlugin(product);\n                break;\n            case RELOAD_PLUGIN_IN_NEW_PATH:\n                resp = handleReloadPluginInNewPath(product, path);\n                break;\n            default:\n                log.error(\"managePlugin fail [path: {}, product: {}, request: {}, errorCode: {}, errorMsg: {}]\", path, product, request.getType(), ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR.getErrorCode(), ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR.getShortMsg());\n                resp = ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.UNSUPPORT_MANAGE_REQUEST_ERROR);\n                break;\n        }\n\n        responseObserver.onNext(resp);\n        responseObserver.onCompleted();\n    }\n\n    private ManageResponse handleLoadPlugins() {", "        try {\n            pluginManagerWrapper.loadPlugins();\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleLoadPlugins) fail [errorCode: {}, errorMsg: {}]\", ServerErrorCodeEnum.MANAGE_LOAD_PLUGINS_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_LOAD_PLUGINS_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_LOAD_PLUGINS_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStartPlugins() {\n        try {\n            pluginManagerWrapper.startPlugins();\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPlugins) fail [errorCode: {}, errorMsg: {}]\", ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleLoadPlugin(String path) {", "        try {\n            pluginManagerWrapper.startPlugins();\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPlugins) fail [errorCode: {}, errorMsg: {}]\", ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGINS_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleLoadPlugin(String path) {\n        try {\n            pluginManagerWrapper.loadPlugin(path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n             log.error(\"manage(handleLoadPlugin) fail [path: {}, errorCode: {}, errorMsg: {}]\", path, ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStartPlugin(String path) {", "        try {\n            pluginManagerWrapper.loadPlugin(path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n             log.error(\"manage(handleLoadPlugin) fail [path: {}, errorCode: {}, errorMsg: {}]\", path, ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_LOAD_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStartPlugin(String path) {\n        try {\n            pluginManagerWrapper.startPlugin(path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPlugin) fail [path: {}, errorCode: {}, errorMsg: {}]\", path, ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStopPlugin(String product) {", "        try {\n            pluginManagerWrapper.startPlugin(path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPlugin) fail [path: {}, errorCode: {}, errorMsg: {}]\", path, ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStopPlugin(String product) {\n        try {\n            pluginManagerWrapper.stopPlugin(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStopPlugin) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStartPluginFromStop(String product) {", "        try {\n            pluginManagerWrapper.stopPlugin(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStopPlugin) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_STOP_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleStartPluginFromStop(String product) {\n        try {\n            pluginManagerWrapper.startPluginFromStop(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPluginFromStop) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleReloadPlugin(String product) {", "        try {\n            pluginManagerWrapper.startPluginFromStop(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleStartPluginFromStop) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_START_PLUGIN_FROM_STOP_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleReloadPlugin(String product) {\n        try {\n            pluginManagerWrapper.reloadPlugin(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleReloadPlugin) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleReloadPluginInNewPath(String product, String path) {", "        try {\n            pluginManagerWrapper.reloadPlugin(product);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleReloadPlugin) fail [product: {}, errorCode: {}, errorMsg: {}]\", product, ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR.getErrorCode(), ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_ERROR, e.toString());\n        }\n    }\n\n    private ManageResponse handleReloadPluginInNewPath(String product, String path) {\n        try {\n            pluginManagerWrapper.reloadPlugin(product, path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleReloadPluginInNewPath) fail [product: {}, path: {}, errorCode: {}, errorMsg: {}]\", ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR.getErrorCode(), product, path, ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR, e.toString());\n        }\n    }\n\n    /**\n     * <pre>\n     * return whether the plugins of the products are supported\n     * </pre>\n     */\n    @Override", "        try {\n            pluginManagerWrapper.reloadPlugin(product, path);\n            return ResponseBuilder.buildPluginManageSuccessResp(PluginManageResp.newBuilder());\n        } catch (Exception e){\n            log.error(\"manage(handleReloadPluginInNewPath) fail [product: {}, path: {}, errorCode: {}, errorMsg: {}]\", ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR.getErrorCode(), product, path, ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR.getShortMsg(), e);\n            return ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR, e.toString());\n        }\n    }\n\n    /**\n     * <pre>\n     * return whether the plugins of the products are supported\n     * </pre>\n     */\n    @Override", "    public void hasPlugins(HasPluginsRequest request, StreamObserver<ManageResponse> responseObserver) {\n        responseObserver.onNext(\n                ResponseBuilder.buildHasPluginsResp(\n                        HasPluginsResp.newBuilder()\n                                .putAllResults(\n                                        request.getProductsList().stream()\n                                                .distinct()\n                                                .collect(Collectors.toMap(p -> p, p -> pluginManagerWrapper.hasPlugin(p)))\n                                )\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    /**\n     * <pre>\n     * return all supported plugin products\n     * </pre>\n     */\n    @Override", "    public void allPlugins(AllPluginsRequest request, StreamObserver<ManageResponse> responseObserver) {\n        responseObserver.onNext(\n                ResponseBuilder.buildAllPluginsResp(\n                        AllPluginsResp.newBuilder().addAllProducts(pluginManagerWrapper.allSupportProducts().stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()))\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    /**\n     * <pre>\n     * return whether the chains of the domains are running\n     * </pre>\n     */\n    @Override", "    public void hasDomains(HasDomainsRequest request, StreamObserver<ManageResponse> responseObserver) {\n        responseObserver.onNext(ResponseBuilder.buildHasDomainsResp(HasDomainsResp.newBuilder()\n                        .putAllResults(request.getDomainsList().stream().distinct().collect(Collectors.toMap(d -> d, d -> pluginManagerWrapper.hasDomain(d))))\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    /**\n     * <pre>\n     * return domains of all running chains\n     * </pre>\n     */\n    @Override", "    public void allDomains(AllDomainsRequest request, StreamObserver<ManageResponse> responseObserver) {\n        responseObserver.onNext(\n                ResponseBuilder.buildAllDomainsResp(\n                        AllDomainsResp.newBuilder().addAllDomains(pluginManagerWrapper.allRunningDomains().stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()))\n                )\n        );\n        responseObserver.onCompleted();\n    }\n\n    @Override\n    public void restartBBC(RestartBBCRequest request, StreamObserver<ManageResponse> responseObserver) {", "    public void restartBBC(RestartBBCRequest request, StreamObserver<ManageResponse> responseObserver) {\n        if (!pluginManagerWrapper.hasPlugin(request.getProduct())) {\n            responseObserver.onNext(\n                    ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"product not found\")\n            );\n            responseObserver.onCompleted();\n            return;\n        }\n        if (!pluginManagerWrapper.hasDomain(request.getDomain())) {\n            responseObserver.onNext(\n                    ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"domain not found\")\n            );\n            responseObserver.onCompleted();\n            return;\n        }", "        if (!pluginManagerWrapper.hasDomain(request.getDomain())) {\n            responseObserver.onNext(\n                    ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"domain not found\")\n            );\n            responseObserver.onCompleted();\n            return;\n        }\n        try {\n            IBBCService oldBbcService = pluginManagerWrapper.getBBCService(request.getProduct(), request.getDomain());\n            if (ObjectUtil.isNull(oldBbcService)) {\n                throw new RuntimeException(\"null BBC service for domain \" + request.getDomain());\n            }\n            IBBCService newBbcService = pluginManagerWrapper.createBBCService(request.getProduct(), request.getDomain());\n            newBbcService.startup(oldBbcService.getContext());\n        } catch (Exception e) {\n            log.error(\"restartBBC fail [errorCode: {}, errorMsg: {}]\",\n                    ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR.getErrorCode(),\n                    ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR.getShortMsg(), e);\n            responseObserver.onNext(\n                    ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"UNKNOWN\")\n            );\n            responseObserver.onCompleted();\n            return;\n        }\n        responseObserver.onNext(\n                ResponseBuilder.buildRestartBBCResp(RestartBBCResp.newBuilder())\n        );\n        responseObserver.onCompleted();\n    }\n}\n", "            if (ObjectUtil.isNull(oldBbcService)) {\n                throw new RuntimeException(\"null BBC service for domain \" + request.getDomain());\n            }\n            IBBCService newBbcService = pluginManagerWrapper.createBBCService(request.getProduct(), request.getDomain());\n            newBbcService.startup(oldBbcService.getContext());\n        } catch (Exception e) {\n            log.error(\"restartBBC fail [errorCode: {}, errorMsg: {}]\",\n                    ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR.getErrorCode(),\n                    ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR.getShortMsg(), e);\n            responseObserver.onNext(\n                    ResponseBuilder.buildFailManageResp(ServerErrorCodeEnum.MANAGE_RESTART_BBC_ERROR, \"UNKNOWN\")\n            );\n            responseObserver.onCompleted();\n            return;\n        }\n        responseObserver.onNext(\n                ResponseBuilder.buildRestartBBCResp(RestartBBCResp.newBuilder())\n        );\n        responseObserver.onCompleted();\n    }\n}\n"]}
{"filename": "ps-server/src/main/java/com/alipay/antchain/bridge/pluginserver/server/exception/ServerErrorCodeEnum.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.server.exception;\n", "package com.alipay.antchain.bridge.pluginserver.server.exception;\n\nimport lombok.Getter;\n\n@Getter\npublic enum ServerErrorCodeEnum {\n    // TODO: add element when you need\n\n    SUCCESS(0, \"success\"),\n\n    UNSUPPORT_BBC_REQUEST_ERROR(200, \"unsupport bbc request type\"),\n\n    BBC_GET_SERVICE_ERROR(201, \"[bbc] get service failed\"),\n\n    BBC_CREATE_ERROR(202, \"[bbc] create service failed\"),\n\n    BBC_STARTUP_ERROR(203, \"[bbc] start up failed\"),\n\n    BBC_SHUTDOWN_ERROR(204, \"[bbc] shut down failed\"),\n\n    BBC_GETCONTEXT_ERROR(205, \"[bbc] get context failed\"),\n\n    BBC_SETUPSDPMESSAGECONTRACT_ERROR(206, \"[bbc] set up sdp contract failed\"),\n\n    BBC_SETUPAUTHMESSAGECONTRACT_ERROR(207, \"[bbc] set up am contract failed\"),\n\n    BBC_SETPROTOCOL_ERROR(208, \"[bbc] set protocol failed\"),\n\n    BBC_SETAMCONTRACT_ERROR(209, \"[bbc] set am contract failed\"),\n\n    BBC_ADDVALIDRELAYER_ERROR(210, \"[bbc] add valid relayer failed\"),\n\n    BBC_RELAYAUTHMESSAGE_ERROR(211, \"[bbc] forward relayer auth msg failed\"),\n\n    BBC_READ_CCMSG_RET_ERROR(212, \"[bbc] read cross chain msg receipt failed\"),\n\n    BBC_READCROSSCHAINMESSAGESBYHEIGHT_ERROR(213, \"[bbc] read cross chain msg by height failed\"),\n\n    BBC_QUERYSDPMESSAGESEQ_ERROR(214, \"[bbc] query sdp msg sequence failed\"),\n\n    BBC_QUERYLATESTHEIGHT_ERROR(215, \"[bbc] query latest height failed\"),\n\n    BBC_SETLOCALDOMAIN_ERROR(216, \"[bbc] set local domain failed\"),\n\n    BBC_OBJECT_NOT_STARTED(217, \"[bbc] none bbc object started\"),\n\n    BBC_PLUGIN_NOT_SUPPORT(218, \"[bbc] none plugin found\"),\n\n    UNSUPPORT_MANAGE_REQUEST_ERROR(300, \"unsupport manage request type\"),\n\n    MANAGE_LOAD_PLUGINS_ERROR(301, \"[manage] load plugins failed\"),\n\n    MANAGE_START_PLUGINS_ERROR(302, \"[manage] start plugins failed\"),\n\n    MANAGE_LOAD_PLUGIN_ERROR(303, \"[manage] load plugin in the specified path failed\"),\n\n    MANAGE_START_PLUGIN_ERROR(304, \"[manage] start plugin in the specified path failed\"),\n\n    MANAGE_STOP_PLUGIN_ERROR(305, \"[manage] stop plugin of specified product failed\"),\n\n    MANAGE_START_PLUGIN_FROM_STOP_ERROR(306, \"[manage] start plugin of specified product from stop failed\"),\n\n    MANAGE_RELOAD_PLUGIN_ERROR(307, \"[manage] reload plugin failed\"),\n\n    MANAGE_RELOAD_PLUGIN_IN_NEW_PATH_ERROR(308, \"[manage] reload plugin in new path failed\"),\n\n    MANAGE_RESTART_BBC_ERROR(309, \"[manage] restart bbc failed\"),\n\n    UNKNOWN_ERROR(100, \"unknow error\");\n\n    /**\n     * Error code for errors happened in project {@code antchain-bridge-pluginserver}\n     */\n    private final int errorCode;\n\n    /**\n     * Every code has a short message to describe the error stuff\n     */\n    private final String shortMsg;\n\n    ServerErrorCodeEnum(int errorCode, String shortMsg) {\n        this.errorCode = errorCode;\n        this.shortMsg = shortMsg;\n    }\n}\n"]}
{"filename": "ps-pluginmanager/src/main/java/com/alipay/antchain/bridge/pluginserver/pluginmanager/PluginManagerWrapperImpl.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.pluginmanager;\n", "package com.alipay.antchain.bridge.pluginserver.pluginmanager;\n\nimport cn.hutool.core.util.ObjectUtil;\nimport com.alipay.antchain.bridge.commons.core.base.CrossChainDomain;\nimport com.alipay.antchain.bridge.plugins.manager.AntChainBridgePluginManagerFactory;\nimport com.alipay.antchain.bridge.plugins.manager.core.IAntChainBridgePlugin;\nimport com.alipay.antchain.bridge.plugins.manager.core.IAntChainBridgePluginManager;\nimport com.alipay.antchain.bridge.plugins.spi.bbc.IBBCService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.ClassLoadingStrategy;", "import lombok.extern.slf4j.Slf4j;\nimport org.pf4j.ClassLoadingStrategy;\n\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n", "import java.util.stream.Collectors;\n\n@Slf4j\npublic class PluginManagerWrapperImpl implements IPluginManagerWrapper {\n\n    private final IAntChainBridgePluginManager manager;\n\n    public PluginManagerWrapperImpl(String path, Map<ClassLoadingStrategy.Source, Set<String>> pathPrefixBannedMap) {\n        log.info(\"plugins path: {}\", Paths.get(path).toAbsolutePath());\n        manager = AntChainBridgePluginManagerFactory.createPluginManager(path, ObjectUtil.defaultIfNull(pathPrefixBannedMap, new HashMap<>()));\n        loadPlugins();\n        startPlugins();\n    }\n\n    @Override", "    public void loadPlugins() {\n        manager.loadPlugins();\n    }\n\n    @Override\n    public void startPlugins() {\n        manager.startPlugins();\n    }\n\n    @Override\n    public void loadPlugin(String path) {\n        manager.loadPlugin(Paths.get(path));\n    }\n\n    @Override", "    public void loadPlugin(String path) {\n        manager.loadPlugin(Paths.get(path));\n    }\n\n    @Override\n    public void startPlugin(String path) {\n        manager.startPlugin(Paths.get(path));\n    }\n\n    @Override\n    public void stopPlugin(String product) {\n        manager.stopPlugin(product);\n    }\n\n    @Override", "    public void stopPlugin(String product) {\n        manager.stopPlugin(product);\n    }\n\n    @Override\n    public void startPluginFromStop(String product) {\n        manager.startPluginFromStop(product);\n    }\n\n    @Override\n    public void reloadPlugin(String product) {\n        manager.reloadPlugin(product);\n    }\n\n    @Override", "    public void reloadPlugin(String product) {\n        manager.reloadPlugin(product);\n    }\n\n    @Override\n    public void reloadPlugin(String product, String path) {\n        manager.reloadPlugin(product, Paths.get(path));\n    }\n\n    @Override\n    public IAntChainBridgePlugin getPlugin(String product) {\n        return manager.getPlugin(product);\n    }\n\n    @Override", "    public IAntChainBridgePlugin getPlugin(String product) {\n        return manager.getPlugin(product);\n    }\n\n    @Override\n    public boolean hasPlugin(String product) {\n        return manager.hasPlugin(product);\n    }\n\n    @Override\n    public List<String> allSupportProducts() {\n        return manager.allSupportProducts();\n    }\n\n    @Override", "    public IBBCService createBBCService(String product, String domain) {\n        return manager.createBBCService(product, new CrossChainDomain(domain));\n    }\n\n    @Override\n    public IBBCService getBBCService(String product, String domain) {\n        return manager.getBBCService(product, new CrossChainDomain(domain));\n    }\n\n    @Override\n    public boolean hasDomain(String domain) {\n        return manager.hasDomain(new CrossChainDomain(domain));\n    }\n\n    @Override\n    public List<String> allRunningDomains() {\n        return manager.allRunningDomains().stream().map(CrossChainDomain::toString).collect(Collectors.toList());\n    }\n}\n", "    public boolean hasDomain(String domain) {\n        return manager.hasDomain(new CrossChainDomain(domain));\n    }\n\n    @Override\n    public List<String> allRunningDomains() {\n        return manager.allRunningDomains().stream().map(CrossChainDomain::toString).collect(Collectors.toList());\n    }\n}\n"]}
{"filename": "ps-pluginmanager/src/main/java/com/alipay/antchain/bridge/pluginserver/pluginmanager/IPluginManagerWrapper.java", "chunked_list": ["/*\n * Copyright 2023 Ant Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alipay.antchain.bridge.pluginserver.pluginmanager;\n", "package com.alipay.antchain.bridge.pluginserver.pluginmanager;\n\nimport com.alipay.antchain.bridge.plugins.manager.core.IAntChainBridgePlugin;\nimport com.alipay.antchain.bridge.plugins.spi.bbc.IBBCService;\n\nimport java.util.List;\n\npublic interface IPluginManagerWrapper {\n    void loadPlugins();\n\n    void startPlugins();\n\n    void loadPlugin(String path);\n\n    void startPlugin(String path);\n\n    void stopPlugin(String product);\n\n    void startPluginFromStop(String product);\n\n    void reloadPlugin(String product);\n\n    void reloadPlugin(String product, String path);\n\n    IAntChainBridgePlugin getPlugin(String product);\n\n    boolean hasPlugin(String product);\n\n    List<String> allSupportProducts();\n\n    IBBCService createBBCService(String product, String domain);\n\n    IBBCService getBBCService(String product, String domain);\n\n    boolean hasDomain(String domain);\n\n    List<String> allRunningDomains();\n\n}\n"]}
