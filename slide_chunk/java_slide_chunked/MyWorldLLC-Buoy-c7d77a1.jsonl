{"filename": "lib/src/test/java/com/myworldvw/buoy/ArrayTest.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport com.myworldvw.buoy.util.InnerT;\nimport com.myworldvw.buoy.util.TestUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.foreign.SegmentScope;\nimport java.lang.foreign.ValueLayout;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;", "\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ArrayTest {\n\n    @Test\n    void getArrayElements() throws Throwable {\n\n        // ====== Setup ======\n        var array = TestUtil.makeInnerTArray();\n        var mapper = new NativeMapper(TestUtil.testLib);\n        mapper.register(InnerT.class);\n\n        var first = array.get(0, new InnerT(), mapper);\n        var second = array.get(1, new InnerT(), mapper);\n        var third = array.get(2, new InnerT(), mapper);\n\n\n        // ====== Assertions ======\n        assertEquals(3, array.length());\n\n        assertEquals(11, first.getInnerA());\n        assertEquals(22, first.getInnerB());\n\n        assertEquals(33, second.getInnerA());\n        assertEquals(44, second.getInnerB());\n\n        assertEquals(55, third.getInnerA());\n        assertEquals(66, third.getInnerB());\n    }\n\n    @Test\n    void setArrayElementFields() throws Throwable {\n\n        // ====== Setup ======\n        var array = TestUtil.makeInnerTArray();\n        var mapper = new NativeMapper(TestUtil.testLib);\n        mapper.register(InnerT.class);\n\n        var first = array.get(0, new InnerT(), mapper);\n        var second = array.get(1, new InnerT(), mapper);\n        var third = array.get(2, new InnerT(), mapper);\n\n        second.setInnerB(77);\n\n        // ====== Assertions ======\n        assertEquals(11, first.getInnerA());\n        assertEquals(22, first.getInnerB());\n\n        assertEquals(33, second.getInnerA());\n        assertEquals(77, second.getInnerB());\n\n        assertEquals(55, third.getInnerA());\n        assertEquals(66, third.getInnerB());\n    }\n\n    @Test\n    void setPrimitiveArrayElements(){\n\n        // ====== Setup ======\n        var array = Platform.allocate(ValueLayout.JAVA_INT, 3, SegmentScope.global());\n        Array.setInt(array, 0, 0xAA);\n        Array.setInt(array, 1, 0xBB);\n        Array.setInt(array, 2, 0xCC);\n\n        // ====== Assertions ======\n        assertEquals(0xAA, Array.getInt(array, 0));\n        assertEquals(0xBB, Array.getInt(array, 1));\n        assertEquals(0xCC, Array.getInt(array, 2));\n\n    }\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/StructLayoutTest.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport com.myworldvw.buoy.util.InnerT;\nimport com.myworldvw.buoy.util.TestUtil;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class StructLayoutTest {\n\n    @Test\n    void mapStructFields() throws Throwable {\n\n        var numbers = TestUtil.makeNumbersT();\n        numbers.set((short)1, 2);\n\n        assertEquals(3, numbers.addShort());\n        assertEquals(3, numbers.addNumbersT());\n    }\n\n    @Test\n    void mapModelsToInlineAndStructPointers() throws Throwable {\n\n        // ====== Setup ======\n        var outer = TestUtil.makeOuterT();\n        var mapper = TestUtil.makeMapper();\n\n        var first = outer.getNestedArray().get(0, new InnerT(), mapper);\n        var second = outer.getNestedArray().get(1, new InnerT(), mapper);\n        var third = outer.getNestedArray().get(2, new InnerT(), mapper);\n\n        // ====== Assertions ======\n        assertEquals(123, outer.getOuterA());\n\n        assertEquals(45, outer.getNested().getInnerA());\n        assertEquals(67, outer.getNested().getInnerB());\n\n        assertEquals(11, first.getInnerA());\n        assertEquals(22, first.getInnerB());\n\n        assertEquals(33, second.getInnerA());\n        assertEquals(44, second.getInnerB());\n\n        assertEquals(55, third.getInnerA());\n        assertEquals(66, third.getInnerB());\n\n        assertEquals(89, outer.getNestedPtr().getInnerA());\n        assertEquals(10, outer.getNestedPtr().getInnerB());\n    }\n}\n", "public class StructLayoutTest {\n\n    @Test\n    void mapStructFields() throws Throwable {\n\n        var numbers = TestUtil.makeNumbersT();\n        numbers.set((short)1, 2);\n\n        assertEquals(3, numbers.addShort());\n        assertEquals(3, numbers.addNumbersT());\n    }\n\n    @Test\n    void mapModelsToInlineAndStructPointers() throws Throwable {\n\n        // ====== Setup ======\n        var outer = TestUtil.makeOuterT();\n        var mapper = TestUtil.makeMapper();\n\n        var first = outer.getNestedArray().get(0, new InnerT(), mapper);\n        var second = outer.getNestedArray().get(1, new InnerT(), mapper);\n        var third = outer.getNestedArray().get(2, new InnerT(), mapper);\n\n        // ====== Assertions ======\n        assertEquals(123, outer.getOuterA());\n\n        assertEquals(45, outer.getNested().getInnerA());\n        assertEquals(67, outer.getNested().getInnerB());\n\n        assertEquals(11, first.getInnerA());\n        assertEquals(22, first.getInnerB());\n\n        assertEquals(33, second.getInnerA());\n        assertEquals(44, second.getInnerB());\n\n        assertEquals(55, third.getInnerA());\n        assertEquals(66, third.getInnerB());\n\n        assertEquals(89, outer.getNestedPtr().getInnerA());\n        assertEquals(10, outer.getNestedPtr().getInnerB());\n    }\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/GlobalLinkageTest.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport com.myworldvw.buoy.util.Globals;\nimport com.myworldvw.buoy.util.TestUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.foreign.ValueLayout;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;", "\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\n\npublic class GlobalLinkageTest {\n\n    @Test\n    void linkToGlobalField() throws Throwable {\n\n        var globals = TestUtil.makeGlobals();\n\n        assertNotEquals(MemorySegment.NULL, Globals.error);\n        assertEquals(globals.getErrorAddress().address(), Globals.error.address());\n\n    }\n\n    @Test\n    void getAndSetGlobalField() throws Throwable {\n\n        var globals = TestUtil.makeGlobals();\n        Globals.error.set(ValueLayout.JAVA_INT, 0, 0xFFEB);\n\n        assertEquals(globals.getError(), Globals.error.get(ValueLayout.JAVA_INT, 0));\n        assertEquals(0xFFEB, globals.getError());\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/FunctionLinkageTest.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport com.myworldvw.buoy.util.Statics;\nimport com.myworldvw.buoy.util.TestFunctionHandles;\nimport com.myworldvw.buoy.util.TestUtil;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FunctionLinkageTest {\n\n    @Test\n    void succeedsMappingFunctionHandles(){\n\n        assertDoesNotThrow(TestUtil::makeFunctionHandles);\n\n    }\n\n    @Test\n    void mapsAddIntegers() throws Throwable {\n\n        var functions = TestUtil.makeFunctionHandles();\n\n        assertNotNull(functions.add);\n        assertEquals(3, functions.add(1, 2));\n\n    }\n\n    @Test\n    void fillsStaticFieldsInStaticUseContext() throws IllegalAccessException {\n\n        TestUtil.fillStatics();\n\n        assertNotNull(Statics.staticAdd);\n\n    }\n\n    @Test\n    void doesNotFillStaticFieldsInInstanceUseContext() throws IllegalAccessException {\n\n        TestUtil.makeFunctionHandles();\n\n        assertNull(TestFunctionHandles.unused);\n    }\n\n}\n", "\npublic class FunctionLinkageTest {\n\n    @Test\n    void succeedsMappingFunctionHandles(){\n\n        assertDoesNotThrow(TestUtil::makeFunctionHandles);\n\n    }\n\n    @Test\n    void mapsAddIntegers() throws Throwable {\n\n        var functions = TestUtil.makeFunctionHandles();\n\n        assertNotNull(functions.add);\n        assertEquals(3, functions.add(1, 2));\n\n    }\n\n    @Test\n    void fillsStaticFieldsInStaticUseContext() throws IllegalAccessException {\n\n        TestUtil.fillStatics();\n\n        assertNotNull(Statics.staticAdd);\n\n    }\n\n    @Test\n    void doesNotFillStaticFieldsInInstanceUseContext() throws IllegalAccessException {\n\n        TestUtil.makeFunctionHandles();\n\n        assertNull(TestFunctionHandles.unused);\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/TestFunctionHandles.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.FunctionHandle;\n\nimport java.lang.invoke.MethodHandle;\n\npublic class TestFunctionHandles {\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})\n    public MethodHandle add;\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})", "    public MethodHandle add;\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})\n    public static MethodHandle unused;\n\n    public int add(int a, int b) throws Throwable {\n        return (int) add.invokeExact(a, b);\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/TestUtil.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.Array;\nimport com.myworldvw.buoy.NativeMapper;\nimport com.myworldvw.buoy.Platform;\n\nimport java.lang.foreign.SegmentAllocator;\nimport java.lang.foreign.SegmentScope;\nimport java.lang.foreign.SymbolLookup;\nimport java.nio.file.Path;", "import java.lang.foreign.SymbolLookup;\nimport java.nio.file.Path;\n\npublic class TestUtil {\n\n    public static final SymbolLookup testLib = Platform.loadLibrary(Path.of(System.getProperty(\"buoy.test.lib.path\") + \"/\" + Platform.standardLibraryName(\"native\")), SegmentScope.global());\n\n    public static NativeMapper makeMapper(){\n        return new NativeMapper(testLib)\n                .register(OuterT.class)\n                .register(TestFunctionHandles.class)\n                .register(Globals.class)\n                .register(NumbersT.class)\n                .register(Statics.class);\n    }\n", "    public static TestFunctionHandles makeFunctionHandles() throws IllegalAccessException {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(TestFunctionHandles.class);\n        return mapper.populateFunctionHandles(new TestFunctionHandles());\n    }\n\n    public static NumbersT makeNumbersT() throws IllegalAccessException {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(NumbersT.class);\n        return mapper.populate(new NumbersT(), Platform.allocate(mapper.getLayout(NumbersT.class), SegmentScope.global()));\n    }\n", "    public static Globals makeGlobals() throws IllegalAccessException {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(Globals.class);\n        mapper.populateStatic(Globals.class);\n        return mapper.populate(new Globals(), null);\n    }\n\n    public static Statics makeStatics() throws IllegalAccessException {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(Statics.class);\n        return mapper.populate(new Statics(), null);\n    }\n", "    public static void fillStatics() throws IllegalAccessException {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(Statics.class);\n        mapper.populateStatic(Statics.class);\n    }\n\n    public static OuterT makeOuterT() throws Throwable {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(OuterT.class);\n        mapper.populateStatic(OuterT.class);\n\n        var innerPtr = mapper.allocate(InnerT.class, SegmentScope.global());\n        return mapper.populate(new OuterT(), OuterT.makeOuterT(Platform.globalAllocator(), innerPtr));\n    }\n", "    public static Array<InnerT> makeInnerTArray() throws Throwable {\n        var mapper = new NativeMapper(testLib);\n        mapper.register(InnerT.class);\n        mapper.populateFunctionHandles(InnerT.class);\n\n        return mapper.arrayOf(InnerT.makeInnerTArray(), InnerT.class, 3, SegmentScope.global());\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/Statics.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.FunctionHandle;\n\nimport java.lang.invoke.MethodHandle;\n\npublic class Statics {\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})\n    public static MethodHandle staticAdd;\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})", "    public static MethodHandle staticAdd;\n\n    @FunctionHandle(name = \"add\", returns = int.class, params = {int.class, int.class})\n    public MethodHandle instanceAdd;\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/OuterT.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.*;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.foreign.SegmentAllocator;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.VarHandle;\n\n@Struct(", "\n@Struct(\n        name = \"outer_t\",\n        fields = {\n                @StructField(name = \"outer_a\", type = byte.class),\n                @StructField(name = \"nested\", type = InnerT.class),\n                @StructField(name = \"nestedArray\", type = InnerT.class, array = 3),\n                @StructField(name = \"nested_ptr\", type = InnerT.class, pointer = true)\n        }\n)\npublic class OuterT {\n\n    @SelfPointer\n    protected MemorySegment self;\n\n    @FieldHandle(name = \"outer_a\")\n    protected VarHandle outerA;\n\n    @FieldHandle(name = \"nested\")\n    protected InnerT nested = new InnerT();\n\n    @FieldHandle(name = \"nestedArray\")\n    protected Array<InnerT> nestedArray;\n\n    @FieldHandle(name = \"nested_ptr\")\n    protected InnerT nestedPtr = new InnerT();\n", "        }\n)\npublic class OuterT {\n\n    @SelfPointer\n    protected MemorySegment self;\n\n    @FieldHandle(name = \"outer_a\")\n    protected VarHandle outerA;\n\n    @FieldHandle(name = \"nested\")\n    protected InnerT nested = new InnerT();\n\n    @FieldHandle(name = \"nestedArray\")\n    protected Array<InnerT> nestedArray;\n\n    @FieldHandle(name = \"nested_ptr\")\n    protected InnerT nestedPtr = new InnerT();\n", "    public byte getOuterA(){\n        return (byte) outerA.get(self);\n    }\n\n    public InnerT getNested(){\n        return nested;\n    }\n\n    public Array<InnerT> getNestedArray(){\n        return nestedArray;\n    }\n", "    public InnerT getNestedPtr(){\n        return nestedPtr;\n    }\n\n    @FunctionHandle(name = \"make_outer_t_value\", returns = OuterT.class, params = {MemorySegment.class})\n    protected static MethodHandle makeOuterTValue;\n\n    public static MemorySegment makeOuterT(SegmentAllocator returnAllocator, MemorySegment innerTPtr) throws Throwable {\n        return (MemorySegment) makeOuterTValue.invokeExact(returnAllocator, innerTPtr);\n    }\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/NumbersT.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.*;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.VarHandle;\n\n@Struct(\n        name = \"numbers_t\",", "@Struct(\n        name = \"numbers_t\",\n        fields = {\n                @StructField(name = \"a\", type = short.class),\n                @StructField(name = \"b\", type = int.class)\n        }\n)\npublic class NumbersT {\n\n    @SelfPointer\n    protected MemorySegment self;\n\n    @FieldHandle(name = \"a\")\n    protected VarHandle a;\n\n    @FieldHandle(name = \"b\")\n    protected VarHandle b;\n\n    @FunctionHandle(name = \"add_short\", returns = int.class, params = {int.class, short.class})\n    protected MethodHandle add_short;\n\n    @FunctionHandle(name = \"add_numbers_t\", returns = int.class, params = { MemorySegment.class })\n    protected MethodHandle add_numbers_t;\n", "    public int addShort() throws Throwable {\n        return (int) add_short.invokeExact((int)b.get(self), (short)a.get(self));\n    }\n\n    public void set(short a, int b){\n        this.a.set(self, a);\n        this.b.set(self, b);\n    }\n\n    public int addNumbersT() throws Throwable {\n        return (int) add_numbers_t.invokeExact(self);\n    }\n\n}\n", "    public int addNumbersT() throws Throwable {\n        return (int) add_numbers_t.invokeExact(self);\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/Globals.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.FunctionHandle;\nimport com.myworldvw.buoy.GlobalHandle;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.invoke.MethodHandle;\n\npublic class Globals {\n\n    @GlobalHandle(name = \"test_error\", type = int.class)", "public class Globals {\n\n    @GlobalHandle(name = \"test_error\", type = int.class)\n    public static MemorySegment error;\n\n    @FunctionHandle(name = \"set_and_get_error\", returns = int.class, params = {int.class})\n    public MethodHandle setAndGetError;\n\n    @FunctionHandle(name = \"get_error\", returns = int.class)\n    public MethodHandle getError;\n\n    @FunctionHandle(name = \"get_error_address\", returns = MemorySegment.class)", "    public MethodHandle getError;\n\n    @FunctionHandle(name = \"get_error_address\", returns = MemorySegment.class)\n    public MethodHandle getErrorAddress;\n\n    public int setAndGetError(int error) throws Throwable {\n        return (int) setAndGetError.invokeExact(error);\n    }\n\n    public int getError() throws Throwable {\n        return (int) getError.invokeExact();\n    }\n", "    public int getError() throws Throwable {\n        return (int) getError.invokeExact();\n    }\n\n    public MemorySegment getErrorAddress() throws Throwable {\n        return (MemorySegment) getErrorAddress.invokeExact();\n    }\n\n}\n"]}
{"filename": "lib/src/test/java/com/myworldvw/buoy/util/InnerT.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.util;\n", "package com.myworldvw.buoy.util;\n\nimport com.myworldvw.buoy.*;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.VarHandle;\n\n@Struct(\n        name = \"inner_t\",", "@Struct(\n        name = \"inner_t\",\n        fields = {\n                @StructField(name = \"a\", type = byte.class),\n                @StructField(name = \"b\", type = int.class)\n        }\n)\npublic class InnerT {\n\n    @FunctionHandle(name = \"make_inner_t_array\", returns = MemorySegment.class)\n    public static MethodHandle makeInnerTArray;\n", "    public static MethodHandle makeInnerTArray;\n\n    public static MemorySegment makeInnerTArray() throws Throwable {\n        return (MemorySegment) makeInnerTArray.invokeExact();\n    }\n\n    @SelfPointer\n    protected MemorySegment self;\n\n    @FieldHandle(name = \"a\")\n    protected VarHandle a;\n\n    @FieldHandle(name = \"b\")\n    protected VarHandle b;\n", "    public byte getInnerA(){\n        return (byte) a.get(self);\n    }\n\n    public int getInnerB(){\n        return (int) b.get(self);\n    }\n\n    public void setInnerB(int value){\n        b.set(self, value);\n    }\n}\n", "    public void setInnerB(int value){\n        b.set(self, value);\n    }\n}\n"]}
{"filename": "lib/src/main/java/module-info.java", "chunked_list": ["module buoy.lib.main {\n    requires java.base;\n\n    opens com.myworldvw.buoy;\n    opens com.myworldvw.buoy.mapping;\n}"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/FunctionHandle.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface FunctionHandle {", "@Target(ElementType.FIELD)\npublic @interface FunctionHandle {\n\n    String name();\n    Class<?> returns() default void.class;\n    Class<?>[] params() default {};\n\n}\n", ""]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/FunctionDef.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.foreign.FunctionDescriptor;\nimport java.lang.foreign.MemoryLayout;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FunctionDef {\n\n    public static Builder create(){\n        return new Builder();\n    }\n", "    public static Builder create(){\n        return new Builder();\n    }\n\n    public static class Builder {\n        protected MemoryLayout retValue;\n        protected List<MemoryLayout> paramValues = new ArrayList<>();\n\n        public Builder withReturn(MemoryLayout layout){\n            retValue = layout;\n            return this;\n        }\n", "        public Builder withReturn(MemoryLayout layout){\n            retValue = layout;\n            return this;\n        }\n\n        public Builder withParam(MemoryLayout layout){\n            paramValues.add(layout);\n            return this;\n        }\n\n        public FunctionDescriptor build(){\n            var params = paramValues.toArray(new MemoryLayout[]{});\n            return retValue == null ?\n                    FunctionDescriptor.ofVoid(params) :\n                    FunctionDescriptor.of(retValue, params);\n        }\n    }\n}\n", "        public FunctionDescriptor build(){\n            var params = paramValues.toArray(new MemoryLayout[]{});\n            return retValue == null ?\n                    FunctionDescriptor.ofVoid(params) :\n                    FunctionDescriptor.of(retValue, params);\n        }\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/Pointer.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.foreign.*;\n\npublic class Pointer {\n\n    public static final long NULL = 0L;\n\n    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType){\n        return MemorySegment.ofAddress(p.address(), targetType.byteSize(), p.scope());\n    }\n", "    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType){\n        return MemorySegment.ofAddress(p.address(), targetType.byteSize(), p.scope());\n    }\n\n    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType, SegmentScope scope){\n        return MemorySegment.ofAddress(p.address(), targetType.byteSize(), scope);\n    }\n\n    public static long getAddress(MemorySegment p){\n        return p.get(ValueLayout.ADDRESS, 0).address();\n    }\n", "    public static long getAddress(MemorySegment p){\n        return p.get(ValueLayout.ADDRESS, 0).address();\n    }\n\n    public static void setAddress(MemorySegment p, long a){\n        p.set(ValueLayout.ADDRESS, 0, MemorySegment.ofAddress(a));\n    }\n\n    public static void setAddress(MemorySegment p, MemorySegment a){\n        p.set(ValueLayout.ADDRESS, 0, a);\n    }\n", "    public static void setAddress(MemorySegment p, MemorySegment a){\n        p.set(ValueLayout.ADDRESS, 0, a);\n    }\n\n    public static boolean getBoolean(MemorySegment p){\n        return p.get(ValueLayout.JAVA_BOOLEAN, 0);\n    }\n\n    public static void setBoolean(MemorySegment p, boolean b){\n        p.set(ValueLayout.JAVA_BOOLEAN, 0, b);\n    }\n", "    public static void setBoolean(MemorySegment p, boolean b){\n        p.set(ValueLayout.JAVA_BOOLEAN, 0, b);\n    }\n\n    public static byte getByte(MemorySegment p){\n        return p.get(ValueLayout.JAVA_BYTE, 0);\n    }\n\n    public static void setByte(MemorySegment p, byte b){\n        p.set(ValueLayout.JAVA_BYTE, 0, b);\n    }\n", "    public static void setByte(MemorySegment p, byte b){\n        p.set(ValueLayout.JAVA_BYTE, 0, b);\n    }\n\n    public static char getChar(MemorySegment p){\n        return p.get(ValueLayout.JAVA_CHAR, 0);\n    }\n\n    public static void setChar(MemorySegment p, char c){\n        p.set(ValueLayout.JAVA_CHAR, 0, c);\n    }\n", "    public static void setChar(MemorySegment p, char c){\n        p.set(ValueLayout.JAVA_CHAR, 0, c);\n    }\n\n    public static double getDouble(MemorySegment p){\n        return p.get(ValueLayout.JAVA_DOUBLE, 0);\n    }\n\n    public static void setDouble(MemorySegment p, double d){\n        p.set(ValueLayout.JAVA_DOUBLE, 0, d);\n    }\n", "    public static void setDouble(MemorySegment p, double d){\n        p.set(ValueLayout.JAVA_DOUBLE, 0, d);\n    }\n\n    public static float getFloat(MemorySegment p){\n        return p.get(ValueLayout.JAVA_FLOAT, 0);\n    }\n\n    public static void setFloat(MemorySegment p, float f){\n        p.set(ValueLayout.JAVA_FLOAT, 0, f);\n    }\n", "    public static void setFloat(MemorySegment p, float f){\n        p.set(ValueLayout.JAVA_FLOAT, 0, f);\n    }\n\n    public static int getInt(MemorySegment p){\n        return p.get(ValueLayout.JAVA_INT, 0);\n    }\n\n    public static void setInt(MemorySegment p, int i){\n        p.set(ValueLayout.JAVA_INT, 0, i);\n    }\n", "    public static void setInt(MemorySegment p, int i){\n        p.set(ValueLayout.JAVA_INT, 0, i);\n    }\n\n    public static long getLong(MemorySegment p){\n        return p.get(ValueLayout.JAVA_LONG, 0);\n    }\n\n    public static void setLong(MemorySegment p, long l){\n        p.set(ValueLayout.JAVA_LONG, 0, l);\n    }\n", "    public static void setLong(MemorySegment p, long l){\n        p.set(ValueLayout.JAVA_LONG, 0, l);\n    }\n\n    public static short getShort(MemorySegment p){\n        return p.get(ValueLayout.JAVA_SHORT, 0);\n    }\n\n    public static void setShort(MemorySegment p, short s){\n        p.set(ValueLayout.JAVA_SHORT, 0, s);\n    }\n}\n", "    public static void setShort(MemorySegment p, short s){\n        p.set(ValueLayout.JAVA_SHORT, 0, s);\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/FieldDef.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n\npublic record FieldDef(int index, String name, Class<?> type, boolean isPointer, long array) {\n\n    public FieldDef{", "package com.myworldvw.buoy;\n\npublic record FieldDef(int index, String name, Class<?> type, boolean isPointer, long array) {\n\n    public FieldDef{\n        if(array < 0){\n            throw new IllegalArgumentException(\"Array parameter must be >= 0: \" + array);\n        }\n    }\n\n    FieldDef(int index, String name, Class<?> type){\n        this(index, name, type, false, 0);\n    }\n", "    public boolean isArray(){\n        return array > 0;\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/package-info.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This package defines the primary public API for Buoy.\n */\npackage com.myworldvw.buoy;", "/**\n * This package defines the primary public API for Buoy.\n */\npackage com.myworldvw.buoy;"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/NativeMapper.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport com.myworldvw.buoy.mapping.*;\n\nimport java.lang.foreign.*;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;", "import java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\npublic class NativeMapper {\n\n    protected final SymbolLookup lookup;\n    protected final Platform.Architecture architecture;\n\n    protected final Map<Class<?>, ObjectHandlers<?>> objectHandlers;\n\n    protected final Map<String, StructDef> structs;\n\n    protected final Map<Class<?>, MemoryLayout> layouts;\n\n    protected final Map<String, MethodHandle> cachedFunctionHandles;\n\n    public NativeMapper(){\n        this(Linker.nativeLinker().defaultLookup());\n    }\n\n    public NativeMapper(SymbolLookup lookup){\n        this.lookup = lookup;\n\n        objectHandlers = new HashMap<>();\n\n        structs = new HashMap<>();\n\n        layouts = new HashMap<>();\n        layouts.put(byte.class, ValueLayout.JAVA_BYTE);\n        layouts.put(boolean.class, ValueLayout.JAVA_BOOLEAN);\n        layouts.put(char.class, ValueLayout.JAVA_CHAR);\n        layouts.put(double.class, ValueLayout.JAVA_DOUBLE);\n        layouts.put(float.class, ValueLayout.JAVA_FLOAT);\n        layouts.put(int.class, ValueLayout.JAVA_INT);\n        layouts.put(long.class, ValueLayout.JAVA_LONG);\n        layouts.put(short.class, ValueLayout.JAVA_SHORT);\n        layouts.put(MemorySegment.class, ValueLayout.ADDRESS);\n\n        cachedFunctionHandles = new HashMap<>();\n\n        architecture = Platform.detectArchitecture();\n    }\n", "    public SymbolLookup getLookup(){\n        return lookup;\n    }\n\n    public void defineStruct(StructDef model){\n        if(structs.containsKey(model.name())){\n            throw new IllegalStateException(\"Struct %s is already defined\".formatted(model.name()));\n        }\n        structs.put(model.name(), model);\n    }\n\n    protected Struct getStructAnnotation(Class<?> type){\n        var annotation = type.getAnnotation(Struct.class);", "        if(annotation == null){\n            throw new IllegalArgumentException(\"Class %s is not annotated with @CStruct\".formatted(type.getName()));\n        }\n        return annotation;\n    }\n\n    public boolean isStructType(Class<?> type){\n        return type.getAnnotation(Struct.class) != null;\n    }\n\n    public String getStructName(Class<?> type){\n        return getStructAnnotation(type).name();\n    }\n", "    public String getStructName(Class<?> type){\n        return getStructAnnotation(type).name();\n    }\n\n    public StructDef getStruct(Class<?> type){\n        return structs.get(getStructAnnotation(type).name());\n    }\n\n    public StructDef getStruct(String name){\n        return structs.get(name);\n    }\n", "    public StructDef getStruct(String name){\n        return structs.get(name);\n    }\n\n    public boolean isStructDefined(String name){\n        return structs.containsKey(name);\n    }\n\n    public StructDef getOrDefineStruct(Class<?> type){\n        var struct = getStructAnnotation(type);\n        return structs.computeIfAbsent(struct.name(), (t) -> {\n\n            var builder = StructDef.create(struct.name(), struct.packed());", "    public StructDef getOrDefineStruct(Class<?> type){\n        var struct = getStructAnnotation(type);\n        return structs.computeIfAbsent(struct.name(), (t) -> {\n\n            var builder = StructDef.create(struct.name(), struct.packed());\n            for (int i = 0; i < struct.fields().length; i++) {\n                var field = struct.fields()[i];\n                builder.with(new FieldDef(i, field.name(), field.type(), field.pointer(), field.array()));\n            }\n\n            return builder.build();\n        });\n    }\n", "    public MemoryLayout getArrayLayout(Class<?> targetType, long length){\n        var layout = getLayout(targetType);\n        return getArrayLayout(layout, length);\n    }\n\n    public MemoryLayout getArrayLayout(MemoryLayout elementLayout, long length){\n        return MemoryLayout.sequenceLayout(length, elementLayout);\n    }\n\n    public MemoryLayout getLayout(FieldDef field){\n        var layout = getLayout(field.isPointer() ? MemorySegment.class : field.type());\n        return field.isArray() ? getArrayLayout(layout, field.array()) : layout;\n    }\n", "    public MemoryLayout getLayout(FieldDef field){\n        var layout = getLayout(field.isPointer() ? MemorySegment.class : field.type());\n        return field.isArray() ? getArrayLayout(layout, field.array()) : layout;\n    }\n\n    public MemoryLayout getLayout(Class<?> targetType){\n        var layout = layouts.get(targetType);\n        if(layout == null){\n            var structAnnotation = getStructAnnotation(targetType);\n            var structDef = structs.get(structAnnotation.name());\n            if(structDef == null){\n                throw new IllegalStateException(\"No struct definition found for class \" + targetType.getName());\n            }\n            layout = calculateLayout(structDef);\n            layouts.put(targetType, layout);\n        }\n        return layout;\n    }\n", "            if(structDef == null){\n                throw new IllegalStateException(\"No struct definition found for class \" + targetType.getName());\n            }\n            layout = calculateLayout(structDef);\n            layouts.put(targetType, layout);\n        }\n        return layout;\n    }\n\n    public MethodHandle getOrDefineFunction(String name, FunctionDescriptor functionDesc){\n        return cachedFunctionHandles.computeIfAbsent(name, (n) -> {\n            var fPtr = lookup.find(name)\n                    .orElseThrow(() -> new IllegalArgumentException(\"Function not found: \" + name));\n\n            return Linker.nativeLinker().downcallHandle(fPtr, functionDesc);\n        });\n    }\n", "    public MethodHandle getOrDefineFunction(String name, FunctionDescriptor functionDesc){\n        return cachedFunctionHandles.computeIfAbsent(name, (n) -> {\n            var fPtr = lookup.find(name)\n                    .orElseThrow(() -> new IllegalArgumentException(\"Function not found: \" + name));\n\n            return Linker.nativeLinker().downcallHandle(fPtr, functionDesc);\n        });\n    }\n\n    public boolean isFunctionDefined(String name){\n        return cachedFunctionHandles.containsKey(name);\n    }\n", "    public boolean isFunctionDefined(String name){\n        return cachedFunctionHandles.containsKey(name);\n    }\n\n    public MethodHandle getFunction(String name){\n        var handle = cachedFunctionHandles.get(name);\n        if(handle == null){\n            throw new IllegalArgumentException(\"Function has not been mapped: \" + name);\n        }\n\n        return handle;\n    }\n", "    public MemorySegment getGlobalSymbol(String name, Class<?> type){\n        return getGlobalSymbol(name, type, null);\n    }\n\n    public MemorySegment getGlobalSymbol(String name, Class<?> type, SegmentScope scope){\n        return lookup.find(name)\n                .map(symbol -> MemorySegment.ofAddress(\n                        symbol.address(),\n                        sizeOf(type),\n                        scope != null ? scope : SegmentScope.auto()\n                ))\n                .orElseThrow(() -> new IllegalArgumentException(\"Symbol \" + name + \" not found\"));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> ObjectHandlers<T> getHandlers(T target){\n        return target instanceof Class ?\n                (ObjectHandlers<T>) objectHandlers.get(target) :\n                (ObjectHandlers<T>) objectHandlers.get(target.getClass());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T populateStructFieldHandles(T target, MemorySegment segment) throws IllegalAccessException {\n        var handlers = getHandlers(target);", "        for(var handler : handlers.structFieldHandlers()){\n            handler.handle(this, segment, target);\n        }\n        return target;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T populateFunctionHandles(T target) throws IllegalAccessException {\n        var handlers = getHandlers(target);\n        for(var handler : handlers.functionHandlers()){\n            handler.handle(this, target);\n        }\n        return target;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T populateGlobals(T target) throws IllegalAccessException {\n        var handlers = getHandlers(target);", "        for(var handler : handlers.functionHandlers()){\n            handler.handle(this, target);\n        }\n        return target;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T populateGlobals(T target) throws IllegalAccessException {\n        var handlers = getHandlers(target);\n        for(var handler : handlers.globalHandlers()){\n            handler.handle(this, null, target);\n        }\n        return target;\n    }\n\n    public <T> T populate(T target, MemorySegment segment) throws IllegalAccessException {\n        populateStructFieldHandles(target, segment);\n        populateFunctionHandles(target);\n        populateGlobals(target);\n        return target;\n    }\n", "        for(var handler : handlers.globalHandlers()){\n            handler.handle(this, null, target);\n        }\n        return target;\n    }\n\n    public <T> T populate(T target, MemorySegment segment) throws IllegalAccessException {\n        populateStructFieldHandles(target, segment);\n        populateFunctionHandles(target);\n        populateGlobals(target);\n        return target;\n    }\n", "    public NativeMapper populateStatic(Class<?> target) throws IllegalAccessException {\n        populate(target, null);\n        return this;\n    }\n\n    public long sizeOf(FieldDef field){\n        return field.isPointer() ? sizeOf(MemorySegment.class) : sizeOf(field.type());\n    }\n\n    public long sizeOf(Class<?> type){\n        if(type.equals(void.class)){\n            return 0;\n        }\n        return layoutFor(type).byteSize();\n    }\n", "    public long sizeOf(Class<?> type){\n        if(type.equals(void.class)){\n            return 0;\n        }\n        return layoutFor(type).byteSize();\n    }\n\n    public MemorySegment allocate(Class<?> type, SegmentScope scope){\n        return Platform.allocate(getLayout(type), scope);\n    }\n\n    public <T> Array<T> arrayOf(MemorySegment array, Class<T> type, long length, SegmentScope scope){\n        return arrayOf(array, type, false, length, scope);\n    }\n\n    public <T> Array<T> arrayOf(MemorySegment array, Class<T> type, boolean isPointer, long length, SegmentScope scope){\n        var segment = Array.cast(array, getLayout(type), length, scope);\n        return arrayOf(segment, type, isPointer);\n    }\n\n    public <T> Array<T> arrayOf(MemorySegment array, Class<T> type){\n        return arrayOf(array, type, false);\n    }\n\n    public <T> Array<T> arrayOf(MemorySegment array, Class<T> type, boolean isPointer){\n        return new Array<>(array, getLayout(type), type, isPointer);\n    }\n\n\n    public <T> MemoryLayout layoutFor(Class<T> c){\n        return layouts.computeIfAbsent(c, (t) -> {\n            // Primitive types are already defined in layouts\n            return calculateLayout(getOrDefineStruct(c));\n        });\n    }\n", "    public MemoryLayout calculateLayout(StructDef def) {\n        var structSize = 0;\n        MemoryLayout largestElement = null;\n\n        var layouts = new ArrayList<>();\n\n        for(int i = 0; i < def.fields().length; i++){\n            var field = def.fields()[i];\n            var layout = getLayout(field).withName(field.name());\n\n            // Track largest element so that we can set\n            // end padding of the struct accordingly", "            if(largestElement == null || largestElement.bitSize() < layout.bitSize()){\n                largestElement = layout;\n            }\n\n            if(!def.isPacked()){\n                var padding = makePadding(structSize, layout);\n                if(padding != null){\n                    layouts.add(padding);\n                    structSize += padding.bitSize();\n                }\n            }\n\n            layouts.add(layout);\n            structSize += layout.bitSize();\n\n        }\n", "        if(!def.isPacked() && largestElement != null){\n            // End padding is based on largest element alignment requirements\n            var padding = makePadding(structSize, largestElement);\n            if(padding != null){\n                layouts.add(padding);\n            }\n        }\n\n        return MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[]{})).withName(def.name());\n    }\n", "    public MemoryLayout makePadding(long structSize, MemoryLayout element){\n        if(structSize == 0){\n            return null; // Struct has no elements yet, so we don't need padding\n        }\n        var remainder = structSize % element.bitAlignment();\n        return remainder != 0 ? MemoryLayout.paddingLayout(element.bitAlignment() - remainder) : null;\n    }\n\n    public <T> NativeMapper register(Class<T> targetType){\n        return register(targetType, false);\n    }\n\n    public <T> NativeMapper register(Class<T> targetType, boolean registerSupers){\n        StructDef structDef = null;", "        if(isStructType(targetType)){\n            structDef = getOrDefineStruct(targetType);\n        }\n\n        var fieldHandlers = new ArrayList<StructMappingHandler<T>>();\n        var functionHandlers = new ArrayList<FunctionHandler<T>>();\n        var globalHandlers = new ArrayList<GlobalHandler<T>>();\n        for(var field : targetType.getDeclaredFields()){\n            field.setAccessible(true);\n            // Handle self pointers\n            var selfPtr = field.getAnnotation(SelfPointer.class);", "            if(selfPtr != null){\n                if(structDef == null){\n                    throw new IllegalArgumentException(\"Cannot use @SelfPointer on a non-struct class: \" + targetType.getName());\n                }\n                fieldHandlers.add(new SelfPointerHandler<>(field));\n            }\n\n            var fieldHandle = field.getAnnotation(FieldHandle.class);\n            if(fieldHandle != null){\n                if(structDef == null){\n                    throw new IllegalArgumentException(\"Cannot use @FieldHandle on a non-struct class: \" + targetType.getName());\n                }\n                fieldHandlers.add(new FieldHandler<>(structDef.field(fieldHandle.name()), field));\n                // Recurse to register nested struct types", "            if(fieldHandle != null){\n                if(structDef == null){\n                    throw new IllegalArgumentException(\"Cannot use @FieldHandle on a non-struct class: \" + targetType.getName());\n                }\n                fieldHandlers.add(new FieldHandler<>(structDef.field(fieldHandle.name()), field));\n                // Recurse to register nested struct types\n                if(!field.getType().equals(VarHandle.class) &&\n                        !field.getType().equals(MemorySegment.class) &&\n                        !isRegistered(field.getType())){\n                    register(field.getType());\n                }\n            }\n\n            var functionHandle = field.getAnnotation(FunctionHandle.class);", "            if(functionHandle != null){\n                var builder = FunctionDef.create();\n                if(!functionHandle.returns().equals(void.class)){\n                    builder.withReturn(getLayout(functionHandle.returns()));\n                }\n\n                for(var param : functionHandle.params()){\n                    builder.withParam(getLayout(param));\n                }\n\n                var descriptor = builder.build();\n\n                getOrDefineFunction(functionHandle.name(), descriptor);\n\n                functionHandlers.add(new FunctionHandler<>(field, functionHandle.name(), descriptor));\n            }\n\n            var globalHandle = field.getAnnotation(GlobalHandle.class);", "            if(globalHandle != null){\n                globalHandlers.add(new GlobalHandler<>(field, globalHandle.name(), globalHandle.type(), globalHandle.pointer()));\n            }\n        }\n\n        var handlers = new ObjectHandlers<>(targetType, fieldHandlers, functionHandlers, globalHandlers);\n        register(targetType, handlers);\n\n        if(registerSupers && !targetType.getSuperclass().equals(Object.class)){\n            register(targetType.getSuperclass());\n        }\n        return this;\n    }\n\n    public <T> NativeMapper register(Class<T> targetType, ObjectHandlers<T> handlers){", "        if(registerSupers && !targetType.getSuperclass().equals(Object.class)){\n            register(targetType.getSuperclass());\n        }\n        return this;\n    }\n\n    public <T> NativeMapper register(Class<T> targetType, ObjectHandlers<T> handlers){\n        if(objectHandlers.containsKey(targetType)){\n            throw new IllegalStateException(\"Mapping is already defined for class \" + targetType.getName());\n        }\n        objectHandlers.put(targetType, handlers);\n        return this;\n    }\n", "    public boolean isRegistered(Class<?> targetType){\n        return objectHandlers.containsKey(targetType);\n    }\n\n    public MemorySegment toCFunction(Object target, String method, SegmentScope scope) throws IllegalAccessException {\n\n        var candidates = Arrays.stream(target.getClass().getMethods()).filter(m -> m.getName().equals(method)).toList();\n        if(candidates.size() > 1){\n            throw new IllegalArgumentException(\"Method %s is ambiguous for type %s\".formatted(method, target.getClass()));\n        }\n", "        if(candidates.size() == 0){\n            throw new IllegalArgumentException(\"Method %s not found for type %s\".formatted(method, target.getClass()));\n        }\n\n        return toCFunction(target, candidates.get(0), scope);\n    }\n\n    public MemorySegment toCFunction(Object target, String method, SegmentScope scope, Class<?> retType, Class<?>... paramTypes) throws IllegalAccessException {\n\n        var candidate = Arrays.stream((target instanceof Class ? ((Class<?>) target) : target.getClass()).getMethods())\n                .filter(m -> m.getName().equals(method))\n                .filter(m -> m.getReturnType().equals(retType))\n                .filter(m -> Arrays.equals(m.getParameterTypes(), paramTypes))\n                .findFirst();\n\n        var m = candidate.orElseThrow(() -> new IllegalArgumentException(\"Method %s not found for type %s\".formatted(method, target.getClass())));\n\n        return toCFunction(target, m, scope);\n    }\n", "    public MemorySegment toCFunction(Object target, Method method, SegmentScope scope) throws IllegalAccessException {\n        var handle = MethodHandles.lookup().unreflect(method);\n        if((method.getModifiers() & Modifier.STATIC) != 0){\n            handle.bindTo(target);\n        }\n        return Platform.toCFunction(handle, getFunctionDescriptor(method), scope);\n    }\n\n    public FunctionDescriptor getFunctionDescriptor(Method m){\n        var rType = m.getReturnType();\n        var paramTypes = Arrays.stream(m.getParameterTypes())\n                .map(this::getLayout)\n                .toArray(MemoryLayout[]::new);\n\n        return rType.equals(void.class)\n                ? FunctionDescriptor.ofVoid(paramTypes)\n                : FunctionDescriptor.of(getLayout(rType), paramTypes);\n    }\n\n}\n", "    public FunctionDescriptor getFunctionDescriptor(Method m){\n        var rType = m.getReturnType();\n        var paramTypes = Arrays.stream(m.getParameterTypes())\n                .map(this::getLayout)\n                .toArray(MemoryLayout[]::new);\n\n        return rType.equals(void.class)\n                ? FunctionDescriptor.ofVoid(paramTypes)\n                : FunctionDescriptor.of(getLayout(rType), paramTypes);\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/Struct.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Struct {", "@Target(ElementType.TYPE)\npublic @interface Struct {\n    String name();\n    boolean packed() default false;\n    StructField[] fields() default {};\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/FieldHandle.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface FieldHandle {", "@Target(ElementType.FIELD)\npublic @interface FieldHandle {\n    String name();\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/StructField.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD, ElementType.METHOD})\npublic @interface StructField {", "@Target({ElementType.FIELD, ElementType.METHOD})\npublic @interface StructField {\n    Class<?> type();\n    boolean pointer() default false;\n    long array() default 0;\n    String name() default \"\";\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/SelfPointer.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface SelfPointer {}", "@Target(ElementType.FIELD)\npublic @interface SelfPointer {}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/GlobalHandle.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface GlobalHandle {", "@Target(ElementType.FIELD)\npublic @interface GlobalHandle {\n\n    String name();\n\n    Class<?> type() default void.class;\n\n    boolean pointer() default false;\n\n}", "\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/StructDef.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic record StructDef(String name, boolean isPacked, FieldDef... fields) {\n\n    public FieldDef field(String name){\n        return Arrays.stream(fields)\n                .filter(f -> f.name().equals(name))\n                .findFirst()\n                .orElse(null);\n    }\n", "    public FieldDef field(String name){\n        return Arrays.stream(fields)\n                .filter(f -> f.name().equals(name))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public static Builder create(){\n        return new Builder();\n    }\n", "    public static Builder create(String name){\n        return new Builder(name, false);\n    }\n\n    public static Builder create(String name, boolean isPacked){\n        return new Builder(name, isPacked);\n    }\n\n    public static class Builder {\n\n        protected final String name;\n        protected final boolean isPacked;\n        protected final List<FieldDef> fields = new ArrayList<>();\n\n        protected Builder() {\n            this(null, false);\n        }\n\n        protected Builder(String name, boolean isPacked) {\n            this.name = name;\n            this.isPacked = isPacked;\n        }\n", "    public static class Builder {\n\n        protected final String name;\n        protected final boolean isPacked;\n        protected final List<FieldDef> fields = new ArrayList<>();\n\n        protected Builder() {\n            this(null, false);\n        }\n\n        protected Builder(String name, boolean isPacked) {\n            this.name = name;\n            this.isPacked = isPacked;\n        }\n", "        public Builder with(FieldDef field) {\n            fields.add(field);\n            return this;\n        }\n\n        public StructDef build() {\n            return new StructDef(name, isPacked, fields.toArray(new FieldDef[]{}));\n        }\n\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/Array.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.foreign.*;\n\npublic record Array<T>(MemorySegment array, MemoryLayout typeLayout, Class<T> carrierType, boolean isPointer) {\n\n    public long length(){\n        return array.byteSize() / typeLayout().byteSize();\n    }\n\n    public MemorySegment get(long index){\n        return get(array, typeLayout, index);\n    }\n", "    public MemorySegment get(long index){\n        return get(array, typeLayout, index);\n    }\n\n    public T get(long index, T target, NativeMapper mapper) throws IllegalAccessException {\n        mapper.populate(target, get(index));\n        return target;\n    }\n\n    public void set(long index, MemorySegment value){\n        set(array, typeLayout, index, value);\n    }\n", "    public void set(long index, MemorySegment value){\n        set(array, typeLayout, index, value);\n    }\n\n    public MemorySegment getAddress(long index){\n        return getAddress(array, index);\n    }\n\n    public void setAddress(long index, long a){\n        setAddress(index, MemorySegment.ofAddress(a));\n    }\n", "    public void setAddress(long index, long a){\n        setAddress(index, MemorySegment.ofAddress(a));\n    }\n\n    public void setAddress(long index, MemorySegment a){\n        setAddress(array, index, a);\n    }\n\n    public boolean getBoolean(long index){\n        return getBoolean(array, index);\n    }\n", "    public boolean getBoolean(long index){\n        return getBoolean(array, index);\n    }\n\n    public void setBoolean(long index, boolean b){\n        setBoolean(array, index, b);\n    }\n\n    public byte getByte(long index){\n        return getByte(array, index);\n    }\n", "    public byte getByte(long index){\n        return getByte(array, index);\n    }\n\n    public void setByte(long index, byte b){\n        setByte(array, index, b);\n    }\n\n    public char getChar(long index){\n        return getChar(array, index);\n    }\n", "    public char getChar(long index){\n        return getChar(array, index);\n    }\n\n    public void setChar(long index, char c){\n        setChar(array, index, c);\n    }\n\n    public double getDouble(long index){\n        return getDouble(array, index);\n    }\n", "    public double getDouble(long index){\n        return getDouble(array, index);\n    }\n\n    public void setDouble(long index, double d){\n        setDouble(array, index, d);\n    }\n\n    public float getFloat(long index){\n        return getFloat(array, index);\n    }\n", "    public float getFloat(long index){\n        return getFloat(array, index);\n    }\n\n    public void setFloat(long index, float f){\n        setFloat(array, index, f);\n    }\n\n    public int getInt(long index){\n        return getInt(array, index);\n    }\n", "    public int getInt(long index){\n        return getInt(array, index);\n    }\n\n    public void setInt(long index, int i){\n        setInt(array, index, i);\n    }\n\n    public long getLong(long index){\n        return getLong(array, index);\n    }\n", "    public long getLong(long index){\n        return getLong(array, index);\n    }\n\n    public void setLong(long index, long l){\n       setLong(array, index, l);\n    }\n\n    public short getShort(long index){\n        return getShort(array, index);\n    }\n", "    public short getShort(long index){\n        return getShort(array, index);\n    }\n\n    public void setShort(long index, short s){\n       setShort(array, index, s);\n    }\n\n    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType, long length){\n        return Pointer.cast(p, MemoryLayout.sequenceLayout(length, targetType), p.scope());\n    }\n", "    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType, long length){\n        return Pointer.cast(p, MemoryLayout.sequenceLayout(length, targetType), p.scope());\n    }\n\n    public static MemorySegment cast(MemorySegment p, MemoryLayout targetType, long length, SegmentScope scope){\n        return Pointer.cast(p, MemoryLayout.sequenceLayout(length, targetType), scope);\n    }\n\n    public static MemorySegment get(MemorySegment p, MemoryLayout type, long index){\n        return p.asSlice(type.byteSize() * index, type.byteSize());\n    }\n", "    public static MemorySegment get(MemorySegment p, MemoryLayout type, long index){\n        return p.asSlice(type.byteSize() * index, type.byteSize());\n    }\n\n    public static void set(MemorySegment p, MemoryLayout type, long index, MemorySegment e){\n        MemorySegment.copy(e, 0, p, type.byteSize() * index, type.byteSize());\n    }\n\n    public static MemorySegment getAddress(MemorySegment p, long index){\n        return p.get(ValueLayout.ADDRESS, ValueLayout.ADDRESS.byteSize() * index);\n    }\n", "    public static MemorySegment getAddress(MemorySegment p, long index){\n        return p.get(ValueLayout.ADDRESS, ValueLayout.ADDRESS.byteSize() * index);\n    }\n\n    public static void setAddress(MemorySegment p, long index, MemorySegment a){\n        p.set(ValueLayout.ADDRESS, ValueLayout.ADDRESS.byteSize() * index, a);\n    }\n\n    public static boolean getBoolean(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_BOOLEAN, ValueLayout.JAVA_BOOLEAN.byteSize() * index);\n    }\n", "    public static boolean getBoolean(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_BOOLEAN, ValueLayout.JAVA_BOOLEAN.byteSize() * index);\n    }\n\n    public static void setBoolean(MemorySegment p, long index, boolean b){\n        p.set(ValueLayout.JAVA_BOOLEAN, ValueLayout.JAVA_BOOLEAN.byteSize() * index, b);\n    }\n\n    public static byte getByte(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_BYTE, ValueLayout.JAVA_BYTE.byteSize() * index);\n    }\n", "    public static byte getByte(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_BYTE, ValueLayout.JAVA_BYTE.byteSize() * index);\n    }\n\n    public static void setByte(MemorySegment p, long index, byte b){\n        p.set(ValueLayout.JAVA_BYTE, ValueLayout.JAVA_BYTE.byteSize() * index, b);\n    }\n\n    public static char getChar(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_CHAR, ValueLayout.JAVA_CHAR.byteSize() * index);\n    }\n", "    public static char getChar(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_CHAR, ValueLayout.JAVA_CHAR.byteSize() * index);\n    }\n\n    public static void setChar(MemorySegment p, long index, char c){\n        p.set(ValueLayout.JAVA_CHAR, ValueLayout.JAVA_CHAR.byteSize() * index, c);\n    }\n\n    public static double getDouble(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_DOUBLE, ValueLayout.JAVA_DOUBLE.byteSize() * index);\n    }\n", "    public static double getDouble(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_DOUBLE, ValueLayout.JAVA_DOUBLE.byteSize() * index);\n    }\n\n    public static void setDouble(MemorySegment p, long index, double d){\n        p.set(ValueLayout.JAVA_DOUBLE, ValueLayout.JAVA_DOUBLE.byteSize() * index, d);\n    }\n\n    public static float getFloat(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_FLOAT, ValueLayout.JAVA_FLOAT.byteSize() * index);\n    }\n", "    public static float getFloat(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_FLOAT, ValueLayout.JAVA_FLOAT.byteSize() * index);\n    }\n\n    public static void setFloat(MemorySegment p, long index, float f){\n        p.set(ValueLayout.JAVA_FLOAT, ValueLayout.JAVA_FLOAT.byteSize() * index, f);\n    }\n\n    public static int getInt(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT.byteSize() * index);\n    }\n", "    public static int getInt(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT.byteSize() * index);\n    }\n\n    public static void setInt(MemorySegment p, long index, int i){\n        p.set(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT.byteSize() * index, i);\n    }\n\n    public static long getLong(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG.byteSize() * index);\n    }\n", "    public static long getLong(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG.byteSize() * index);\n    }\n\n    public static void setLong(MemorySegment p, long index, long l){\n        p.set(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG.byteSize() * index, l);\n    }\n\n    public static short getShort(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_SHORT, ValueLayout.JAVA_SHORT.byteSize() * index);\n    }\n", "    public static short getShort(MemorySegment p, long index){\n        return p.get(ValueLayout.JAVA_SHORT, ValueLayout.JAVA_SHORT.byteSize() * index);\n    }\n\n    public static void setShort(MemorySegment p, long index, short s){\n        p.set(ValueLayout.JAVA_SHORT, ValueLayout.JAVA_SHORT.byteSize() * index, s);\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/Platform.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy;\n", "package com.myworldvw.buoy;\n\nimport java.lang.foreign.*;\nimport java.lang.invoke.MethodHandle;\nimport java.nio.file.Path;\n\npublic class Platform {\n\n    public static final MemoryLayout SIZE_T = ValueLayout.JAVA_LONG;\n\n    public static final int C_TRUE = 1;", "    public static final MemoryLayout SIZE_T = ValueLayout.JAVA_LONG;\n\n    public static final int C_TRUE = 1;\n    public static final int C_FALSE = 0;\n\n    public static int toCBoolean(boolean b){\n        return b ? C_TRUE : C_FALSE;\n    }\n\n    public static MemorySegment toCFunction(MethodHandle method, FunctionDescriptor descriptor, SegmentScope scope){\n        return Linker.nativeLinker().upcallStub(method, descriptor, scope);\n    }\n", "    public static MemorySegment toCFunction(MethodHandle method, FunctionDescriptor descriptor, SegmentScope scope){\n        return Linker.nativeLinker().upcallStub(method, descriptor, scope);\n    }\n\n    public static String standardLibraryName(String name){\n        var os = detectOS();\n        return os == null ? name : switch (os){\n            case LINUX -> \"lib\" + name + \".so\";\n            case MAC_OSX -> \"lib\" + name + \".dylib\";\n            case WINDOWS -> name + \".dll\";\n        };\n    }\n", "    public static SymbolLookup loadLibrary(String libName, SegmentScope scope){\n        return SymbolLookup.libraryLookup(libName, scope);\n    }\n\n    public static SymbolLookup loadLibrary(Path libPath, SegmentScope scope){\n        return SymbolLookup.libraryLookup(libPath, scope);\n    }\n\n    public static SegmentAllocator globalAllocator(){\n        return allocator(SegmentScope.global());\n    }\n", "    public static SegmentAllocator globalAllocator(){\n        return allocator(SegmentScope.global());\n    }\n\n    public static SegmentAllocator autoAllocator(){\n        return allocator(SegmentScope.auto());\n    }\n\n    public static SegmentAllocator allocator(SegmentScope scope){\n        return SegmentAllocator.nativeAllocator(scope);\n    }\n", "    public static SegmentAllocator allocator(SegmentScope scope){\n        return SegmentAllocator.nativeAllocator(scope);\n    }\n\n    public static MemorySegment allocate(MemoryLayout layout){\n        return allocate(layout, SegmentScope.global());\n    }\n\n    public static MemorySegment allocate(MemoryLayout layout, long count){\n        return allocate(layout, count, SegmentScope.global());\n    }\n", "    public static MemorySegment allocate(MemoryLayout layout, long count){\n        return allocate(layout, count, SegmentScope.global());\n    }\n\n    public static MemorySegment allocate(MemoryLayout layout, SegmentScope scope){\n        return allocate(layout, 1, scope);\n    }\n\n    public static MemorySegment allocate(MemoryLayout layout, long count, SegmentScope scope){\n        return MemorySegment.allocateNative(layout.byteSize() * count, scope);\n    }\n", "    public static MemorySegment allocate(MemoryLayout layout, long count, SegmentScope scope){\n        return MemorySegment.allocateNative(layout.byteSize() * count, scope);\n    }\n\n    public static long offsetOf(MemoryLayout structLayout, String field){\n        return structLayout.byteOffset(MemoryLayout.PathElement.groupElement(field));\n    }\n\n    public static OperatingSystemFamily detectOS(){\n        var os = System.getProperty(\"os.name\").toLowerCase();\n", "    public static OperatingSystemFamily detectOS(){\n        var os = System.getProperty(\"os.name\").toLowerCase();\n\n        if(os.contains(\"win\")){\n            return OperatingSystemFamily.WINDOWS;\n        }else if(os.contains(\"linux\")){\n            return OperatingSystemFamily.LINUX;\n        }else if(os.contains(\"mac\")){\n            return OperatingSystemFamily.MAC_OSX;\n        }\n\n        return null;\n    }\n", "    public static Architecture detectArchitecture(){\n        var arch = System.getProperty(\"os.arch\");\n        return switch (arch){\n            case \"amd64\" -> Architecture.AMD64;\n            case \"x86\" -> Architecture.X86;\n            case \"ia64\" -> Architecture.IA64;\n            case \"unknown\" -> Architecture.UNKNOWN;\n            default -> Architecture.UNKNOWN;\n        };\n    }\n", "    public enum OperatingSystemFamily {\n        LINUX, MAC_OSX, WINDOWS\n    }\n\n    public enum Architecture {\n        AMD64(64), IA64(64), X86(32), UNKNOWN(64);\n        int width;\n\n        Architecture(int width){\n            this.width = width;\n        }\n", "        public int width(){\n            return width;\n        }\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/FieldHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.Array;\nimport com.myworldvw.buoy.FieldDef;\nimport com.myworldvw.buoy.NativeMapper;\nimport com.myworldvw.buoy.Pointer;\n\nimport java.lang.foreign.MemoryLayout;\nimport java.lang.foreign.MemorySegment;\nimport java.lang.foreign.ValueLayout;", "import java.lang.foreign.MemorySegment;\nimport java.lang.foreign.ValueLayout;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.VarHandle;\nimport java.lang.reflect.Field;\n\npublic class FieldHandler<T> implements StructMappingHandler<T> {\n\n    protected final FieldDef model;\n    protected final Field field;\n\n    protected volatile VarHandle handle;\n\n    public FieldHandler(FieldDef model, Field field){\n        this.model = model;\n        this.field = field;\n    }\n", "    public VarHandle getHandle(MemoryLayout layout){\n        return layout.varHandle(MemoryLayout.PathElement.groupElement(model.name()));\n    }\n\n    public MethodHandle getAccessor(MemoryLayout layout, VarHandle.AccessMode mode){\n        return getHandle(layout).toMethodHandle(mode);\n    }\n\n    public MethodHandle getGetter(MemoryLayout layout){\n        return getAccessor(layout, VarHandle.AccessMode.GET);\n    }\n", "    public MethodHandle getGetter(MemoryLayout layout){\n        return getAccessor(layout, VarHandle.AccessMode.GET);\n    }\n\n    public MethodHandle getGetter(MemorySegment ptr, MemoryLayout layout){\n        return getGetter(layout).bindTo(ptr);\n    }\n\n    public MethodHandle getSetter(MemoryLayout layout){\n        return getAccessor(layout, VarHandle.AccessMode.SET);\n    }\n", "    public MethodHandle getSetter(MemoryLayout layout){\n        return getAccessor(layout, VarHandle.AccessMode.SET);\n    }\n\n    public MethodHandle getSetter(MemorySegment ptr, MemoryLayout layout){\n        return getSetter(layout).bindTo(ptr);\n    }\n\n    @Override\n    public void fill(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException {\n        // Given the field type:\n        // If it's a VarHandle, we get a handle to the field in the struct\n        // If it's a MemorySegment, we calculate the field offset and assign it\n        // If it's an Array, we bind it to the segment\n        // If it's an object, we determine if it's a nested struct or a pointer to a struct,\n        // and we populate it with the offset of the field (nested) *or* the memory address\n        // contained in the field (pointer) as the object's self-pointer segment\n", "    public void fill(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException {\n        // Given the field type:\n        // If it's a VarHandle, we get a handle to the field in the struct\n        // If it's a MemorySegment, we calculate the field offset and assign it\n        // If it's an Array, we bind it to the segment\n        // If it's an object, we determine if it's a nested struct or a pointer to a struct,\n        // and we populate it with the offset of the field (nested) *or* the memory address\n        // contained in the field (pointer) as the object's self-pointer segment\n\n        if(Util.skipField(field, target)){\n            return;\n        }\n\n        var fieldType = field.getType();", "        if(Util.skipField(field, target)){\n            return;\n        }\n\n        var fieldType = field.getType();\n        if(fieldType.equals(VarHandle.class)){\n            if(handle == null){\n                handle = getHandle(mapper.getLayout(target.getClass()));\n            }\n            field.set(target, handle);\n        }else if(fieldType.equals(MemorySegment.class)){\n            field.set(target, segmentForField(mapper, target, segment));", "        }else if(fieldType.equals(MemorySegment.class)){\n            field.set(target, segmentForField(mapper, target, segment));\n        }else if(fieldType.equals(Array.class)){\n            field.set(target, new Array<>(\n                    arraySegmentForField(mapper, target, segment),\n                    mapper.getLayout(model.type()),\n                    model.type(),\n                    model.isPointer()\n                    ));\n        } else{\n            var structDef = mapper.getOrDefineStruct(fieldType);", "            if(structDef == null){\n                throw new IllegalArgumentException(\"Not a mappable type for a field handle: \" + fieldType);\n            }\n\n            var structSegment = segmentForField(mapper, target, segment);\n            if(model.isPointer()){\n                // If this is a pointer type, we have to construct a new segment starting at the address\n                // contained in this segment, with the length of the field type.\n                structSegment = MemorySegment.ofAddress(\n                        Pointer.getAddress(structSegment),\n                        mapper.sizeOf(model.type()),\n                        structSegment.scope());\n            }\n            var nestedTarget = field.get(target);", "            if(nestedTarget != null){\n                mapper.populate(nestedTarget, structSegment);\n            }\n        }\n    }\n\n    protected MemorySegment arraySegmentForField(NativeMapper mapper, Object target, MemorySegment segment){\n        // 1. If model is a pointer (*type[length]), dereference to get the address of the array.\n        // 2. Create a segment appropriate to the array type * length\n        var fieldSegment = segmentForField(mapper, target, segment);\n        var address = fieldSegment.address();", "        if(model.isPointer()){\n            address = Pointer.getAddress(fieldSegment);\n        }\n\n        var elementType = mapper.getLayout(model.type());\n        return MemorySegment.ofAddress(address, elementType.byteSize() * model.array(), segment.scope());\n    }\n\n    protected MemorySegment segmentForField(NativeMapper mapper, Object target, MemorySegment segment){\n        var offset = mapper.getLayout(target.getClass()).byteOffset(MemoryLayout.PathElement.groupElement(model.name()));\n        return model.isPointer()\n                ? segment.asSlice(offset, ValueLayout.ADDRESS.byteSize())\n                : segment.asSlice(offset, mapper.sizeOf(model));\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/Util.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\npublic class Util {\n\n    public static <T> boolean skipField(Field field, T target){\n        // Skip fields that are static when the target is not a class\n        var isStatic = Modifier.isStatic(field.getModifiers());\n        var targetIsClass = target instanceof Class;\n        return (isStatic && !targetIsClass) ||\n                (!isStatic && targetIsClass);\n    }\n\n    public static <T> boolean isStaticTarget(T target){\n        return target instanceof Class;\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/package-info.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The mapping package defines a number of helper classes that are used by", "/**\n * The mapping package defines a number of helper classes that are used by\n * the {@link com.myworldvw.buoy.NativeMapper} class to map native constructs\n * to Buoy models. It's unlikely that end users will need to use anything here\n * directly, but advanced users (or downstream libraries that extend Buoy\n * functionality) may need to use these.\n */\npackage com.myworldvw.buoy.mapping;"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/FunctionHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.NativeMapper;\n\nimport java.lang.foreign.FunctionDescriptor;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.reflect.Field;\n\npublic class FunctionHandler<T> implements FunctionMappingHandler<T> {\n\n    protected final Field field;\n    protected final String name;\n    protected final FunctionDescriptor descriptor;\n\n    protected MethodHandle handle;\n\n    public FunctionHandler(Field field, String functionName, FunctionDescriptor descriptor){\n        this.field = field;\n        name = functionName;\n        this.descriptor = descriptor;\n    }\n\n    @Override", "public class FunctionHandler<T> implements FunctionMappingHandler<T> {\n\n    protected final Field field;\n    protected final String name;\n    protected final FunctionDescriptor descriptor;\n\n    protected MethodHandle handle;\n\n    public FunctionHandler(Field field, String functionName, FunctionDescriptor descriptor){\n        this.field = field;\n        name = functionName;\n        this.descriptor = descriptor;\n    }\n\n    @Override", "    public void fill(NativeMapper mapper, T target) throws IllegalAccessException {\n\n        if(Util.skipField(field, target)){\n            return;\n        }\n\n        if(handle == null){\n            handle = mapper.getOrDefineFunction(name, descriptor);\n        }\n\n        field.set(target, handle);\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/FunctionMappingHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.NativeMapper;\n\npublic interface FunctionMappingHandler<T> {\n\n    void fill(NativeMapper mapper, T target) throws IllegalAccessException;\n\n    default T handle(NativeMapper mapper, T target) throws IllegalAccessException{\n        fill(mapper, target);\n        return target;\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/SelfPointerHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.NativeMapper;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.reflect.Field;\n\npublic class SelfPointerHandler<T> implements StructMappingHandler<T> {\n\n    protected final Field field;\n\n    public SelfPointerHandler(Field field){\n        this.field = field;\n    }\n\n    @Override", "    public void fill(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException {\n        if(!Util.skipField(field, target)){\n            field.set(target, segment);\n        }\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/GlobalHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.NativeMapper;\nimport com.myworldvw.buoy.Pointer;\n\nimport java.lang.foreign.MemorySegment;\nimport java.lang.reflect.Field;\n\npublic class GlobalHandler<T> implements StructMappingHandler<T> {\n\n    protected final Field field;\n    protected final String name;\n    protected final Class<?> type;\n    protected final boolean pointer;\n\n    protected volatile MemorySegment symbolPtr;\n\n    public GlobalHandler(Field field, String name, Class<?> type, boolean pointer){\n        this.field = field;\n        this.name = name;\n        this.type = type;\n        this.pointer = pointer;\n", "public class GlobalHandler<T> implements StructMappingHandler<T> {\n\n    protected final Field field;\n    protected final String name;\n    protected final Class<?> type;\n    protected final boolean pointer;\n\n    protected volatile MemorySegment symbolPtr;\n\n    public GlobalHandler(Field field, String name, Class<?> type, boolean pointer){\n        this.field = field;\n        this.name = name;\n        this.type = type;\n        this.pointer = pointer;\n", "        if(!field.getType().equals(MemorySegment.class)){\n            throw new IllegalArgumentException(\"Globals can only be accessed via MemorySegment\");\n        }\n    }\n\n    @Override\n    public void fill(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException {\n        if(Util.skipField(field, target)){\n            return;\n        }\n", "        if(symbolPtr == null){\n            symbolPtr = mapper.getLookup().find(name)\n                    .map(symbol -> Pointer.cast(symbol, mapper.getLayout(pointer ? MemorySegment.class : type)))\n                    .orElseThrow(() -> new IllegalArgumentException(\"Symbol \" + name + \" not found\"));\n        }\n\n        field.set(target, symbolPtr);\n    }\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/StructMappingHandler.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport com.myworldvw.buoy.NativeMapper;\n\nimport java.lang.foreign.MemorySegment;\n\npublic interface StructMappingHandler<T> {\n\n    void fill(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException;\n\n    default T handle(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException{\n        fill(mapper, segment, target);\n        return target;\n    }\n\n}\n"]}
{"filename": "lib/src/main/java/com/myworldvw/buoy/mapping/ObjectHandlers.java", "chunked_list": ["/*\n * Copyright (c) 2023. MyWorld, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software", " *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.myworldvw.buoy.mapping;\n", "package com.myworldvw.buoy.mapping;\n\nimport java.util.List;\n\npublic record ObjectHandlers<T>(Class<T> type, List<StructMappingHandler<T>> structFieldHandlers, List<FunctionHandler<T>> functionHandlers, List<GlobalHandler<T>> globalHandlers) {}\n"]}
