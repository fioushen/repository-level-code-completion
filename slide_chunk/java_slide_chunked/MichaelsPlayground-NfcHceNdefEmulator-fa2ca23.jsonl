{"filename": "app/src/test/java/de/androidcrypto/nfchcendefemulator/ExampleUnitTest.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>", " *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() {\n        assertEquals(4, 2 + 2);\n    }\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/MainActivity.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.appcompat.widget.Toolbar;\nimport androidx.fragment.app.Fragment;\n\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\n", "import android.view.MenuItem;\n\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\nimport com.google.android.material.navigation.NavigationBarView;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        BottomNavigationView bottomNav = findViewById(R.id.bottom_navigation);\n        //bottomNav.setOnNavigationItemSelectedListener(navListener);\n        bottomNav.setOnItemSelectedListener(navListener);\n\n        // as soon as the application opens the first\n        // fragment should be shown to the user\n        // in this case it is algorithm fragment\n        getSupportFragmentManager().beginTransaction().replace(R.id.fragment_container, new HomeFragment()).commit();\n    }\n\n    //private final BottomNavigationView.OnNavigationItemSelectedListener navListener = item -> {\n    private final NavigationBarView.OnItemSelectedListener navListener = item -> {\n        // By using switch we can easily get\n        // the selected fragment\n        // by using there id.\n        Fragment selectedFragment = null;\n        int itemId = item.getItemId();", "        if (itemId == R.id.home) {\n            selectedFragment = new HomeFragment();\n        } else if (itemId == R.id.send) {\n            selectedFragment = new SendFragment();\n        } else if (itemId == R.id.receive) {\n            selectedFragment = new ReceiveFragment();\n        } else if (itemId == R.id.receive_extended) {\n            selectedFragment = new ReceiveExtendedFragment();\n        }\n        // It will help to replace the\n        // one fragment to other.", "        if (selectedFragment != null) {\n            getSupportFragmentManager().beginTransaction().replace(R.id.fragment_container, selectedFragment).commit();\n        }\n        return true;\n    };\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/ReceiveFragment.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport static android.content.Context.VIBRATOR_SERVICE;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.nfc.FormatException;\nimport android.nfc.NdefMessage;\nimport android.nfc.NdefRecord;\nimport android.nfc.NfcAdapter;", "import android.nfc.NdefRecord;\nimport android.nfc.NfcAdapter;\nimport android.nfc.Tag;\nimport android.nfc.tech.IsoDep;\nimport android.nfc.tech.Ndef;\nimport android.os.Build;\nimport android.os.Bundle;\n\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;", "import androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n\nimport android.os.VibrationEffect;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;", "import android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Objects;\n\n/**", "\n/**\n * A simple {@link Fragment} subclass.\n * Use the {@link ReceiveFragment#newInstance} factory method to\n * create an instance of this fragment.\n */\npublic class ReceiveFragment extends Fragment implements NfcAdapter.ReaderCallback {\n\n    // TODO: Rename parameter arguments, choose names that match\n    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER\n    private static final String ARG_PARAM1 = \"param1\";\n    private static final String ARG_PARAM2 = \"param2\";\n\n    // TODO: Rename and change types of parameters\n    private String mParam1;\n    private String mParam2;\n\n    public ReceiveFragment() {\n        // Required empty public constructor\n    }\n\n    /**\n     * Use this factory method to create a new instance of\n     * this fragment using the provided parameters.\n     *\n     * @param param1 Parameter 1.\n     * @param param2 Parameter 2.\n     * @return A new instance of fragment ReceiveFragment.\n     */\n    // TODO: Rename and change types and number of parameters", "    public static ReceiveFragment newInstance(String param1, String param2) {\n        ReceiveFragment fragment = new ReceiveFragment();\n        Bundle args = new Bundle();\n        args.putString(ARG_PARAM1, param1);\n        args.putString(ARG_PARAM2, param2);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    TextView readResult;\n    private NfcAdapter mNfcAdapter;\n    String dumpExportString = \"\";\n    String tagIdString = \"\";\n    String tagTypeString = \"\";\n    private static final int REQUEST_PERMISSION_WRITE_EXTERNAL_STORAGE = 100;\n    Context contextSave;\n\n    @Override", "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (getArguments() != null) {\n            mParam1 = getArguments().getString(ARG_PARAM1);\n            mParam2 = getArguments().getString(ARG_PARAM2);\n        }\n        contextSave = getActivity().getApplicationContext();\n        mNfcAdapter = NfcAdapter.getDefaultAdapter(this.getContext());\n    }\n\n    @Override", "    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        readResult = getView().findViewById(R.id.tvReceiveReadResult);\n        //doVibrate();\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_receive, container, false);\n    }\n\n    // This method is running in another thread when a card is discovered\n    // !!!! This method cannot cannot direct interact with the UI Thread\n    // Use `runOnUiThread` method to change the UI from this method\n    @Override", "    public void onTagDiscovered(Tag tag) {\n        // Read and or write to Tag here to the appropriate Tag Technology type class\n        // in this example the card should be an Ndef Technology Type\n\n        System.out.println(\"NFC tag discovered\");\n        requireActivity().runOnUiThread(() -> {\n            readResult.setText(\"\");\n        });\n\n        Ndef mNdef = Ndef.get(tag);\n        if (mNdef != null) {\n\n            // If we want to read\n            // As we did not turn on the NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK\n            // We can get the cached Ndef message the system read for us.\n            NdefMessage mNdefMessage = mNdef.getCachedNdefMessage();\n            NdefRecord[] record = mNdefMessage.getRecords();\n            int ndefRecordsCount = record.length;", "        if (mNdef != null) {\n\n            // If we want to read\n            // As we did not turn on the NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK\n            // We can get the cached Ndef message the system read for us.\n            NdefMessage mNdefMessage = mNdef.getCachedNdefMessage();\n            NdefRecord[] record = mNdefMessage.getRecords();\n            int ndefRecordsCount = record.length;\n            if (ndefRecordsCount > 0) {\n                String ndefText = \"\";\n                for (int i = 0; i < ndefRecordsCount; i++) {\n                    short ndefTnf = record[i].getTnf();\n                    byte[] ndefType = record[i].getType();\n                    byte[] ndefPayload = record[i].getPayload();\n                    // here we are trying to parse the content\n                    // Well known type - Text", "            if (ndefRecordsCount > 0) {\n                String ndefText = \"\";\n                for (int i = 0; i < ndefRecordsCount; i++) {\n                    short ndefTnf = record[i].getTnf();\n                    byte[] ndefType = record[i].getType();\n                    byte[] ndefPayload = record[i].getPayload();\n                    // here we are trying to parse the content\n                    // Well known type - Text\n                    if (ndefTnf == NdefRecord.TNF_WELL_KNOWN &&\n                            Arrays.equals(ndefType, NdefRecord.RTD_TEXT)) {\n                        ndefText = ndefText + \"\\n\" + \"rec: \" + i +\n                                \" Well known Text payload\\n\" + new String(ndefPayload) + \" \\n\";\n                        ndefText = ndefText + Utils.parseTextrecordPayload(ndefPayload) + \" \\n\";\n                    }\n                    // Well known type - Uri", "                    if (ndefTnf == NdefRecord.TNF_WELL_KNOWN &&\n                            Arrays.equals(ndefType, NdefRecord.RTD_TEXT)) {\n                        ndefText = ndefText + \"\\n\" + \"rec: \" + i +\n                                \" Well known Text payload\\n\" + new String(ndefPayload) + \" \\n\";\n                        ndefText = ndefText + Utils.parseTextrecordPayload(ndefPayload) + \" \\n\";\n                    }\n                    // Well known type - Uri\n                    if (ndefTnf == NdefRecord.TNF_WELL_KNOWN &&\n                            Arrays.equals(ndefType, NdefRecord.RTD_URI)) {\n                        ndefText = ndefText + \"\\n\" + \"rec: \" + i +\n                                \" Well known Uri payload\\n\" + new String(ndefPayload) + \" \\n\";\n                        ndefText = ndefText + Utils.parseUrirecordPayload(ndefPayload) + \" \\n\";\n                    }\n\n                    // TNF 2 Mime Media", "                    if (ndefTnf == NdefRecord.TNF_MIME_MEDIA) {\n                        ndefText = ndefText + \"\\n\" + \"rec: \" + i +\n                                \" TNF Mime Media  payload\\n\" + new String(ndefPayload) + \" \\n\";\n                        ndefText = ndefText + \"TNF Mime Media  type\\n\" + new String(ndefType) + \" \\n\";\n                    }\n                    // TNF 4 External type\n                    if (ndefTnf == NdefRecord.TNF_EXTERNAL_TYPE) {\n                        ndefText = ndefText + \"\\n\" + \"rec: \" + i +\n                                \" TNF External type payload\\n\" + new String(ndefPayload) + \" \\n\";\n                        ndefText = ndefText + \"TNF External type type\\n\" + new String(ndefType) + \" \\n\";\n                    }\n                    String finalNdefText = ndefText;\n                    getActivity().runOnUiThread(() -> {\n                        readResult.setText(finalNdefText);\n                    });\n\n                }\n            }\n        } else {\n            getActivity().runOnUiThread(() -> {\n                readResult.setText(\"There was an error in NDEF data\");\n            });\n\n        }\n        doVibrate();\n    }\n\n    private void doVibrate() {", "        if (getActivity() != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                ((Vibrator) getActivity().getSystemService(VIBRATOR_SERVICE)).vibrate(VibrationEffect.createOneShot(150, 10));\n            } else {\n                Vibrator v = (Vibrator) getActivity().getSystemService(VIBRATOR_SERVICE);\n                v.vibrate(200);\n            }\n        }\n    }\n\n    private void showWirelessSettings() {\n        Toast.makeText(this.getContext(), \"You need to enable NFC\", Toast.LENGTH_SHORT).show();\n        Intent intent = new Intent(Settings.ACTION_WIRELESS_SETTINGS);\n        startActivity(intent);\n    }\n\n    @Override", "    public void onResume() {\n        super.onResume();\n\n        if (mNfcAdapter != null) {\n\n            if (!mNfcAdapter.isEnabled())\n                showWirelessSettings();\n\n            Bundle options = new Bundle();\n            // Work around for some broken Nfc firmware implementations that poll the card too fast\n            options.putInt(NfcAdapter.EXTRA_READER_PRESENCE_CHECK_DELAY, 250);\n\n            // Enable ReaderMode for all types of card and disable platform sounds\n            // the option NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK is NOT set\n            // to get the data of the tag afer reading\n            mNfcAdapter.enableReaderMode(this.getActivity(),\n                    this,\n                    NfcAdapter.FLAG_READER_NFC_A |\n                            NfcAdapter.FLAG_READER_NFC_B |\n                            NfcAdapter.FLAG_READER_NFC_F |\n                            NfcAdapter.FLAG_READER_NFC_V |\n                            NfcAdapter.FLAG_READER_NFC_BARCODE |\n                            NfcAdapter.FLAG_READER_NO_PLATFORM_SOUNDS,\n                    options);\n        }\n    }\n\n    @Override", "    public void onPause() {\n        super.onPause();\n        if (mNfcAdapter != null)\n            mNfcAdapter.disableReaderMode(this.getActivity());\n    }\n\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/NdefHostApduServiceOrg.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.nfc.NdefMessage;\nimport android.nfc.NdefRecord;\nimport android.nfc.cardemulation.HostApduService;\nimport android.os.Bundle;\n\nimport java.util.Arrays;\n\npublic class NdefHostApduServiceOrg extends HostApduService {\n    // \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_APP = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x00,\n            (byte)0x07, (byte)0xd2, (byte)0x76, (byte)0x00, (byte)0x00, (byte)0x85, (byte)0x01, (byte)0x01,\n            (byte)0x00,\n    };\n    // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU)\n    private final static byte[] SELECT_CC_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x03,\n    };\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_NDEF_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x04,\n    };\n\n    // \u6210\u529f\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] SUCCESS_SW = new byte[] {\n            (byte)0x90, (byte)0x00,\n    };\n    // \u5931\u6557\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] FAILURE_SW = new byte[] {\n            (byte)0x6a, (byte)0x82,\n    };\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\n    private final static byte[] CC_FILE = new byte[] {\n            0x00, 0x0f, // CCLEN\n            0x20, // Mapping Version\n            0x00, 0x3b, // Maximum R-APDU data size\n            0x00, 0x34, // Maximum C-APDU data size\n            0x04, 0x06, // Tag & Length\n            (byte)0xe1, 0x04, // NDEF File Identifier\n            0x00, 0x32, // Maximum NDEF size\n            0x00, // NDEF file read access granted\n            (byte)0xff, // NDEF File write access denied\n    };\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u306b\u683c\u7d0d\u3059\u308bURL\n    private static final String URL = \"http://brightechno.com/blog/\";\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u7528\u5909\u6570\n    private byte[] mNdefRecordFile;\n\n    // \u30a2\u30d7\u30ea\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mAppSelected;\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mCcSelected;\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mNdefSelected;\n\n    @Override", "\npublic class NdefHostApduServiceOrg extends HostApduService {\n    // \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_APP = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x00,\n            (byte)0x07, (byte)0xd2, (byte)0x76, (byte)0x00, (byte)0x00, (byte)0x85, (byte)0x01, (byte)0x01,\n            (byte)0x00,\n    };\n    // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU)\n    private final static byte[] SELECT_CC_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x03,\n    };\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_NDEF_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x04,\n    };\n\n    // \u6210\u529f\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] SUCCESS_SW = new byte[] {\n            (byte)0x90, (byte)0x00,\n    };\n    // \u5931\u6557\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] FAILURE_SW = new byte[] {\n            (byte)0x6a, (byte)0x82,\n    };\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\n    private final static byte[] CC_FILE = new byte[] {\n            0x00, 0x0f, // CCLEN\n            0x20, // Mapping Version\n            0x00, 0x3b, // Maximum R-APDU data size\n            0x00, 0x34, // Maximum C-APDU data size\n            0x04, 0x06, // Tag & Length\n            (byte)0xe1, 0x04, // NDEF File Identifier\n            0x00, 0x32, // Maximum NDEF size\n            0x00, // NDEF file read access granted\n            (byte)0xff, // NDEF File write access denied\n    };\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u306b\u683c\u7d0d\u3059\u308bURL\n    private static final String URL = \"http://brightechno.com/blog/\";\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u7528\u5909\u6570\n    private byte[] mNdefRecordFile;\n\n    // \u30a2\u30d7\u30ea\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mAppSelected;\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mCcSelected;\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mNdefSelected;\n\n    @Override", "    public void onCreate() {\n        super.onCreate();\n\n        // \u72b6\u614b\u306e\u30af\u30ea\u30a2\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n\n        // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u306e\u751f\u6210\n        NdefRecord record = NdefRecord.createUri(URL);\n        NdefMessage ndefMessage = new NdefMessage(record);\n\n        int nlen = ndefMessage.getByteArrayLength();\n\n        mNdefRecordFile = new byte[nlen + 2];\n\n        mNdefRecordFile[0] = (byte)((nlen & 0xff00) / 256);\n        mNdefRecordFile[1] = (byte)(nlen & 0xff);\n        System.arraycopy(ndefMessage.toByteArray(), 0, mNdefRecordFile, 2, ndefMessage.getByteArrayLength());\n    }\n\n    /**\n     * NFC Forum Tag Type 4\u3068\u3057\u3066\u632f\u308b\u821e\u3046\u51e6\u7406\u3092\u884c\u3046\u3002\n     * C-APDU\u3092\u53d7\u3051\u53d6\u308a\u3001\u5bfe\u5fdc\u3059\u308bR-APDU\u3092\u8fd4\u3059\u3002\n     */\n    @Override\n    public byte[] processCommandApdu(byte[] commandApdu, Bundle extras) {", "        if (Arrays.equals(SELECT_APP, commandApdu)) {\n            // \u30a2\u30d7\u30ea\u9078\u629e\n            mAppSelected = true;\n            mCcSelected = false;\n            mNdefSelected = false;\n            return SUCCESS_SW; // \u6210\u529f\n        } else if (mAppSelected && Arrays.equals(SELECT_CC_FILE, commandApdu)) {\n            // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\n            mCcSelected = true;\n            mNdefSelected = false;\n            return SUCCESS_SW; // \u6210\u529f", "        } else if (mAppSelected && Arrays.equals(SELECT_NDEF_FILE, commandApdu)) {\n            // NDEF\u30d5\u30a1\u30a4\u30eb\u9078\u629e\n            mCcSelected = false;\n            mNdefSelected = true;\n            return SUCCESS_SW; // \u6210\u529f\n        } else if (commandApdu[0] == (byte)0x00 && commandApdu[1] == (byte)0xb0) {\n            // READ_BINARY (\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u51fa\u3057)\n\n            // \u30aa\u30d5\u30bb\u30c3\u30c8\u3068\u9577\u3055\u3092\u53d6\u308a\u51fa\u3059\n            int offset = (0x00ff & commandApdu[2]) * 256 + (0x00ff & commandApdu[3]);\n            int le = 0x00ff & commandApdu[4];\n\n            // R-APDU\u7528\u306e\u30d0\u30c3\u30d5\u30a1\u3092\u751f\u6210\u3059\u308b\n            byte[] responseApdu = new byte[le + SUCCESS_SW.length];\n", "            if (mCcSelected && offset == 0 && le == CC_FILE.length) {\n                // CC\u9078\u629e\u6642\u306f\u30aa\u30d5\u30bb\u30c3\u30c8\u304c0\u3001\u9577\u3055\u304c\u30d5\u30a1\u30a4\u30eb\u9577(15)\u3068\u4e00\u81f4\u3057\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\n                System.arraycopy(CC_FILE, offset, responseApdu, 0, le);\n                System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n\n                return responseApdu;\n            } else if (mNdefSelected) {\n                if (offset + le <= mNdefRecordFile.length) {\n                    System.arraycopy(mNdefRecordFile, offset, responseApdu, 0, le);\n                    System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n\n                    return responseApdu;\n                }\n            }\n        }\n\n        // \u30a8\u30e9\u30fc\u3092\u8fd4\u3059\n        // \u672c\u6765\u3001IC\u30ab\u30fc\u30c9\u30a2\u30d7\u30ea\u3067\u306f\u30a8\u30e9\u30fc\u7a2e\u5225\u306b\u3042\u308f\u305b\u3066\u30a8\u30e9\u30fc\u306e\u5024\u3092\u5909\u3048\u306a\u3051\u308c\u3070\n        // \u306a\u3089\u306a\u3044\u304c\u3001\u3053\u3053\u3067\u306f\u7701\u7565\u3057\u3066\u4e00\u7a2e\u985e\u306e\u307f\u3092\u8fd4\u3057\u3066\u3044\u308b\u3002\n        return FAILURE_SW;\n    }\n\n    /**\n     * \u30ab\u30fc\u30c9\u30a2\u30d7\u30ea\u304c\u975e\u9078\u629e\u72b6\u614b\u306b\u306a\u3063\u305f\u6642\u306b\u547c\u3070\u308c\u308b\u3002\n     * \u672c\u30a2\u30d7\u30ea\u3067\u306f\u72b6\u614b\u3092\u30ea\u30bb\u30c3\u30c8\u3057\u3066\u521d\u671f\u72b6\u614b\u306b\u623b\u3057\u307e\u3059\u3002\n     */\n    @Override", "    public void onDeactivated(int reason) {\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n    }\n}\n"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/HomeFragment.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.os.Bundle;\n\nimport androidx.fragment.app.Fragment;\n\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n", "import android.view.ViewGroup;\n\n/**\n * A simple {@link Fragment} subclass.\n * Use the {@link HomeFragment#newInstance} factory method to\n * create an instance of this fragment.\n */\npublic class HomeFragment extends Fragment {\n\n    // TODO: Rename parameter arguments, choose names that match\n    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER\n    private static final String ARG_PARAM1 = \"param1\";\n    private static final String ARG_PARAM2 = \"param2\";\n\n    // TODO: Rename and change types of parameters\n    private String mParam1;\n    private String mParam2;\n\n    public HomeFragment() {\n        // Required empty public constructor\n    }\n\n    /**\n     * Use this factory method to create a new instance of\n     * this fragment using the provided parameters.\n     *\n     * @param param1 Parameter 1.\n     * @param param2 Parameter 2.\n     * @return A new instance of fragment HomeFragment.\n     */\n    // TODO: Rename and change types and number of parameters", "    public static HomeFragment newInstance(String param1, String param2) {\n        HomeFragment fragment = new HomeFragment();\n        Bundle args = new Bundle();\n        args.putString(ARG_PARAM1, param1);\n        args.putString(ARG_PARAM2, param2);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);", "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (getArguments() != null) {\n            mParam1 = getArguments().getString(ARG_PARAM1);\n            mParam2 = getArguments().getString(ARG_PARAM2);\n        }\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_home, container, false);\n    }\n}", "    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_home, container, false);\n    }\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/ReceiveExtendedFragment.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport static android.content.Context.VIBRATOR_SERVICE;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.nfc.FormatException;\nimport android.nfc.NdefMessage;\nimport android.nfc.NdefRecord;\nimport android.nfc.NfcAdapter;", "import android.nfc.NdefRecord;\nimport android.nfc.NfcAdapter;\nimport android.nfc.Tag;\nimport android.nfc.tech.IsoDep;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.VibrationEffect;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.view.LayoutInflater;", "import android.provider.Settings;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n", "import androidx.fragment.app.Fragment;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\n/**\n * A simple {@link Fragment} subclass.\n * Use the {@link ReceiveExtendedFragment#newInstance} factory method to\n * create an instance of this fragment.", " * Use the {@link ReceiveExtendedFragment#newInstance} factory method to\n * create an instance of this fragment.\n */\npublic class ReceiveExtendedFragment extends Fragment implements NfcAdapter.ReaderCallback {\n\n    // TODO: Rename parameter arguments, choose names that match\n    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER\n    private static final String ARG_PARAM1 = \"param1\";\n    private static final String ARG_PARAM2 = \"param2\";\n\n    // TODO: Rename and change types of parameters\n    private String mParam1;\n    private String mParam2;\n\n    public ReceiveExtendedFragment() {\n        // Required empty public constructor\n    }\n\n    /**\n     * Use this factory method to create a new instance of\n     * this fragment using the provided parameters.\n     *\n     * @param param1 Parameter 1.\n     * @param param2 Parameter 2.\n     * @return A new instance of fragment ReceiveFragment.\n     */\n    // TODO: Rename and change types and number of parameters", "    public static ReceiveExtendedFragment newInstance(String param1, String param2) {\n        ReceiveExtendedFragment fragment = new ReceiveExtendedFragment();\n        Bundle args = new Bundle();\n        args.putString(ARG_PARAM1, param1);\n        args.putString(ARG_PARAM2, param2);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    TextView readResult;\n    private NfcAdapter mNfcAdapter;\n    String dumpExportString = \"\";\n    String tagIdString = \"\";\n    String tagTypeString = \"\";\n    private static final int REQUEST_PERMISSION_WRITE_EXTERNAL_STORAGE = 100;\n    Context contextSave;\n\n    @Override", "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (getArguments() != null) {\n            mParam1 = getArguments().getString(ARG_PARAM1);\n            mParam2 = getArguments().getString(ARG_PARAM2);\n        }\n        mNfcAdapter = NfcAdapter.getDefaultAdapter(this.getContext());\n    }\n\n    @Override\n    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        readResult = getView().findViewById(R.id.tvReceiveReadResult);\n    }\n\n    @Override", "    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        readResult = getView().findViewById(R.id.tvReceiveReadResult);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_receive_extended, container, false);\n    }\n\n    // This method is running in another thread when a card is discovered\n    // !!!! This method cannot cannot direct interact with the UI Thread\n    // Use `runOnUiThread` method to change the UI from this method\n    @Override", "    public void onTagDiscovered(Tag tag) {\n        // Read and or write to Tag here to the appropriate Tag Technology type class\n        // in this example the card should be an Ndef Technology Type\n\n        System.out.println(\"NFC tag discovered\");\n        getActivity().runOnUiThread(() -> {\n            readResult.setText(\"\");\n        });\n\n        IsoDep isoDep = null;\n        writeToUiAppend(readResult, \"Tag found\");\n        String[] techList = tag.getTechList();", "        for (int i = 0; i < techList.length; i++) {\n            writeToUiAppend(readResult, \"TechList: \" + techList[i]);\n        }\n        String tagId = Utils.bytesToHex(tag.getId());\n        writeToUiAppend(readResult, \"TagId: \" + tagId);\n\n        try {\n            isoDep = IsoDep.get(tag);\n\n            if (isoDep != null) {\n                getActivity().runOnUiThread(() -> {\n                    Toast.makeText(this.getContext(),\n                            \"NFC tag is IsoDep compatible\",\n                            Toast.LENGTH_SHORT).show();\n                });\n\n                isoDep.connect();\n                dumpExportString = \"\";\n                getActivity().runOnUiThread(() -> {\n                    //readResult.setText(\"\");\n                });\n\n\n                writeToUiAppend(readResult, \"IsoDep reading\");\n                String nfcaContent = \"IsoDep reading\" + \"\\n\";\n\n                // now we run the select command with AID\n                String nfcHceNdefAid = \"D2760000850101\";\n                byte[] aid = Utils.hexStringToByteArray(nfcHceNdefAid);\n\n                byte[] command = selectApdu(aid);\n                byte[] responseSelect = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"selectApdu with AID: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"selectApdu response: \" + Utils.bytesToHex(responseSelect));\n", "            if (isoDep != null) {\n                getActivity().runOnUiThread(() -> {\n                    Toast.makeText(this.getContext(),\n                            \"NFC tag is IsoDep compatible\",\n                            Toast.LENGTH_SHORT).show();\n                });\n\n                isoDep.connect();\n                dumpExportString = \"\";\n                getActivity().runOnUiThread(() -> {\n                    //readResult.setText(\"\");\n                });\n\n\n                writeToUiAppend(readResult, \"IsoDep reading\");\n                String nfcaContent = \"IsoDep reading\" + \"\\n\";\n\n                // now we run the select command with AID\n                String nfcHceNdefAid = \"D2760000850101\";\n                byte[] aid = Utils.hexStringToByteArray(nfcHceNdefAid);\n\n                byte[] command = selectApdu(aid);\n                byte[] responseSelect = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"selectApdu with AID: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"selectApdu response: \" + Utils.bytesToHex(responseSelect));\n", "                if (responseSelect == null) {\n                    writeToUiAppend(readResult, \"selectApdu with AID fails (null)\");\n                } else {\n                    writeToUiAppend(readResult, \"responseSelect length: \" + responseSelect.length + \" data: \" + Utils.bytesToHex(responseSelect));\n                    System.out.println(\"responseSelect: \" + Utils.bytesToHex(responseSelect));\n                }\n\n                if (!Utils.isSucceed(responseSelect)) {\n                    writeToUiAppend(readResult, \"responseSelect is not 90 00 - aborted\");\n                    System.out.println(\"responseSelect is not 90 00 - aborted \");\n                    return;\n                }\n\n                // sending cc select = get the capability container\n                String selectCapabilityContainer = \"00a4000c02e103\";\n                command = Utils.hexStringToByteArray(selectCapabilityContainer);\n                byte[] responseSelectCc = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"select CC: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"select CC response: \" + Utils.bytesToHex(responseSelectCc));\n                writeToUiAppend(readResult, \"responseSelect length: \" + responseSelectCc.length + \" data: \" + Utils.bytesToHex(responseSelectCc));\n                System.out.println(\"responseSelectCc: \" + Utils.bytesToHex(responseSelectCc));\n", "                if (!Utils.isSucceed(responseSelectCc)) {\n                    writeToUiAppend(readResult, \"responseSelectCc is not 90 00 - aborted\");\n                    System.out.println(\"responseSelectCc is not 90 00 - aborted \");\n                    return;\n                }\n\n                // Sending ReadBinary from CC...\n                String sendBinareFromCc = \"00b000000f\";\n                command = Utils.hexStringToByteArray(sendBinareFromCc);\n                byte[] responseSendBinaryFromCc = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"sendBinaryFromCc: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"sendBinaryFromCc response: \" + Utils.bytesToHex(responseSendBinaryFromCc));\n                writeToUiAppend(readResult, \"sendBinaryFromCc response length: \" + responseSendBinaryFromCc.length + \" data: \" + Utils.bytesToHex(responseSendBinaryFromCc));\n                System.out.println(\"sendBinaryFromCc response: \" + Utils.bytesToHex(responseSendBinaryFromCc));\n", "                if (!Utils.isSucceed(responseSendBinaryFromCc)) {\n                    writeToUiAppend(readResult, \"responseSendBinaryFromCc is not 90 00 - aborted\");\n                    System.out.println(\"responseSendBinaryFromCc is not 90 00 - aborted \");\n                    return;\n                }\n\n                // Capability Container header:\n                byte[] capabilityContainerHeader = Arrays.copyOfRange(responseSendBinaryFromCc, 0, responseSendBinaryFromCc.length - 2);\n                writeToUiAppend(readResult, \"capabilityContainerHeader length: \" + capabilityContainerHeader.length + \" data: \" + Utils.bytesToHex(capabilityContainerHeader));\n                System.out.println(\"capabilityContainerHeader: \" + Utils.bytesToHex(capabilityContainerHeader));\n                System.out.println(\"capabilityContainerHeader: \" + new String(capabilityContainerHeader));\n\n                // Sending NDEF Select...\n                String sendNdefSelect = \"00a4000c02e104\";\n                command = Utils.hexStringToByteArray(sendNdefSelect);\n                byte[] responseSendNdefSelect = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"sendNdefSelect: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"sendNdefSelect response: \" + Utils.bytesToHex(responseSendNdefSelect));\n                writeToUiAppend(readResult, \"sendNdefSelect response length: \" + responseSendNdefSelect.length + \" data: \" + Utils.bytesToHex(responseSendNdefSelect));\n                System.out.println(\"sendNdefSelect response: \" + Utils.bytesToHex(responseSendNdefSelect));\n", "                if (!Utils.isSucceed(responseSendNdefSelect)) {\n                    writeToUiAppend(readResult, \"responseSendNdefSelect is not 90 00 - aborted\");\n                    System.out.println(\"responseSendNdefSelect is not 90 00 - aborted \");\n                    return;\n                }\n\n                // Sending ReadBinary NLEN...\n                String sendReadBinaryNlen = \"00b0000002\";\n                command = Utils.hexStringToByteArray(sendReadBinaryNlen);\n                byte[] responseSendBinaryNlen = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"sendBinaryNlen: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"sendBinaryNlen response: \" + Utils.bytesToHex(responseSendBinaryNlen));\n                writeToUiAppend(readResult, \"sendBinaryNlen response length: \" + responseSendBinaryNlen.length + \" data: \" + Utils.bytesToHex(responseSendBinaryNlen));\n                System.out.println(\"sendBinaryNlen response: \" + Utils.bytesToHex(responseSendBinaryNlen));\n", "                if (!Utils.isSucceed(responseSendBinaryNlen)) {\n                    writeToUiAppend(readResult, \"responseSendBinaryNlen is not 90 00 - aborted\");\n                    System.out.println(\"responseSendBinaryNlen is not 90 00 - aborted \");\n                    return;\n                }\n\n                // Sending ReadBinary, get NDEF data...\n                byte[] ndefLen = Arrays.copyOfRange(responseSendBinaryNlen, 0, 2);\n                byte[] cmdLen = Utils.hexStringToByteArray(sendReadBinaryNlen);\n                int ndefLenInt = new BigInteger(ndefLen).intValue();\n                writeToUiAppend(readResult,\"ndefLen: \" + Utils.bytesToHex(ndefLen) + \" len (dec): \" + ndefLenInt);\n                int ndefLenIntRequest = ndefLenInt + 2;\n                //byte[] cmdLenNew = BigInteger.valueOf(ndefLenIntRequest).toByteArray();\n                byte[] cmdLenNew = Utils.convertIntToByteArray(ndefLenIntRequest, 2);\n                writeToUiAppend(readResult,\"ndefLen new (dec): \" + ndefLenIntRequest + \" data: \" + Utils.bytesToHex(cmdLenNew) );\n\n                String sendReadBinaryNdefData = \"00b000\" + Utils.bytesToHex(cmdLenNew);\n                //String sendReadBinaryNdefData = \"00b000000f\";\n                //String sendReadBinaryNdefData = \"00b0000092\";\n                command = Utils.hexStringToByteArray(sendReadBinaryNdefData);\n                byte[] responseSendBinaryNdefData = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"sendBinaryNdefData: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"sendBinaryNdefData response: \" + Utils.bytesToHex(responseSendBinaryNdefData));\n                writeToUiAppend(readResult, \"sendBinaryNdefData response length: \" + responseSendBinaryNdefData.length + \" data: \" + Utils.bytesToHex(responseSendBinaryNdefData));\n                writeToUiAppend(readResult, \"sendBinaryNdefData response: \" + new String(responseSendBinaryNdefData));\n                System.out.println(\"sendBinaryNdefData response: \" + Utils.bytesToHex(responseSendBinaryNdefData));\n                System.out.println(\"sendBinaryNdefData response: \" + new String(responseSendBinaryNdefData));\n", "                if (!Utils.isSucceed(responseSendBinaryNdefData)) {\n                    writeToUiAppend(readResult, \"responseSendBinaryNdefData is not 90 00 - aborted\");\n                    System.out.println(\"responseSendBinaryNdefData is not 90 00 - aborted \");\n                    return;\n                }\n\n                byte[] ndefMessage = Arrays.copyOfRange(responseSendBinaryNdefData, 0, responseSendBinaryNdefData.length - 2);\n                writeToUiAppend(readResult, \"ndefMessage length: \" + ndefMessage.length + \" data: \" + Utils.bytesToHex(ndefMessage));\n                writeToUiAppend(readResult, \"ndefMessage: \" + new String(ndefMessage));\n                System.out.println(\"ndefMessage: \" + new String(ndefMessage));\n\n                // strip off the first 2 bytes\n                byte[] ndefMessageStrip = Arrays.copyOfRange(ndefMessage, 9, ndefMessage.length);\n\n                //String ndefMessageParsed = Utils.parseTextrecordPayload(ndefMessageStrip);\n                String ndefMessageParsed = new String(ndefMessageStrip);\n                writeToUiAppend(readResult, \"ndefMessage parsed: \" + ndefMessageParsed);\n                System.out.println(\"ndefMessage parsed: \" + ndefMessageParsed);\n\n                // try to get a NdefMessage from the byte array\n                byte[] ndefMessageByteArray = Arrays.copyOfRange(ndefMessage, 2, ndefMessage.length);", "                try {\n                    NdefMessage ndefMessageFromTag = new NdefMessage(ndefMessageByteArray);\n                    NdefRecord[] ndefRecords = ndefMessageFromTag.getRecords();\n                    NdefRecord ndefRecord;\n                    int ndefRecordsCount = ndefRecords.length;\n                    if (ndefRecordsCount > 0) {\n                        for (int i = 0; i < ndefRecordsCount; i++) {\n                            short ndefTnf = ndefRecords[i].getTnf();\n                            byte[] ndefType = ndefRecords[i].getType();\n                            byte[] ndefPayload = ndefRecords[i].getPayload();\n                            // here we are trying to parse the content\n                            // Well known type - Text", "                            if (ndefTnf == NdefRecord.TNF_WELL_KNOWN &&\n                                    Arrays.equals(ndefType, NdefRecord.RTD_TEXT)) {\n                                writeToUiAppend(readResult, \"rec: \" + i +\n                                        \" Well known Text payload\\n\" + new String(ndefPayload) + \" \\n\");\n                                writeToUiAppend(readResult, Utils.parseTextrecordPayload(ndefPayload));\n                            }\n                            // Well known type - Uri\n                            if (ndefTnf == NdefRecord.TNF_WELL_KNOWN &&\n                                    Arrays.equals(ndefType, NdefRecord.RTD_URI)) {\n                                writeToUiAppend(readResult, \"rec: \" + i +\n                                        \" Well known Uri payload\\n\" + new String(ndefPayload) + \" \\n\");\n                                writeToUiAppend(readResult, Utils.parseUrirecordPayload(ndefPayload) + \" \\n\");\n                            }\n                        }\n                        dumpExportString = readResult.getText().toString();\n                    }\n                    //dumpExportString = readResult.getText().toString();\n\n                } catch (FormatException e) {\n                    e.printStackTrace();\n                }\n                doVibrate();\n            } else {\n                writeToUiAppend(readResult, \"IsoDep == null\");\n            }\n        } catch (IOException e) {\n            writeToUiAppend(readResult, \"ERROR IOException: \" + e);\n            e.printStackTrace();\n        }\n    }\n\n    // https://stackoverflow.com/a/51338700/8166854\n    private byte[] selectApdu(byte[] aid) {\n        byte[] commandApdu = new byte[6 + aid.length];\n        commandApdu[0] = (byte) 0x00;  // CLA\n        commandApdu[1] = (byte) 0xA4;  // INS\n        commandApdu[2] = (byte) 0x04;  // P1\n        commandApdu[3] = (byte) 0x00;  // P2\n        commandApdu[4] = (byte) (aid.length & 0x0FF);       // Lc\n        System.arraycopy(aid, 0, commandApdu, 5, aid.length);\n        commandApdu[commandApdu.length - 1] = (byte) 0x00;  // Le\n        return commandApdu;\n    }\n\n    private void doVibrate() {", "        if (getActivity() != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                ((Vibrator) getActivity().getSystemService(VIBRATOR_SERVICE)).vibrate(VibrationEffect.createOneShot(150, 10));\n            } else {\n                Vibrator v = (Vibrator) getActivity().getSystemService(VIBRATOR_SERVICE);\n                v.vibrate(200);\n            }\n        }\n    }\n\n    private void writeToUiAppend(TextView textView, String message) {\n        getActivity().runOnUiThread(() -> {\n            String newString = textView.getText().toString() + \"\\n\" + message;\n            textView.setText(newString);\n            dumpExportString = newString;\n        });\n    }\n\n    private void writeToUiAppendReverse(TextView textView, String message) {\n        getActivity().runOnUiThread(() -> {\n            String newString = message + \"\\n\" + textView.getText().toString();\n            textView.setText(newString);\n        });\n    }\n\n    private void writeToUiToast(String message) {\n        getActivity().runOnUiThread(() -> {\n            Toast.makeText(this.getContext(),\n                    message,\n                    Toast.LENGTH_SHORT).show();\n        });\n    }\n\n    private void showWirelessSettings() {\n        Toast.makeText(this.getContext(), \"You need to enable NFC\", Toast.LENGTH_SHORT).show();\n        Intent intent = new Intent(Settings.ACTION_WIRELESS_SETTINGS);\n        startActivity(intent);\n    }\n\n    @Override", "    public void onResume() {\n        super.onResume();\n\n        if (mNfcAdapter != null) {\n\n            if (!mNfcAdapter.isEnabled())\n                showWirelessSettings();\n\n            Bundle options = new Bundle();\n            // Work around for some broken Nfc firmware implementations that poll the card too fast\n            options.putInt(NfcAdapter.EXTRA_READER_PRESENCE_CHECK_DELAY, 250);\n\n            // Enable ReaderMode for all types of card and disable platform sounds\n            // the option NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK is NOT set\n            // to get the data of the tag afer reading\n            mNfcAdapter.enableReaderMode(this.getActivity(),\n                    this,\n                    NfcAdapter.FLAG_READER_NFC_A |\n                            NfcAdapter.FLAG_READER_NFC_B |\n                            NfcAdapter.FLAG_READER_NFC_F |\n                            NfcAdapter.FLAG_READER_NFC_V |\n                            NfcAdapter.FLAG_READER_NFC_BARCODE |\n                            NfcAdapter.FLAG_READER_NO_PLATFORM_SOUNDS,\n                    options);\n        }\n    }\n\n    @Override", "    public void onPause() {\n        super.onPause();\n        if (mNfcAdapter != null)\n            mNfcAdapter.disableReaderMode(this.getActivity());\n    }\n\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/Utils.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.os.Build;\n\nimport java.lang.reflect.Array;\nimport java.nio.charset.StandardCharsets;\nimport java.text.SimpleDateFormat;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;", "import java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Arrays;\nimport java.util.Date;\n\npublic class Utils {\n\n    public static String getTimestamp() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            return ZonedDateTime\n                    .now(ZoneId.systemDefault())\n                    .format(DateTimeFormatter.ofPattern(\"uuuu.MM.dd HH:mm:ss\"));\n        } else {\n            return new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss\").format(new Date());\n        }\n    }\n", "        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            return ZonedDateTime\n                    .now(ZoneId.systemDefault())\n                    .format(DateTimeFormatter.ofPattern(\"uuuu.MM.dd HH:mm:ss\"));\n        } else {\n            return new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss\").format(new Date());\n        }\n    }\n\n    public static String removeAllNonAlphaNumeric(String s) {\n        if (s == null) {\n            return null;\n        }\n        return s.replaceAll(\"[^A-Za-z0-9]\", \"\");\n    }\n\n    // position is 0 based starting from right to left", "    public static String removeAllNonAlphaNumeric(String s) {\n        if (s == null) {\n            return null;\n        }\n        return s.replaceAll(\"[^A-Za-z0-9]\", \"\");\n    }\n\n    // position is 0 based starting from right to left\n    public static byte setBitInByte(byte input, int pos) {\n        return (byte) (input | (1 << pos));\n    }\n\n    // position is 0 based starting from right to left", "    public static byte setBitInByte(byte input, int pos) {\n        return (byte) (input | (1 << pos));\n    }\n\n    // position is 0 based starting from right to left\n    public static byte unsetBitInByte(byte input, int pos) {\n        return (byte) (input & ~(1 << pos));\n    }\n\n    // https://stackoverflow.com/a/29396837/8166854\n    public static boolean testBit(byte b, int n) {\n        int mask = 1 << n; // equivalent of 2 to the nth power\n        return (b & mask) != 0;\n    }\n\n    // https://stackoverflow.com/a/29396837/8166854", "    public static boolean testBit(byte b, int n) {\n        int mask = 1 << n; // equivalent of 2 to the nth power\n        return (b & mask) != 0;\n    }\n\n    // https://stackoverflow.com/a/29396837/8166854\n    public static boolean testBit(byte[] array, int n) {\n        int index = n >>> 3; // divide by 8\n        int mask = 1 << (n & 7); // n modulo 8\n        return (array[index] & mask) != 0;\n    }\n", "    public static String bytesToHex(byte[] bytes) {\n        StringBuffer result = new StringBuffer();\n        for (byte b : bytes)\n            result.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));\n        return result.toString();\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                    + Character.digit(s.charAt(i + 1), 16));\n        }\n        return data;\n    }\n", "        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                    + Character.digit(s.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n    public static String getDec(byte[] bytes) {\n        long result = 0;\n        long factor = 1;\n        for (int i = 0; i < bytes.length; ++i) {\n            long value = bytes[i] & 0xffl;\n            result += value * factor;\n            factor *= 256l;\n        }\n        return result + \"\";\n    }\n", "        for (int i = 0; i < bytes.length; ++i) {\n            long value = bytes[i] & 0xffl;\n            result += value * factor;\n            factor *= 256l;\n        }\n        return result + \"\";\n    }\n\n    public static String printByteBinary(byte bytes){\n        byte[] data = new byte[1];\n        data[0] = bytes;\n        return printByteArrayBinary(data);\n    }\n", "    public static String printByteBinary(byte bytes){\n        byte[] data = new byte[1];\n        data[0] = bytes;\n        return printByteArrayBinary(data);\n    }\n\n    public static String printByteArrayBinary(byte[] bytes){\n        String output = \"\";\n        for (byte b1 : bytes){\n            String s1 = String.format(\"%8s\", Integer.toBinaryString(b1 & 0xFF)).replace(' ', '0');\n            //s1 += \" \" + Integer.toHexString(b1);\n            //s1 += \" \" + b1;\n            output = output + \" \" + s1;\n            //System.out.println(s1);\n        }\n        return output;\n    }\n", "        for (byte b1 : bytes){\n            String s1 = String.format(\"%8s\", Integer.toBinaryString(b1 & 0xFF)).replace(' ', '0');\n            //s1 += \" \" + Integer.toHexString(b1);\n            //s1 += \" \" + b1;\n            output = output + \" \" + s1;\n            //System.out.println(s1);\n        }\n        return output;\n    }\n\n    public static byte[] convertIntToByteArray(int value, int numberOfBytes) {\n        byte b[] = new byte[numberOfBytes];\n        int i, shift;", "    public static byte[] convertIntToByteArray(int value, int numberOfBytes) {\n        byte b[] = new byte[numberOfBytes];\n        int i, shift;\n        for (i = 0, shift = (b.length - 1) * 8; i < b.length; i++, shift -= 8) {\n            b[i] = (byte) (0xFF & (value >> shift));\n        }\n        return b;\n    }\n\n    public static String parseTextrecordPayload(byte[] ndefPayload) {\n        int languageCodeLength = Array.getByte(ndefPayload, 0);\n        int ndefPayloadLength = ndefPayload.length;\n        byte[] languageCode = new byte[languageCodeLength];\n        System.arraycopy(ndefPayload, 1, languageCode, 0, languageCodeLength);\n        byte[] message = new byte[ndefPayloadLength - 1 - languageCodeLength];\n        System.arraycopy(ndefPayload, 1 + languageCodeLength, message, 0, ndefPayloadLength - 1 - languageCodeLength);\n        return new String(message, StandardCharsets.UTF_8);\n    }\n\n    /**\n     * NFC Forum \"URI Record Type Definition\"<p>\n     * This is a mapping of \"URI Identifier Codes\" to URI string prefixes,\n     * per section 3.2.2 of the NFC Forum URI Record Type Definition document.\n     */\n    // source: https://github.com/skjolber/ndef-tools-for-android\n    private static final String[] URI_PREFIX_MAP = new String[] {\n            \"\", // 0x00\n            \"http://www.\", // 0x01\n            \"https://www.\", // 0x02\n            \"http://\", // 0x03\n            \"https://\", // 0x04\n            \"tel:\", // 0x05\n            \"mailto:\", // 0x06\n            \"ftp://anonymous:anonymous@\", // 0x07\n            \"ftp://ftp.\", // 0x08\n            \"ftps://\", // 0x09\n            \"sftp://\", // 0x0A\n            \"smb://\", // 0x0B\n            \"nfs://\", // 0x0C\n            \"ftp://\", // 0x0D\n            \"dav://\", // 0x0E\n            \"news:\", // 0x0F\n            \"telnet://\", // 0x10\n            \"imap:\", // 0x11\n            \"rtsp://\", // 0x12\n            \"urn:\", // 0x13\n            \"pop:\", // 0x14\n            \"sip:\", // 0x15\n            \"sips:\", // 0x16\n            \"tftp:\", // 0x17\n            \"btspp://\", // 0x18\n            \"btl2cap://\", // 0x19\n            \"btgoep://\", // 0x1A\n            \"tcpobex://\", // 0x1B\n            \"irdaobex://\", // 0x1C\n            \"file://\", // 0x1D\n            \"urn:epc:id:\", // 0x1E\n            \"urn:epc:tag:\", // 0x1F\n            \"urn:epc:pat:\", // 0x20\n            \"urn:epc:raw:\", // 0x21\n            \"urn:epc:\", // 0x22\n    };\n", "    public static String parseTextrecordPayload(byte[] ndefPayload) {\n        int languageCodeLength = Array.getByte(ndefPayload, 0);\n        int ndefPayloadLength = ndefPayload.length;\n        byte[] languageCode = new byte[languageCodeLength];\n        System.arraycopy(ndefPayload, 1, languageCode, 0, languageCodeLength);\n        byte[] message = new byte[ndefPayloadLength - 1 - languageCodeLength];\n        System.arraycopy(ndefPayload, 1 + languageCodeLength, message, 0, ndefPayloadLength - 1 - languageCodeLength);\n        return new String(message, StandardCharsets.UTF_8);\n    }\n\n    /**\n     * NFC Forum \"URI Record Type Definition\"<p>\n     * This is a mapping of \"URI Identifier Codes\" to URI string prefixes,\n     * per section 3.2.2 of the NFC Forum URI Record Type Definition document.\n     */\n    // source: https://github.com/skjolber/ndef-tools-for-android\n    private static final String[] URI_PREFIX_MAP = new String[] {\n            \"\", // 0x00\n            \"http://www.\", // 0x01\n            \"https://www.\", // 0x02\n            \"http://\", // 0x03\n            \"https://\", // 0x04\n            \"tel:\", // 0x05\n            \"mailto:\", // 0x06\n            \"ftp://anonymous:anonymous@\", // 0x07\n            \"ftp://ftp.\", // 0x08\n            \"ftps://\", // 0x09\n            \"sftp://\", // 0x0A\n            \"smb://\", // 0x0B\n            \"nfs://\", // 0x0C\n            \"ftp://\", // 0x0D\n            \"dav://\", // 0x0E\n            \"news:\", // 0x0F\n            \"telnet://\", // 0x10\n            \"imap:\", // 0x11\n            \"rtsp://\", // 0x12\n            \"urn:\", // 0x13\n            \"pop:\", // 0x14\n            \"sip:\", // 0x15\n            \"sips:\", // 0x16\n            \"tftp:\", // 0x17\n            \"btspp://\", // 0x18\n            \"btl2cap://\", // 0x19\n            \"btgoep://\", // 0x1A\n            \"tcpobex://\", // 0x1B\n            \"irdaobex://\", // 0x1C\n            \"file://\", // 0x1D\n            \"urn:epc:id:\", // 0x1E\n            \"urn:epc:tag:\", // 0x1F\n            \"urn:epc:pat:\", // 0x20\n            \"urn:epc:raw:\", // 0x21\n            \"urn:epc:\", // 0x22\n    };\n", "    public static String parseUrirecordPayload(byte[] ndefPayload) {\n        int uriPrefix = Array.getByte(ndefPayload, 0);\n        int ndefPayloadLength = ndefPayload.length;\n        byte[] message = new byte[ndefPayloadLength - 1];\n        System.arraycopy(ndefPayload, 1, message, 0, ndefPayloadLength - 1);\n        return URI_PREFIX_MAP[uriPrefix] + new String(message, StandardCharsets.UTF_8);\n    }\n\n    private static final byte[] SW_9000 = {\n            (byte)0x90,  // SW1\tStatus byte 1 - Command processing status\n            (byte)0x00   // SW2\tStatus byte 2 - Command processing qualifier\n    };\n\n    /**\n     * Method used to check if the last command return SW1SW2 == 9000\n     *\n     * @param pByte\n     *            response to the last command\n     * @return true if the status is 9000 false otherwise\n     */", "    public static boolean isSucceed(final byte[] pByte) {\n        byte[] resultValue = Arrays.copyOfRange(pByte, pByte.length - 2, pByte.length);\n        if (Arrays.equals(resultValue, SW_9000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Constant-time Byte Array Comparison\n     * Less overheard, safer. Originally from: http://codahale.com/a-lesson-in-timing-attacks/\n     *\n     * @param a yourByteArrayA\n     * @param b yourByteArrayB\n     * @return boolean\n     *\n     */", "    public static boolean isEqual(byte[] a, byte[] b) {\n        if (a.length != b.length) {\n            return false;\n        }\n\n        int result = 0;\n        for (int i = 0; i < a.length; i++) {\n            result |= a[i] ^ b[i];\n        }\n        return result == 0;\n    }\n}\n"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/SendFragment.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.os.Bundle;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;", "import androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n\nimport android.text.TextUtils;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.CompoundButton;\nimport android.widget.RadioButton;", "import android.widget.CompoundButton;\nimport android.widget.RadioButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Objects;\nimport java.util.Timer;\nimport java.util.TimerTask;", "import java.util.Timer;\nimport java.util.TimerTask;\n\n/**\n * A simple {@link Fragment} subclass.\n * Use the {@link SendFragment#newInstance} factory method to\n * create an instance of this fragment.\n */\npublic class SendFragment extends Fragment {\n\n    // TODO: Rename parameter arguments, choose names that match\n    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER\n    private static final String ARG_PARAM1 = \"param1\";\n    private static final String ARG_PARAM2 = \"param2\";\n\n    // TODO: Rename and change types of parameters\n    private String mParam1;\n    private String mParam2;\n\n    RadioButton rbTimestamp, rbMessage, rbUrl;\n    TextView tvTimestamp;\n    boolean isTimestamp = false; // start/default\n    com.google.android.material.textfield.TextInputLayout dataToSendLayout;\n    com.google.android.material.textfield.TextInputEditText dataToSend;\n    //private final String DEFAULT_URL = \"https://www.google.de/maps/@34.7967917,-111.765671,3a,66.6y,15.7h,102.19t/data=!3m6!1e1!3m4!1sFV61wUEyLNwFi6zHHaKMcg!2e0!7i16384!8i8192\";\n    private final String DEFAULT_URL = \"https://github.com/AndroidCrypto?tab=repositories\";\n\n    public SendFragment() {\n        // Required empty public constructor\n    }\n\n    /**\n     * Use this factory method to create a new instance of\n     * this fragment using the provided parameters.\n     *\n     * @param param1 Parameter 1.\n     * @param param2 Parameter 2.\n     * @return A new instance of fragment SendFragment.\n     */\n    // TODO: Rename and change types and number of parameters", "public class SendFragment extends Fragment {\n\n    // TODO: Rename parameter arguments, choose names that match\n    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER\n    private static final String ARG_PARAM1 = \"param1\";\n    private static final String ARG_PARAM2 = \"param2\";\n\n    // TODO: Rename and change types of parameters\n    private String mParam1;\n    private String mParam2;\n\n    RadioButton rbTimestamp, rbMessage, rbUrl;\n    TextView tvTimestamp;\n    boolean isTimestamp = false; // start/default\n    com.google.android.material.textfield.TextInputLayout dataToSendLayout;\n    com.google.android.material.textfield.TextInputEditText dataToSend;\n    //private final String DEFAULT_URL = \"https://www.google.de/maps/@34.7967917,-111.765671,3a,66.6y,15.7h,102.19t/data=!3m6!1e1!3m4!1sFV61wUEyLNwFi6zHHaKMcg!2e0!7i16384!8i8192\";\n    private final String DEFAULT_URL = \"https://github.com/AndroidCrypto?tab=repositories\";\n\n    public SendFragment() {\n        // Required empty public constructor\n    }\n\n    /**\n     * Use this factory method to create a new instance of\n     * this fragment using the provided parameters.\n     *\n     * @param param1 Parameter 1.\n     * @param param2 Parameter 2.\n     * @return A new instance of fragment SendFragment.\n     */\n    // TODO: Rename and change types and number of parameters", "    public static SendFragment newInstance(String param1, String param2) {\n        SendFragment fragment = new SendFragment();\n        Bundle args = new Bundle();\n        args.putString(ARG_PARAM1, param1);\n        args.putString(ARG_PARAM2, param2);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    // AID is setup in apduservice.xml\n    // original AID: F0394148148100\n\n    @Override", "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (getArguments() != null) {\n            mParam1 = getArguments().getString(ARG_PARAM1);\n            mParam2 = getArguments().getString(ARG_PARAM2);\n        }\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_send, container, false);\n    }\n\n    @Override", "    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_send, container, false);\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n\n        tvTimestamp = getView().findViewById(R.id.tvTimestamp);\n        rbTimestamp = getView().findViewById(R.id.rbTimestamp);\n        rbMessage = getView().findViewById(R.id.rbMessage);\n        rbUrl = getView().findViewById(R.id.rbUrl);\n\n        dataToSendLayout = getView().findViewById(R.id.etDataToSendsLayout);\n        dataToSendLayout.setEnabled(false);\n        dataToSend = getView().findViewById(R.id.etDataToSend);\n        dataToSendLayout.setEndIconOnClickListener(new View.OnClickListener() {\n            @Override", "            public void onClick(View view) {\n                String dataToSendString = dataToSend.getText().toString();\n                if (TextUtils.isEmpty(dataToSendString)) {\n                    Toast.makeText(view.getContext(), \"Enter data to send\", Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                if (rbMessage.isChecked()) {\n                    String messageWithTimestamp = dataToSendString + \" on \" +\n                            Utils.getTimestamp();\n                    Intent intent = new Intent(view.getContext(), MyHostApduService.class);\n                    intent.putExtra(\"ndefMessage\", messageWithTimestamp);\n                    Toast.makeText(view.getContext(), \"This message is send as NDEF message: \" + messageWithTimestamp, Toast.LENGTH_SHORT).show();\n                    requireActivity().startService(intent);\n                }", "                if (rbUrl.isChecked()) {\n                    // check for https:// at the beginning\n                    if (!dataToSendString.substring(0, 8).toLowerCase().equals(\"https://\")) {\n                        Toast.makeText(view.getContext(), \"The URL needs to start with https://\", Toast.LENGTH_SHORT).show();\n                        return;\n                    }\n                    Intent intent = new Intent(view.getContext(), MyHostApduService.class);\n                    intent.putExtra(\"ndefUrl\", dataToSendString);\n                    Toast.makeText(view.getContext(), \"This URL is send as NDEF message: \" + dataToSendString, Toast.LENGTH_SHORT).show();\n                    requireActivity().startService(intent);\n                }\n            }\n        });\n\n        rbTimestamp.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override", "            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {\n                if (rbTimestamp.isChecked()) {\n                    dataToSendLayout.setEnabled(false);\n                    dataToSend.setText(\"\");\n                    isTimestamp = true;\n                    Toast.makeText(view.getContext(), \"An actual is send as NDEF message\", Toast.LENGTH_SHORT).show();\n                }\n            }\n        });\n        rbMessage.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override", "            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {\n                if (rbMessage.isChecked()) {\n                    dataToSendLayout.setEnabled(true);\n                    dataToSend.setText(\"\");\n                    isTimestamp = false;\n                }\n            }\n        });\n\n        rbUrl.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override", "            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {\n                if (rbUrl.isChecked()) {\n                    dataToSendLayout.setEnabled(true);\n                    dataToSend.setText(DEFAULT_URL);\n                    isTimestamp = false;\n                }\n            }\n        });\n\n        // start with timestamp\n        ndefWithTimestamp(view.getContext());\n    }\n\n    private void ndefWithTimestamp(Context context) {\n        PackageManager pm = context.getPackageManager();\n        Timer t = new Timer();\n\n        TimerTask task = new TimerTask() {\n            @Override", "            public void run() {\n                if (isTimestamp) {\n                    Date dt = Calendar.getInstance().getTime();\n                    //Log.d(TAG, \"Set time as \" + dt.toString());\n                    tvTimestamp.setText(dt.toString());\n                    if (pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {\n                        Intent intent = new Intent(context, MyHostApduService.class);\n                        intent.putExtra(\"ndefMessage\", dt.toString());\n                        context.startService(intent);\n                    }\n                }\n            }\n\n        };\n        //t.scheduleAtFixedRate(task, 0, 1000); // every second\n        //t.scheduleAtFixedRate(task, 0, 60000); // every minute\n        t.scheduleAtFixedRate(task, 0, 2000); // every 2 seconds\n    }\n\n\n    @Override", "    public void onResume() {\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n    }\n\n    @Override", "    public void onStop() {\n        super.onStop();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n\n}"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/MyHostApduService.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.content.Intent;\nimport android.nfc.NdefMessage;\nimport android.nfc.NdefRecord;\nimport android.nfc.cardemulation.HostApduService;\nimport android.os.Bundle;\nimport android.util.Log;\n\nimport java.util.Arrays;", "\nimport java.util.Arrays;\n\n/**\n * This class emulates a NFC Forum Tag Type 4 containing a NDEF message\n * The class uses the AID D2760000850101\n */\npublic class MyHostApduService extends HostApduService {\n\n    // source: https://github.com/TechBooster/C85-Android-4.4-Sample/blob/master/chapter08/NdefCard/src/com/example/ndefcard/NdefHostApduService.java\n    \n    private final static String TAG = \"MyHostApduService\";\n\n    private static final byte[] SELECT_APPLICATION = {\n            (byte) 0x00, // CLA\t- Class - Class of instruction\n            (byte) 0xA4, // INS\t- Instruction - Instruction code\n            (byte) 0x04, // P1\t- Parameter 1 - Instruction parameter 1\n            (byte) 0x00, // P2\t- Parameter 2 - Instruction parameter 2\n            (byte) 0x07, // Lc field\t- Number of bytes present in the data field of the command\n            (byte) 0xD2, (byte) 0x76, (byte) 0x00, (byte) 0x00, (byte) 0x85, (byte) 0x01, (byte) 0x01, // NDEF Tag Application name D2 76 00 00 85 01 01\n            (byte) 0x00  // Le field\t- Maximum number of bytes expected in the data field of the response to the command\n    };\n\n    private static final byte[] SELECT_CAPABILITY_CONTAINER = {\n            (byte) 0x00, // CLA\t- Class - Class of instruction\n            (byte) 0xa4, // INS\t- Instruction - Instruction code\n            (byte) 0x00, // P1\t- Parameter 1 - Instruction parameter 1\n            (byte) 0x0c, // P2\t- Parameter 2 - Instruction parameter 2\n            (byte) 0x02, // Lc field\t- Number of bytes present in the data field of the command\n            (byte) 0xe1, (byte) 0x03 // file identifier of the CC file\n    };\n\n    private static final byte[] SELECT_NDEF_FILE = {\n            (byte) 0x00, // CLA\t- Class - Class of instruction\n            (byte) 0xa4, // Instruction byte (INS) for Select command\n            (byte) 0x00, // Parameter byte (P1), select by identifier\n            (byte) 0x0c, // Parameter byte (P1), select by identifier\n            (byte) 0x02, // Lc field\t- Number of bytes present in the data field of the command\n            (byte) 0xE1, (byte) 0x04 // file identifier of the NDEF file retrieved from the CC file\n    };\n\n    private final static byte[] CAPABILITY_CONTAINER_FILE = new byte[] {\n            0x00, 0x0f, // CCLEN\n            0x20, // Mapping Version\n            0x00, 0x3b, // Maximum R-APDU data size\n            0x00, 0x34, // Maximum C-APDU data size\n            0x04, 0x06, // Tag & Length\n            (byte)0xe1, 0x04, // NDEF File Identifier\n            (byte) 0x00, (byte) 0xff, // Maximum NDEF size, do NOT extend this value\n            0x00, // NDEF file read access granted\n            (byte)0xff, // NDEF File write access denied\n    };\n\n    // Status Word success\n    private final static byte[] SUCCESS_SW = new byte[] {\n            (byte)0x90,\n            (byte)0x00,\n    };\n    // Status Word failure\n    private final static byte[] FAILURE_SW = new byte[] {\n            (byte)0x6a,\n            (byte)0x82,\n    };\n\n    private byte[] mNdefRecordFile;\n\n    private boolean mAppSelected; // true when SELECT_APPLICATION detected\n\n    private boolean mCcSelected; // true when SELECT_CAPABILITY_CONTAINER detected\n\n    private boolean mNdefSelected; // true when SELECT_NDEF_FILE detected\n\n    @Override", "    public void onCreate() {\n        super.onCreate();\n\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n\n        // default NDEF-message\n        final String DEFAULT_MESSAGE = \"This is the default message from NfcHceNdelEmulator. If you want to change the message use the tab 'Send' to enter an individual message.\";\n        NdefMessage ndefDefaultMessage = getNdefMessage(DEFAULT_MESSAGE);\n        // the maximum length is 246 so do not extend this value\n        int nlen = ndefDefaultMessage.getByteArrayLength();\n        mNdefRecordFile = new byte[nlen + 2];\n        mNdefRecordFile[0] = (byte)((nlen & 0xff00) / 256);\n        mNdefRecordFile[1] = (byte)(nlen & 0xff);\n        System.arraycopy(ndefDefaultMessage.toByteArray(), 0, mNdefRecordFile, 2, ndefDefaultMessage.getByteArrayLength());\n    }\n\n    @Override", "    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (intent != null) {\n            // intent contains a text message\n            if (intent.hasExtra(\"ndefMessage\")) {\n                NdefMessage ndefMessage = getNdefMessage(intent.getStringExtra(\"ndefMessage\"));\n                if (ndefMessage != null) {\n                    int nlen = ndefMessage.getByteArrayLength();\n                    mNdefRecordFile = new byte[nlen + 2];\n                    mNdefRecordFile[0] = (byte) ((nlen & 0xff00) / 256);\n                    mNdefRecordFile[1] = (byte) (nlen & 0xff);\n                    System.arraycopy(ndefMessage.toByteArray(), 0, mNdefRecordFile, 2, ndefMessage.getByteArrayLength());\n                }\n            }\n            // intent contains an URL", "            if (intent.hasExtra(\"ndefUrl\")) {\n                NdefMessage ndefMessage = getNdefUrlMessage(intent.getStringExtra(\"ndefUrl\"));\n                if (ndefMessage != null) {\n                    int nlen = ndefMessage.getByteArrayLength();\n                    mNdefRecordFile = new byte[nlen + 2];\n                    mNdefRecordFile[0] = (byte) ((nlen & 0xff00) / 256);\n                    mNdefRecordFile[1] = (byte) (nlen & 0xff);\n                    System.arraycopy(ndefMessage.toByteArray(), 0, mNdefRecordFile, 2, ndefMessage.getByteArrayLength());\n                }\n            }\n        }\n        return super.onStartCommand(intent, flags, startId);\n    }\n\n    private NdefMessage getNdefMessage(String ndefData) {", "        if (ndefData.length() == 0) {\n            return null;\n        }\n        NdefRecord ndefRecord;\n        ndefRecord = NdefRecord.createTextRecord(\"en\", ndefData);\n        return new NdefMessage(ndefRecord);\n    }\n\n    private NdefMessage getNdefUrlMessage(String ndefData) {\n        if (ndefData.length() == 0) {\n            return null;\n        }\n        NdefRecord ndefRecord;\n        ndefRecord = NdefRecord.createUri(ndefData);\n        return new NdefMessage(ndefRecord);\n    }\n\n    /**\n     * emulates an NFC Forum Tag Type 4\n     */\n    @Override\n    public byte[] processCommandApdu(byte[] commandApdu, Bundle extras) {\n        Log.d((TAG), \"commandApdu: \" + Utils.bytesToHex(commandApdu)); ", "        if (ndefData.length() == 0) {\n            return null;\n        }\n        NdefRecord ndefRecord;\n        ndefRecord = NdefRecord.createUri(ndefData);\n        return new NdefMessage(ndefRecord);\n    }\n\n    /**\n     * emulates an NFC Forum Tag Type 4\n     */\n    @Override\n    public byte[] processCommandApdu(byte[] commandApdu, Bundle extras) {\n        Log.d((TAG), \"commandApdu: \" + Utils.bytesToHex(commandApdu)); ", "        //if (Arrays.equals(SELECT_APP, commandApdu)) {\n        // check if commandApdu qualifies for SELECT_APPLICATION\n        if (Arrays.equals(SELECT_APPLICATION, commandApdu)) {\n            mAppSelected = true;\n            mCcSelected = false;\n            mNdefSelected = false;\n            Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(SUCCESS_SW));\n            return SUCCESS_SW;\n            // check if commandApdu qualifies for SELECT_CAPABILITY_CONTAINER\n        } else if (mAppSelected && Arrays.equals(SELECT_CAPABILITY_CONTAINER, commandApdu)) {\n            mCcSelected = true;\n            mNdefSelected = false;\n            Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(SUCCESS_SW));\n            return SUCCESS_SW;\n            // check if commandApdu qualifies for SELECT_NDEF_FILE", "        } else if (mAppSelected && Arrays.equals(SELECT_CAPABILITY_CONTAINER, commandApdu)) {\n            mCcSelected = true;\n            mNdefSelected = false;\n            Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(SUCCESS_SW));\n            return SUCCESS_SW;\n            // check if commandApdu qualifies for SELECT_NDEF_FILE\n        } else if (mAppSelected && Arrays.equals(SELECT_NDEF_FILE, commandApdu)) {\n            // NDEF\n            mCcSelected = false;\n            mNdefSelected = true;\n            Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(SUCCESS_SW));\n            return SUCCESS_SW;\n            // check if commandApdu qualifies for // READ_BINARY", "        } else if (commandApdu[0] == (byte)0x00 && commandApdu[1] == (byte)0xb0) {\n            // READ_BINARY\n            // get the offset an le (length) data\n            //System.out.println(\"** \" + Utils.bytesToHex(commandApdu) + \" in else if (commandApdu[0] == (byte)0x00 && commandApdu[1] == (byte)0xb0) {\");\n            int offset = (0x00ff & commandApdu[2]) * 256 + (0x00ff & commandApdu[3]);\n            int le = 0x00ff & commandApdu[4];\n\n            byte[] responseApdu = new byte[le + SUCCESS_SW.length];\n\n            if (mCcSelected && offset == 0 && le == CAPABILITY_CONTAINER_FILE.length) {\n                System.arraycopy(CAPABILITY_CONTAINER_FILE, offset, responseApdu, 0, le);\n                System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n                Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(responseApdu));\n                return responseApdu;", "            if (mCcSelected && offset == 0 && le == CAPABILITY_CONTAINER_FILE.length) {\n                System.arraycopy(CAPABILITY_CONTAINER_FILE, offset, responseApdu, 0, le);\n                System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n                Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(responseApdu));\n                return responseApdu;\n            } else if (mNdefSelected) {\n                if (offset + le <= mNdefRecordFile.length) {\n                    System.arraycopy(mNdefRecordFile, offset, responseApdu, 0, le);\n                    System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n                    Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(responseApdu));\n                    return responseApdu;\n                }\n            }\n        }\n\n        // The tag should return different errors for different reasons\n        // this emulation just returns the general error message\n        Log.d((TAG), \"responseApdu: \" + Utils.bytesToHex(FAILURE_SW));\n        return FAILURE_SW;\n    }\n    \n/*\ncomplete sequence:\ncommandApdu: 00a4040007d276000085010100\nresponseApdu: 9000\ncommandApdu: 00a4000c02e103\nresponseApdu: 9000\ncommandApdu: 00b000000f\nresponseApdu: 000f20003b00340406e10400ff00ff9000\ncommandApdu: 00a4000c02e104\nresponseApdu: 9000\ncommandApdu: 00b0000002\nresponseApdu: 002e9000\ncommandApdu: 00b000022e\nresponseApdu: d1012a55046769746875622e636f6d2f416e64726f696443727970746f3f7461623d7265706f7369746f726965739000    \n */\n\n    /**\n     * onDeactivated is called when reading ends\n     * reset the status boolean values\n     */\n    @Override", "    public void onDeactivated(int reason) {\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n    }\n}\n\n"]}
{"filename": "app/src/main/java/de/androidcrypto/nfchcendefemulator/NdefHostApduService.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.nfc.NdefMessage;\nimport android.nfc.NdefRecord;\nimport android.nfc.cardemulation.HostApduService;\nimport android.os.Bundle;\n\nimport java.util.Arrays;\n\npublic class NdefHostApduService extends HostApduService {\n    // \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_APP = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x00,\n            (byte)0x07, (byte)0xd2, (byte)0x76, (byte)0x00, (byte)0x00, (byte)0x85, (byte)0x01, (byte)0x01,\n            (byte)0x00,\n    };\n    // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU)\n    private final static byte[] SELECT_CC_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x03,\n    };\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_NDEF_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x04,\n    };\n\n    // \u6210\u529f\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] SUCCESS_SW = new byte[] {\n            (byte)0x90, (byte)0x00,\n    };\n    // \u5931\u6557\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] FAILURE_SW = new byte[] {\n            (byte)0x6a, (byte)0x82,\n    };\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\n    private final static byte[] CC_FILE = new byte[] {\n            0x00, 0x0f, // CCLEN\n            0x20, // Mapping Version\n            0x00, 0x3b, // Maximum R-APDU data size\n            0x00, 0x34, // Maximum C-APDU data size\n            0x04, 0x06, // Tag & Length\n            (byte)0xe1, 0x04, // NDEF File Identifier\n            //0x00, 0x32, // Maximum NDEF size, original\n            (byte) 0x00, (byte) 0xff, // Maximum NDEF size\n            0x00, // NDEF file read access granted\n            (byte)0xff, // NDEF File write access denied\n    };\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u7528\u5909\u6570\n    private byte[] mNdefRecordFile;\n\n    // \u30a2\u30d7\u30ea\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mAppSelected;\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mCcSelected;\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mNdefSelected;\n\n    @Override", "\npublic class NdefHostApduService extends HostApduService {\n    // \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_APP = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x00,\n            (byte)0x07, (byte)0xd2, (byte)0x76, (byte)0x00, (byte)0x00, (byte)0x85, (byte)0x01, (byte)0x01,\n            (byte)0x00,\n    };\n    // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU)\n    private final static byte[] SELECT_CC_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x03,\n    };\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u9078\u629e\u306eC-APDU\n    private final static byte[] SELECT_NDEF_FILE = new byte[] {(byte)0x00, (byte)0xa4, (byte)0x00, (byte)0x0c,\n            (byte)0x02, (byte)0xe1, (byte)0x04,\n    };\n\n    // \u6210\u529f\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] SUCCESS_SW = new byte[] {\n            (byte)0x90, (byte)0x00,\n    };\n    // \u5931\u6557\u6642\u306e Status Word (\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4f7f\u7528\u3059\u308b)\n    private final static byte[] FAILURE_SW = new byte[] {\n            (byte)0x6a, (byte)0x82,\n    };\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\n    private final static byte[] CC_FILE = new byte[] {\n            0x00, 0x0f, // CCLEN\n            0x20, // Mapping Version\n            0x00, 0x3b, // Maximum R-APDU data size\n            0x00, 0x34, // Maximum C-APDU data size\n            0x04, 0x06, // Tag & Length\n            (byte)0xe1, 0x04, // NDEF File Identifier\n            //0x00, 0x32, // Maximum NDEF size, original\n            (byte) 0x00, (byte) 0xff, // Maximum NDEF size\n            0x00, // NDEF file read access granted\n            (byte)0xff, // NDEF File write access denied\n    };\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u7528\u5909\u6570\n    private byte[] mNdefRecordFile;\n\n    // \u30a2\u30d7\u30ea\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mAppSelected;\n\n    // CC\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mCcSelected;\n\n    // NDEF\u30ec\u30b3\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n    private boolean mNdefSelected;\n\n    @Override", "    public void onCreate() {\n        super.onCreate();\n\n        // \u72b6\u614b\u306e\u30af\u30ea\u30a2\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n\n        // default NDEF-message\n        final String DEFAULT_MESSAGE = \"This is the default message from NfcHceNdelEmulator. If you want to change the message use the tab 'Send' to enter an individual message.\";\n        // the maximum length is 246 so do not extend this value\n        NdefMessage ndefDefaultMessage = getNdefMessage(DEFAULT_MESSAGE);\n        int nlen = ndefDefaultMessage.getByteArrayLength();\n        mNdefRecordFile = new byte[nlen + 2];\n        mNdefRecordFile[0] = (byte)((nlen & 0xff00) / 256);\n        mNdefRecordFile[1] = (byte)(nlen & 0xff);\n        System.arraycopy(ndefDefaultMessage.toByteArray(), 0, mNdefRecordFile, 2, ndefDefaultMessage.getByteArrayLength());\n    }\n\n    private NdefMessage getNdefMessage(String ndefData) {", "        if (ndefData.length() == 0) {\n            return null;\n        }\n        NdefRecord ndefRecord;\n        ndefRecord = NdefRecord.createTextRecord(\"en\", ndefData);\n        return new NdefMessage(ndefRecord);\n    }\n\n    /**\n     * NFC Forum Tag Type 4\u3068\u3057\u3066\u632f\u308b\u821e\u3046\u51e6\u7406\u3092\u884c\u3046\u3002\n     * C-APDU\u3092\u53d7\u3051\u53d6\u308a\u3001\u5bfe\u5fdc\u3059\u308bR-APDU\u3092\u8fd4\u3059\u3002\n     */\n    @Override\n    public byte[] processCommandApdu(byte[] commandApdu, Bundle extras) {", "        if (Arrays.equals(SELECT_APP, commandApdu)) {\n            // \u30a2\u30d7\u30ea\u9078\u629e\n            mAppSelected = true;\n            mCcSelected = false;\n            mNdefSelected = false;\n            return SUCCESS_SW; // \u6210\u529f\n        } else if (mAppSelected && Arrays.equals(SELECT_CC_FILE, commandApdu)) {\n            // CC\u30d5\u30a1\u30a4\u30eb\u9078\u629e\n            mCcSelected = true;\n            mNdefSelected = false;\n            return SUCCESS_SW; // \u6210\u529f", "        } else if (mAppSelected && Arrays.equals(SELECT_NDEF_FILE, commandApdu)) {\n            // NDEF\u30d5\u30a1\u30a4\u30eb\u9078\u629e\n            mCcSelected = false;\n            mNdefSelected = true;\n            return SUCCESS_SW; // \u6210\u529f\n        } else if (commandApdu[0] == (byte)0x00 && commandApdu[1] == (byte)0xb0) {\n            // READ_BINARY (\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u51fa\u3057)\n\n            // \u30aa\u30d5\u30bb\u30c3\u30c8\u3068\u9577\u3055\u3092\u53d6\u308a\u51fa\u3059\n            int offset = (0x00ff & commandApdu[2]) * 256 + (0x00ff & commandApdu[3]);\n            int le = 0x00ff & commandApdu[4];\n\n            // R-APDU\u7528\u306e\u30d0\u30c3\u30d5\u30a1\u3092\u751f\u6210\u3059\u308b\n            byte[] responseApdu = new byte[le + SUCCESS_SW.length];\n", "            if (mCcSelected && offset == 0 && le == CC_FILE.length) {\n                // CC\u9078\u629e\u6642\u306f\u30aa\u30d5\u30bb\u30c3\u30c8\u304c0\u3001\u9577\u3055\u304c\u30d5\u30a1\u30a4\u30eb\u9577(15)\u3068\u4e00\u81f4\u3057\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\n                System.arraycopy(CC_FILE, offset, responseApdu, 0, le);\n                System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n\n                return responseApdu;\n            } else if (mNdefSelected) {\n                if (offset + le <= mNdefRecordFile.length) {\n                    System.arraycopy(mNdefRecordFile, offset, responseApdu, 0, le);\n                    System.arraycopy(SUCCESS_SW, 0, responseApdu, le, SUCCESS_SW.length);\n\n                    return responseApdu;\n                }\n            }\n        }\n\n        // \u30a8\u30e9\u30fc\u3092\u8fd4\u3059\n        // \u672c\u6765\u3001IC\u30ab\u30fc\u30c9\u30a2\u30d7\u30ea\u3067\u306f\u30a8\u30e9\u30fc\u7a2e\u5225\u306b\u3042\u308f\u305b\u3066\u30a8\u30e9\u30fc\u306e\u5024\u3092\u5909\u3048\u306a\u3051\u308c\u3070\n        // \u306a\u3089\u306a\u3044\u304c\u3001\u3053\u3053\u3067\u306f\u7701\u7565\u3057\u3066\u4e00\u7a2e\u985e\u306e\u307f\u3092\u8fd4\u3057\u3066\u3044\u308b\u3002\n        return FAILURE_SW;\n    }\n\n    /**\n     * \u30ab\u30fc\u30c9\u30a2\u30d7\u30ea\u304c\u975e\u9078\u629e\u72b6\u614b\u306b\u306a\u3063\u305f\u6642\u306b\u547c\u3070\u308c\u308b\u3002\n     * \u672c\u30a2\u30d7\u30ea\u3067\u306f\u72b6\u614b\u3092\u30ea\u30bb\u30c3\u30c8\u3057\u3066\u521d\u671f\u72b6\u614b\u306b\u623b\u3057\u307e\u3059\u3002\n     */\n    @Override", "    public void onDeactivated(int reason) {\n        mAppSelected = false;\n        mCcSelected = false;\n        mNdefSelected = false;\n    }\n}\n"]}
{"filename": "app/src/androidTest/java/de/androidcrypto/nfchcendefemulator/ExampleInstrumentedTest.java", "chunked_list": ["package de.androidcrypto.nfchcendefemulator;\n\nimport android.content.Context;\n\nimport androidx.test.platform.app.InstrumentationRegistry;\nimport androidx.test.ext.junit.runners.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n", "import org.junit.runner.RunWith;\n\nimport static org.junit.Assert.*;\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test", " */\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();\n        assertEquals(\"de.androidcrypto.nfchcendefemulator\", appContext.getPackageName());\n    }\n}"]}
