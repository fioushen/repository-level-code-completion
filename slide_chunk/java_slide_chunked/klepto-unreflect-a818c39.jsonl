{"filename": "benchmark/src/main/java/dev/klepto/unreflect/benchmark/ConstructorBenchmarks.java", "chunked_list": ["package dev.klepto.unreflect.benchmark;\n\nimport dev.klepto.unreflect.ParameterAccess;\nimport dev.klepto.unreflect.Unreflect;\nimport dev.klepto.unreflect.property.Invokable;\nimport lombok.SneakyThrows;\nimport one.util.streamex.StreamEx;\nimport org.openjdk.jmh.annotations.*;\n\nimport java.util.concurrent.TimeUnit;", "\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@Fork(1)\n@BenchmarkMode(Mode.AverageTime)\n@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)", "@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 2, time = 1)\n@Measurement(iterations = 5, time = 1)\npublic class ConstructorBenchmarks {\n\n    private final Invokable direct;\n    private final Invokable reflect;\n    private final Invokable unreflect;\n\n    @SneakyThrows\n    public ConstructorBenchmarks() {\n        this.direct = new Invokable() {\n            @Override\n            public StreamEx<ParameterAccess> parameters() {\n                return null;\n            }\n\n            @Override\n            public <T> T invoke(Object... args) throws RuntimeException {\n                return (T) new Subject();\n            }\n        };\n        this.reflect = Unreflect.reflect(Subject.class).constructor();\n        this.unreflect = Unreflect.unreflect(Subject.class).constructor();\n    }\n\n    @Benchmark", "    public void direct() {\n        direct.invoke();\n    }\n\n    @Benchmark\n    @SneakyThrows\n    public void reflection() {\n        reflect.invoke();\n    }\n\n    @Benchmark", "    public void unreflect() {\n        unreflect.invoke();\n    }\n\n    private static class Subject {\n        public Subject() {\n        }\n    }\n\n}\n"]}
{"filename": "benchmark/src/main/java/dev/klepto/unreflect/benchmark/FieldBenchmarks.java", "chunked_list": ["package dev.klepto.unreflect.benchmark;\n\nimport dev.klepto.unreflect.FieldAccess;\nimport dev.klepto.unreflect.Unreflect;\nimport dev.klepto.unreflect.property.Mutable;\nimport lombok.SneakyThrows;\nimport lombok.val;\nimport org.openjdk.jmh.annotations.*;\n\nimport java.util.concurrent.TimeUnit;", "\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@Fork(1)\n@BenchmarkMode(Mode.AverageTime)\n@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)", "@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 2, time = 1)\n@Measurement(iterations = 5, time = 1)\npublic class FieldBenchmarks {\n\n    private final Subject subject;\n\n    private final Mutable direct;\n    private final Mutable reflect;\n    private final Mutable unreflect;\n\n    @SneakyThrows\n    public FieldBenchmarks() {\n        this.subject = new Subject();\n\n        this.direct = new Mutable() {\n            @Override\n            public <T> T get() {\n                return (T) (Object) subject.value;\n            }\n\n            @Override", "            public void set(Object value) {\n                subject.value = (int) value;\n            }\n        };\n\n        this.reflect = Unreflect.reflect(subject).field(\"value\");\n        this.unreflect = Unreflect.unreflect(subject).field(\"value\");\n    }\n\n    @Benchmark\n    public void direct() {\n        val value = (int) direct.get();\n        direct.set(value + 1);\n    }\n\n    @Benchmark\n    @SneakyThrows", "    public void direct() {\n        val value = (int) direct.get();\n        direct.set(value + 1);\n    }\n\n    @Benchmark\n    @SneakyThrows\n    public void reflection() {\n        val value = (int) reflect.get();\n        reflect.set(value + 1);\n    }\n\n\n    @Benchmark", "    public void unreflect() {\n        val value = (int) unreflect.get();\n        unreflect.set(value + 1);\n    }\n\n    private static class Subject {\n        private int value = 0;\n    }\n\n}\n"]}
{"filename": "benchmark/src/main/java/dev/klepto/unreflect/benchmark/MethodBenchmarks.java", "chunked_list": ["package dev.klepto.unreflect.benchmark;\n\nimport dev.klepto.unreflect.ParameterAccess;\nimport dev.klepto.unreflect.Unreflect;\nimport dev.klepto.unreflect.property.Invokable;\nimport lombok.SneakyThrows;\nimport one.util.streamex.StreamEx;\nimport org.openjdk.jmh.annotations.*;\n\nimport java.util.concurrent.TimeUnit;", "\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@Fork(1)\n@BenchmarkMode(Mode.AverageTime)\n@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)", "@State(Scope.Benchmark)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 2, time = 1)\n@Measurement(iterations = 5, time = 1)\npublic class MethodBenchmarks {\n\n    private final Subject subject;\n    private final Invokable direct;\n    private final Invokable reflect;\n    private final Invokable unreflect;\n\n    @SneakyThrows\n    public MethodBenchmarks() {\n        this.subject = new Subject();\n        this.direct = new Invokable() {\n            @Override\n            public StreamEx<ParameterAccess> parameters() {\n                return null;\n            }\n\n            @Override\n            public <T> T invoke(Object... args) throws RuntimeException {\n                subject.increaseValue((int) args[0]);\n                return null;\n            }\n        };\n        this.reflect = Unreflect.reflect(subject).method(0);\n        this.unreflect = Unreflect.unreflect(subject).method(0);\n    }\n\n    @Benchmark", "    public void direct() {\n        direct.invoke(1);\n    }\n\n    @Benchmark\n    @SneakyThrows\n    public void reflection() {\n        reflect.invoke(1);\n    }\n\n    @Benchmark", "    public void unreflect() {\n        unreflect.invoke(1);\n    }\n\n    private static class Subject {\n        private int value = 0;\n        public void increaseValue(int amount) {\n            value += amount;\n        }\n    }\n\n}\n"]}
{"filename": "benchmark/src/main/java/dev/klepto/unreflect/benchmark/Benchmarks.java", "chunked_list": ["package dev.klepto.unreflect.benchmark;\n\nimport lombok.val;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.RunnerException;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\n\nimport java.lang.reflect.Constructor;\n\n/**", "\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class Benchmarks {\n\n    public static void main(String[] args) throws RunnerException {\n        val options = new OptionsBuilder()\n                .include(Constructor.class.getSimpleName())\n                .include(MethodBenchmarks.class.getSimpleName())\n                .include(FieldBenchmarks.class.getSimpleName())\n                .build();\n        \n        new Runner(options).run();\n    }\n\n}\n"]}
{"filename": "src/test/java/dev/klepto/unreflect/ClassAccessTest.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.bytecode.BytecodeClassAccess;\nimport dev.klepto.unreflect.bytecode.BytecodeContructorAccess;\nimport dev.klepto.unreflect.bytecode.BytecodeFieldAccess;\nimport dev.klepto.unreflect.bytecode.BytecodeMethodAccess;\nimport dev.klepto.unreflect.reflection.ReflectionClassAccess;\nimport dev.klepto.unreflect.reflection.ReflectionConstructorAccess;\nimport dev.klepto.unreflect.reflection.ReflectionFieldAccess;\nimport dev.klepto.unreflect.reflection.ReflectionMethodAccess;", "import dev.klepto.unreflect.reflection.ReflectionFieldAccess;\nimport dev.klepto.unreflect.reflection.ReflectionMethodAccess;\nimport lombok.val;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.function.Predicate;\n\nimport static org.junit.jupiter.api.Assertions.*;", "\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class ClassAccessTest {\n\n    private final TestSubject subject = new TestSubject();\n    private final ClassAccess<TestSubject> classAccess = Unreflect.reflect(subject);\n\n    @Test", "    public void testSource() {\n        assertEquals(TestSubject.class, classAccess.source());\n    }\n\n    @Test\n    public void testDeclaringType() {\n        assertEquals(getClass(), classAccess.declaringType().toClass());\n    }\n\n    @Test\n    public void testUnreflect() {\n        val unreflected = classAccess.unreflect();\n        assertSame(unreflected.getClass(), BytecodeClassAccess.class);\n        assertTrue(unreflected.constructors().allMatch(member -> member.getClass() == BytecodeContructorAccess.class));\n        assertTrue(unreflected.fields().allMatch(member -> member.getClass() == BytecodeFieldAccess.class));\n        assertTrue(unreflected.methods().allMatch(member -> member.getClass() == BytecodeMethodAccess.class));\n\n        val reflected = unreflected.reflect();\n        assertSame(reflected.getClass(), ReflectionClassAccess.class);\n        assertTrue(reflected.constructors().allMatch(member -> member.getClass() == ReflectionConstructorAccess.class));\n        assertTrue(reflected.fields().allMatch(member -> member.getClass() == ReflectionFieldAccess.class));\n        assertTrue(reflected.methods().allMatch(member -> member.getClass() == ReflectionMethodAccess.class));\n    }\n\n    @Test", "    public void testUnreflect() {\n        val unreflected = classAccess.unreflect();\n        assertSame(unreflected.getClass(), BytecodeClassAccess.class);\n        assertTrue(unreflected.constructors().allMatch(member -> member.getClass() == BytecodeContructorAccess.class));\n        assertTrue(unreflected.fields().allMatch(member -> member.getClass() == BytecodeFieldAccess.class));\n        assertTrue(unreflected.methods().allMatch(member -> member.getClass() == BytecodeMethodAccess.class));\n\n        val reflected = unreflected.reflect();\n        assertSame(reflected.getClass(), ReflectionClassAccess.class);\n        assertTrue(reflected.constructors().allMatch(member -> member.getClass() == ReflectionConstructorAccess.class));\n        assertTrue(reflected.fields().allMatch(member -> member.getClass() == ReflectionFieldAccess.class));\n        assertTrue(reflected.methods().allMatch(member -> member.getClass() == ReflectionMethodAccess.class));\n    }\n\n    @Test", "    public void testCreate() {\n        val instanceA = classAccess.create();\n        val instanceB = classAccess.create(\"\");\n\n        assertNotNull(instanceA);\n        assertNotNull(instanceB);\n        assertNotEquals(instanceA, instanceB);\n    }\n\n    @Test\n    public void testConstructors() {\n        val constructors = classAccess.constructors().toList();\n        assertTrue(3 <= constructors.size());\n        assertEquals(constructors.get(0).source(), classAccess.constructor().source());\n        assertEquals(constructors.get(1).source(), classAccess.constructor(1).source());\n\n        val stringValueConstructors = classAccess.constructors(\"\").toList();\n        val stringTypeConstructors = classAccess.constructors(String.class).toList();\n        assertEquals(2, stringValueConstructors.size());\n        assertEquals(2, stringTypeConstructors.size());\n\n        val objectTypeConstructors = classAccess.constructors(Object.class).toList();\n        assertEquals(1, objectTypeConstructors.size());\n    }\n\n    @Test", "    public void testConstructors() {\n        val constructors = classAccess.constructors().toList();\n        assertTrue(3 <= constructors.size());\n        assertEquals(constructors.get(0).source(), classAccess.constructor().source());\n        assertEquals(constructors.get(1).source(), classAccess.constructor(1).source());\n\n        val stringValueConstructors = classAccess.constructors(\"\").toList();\n        val stringTypeConstructors = classAccess.constructors(String.class).toList();\n        assertEquals(2, stringValueConstructors.size());\n        assertEquals(2, stringTypeConstructors.size());\n\n        val objectTypeConstructors = classAccess.constructors(Object.class).toList();\n        assertEquals(1, objectTypeConstructors.size());\n    }\n\n    @Test", "    public void testFields() {\n        val fields = classAccess.fields().toList();\n        assertEquals(2, fields.size());\n        assertEquals(fields.get(0).source(), classAccess.field(0).source());\n        assertEquals(fields.get(1).source(), classAccess.field(1).source());\n        assertEquals(fields.get(0).source(), classAccess.field(\"field\").source());\n        assertEquals(fields.get(1).source(), classAccess.field(\"fieldStatic\").source());\n    }\n\n    @Test\n    public void testMethods() {\n        val declaringFilter = (Predicate<MethodAccess>) member -> member.declaringType().matchesExact(TestSubject.class);\n        val allMethods = classAccess.methods().toList();\n        val declaredMethods = classAccess.methods().filter(declaringFilter).toList();\n        val stringMethods = classAccess.methods(String.class).filter(declaringFilter).toList();\n        val staticMethods = classAccess.methods(\"methodStatic\").toList();\n        val staticStringMethods = classAccess.methods(\"methodStatic\", String.class).toList();\n        val staticObjectMethods = classAccess.methods(\"methodStatic\", Object.class).toList();\n\n        assertEquals(3, declaredMethods.size());\n        assertEquals(2, stringMethods.size());\n        assertEquals(2, staticMethods.size());\n        assertEquals(2, staticStringMethods.size());\n        assertEquals(1, staticObjectMethods.size());\n        assertEquals(allMethods.get(0).source(), classAccess.method(0).source());\n        assertEquals(staticObjectMethods.get(0).source(), classAccess.method(Object.class).source());\n        assertEquals(staticStringMethods.get(0).source(), classAccess.method(\"methodStatic\").source());\n        assertEquals(staticObjectMethods.get(0).source(), classAccess.method(\"methodStatic\", Object.class).source());\n    }\n\n    @Test", "    public void testMethods() {\n        val declaringFilter = (Predicate<MethodAccess>) member -> member.declaringType().matchesExact(TestSubject.class);\n        val allMethods = classAccess.methods().toList();\n        val declaredMethods = classAccess.methods().filter(declaringFilter).toList();\n        val stringMethods = classAccess.methods(String.class).filter(declaringFilter).toList();\n        val staticMethods = classAccess.methods(\"methodStatic\").toList();\n        val staticStringMethods = classAccess.methods(\"methodStatic\", String.class).toList();\n        val staticObjectMethods = classAccess.methods(\"methodStatic\", Object.class).toList();\n\n        assertEquals(3, declaredMethods.size());\n        assertEquals(2, stringMethods.size());\n        assertEquals(2, staticMethods.size());\n        assertEquals(2, staticStringMethods.size());\n        assertEquals(1, staticObjectMethods.size());\n        assertEquals(allMethods.get(0).source(), classAccess.method(0).source());\n        assertEquals(staticObjectMethods.get(0).source(), classAccess.method(Object.class).source());\n        assertEquals(staticStringMethods.get(0).source(), classAccess.method(\"methodStatic\").source());\n        assertEquals(staticObjectMethods.get(0).source(), classAccess.method(\"methodStatic\", Object.class).source());\n    }\n\n    @Test", "    public void testAnnotations() {\n        assertEquals(1, classAccess.annotations().count());\n        assertTrue(classAccess.containsAnnotation(TestAnnotation.class));\n    }\n\n    @Test\n    public void testModifiers() {\n        assertTrue(classAccess.isStatic());\n        assertTrue(classAccess.isPrivate());\n    }\n\n    @Test", "    public void testSuperclass() {\n        assertEquals(Object.class, classAccess.superclass().source());\n    }\n\n    @Retention(RetentionPolicy.RUNTIME)\n    private @interface TestAnnotation {\n    }\n\n    @TestAnnotation\n    private static class TestSubject {\n        private Object field;\n        private static Object fieldStatic;\n\n        private TestSubject() {\n        }\n\n        private TestSubject(String value) {\n        }\n\n        private TestSubject(Object value) {\n        }\n\n        private void method() {\n        }\n\n        private static void methodStatic(String value) {\n        }\n        private static void methodStatic(Object value) {\n        }\n    }\n\n}\n"]}
{"filename": "src/test/java/dev/klepto/unreflect/FieldAccessTest.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.bytecode.BytecodeFieldAccess;\nimport lombok.SneakyThrows;\nimport lombok.val;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**", "\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class FieldAccessTest {\n\n    private final ClassAccess<TestSubject> classAccess = Unreflect.reflect(TestSubject.class);\n\n    @Test\n    @SneakyThrows\n    public void testSource() {\n        val field = TestSubject.class.getDeclaredField(\"field\");\n        assertEquals(field, classAccess.field(\"field\").source());\n    }\n\n    @Test", "    public void testSource() {\n        val field = TestSubject.class.getDeclaredField(\"field\");\n        assertEquals(field, classAccess.field(\"field\").source());\n    }\n\n    @Test\n    public void testSetAndGet() {\n        val field = classAccess.bind(new TestSubject()).field(\"field\");\n        assertEquals(0, field.<Integer>get());\n\n        field.set(1337);\n        assertEquals(1337, field.<Integer>get());\n    }\n\n    @Test", "    public void testUnreflect() {\n        val field = classAccess.bind(new TestSubject()).field(\"field\").unreflect();\n        assertTrue(field instanceof BytecodeFieldAccess);\n        assertEquals(0, field.<Integer>get());\n\n        field.set(1337);\n        assertEquals(1337, field.<Integer>get());\n    }\n\n    private static class TestSubject {\n        private int field;\n    }\n\n}\n"]}
{"filename": "src/test/java/dev/klepto/unreflect/MethodAccessTest.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.bytecode.BytecodeMethodAccess;\nimport lombok.SneakyThrows;\nimport lombok.val;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**", "\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class MethodAccessTest {\n    private final ClassAccess<TestSubject> classAccess = Unreflect.reflect(TestSubject.class);\n\n    @Test\n    @SneakyThrows\n    public void testSource() {\n        val method = TestSubject.class.getDeclaredMethod(\"method\");\n        assertEquals(method, classAccess.method(\"method\").source());\n    }\n\n    @Test", "    public void testSource() {\n        val method = TestSubject.class.getDeclaredMethod(\"method\");\n        assertEquals(method, classAccess.method(\"method\").source());\n    }\n\n    @Test\n    public void testInvoke() {\n        assertEquals(3, classAccess.method(\"increase\").<Integer>invoke(2));\n        assertNull(classAccess.method(\"method\").invoke());\n    }\n\n    @Test", "    public void testUnreflect() {\n        assertTrue(classAccess.method(\"method\").unreflect() instanceof BytecodeMethodAccess);\n        assertEquals(3, classAccess.method(\"increase\").unreflect().<Integer>invoke(2));\n        assertNull(classAccess.method(\"method\").unreflect().invoke());\n    }\n\n    private static class TestSubject {\n        private static int increase(int value) {\n            return value + 1;\n        }\n        private static void method() {\n        }\n    }\n}\n"]}
{"filename": "src/test/java/dev/klepto/unreflect/ConstructorAccessTest.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.bytecode.BytecodeContructorAccess;\nimport lombok.val;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>", "/**\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class ConstructorAccessTest {\n\n    private final ClassAccess<TestSubject> classAccess = Unreflect.reflect(TestSubject.class);\n\n    @Test\n    public void testSource() {\n        val constructor = TestSubject.class.getDeclaredConstructors()[0];\n        assertEquals(constructor, classAccess.constructor().source());\n    }\n\n    @Test", "    public void testSource() {\n        val constructor = TestSubject.class.getDeclaredConstructors()[0];\n        assertEquals(constructor, classAccess.constructor().source());\n    }\n\n    @Test\n    public void testCreate() {\n        val instanceA = classAccess.constructor().create();\n        val instanceB = classAccess.constructor(String.class).create(\"\");\n        val instanceC = classAccess.constructor(int.class).create(0);\n\n        assertNotNull(instanceA);\n        assertNotNull(instanceB);\n        assertNotNull(instanceC);\n\n        assertNotSame(instanceA, instanceB);\n        assertNotSame(instanceB, instanceC);\n        assertNotSame(instanceC, instanceA);\n    }\n\n    @Test", "    public void testUnreflect() {\n        val constructorAccess = classAccess.constructor().unreflect();\n        assertTrue(constructorAccess instanceof BytecodeContructorAccess);\n\n        val instance = constructorAccess.create();\n        assertNotNull(instance);\n    }\n\n\n    private static class TestSubject {\n        private TestSubject() {\n        }\n        private TestSubject(String value) {\n        }\n\n        private TestSubject(int value) {\n        }\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/FieldAccess.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.property.Mutable;\nimport dev.klepto.unreflect.property.Named;\nimport dev.klepto.unreflect.property.Reflectable;\n\nimport java.lang.reflect.Field;\n\n/**", "\n/**\n * Represents a declared field of a class. Enables setting and getting field values. Contains type, modifier, name and\n * annotation access.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface FieldAccess extends Reflectable, Mutable, Named, Accessible<FieldAccess> {\n\n    /**\n     * Reflection representation this field.\n     *\n     * @return a reflection representation this field\n     * @see Class#getDeclaredFields()\n     */\n    Field source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {\n        return UnreflectType.of(source().getDeclaringClass());\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/ConstructorAccess.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.property.Invokable;\nimport dev.klepto.unreflect.property.Reflectable;\n\nimport java.lang.reflect.Constructor;\n\n/**\n * Represents a declared constructor of a class. Enables creation of new instances. Contains invocation, annotation,", "/**\n * Represents a declared constructor of a class. Enables creation of new instances. Contains invocation, annotation,\n * modifiers and parameter access.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface ConstructorAccess<T> extends Reflectable, Invokable, Accessible<ConstructorAccess<T>> {\n\n    /**\n     * Reflection representation of the constructor.\n     *\n     * @return a reflection representation of the constructor\n     * @see Class#getDeclaredConstructors()\n     */\n    Constructor<T> source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {\n        return UnreflectType.of(source().getDeclaringClass());\n    }\n\n    /**\n     * Invokes constructor with given argument values and returns the new instance of the class.\n     *\n     * @param args the constructor arguments\n     * @return a new instance of the class\n     * @throws RuntimeException if any exception is thrown during initialization of the class or if constructor doesn't\n     *                          accept given arguments\n     */\n    T create(Object... args) throws RuntimeException;\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/MethodAccess.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.property.Invokable;\nimport dev.klepto.unreflect.property.Named;\nimport dev.klepto.unreflect.property.Reflectable;\n\nimport java.lang.reflect.Method;\n\n/**", "\n/**\n * Represents a declared method of a class. Enables method invocation. Contains name, invocation, type, annotation,\n * modifiers and parameter access.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface MethodAccess extends Reflectable, Invokable, Named, Accessible<MethodAccess> {\n\n    /**\n     * Reflection representation of the method.\n     *\n     * @return a reflection representation of the method\n     * @see Class#getDeclaredMethods()\n     */\n    Method source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {\n        return UnreflectType.of(source().getDeclaringClass());\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/ClassAccess.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.property.Named;\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.util.Parameters;\nimport one.util.streamex.StreamEx;\n\nimport javax.annotation.Nullable;\n", "import javax.annotation.Nullable;\n\n/**\n * Represents access to a class and it's members. Enables type, annotation, name, modifiers and members access.\n * Contains easy and intuitive lookup for constructors, fields and methods.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface ClassAccess<T> extends Reflectable, Named, Accessible<ClassAccess<T>> {\n\n    /**\n     * Returns the class that this class access represents.\n     *\n     * @return the represented class\n     */\n    Class<T> source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {\n        return UnreflectType.of(source().getDeclaringClass());\n    }\n\n    /**\n     * Creates a new instance of a class, using runtime constructor lookup based on given parameter arguments.\n     *\n     * @param args the constructor arguments\n     * @return an instance of represented class\n     */\n    T create(Object... args);\n\n    /**\n     * Returns a stream of all declared constructors in the represented class. Represented by {@link ConstructorAccess}.\n     *\n     * @return a stream of constructors in the represented class\n     */\n    StreamEx<ConstructorAccess<T>> constructors();\n\n    /**\n     * Returns a constructor by index, or null if constructor by given index doesn't exist. Note that declaration order\n     * in the source code is not guaranteed to be preserved during runtime.\n     *\n     * @param index the constructor index\n     * @return the declared constructor at a given index in the represented class\n     */\n    @Nullable\n    default ConstructorAccess<T> constructor(int index) {\n        return constructors().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared constructor of represented class, or null if class has no constructors.\n     *\n     * @return the first available constructor in the represented class\n     */\n    default ConstructorAccess<T> constructor() {\n        return constructor(0);\n    }\n\n    /**\n     * Returns a constructors that loosely matches given parameter values or parameter types. This method can be\n     * either supplied with array of values that you are going to pass to the constructor or array of classes that\n     * represent value types. Neither values nor types have to be exact types, as long as they are assignable to a\n     * constructor parameters a match will be found. May cause unexpected results with heavy constructor overloading.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of constructors that accepts given parameter values or parameter types\n     */\n    default StreamEx<ConstructorAccess<T>> constructors(Object... argsOrTypes) {\n        return constructors().filter(constructor -> Parameters.matches(constructor, argsOrTypes));\n    }\n\n    /**\n     * Returns first constructor that loosely matches given parameter values or parameter types, or null if such\n     * constructor is not found in represented class.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return first constructor that accepts given parameter values or parameter types, or null if it's not found\n     * @see ClassAccess#constructors(Object...) \n     */\n    @Nullable\n    default ConstructorAccess<T> constructor(Object... argsOrTypes) {\n        return constructors(argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a stream of declared fields in the represented class. Represented by {@link FieldAccess}.\n     *\n     * @return a stream of fields in the represented class\n     */\n    StreamEx<FieldAccess> fields();\n\n    /**\n     * Returns a field by index, or null if field by given index doesn't exist. Field order in source code should always\n     * match field order during runtime, which makes it rather safe to use source code as a reference for an index.\n     *\n     * @param index the field index\n     * @return the declared field at a given index in the represented class\n     */\n    @Nullable\n    default FieldAccess field(int index) {\n        return fields().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a field by name, or null if field by given name doesn't exist. Field names are in classes guaranteed to\n     * be unique.\n     *\n     * @param name the field name\n     * @return the declared field with a given name in the represented class\n     */\n    default FieldAccess field(String name) {\n        return fields().findFirst(field -> field.name().equals(name)).orElse(null);\n    }\n\n    /**\n     * Returns a stream of declared methods in the represented class. Represented by {@link MethodAccess}.\n     *\n     * @return a stream of methods in the represented class\n     */\n    StreamEx<MethodAccess> methods();\n\n    /**\n     * Returns a stream of methods that loosely matches given parameter values or parameter types. Can be either supplied\n     * with array of values that you are going to pass to the method or array of classes that represent value types.\n     * Neither values nor types have to be exact types, as long as they are assignable to a method parameters a match\n     * will be found.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of methods that accepts given parameter values or parameter types\n     */\n    default StreamEx<MethodAccess> methods(Object... argsOrTypes) {\n        return methods().filter(method -> Parameters.matches(method, argsOrTypes));\n    }\n\n    /**\n     * Returns a stream of declared methods that have a given name in the represented class.\n     *\n     * @param name the name of the methods\n     * @return a stream of methods that have a given name\n     */\n    default StreamEx<MethodAccess> methods(String name) {\n        return methods().filter(method -> method.name().equals(name));\n    }\n\n    /**\n     * Returns a stream of declared methods that have a given name and match given parameter values or parameter types.\n     *\n     * @param name        the name of the methods\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of methods that have a given name and match given parameter values or types\n     * @see ClassAccess#methods(Object...)\n     */\n    default StreamEx<MethodAccess> methods(String name, Object... argsOrTypes) {\n        return methods().filter(method -> method.name().equals(name)).filter(method -> Parameters.matches(method, argsOrTypes));\n    }\n\n    /**\n     * Returns a declared method in the represented class by a given index, or null if method by given index doesn't\n     * exist. Note that method order in the source code is not guaranteed to be preserved during runtime.\n     *\n     * @param index the method index\n     * @return a method at a given index in the represented class, or null if method at a given index doesn't exist\n     */\n    @Nullable\n    default MethodAccess method(int index) {\n        return methods().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared method that matches given parameter values or types, or null if no matches are found.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a method that accepts given parameter values or parameter types, or null if method is not found\n     * @see ClassAccess#methods(Object...)\n     */\n    @Nullable\n    default MethodAccess method(Object... argsOrTypes) {\n        return methods(argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first method that matches given method name, or null if no declared method with given name is found.\n     *\n     * @param name a method name\n     * @return a method that has given name, or null if method is not found\n     * @see ClassAccess#methods(String)\n     */\n    @Nullable\n    default MethodAccess method(String name) {\n        return methods(name).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared method that has a given name and match given parameter values or parameter types, or\n     * null if matching method is not found.\n     *\n     * @param name        the name of the method\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a method that have a given name and match given parameter values or types, or null if method is not found\n     * @see ClassAccess#methods(String, Object...)\n     */\n    @Nullable\n    default MethodAccess method(String name, Object... argsOrTypes) {\n        return methods(name, argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns class access of a superclass. Can be null if this class access represents {@link java.lang.Object}.\n     *\n     * @return the superclass access of represented class\n     */\n    @Nullable\n    default ClassAccess<?> superclass() {\n        return (ClassAccess<?>) parent();\n    }\n\n}\n", "public interface ClassAccess<T> extends Reflectable, Named, Accessible<ClassAccess<T>> {\n\n    /**\n     * Returns the class that this class access represents.\n     *\n     * @return the represented class\n     */\n    Class<T> source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {\n        return UnreflectType.of(source().getDeclaringClass());\n    }\n\n    /**\n     * Creates a new instance of a class, using runtime constructor lookup based on given parameter arguments.\n     *\n     * @param args the constructor arguments\n     * @return an instance of represented class\n     */\n    T create(Object... args);\n\n    /**\n     * Returns a stream of all declared constructors in the represented class. Represented by {@link ConstructorAccess}.\n     *\n     * @return a stream of constructors in the represented class\n     */\n    StreamEx<ConstructorAccess<T>> constructors();\n\n    /**\n     * Returns a constructor by index, or null if constructor by given index doesn't exist. Note that declaration order\n     * in the source code is not guaranteed to be preserved during runtime.\n     *\n     * @param index the constructor index\n     * @return the declared constructor at a given index in the represented class\n     */\n    @Nullable\n    default ConstructorAccess<T> constructor(int index) {\n        return constructors().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared constructor of represented class, or null if class has no constructors.\n     *\n     * @return the first available constructor in the represented class\n     */\n    default ConstructorAccess<T> constructor() {\n        return constructor(0);\n    }\n\n    /**\n     * Returns a constructors that loosely matches given parameter values or parameter types. This method can be\n     * either supplied with array of values that you are going to pass to the constructor or array of classes that\n     * represent value types. Neither values nor types have to be exact types, as long as they are assignable to a\n     * constructor parameters a match will be found. May cause unexpected results with heavy constructor overloading.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of constructors that accepts given parameter values or parameter types\n     */\n    default StreamEx<ConstructorAccess<T>> constructors(Object... argsOrTypes) {\n        return constructors().filter(constructor -> Parameters.matches(constructor, argsOrTypes));\n    }\n\n    /**\n     * Returns first constructor that loosely matches given parameter values or parameter types, or null if such\n     * constructor is not found in represented class.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return first constructor that accepts given parameter values or parameter types, or null if it's not found\n     * @see ClassAccess#constructors(Object...) \n     */\n    @Nullable\n    default ConstructorAccess<T> constructor(Object... argsOrTypes) {\n        return constructors(argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a stream of declared fields in the represented class. Represented by {@link FieldAccess}.\n     *\n     * @return a stream of fields in the represented class\n     */\n    StreamEx<FieldAccess> fields();\n\n    /**\n     * Returns a field by index, or null if field by given index doesn't exist. Field order in source code should always\n     * match field order during runtime, which makes it rather safe to use source code as a reference for an index.\n     *\n     * @param index the field index\n     * @return the declared field at a given index in the represented class\n     */\n    @Nullable\n    default FieldAccess field(int index) {\n        return fields().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a field by name, or null if field by given name doesn't exist. Field names are in classes guaranteed to\n     * be unique.\n     *\n     * @param name the field name\n     * @return the declared field with a given name in the represented class\n     */\n    default FieldAccess field(String name) {\n        return fields().findFirst(field -> field.name().equals(name)).orElse(null);\n    }\n\n    /**\n     * Returns a stream of declared methods in the represented class. Represented by {@link MethodAccess}.\n     *\n     * @return a stream of methods in the represented class\n     */\n    StreamEx<MethodAccess> methods();\n\n    /**\n     * Returns a stream of methods that loosely matches given parameter values or parameter types. Can be either supplied\n     * with array of values that you are going to pass to the method or array of classes that represent value types.\n     * Neither values nor types have to be exact types, as long as they are assignable to a method parameters a match\n     * will be found.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of methods that accepts given parameter values or parameter types\n     */\n    default StreamEx<MethodAccess> methods(Object... argsOrTypes) {\n        return methods().filter(method -> Parameters.matches(method, argsOrTypes));\n    }\n\n    /**\n     * Returns a stream of declared methods that have a given name in the represented class.\n     *\n     * @param name the name of the methods\n     * @return a stream of methods that have a given name\n     */\n    default StreamEx<MethodAccess> methods(String name) {\n        return methods().filter(method -> method.name().equals(name));\n    }\n\n    /**\n     * Returns a stream of declared methods that have a given name and match given parameter values or parameter types.\n     *\n     * @param name        the name of the methods\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a stream of methods that have a given name and match given parameter values or types\n     * @see ClassAccess#methods(Object...)\n     */\n    default StreamEx<MethodAccess> methods(String name, Object... argsOrTypes) {\n        return methods().filter(method -> method.name().equals(name)).filter(method -> Parameters.matches(method, argsOrTypes));\n    }\n\n    /**\n     * Returns a declared method in the represented class by a given index, or null if method by given index doesn't\n     * exist. Note that method order in the source code is not guaranteed to be preserved during runtime.\n     *\n     * @param index the method index\n     * @return a method at a given index in the represented class, or null if method at a given index doesn't exist\n     */\n    @Nullable\n    default MethodAccess method(int index) {\n        return methods().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared method that matches given parameter values or types, or null if no matches are found.\n     *\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a method that accepts given parameter values or parameter types, or null if method is not found\n     * @see ClassAccess#methods(Object...)\n     */\n    @Nullable\n    default MethodAccess method(Object... argsOrTypes) {\n        return methods(argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first method that matches given method name, or null if no declared method with given name is found.\n     *\n     * @param name a method name\n     * @return a method that has given name, or null if method is not found\n     * @see ClassAccess#methods(String)\n     */\n    @Nullable\n    default MethodAccess method(String name) {\n        return methods(name).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the first declared method that has a given name and match given parameter values or parameter types, or\n     * null if matching method is not found.\n     *\n     * @param name        the name of the method\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return a method that have a given name and match given parameter values or types, or null if method is not found\n     * @see ClassAccess#methods(String, Object...)\n     */\n    @Nullable\n    default MethodAccess method(String name, Object... argsOrTypes) {\n        return methods(name, argsOrTypes).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns class access of a superclass. Can be null if this class access represents {@link java.lang.Object}.\n     *\n     * @return the superclass access of represented class\n     */\n    @Nullable\n    default ClassAccess<?> superclass() {\n        return (ClassAccess<?>) parent();\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/ParameterAccess.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Named;\nimport dev.klepto.unreflect.property.Reflectable;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\n\n/**", "\n/**\n * Represents a parameter of declared constructor or method of a class. Enables annotation, type and name access.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface ParameterAccess extends Reflectable, Named {\n\n    /**\n     * Reflection representation of the parameter.\n     *\n     * @return a reflection representation of the parameter\n     * @see Constructor#getParameters()\n     * @see Method#getParameters()\n     */\n    Parameter source();\n\n    /**\n     * Returns the type that declares this member.\n     *\n     * @return the unreflect type that declares this member\n     */\n    default UnreflectType declaringType() {", "        if (parent() instanceof ConstructorAccess) {\n            return constructor().declaringType();\n        }\n        return method().declaringType();\n    }\n\n    /**\n     * Returns the constructor that contains this parameter.\n     *\n     * @return the constructor containing this parameter\n     * @throws RuntimeException if parameter belongs to a method and not a constructor\n     */\n    default ConstructorAccess<?> constructor() throws RuntimeException {\n        return (ConstructorAccess<?>) parent();\n    }\n\n    /**\n     * Returns the method that contains this parameter.\n     *\n     * @return the method containing this parameter\n     * @throws RuntimeException if parameter belongs to a constructor and not a method\n     */\n    default MethodAccess method() throws RuntimeException {\n        return (MethodAccess) parent();\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/Unreflect.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.reflection.ReflectionClassAccess;\nimport dev.klepto.unreflect.util.JdkInternals;\nimport lombok.SneakyThrows;\nimport lombok.val;\n\n/**\n * Unreflect is small but very powerful alternative to java reflection API. Provides easy to use type, class, field,", "/**\n * Unreflect is small but very powerful alternative to java reflection API. Provides easy to use type, class, field,\n * method and constructor lookup and access. Enables high-performance reflection by using code generation. Bypasses all\n * JVM security checks to enable access to any modules and members for both reflection based and bytecode generated API.\n * Reflection API is accessible by {@link Unreflect#reflect(Class)}.\n * Code-generated API is accessible by {@link Unreflect#unreflect(Class)}.\n * Library utilizes JDK's internal API and is not guaranteed to work with different versions of JDK, this library should\n * not be used in production.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>", " *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n * @see <a href=\"https://github.com/klepto/unreflect\">GitHub Repository</a>\n */\npublic class Unreflect {\n\n    /**\n     * Creates {@link ClassAccess} for a given object which generates bytecode for accessing its members. This method\n     * automatically calls {@link Accessible#bind(Object)} on created accessor in order to skip on supplying instance\n     * every time you want to access its members.\n     *\n     * @param targetObject the target object\n     * @param <T>          type that represents the class of the object\n     * @return a class accessor that will use code-generation rather than reflection for accessing members\n     * @see Unreflect#unreflect(Class)\n     */\n    public static <T> ClassAccess<T> unreflect(T targetObject) {\n        return reflect(targetObject).unreflect();\n    }\n\n    /**\n     * Creates {@link ClassAccess} for a given class which generates bytecode for accessing its members. Access to any\n     * fields, methods or constructors will automatically generate code for direct access to all members. Bytecode\n     * generation is very costly and should be only used during initialization in order to get performance benefits\n     * it provides over regular reflection. If you want bytecode to be only generated for specific members, use\n     * {@link Unreflect#reflect(Object)} for lookup and then call {@link Accessible#unreflect()}.\n     *\n     * @param targetClass the target class\n     * @param <T>         type that represents the class\n     * @return a class accessor that will use code-generation rather than reflection for accessing its members\n     */\n    public static <T> ClassAccess<T> unreflect(Class<T> targetClass) {\n        return reflect(targetClass).unreflect();\n    }\n\n    /**\n     * Creates {@link ClassAccess} for a given object that use reflection API to access its members. This method\n     * automatically calls {@link Accessible#bind(Object)} on created accessor in order to skip on supplying instance\n     * every time you want to access its members.\n     *\n     * @param targetObject the target object\n     * @param <T>          type that represents the class of the object\n     * @return a class accessor that will use code-generation rather than reflection for accessing members\n     * @see Unreflect#reflect(Class)\n     */\n    public static <T> ClassAccess<T> reflect(T targetObject) {\n        val targetClass = (Class<T>) targetObject.getClass();\n        return reflect(targetClass).bind(targetObject);\n    }\n\n    /**\n     * Creates {@link ClassAccess} for a given class name that use reflection API to access its members.\n     *\n     * @param targetClassName the target class name\n     * @return a class accessor that will use reflection API for accessing its members\n     * @throws RuntimeException if class with a given name cannot be found\n     * @see Unreflect#reflect(Class)\n     */\n    @SneakyThrows", "    public static ClassAccess<?> reflect(String targetClassName) throws RuntimeException {\n        return reflect(Class.forName(targetClassName));\n    }\n\n    /**\n     * Creates {@link ClassAccess} for a given class that use reflection API to access its members. All members are\n     * automatically set to accessible upon lookup to prevent any security checks by the JVM. This allows for\n     * unrestricted access to anything regardless of module or visibility.\n     *\n     * @param targetClass the target class\n     * @param <T>         type that represents the class\n     * @return a class accessor that will use reflection API for accessing its members\n     */\n    public static <T> ClassAccess<T> reflect(Class<T> targetClass) {\n        return new ReflectionClassAccess<>(targetClass, null);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/UnreflectType.java", "chunked_list": ["package dev.klepto.unreflect;\n\nimport com.google.common.reflect.TypeToken;\nimport dev.klepto.unreflect.property.Named;\nimport dev.klepto.unreflect.util.JdkInternals;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.ParameterizedType;", "import javax.annotation.Nullable;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\n\n/**\n * A wrapper for java types enabling simple generic lookup, instance allocation and superclass and subtype resolving.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class UnreflectType implements Named {\n\n    private final TypeToken typeToken;\n\n    private UnreflectType(TypeToken<?> typeToken) {\n        this.typeToken = typeToken;\n    }\n\n    /**\n     * Returns a reflection-based {@link ClassAccess} for this type.\n     *\n     * @return a reflection access for class that this type represents\n     */\n    public ClassAccess<?> reflect() {\n        return Unreflect.reflect(toClass());\n    }\n\n    /**\n     * Returns a bytecode-based {@link ClassAccess} for this type.\n     *\n     * @return a bytecode access for class that this type represents\n     */\n    public ClassAccess<?> unreflect() {\n        return Unreflect.unreflect(toClass());\n    }\n\n    /**\n     * Allocates a new instance of this type without calling any of its constructors. Enables initialization of any\n     * object of any type regardless of constructor visibility. Note that any important initialization code might be\n     * skipped.\n     *\n     * @param <T> generic type for automatic return value casting\n     * @return a new instance of this type\n     */\n    public <T> T allocate() {\n        return (T) JdkInternals.allocateInstance(toClass());\n    }\n\n    /**\n     * Returns the name of this type.\n     *\n     * @return the name of this type\n     */\n    @Override", " * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class UnreflectType implements Named {\n\n    private final TypeToken typeToken;\n\n    private UnreflectType(TypeToken<?> typeToken) {\n        this.typeToken = typeToken;\n    }\n\n    /**\n     * Returns a reflection-based {@link ClassAccess} for this type.\n     *\n     * @return a reflection access for class that this type represents\n     */\n    public ClassAccess<?> reflect() {\n        return Unreflect.reflect(toClass());\n    }\n\n    /**\n     * Returns a bytecode-based {@link ClassAccess} for this type.\n     *\n     * @return a bytecode access for class that this type represents\n     */\n    public ClassAccess<?> unreflect() {\n        return Unreflect.unreflect(toClass());\n    }\n\n    /**\n     * Allocates a new instance of this type without calling any of its constructors. Enables initialization of any\n     * object of any type regardless of constructor visibility. Note that any important initialization code might be\n     * skipped.\n     *\n     * @param <T> generic type for automatic return value casting\n     * @return a new instance of this type\n     */\n    public <T> T allocate() {\n        return (T) JdkInternals.allocateInstance(toClass());\n    }\n\n    /**\n     * Returns the name of this type.\n     *\n     * @return the name of this type\n     */\n    @Override", "    public String name() {\n        return toClass().getName();\n    }\n\n    /**\n     * Returns the superclass type of this type, or null if this type represents {@link java.lang.Object}.\n     *\n     * @return the superclass type, or null if superclass doesn't exist\n     */\n    @Nullable\n    public UnreflectType superType() {\n        val superClass = toClass().getSuperclass();", "    public UnreflectType superType() {\n        val superClass = toClass().getSuperclass();\n        if (superClass == null) {\n            return null;\n        }\n\n        val superTypeToken = typeToken.getSupertype(superClass);\n        return UnreflectType.of(superTypeToken);\n    }\n\n    /**\n     * Returns the superclass type of this type at given index (depth), or null if superclass at given depth doesn't\n     * exist.\n     *\n     * @param index the superclass index\n     * @return the superclass type at a given depth\n     */\n    @Nullable", "    public UnreflectType superType(int index) {\n        return superTypes().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a stream of all superclass types up to {@link java.lang.Object}.\n     *\n     * @return a stream containing all superclass types\n     */\n    public StreamEx<UnreflectType> superTypes() {\n        val result = new ArrayList<UnreflectType>();\n        UnreflectType superType = this;", "        while ((superType = superType.superType()) != null) {\n            result.add(superType);\n        }\n        return StreamEx.of(result);\n    }\n\n    /**\n     * Returns a stream of all implemented types, this includes both super classes and implemented interfaces.\n     *\n     * @return a stream containing all implemented types\n     */\n    public StreamEx<UnreflectType> subTypes() {\n        return StreamEx.of(typeToken.getTypes()).map(UnreflectType::of);\n    }\n\n    /**\n     * Returns a stream of all generic types associated with this type. Sometimes due to type erasure generics are not\n     * preserved in which case, empty stream will be returned.\n     *\n     * @return a stream containing generic types associated with this type\n     */\n    public StreamEx<UnreflectType> genericTypes() {\n        val parameterizedType = (ParameterizedType) typeToken.getType();\n        return StreamEx.of(parameterizedType.getActualTypeArguments()).map(UnreflectType::of);\n    }\n\n    /**\n     * Returns the first generic type associated with this type, or null if this type has no associated generics\n     *\n     * @return the first generic type associated with this type, or null if unavailable\n     */\n    @Nullable", "    public UnreflectType genericType() {\n        return genericTypes().findFirst().orElse(null);\n    }\n\n    /**\n     * Returns the generic type at a given index (slot), or null if generic type is unavailable. For example, if this\n     * type is {@code Map<String, Integer>} calling {@code genericType(1)} will return type of {@link Integer}. Can be\n     * chained to resolve generics at any depth.\n     *\n     * @param index the slot of the generic\n     * @return the generic type at a given slot\n     */", "    public UnreflectType genericType(int index) {\n        return genericTypes().skip(index).findFirst().orElse(null);\n    }\n\n    /**\n     * Returns a component type of this type, or null if this type has no component type. Only applicable to array types.\n     *\n     * @return the component type of this array type, or null if no component type present\n     * @see UnreflectType#isArray()\n     */\n    public UnreflectType componentType() {\n        val componentType = typeToken.getComponentType();", "    public UnreflectType componentType() {\n        val componentType = typeToken.getComponentType();\n        if (componentType == null) {\n            return null;\n        }\n\n        return of(componentType);\n    }\n\n    /**\n     * Checks if this type matches the given value or type.\n     *\n     * @param object the value or type\n     * @return true if this type is assignable for a given value or type\n     */", "    public boolean matches(Object object) {\n        return typeToken.isSupertypeOf(of(object).toClass());\n    }\n\n    /**\n     * Checks if this type class matches the given value or type class.\n     *\n     * @param object the value or type\n     * @return true if this type class is the class of given value or type\n     */\n    public boolean matchesExact(Object object) {\n        return toClass() == of(object).toClass();\n    }\n\n    /**\n     * Checks if this type is an array type.\n     *\n     * @return true if this type is an array type\n     */", "    public boolean matchesExact(Object object) {\n        return toClass() == of(object).toClass();\n    }\n\n    /**\n     * Checks if this type is an array type.\n     *\n     * @return true if this type is an array type\n     */\n    public boolean isArray() {\n        return typeToken.isArray();\n    }\n\n    /**\n     * Checks if this type is a primitive type.\n     *\n     * @return true if this type is a primitive type\n     */", "    public boolean isArray() {\n        return typeToken.isArray();\n    }\n\n    /**\n     * Checks if this type is a primitive type.\n     *\n     * @return true if this type is a primitive type\n     */\n    public boolean isPrimitive() {\n        return typeToken.isPrimitive();\n    }\n\n    /**\n     * Returns {@link Type} representation of this type.\n     *\n     * @return a reflection representation of this type\n     */", "    public boolean isPrimitive() {\n        return typeToken.isPrimitive();\n    }\n\n    /**\n     * Returns {@link Type} representation of this type.\n     *\n     * @return a reflection representation of this type\n     */\n    public Type toType() {\n        return typeToken.getType();\n    }\n\n    /**\n     * Returns {@link Class} representation of this type.\n     *\n     * @return a class representation of this type\n     */\n    public Class<?> toClass() {\n        return typeToken.getRawType();\n    }\n\n    @Override", "    public Type toType() {\n        return typeToken.getType();\n    }\n\n    /**\n     * Returns {@link Class} representation of this type.\n     *\n     * @return a class representation of this type\n     */\n    public Class<?> toClass() {\n        return typeToken.getRawType();\n    }\n\n    @Override", "    public String toString() {\n        val type = isArray() ? componentType() : this;\n        val simpleName = type.toClass().getSimpleName();\n        return simpleName + (isArray() ? \"[]\" : \"\");\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        return typeToken.equals(object);\n    }\n\n    @Override", "    public int hashCode() {\n        return typeToken.hashCode();\n    }\n\n    /**\n     * Creates a type representation of a given value, value can be class, type, typetoken or just a regular value in\n     * which case it's class is going to be used as type.\n     *\n     * @param object the value\n     * @return the type representation of a given value\n     */", "    public static UnreflectType of(Object object) {\n        if (object instanceof Class<?>) {\n            return of((Class<?>) object);\n        }\n\n        if (object instanceof Type) {\n            return of((Type) object);\n        }\n\n        if (object instanceof TypeToken<?>) {\n            return of((TypeToken<?>) object);\n        }\n\n        return of(object.getClass());\n    }\n\n    /**\n     * Creates a type representation for a given {@link Type}.\n     *\n     * @param type the reflection type\n     * @return the type representation of a given reflection type\n     */", "        if (object instanceof TypeToken<?>) {\n            return of((TypeToken<?>) object);\n        }\n\n        return of(object.getClass());\n    }\n\n    /**\n     * Creates a type representation for a given {@link Type}.\n     *\n     * @param type the reflection type\n     * @return the type representation of a given reflection type\n     */", "    public static UnreflectType of(Type type) {\n        return of(TypeToken.of(type));\n    }\n\n    /**\n     * Creates a type representation for a given {@link Class}.\n     *\n     * @param type the class type\n     * @return the type representation of a given class type\n     */\n    public static UnreflectType of(Class<?> type) {\n        return of(TypeToken.of(type));\n    }\n\n    /**\n     * Creates a type representation for a given guava's {@link TypeToken}.\n     *\n     * @param type the guava type\n     * @return the type representation of a given guava type\n     */", "    public static UnreflectType of(Class<?> type) {\n        return of(TypeToken.of(type));\n    }\n\n    /**\n     * Creates a type representation for a given guava's {@link TypeToken}.\n     *\n     * @param type the guava type\n     * @return the type representation of a given guava type\n     */\n    public static UnreflectType of(TypeToken<?> type) {\n        return new UnreflectType(type);\n    }\n\n}", "    public static UnreflectType of(TypeToken<?> type) {\n        return new UnreflectType(type);\n    }\n\n}"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/BytecodeMethodAccess.java", "chunked_list": ["package dev.klepto.unreflect.bytecode;\n\nimport dev.klepto.unreflect.MethodAccess;\nimport dev.klepto.unreflect.bytecode.asm.InvokableAccessor;\nimport dev.klepto.unreflect.reflection.ReflectionMethodAccess;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.experimental.Delegate;\n\n/**", "\n/**\n * Bytecode access to a method of a class. Delegates all methods to {@link ReflectionMethodAccess} except the\n * {@link MethodAccess#invoke(Object...)} method for which it uses direct accessor.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@RequiredArgsConstructor\npublic class BytecodeMethodAccess implements MethodAccess {\n\n    @Delegate(excludes = Overrides.class)\n    private final ReflectionMethodAccess delegate;\n    private final InvokableAccessor accessor;\n\n    @Override", "public class BytecodeMethodAccess implements MethodAccess {\n\n    @Delegate(excludes = Overrides.class)\n    private final ReflectionMethodAccess delegate;\n    private final InvokableAccessor accessor;\n\n    @Override\n    public MethodAccess unreflect() {\n        return this;\n    }\n\n    @Override", "    public MethodAccess reflect() {\n        return delegate;\n    }\n\n    @Override\n    public MethodAccess bind(Object object) {\n        return new BytecodeMethodAccess((ReflectionMethodAccess) delegate.bind(object), accessor);\n    }\n\n    @Override\n    public <T> T invoke(Object... args) {\n        return (T) accessor.invoke(object(), args);\n    }\n\n    @Override", "    public String toString() {\n        return delegate.toString();\n    }\n\n    private interface Overrides {\n        void unreflect();\n        void reflect();\n        void bind(Object object);\n        void invoke(Object... args);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/BytecodeFieldAccess.java", "chunked_list": ["package dev.klepto.unreflect.bytecode;\n\nimport dev.klepto.unreflect.FieldAccess;\nimport dev.klepto.unreflect.bytecode.asm.MutableAccessor;\nimport dev.klepto.unreflect.reflection.ReflectionFieldAccess;\nimport lombok.RequiredArgsConstructor;\nimport lombok.experimental.Delegate;\n\n/**\n * Bytecode access to a field of a class. Delegates all functions to {@link ReflectionFieldAccess} except the", "/**\n * Bytecode access to a field of a class. Delegates all functions to {@link ReflectionFieldAccess} except the\n * {@link FieldAccess#set(Object)} and {@link FieldAccess#get()} functions for which it uses direct accessor.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@RequiredArgsConstructor\npublic class BytecodeFieldAccess implements FieldAccess {\n\n    @Delegate(excludes = Overrides.class)\n    private final ReflectionFieldAccess delegate;\n    private final MutableAccessor accessor;\n\n    @Override", "    public FieldAccess unreflect() {\n        return this;\n    }\n\n    @Override\n    public FieldAccess reflect() {\n        return delegate;\n    }\n\n    @Override\n    public FieldAccess bind(Object object) {\n        return new BytecodeFieldAccess((ReflectionFieldAccess) delegate.bind(object), accessor);\n    }\n\n    @Override\n    public <T> T get() {\n        return (T) accessor.get(object());\n    }\n\n    @Override", "    public FieldAccess bind(Object object) {\n        return new BytecodeFieldAccess((ReflectionFieldAccess) delegate.bind(object), accessor);\n    }\n\n    @Override\n    public <T> T get() {\n        return (T) accessor.get(object());\n    }\n\n    @Override\n    public void set(Object value) {\n        accessor.set(object(), value);\n    }\n\n    @Override", "    public void set(Object value) {\n        accessor.set(object(), value);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n    private interface Overrides {\n        void unreflect();\n        void reflect();\n        void bind(Object object);\n        void get();\n        void set(Object value);\n\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/BytecodeContructorAccess.java", "chunked_list": ["package dev.klepto.unreflect.bytecode;\n\nimport dev.klepto.unreflect.ConstructorAccess;\nimport dev.klepto.unreflect.bytecode.asm.InvokableAccessor;\nimport dev.klepto.unreflect.reflection.ReflectionConstructorAccess;\nimport lombok.RequiredArgsConstructor;\nimport lombok.experimental.Delegate;\n\n/**\n * Bytecode access to a constructor of a class. Delegates all functions to {@link ReflectionConstructorAccess} except", "/**\n * Bytecode access to a constructor of a class. Delegates all functions to {@link ReflectionConstructorAccess} except\n * the {@link ConstructorAccess#invoke(Object...)} function for which it uses direct accessor.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@RequiredArgsConstructor\npublic class BytecodeContructorAccess<T> implements ConstructorAccess<T> {\n\n    @Delegate(excludes = Overrides.class)\n    private final ReflectionConstructorAccess<T> delegate;\n    private final InvokableAccessor accessor;\n\n    @Override\n    public ConstructorAccess<T> unreflect() {\n        return this;\n    }\n\n    @Override\n    public ConstructorAccess<T> reflect() {\n        return delegate;\n    }\n\n    @Override", "    public T invoke(Object... args) {\n        return (T) accessor.invoke(null, args);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n    private interface Overrides {\n        void unreflect();\n\n        void reflect();\n\n        void invoke(Object... args);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/BytecodeClassAccess.java", "chunked_list": ["package dev.klepto.unreflect.bytecode;\n\nimport dev.klepto.unreflect.property.Accessible;\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.ClassAccess;\nimport dev.klepto.unreflect.ConstructorAccess;\nimport dev.klepto.unreflect.FieldAccess;\nimport dev.klepto.unreflect.MethodAccess;\nimport dev.klepto.unreflect.reflection.ReflectionClassAccess;\nimport lombok.RequiredArgsConstructor;", "import dev.klepto.unreflect.reflection.ReflectionClassAccess;\nimport lombok.RequiredArgsConstructor;\nimport lombok.experimental.Delegate;\nimport one.util.streamex.StreamEx;\n\n/**\n * Bytecode version of {@link ClassAccess}. All members returned by this class generate bytecode for direct access.\n * Since bytecode generation is very costly use this only when you need direct access to the entire class, otherwise\n * use of {@link ReflectionClassAccess} is advised and selectively converting members to bytecode access by calling\n * {@link Accessible#unreflect()}.", " * use of {@link ReflectionClassAccess} is advised and selectively converting members to bytecode access by calling\n * {@link Accessible#unreflect()}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@RequiredArgsConstructor\npublic class BytecodeClassAccess<T> implements ClassAccess<T> {\n\n    @Delegate(excludes = Overrides.class)\n    private final ReflectionClassAccess<T> delegate;\n\n    @Override\n    public ClassAccess<T> unreflect() {\n        return this;\n    }\n\n    @Override\n    public ClassAccess<T> reflect() {\n        return delegate;\n    }\n\n    @Override\n    public ClassAccess<T> bind(Object object) {\n        return delegate.bind(object).unreflect();\n    }\n\n    @Override", "    public Reflectable parent() {\n        return ((ClassAccess<?>)delegate.parent()).unreflect();\n    }\n\n    @Override\n    public StreamEx<ConstructorAccess<T>> constructors() {\n        return delegate.constructors().map(Accessible::unreflect);\n    }\n\n    @Override\n    public StreamEx<FieldAccess> fields() {\n        return delegate.fields().map(Accessible::unreflect);\n    }\n\n    @Override\n    public StreamEx<MethodAccess> methods() {\n        return delegate.methods().map(Accessible::unreflect);\n    }\n\n    @Override", "    public String toString() {\n        return delegate.toString();\n    }\n\n    private interface Overrides {\n        void unreflect();\n        void reflect();\n        void bind(Object object);\n        void parent();\n        void constructors();\n        void constructor();\n        void constructor(int index);\n        void constructor(Object[] argsOrTypes);\n        void fields();\n        void field(int index);\n        void field(String name);\n        void methods();\n        void methods(Object[] argsOrTypes);\n        void methods(String name);\n        void methods(String name, Object[] argsOrTypes);\n        void method(int index);\n        void method(Object[] argsOrTypes);\n        void method(String name);\n        void method(String name, Object[] argsOrTypes);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/asm/InvokableAccessor.java", "chunked_list": ["package dev.klepto.unreflect.bytecode.asm;\n\nimport lombok.Value;\n\nimport java.util.function.BiFunction;\n\n/**\n * Contains implementation of direct access to method or constructor of a class.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>", " *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@Value\npublic class InvokableAccessor {\n\n    BiFunction function;\n\n    public Object invoke(Object object, Object... args) {\n        return function.apply(object, (Object) args);\n    }\n\n}\n", "    public Object invoke(Object object, Object... args) {\n        return function.apply(object, (Object) args);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/asm/MutableAccessor.java", "chunked_list": ["package dev.klepto.unreflect.bytecode.asm;\n\n\nimport lombok.Value;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\n/**\n * Contains implementations of direct access to a field of class.", "/**\n * Contains implementations of direct access to a field of class.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@Value\npublic class MutableAccessor {\n\n    Function getter;\n    BiConsumer setter;\n", "    public Object get(Object object) {\n        return getter.apply(object);\n    }\n\n    public void set(Object object, Object value) {\n        setter.accept(object, value);\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/bytecode/asm/AccessorGenerator.java", "chunked_list": ["package dev.klepto.unreflect.bytecode.asm;\n\nimport com.google.common.primitives.Primitives;\nimport dev.klepto.unreflect.util.JdkInternals;\nimport lombok.Getter;\nimport lombok.SneakyThrows;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Label;", "import org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Label;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Type;\n\nimport java.lang.reflect.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;", "import java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\nimport static org.objectweb.asm.Opcodes.*;\n\n/**\n * Bytecode generation of field, constructor and method accessors. Utilizes the JDK's internal MagicAccessorImpl class,\n * which allows to bypass all security checks and directly access private and otherwise unreachable members.", " * Bytecode generation of field, constructor and method accessors. Utilizes the JDK's internal MagicAccessorImpl class,\n * which allows to bypass all security checks and directly access private and otherwise unreachable members.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class AccessorGenerator {\n\n    @Getter(lazy = true)\n    private static final AccessorGenerator instance = new AccessorGenerator();\n\n    private final AtomicInteger accessorIndex = new AtomicInteger();\n    private final String superClass = JdkInternals.getMagicAccessorImpl().getName();\n\n    @SneakyThrows", "    public MutableAccessor generateMutableAccessor(Field field) {\n        val className = getNextClassName();\n        val cw = new ClassWriter(COMPUTE_MAXS);\n        generateHeader(cw, className, Function.class.getName(), BiConsumer.class.getName());\n\n        val fieldOwner = Type.getInternalName(field.getDeclaringClass());\n        val fieldName = field.getName();\n        val fieldType = field.getType();\n        val fieldModifiers = field.getModifiers();\n        val fieldDescriptor = Type.getDescriptor(field.getType());\n\n        // Getter.\n        {\n            val methodDescriptor = Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class));\n            val fieldOpcode = Modifier.isStatic(fieldModifiers) ? GETSTATIC : GETFIELD;\n            val mv = cw.visitMethod(ACC_PUBLIC, \"apply\", methodDescriptor, null, null);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitTypeInsn(CHECKCAST, fieldOwner);\n            mv.visitFieldInsn(fieldOpcode, fieldOwner, fieldName, fieldDescriptor);", "            if (isPrimitive(fieldType)) {\n                generateWrapPrimitive(mv, fieldType);\n            }\n            mv.visitInsn(ARETURN);\n            mv.visitMaxs(-1, -1);\n            mv.visitEnd();\n        }\n\n        // Setter.\n        {\n            val methodDescriptor = Type.getMethodDescriptor(\n                    Type.getType(void.class),\n                    Type.getType(Object.class),\n                    Type.getType(Object.class)\n            );\n            val fieldOpcode = Modifier.isStatic(field.getModifiers()) ? PUTSTATIC : PUTFIELD;\n            val mv = cw.visitMethod(ACC_PUBLIC, \"accept\", methodDescriptor, null, null);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitTypeInsn(CHECKCAST, fieldOwner);\n            mv.visitVarInsn(ALOAD, 2);", "            if (isPrimitive(field.getType())) {\n                generateUnwrapPrimitive(mv, fieldType);\n            } else {\n                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(fieldType));\n            }\n            mv.visitFieldInsn(fieldOpcode, fieldOwner, fieldName, fieldDescriptor);\n            mv.visitInsn(RETURN);\n            mv.visitMaxs(-1, -1);\n            mv.visitEnd();\n        }\n\n        // Finish class generation.\n        cw.visitEnd();\n\n        // Load accessor.\n        val accessor = loadAccessor(field.getDeclaringClass(), className, cw.toByteArray());\n        return new MutableAccessor((Function) accessor, (BiConsumer) accessor);\n    }\n", "    public InvokableAccessor generateInvokableAccessor(Method method) {\n        return _generateInvokableAccessor(method);\n    }\n\n    public InvokableAccessor generateInvokableAccessor(Constructor<?> constructor) {\n        return _generateInvokableAccessor(constructor);\n    }\n\n    private InvokableAccessor _generateInvokableAccessor(Member member) {\n        checkArgument(member instanceof Constructor<?> || member instanceof Method);\n\n        val className = getNextClassName();\n        val cw = new ClassWriter(COMPUTE_MAXS);\n        generateHeader(cw, className, BiFunction.class.getName());\n\n        val invokeDescriptor = Type.getMethodDescriptor(\n                Type.getType(Object.class),\n                Type.getType(Object.class),\n                Type.getType(Object.class)\n        );\n        val mv = cw.visitMethod(ACC_PUBLIC + ACC_INTERFACE, \"apply\", invokeDescriptor, null, null);\n\n        val parameterCount = member instanceof Constructor\n                ? ((Constructor<?>) member).getParameterCount()\n                : ((Method) member).getParameterCount();\n        val exceptionType = Type.getInternalName(RuntimeException.class);\n        val executionLabel = new Label();\n\n        mv.visitVarInsn(ALOAD, 2);\n        mv.visitTypeInsn(CHECKCAST, \"[Ljava/lang/Object;\");\n        mv.visitInsn(ARRAYLENGTH);\n        mv.visitLdcInsn(parameterCount);\n        mv.visitJumpInsn(IF_ICMPEQ, executionLabel);\n        mv.visitTypeInsn(NEW, exceptionType);\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(\"Parameter count mismatch for: \" + member);\n        mv.visitMethodInsn(INVOKESPECIAL, exceptionType, \"<init>\", \"(Ljava/lang/String;)V\", false);\n        mv.visitInsn(ATHROW);\n\n        mv.visitLabel(executionLabel);", "        if (member instanceof Constructor) {\n            val constructor = (Constructor<?>) member;\n            val constructorOwner = Type.getInternalName(constructor.getDeclaringClass());\n            val constructorDescriptor = Type.getConstructorDescriptor(constructor);\n            val constructorParameters = constructor.getParameters();\n\n            mv.visitTypeInsn(NEW, constructorOwner);\n            mv.visitInsn(DUP);\n            for (int i = 0; i < constructorParameters.length; i++) {\n                val parameter = constructorParameters[i];\n                generateArrayParameter(mv, 2, i, parameter.getType());\n            }\n            mv.visitMethodInsn(INVOKEVIRTUAL, constructorOwner, \"<init>\", constructorDescriptor, false);\n        } else {\n            val method = (Method) member;\n            val methodOwner = Type.getInternalName(method.getDeclaringClass());\n            val methodName = method.getName();\n            val methodDescriptor = Type.getMethodDescriptor(method);\n            val methodType = method.getReturnType();\n            val methodStatic = Modifier.isStatic(method.getModifiers());\n            val methodOpcode = methodStatic ? INVOKESTATIC : INVOKEVIRTUAL;\n            val methodParameters = method.getParameters();\n", "            for (int i = 0; i < constructorParameters.length; i++) {\n                val parameter = constructorParameters[i];\n                generateArrayParameter(mv, 2, i, parameter.getType());\n            }\n            mv.visitMethodInsn(INVOKEVIRTUAL, constructorOwner, \"<init>\", constructorDescriptor, false);\n        } else {\n            val method = (Method) member;\n            val methodOwner = Type.getInternalName(method.getDeclaringClass());\n            val methodName = method.getName();\n            val methodDescriptor = Type.getMethodDescriptor(method);\n            val methodType = method.getReturnType();\n            val methodStatic = Modifier.isStatic(method.getModifiers());\n            val methodOpcode = methodStatic ? INVOKESTATIC : INVOKEVIRTUAL;\n            val methodParameters = method.getParameters();\n", "            if (!methodStatic) {\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitTypeInsn(CHECKCAST, methodOwner);\n            }\n\n            for (int i = 0; i < methodParameters.length; i++) {\n                val parameter = methodParameters[i];\n                generateArrayParameter(mv, 2, i, parameter.getType());\n            }\n\n            mv.visitMethodInsn(methodOpcode, methodOwner, methodName, methodDescriptor, false);", "            if (methodType.isPrimitive() && methodType != void.class) {\n                generateWrapPrimitive(mv, method.getReturnType());\n            } else if (methodType == void.class) {\n                mv.visitInsn(ACONST_NULL);\n            }\n        }\n        mv.visitInsn(ARETURN);\n        mv.visitMaxs(-1, -1);\n        mv.visitEnd();\n\n        // Finish class generation.\n        cw.visitEnd();\n\n        // Load accessor.\n        val accessor = loadAccessor(member.getDeclaringClass(), className, cw.toByteArray());\n        return new InvokableAccessor((BiFunction) accessor);\n    }\n\n    @SneakyThrows", "    public Object loadAccessor(Class<?> context, String className, byte[] bytecode) {\n        val accessorClass = JdkInternals.defineClass(context.getClassLoader(), className, bytecode);\n        return JdkInternals.allocateInstance(accessorClass);\n    }\n\n    public String getNextClassName() {\n        val baseClass = superClass + \"$unreflect\";\n        return baseClass + accessorIndex.getAndIncrement();\n    }\n\n    public void generateHeader(ClassWriter cw, String className, String... interfaceNames) {\n        val interfaces = StreamEx.of(interfaceNames).map(AccessorGenerator::getInternal).toArray(String.class);\n\n        cw.visit(\n                V1_8,\n                ACC_PUBLIC,\n                getInternal(className),\n                null,\n                getInternal(superClass),\n                interfaces\n        );\n\n        val mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitMethodInsn(INVOKESPECIAL, getInternal(superClass), \"<init>\", \"()V\", false);\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(-1, -1);\n        mv.visitEnd();\n    }\n", "    public void generateHeader(ClassWriter cw, String className, String... interfaceNames) {\n        val interfaces = StreamEx.of(interfaceNames).map(AccessorGenerator::getInternal).toArray(String.class);\n\n        cw.visit(\n                V1_8,\n                ACC_PUBLIC,\n                getInternal(className),\n                null,\n                getInternal(superClass),\n                interfaces\n        );\n\n        val mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitMethodInsn(INVOKESPECIAL, getInternal(superClass), \"<init>\", \"()V\", false);\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(-1, -1);\n        mv.visitEnd();\n    }\n", "    public void generateArrayParameter(MethodVisitor mv, int arraySlot, int valueIndex, Class<?> parameterType) {\n        mv.visitVarInsn(ALOAD, arraySlot);\n        mv.visitTypeInsn(CHECKCAST, \"[Ljava/lang/Object;\");\n        mv.visitLdcInsn(valueIndex);\n        mv.visitInsn(AALOAD);\n        if (parameterType.isPrimitive()) {\n            generateUnwrapPrimitive(mv, parameterType);\n        } else {\n            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(parameterType));\n        }\n    }\n", "    public void generateWrapPrimitive(MethodVisitor mv, Class<?> type) {\n        val wrapped = Primitives.wrap(type);\n        val unwrapped = Primitives.unwrap(type);\n        val owner = Type.getInternalName(wrapped);\n        val descriptor = Type.getMethodDescriptor(Type.getType(wrapped), Type.getType(unwrapped));\n\n        mv.visitMethodInsn(\n                INVOKESTATIC,\n                owner,\n                \"valueOf\",\n                descriptor,\n                false\n        );\n    }\n", "    public void generateUnwrapPrimitive(MethodVisitor mv, Class<?> type) {\n        val wrapped = Primitives.wrap(type);\n        val unwrapped = Primitives.unwrap(type);\n        val name = unwrapped.getSimpleName() + \"Value\";\n        val owner = Type.getInternalName(wrapped);\n        val descriptor = Type.getMethodDescriptor(Type.getType(unwrapped));\n\n        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(wrapped));\n        mv.visitMethodInsn(\n                INVOKEVIRTUAL,\n                owner,\n                name,\n                descriptor,\n                false\n        );\n    }\n\n    private static boolean isPrimitive(Class<?> type) {\n        return Primitives.allPrimitiveTypes().contains(type);\n    }\n\n    private static String getInternal(String className) {\n        return className.replace('.', '/');\n    }\n\n}"]}
{"filename": "src/main/java/dev/klepto/unreflect/util/JdkInternals.java", "chunked_list": ["package dev.klepto.unreflect.util;\n\nimport lombok.Getter;\nimport lombok.SneakyThrows;\nimport lombok.val;\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Method;\n", "import java.lang.reflect.Method;\n\n/**\n * A set of very unsafe JDK utility methods. The heavy usage of internal JDK API means that this not guaranteed to work\n * on all versions of JDK and might break with future versions. Use with caution.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class JdkInternals {\n\n    private static final Unsafe unsafe;\n    private static final int accessibleFlagIndex;\n    @Getter private static final Class<?> magicAccessorImpl;\n    private static final Class<?> classDefiner;\n    private static final Method defineClassMethod;\n\n    static {\n        unsafe = getUnsafe();\n        accessibleFlagIndex = findAccessibleFlagIndex();\n        magicAccessorImpl = findMagicAccessorImpl();\n        classDefiner = findClassDefiner();\n        defineClassMethod = getDefineClassMethod();\n    }\n\n    private JdkInternals() {\n    }\n\n    @SneakyThrows\n    private static int findAccessibleFlagIndex() {\n        val methodA = JdkInternals.class.getDeclaredMethods()[0];\n        val methodB = JdkInternals.class.getDeclaredMethods()[0];\n        methodA.setAccessible(true);\n        methodB.setAccessible(false);\n", "public class JdkInternals {\n\n    private static final Unsafe unsafe;\n    private static final int accessibleFlagIndex;\n    @Getter private static final Class<?> magicAccessorImpl;\n    private static final Class<?> classDefiner;\n    private static final Method defineClassMethod;\n\n    static {\n        unsafe = getUnsafe();\n        accessibleFlagIndex = findAccessibleFlagIndex();\n        magicAccessorImpl = findMagicAccessorImpl();\n        classDefiner = findClassDefiner();\n        defineClassMethod = getDefineClassMethod();\n    }\n\n    private JdkInternals() {\n    }\n\n    @SneakyThrows\n    private static int findAccessibleFlagIndex() {\n        val methodA = JdkInternals.class.getDeclaredMethods()[0];\n        val methodB = JdkInternals.class.getDeclaredMethods()[0];\n        methodA.setAccessible(true);\n        methodB.setAccessible(false);\n", "        for (int index = 0; index < Byte.MAX_VALUE; index++) {\n            val valueA = unsafe.getBoolean(methodA, (long) index);\n            val valueB = unsafe.getBoolean(methodB, (long) index);\n            if (valueA != valueB) {\n                return index;\n            }\n        }\n\n        throw new RuntimeException(\"Couldn't detect accessible flag index.\");\n    }\n\n    @SneakyThrows\n    private static Unsafe getUnsafe() {", "        try {\n            val theUnsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            theUnsafeField.setAccessible(true);\n            return (Unsafe) theUnsafeField.get(null);\n        } catch (Throwable err) {\n            throw new RuntimeException(\"Couldn't acquire the Unsafe in current JDK version.\");\n        }\n    }\n\n    private static Class<?> getClass(String name) {\n        try {\n            return Class.forName(name);\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }\n\n    private static Class<?> findClassDefiner() {\n        Class<?> classDefiner = getClass(\"jdk.internal.reflect.ClassDefiner\");", "        try {\n            return Class.forName(name);\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }\n\n    private static Class<?> findClassDefiner() {\n        Class<?> classDefiner = getClass(\"jdk.internal.reflect.ClassDefiner\");\n        if (classDefiner == null) {\n            classDefiner = getClass(\"sun.reflect.ClassDefiner\");\n        }", "        if (classDefiner == null) {\n            classDefiner = getClass(\"sun.reflect.ClassDefiner\");\n        }\n        if (classDefiner == null) {\n            throw new RuntimeException(\"Couldn't detect ClassDefiner in current JDK version.\");\n        }\n        return classDefiner;\n    }\n\n    private static Method getDefineClassMethod() {\n        try {\n            val method = classDefiner.getDeclaredMethods()[0];\n            setAccessible(method, true);\n            return method;\n        } catch (Throwable err) {\n            throw new RuntimeException(\"Couldn't detect defineClass method in current JDK version.\");\n        }\n    }\n\n    private static Class<?> findMagicAccessorImpl() {\n        Class<?> magicAccessorImpl = getClass(\"jdk.internal.reflect.MagicAccessorImpl\");", "        try {\n            val method = classDefiner.getDeclaredMethods()[0];\n            setAccessible(method, true);\n            return method;\n        } catch (Throwable err) {\n            throw new RuntimeException(\"Couldn't detect defineClass method in current JDK version.\");\n        }\n    }\n\n    private static Class<?> findMagicAccessorImpl() {\n        Class<?> magicAccessorImpl = getClass(\"jdk.internal.reflect.MagicAccessorImpl\");", "        if (magicAccessorImpl == null) {\n            magicAccessorImpl = getClass(\"sun.reflect.MagicAccessorImpl\");\n        }\n        if (magicAccessorImpl == null) {\n            throw new RuntimeException(\"Couldn't detect MagicAccessorImpl in current JDK version.\");\n        }\n        return magicAccessorImpl;\n    }\n\n    /**\n     * Checks if reflection object is accessible ({@link AccessibleObject#setAccessible(boolean)}) using Unsafe API.\n     * Since accessible flag is private property, this accesses memory directly to acquire the boolean.\n     *\n     * @param object the reflection object\n     * @return true if object is flagged as accessible\n     */", "    public static boolean isAccessible(AccessibleObject object) {\n        return unsafe.getBoolean(object, (long) accessibleFlagIndex);\n    }\n\n    /**\n     * Changes reflection object's accessible flag bypassing all security checks using Unsafe API. This is achieved by\n     * changing field value directly in the memory. Note that altering memory directly is significantly faster than\n     * using field reflection.\n     *\n     * @param object     the reflection object\n     * @param accessible the accessible flag\n     */", "    public static void setAccessible(AccessibleObject object, boolean accessible) {\n        unsafe.putBoolean(object, (long) accessibleFlagIndex, accessible);\n    }\n\n    /**\n     * Allocates a new instance of a {@link java.lang.Class} without invoking any constructors.\n     *\n     * @param type the class type\n     * @return the instantiated object\n     */\n    @SneakyThrows", "    public static Object allocateInstance(Class<?> type) {\n        return unsafe.allocateInstance(type);\n    }\n\n    /**\n     * Defines a class in the target {@link ClassLoader}. Utilizes the class loading of native {@link java.lang.reflect}\n     * API. Using JDK's internal class loader bypasses a lot of security checks and allows to load bytecode that otherwise\n     * be impossible to load by a regular class loader.\n     *\n     * @param classLoader the target class loader\n     * @param name        the name of the class\n     * @param bytecode    the class bytecode\n     * @return the loaded class\n     */\n    @SneakyThrows", "    public static Class<?> defineClass(ClassLoader classLoader, String name, byte[] bytecode) {\n        return (Class<?>) defineClassMethod.invoke(\n                null,\n                name,\n                bytecode,\n                0,\n                bytecode.length,\n                classLoader\n        );\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/util/Parameters.java", "chunked_list": ["package dev.klepto.unreflect.util;\n\nimport dev.klepto.unreflect.ParameterAccess;\nimport dev.klepto.unreflect.property.Invokable;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\n\nimport java.util.Collection;\n\n/**", "\n/**\n * Utility functions for parameter matching.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic class Parameters {\n\n    private Parameters() {\n    }\n\n    /**\n     * Matches parameter arguments or parameter types with given invokable. Used for ability to lookup constructors and\n     * methods by using either values or value types.\n     *\n     * @param invokable   the invokable\n     * @param argsOrTypes an array of parameter values or parameter types\n     * @return true if invokable parameters match given parameter values or types\n     */", "    public static boolean matches(Invokable invokable, Object[] argsOrTypes) {\n        val parameters = invokable.parameters().toList();\n        if (parameters.size() != argsOrTypes.length) {\n            return false;\n        }\n\n        val isTypes = StreamEx.of(argsOrTypes).allMatch(value -> value instanceof Class);\n        for (int i = 0; i < parameters.size(); i++) {\n            val value = isTypes ? argsOrTypes[i] : argsOrTypes[i].getClass();\n            if (!parameters.get(i).type().matches(value)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Converts collection of parameters into easy to read signature. Used for debugging methods and constructors.\n     *\n     * @param parameters a collection containing parameters\n     * @return a parameter signature string\n     */", "            if (!parameters.get(i).type().matches(value)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Converts collection of parameters into easy to read signature. Used for debugging methods and constructors.\n     *\n     * @param parameters a collection containing parameters\n     * @return a parameter signature string\n     */", "    public static String toString(Collection<ParameterAccess> parameters) {\n        val result = StreamEx.of(parameters).map(ParameterAccess::toString).joining(\", \");\n        return \"(\" + result + \")\";\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/reflection/ReflectionParameterAccess.java", "chunked_list": ["package dev.klepto.unreflect.reflection;\n\nimport dev.klepto.unreflect.*;\nimport dev.klepto.unreflect.property.Reflectable;\nimport lombok.RequiredArgsConstructor;\nimport one.util.streamex.StreamEx;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Parameter;\n", "import java.lang.reflect.Parameter;\n\n/**\n * Reflection-based implementation of {@link ParameterAccess}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@RequiredArgsConstructor\npublic class ReflectionParameterAccess implements ParameterAccess {\n\n    private final Reflectable parent;\n    private final Parameter source;\n\n    @Override", "public class ReflectionParameterAccess implements ParameterAccess {\n\n    private final Reflectable parent;\n    private final Parameter source;\n\n    @Override\n    public Reflectable parent() {\n        return parent;\n    }\n\n    @Override", "    public Parameter source() {\n        return source;\n    }\n\n    @Override\n    public String name() {\n        return source.getName();\n    }\n\n    @Override\n    public ConstructorAccess<?> constructor() {\n        return (ConstructorAccess<?>) parent();\n    }\n\n    @Override", "    public MethodAccess method() {\n        return (MethodAccess) parent();\n    }\n\n    @Override\n    public StreamEx<Annotation> annotations() {\n        return StreamEx.of(source.getDeclaredAnnotations());\n    }\n\n    @Override\n    public UnreflectType type() {\n        return UnreflectType.of(source.getParameterizedType());\n    }\n\n    @Override", "    public UnreflectType type() {\n        return UnreflectType.of(source.getParameterizedType());\n    }\n\n    @Override\n    public String toString() {\n        return type().toString() + \" \" + name();\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/reflection/ReflectionFieldAccess.java", "chunked_list": ["package dev.klepto.unreflect.reflection;\n\nimport dev.klepto.unreflect.bytecode.asm.AccessorGenerator;\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.bytecode.BytecodeFieldAccess;\nimport dev.klepto.unreflect.UnreflectType;\nimport dev.klepto.unreflect.FieldAccess;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.With;", "import lombok.SneakyThrows;\nimport lombok.With;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\n\n/**\n * Reflection-based implementation of {@link FieldAccess}.", "/**\n * Reflection-based implementation of {@link FieldAccess}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@With\n@RequiredArgsConstructor\npublic class ReflectionFieldAccess implements FieldAccess {\n\n    private final Reflectable parent;\n    private final Field source;\n    private final Object object;\n\n    @Override", "    public Reflectable parent() {\n        return parent;\n    }\n\n    @Override\n    public FieldAccess unreflect() {\n        val accessor = AccessorGenerator.getInstance().generateMutableAccessor(source);\n        return new BytecodeFieldAccess(this, accessor);\n    }\n\n    @Override", "    public FieldAccess reflect() {\n        return this;\n    }\n\n    @Override\n    public FieldAccess bind(Object object) {\n        return withObject(object);\n    }\n\n    @Override\n    public int modifiers() {\n        return source.getModifiers();\n    }\n\n    @Override\n    @SneakyThrows\n    public <T> T get() {\n        return (T) source.get(object);\n    }\n\n    @Override\n    @SneakyThrows", "    public int modifiers() {\n        return source.getModifiers();\n    }\n\n    @Override\n    @SneakyThrows\n    public <T> T get() {\n        return (T) source.get(object);\n    }\n\n    @Override\n    @SneakyThrows", "    public void set(Object value) {\n        source.set(object, value);\n    }\n\n    @Override\n    public StreamEx<Annotation> annotations() {\n        return StreamEx.of(source.getDeclaredAnnotations());\n    }\n\n    @Override\n    public UnreflectType type() {\n        return UnreflectType.of(source.getGenericType());\n    }\n\n    @Override", "    public UnreflectType type() {\n        return UnreflectType.of(source.getGenericType());\n    }\n\n    @Override\n    public String name() {\n        return source.getName();\n    }\n\n    @Override\n    public Field source() {\n        return source;\n    }\n", "    public Field source() {\n        return source;\n    }\n\n    public Object object() {\n        return object;\n    }\n\n    @Override\n    public String toString() {\n        val signature = type().toString() + \" \" + name();\n        return isStatic() ? \"static \" + signature : signature;\n    }\n\n}\n", "    public String toString() {\n        val signature = type().toString() + \" \" + name();\n        return isStatic() ? \"static \" + signature : signature;\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/reflection/ReflectionMethodAccess.java", "chunked_list": ["package dev.klepto.unreflect.reflection;\n\nimport dev.klepto.unreflect.bytecode.asm.AccessorGenerator;\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.bytecode.BytecodeMethodAccess;\nimport dev.klepto.unreflect.UnreflectType;\nimport dev.klepto.unreflect.MethodAccess;\nimport dev.klepto.unreflect.ParameterAccess;\nimport dev.klepto.unreflect.util.Parameters;\nimport lombok.RequiredArgsConstructor;", "import dev.klepto.unreflect.util.Parameters;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.With;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n", "import java.lang.reflect.Method;\n\n/**\n * Reflection-based implementation of {@link MethodAccess}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@With\n@RequiredArgsConstructor\npublic class ReflectionMethodAccess implements MethodAccess {\n\n    private final Reflectable parent;\n    private final Method source;\n    private final Object object;\n\n    @Override\n    @SneakyThrows", "@RequiredArgsConstructor\npublic class ReflectionMethodAccess implements MethodAccess {\n\n    private final Reflectable parent;\n    private final Method source;\n    private final Object object;\n\n    @Override\n    @SneakyThrows\n    public MethodAccess unreflect() {\n        val accessor = AccessorGenerator.getInstance().generateInvokableAccessor(source);\n        return new BytecodeMethodAccess(this, accessor);\n    }\n\n    @Override", "    public MethodAccess unreflect() {\n        val accessor = AccessorGenerator.getInstance().generateInvokableAccessor(source);\n        return new BytecodeMethodAccess(this, accessor);\n    }\n\n    @Override\n    public MethodAccess reflect() {\n        return this;\n    }\n\n    @Override", "    public MethodAccess bind(Object object) {\n        return withObject(object);\n    }\n\n    @Override\n    public int modifiers() {\n        return source.getModifiers();\n    }\n\n    @Override\n    public StreamEx<ParameterAccess> parameters() {\n        return StreamEx.of(source.getParameters())\n                .map(parameter -> new ReflectionParameterAccess(this, parameter));\n    }\n\n    @Override\n    @SneakyThrows\n    public <T> T invoke(Object... args) {\n        return (T) source.invoke(object, args);\n    }\n\n    @Override", "    public Reflectable parent() {\n        return parent;\n    }\n\n    @Override\n    public StreamEx<Annotation> annotations() {\n        return StreamEx.of(source.getAnnotations());\n    }\n\n    @Override\n    public UnreflectType type() {\n        return UnreflectType.of(source.getGenericReturnType());\n    }\n\n    @Override", "    public UnreflectType type() {\n        return UnreflectType.of(source.getGenericReturnType());\n    }\n\n    @Override\n    public String name() {\n        return source.getName();\n    }\n\n    @Override\n    public Method source() {\n        return source;\n    }\n", "    public Method source() {\n        return source;\n    }\n\n    public Object object() {\n        return object;\n    }\n\n    @Override\n    public String toString() {\n        val signature = type().toClass().getSimpleName() + \" \" + name() + Parameters.toString(parameters().toList());\n        return isStatic() ? \"static \" + signature : signature;\n    }\n\n}\n", "    public String toString() {\n        val signature = type().toClass().getSimpleName() + \" \" + name() + Parameters.toString(parameters().toList());\n        return isStatic() ? \"static \" + signature : signature;\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/reflection/ReflectionClassAccess.java", "chunked_list": ["package dev.klepto.unreflect.reflection;\n\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.UnreflectType;\nimport dev.klepto.unreflect.ClassAccess;\nimport dev.klepto.unreflect.ConstructorAccess;\nimport dev.klepto.unreflect.FieldAccess;\nimport dev.klepto.unreflect.MethodAccess;\nimport dev.klepto.unreflect.bytecode.BytecodeClassAccess;\nimport dev.klepto.unreflect.util.JdkInternals;", "import dev.klepto.unreflect.bytecode.BytecodeClassAccess;\nimport dev.klepto.unreflect.util.JdkInternals;\nimport lombok.RequiredArgsConstructor;\nimport lombok.With;\nimport one.util.streamex.StreamEx;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\n\n/**", "\n/**\n * Reflection-based implementation of {@link ClassAccess}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@With\n@RequiredArgsConstructor\npublic class ReflectionClassAccess<T> implements ClassAccess<T> {\n\n    private final Class<T> source;\n    private final Object object;\n\n    @Override\n    public ClassAccess<T> unreflect() {\n        return new BytecodeClassAccess<>(this);\n    }\n\n    @Override\n    public ClassAccess<T> reflect() {\n        return this;\n    }\n\n    @Override\n    public ClassAccess<T> bind(Object object) {\n        return withObject(object);\n    }\n\n    @Override", "public class ReflectionClassAccess<T> implements ClassAccess<T> {\n\n    private final Class<T> source;\n    private final Object object;\n\n    @Override\n    public ClassAccess<T> unreflect() {\n        return new BytecodeClassAccess<>(this);\n    }\n\n    @Override\n    public ClassAccess<T> reflect() {\n        return this;\n    }\n\n    @Override\n    public ClassAccess<T> bind(Object object) {\n        return withObject(object);\n    }\n\n    @Override", "    public int modifiers() {\n        return source.getModifiers();\n    }\n\n    @Override\n    public Reflectable parent() {\n        return new ReflectionClassAccess<>(source.getSuperclass(), object);\n    }\n\n    @Override\n    public StreamEx<Annotation> annotations() {\n        return StreamEx.of(source.getDeclaredAnnotations());\n    }\n\n    @Override", "    public UnreflectType type() {\n        return UnreflectType.of(source);\n    }\n\n    @Override\n    public Class<T> source() {\n        return source;\n    }\n\n    @Override\n    public T create(Object... args) {\n        return constructor(args).create(args);\n    }\n\n    @Override\n    public StreamEx<ConstructorAccess<T>> constructors() {\n        return StreamEx.of(source.getDeclaredConstructors())\n                .peek(constructor -> JdkInternals.setAccessible(constructor, true))\n                .map(constructor ->\n                        new ReflectionConstructorAccess<>(\n                                this,\n                                (Constructor<T>) constructor\n                        )\n                );\n    }\n\n    @Override\n    public StreamEx<FieldAccess> fields() {\n        return type().subTypes().flatArray(type -> type.toClass().getDeclaredFields())\n                .peek(field -> JdkInternals.setAccessible(field, true))\n                .map(field ->\n                        new ReflectionFieldAccess(\n                                this,\n                                field,\n                                object\n                        )\n                );\n    }\n\n    @Override\n    public StreamEx<MethodAccess> methods() {\n        return type().subTypes().flatArray(type -> type.toClass().getDeclaredMethods())\n                .peek(method -> JdkInternals.setAccessible(method, true))\n                .map(method ->\n                        new ReflectionMethodAccess(\n                                this,\n                                method,\n                                object\n                        )\n                );\n    }\n\n    @Override", "    public T create(Object... args) {\n        return constructor(args).create(args);\n    }\n\n    @Override\n    public StreamEx<ConstructorAccess<T>> constructors() {\n        return StreamEx.of(source.getDeclaredConstructors())\n                .peek(constructor -> JdkInternals.setAccessible(constructor, true))\n                .map(constructor ->\n                        new ReflectionConstructorAccess<>(\n                                this,\n                                (Constructor<T>) constructor\n                        )\n                );\n    }\n\n    @Override\n    public StreamEx<FieldAccess> fields() {\n        return type().subTypes().flatArray(type -> type.toClass().getDeclaredFields())\n                .peek(field -> JdkInternals.setAccessible(field, true))\n                .map(field ->\n                        new ReflectionFieldAccess(\n                                this,\n                                field,\n                                object\n                        )\n                );\n    }\n\n    @Override\n    public StreamEx<MethodAccess> methods() {\n        return type().subTypes().flatArray(type -> type.toClass().getDeclaredMethods())\n                .peek(method -> JdkInternals.setAccessible(method, true))\n                .map(method ->\n                        new ReflectionMethodAccess(\n                                this,\n                                method,\n                                object\n                        )\n                );\n    }\n\n    @Override", "    public String name() {\n        return source.getName();\n    }\n\n    @Override\n    public String toString() {\n        return name();\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/reflection/ReflectionConstructorAccess.java", "chunked_list": ["package dev.klepto.unreflect.reflection;\n\nimport dev.klepto.unreflect.bytecode.asm.AccessorGenerator;\nimport dev.klepto.unreflect.property.Reflectable;\nimport dev.klepto.unreflect.bytecode.BytecodeContructorAccess;\nimport dev.klepto.unreflect.UnreflectType;\nimport dev.klepto.unreflect.ConstructorAccess;\nimport dev.klepto.unreflect.ParameterAccess;\nimport dev.klepto.unreflect.util.Parameters;\nimport lombok.RequiredArgsConstructor;", "import dev.klepto.unreflect.util.Parameters;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.With;\nimport lombok.val;\nimport one.util.streamex.StreamEx;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\n", "import java.lang.reflect.Constructor;\n\n/**\n * Reflection-based implementation of {@link ConstructorAccess}.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\n@With\n@RequiredArgsConstructor\npublic class ReflectionConstructorAccess<T> implements ConstructorAccess<T> {\n\n    private final Reflectable parent;\n    private final Constructor<T> source;\n\n    @Override\n    public ConstructorAccess<T> unreflect() {\n        val accessor = AccessorGenerator.getInstance().generateInvokableAccessor(source);\n        return new BytecodeContructorAccess<>(this, accessor);\n    }\n\n    @Override\n    public ConstructorAccess<T> reflect() {\n        return this;\n    }\n\n    @Override\n    public ConstructorAccess<T> bind(Object object) {\n        return this;\n    }\n\n    @Override", "@RequiredArgsConstructor\npublic class ReflectionConstructorAccess<T> implements ConstructorAccess<T> {\n\n    private final Reflectable parent;\n    private final Constructor<T> source;\n\n    @Override\n    public ConstructorAccess<T> unreflect() {\n        val accessor = AccessorGenerator.getInstance().generateInvokableAccessor(source);\n        return new BytecodeContructorAccess<>(this, accessor);\n    }\n\n    @Override\n    public ConstructorAccess<T> reflect() {\n        return this;\n    }\n\n    @Override\n    public ConstructorAccess<T> bind(Object object) {\n        return this;\n    }\n\n    @Override", "    public int modifiers() {\n        return source.getModifiers();\n    }\n\n    @Override\n    public StreamEx<ParameterAccess> parameters() {\n        return StreamEx.of(source.getParameters())\n                .map(parameter -> new ReflectionParameterAccess(this, parameter));\n    }\n\n    @Override\n    public Constructor<T> source() {\n        return source;\n    }\n\n    @Override", "    public T create(Object... args) {\n        return invoke(args);\n    }\n\n    @Override\n    @SneakyThrows\n    public T invoke(Object... args) {\n        return source.newInstance(args);\n    }\n\n    @Override", "    public Reflectable parent() {\n        return parent;\n    }\n\n    @Override\n    public StreamEx<Annotation> annotations() {\n        return StreamEx.of(source.getDeclaredAnnotations());\n    }\n\n    @Override\n    public UnreflectType type() {\n        return parent.type();\n    }\n\n    @Override", "    public UnreflectType type() {\n        return parent.type();\n    }\n\n    @Override\n    public String toString() {\n        return type().toClass().getSimpleName() + Parameters.toString(parameters().toList());\n    }\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/property/Named.java", "chunked_list": ["package dev.klepto.unreflect.property;\n\n/**\n * Represents a named member (type, class, method, field).\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Named {\n\n    /**\n     * Returns the name of this member.\n     *\n     * @return the name of this member\n     */\n    String name();\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/property/Reflectable.java", "chunked_list": ["package dev.klepto.unreflect.property;\n\nimport dev.klepto.unreflect.UnreflectType;\nimport one.util.streamex.StreamEx;\n\nimport javax.annotation.Nullable;\nimport java.lang.annotation.Annotation;\n\n/**\n * Represents a reflectable member (class, constructor, method, field, parameter).", "/**\n * Represents a reflectable member (class, constructor, method, field, parameter).\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Reflectable {\n\n    /**\n     * Gets the parent of this member.\n     *\n     * @return the parent member\n     */\n    Reflectable parent();\n\n    /**\n     * Returns a stream of annotations annotating this member.\n     *\n     * @return a stream of annotations present on this member\n     */\n    StreamEx<Annotation> annotations();\n\n    /**\n     * Gets annotation of a given type annotating this member, or null if annotation of a given type is not present.\n     *\n     * @param annotationClass the annotation type\n     * @param <A>             the generic annotation type\n     * @return an annotation of a given type, or null if annotation is not found\n     */\n    @Nullable\n    default <A extends Annotation> A annotation(Class<A> annotationClass) {\n        return annotations()\n                .findFirst(annotation -> annotation.annotationType() == annotationClass)\n                .map(annotationClass::cast)\n                .orElse(null);\n    }\n\n    /**\n     * Checks if member is annotated with given annotation.\n     *\n     * @param annotationClass the annotation type\n     * @return true if member is annotated with given annotation\n     */\n    default boolean containsAnnotation(Class<? extends Annotation> annotationClass) {\n        return annotation(annotationClass) != null;\n    }\n\n    /**\n     * Returns {@link UnreflectType} representation of the member type.\n     *\n     * @return An unreflect type representation of the member type\n     */\n    UnreflectType type();\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/property/Mutable.java", "chunked_list": ["package dev.klepto.unreflect.property;\n\n/**\n * Represents a mutable member (field) of a class.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Mutable {\n\n    /**\n     * Gets value of this member.\n     *\n     * @param <T> a generic type for automatic casting\n     * @return the value of this member\n     */\n    <T> T get();\n\n    /**\n     * Sets the value of this member.\n     *\n     * @param value the value of this member\n     */\n    void set(Object value);\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/property/Invokable.java", "chunked_list": ["package dev.klepto.unreflect.property;\n\nimport dev.klepto.unreflect.ParameterAccess;\nimport one.util.streamex.StreamEx;\n\n/**\n * Represents an invokable member (constructor, method) of a class.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Invokable {\n\n    /**\n     * Returns a stream of parameters associated with this member.\n     *\n     * @return a stream of parameters, or an empty stream if this member has no parameters\n     */\n    StreamEx<ParameterAccess> parameters();\n\n    /**\n     * Invokes this member with given arguments. For instanced access, you have call {@link Accessible#bind(Object)}\n     * before invocation of this function. For static functions and constructors binding are ignored.\n     *\n     * @param args the arguments for invocation\n     * @param <T>  a generic type for automatic casting\n     * @return the result of member invocation, or null if result is void\n     * @throws RuntimeException if exception occurred during invocation, or if member doesn't accept given arguments\n     */\n    <T> T invoke(Object... args) throws RuntimeException;\n\n}\n", " * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Invokable {\n\n    /**\n     * Returns a stream of parameters associated with this member.\n     *\n     * @return a stream of parameters, or an empty stream if this member has no parameters\n     */\n    StreamEx<ParameterAccess> parameters();\n\n    /**\n     * Invokes this member with given arguments. For instanced access, you have call {@link Accessible#bind(Object)}\n     * before invocation of this function. For static functions and constructors binding are ignored.\n     *\n     * @param args the arguments for invocation\n     * @param <T>  a generic type for automatic casting\n     * @return the result of member invocation, or null if result is void\n     * @throws RuntimeException if exception occurred during invocation, or if member doesn't accept given arguments\n     */\n    <T> T invoke(Object... args) throws RuntimeException;\n\n}\n"]}
{"filename": "src/main/java/dev/klepto/unreflect/property/Accessible.java", "chunked_list": ["package dev.klepto.unreflect.property;\n\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Modifier;\n\n/**\n * Represents an accessible member (constructor, method, field) of a class.\n *\n * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Accessible<T extends Accessible<T>> {\n\n    /**\n     * Returns code-generated representation of this member.\n     *\n     * @return a code-generated representation of this member\n     */\n    T unreflect();\n\n    /**\n     * Returns reflection representation of this member.\n     *\n     * @return a reflection representation of this member\n     */\n    T reflect();\n\n    /**\n     * Binds this member to a specific object instance for invocation/access.\n     *\n     * @return binds this member to a given object instance\n     */\n    T bind(Object object);\n\n    /**\n     * Returns the modifiers of this member.\n     *\n     * @return the modifiers of this member\n     * @see Member#getModifiers()\n     */\n    int modifiers();\n\n    /**\n     * Returns true if member contains 'abstract' keyword.\n     *\n     * @return true if member is abstract\n     */\n    default boolean isAbstract() {\n        return Modifier.isAbstract(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'final' keyword.\n     *\n     * @return true if member is final\n     */\n    default boolean isFinal() {\n        return Modifier.isFinal(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'interface' keyword.\n     *\n     * @return true if member is an interface\n     */\n    default boolean isInterface() {\n        return Modifier.isInterface(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'native' keyword.\n     *\n     * @return true if member is native\n     */\n    default boolean isNative() {\n        return Modifier.isNative(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'private' keyword.\n     *\n     * @return true if member is private\n     */\n    default boolean isPrivate() {\n        return Modifier.isPrivate(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'protected' keyword.\n     *\n     * @return true if member is protected\n     */\n    default boolean isProtected() {\n        return Modifier.isProtected(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'public' keyword.\n     *\n     * @return true if member is public\n     */\n    default boolean isPublic() {\n        return Modifier.isPublic(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'static' keyword.\n     *\n     * @return true if member is static\n     */\n    default boolean isStatic() {\n        return Modifier.isStatic(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'strictfp' keyword.\n     *\n     * @return true if member is strict\n     */\n    default boolean isStrict() {\n        return Modifier.isStrict(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'synchronized' keyword.\n     *\n     * @return true if member is synchronized\n     */\n    default boolean isSynchronized() {\n        return Modifier.isSynchronized(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'transient' keyword.\n     *\n     * @return true if member is transient\n     */\n    default boolean isTransient() {\n        return Modifier.isTransient(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'volatile' keyword.\n     *\n     * @return true if member is volatile\n     */\n    default boolean isVolatile() {\n        return Modifier.isVolatile(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'enum' keyword.\n     *\n     * @return true if member is enum\n     */\n    default boolean isEnum() {\n        return (modifiers() & 0x00004000) != 0;\n    }\n\n\n}\n", " * @author <a href=\"http://github.com/klepto\">Augustinas R.</a>\n */\npublic interface Accessible<T extends Accessible<T>> {\n\n    /**\n     * Returns code-generated representation of this member.\n     *\n     * @return a code-generated representation of this member\n     */\n    T unreflect();\n\n    /**\n     * Returns reflection representation of this member.\n     *\n     * @return a reflection representation of this member\n     */\n    T reflect();\n\n    /**\n     * Binds this member to a specific object instance for invocation/access.\n     *\n     * @return binds this member to a given object instance\n     */\n    T bind(Object object);\n\n    /**\n     * Returns the modifiers of this member.\n     *\n     * @return the modifiers of this member\n     * @see Member#getModifiers()\n     */\n    int modifiers();\n\n    /**\n     * Returns true if member contains 'abstract' keyword.\n     *\n     * @return true if member is abstract\n     */\n    default boolean isAbstract() {\n        return Modifier.isAbstract(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'final' keyword.\n     *\n     * @return true if member is final\n     */\n    default boolean isFinal() {\n        return Modifier.isFinal(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'interface' keyword.\n     *\n     * @return true if member is an interface\n     */\n    default boolean isInterface() {\n        return Modifier.isInterface(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'native' keyword.\n     *\n     * @return true if member is native\n     */\n    default boolean isNative() {\n        return Modifier.isNative(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'private' keyword.\n     *\n     * @return true if member is private\n     */\n    default boolean isPrivate() {\n        return Modifier.isPrivate(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'protected' keyword.\n     *\n     * @return true if member is protected\n     */\n    default boolean isProtected() {\n        return Modifier.isProtected(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'public' keyword.\n     *\n     * @return true if member is public\n     */\n    default boolean isPublic() {\n        return Modifier.isPublic(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'static' keyword.\n     *\n     * @return true if member is static\n     */\n    default boolean isStatic() {\n        return Modifier.isStatic(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'strictfp' keyword.\n     *\n     * @return true if member is strict\n     */\n    default boolean isStrict() {\n        return Modifier.isStrict(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'synchronized' keyword.\n     *\n     * @return true if member is synchronized\n     */\n    default boolean isSynchronized() {\n        return Modifier.isSynchronized(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'transient' keyword.\n     *\n     * @return true if member is transient\n     */\n    default boolean isTransient() {\n        return Modifier.isTransient(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'volatile' keyword.\n     *\n     * @return true if member is volatile\n     */\n    default boolean isVolatile() {\n        return Modifier.isVolatile(modifiers());\n    }\n\n    /**\n     * Returns true if member contains 'enum' keyword.\n     *\n     * @return true if member is enum\n     */\n    default boolean isEnum() {\n        return (modifiers() & 0x00004000) != 0;\n    }\n\n\n}\n"]}
