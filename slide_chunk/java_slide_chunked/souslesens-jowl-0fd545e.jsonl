{"filename": "src/test/java/com/souslesens/Jowl/JowlApplicationTests.java", "chunked_list": ["package com.souslesens.Jowl;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass JowlApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {", "\t@Test\n\tvoid contextLoads() {\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/JowlApplication.java", "chunked_list": ["package com.souslesens.Jowl;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class JowlApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(JowlApplication.class, args);\n\t}\n\n}\n", "\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(JowlApplication.class, args);\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/Controller/SWRLController.java", "chunked_list": ["package com.souslesens.Jowl.Controller;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;", "import org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport com.souslesens.Jowl.model.SWRLTypeEntityVariable;\nimport com.souslesens.Jowl.model.ruleSWRLInput;\nimport com.souslesens.Jowl.model.ruleSWRLInputComplex;\nimport com.souslesens.Jowl.services.SWRLService;\n\n\n@RestController", "\n@RestController\n@RequestMapping(\"/swrl\")\npublic class SWRLController {\n\n\t@Autowired\n\tprivate SWRLService SWRLService;\n    //Post API For STRING\n    @PostMapping(\"/alternative_exec_rule\")\n    public ResponseEntity<?> postReclassification(@RequestBody(required = false) ruleSWRLInput request) { \n    \t// This Class works only for Classess\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;\n        String[] reqBodies = request.getBody();\n        String[] reqHead = request.getHead();", "        if (reqBodies.length == 0 || reqHead.length == 0) {\n        \treturn ResponseEntity.badRequest().body(\"Body or Head are empty\");\n        }\n    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes, StandardCharsets.UTF_8);\n    \t}\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);\n        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n            \tString result ;\n            \tif (!(filePath == null) || !(url == null) ) {\n                result = SWRLService.SWRLruleReclassification(filePath, url,reqBodies,reqHead);\n            \t}else {\n            \tresult = SWRLService.SWRLruleReclassificationB64(ontologyContentDecoded64,reqBodies,reqHead);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n    @PostMapping(\"/exec_rule\")\n    public ResponseEntity<?> postPropertyValueAssignment(@RequestBody(required = false) ruleSWRLInputComplex request) { \n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;\n    \tList<SWRLTypeEntityVariable> reqBodies = request.getBody();\n    \tList<SWRLTypeEntityVariable> reqHead = request.getHead();", "    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes, StandardCharsets.UTF_8);\n    \t}\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);\n        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n            \tString result = null;", "            try {\n            \tString result = null;\n            \tif (!(filePath == null) || !(url == null) ) {\n            \t\tresult = SWRLService.SWRLruleVABUF(filePath,url,reqBodies,reqHead);\n            \t}else {\n            \t\tresult = SWRLService.SWRLruleVAB64(ontologyContentDecoded64,reqBodies,reqHead);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n    // This to count the number of the parameteres that will help us to know how many parameteres we passed to the API \n    // and we can return errors if the number of parameters is more than one\n    private int countNumberOfParametres(Object... parameters) {\n        int nb = 0;", "        for (Object prms : parameters) {\n            if (prms != null && !prms.toString().isEmpty()) {\n            \tnb++;\n            }\n        }\n        return nb;\n    }\n\t\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/Controller/ReasonerAlternativeAPIController.java", "chunked_list": ["package com.souslesens.Jowl.Controller;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;", "import org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\nimport com.souslesens.Jowl.model.reasonerExtractTriples;\nimport com.souslesens.Jowl.services.AlternativeReasonerService;\n\n@RestController\n@RequestMapping(\"/alternative\")\npublic class ReasonerAlternativeAPIController {\n\n    @Autowired\n    private AlternativeReasonerService reasonerServiceAlt;\n    // POST API to expose consistency\n    @PostMapping(\"/consistency\")\n    public ResponseEntity<?> postConsistencyAlt(@RequestParam(required = false) MultipartFile ontologyFile,\n            @RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) { \n    \tint parametersCount = countNumberOfParametres(ontologyFile, filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n                String result = reasonerServiceAlt.getConsistencyAlt(filePath, url,ontologyFile);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n\n    \n    \n    // POST API Alternative solution to expose inference\n    @PostMapping(\"/inference\")\n    public ResponseEntity<?> postInferenceAlt(@RequestParam(required = false) MultipartFile ontologyFile,\n            @RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) { \n    \tint parametersCount = countNumberOfParametres(ontologyFile, filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n                List<reasonerExtractTriples> result = reasonerServiceAlt.getInferencesAlt(filePath, url,ontologyFile);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n   \n    @PostMapping(\"/unsatisfiable\")\n    public ResponseEntity<?> postUnsatisfaisableClassesAlt(@RequestParam(required = false) MultipartFile ontologyFile,\n            @RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) { \n    \tint parametersCount = countNumberOfParametres(ontologyFile, filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n                String result = reasonerServiceAlt.getUnsatisfaisableClassesAlt(filePath, url,ontologyFile);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    // This to count the number of the parameteres that will help us to know how many parameteres we passed to the API \n    // and we can return errors if the number of parameters is more than one\n    private int countNumberOfParametres(Object... parameters) {\n        int nb = 0;", "        for (Object prms : parameters) {\n            if (prms != null && !prms.toString().isEmpty()) {\n            \tnb++;\n            }\n        }\n        return nb;\n    }\n\n\n\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/Controller/ReasonerController.java", "chunked_list": ["package com.souslesens.Jowl.Controller;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.springframework.beans.factory.annotation.Autowired;", "import java.util.Map;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;", "import org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.souslesens.Jowl.model.parametresInputInference;\nimport com.souslesens.Jowl.model.reasonerInference;\nimport com.souslesens.Jowl.model.reasonerInput;", "import com.souslesens.Jowl.model.reasonerInference;\nimport com.souslesens.Jowl.model.reasonerInput;\nimport com.souslesens.Jowl.services.ReasonerService;\n\n\n@RestController\n@RequestMapping(\"/reasoner\")\npublic class ReasonerController {\n\n    @Autowired\n    private ReasonerService reasonerService;\n    @GetMapping(value = \"/test\")\n    public ResponseEntity<String> pong() \n    {\n        \n        return new ResponseEntity<String>(\"Test du serveur Spring: \"+HttpStatus.OK.name(), HttpStatus.OK);\n    }\n\n\n    @GetMapping(\"/unsatisfiable\")\n    public ResponseEntity<?> getUnsatisfaisableClasses(\n            @RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) { \n    \tint parametersCount = countNumberOfParametres( filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n                String result = reasonerService.getUnsatisfaisableClasses(filePath, url);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    @GetMapping(\"/consistency\")\n    public ResponseEntity<?> getConsistency(@RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) {\n        \n    \t\tint parametersCount = countNumberOfParametres( filePath, url);", "        \tif (parametersCount == 0) {\n            \treturn ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        \t} else if (parametersCount > 1) {\n            \treturn ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        \t}\n            try {\n                String result = reasonerService.getConsistency(filePath, url);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n            \n        \t\n        \n    }\n    @GetMapping(\"/inference\")\n    public ResponseEntity<?> getInference(@RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) {\n        \n    \t\tint parametersCount = countNumberOfParametres( filePath, url);", "        \tif (parametersCount == 0) {\n            \treturn ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        \t} else if (parametersCount > 1) {\n            \treturn ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        \t}\n            try {\n                String result = reasonerService.getInferences(filePath, url);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n            \n        \t\n        \n    }\n    //Post API For STRING\n    @PostMapping(\"/consistency\")\n    public ResponseEntity<?> postConsistency(@RequestBody(required = false) reasonerInput request) { \n        // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;", "    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes, StandardCharsets.UTF_8);\n    \tSystem.out.println(\"Inference\"+ontologyContentDecoded64);\n    \t}\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);\n        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }", "        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n            \tString result ;\n            \tif (!(filePath == null) || !(url == null) ) {\n                result = reasonerService.postConsistency(filePath, url);\n                // Here if we use filePath or Url\n            \t}else {\n            \tresult = reasonerService.postConsistencyContent(ontologyContentDecoded64);\n            \t// Here if we use the Encoded Content\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    //Post API For STRING\n    @PostMapping(\"/inference\")\n    public ResponseEntity<?> postInference(@RequestBody(required = false) reasonerInference request) { \n    \tRestTemplate restTemplate = new RestTemplate();\n        // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n        String[] reqParametres = request.getParams();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;", "    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes, StandardCharsets.UTF_8);\n    \t}\n    \t// Automatic call to the parametres API\n        HttpHeaders headers = new HttpHeaders();\n        headers.set(\"Accept\", \"application/json\");\n\n        HttpEntity<String> entity = new HttpEntity<>(headers);\n    \t String externalApiUrl = \"http://localhost:9170/reasoner/parametres\";\n    \t ResponseEntity<String> response = restTemplate.exchange(externalApiUrl, HttpMethod.GET, entity, String.class);\n    \t System.out.println(response.getBody());\n    \t List<String> valuesList = new ArrayList<>();\n    \t List<String> valuesList2 = new ArrayList<>();", "\t     for (int i = 0; i < reqParametres.length; i++) {\n\t        \t if (reqParametres[i].equals(\"All_OWL\")) {\n\t                valuesList2.add(\"All\");\n\t                break;\n\t            }\n\t        \t\n\t        }\n    \t if (valuesList2.isEmpty()) {\n        \t try {\n     \t\t    ObjectMapper objectMapper = new ObjectMapper();\n     \t\t    Map<String, String> jsonMappin = objectMapper.readValue(response.getBody(), Map.class);\n     \t\t    \n\n     \t\t    // Loop through the JSON data", "        \t try {\n     \t\t    ObjectMapper objectMapper = new ObjectMapper();\n     \t\t    Map<String, String> jsonMappin = objectMapper.readValue(response.getBody(), Map.class);\n     \t\t    \n\n     \t\t    // Loop through the JSON data\n     \t\t    for (Map.Entry<String, String> entry : jsonMappin.entrySet()) {\n     \t\t        String key = entry.getKey();     \t\t        \n     \t\t        for (int i = 0; i < reqParametres.length; i++) {\n     \t\t        \t if (reqParametres[i].equals(key)) {\n     \t\t                valuesList.add(entry.getValue());\n     \t\t                break;\n     \t\t            }\n     \t\t        }\n     \t\t    }\n\n     \t\t} catch (Exception e) {\n     \t\t\treturn ResponseEntity.badRequest().body(e.getMessage());\n          }\n    \t }else {\n    \t\t valuesList = valuesList2;\n    \t }\n\n\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);", "     \t\t        for (int i = 0; i < reqParametres.length; i++) {\n     \t\t        \t if (reqParametres[i].equals(key)) {\n     \t\t                valuesList.add(entry.getValue());\n     \t\t                break;\n     \t\t            }\n     \t\t        }\n     \t\t    }\n\n     \t\t} catch (Exception e) {\n     \t\t\treturn ResponseEntity.badRequest().body(e.getMessage());\n          }\n    \t }else {\n    \t\t valuesList = valuesList2;\n    \t }\n\n\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n            \tString result ;\n            \tif (!(filePath == null) || !(url == null) ) {\n                result = reasonerService.postInferences(filePath, url,valuesList);\n            \t}else {\n            \tresult = reasonerService.postInferencesContent(ontologyContentDecoded64,valuesList);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    //Post API For STRING\n    @PostMapping(\"/unsatisfiable\")\n    public ResponseEntity<?> postUnsatisfiable(@RequestBody(required = false) reasonerInput request) { \n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;", "    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes, StandardCharsets.UTF_8);\n    \t}\n    \tint parametersCount = countNumberOfParametres(ontologyContentDecoded64, filePath, url);\n        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n            try {\n            \tString result ;", "            try {\n            \tString result ;\n            \tif (!(filePath == null) || !(url == null) ) {\n                result = reasonerService.postUnsatisfaisableClasses(filePath, url);\n            \t}else {\n            \tresult = reasonerService.postUnsatisfaisableClassesContent(ontologyContentDecoded64);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n    //Post API For STRING\n    @GetMapping(\"/parametres\")\n    public ResponseEntity<?> retrieveParameteresInferenceMethod() { \n        Map<String, String> hashMap = new HashMap<>();\n        // Add key-value pairs to the HashMap\n        hashMap.put(\"equivalentClass\", \"CustomInferredEquivalentClassesAxiomGenerator()\"); // Covers owl:equivalentClass Inferences\n        hashMap.put(\"sameIndividual\", \"CustomSameIndividualAxiomGenerator()\"); // Covers Owl SameAs \n        hashMap.put(\"IntersectionOf\", \"CustomInferredIntersectionOfAxiomGenerator()\"); // Covers Owl:Intersection:Of Inferences\n        hashMap.put(\"UnionOf\", \"CustomInferredUnionOfAxiomGenerator()\"); // Covers Owl:UnionOf inferences\n        hashMap.put(\"DisjointClasses\", \"CustomInferredDisjointClassesAxiomGenerator()\"); // Covers Owl:DisjointClasses Inferences\n        hashMap.put(\"differentIndividual\",\"CustomInferredDifferentIndividualAxiomGenerator()\" );\n        hashMap.put(\"HasValue\", \"CustomInferredHasValueAxiomGenerator()\"); // Covers owl:hasValue restriction\n        hashMap.put(\"InverseObjectProperties\", \"CustomInferredInverseObjectPropertiesAxiomGenerator()\"); // Covers Inveerse object properties // if property A relates individual x to individual y, then property B relates individual y to individual x\n        hashMap.put(\"AllValuesFrom\", \"CustomInferredAllValuesFromAxiomGenerator()\"); // Cover Owl:allValuesFrom\n        hashMap.put(\"SomeValuesFrom\", \"CustomInferredSameValueSomeValuesFromAxiomGenerator()\"); // Cover Owl:someValuesFrom\n        hashMap.put(\"DomainAndRange\", \"CustomInferredDomainAndRangeAxiomGenerator()\"); // Cover Domain and Range\n        hashMap.put(\"ClassAssertion\", \"InferredClassAssertionAxiomGenerator()\");\n        hashMap.put(\"SubClass\", \"InferredSubClassAxiomGenerator()\"); // Covers Rdfs:SubClass\n        hashMap.put(\"DataPropertyCharacteristic\", \"InferredDataPropertyCharacteristicAxiomGenerator()\");\n        hashMap.put(\"EquivalentDataProperty\", \"InferredEquivalentDataPropertiesAxiomGenerator()\");\n        hashMap.put(\"EquivalentObjectProperty\", \"InferredEquivalentObjectPropertyAxiomGenerator()\");\n        hashMap.put(\"SubObjectProperty\", \"InferredSubObjectPropertyAxiomGenerator()\");\n        hashMap.put(\"SubDataPropertyOfAxiom\", \"InferredSubDataPropertyAxiomGenerator()\");\n        hashMap.put(\"ObjectPropertyCharacteristic\", \"InferredObjectPropertyCharacteristicAxiomGenerator()\"); // FunctionalObjectProperty/InverseFunctionalObjectProperty/SymmetricObjectProperty/AsymmetricObjectProperty/ReflexiveObjectProperty/IrreflexiveObjectProperty/TransitiveObjectProperty \n        hashMap.put(\"SubDataPropertyOfAxiom\", \"InferredPropertyAssertionGenerator()\"); // This Covers both OWLObjectPropertyAssertionAxiom and OWLDataPropertyAssertionAxiom\n        hashMap.put(\"ComplementOf\", \"CustomInferredComplementOfAxiomGenerator()\"); // Cover OwlComplementOf\n        hashMap.put(\"All_OWL\", \"All\"); // Covers Evreything", "            try {\n\n            \t\n                return ResponseEntity.ok(hashMap);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n    \n    //Post API For STRING To use Parametere AS boolean \n    @PostMapping(\"/parametres\")\n    public ResponseEntity<?> retrieveParameteresInference(@RequestBody(required = false) parametresInputInference request) { \n        \n        Boolean equivalentClass = request.getEquivalentClass();\n        Boolean sameIndividual = request.getSameIndividual();\n        Boolean IntersectionOf = request.getIntersectionOf();\n        Boolean UnionOf = request.getUnionOf();\n        Boolean DisjointClasses  = request.getDisjointClasses();\n        Boolean differentIndividual = request.getDifferentIndividual();\n        Boolean HasValue = request.getHasValue();\n        Boolean InverseObjectProperties = request.getInverseObjectProperties();\n        Boolean AllValuesFrom = request.getAllValuesFrom();\n        Boolean SomeValuesFrom = request.getSomeValuesFrom();\n        Boolean DomainAndRange  = request.getDomainAndRange();\n        \n    \tint parametersCount = countNumberOfParametres(equivalentClass, sameIndividual, IntersectionOf,UnionOf,DisjointClasses,differentIndividual,HasValue,InverseObjectProperties,AllValuesFrom,SomeValuesFrom,DomainAndRange);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 11) {\n            return ResponseEntity.badRequest().body(\"paramateres u provided are more than u should pass\");\n        }\n            try {\n\n            \tList<parametresInputInference> parametresInference = new LinkedList<>();\n            \tparametresInference.add(new parametresInputInference(equivalentClass, sameIndividual, IntersectionOf,UnionOf,DisjointClasses,differentIndividual,HasValue,InverseObjectProperties,AllValuesFrom,SomeValuesFrom,DomainAndRange));\n                return ResponseEntity.ok(parametresInference);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        }\n    \n    // This to count the number of the parameteres that will help us to know how many parameteres we passed to the API \n    // and we can return errors if the number of parameters is more than one\n    private int countNumberOfParametres(Object... parameters) {\n        int nb = 0;", "        for (Object prms : parameters) {\n            if (prms != null && !prms.toString().isEmpty()) {\n            \tnb++;\n            }\n        }\n        return nb;\n    }\n\n\n\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/Controller/JenaController.java", "chunked_list": ["package com.souslesens.Jowl.Controller;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport com.souslesens.Jowl.model.jenaTripleParser;", "import org.springframework.web.bind.annotation.RestController;\nimport com.souslesens.Jowl.model.jenaTripleParser;\nimport com.souslesens.Jowl.model.jenaTripleParserInput;\nimport com.souslesens.Jowl.services.JenaService;\n\n@RestController\n@RequestMapping(value=\"/jena\")\npublic class JenaController { \n\t\n\t@Autowired\n\t\tJenaService serviceJena;\n\t\n    @PostMapping(\"/rdftriple\")\n    public ResponseEntity<?> rdfToTriples(@RequestBody jenaTripleParserInput request ){\n    \t\n        // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        System.out.println(url);\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n        int parametersCount = countParams(ontologyContentEncoded64, filePath, url);", "        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params should be provided\");\n        } else if (parametersCount > 1) {\n            return ResponseEntity.badRequest().body(\"Only one of params should be provided\");\n        }\n        \t\ttry {\n        \t\t\tList<jenaTripleParser> result = serviceJena.getTriples(filePath, url, ontologyContentEncoded64) ;\n   \t              return ResponseEntity.ok(result);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn ResponseEntity.badRequest().body(\"Error\");\n\t\t\t\t}\n        }\n    \n    private int countParams(Object... parameters) {\n        int count = 0;", "        for (Object param : parameters) {\n            if (param != null && !param.toString().isEmpty()) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    \t    \n    \t      \n}\n\n\n\n\n\n///\n\n\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerConsistency.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\n\npublic class reasonerConsistency {\n\n\tprivate boolean Consistency;\n\n\tpublic reasonerConsistency() {\n        \n    }\n\t", "\tpublic boolean getConsistency() {\n\t\treturn Consistency;\n\t}\n\n\tpublic void setConsistency(boolean Consistency) {\n\t\tthis.Consistency = Consistency;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerExtractTriples.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\n\npublic class reasonerExtractTriples {\n    private String subject;\n    private String predicate;\n    private String object;\n\n    public reasonerExtractTriples() {\n    }\n\n    public reasonerExtractTriples(String subject,String predicate, String object ) {\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n    }\n", "    public String getSubject() {\n        return subject;\n    }\n\n    public void setSubject(String subject) {\n        this.subject = subject;\n    }\n\n    public String getPredicate() {\n        return predicate;\n    }\n", "    public String getPredicate() {\n        return predicate;\n    }\n\n    public void setPredicate(String predicate) {\n        this.predicate = predicate;\n    }\n\n    public String getObject() {\n        return object;\n    }\n", "    public String getObject() {\n        return object;\n    }\n\n    public void setObject(String object) {\n        this.object = object;\n    }\n\n    @Override\n    public String toString() {\n        return \"{\" +\n                \"\\\"subject\\\":\\\"\" + subject + \"\\\",\" +\n                \"\\\"predicate\\\":\\\"\" + predicate + \"\\\",\" +\n                \"\\\"object\\\":\\\"\" + object + \"\\\"\" +\n                \"}\";\n    }\n}", "    public String toString() {\n        return \"{\" +\n                \"\\\"subject\\\":\\\"\" + subject + \"\\\",\" +\n                \"\\\"predicate\\\":\\\"\" + predicate + \"\\\",\" +\n                \"\\\"object\\\":\\\"\" + object + \"\\\"\" +\n                \"}\";\n    }\n}"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerInference.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class reasonerInference {\n\tprivate String filePath;\n\tprivate String url;\n\tprivate String ontologyContentEncoded64;\n\tprivate String[] predicates;\n\t\n\tpublic reasonerInference(String filePath , String url, String ontologyContentEncoded64 ,String[] predicates) {\n\t\tthis.filePath = filePath;\n\t\tthis.url = url;\n\t\tthis.ontologyContentEncoded64 = ontologyContentEncoded64;\n        this.predicates = predicates;\n        }", "\tpublic String getFilePath() {\n\t\treturn filePath;\n\t}\n\t\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\t\n\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic String[] getParams() {\n\t\treturn predicates;\n\t}\n}\n", "\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic String[] getParams() {\n\t\treturn predicates;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/jenaTripleParserInput.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class jenaTripleParserInput {\n\n\t\tprivate String filePath;\n\t\tprivate String url;\n\t\tprivate String ontologyContentEncoded64;\n\t\t\n\t\tpublic jenaTripleParserInput(String filePath , String url, String ontologyContentEncoded64) {\n\t\t\tthis.filePath = filePath;\n\t\t\tthis.url = url;\n\t\t\tthis.ontologyContentEncoded64 = ontologyContentEncoded64;\n\t\t}", "\t\tpublic String getFilePath() {\n\t\t\treturn filePath;\n\t\t}\n\t\t\n\t\tpublic String getUrl() {\n\t\t\treturn url;\n\t\t}\n\t\t\n\t\tpublic String getOntologyContentEncoded64() {\n\t\t\treturn ontologyContentEncoded64;\n\t\t}\n\n\t}\n\n\n", "\t\tpublic String getOntologyContentEncoded64() {\n\t\t\treturn ontologyContentEncoded64;\n\t\t}\n\n\t}\n\n\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerOutput.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class reasonerOutput {\n    private reasonerConsistency myBoolean;\n    private reasonerUnsatisfaisability Unsatisfaisable;\n    private reasonerExtractTriples triplesInference;\n\n    public reasonerOutput() {\n    \t\n    }\n    public reasonerOutput(reasonerUnsatisfaisability Unsatisfaisable) {\n    \tthis.Unsatisfaisable=Unsatisfaisable;\n    }\n    public reasonerOutput(reasonerConsistency myBoolean) {\n        this.myBoolean = myBoolean;\n    }\n    \n    public reasonerOutput(reasonerExtractTriples triplesInference) {\n        this.triplesInference = triplesInference;\n    }\n    \n    public reasonerOutput(reasonerConsistency myBoolean, reasonerUnsatisfaisability Unsatisfaisable, reasonerExtractTriples triplesInference) {\n        this.myBoolean = myBoolean;\n        this.Unsatisfaisable = Unsatisfaisable;\n        this.triplesInference = triplesInference;\n    }\n", "    public reasonerConsistency isMyBoolean() {\n        return myBoolean;\n    }\n\n    public void setMyBoolean(reasonerConsistency myBoolean) {\n        this.myBoolean = myBoolean;\n    }\n\n\tpublic reasonerExtractTriples getTriples() {\n\t\treturn triplesInference;\n\t}\n", "\tpublic reasonerExtractTriples getTriples() {\n\t\treturn triplesInference;\n\t}\n\n\tpublic void setTriples(reasonerExtractTriples triplesInference) {\n\t\tthis.triplesInference = triplesInference;\n\t}\n\n\tpublic reasonerUnsatisfaisability getUnsatisfaisable() {\n\t\treturn Unsatisfaisable;\n\t}\n", "\tpublic reasonerUnsatisfaisability getUnsatisfaisable() {\n\t\treturn Unsatisfaisable;\n\t}\n\n\tpublic void setUnsatisfaisable(reasonerUnsatisfaisability unsatisfaisable) {\n\t\tUnsatisfaisable = unsatisfaisable;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/parametresInputInference.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class parametresInputInference {\n\n\t\tprivate Boolean equivalentClass;\n\t    private Boolean sameIndividual;\n\t    private Boolean differentIndividual;\n\t    private Boolean IntersectionOf;\n\t    private Boolean UnionOf;\n\t    private Boolean DisjointClasses;\n\t    private Boolean HasValue;\n\t    private Boolean InverseObjectProperties;\n\t    private Boolean AllValuesFrom;\n\t    private Boolean SomeValuesFrom;\n\t    private Boolean DomainAndRange;\n\t    \n\t    \n\t    public parametresInputInference() {\n\t    }\n\n\t    public parametresInputInference(Boolean equivalentClass,Boolean sameIndividual, Boolean differentIndividual, Boolean IntersectionOf,Boolean UnionOf, Boolean DisjointClasses, Boolean HasValue, Boolean InverseObjectProperties, Boolean AllValuesFrom , Boolean SomeValuesFrom , Boolean DomainAndRange ) {\n\t        this.equivalentClass = equivalentClass;\n\t        this.sameIndividual = sameIndividual;\n\t        this.differentIndividual = differentIndividual;\n\t        this.IntersectionOf = IntersectionOf;\n\t        this.UnionOf = UnionOf;\n\t        this.DisjointClasses = DisjointClasses;\n\t        this.HasValue = HasValue; \n\t        this.InverseObjectProperties = InverseObjectProperties;\n\t        this.AllValuesFrom = AllValuesFrom;\n\t        this.SomeValuesFrom = SomeValuesFrom;\n\t        this.DomainAndRange = DomainAndRange;\n\t    }\n", "\t    public Boolean getEquivalentClass() {\n\t        return equivalentClass;\n\t    }\n\n\t    public void setEquivalentClass(Boolean equivalentClass) {\n\t        this.equivalentClass = equivalentClass;\n\t    }\n\n\t    public Boolean getSameIndividual() {\n\t        return sameIndividual;\n\t    }\n", "\t    public Boolean getSameIndividual() {\n\t        return sameIndividual;\n\t    }\n\n\t    public void setSameIndividual(Boolean sameIndividual) {\n\t        this.sameIndividual = sameIndividual;\n\t    }\n\n\t    public Boolean getDifferentIndividual() {\n\t        return differentIndividual;\n\t    }\n", "\t    public Boolean getDifferentIndividual() {\n\t        return differentIndividual;\n\t    }\n\n\t    public void setDifferentIndividual(Boolean differentIndividual) {\n\t        this.differentIndividual = differentIndividual;\n\t    }\n\t    \n\t    public Boolean getIntersectionOf() {\n\t        return IntersectionOf;\n\t    }\n", "\t    public Boolean getIntersectionOf() {\n\t        return IntersectionOf;\n\t    }\n\n\t    public void setIntersectionOf(Boolean IntersectionOf) {\n\t        this.IntersectionOf = IntersectionOf;\n\t    }\n\n\t    public Boolean getUnionOf() {\n\t        return UnionOf;\n\t    }\n", "\t    public Boolean getUnionOf() {\n\t        return UnionOf;\n\t    }\n\n\t    public void setUnionOf(Boolean UnionOf) {\n\t        this.UnionOf = UnionOf;\n\t    }\n\t    \n\t    public Boolean getDisjointClasses() {\n\t        return DisjointClasses;\n\t    }\n", "\t    public Boolean getDisjointClasses() {\n\t        return DisjointClasses;\n\t    }\n\n\t    public void setDisjointClasses(Boolean DisjointClasses) {\n\t        this.DisjointClasses = DisjointClasses;\n\t    }\n\t    \n\t    public Boolean getHasValue() {\n\t        return HasValue;\n\t    }\n", "\t    public Boolean getHasValue() {\n\t        return HasValue;\n\t    }\n\n\t    public void setHasValue(Boolean HasValue) {\n\t        this.HasValue = HasValue;\n\t    }\n\t    \n\t    public Boolean getInverseObjectProperties() {\n\t        return InverseObjectProperties;\n\t    }\n", "\t    public Boolean getInverseObjectProperties() {\n\t        return InverseObjectProperties;\n\t    }\n\n\t    public void setInverseObjectProperties(Boolean InverseObjectProperties) {\n\t        this.InverseObjectProperties = InverseObjectProperties;\n\t    }\n\t    \n\t    public Boolean getAllValuesFrom() {\n\t        return AllValuesFrom;\n\t    }\n", "\t    public Boolean getAllValuesFrom() {\n\t        return AllValuesFrom;\n\t    }\n\n\t    public void setAllValuesFrom(Boolean AllValuesFrom) {\n\t        this.AllValuesFrom = AllValuesFrom;\n\t    }\n\t    \n\t    public Boolean getSomeValuesFrom() {\n\t        return SomeValuesFrom;\n\t    }\n", "\t    public Boolean getSomeValuesFrom() {\n\t        return SomeValuesFrom;\n\t    }\n\n\t    public void setSomeValuesFrom(Boolean SomeValuesFrom) {\n\t        this.SomeValuesFrom = SomeValuesFrom;\n\t    }\n\n\t    public Boolean getDomainAndRange() {\n\t        return DomainAndRange;\n\t    }\n", "\t    public Boolean getDomainAndRange() {\n\t        return DomainAndRange;\n\t    }\n\n\t    public void setDomainAndRange(Boolean DomainAndRange) {\n\t        this.DomainAndRange = DomainAndRange;\n\t    }\n\n\t    @Override\n\t    public String toString() {\n\t        return \"{\" +\n\t                \"\\\"equivalentClass\\\":\\\"\" + equivalentClass + \"\\\",\" +\n\t                \"\\\"sameIndividual\\\":\\\"\" + sameIndividual + \"\\\",\" +\n\t                \"\\\"IntersectionOf\\\":\\\"\" + IntersectionOf + \"\\\",\" +\n\t                \"\\\"UnionOf\\\":\\\"\" + UnionOf + \"\\\",\" +\n\t                \"\\\"DisjointClasses\\\":\\\"\" + DisjointClasses + \"\\\",\" +\n\t                \"\\\"differentIndividual\\\":\\\"\" + differentIndividual + \"\\\",\" +\n\t                \"\\\"HasValue\\\":\\\"\" + HasValue + \"\\\",\" +\n\t                \"\\\"InverseObjectProperties\\\":\\\"\" + InverseObjectProperties + \"\\\",\" +\n\t                \"\\\"AllValuesFrom\\\":\\\"\" + AllValuesFrom + \"\\\",\" +\n\t                \"\\\"SomeValuesFrom\\\":\\\"\" + SomeValuesFrom + \"\\\",\" +\n\t                \"\\\"DomainAndRange\\\":\\\"\" + DomainAndRange + \"\\\"\" +\n\t                \"}\";\n\t    }\n\t}\n\n\t\n\t\n\n", "\t    public String toString() {\n\t        return \"{\" +\n\t                \"\\\"equivalentClass\\\":\\\"\" + equivalentClass + \"\\\",\" +\n\t                \"\\\"sameIndividual\\\":\\\"\" + sameIndividual + \"\\\",\" +\n\t                \"\\\"IntersectionOf\\\":\\\"\" + IntersectionOf + \"\\\",\" +\n\t                \"\\\"UnionOf\\\":\\\"\" + UnionOf + \"\\\",\" +\n\t                \"\\\"DisjointClasses\\\":\\\"\" + DisjointClasses + \"\\\",\" +\n\t                \"\\\"differentIndividual\\\":\\\"\" + differentIndividual + \"\\\",\" +\n\t                \"\\\"HasValue\\\":\\\"\" + HasValue + \"\\\",\" +\n\t                \"\\\"InverseObjectProperties\\\":\\\"\" + InverseObjectProperties + \"\\\",\" +\n\t                \"\\\"AllValuesFrom\\\":\\\"\" + AllValuesFrom + \"\\\",\" +\n\t                \"\\\"SomeValuesFrom\\\":\\\"\" + SomeValuesFrom + \"\\\",\" +\n\t                \"\\\"DomainAndRange\\\":\\\"\" + DomainAndRange + \"\\\"\" +\n\t                \"}\";\n\t    }\n\t}\n\n\t\n\t\n\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/SWRLVariables.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class SWRLVariables {\n\tString name;\n\tString[] var;\n\tString[] literal;\n\t\n\tpublic SWRLVariables(String name,String[] var,String[] literal) {\n\t\tthis.name = name;\n\t\tthis.var = var;\n\t\tthis.literal=literal;\n\t}\n\t", "\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic String[] getVar() {\n\t\treturn var;\n\t}\n\t\n\tpublic String[] getLiteral() {\n\t\treturn literal;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/jenaTripleParser.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class jenaTripleParser {\n\tprivate String subject;\n    private String predicate;\n    private String object;\n\n    public jenaTripleParser() {\n    }\n\n    public jenaTripleParser(String subject,String predicate, String object ) {\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n    }\n", "    public String getSubject() {\n        return subject;\n    }\n\n    public void setSubject(String subject) {\n        this.subject = subject;\n    }\n\n    public String getPredicate() {\n        return predicate;\n    }\n", "    public String getPredicate() {\n        return predicate;\n    }\n\n    public void setPredicate(String predicate) {\n        this.predicate = predicate;\n    }\n\n    public String getObject() {\n        return object;\n    }\n", "    public String getObject() {\n        return object;\n    }\n\n    public void setObject(String object) {\n        this.object = object;\n    }\n\n    @Override\n    public String toString() {\n        return \"{\" +\n                \"\\\"subject\\\":\\\"\" + subject + \"\\\",\" +\n                \"\\\"predicate\\\":\\\"\" + predicate + \"\\\",\" +\n                \"\\\"object\\\":\\\"\" + object + \"\\\"\" +\n                \"}\";\n    }\n}\n", "    public String toString() {\n        return \"{\" +\n                \"\\\"subject\\\":\\\"\" + subject + \"\\\",\" +\n                \"\\\"predicate\\\":\\\"\" + predicate + \"\\\",\" +\n                \"\\\"object\\\":\\\"\" + object + \"\\\"\" +\n                \"}\";\n    }\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/ruleSWRLInput.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class ruleSWRLInput {\n\tprivate String filePath;\n\tprivate String url;\n\tprivate String ontologyContentEncoded64;\n\tprivate String[] premise;\n\tprivate String[] conclusion;\n\t\n\tpublic ruleSWRLInput(String filePath , String url, String ontologyContentEncoded64 ,String[] premise,String[] conclusion) {\n\t\tthis.filePath = filePath;\n\t\tthis.url = url;\n\t\tthis.ontologyContentEncoded64 = ontologyContentEncoded64;\n        this.premise = premise;\n        this.conclusion = conclusion;\n        }", "\tpublic String getFilePath() {\n\t\treturn filePath;\n\t}\n\t\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\t\n\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic String[] getHead() {\n\t\treturn conclusion;\n\t}\n\t\n\tpublic String[] getBody() {\n\t\treturn premise;\n\t}\n}\n", "\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic String[] getHead() {\n\t\treturn conclusion;\n\t}\n\t\n\tpublic String[] getBody() {\n\t\treturn premise;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerUnsatisfaisability.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\n\nimport org.semanticweb.owlapi.model.OWLClass;\n\npublic class reasonerUnsatisfaisability {\n\tprivate OWLClass[] Unsatisfaisable;\n\n\tpublic reasonerUnsatisfaisability() {\n        this.Unsatisfaisable = new OWLClass[100]; // initialize with a maximum capacity of 100 elements\n    }\n\t\n\tpublic OWLClass[] getUnsatisfaisable() {\n\t\treturn Unsatisfaisable;\n\t}\n", "\tpublic void setUnsatisfaisable(OWLClass[] unsatisfaisable) {\n\t\tUnsatisfaisable = unsatisfaisable;\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/reasonerInput.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\npublic class reasonerInput {\n\tprivate String filePath;\n\tprivate String url;\n\tprivate String ontologyContentEncoded64;\n\t\n\tpublic reasonerInput(String filePath , String url, String ontologyContentEncoded64) {\n\t\tthis.filePath = filePath;\n\t\tthis.url = url;\n\t\tthis.ontologyContentEncoded64 = ontologyContentEncoded64;\n\t}", "\tpublic String getFilePath() {\n\t\treturn filePath;\n\t}\n\t\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\t\n\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n}\n", "\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/ruleSWRLInputComplex.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\nimport java.util.List;\n\npublic class ruleSWRLInputComplex {\n\tprivate String filePath;\n\tprivate String url;\n\tprivate String ontologyContentEncoded64;\n\tprivate List<SWRLTypeEntityVariable> premise;\n\tprivate List<SWRLTypeEntityVariable> conclusion;\n\t\n\tpublic ruleSWRLInputComplex(String filePath , String url, String ontologyContentEncoded64 ,List<SWRLTypeEntityVariable> premise,List<SWRLTypeEntityVariable> conclusion) {\n\t\tthis.filePath = filePath;\n\t\tthis.url = url;\n\t\tthis.ontologyContentEncoded64 = ontologyContentEncoded64;\n        this.premise = premise;\n        this.conclusion = conclusion;\n        }", "\tpublic String getFilePath() {\n\t\treturn filePath;\n\t}\n\t\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\t\n\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic List<SWRLTypeEntityVariable> getHead() {\n\t\treturn conclusion;\n\t}\n\t\n\tpublic List<SWRLTypeEntityVariable> getBody() {\n\t\treturn premise;\n\t}\n}\n", "\tpublic String getOntologyContentEncoded64() {\n\t\treturn ontologyContentEncoded64;\n\t}\n\n\tpublic List<SWRLTypeEntityVariable> getHead() {\n\t\treturn conclusion;\n\t}\n\t\n\tpublic List<SWRLTypeEntityVariable> getBody() {\n\t\treturn premise;\n\t}\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/model/SWRLTypeEntityVariable.java", "chunked_list": ["package com.souslesens.Jowl.model;\n\nimport java.util.List;\n\npublic class SWRLTypeEntityVariable {\n\t\tString type;\n\t\tList<SWRLVariables> entities;\n\t\tpublic SWRLTypeEntityVariable (String type , List<SWRLVariables> entities) {\n\t\t\tthis.entities = entities;\n\t\t\tthis.type = type;\n\t\t}", "\t    public String getType() {\n\t        return type;\n\t    }\n\n\t    public List<SWRLVariables> getEntities() {\n\t        return entities;\n\t    }\n\t\t\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/AlternativeReasonerServiceImpl.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;", "import java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport org.json.JSONObject;\nimport org.semanticweb.owlapi.apibinding.OWLManager;\nimport org.semanticweb.owlapi.model.IRI;\nimport org.semanticweb.owlapi.model.OWLAnnotationAssertionAxiom;\nimport org.semanticweb.owlapi.model.OWLAxiom;\nimport org.semanticweb.owlapi.model.OWLClass;", "import org.semanticweb.owlapi.model.OWLAxiom;\nimport org.semanticweb.owlapi.model.OWLClass;\nimport org.semanticweb.owlapi.model.OWLClassAssertionAxiom;\nimport org.semanticweb.owlapi.model.OWLClassExpression;\nimport org.semanticweb.owlapi.model.OWLDataFactory;\nimport org.semanticweb.owlapi.model.OWLDataProperty;\nimport org.semanticweb.owlapi.model.OWLDataPropertyAssertionAxiom;\nimport org.semanticweb.owlapi.model.OWLDatatype;\nimport org.semanticweb.owlapi.model.OWLDeclarationAxiom;\nimport org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;", "import org.semanticweb.owlapi.model.OWLDeclarationAxiom;\nimport org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;\nimport org.semanticweb.owlapi.model.OWLFunctionalObjectPropertyAxiom;\nimport org.semanticweb.owlapi.model.OWLNamedIndividual;\nimport org.semanticweb.owlapi.model.OWLObjectProperty;\nimport org.semanticweb.owlapi.model.OWLObjectPropertyAssertionAxiom;\nimport org.semanticweb.owlapi.model.OWLObjectPropertyDomainAxiom;\nimport org.semanticweb.owlapi.model.OWLObjectPropertyRangeAxiom;\nimport org.semanticweb.owlapi.model.OWLOntology;\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;", "import org.semanticweb.owlapi.model.OWLOntology;\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyManager;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport org.semanticweb.owlapi.model.OWLSubClassOfAxiom;\nimport org.semanticweb.owlapi.reasoner.InferenceType;\nimport org.semanticweb.owlapi.reasoner.Node;\nimport org.semanticweb.owlapi.reasoner.OWLReasoner;\nimport org.semanticweb.owlapi.util.InferredOntologyGenerator;\nimport org.springframework.stereotype.Service;", "import org.semanticweb.owlapi.util.InferredOntologyGenerator;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport com.clarkparsia.pellet.owlapiv3.PelletReasonerFactory;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.souslesens.Jowl.model.reasonerConsistency;\nimport com.souslesens.Jowl.model.reasonerExtractTriples;\nimport com.souslesens.Jowl.model.reasonerUnsatisfaisability;\n@Service", "import com.souslesens.Jowl.model.reasonerUnsatisfaisability;\n@Service\n\npublic class AlternativeReasonerServiceImpl implements AlternativeReasonerService{\n\t\n\t// ALTERNATIVE FUNCTIONS\n\t @Override\n\tpublic String getUnsatisfaisableClassesAlt(String filePath, String Url, MultipartFile ontologyFile) throws Exception {\n        OWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t    OWLOntology ontology = null ;\n \t\tFile inputOntology = null;\n \t\tPath tempFile = null;", "        if (ontologyFile != null) {\n             try {\n                 inputOntology = CnvMultFile(ontologyFile);\n                 inputOntology.setLastModified(System.currentTimeMillis());\n                 filePath = inputOntology.getAbsolutePath();\n                 System.out.println(filePath);\n                 tempFile = Files.createTempFile(\"ontology-unsat\", \".owl\");\n                 \n                 System.out.println(tempFile);\n                 Files.copy(inputOntology.toPath(), tempFile, StandardCopyOption.REPLACE_EXISTING);\n                 filePath = tempFile.toAbsolutePath().toString();\n                 \n                 String tempDirectoryPath = System.getProperty(\"java.io.tmpdir\");\n                 deleteFilesStartingWithOntologyAndAreOneDayOld(tempDirectoryPath);\n             } catch (Exception e) {\n                 return null;\n             }\n         }", "\t        if (filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t        \t\n\t        \tontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t        } else if(filePath.isEmpty() == false && Url == null) {\n\t        \t\n\t            ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t        } else {\n\t        \treturn null;\n\t        }\n\n        PelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n        OWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\n        reasonerUnsatisfaisability myData = new reasonerUnsatisfaisability();\n        Node<OWLClass> unsatisfiableClasses = reasoner.getUnsatisfiableClasses();\n\n        OWLClass[] unsatisfiable = new OWLClass[unsatisfiableClasses.getSize()];\n        int i = 0;", "        if (unsatisfiableClasses.getSize() > 0) {\n            for (OWLClass cls : unsatisfiableClasses) {\n                unsatisfiable[i] = cls;\n                i++;\n            }\n            myData.setUnsatisfaisable(unsatisfiable);\n        }\n\n        OWLClass[] unsatisfiableArray = myData.getUnsatisfaisable();\n        String[] iriStrings = new String[unsatisfiableArray.length];\n        for (int j = 0; j < unsatisfiableArray.length; j++) {\n            iriStrings[j] = unsatisfiableArray[j].toStringID();\n        }\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"unsatisfiable\", iriStrings);\n        String jsonString = jsonObject.toString();\n        return jsonString;\n    }", "        for (int j = 0; j < unsatisfiableArray.length; j++) {\n            iriStrings[j] = unsatisfiableArray[j].toStringID();\n        }\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"unsatisfiable\", iriStrings);\n        String jsonString = jsonObject.toString();\n        return jsonString;\n    }\n\t public String getConsistencyAlt(String filePath, String Url, MultipartFile ontologyFile) throws OWLOntologyCreationException, JsonProcessingException,Exception {\n\t     OWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t     OWLOntology ontology = null ;\n \t\t File inputOntology = null;\n \t\t Path tempFile = null;", "\t public String getConsistencyAlt(String filePath, String Url, MultipartFile ontologyFile) throws OWLOntologyCreationException, JsonProcessingException,Exception {\n\t     OWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t     OWLOntology ontology = null ;\n \t\t File inputOntology = null;\n \t\t Path tempFile = null;\n         if (ontologyFile != null) {\n             try {\n                 inputOntology = CnvMultFile(ontologyFile);\n                 inputOntology.setLastModified(System.currentTimeMillis());\n                 filePath = inputOntology.getAbsolutePath();\n                 System.out.println(filePath);\n                 tempFile = Files.createTempFile(\"ontology-\", \".owl\");\n                 \n                 System.out.println(tempFile);\n                 Files.copy(inputOntology.toPath(), tempFile, StandardCopyOption.REPLACE_EXISTING);\n                 filePath = tempFile.toAbsolutePath().toString();\n                 \n                 String tempDirectoryPath = System.getProperty(\"java.io.tmpdir\");\n                 deleteFilesStartingWithOntologyAndAreOneDayOld(tempDirectoryPath);\n             } catch (Exception e) {\n                 return null;\n             }\n         }\n\t     ", "\t     if ( filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t        \t\n\t        \tontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t        } else if(filePath.isEmpty() == false && Url == null ) {\n\t        \t\n\t            ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));}\n\t        else {\n\t        \t\n\t        \n\t        \treturn null;\n\t        }\n\t         PelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t         OWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t         reasonerConsistency myData = new reasonerConsistency();\n\t         boolean consistency = reasoner.isConsistent();\n\t         System.out.println(consistency);\n\t         myData.setConsistency(consistency);\n\t         JSONObject jsonObject = new JSONObject();\n\t         jsonObject.put(\"consistency\", myData.getConsistency());\n\t         String jsonString = jsonObject.toString();\n\t         return jsonString;\n\t         \n\t         \n\t \t}\n\n\t \n\t @Override\n\t public List<reasonerExtractTriples> getInferencesAlt(String filePath, String url,MultipartFile ontologyFile ) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t     OWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t     OWLOntology ontology = null ;\n \t\t File inputOntology = null;\n \t\t Path tempFile = null;", "         if (ontologyFile != null) {\n             try {\n                 inputOntology = CnvMultFile(ontologyFile);\n                 \n                 filePath = inputOntology.getAbsolutePath();\n                 System.out.println(filePath);\n                 tempFile = Files.createTempFile(\"ontology-ontology\", \".owl\");\n                 System.out.println(tempFile);\n                 Files.copy(inputOntology.toPath(), tempFile, StandardCopyOption.REPLACE_EXISTING);\n                 filePath = tempFile.toAbsolutePath().toString();\n                 \n                 System.out.println(\"dir from infe\"+filePath);\n             } catch (Exception e) {\n                 return null;\n             }\n         }", "\t        if (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\t        \t\n\t        \tontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));\n\t        } else if(filePath.isEmpty() == false && url == null) {\n\t        \t\n\t            ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t        } else {\n\t        \treturn null;\n\t        }\n\t        PelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t        OWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t        reasoner.precomputeInferences(InferenceType.values());\n\t        InferredOntologyGenerator iog = new InferredOntologyGenerator(reasoner);\n\t        OWLOntology inferredOntology = manager.createOntology();\n\t        OWLDataFactory dataFactory = manager.getOWLDataFactory();\n\t        iog.fillOntology(dataFactory, inferredOntology);\n\t        Path tempFileInfer = null;", "\t        try {\n\t            tempFileInfer = Files.createTempFile(\"ontology-inferred\", \".owl\");\n\t            manager.saveOntology(inferredOntology, IRI.create(tempFileInfer.toFile()));\n\n\t            System.out.println(\"New file created: \" + tempFileInfer);\n\t        } catch (IOException e) {\n\t            System.out.println(\"An error occurred: \" + e.getMessage());\n\t            e.printStackTrace();\n\t        }\n\n\t        String filePathInfer = tempFileInfer.toAbsolutePath().toString();\n\t        String tempDirectoryPath = System.getProperty(\"java.io.tmpdir\");\n\t        deleteFilesStartingWithOntologyAndAreOneDayOld(tempDirectoryPath);\n\t        System.out.println(\"TEMP: \" + tempDirectoryPath);\n\t        // Load the ontology from the file\n\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePathInfer));\n\t        \n\t     // Print the inferred axioms", "\t        for (OWLAxiom axiom : inferredOntology.getAxioms()) {\n\t            System.out.println(\"THE INFERRED AXIOMS\"+axiom);\n\t        }\n\t        System.out.println(\"Ontology ComputeInference Completed\");\n\t        Set<OWLAxiom> axioms = ontology.getAxioms();\n\t        List<reasonerExtractTriples> triplesList = new ArrayList<>(); \n\t        // Iterate through axioms\n\t        for (OWLAxiom axiom : axioms) {\n\t            String subject = null;\n\t            String predicate = null;\n\t            String object = null;\n\t            \n\t            // Extract subject and object", "\t            if (axiom instanceof OWLSubClassOfAxiom) {\n\t                OWLSubClassOfAxiom subClassAxiom = (OWLSubClassOfAxiom) axiom;\n\t                subject = subClassAxiom.getSubClass().toString();\n\t                object = subClassAxiom.getSuperClass().toString();\n\t                predicate = \"subClassOf\";\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLEquivalentClassesAxiom) {\n\t                OWLEquivalentClassesAxiom equivClassesAxiom = (OWLEquivalentClassesAxiom) axiom;\n\t                Set<OWLClassExpression> classExpressions = equivClassesAxiom.getClassExpressions();", "\t            } else if (axiom instanceof OWLEquivalentClassesAxiom) {\n\t                OWLEquivalentClassesAxiom equivClassesAxiom = (OWLEquivalentClassesAxiom) axiom;\n\t                Set<OWLClassExpression> classExpressions = equivClassesAxiom.getClassExpressions();\n\t                for (OWLClassExpression classExpression : classExpressions) {\n\t                    if (!classExpression.isAnonymous()) {\n\t                        if (subject == null) {\n\t                            subject = classExpression.asOWLClass().toStringID();\n\t                            predicate = \"equivalentTo\";\n\t                        } else {\n\t                            object = classExpression.asOWLClass().toStringID();\n\t                        }", "\t                        if (subject != null && predicate != null && object !=null) {\n\t                            triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                            }\n\t    \t                \n\t                    }\n\t                }\n\t            } else if (axiom instanceof OWLClassAssertionAxiom) {\n\t                OWLClassAssertionAxiom classAssertionAxiom = (OWLClassAssertionAxiom) axiom;\n\t                subject = classAssertionAxiom.getIndividual().toStringID();\n\t                object = classAssertionAxiom.getClassExpression().toString();\n\t                predicate = \"type\";", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLObjectPropertyAssertionAxiom) {\n\t                OWLObjectPropertyAssertionAxiom objectPropertyAssertionAxiom = (OWLObjectPropertyAssertionAxiom) axiom;\n\t                subject = objectPropertyAssertionAxiom.getSubject().toStringID();\n\t                object = objectPropertyAssertionAxiom.getObject().toStringID();\n\t                predicate = objectPropertyAssertionAxiom.getProperty().toString();\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLDataPropertyAssertionAxiom) {\n\t                OWLDataPropertyAssertionAxiom dataPropertyAssertionAxiom = (OWLDataPropertyAssertionAxiom) axiom;\n\t                subject = dataPropertyAssertionAxiom.getSubject().toStringID();\n\t                object = dataPropertyAssertionAxiom.getObject().toString();\n\t                predicate = dataPropertyAssertionAxiom.getProperty().toString();\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLAnnotationAssertionAxiom) {\n\t                OWLAnnotationAssertionAxiom annotationAssertionAxiom = (OWLAnnotationAssertionAxiom) axiom;\n\t                subject = annotationAssertionAxiom.getSubject().toString();\n\t                object = annotationAssertionAxiom.getValue().toString();\n\t                predicate = annotationAssertionAxiom.getProperty().toString();\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLObjectPropertyDomainAxiom) {\n\t                OWLObjectPropertyDomainAxiom objectPropertyDomainAxiom = (OWLObjectPropertyDomainAxiom) axiom;\n\t                subject = objectPropertyDomainAxiom.getProperty().toString();\n\t                object = objectPropertyDomainAxiom.getDomain().toString();\n\t                predicate = \"domain\";\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLObjectPropertyRangeAxiom) {\n\t                OWLObjectPropertyRangeAxiom objectPropertyRangeAxiom = (OWLObjectPropertyRangeAxiom) axiom;\n\t                subject = objectPropertyRangeAxiom.getProperty().toString();\n\t                object = objectPropertyRangeAxiom.getRange().toString();\n\t                predicate = \"range\";\n\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null && object !=null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLFunctionalObjectPropertyAxiom) {\n\t                OWLFunctionalObjectPropertyAxiom functionalObjectPropertyAxiom = (OWLFunctionalObjectPropertyAxiom) axiom;\n\t                subject = functionalObjectPropertyAxiom.getProperty().toString();\n\t                predicate = \"functionalProperty\";\n\t                \n\t                if (subject != null && predicate != null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }", "\t                if (subject != null && predicate != null) {\n\t                triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                }\n\t            } else if (axiom instanceof OWLDeclarationAxiom) {\n\t                OWLDeclarationAxiom declarationAxiom = (OWLDeclarationAxiom) axiom;\n\t                if (declarationAxiom.getEntity() instanceof OWLClass) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"classDeclaration\";\n\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }", "\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }\n\t                } else if (declarationAxiom.getEntity() instanceof OWLObjectProperty) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"objectPropertyDeclaration\";\n\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }\n\t                } else if (declarationAxiom.getEntity() instanceof OWLDataProperty) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"dataPropertyDeclaration\";", "\t                } else if (declarationAxiom.getEntity() instanceof OWLDataProperty) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"dataPropertyDeclaration\";\n\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }\n\t                } else if (declarationAxiom.getEntity() instanceof OWLNamedIndividual) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"namedIndividualDeclaration\";\n\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }", "\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }\n\t                }else if (declarationAxiom.getEntity() instanceof OWLDatatype) {\n\t                    subject = declarationAxiom.getEntity().toStringID();\n\t                    predicate = \"datatypeDeclaration\";\n\t                    if (subject != null && predicate != null) {\n\t                    triplesList.add(new reasonerExtractTriples(subject, predicate, object));\n\t                    }\n\t                }\n\t            }\n\n\t            \n\t        }\n\t        return triplesList;\n\t         \n\t \t\n\t\t\t\n\t }\n\t \n\t // ******************* Executors && Thread *******************", "\t    public void deleteIfOneMinuteOld(String filePath) {\n\t        File file = new File(filePath);\n\t        long creationTime = file.lastModified();\n\t        long currentTime = System.currentTimeMillis();\n\t        Duration DiffBetweenCreationCurrent = Duration.between(Instant.ofEpochMilli(creationTime), Instant.ofEpochMilli(currentTime));\n\t        if (DiffBetweenCreationCurrent.equals(Duration.ofMinutes(1))) {\n\t            boolean deleted = file.delete();\n\t            if (deleted) {\n\t                System.out.println(\"File \" + filePath + \" deleted new meth successfully.\");\n\t            } else {\n\t                System.out.println(\"Failed to delete file \" + filePath);\n\t            }\n\t        }\n\t    }", "\t    public void deleteFilesStartingWithOntologyAndAreOneDayOld(String directoryPath) {\n\t        File directory = new File(directoryPath);\n\t        System.out.println(\"Dir Path\"+directoryPath );\n\t        File[] files = directory.listFiles();\n\t        long currentTime = System.currentTimeMillis();\n\t        System.out.println(\"Current Time\"+currentTime);\n\t        \n\t        if (files != null) {\n\t            for (File file : files) {\n\t                if (file.getName().startsWith(\"ontology\") ) {\n\t                    long createTime = file.lastModified();\n\t                    long diffInMilliseconds = currentTime - createTime;\n\t                    System.out.println(\"Difference in milliseconds\"+diffInMilliseconds);\n\t                    long diffInSeconds = diffInMilliseconds / 1000;\n\t                    System.out.println(\"Difference in seconds\"+diffInSeconds);", "\t            for (File file : files) {\n\t                if (file.getName().startsWith(\"ontology\") ) {\n\t                    long createTime = file.lastModified();\n\t                    long diffInMilliseconds = currentTime - createTime;\n\t                    System.out.println(\"Difference in milliseconds\"+diffInMilliseconds);\n\t                    long diffInSeconds = diffInMilliseconds / 1000;\n\t                    System.out.println(\"Difference in seconds\"+diffInSeconds);\n\t                    if (diffInSeconds >= 60) {\n\t                        boolean deleted = file.delete();\n\t                        if (deleted) {\n\t                            System.out.println(\"File \" + file.getName() + \" deleted successfully.\");\n\t                        } else {\n\t                            System.out.println(\"Failed to delete file \" + file.getName());\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // Convert the MultiPartFile to File\n\t private File CnvMultFile(MultipartFile nameFile) throws IOException {\n\t\t    File CnvFile = new File(nameFile.getOriginalFilename());\n\t\t    nameFile.transferTo(CnvFile);\n\t\t    return CnvFile;\n\t\t}\n\n}\n\n\n\n", "\t                        if (deleted) {\n\t                            System.out.println(\"File \" + file.getName() + \" deleted successfully.\");\n\t                        } else {\n\t                            System.out.println(\"Failed to delete file \" + file.getName());\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // Convert the MultiPartFile to File\n\t private File CnvMultFile(MultipartFile nameFile) throws IOException {\n\t\t    File CnvFile = new File(nameFile.getOriginalFilename());\n\t\t    nameFile.transferTo(CnvFile);\n\t\t    return CnvFile;\n\t\t}\n\n}\n\n\n\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/JenaServiceImpl.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.List;\n\nimport org.apache.jena.rdf.model.Model;", "\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.rdf.model.RDFNode;\nimport org.apache.jena.rdf.model.Statement;\nimport org.apache.jena.rdf.model.StmtIterator;\nimport org.apache.jena.riot.RDFDataMgr;\nimport org.apache.jena.riot.RDFLanguages;\nimport org.springframework.stereotype.Service;\n", "import org.springframework.stereotype.Service;\n\nimport com.souslesens.Jowl.model.jenaTripleParser;\n@Service\n\npublic class JenaServiceImpl implements JenaService {\n\n\t\n\n\t@Override\n\tpublic List<jenaTripleParser> getTriples(String filePath, String url,\n\t\t\tString ontologyContentEncoded64) {\n\t\t\n\t\tArrayList<jenaTripleParser> tripleParser = new ArrayList<>();\n\t\tModel m = ModelFactory.createDefaultModel();\n\t\t// Can Read all FORMATS\n", "        try {\n            if (filePath != null && url == null && ontologyContentEncoded64 == null) {\n            \tm = RDFDataMgr.loadModel(filePath, RDFLanguages.filenameToLang(filePath));\n            } else if (url != null && filePath == null && ontologyContentEncoded64 == null) {\n            \tm = RDFDataMgr.loadModel(url, RDFLanguages.filenameToLang(url));\n            } else if (ontologyContentEncoded64 != null && filePath == null && url == null) {\n                byte[] ontologyBytes =  Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n                try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                    RDFDataMgr.read(m, inputStream, null, RDFLanguages.RDFXML); //  RDF/XML  and OWL )\n                } catch (Exception e) {\n                    try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                        RDFDataMgr.read(m, inputStream, null, RDFLanguages.TURTLE); // Turtle and OWL\n                    } catch (Exception e2) {\n                        try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                        \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.JSONLD); // JSONLD\n                        }catch (Exception e3){\n                            try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                            \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.NTRIPLES);  // NTRIPLES\n                            }\n                            catch (Exception e4){\n                                try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                                \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.RDFJSON);  // RDFJSON\n                                }catch (Exception e5) {\n                                    try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                                    \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.SHACLC);  // SHACLC\n                                    }catch (Exception e6) {\n                                        try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                                        \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.N3);  // N3\n                                        }catch (Exception e7) {\n                                            try (InputStream inputStream = new ByteArrayInputStream(ontologyBytes)) {\n                                            \tRDFDataMgr.read(m, inputStream, null, RDFLanguages.NQUADS);\n                                        }catch (Exception e8) {\n                                        \te8.printStackTrace();\n                                            return null;\n                                        }\n                                        }\n                                    }\n                                }\n                            }\n                        \t}\n\n                    }\n                }\n            }\n             else {\n                return null;\n            }\n            \t \n \t            StmtIterator sIter = m.listStatements();\n", " \t            while (sIter.hasNext()) {\n \t                Statement statement = sIter.next();\n\n \t                String objectStr;\n \t                RDFNode objectNode = statement.getObject();\n\n \t                if (objectNode.isResource()) {\n \t                    objectStr = \"<\" + objectNode.toString() + \">\";\n \t                } else {\n \t                    objectStr = \"'\" + objectNode.toString().replaceAll(\"'\", \"\") + \"'\";\n \t                    objectStr = objectStr.replaceAll(\"\\n\", \"\");\n \t                    objectStr = objectStr.replaceAll(\"\\r\", \"\");\n \t                    objectStr = objectStr.replaceAll(\"\\\"\", \"\");\n \t                    objectStr = objectStr.replaceAll(\"\\\\\\\\\", \"\");\n \t                }\n \t                String subject = \"<\" + statement.getSubject().toString() + \">\";\n \t                String predicate = \"<\" + statement.getPredicate().toString() + \">\";\n \t                String object =   objectStr ;\n\n \t               tripleParser.add(new jenaTripleParser(subject, predicate, object));\n \t               \n \t            }\n \t           return tripleParser;\n            }\n \t            catch (Exception e) {\n \t            \treturn null;\n\t\t\t\t}\n\t\t\t\n\t\t\n\t}\n}\n\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/SWRLService.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.IOException;\nimport java.util.List;\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport com.souslesens.Jowl.model.SWRLTypeEntityVariable;\n\npublic interface SWRLService {\n\n\t\n\tString SWRLruleReclassification(String filePath, String Url, String[] reqBodies , String[] reqHead) throws Exception;\n\tString SWRLruleReclassificationB64(String ontologyContentDecoded64 , String[] reqBodies , String[] reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\tString SWRLruleVAB64(String ontologyContentDecoded64 , List<SWRLTypeEntityVariable> reqBodies , List<SWRLTypeEntityVariable> reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\tString SWRLruleVABUF(String filePath,String url, List<SWRLTypeEntityVariable> reqBodies,List<SWRLTypeEntityVariable> reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n}\n", "public interface SWRLService {\n\n\t\n\tString SWRLruleReclassification(String filePath, String Url, String[] reqBodies , String[] reqHead) throws Exception;\n\tString SWRLruleReclassificationB64(String ontologyContentDecoded64 , String[] reqBodies , String[] reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\tString SWRLruleVAB64(String ontologyContentDecoded64 , List<SWRLTypeEntityVariable> reqBodies , List<SWRLTypeEntityVariable> reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\tString SWRLruleVABUF(String filePath,String url, List<SWRLTypeEntityVariable> reqBodies,List<SWRLTypeEntityVariable> reqHead) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/ReasonerServiceImpl.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;", "import java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Stream;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.semanticweb.owlapi.apibinding.OWLManager;\nimport org.semanticweb.owlapi.io.OWLOntologyDocumentSource;\nimport org.semanticweb.owlapi.io.StreamDocumentSource;", "import org.semanticweb.owlapi.io.OWLOntologyDocumentSource;\nimport org.semanticweb.owlapi.io.StreamDocumentSource;\nimport org.semanticweb.owlapi.model.AxiomType;\nimport org.semanticweb.owlapi.model.IRI;\nimport org.semanticweb.owlapi.model.MissingImportHandlingStrategy;\nimport org.semanticweb.owlapi.model.OWLAxiom;\nimport org.semanticweb.owlapi.model.OWLClass;\nimport org.semanticweb.owlapi.model.OWLClassAxiom;\nimport org.semanticweb.owlapi.model.OWLClassExpression;\nimport org.semanticweb.owlapi.model.OWLDataFactory;", "import org.semanticweb.owlapi.model.OWLClassExpression;\nimport org.semanticweb.owlapi.model.OWLDataFactory;\nimport org.semanticweb.owlapi.model.OWLDifferentIndividualsAxiom;\nimport org.semanticweb.owlapi.model.OWLDisjointClassesAxiom;\nimport org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;\nimport org.semanticweb.owlapi.model.OWLIndividual;\nimport org.semanticweb.owlapi.model.OWLInverseObjectPropertiesAxiom;\nimport org.semanticweb.owlapi.model.OWLNamedIndividual;\nimport org.semanticweb.owlapi.model.OWLObjectComplementOf;\nimport org.semanticweb.owlapi.model.OWLObjectHasValue;", "import org.semanticweb.owlapi.model.OWLObjectComplementOf;\nimport org.semanticweb.owlapi.model.OWLObjectHasValue;\nimport org.semanticweb.owlapi.model.OWLObjectIntersectionOf;\nimport org.semanticweb.owlapi.model.OWLObjectProperty;\nimport org.semanticweb.owlapi.model.OWLObjectPropertyAxiom;\nimport org.semanticweb.owlapi.model.OWLObjectPropertyExpression;\nimport org.semanticweb.owlapi.model.OWLObjectSomeValuesFrom;\nimport org.semanticweb.owlapi.model.OWLOntology;\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyLoaderConfiguration;", "import org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyLoaderConfiguration;\nimport org.semanticweb.owlapi.model.OWLOntologyManager;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport org.semanticweb.owlapi.model.OWLSameIndividualAxiom;\nimport org.semanticweb.owlapi.model.OWLSubClassOfAxiom;\nimport org.semanticweb.owlapi.reasoner.InferenceType;\nimport org.semanticweb.owlapi.reasoner.Node;\nimport org.semanticweb.owlapi.reasoner.NodeSet;\nimport org.semanticweb.owlapi.reasoner.OWLReasoner;", "import org.semanticweb.owlapi.reasoner.NodeSet;\nimport org.semanticweb.owlapi.reasoner.OWLReasoner;\nimport org.semanticweb.owlapi.util.InferredAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredClassAssertionAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredClassAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredDataPropertyCharacteristicAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredEquivalentDataPropertiesAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredEquivalentObjectPropertyAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredIndividualAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredObjectPropertyCharacteristicAxiomGenerator;", "import org.semanticweb.owlapi.util.InferredIndividualAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredObjectPropertyCharacteristicAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredOntologyGenerator;\nimport org.semanticweb.owlapi.util.InferredPropertyAssertionGenerator;\nimport org.semanticweb.owlapi.util.InferredSubClassAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredSubDataPropertyAxiomGenerator;\nimport org.semanticweb.owlapi.util.InferredSubObjectPropertyAxiomGenerator;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.WritableResource;", "import org.springframework.core.io.Resource;\nimport org.springframework.core.io.WritableResource;\nimport org.springframework.stereotype.Service;\nimport com.clarkparsia.pellet.owlapiv3.PelletReasonerFactory;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.souslesens.Jowl.model.reasonerConsistency;\nimport com.souslesens.Jowl.model.reasonerUnsatisfaisability;\n\n@Service\n\npublic class ReasonerServiceImpl implements ReasonerService {\n\n\t@Override", "@Service\n\npublic class ReasonerServiceImpl implements ReasonerService {\n\n\t@Override\n\tpublic String getUnsatisfaisableClasses(String filePath, String Url) throws Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\n\t\tOWLOntologyLoaderConfiguration configurator = new OWLOntologyLoaderConfiguration();\n\t     configurator.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t    // manager.setOntologyConfigurator(configurator);\n\t\t\n\t\tOWLOntology ontology = null;", "\t\ttry {\n\t\t    if (filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t\t    } else if (filePath.isEmpty() == false && Url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasonerUnsatisfaisability myData = new reasonerUnsatisfaisability();\n\t\tNode<OWLClass> unsatisfiableClasses = reasoner.getUnsatisfiableClasses();\n\n\t\tOWLClass[] unsatisfiable = new OWLClass[unsatisfiableClasses.getSize()];\n\t\tint i = 0;", "\t\tif (unsatisfiableClasses.getSize() > 0) {\n\t\t\tfor (OWLClass cls : unsatisfiableClasses) {\n\t\t\t\tunsatisfiable[i] = cls;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tmyData.setUnsatisfaisable(unsatisfiable);\n\t\t}\n\n\t\tOWLClass[] unsatisfiableArray = myData.getUnsatisfaisable();\n\t\tString[] iriStrings = new String[unsatisfiableArray.length];\n\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override", "\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override\n\tpublic String postInferencesContent(String ontologyContentDecoded64, List<String> ListOfValues)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;", "\tpublic String postInferencesContent(String ontologyContentDecoded64, List<String> ListOfValues)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;\n\t\ttry {", "\t\ttry {\n\t\t    if (instream.available() > 0) {\n\t\t        OWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage(); \n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasoner.precomputeInferences(InferenceType.values());\n\t\tOWLOntology inferredOntology = manager.createOntology();\n        List<InferredAxiomGenerator<? extends OWLAxiom>> axiomGenerators = new ArrayList<>();       \n\t\tInferredOntologyGenerator iog = new InferredOntologyGenerator(reasoner, axiomGenerators);\n\t\t\n\t\t//", "        for (String value : ListOfValues) {\n            try {\n                boolean generatorAdded = false;\n                if (value.contentEquals(\"CustomInferredIntersectionOfAxiomGenerator()\")   && !generatorAdded ) {\n                \tiog.addGenerator( new CustomInferredIntersectionOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredEquivalentClassesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredEquivalentClassesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomSameIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomSameIndividualAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomSameIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomSameIndividualAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredUnionOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredUnionOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDisjointClassesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDisjointClassesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDifferentIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDifferentIndividualAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredDifferentIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDifferentIndividualAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredHasValueAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredHasValueAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredInverseObjectPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredInverseObjectPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredAllValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredAllValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredAllValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredAllValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredSameValueSomeValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredSameValueSomeValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDomainAndRangeAxiomGenerator()\") && !generatorAdded)  {\n                \tiog.addGenerator( new CustomInferredDomainAndRangeAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredClassAssertionAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredClassAssertionAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"InferredClassAssertionAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredClassAssertionAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredSubClassAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubClassAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredDataPropertyCharacteristicAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredDataPropertyCharacteristicAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredEquivalentDataPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                ", "                }else if (value.contentEquals(\"InferredEquivalentDataPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                \n                }else if (value.contentEquals(\"InferredEquivalentObjectPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentObjectPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredSubObjectPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubObjectPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                ", "                }else if (value.contentEquals(\"InferredSubDataPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubDataPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredObjectPropertyCharacteristicAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredObjectPropertyCharacteristicAxiomGenerator());\n                \tgeneratorAdded = true;;\n                }else if (value.contentEquals(\"InferredPropertyAssertionGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredPropertyAssertionGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredComplementOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredComplementOfAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredComplementOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredComplementOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"All\")) {\n        \t        iog.addGenerator(new CustomInferredEquivalentClassesAxiomGenerator() );\n        \t        iog.addGenerator(new CustomSameIndividualAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredDifferentIndividualAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredIntersectionOfAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredUnionOfAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredDisjointClassesAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredHasValueAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredInverseObjectPropertiesAxiomGenerator() );\n        \t        iog.addGenerator(new CustomInferredAllValuesFromAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredSameValueSomeValuesFromAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredDomainAndRangeAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubClassAxiomGenerator());\n        \t        iog.addGenerator( new InferredClassAssertionAxiomGenerator());\n        \t        iog.addGenerator( new InferredDataPropertyCharacteristicAxiomGenerator());\n        \t        iog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n        \t        iog.addGenerator( new InferredEquivalentObjectPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubObjectPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubDataPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredObjectPropertyCharacteristicAxiomGenerator());\n        \t        iog.addGenerator( new InferredPropertyAssertionGenerator());\n        \t        iog.addGenerator(new CustomInferredComplementOfAxiomGenerator()); // Generate owl:ComplementOf\n        \t        \n                        break;\n                }else {\n                \tbreak;\n                }", "                if (generatorAdded) {\n                    continue;\n                }\n\n\n                \n            } catch (Exception e) {\n                e.printStackTrace(); // Handle any exceptions that may occur\n            }\n        }\n\t\tOWLDataFactory dataFactory = manager.getOWLDataFactory();\n\t\tiog.fillOntology(dataFactory, inferredOntology);\n\t\tJSONObject jsonObject = new JSONObject();", "\t\tfor (AxiomType<?> axiomType : AxiomType.AXIOM_TYPES) {\n\t\t\tSet<? extends OWLAxiom> axioms = inferredOntology.getAxioms(axiomType);\n\t\t\tif (!axioms.isEmpty()) {\n\t\t\t\tjsonObject.put(axiomType.toString(), convertAxiomSetToJSONArray(axioms));\n\t\t\t}\n\t\t}\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\tprivate static JSONArray convertAxiomSetToJSONArray(Set<? extends OWLAxiom> axiomSet) {\n\t\tJSONArray jsonArray = new JSONArray();", "\t\tfor (OWLAxiom axiom : axiomSet) {\n\t\t\tjsonArray.put(axiom.toString());\n\t\t}\n\t\treturn jsonArray;\n\t}\n\n\t@Override\n\tpublic String postUnsatisfaisableClassesContent(String ontologyContentDecoded64) throws Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;", "\t\ttry {\n\t\t    if (instream.available() > 0) {\n\t\t        OWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage(); \n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\n\t\treasonerUnsatisfaisability myData = new reasonerUnsatisfaisability();\n\t\tNode<OWLClass> unsatisfiableClasses = reasoner.getUnsatisfiableClasses();\n\n\t\tOWLClass[] unsatisfiable = new OWLClass[unsatisfiableClasses.getSize()];\n\t\tint i = 0;", "\t\tif (unsatisfiableClasses.getSize() > 0) {\n\t\t\tfor (OWLClass cls : unsatisfiableClasses) {\n\t\t\t\tunsatisfiable[i] = cls;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tmyData.setUnsatisfaisable(unsatisfiable);\n\t\t}\n\n\t\tOWLClass[] unsatisfiableArray = myData.getUnsatisfaisable();\n\t\tString[] iriStrings = new String[unsatisfiableArray.length];\n\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override", "\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override\n\tpublic String postConsistencyContent(String ontologyContentDecoded64)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;", "\tpublic String postConsistencyContent(String ontologyContentDecoded64)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (instream.available() > 0) {\n\t\t        OWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage(); \n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasonerConsistency myData = new reasonerConsistency();\n\t\tboolean consistency = reasoner.isConsistent();\n\t\tSystem.out.println(consistency);\n\t\tmyData.setConsistency(consistency);\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"consistency\", myData.getConsistency());\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\n\t}\n\n\t@Override", "\t\ttry {\n\t\t    if (instream.available() > 0) {\n\t\t        OWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage(); \n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasonerConsistency myData = new reasonerConsistency();\n\t\tboolean consistency = reasoner.isConsistent();\n\t\tSystem.out.println(consistency);\n\t\tmyData.setConsistency(consistency);\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"consistency\", myData.getConsistency());\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\n\t}\n\n\t@Override", "\tpublic String postInferences(String filePath, String url,List<String> ListOfValues)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));\n\t\t    } else if (filePath.isEmpty() == false && url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasoner.precomputeInferences(InferenceType.values());\n\t\tOWLOntology inferredOntology = manager.createOntology();\n        List<InferredAxiomGenerator<? extends OWLAxiom>> axiomGenerators = new ArrayList<>();       \n\t\tInferredOntologyGenerator iog = new InferredOntologyGenerator(reasoner, axiomGenerators);", "        for (String value : ListOfValues) {\n            try {\n                boolean generatorAdded = false;\n                if (value.contentEquals(\"CustomInferredIntersectionOfAxiomGenerator()\")   && !generatorAdded ) {\n                \tiog.addGenerator( new CustomInferredIntersectionOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredEquivalentClassesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredEquivalentClassesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomSameIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomSameIndividualAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomSameIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomSameIndividualAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredUnionOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredUnionOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDisjointClassesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDisjointClassesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDifferentIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDifferentIndividualAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredDifferentIndividualAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredDifferentIndividualAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredHasValueAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredHasValueAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredInverseObjectPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredInverseObjectPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredAllValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredAllValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredAllValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredAllValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredSameValueSomeValuesFromAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredSameValueSomeValuesFromAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredDomainAndRangeAxiomGenerator()\") && !generatorAdded)  {\n                \tiog.addGenerator( new CustomInferredDomainAndRangeAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredClassAssertionAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredClassAssertionAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"InferredClassAssertionAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredClassAssertionAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredSubClassAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubClassAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredDataPropertyCharacteristicAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredDataPropertyCharacteristicAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredEquivalentDataPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                ", "                }else if (value.contentEquals(\"InferredEquivalentDataPropertiesAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n                \tgeneratorAdded = true;\n                \n                }else if (value.contentEquals(\"InferredEquivalentObjectPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredEquivalentObjectPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredSubObjectPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubObjectPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                ", "                }else if (value.contentEquals(\"InferredSubDataPropertyAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredSubDataPropertyAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"InferredObjectPropertyCharacteristicAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredObjectPropertyCharacteristicAxiomGenerator());\n                \tgeneratorAdded = true;;\n                }else if (value.contentEquals(\"InferredPropertyAssertionGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new InferredPropertyAssertionGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"CustomInferredComplementOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredComplementOfAxiomGenerator());\n                \tgeneratorAdded = true;", "                }else if (value.contentEquals(\"CustomInferredComplementOfAxiomGenerator()\") && !generatorAdded) {\n                \tiog.addGenerator( new CustomInferredComplementOfAxiomGenerator());\n                \tgeneratorAdded = true;\n                }else if (value.contentEquals(\"All\")) {\n        \t        iog.addGenerator(new CustomInferredEquivalentClassesAxiomGenerator() );\n        \t        iog.addGenerator(new CustomSameIndividualAxiomGenerator()); // we generate same individual axioms\n        \t        iog.addGenerator(new CustomInferredDifferentIndividualAxiomGenerator()); // we generate different individual axioms\n        \t        iog.addGenerator(new CustomInferredIntersectionOfAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredUnionOfAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredDisjointClassesAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredHasValueAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredInverseObjectPropertiesAxiomGenerator() );\n        \t        iog.addGenerator(new CustomInferredAllValuesFromAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredSameValueSomeValuesFromAxiomGenerator());\n        \t        iog.addGenerator(new CustomInferredDomainAndRangeAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubClassAxiomGenerator());\n        \t        iog.addGenerator( new InferredClassAssertionAxiomGenerator());\n        \t        iog.addGenerator( new InferredDataPropertyCharacteristicAxiomGenerator());\n        \t        iog.addGenerator( new InferredEquivalentDataPropertiesAxiomGenerator());\n        \t        iog.addGenerator( new InferredEquivalentObjectPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubObjectPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredSubDataPropertyAxiomGenerator());\n        \t        iog.addGenerator( new InferredObjectPropertyCharacteristicAxiomGenerator());\n        \t        iog.addGenerator( new InferredPropertyAssertionGenerator());\n        \t        iog.addGenerator(new CustomInferredComplementOfAxiomGenerator()); // Generate owl:ComplementOf\n                        break;\n                }else {\n                \tbreak;\n                }", "                if (generatorAdded) {\n                    continue;\n                }\n\n\n                \n            } catch (Exception e) {\n                e.printStackTrace(); \n            }\n        }\n\t\tOWLDataFactory dataFactory = manager.getOWLDataFactory();\n\t\tiog.fillOntology(dataFactory, inferredOntology);\n\t\tJSONObject jsonObject = new JSONObject();", "\t\tfor (AxiomType<?> axiomType : AxiomType.AXIOM_TYPES) {\n\t\t\tSet<? extends OWLAxiom> axioms = inferredOntology.getAxioms(axiomType);\n\t\t\tif (!axioms.isEmpty()) {\n\t\t\t\tjsonObject.put(axiomType.toString(), convertAxiomSetToJSONArray(axioms));\n\t\t\t}\n\t\t}\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\t@Override\n\tpublic String postUnsatisfaisableClasses(String filePath, String Url) throws Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;", "\tpublic String postUnsatisfaisableClasses(String filePath, String Url) throws Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t\t    } else if (filePath.isEmpty() == false && Url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\n\t\treasonerUnsatisfaisability myData = new reasonerUnsatisfaisability();\n\t\tNode<OWLClass> unsatisfiableClasses = reasoner.getUnsatisfiableClasses();\n\n\t\tOWLClass[] unsatisfiable = new OWLClass[unsatisfiableClasses.getSize()];\n\t\tint i = 0;", "\t\tif (unsatisfiableClasses.getSize() > 0) {\n\t\t\tfor (OWLClass cls : unsatisfiableClasses) {\n\t\t\t\tunsatisfiable[i] = cls;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tmyData.setUnsatisfaisable(unsatisfiable);\n\t\t}\n\n\t\tOWLClass[] unsatisfiableArray = myData.getUnsatisfaisable();\n\t\tString[] iriStrings = new String[unsatisfiableArray.length];\n\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override", "\t\tfor (int j = 0; j < unsatisfiableArray.length; j++) {\n\t\t\tiriStrings[j] = unsatisfiableArray[j].toStringID();\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"unsatisfiable\", iriStrings);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n\n\t@Override\n\tpublic String postConsistency(String filePath, String Url)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;", "\tpublic String postConsistency(String filePath, String Url)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t\t    } else if (filePath.isEmpty() == false && Url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasonerConsistency myData = new reasonerConsistency();\n\t\tboolean consistency = reasoner.isConsistent();\n\t\tSystem.out.println(consistency);\n\t\tmyData.setConsistency(consistency);\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"consistency\", myData.getConsistency());\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\n\t}\n\n\t// END\n\t@Override", "\tpublic String getConsistency(String filePath, String Url)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (filePath == null && Url.isEmpty() == false && (Url.startsWith(\"http\") || Url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(Url));\n\t\t    } else if (filePath.isEmpty() == false && Url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\treasonerConsistency myData = new reasonerConsistency();\n\t\tboolean consistency = reasoner.isConsistent();\n\t\tSystem.out.println(consistency);\n\t\tmyData.setConsistency(consistency);\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"consistency\", myData.getConsistency());\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\n\t}\n\n\t@Override", "\tpublic String getInferences(String filePath, String url)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntology ontology = null;\n\t\ttry {\n\t\t    if (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));\n\t\t    } else if (filePath.isEmpty() == false && url == null) {\n\t\t        ontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t    }\n\t\t} catch (OWLOntologyCreationException e) {\n\t\t    e.printStackTrace();\n\t\t    return e.getMessage();\n\t\t}\n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\tString fileName = \"inferred-ontology.owl\";\n\t\treasoner.precomputeInferences(InferenceType.values());\n\t\tInferredOntologyGenerator iog = new InferredOntologyGenerator(reasoner);\n\t\tOWLOntology inferredOntology = manager.createOntology();\n\t\tOWLDataFactory dataFactory = manager.getOWLDataFactory();\n\t\tiog.fillOntology(dataFactory, inferredOntology);\n\n\t\tResource resource = new FileSystemResource(fileName);", "\t\tif (resource instanceof WritableResource) {\n\t\t\ttry (OutputStream outputStream = ((WritableResource) resource).getOutputStream()) {\n\t\t\t\tmanager.saveOntology(inferredOntology, IRI.create(resource.getURI()));\n\t\t\t\tSystem.out.println(\"New file created: \" + fileName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.out.println(\"An error occurred: \" + e.getMessage());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\tontology = manager.loadOntologyFromOntologyDocument(resource.getFile());\n\t\tStringBuilder sb = new StringBuilder();\n\t\t// Add the inferred axioms to the list", "\t\tfor (OWLAxiom axiom : inferredOntology.getAxioms()) {\n\t\t\tsb.append(axiom.toString());\n\n\t\t}\n\t\tString axiomsString = sb.toString();\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"inference\", axiomsString);\n\t\tString jsonString = jsonObject.toString();\n\t\treturn jsonString;\n\t}\n", "\tpublic static class CustomSameIndividualAxiomGenerator extends InferredIndividualAxiomGenerator<OWLSameIndividualAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLNamedIndividual entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSameIndividualAxiom> resultAxiom) {\n\t\t\tfor (OWLNamedIndividual x : reasoner.getSameIndividuals(entity).getEntities()) {\n\t\t\t\tif (!entity.equals(x)) {\n\t\t\t\t\tresultAxiom.add(dataFactory.getOWLSameIndividualAxiom(entity, x));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"OWL:SameAs Inferences\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredEquivalentClassesAxiomGenerator\n\t\t\textends InferredClassAxiomGenerator<OWLEquivalentClassesAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLEquivalentClassesAxiom> resultAxiom) {\n\t\t\tSet<OWLClass> equivalentClasses = reasoner.getEquivalentClasses(entity).getEntities();", "\t\t\tif (equivalentClasses.size() > 1) {\n\t\t\t\tresultAxiom.add(dataFactory.getOWLEquivalentClassesAxiom(equivalentClasses));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getLabel() {\n\t\t\treturn \"owl:equivalentClass Inferences\";\n\t\t}\n\t}\n", "\tpublic class CustomInferredDifferentIndividualAxiomGenerator\n\t\t\textends InferredIndividualAxiomGenerator<OWLDifferentIndividualsAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLNamedIndividual entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLDifferentIndividualsAxiom> AxiomResult) {\n\t\t\tSet<OWLNamedIndividual> differentOWLNamedIndividual = reasoner.getDifferentIndividuals(entity).getFlattened();\n\t\t\tif (!differentOWLNamedIndividual.isEmpty()) {\n\t\t\t\tAxiomResult.add(dataFactory.getOWLDifferentIndividualsAxiom(\n\t\t\t\t\t\tStream.concat(Stream.of(entity), differentOWLNamedIndividual.stream()).toArray(OWLIndividual[]::new)));\n\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"Different individuals\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredIntersectionOfAxiomGenerator extends InferredClassAxiomGenerator<OWLEquivalentClassesAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLEquivalentClassesAxiom> resultAxiom) {\n\t\t\tNodeSet<OWLClass> SuperClasses = reasoner.getSuperClasses(entity, true);", "\t\t\tif (SuperClasses.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSet<OWLClassExpression> operands = new HashSet<>();\n\t\t\tfor (Node<OWLClass> superClassNode : SuperClasses.getNodes()) {\n\t\t\t\toperands.add(superClassNode.getRepresentativeElement());\n\t\t\t}\n\n\t\t\tif (operands.size() > 1) {\n\t\t\t\tOWLObjectIntersectionOf intersectionOf = dataFactory.getOWLObjectIntersectionOf(operands);\n\t\t\t\tOWLEquivalentClassesAxiom axiom = dataFactory.getOWLEquivalentClassesAxiom(entity, intersectionOf);\n\t\t\t\tresultAxiom.add(axiom);\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\t\tif (operands.size() > 1) {\n\t\t\t\tOWLObjectIntersectionOf intersectionOf = dataFactory.getOWLObjectIntersectionOf(operands);\n\t\t\t\tOWLEquivalentClassesAxiom axiom = dataFactory.getOWLEquivalentClassesAxiom(entity, intersectionOf);\n\t\t\t\tresultAxiom.add(axiom);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getLabel() {\n\t\t\treturn \"OWL:IntersectionOf Inference\";\n\t\t}\n\t}\n", "\t\tpublic String getLabel() {\n\t\t\treturn \"OWL:IntersectionOf Inference\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredUnionOfAxiomGenerator extends InferredClassAxiomGenerator<OWLSubClassOfAxiom> {\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSubClassOfAxiom> resultAxiom) {\n\t\t\tSet<OWLClass> SuperClasses = reasoner.getSuperClasses(entity, true).getFlattened();\n\t\t\tif (SuperClasses.size() > 1) {\n\t\t\t\tresultAxiom.add(\n\t\t\t\t\t\tdataFactory.getOWLSubClassOfAxiom(entity, dataFactory.getOWLObjectUnionOf(SuperClasses)));\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\t\tif (SuperClasses.size() > 1) {\n\t\t\t\tresultAxiom.add(\n\t\t\t\t\t\tdataFactory.getOWLSubClassOfAxiom(entity, dataFactory.getOWLObjectUnionOf(SuperClasses)));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getLabel() {\n\t\t\treturn \"OWL:UnionOf Inference\";\n\t\t}\n\t}\n", "\tpublic class CustomInferredDisjointClassesAxiomGenerator extends InferredClassAxiomGenerator<OWLDisjointClassesAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLDisjointClassesAxiom> resultAxiom) {\n\t\t\tSet<OWLClass> allClasses = reasoner.getRootOntology().getClassesInSignature();\n\t\t\tfor (OWLClass classe : allClasses) {\n\t\t\t\tif (!classe.equals(entity)) {\n\t\t\t\t\tNodeSet<OWLClass> disjointClasses = reasoner.getDisjointClasses(entity);\n\t\t\t\t\tif (disjointClasses.containsEntity(classe)) {\n\n\t\t\t\t\t\tSet<OWLClass> equivalentClasses1 = reasoner.getEquivalentClasses(entity).getEntities();\n\t\t\t\t\t\tSet<OWLClass> equivalentClasses2 = reasoner.getEquivalentClasses(classe).getEntities();", "\t\t\t\t\tif (disjointClasses.containsEntity(classe)) {\n\n\t\t\t\t\t\tSet<OWLClass> equivalentClasses1 = reasoner.getEquivalentClasses(entity).getEntities();\n\t\t\t\t\t\tSet<OWLClass> equivalentClasses2 = reasoner.getEquivalentClasses(classe).getEntities();\n\t\t\t\t\t\tfor (OWLClass loopEquivalentClass1 : equivalentClasses1) {\n\t\t\t\t\t\t\tfor (OWLClass loopEquivalentClass2 : equivalentClasses2) {\n\t\t\t\t\t\t\t\tif (!loopEquivalentClass1.equals(loopEquivalentClass2)) {\n\t\t\t\t\t\t\t\t\tresultAxiom.add(dataFactory.getOWLDisjointClassesAxiom(loopEquivalentClass1, loopEquivalentClass2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"OWL DisjointClasses\";\n\t\t}\n\t}\n\n\tpublic class InferredSomeValuesFromAxiomGenerator extends InferredClassAxiomGenerator<OWLSubClassOfAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass cls, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSubClassOfAxiom> result) {\n\t\t\tfor (OWLClassExpression superClass : reasoner.getEquivalentClasses(cls).getEntities()) {", "\t\t\tfor (OWLClassExpression superClass : reasoner.getEquivalentClasses(cls).getEntities()) {\n\t\t\t\tif (superClass.isAnonymous() && superClass instanceof OWLObjectSomeValuesFrom) {\n\t\t\t\t\tOWLObjectSomeValuesFrom someValuesFrom = (OWLObjectSomeValuesFrom) superClass;\n\t\t\t\t\tOWLClassExpression filler = someValuesFrom.getFiller();\n\t\t\t\t\tif (!filler.isAnonymous()) {\n\t\t\t\t\t\tOWLSubClassOfAxiom axiom = dataFactory.getOWLSubClassOfAxiom(cls, someValuesFrom);\n\t\t\t\t\t\tresult.add(axiom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Set<InferredAxiomGenerator<?>> getInferredAxiomGenerators() {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"Some values from\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredHasValueAxiomGenerator extends InferredClassAxiomGenerator<OWLSubClassOfAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass cls, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSubClassOfAxiom> resultAxiom) {\n\t\t\tfor (OWLClassExpression equivalentClass : reasoner.getEquivalentClasses(cls).getEntities()) {", "\t\t\tfor (OWLClassExpression equivalentClass : reasoner.getEquivalentClasses(cls).getEntities()) {\n\t\t\t\tif (equivalentClass.isAnonymous() && equivalentClass instanceof OWLObjectHasValue) {\n\t\t\t\t\tOWLObjectHasValue owlHasValue = (OWLObjectHasValue) equivalentClass;\n\t\t\t\t\tOWLSubClassOfAxiom axiom = dataFactory.getOWLSubClassOfAxiom(cls, owlHasValue);\n\t\t\t\t\tresultAxiom.add(axiom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Set<InferredAxiomGenerator<?>> getInferredAxiomGenerators() {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"Owl:hasValue Inferences\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredInverseObjectPropertiesAxiomGenerator\n\t\t\timplements InferredAxiomGenerator<OWLInverseObjectPropertiesAxiom> {\n\n\t\t@Override\n\t\tpublic Set<OWLInverseObjectPropertiesAxiom> createAxioms(OWLDataFactory dataFactory, OWLReasoner reasoner) {\n\t\t\tSet<OWLInverseObjectPropertiesAxiom> resultSet = new HashSet<>();", "\t\t\tfor (OWLObjectProperty objectProperty : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t\t\taddAxioms(objectProperty, reasoner, dataFactory, resultSet);\n\t\t\t}\n\t\t\treturn resultSet;\n\t\t}\n\n\t\tprotected void addAxioms(OWLObjectProperty entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLInverseObjectPropertiesAxiom> resultAxiom) {\n\t\t\tfor (OWLObjectPropertyExpression inverseAxiom : reasoner.getInverseObjectProperties(entity).getEntities()) {\n\t\t\t\tif (!inverseAxiom.equals(entity)) {\n\t\t\t\t\tresultAxiom.add(dataFactory.getOWLInverseObjectPropertiesAxiom(entity, inverseAxiom));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\t\tfor (OWLObjectPropertyExpression inverseAxiom : reasoner.getInverseObjectProperties(entity).getEntities()) {\n\t\t\t\tif (!inverseAxiom.equals(entity)) {\n\t\t\t\t\tresultAxiom.add(dataFactory.getOWLInverseObjectPropertiesAxiom(entity, inverseAxiom));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getLabel() {\n\t\t\treturn \"owl:InverseFunctionalProperty\";\n\t\t}\n\t}\n", "\t\tpublic String getLabel() {\n\t\t\treturn \"owl:InverseFunctionalProperty\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredAllValuesFromAxiomGenerator implements InferredAxiomGenerator<OWLSubClassOfAxiom> {\n\n\t\t@Override\n\t\tpublic Set<OWLSubClassOfAxiom> createAxioms(OWLDataFactory dataFactory, OWLReasoner reasoner) {\n\t\t\tSet<OWLSubClassOfAxiom> resultSet = new HashSet<>();\n\t\t\tfor (OWLClass owlClass : reasoner.getRootOntology().getClassesInSignature()) {\n\t\t\t\taddAxioms(owlClass, reasoner, dataFactory, resultSet);\n\t\t\t}\n\t\t\treturn resultSet;\n\t\t}\n\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSubClassOfAxiom> resultAxiom) {", "\t\t\tfor (OWLClass owlClass : reasoner.getRootOntology().getClassesInSignature()) {\n\t\t\t\taddAxioms(owlClass, reasoner, dataFactory, resultSet);\n\t\t\t}\n\t\t\treturn resultSet;\n\t\t}\n\n\t\tprotected void addAxioms(OWLClass entity, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t\t\tSet<OWLSubClassOfAxiom> resultAxiom) {\n\t\t\tfor (OWLObjectProperty objectProperty : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t\t\tNodeSet<OWLClass> possibleRanges = reasoner.getObjectPropertyRanges(objectProperty, true);\n\t\t\t\tif (!possibleRanges.isEmpty()) {\n\t\t\t\t\tOWLClassExpression owlAllValuesFrom = dataFactory.getOWLObjectAllValuesFrom(objectProperty,\n\t\t\t\t\t\t\tpossibleRanges.getFlattened().iterator().next());\n\t\t\t\t\tOWLSubClassOfAxiom axiom = dataFactory.getOWLSubClassOfAxiom(entity, owlAllValuesFrom);\n\t\t\t\t\tresultAxiom.add(axiom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\t\tfor (OWLObjectProperty objectProperty : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t\t\tNodeSet<OWLClass> possibleRanges = reasoner.getObjectPropertyRanges(objectProperty, true);\n\t\t\t\tif (!possibleRanges.isEmpty()) {\n\t\t\t\t\tOWLClassExpression owlAllValuesFrom = dataFactory.getOWLObjectAllValuesFrom(objectProperty,\n\t\t\t\t\t\t\tpossibleRanges.getFlattened().iterator().next());\n\t\t\t\t\tOWLSubClassOfAxiom axiom = dataFactory.getOWLSubClassOfAxiom(entity, owlAllValuesFrom);\n\t\t\t\t\tresultAxiom.add(axiom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"owl:allValuesFrom \";\n\t\t}\n\t}\n\n\tpublic class CustomInferredSameValueSomeValuesFromAxiomGenerator extends InferredClassAxiomGenerator<OWLSubClassOfAxiom> {\n\n\t\t@Override\n\t\tprotected void addAxioms(OWLClass entty, OWLReasoner reasoner, OWLDataFactory dataFactory,\n\t\t        Set<OWLSubClassOfAxiom> resultAxioms) {\n\t\t    for (OWLObjectProperty objectProperty : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t        NodeSet<OWLClass> possibleRanges = reasoner.getObjectPropertyRanges(objectProperty, true);", "\t\t    for (OWLObjectProperty objectProperty : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t        NodeSet<OWLClass> possibleRanges = reasoner.getObjectPropertyRanges(objectProperty, true);\n\t\t        if (!possibleRanges.isEmpty()) {\n\t\t            OWLClassExpression owlSomeValuesFromRslt = dataFactory.getOWLObjectSomeValuesFrom(objectProperty,\n\t\t                    possibleRanges.getFlattened().iterator().next());\n\t\t            OWLSubClassOfAxiom axiom = dataFactory.getOWLSubClassOfAxiom(entty, owlSomeValuesFromRslt);\n\t\t            resultAxioms.add(axiom);\n\t\t        }\n\t\t    }\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"owl:someValueFrom\";\n\t\t}\n\t}\n\n\tpublic class CustomInferredDomainAndRangeAxiomGenerator implements InferredAxiomGenerator<OWLObjectPropertyAxiom> {\n\n\t\t@Override\n\t\tpublic Set<OWLObjectPropertyAxiom> createAxioms(OWLDataFactory dataFactory, OWLReasoner reasoner) {\n\t\t\tSet<OWLObjectPropertyAxiom> resultSet = new HashSet<>();\n\t\t\t// Two loops to get inference from domain and range", "\t\t\tfor (OWLObjectProperty property : reasoner.getRootOntology().getObjectPropertiesInSignature()) {\n\t\t\t\tfor (OWLClass domainInf : reasoner.getObjectPropertyDomains(property, true).getFlattened()) {\n\t\t\t\t\tresultSet.add(dataFactory.getOWLObjectPropertyDomainAxiom(property, domainInf));\n\t\t\t\t}\n\t\t\t\tfor (OWLClass rangeInf : reasoner.getObjectPropertyRanges(property, true).getFlattened()) {\n\t\t\t\t\tresultSet.add(dataFactory.getOWLObjectPropertyRangeAxiom(property, rangeInf));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resultSet;\n\t\t}\n\n\t\t@Override", "\t\tpublic String getLabel() {\n\t\t\treturn \"Inference of Domain And Range\";\n\t\t}\n\t}\n\t\n\tpublic class CustomInferredComplementOfAxiomGenerator implements InferredAxiomGenerator<OWLClassAxiom> {\n\n\t    @Override\n\t    public Set<OWLClassAxiom> createAxioms(OWLDataFactory dataFactory, OWLReasoner reasoner) {\n\t        Set<OWLClassAxiom> resultSet = new HashSet<>();\n\n\t        Set<OWLClass> allClasses = reasoner.getRootOntology().getClassesInSignature();\n", "\t        for (OWLClass cls : allClasses) {\n\t            if (!reasoner.isSatisfiable(cls) && !cls.isOWLNothing()) {\n\t                NodeSet<OWLClass> disjointClasses = reasoner.getDisjointClasses(cls);\n\t                disjointClasses.getFlattened().forEach(disjointClass -> {\n\t                    OWLObjectComplementOf ObjectComplementOf = dataFactory.getOWLObjectComplementOf(disjointClass);\n\t                    OWLEquivalentClassesAxiom axiomEQ = dataFactory.getOWLEquivalentClassesAxiom(cls, ObjectComplementOf);\n\t                    resultSet.add(axiomEQ);\n\t                });\n\t            }\n\t        }\n\n\t        return resultSet;\n\t    }\n\n\t    @Override", "\t    public String getLabel() {\n\t        return \"complementOf\";\n\t    }\n\t}\n\n\tpublic class CustomInferredOntologyGenerator extends InferredOntologyGenerator {\n\n\t    public CustomInferredOntologyGenerator(OWLReasoner reasoner) {\n\t        super(reasoner);\n\t    }\n\t}\n\t\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/JenaService.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.util.List;\n\nimport com.souslesens.Jowl.model.jenaTripleParser;\n\npublic interface JenaService {\n\n\t\n\tList<jenaTripleParser> getTriples(String filePath, String Url,String ontologyContentEncoded64 );\n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/AlternativeReasonerService.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport org.springframework.web.multipart.MultipartFile;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.souslesens.Jowl.model.reasonerExtractTriples;", "import com.fasterxml.jackson.core.JsonProcessingException;\nimport com.souslesens.Jowl.model.reasonerExtractTriples;\n\n\npublic interface AlternativeReasonerService {\n\t\n\t\n    \n\t//Alternative\n    String getUnsatisfaisableClassesAlt(String filePath, String Url,MultipartFile ontologyFile) throws Exception;\n    String getConsistencyAlt(String filePath, String Url,MultipartFile ontologyFile) throws OWLOntologyCreationException, JsonProcessingException, Exception;\n    List<reasonerExtractTriples> getInferencesAlt(String filePath, String Url,MultipartFile ontologyFile) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t\n    \n    \n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/ReasonerService.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\n\npublic interface ReasonerService {\n\t\n\t// GET API METHODS\n    String getUnsatisfaisableClasses(String filePath, String Url) throws Exception;\n    String getConsistency(String filePath, String Url) throws OWLOntologyCreationException, JsonProcessingException, Exception;\n    String getInferences(String filePath, String Url) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t// POST API METHODS\n\t\n\tString postUnsatisfaisableClassesContent(String ontologyContentDecoded64) throws Exception;\n\t\n\tString postInferencesContent(String ontologyContentDecoded64, List<String> valuesList)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t\n\tString postConsistencyContent(String ontologyContentDecoded64)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception;\n\n\tString postInferences(String filePath, String url , List<String> valuesList)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t\n\tString postConsistency(String filePath, String Url)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception;\n\t\n\tString postUnsatisfaisableClasses( String filePath, String Url) throws Exception;\n    \n    \n}\n", "\n\npublic interface ReasonerService {\n\t\n\t// GET API METHODS\n    String getUnsatisfaisableClasses(String filePath, String Url) throws Exception;\n    String getConsistency(String filePath, String Url) throws OWLOntologyCreationException, JsonProcessingException, Exception;\n    String getInferences(String filePath, String Url) throws OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t// POST API METHODS\n\t\n\tString postUnsatisfaisableClassesContent(String ontologyContentDecoded64) throws Exception;\n\t\n\tString postInferencesContent(String ontologyContentDecoded64, List<String> valuesList)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t\n\tString postConsistencyContent(String ontologyContentDecoded64)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception;\n\n\tString postInferences(String filePath, String url , List<String> valuesList)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception;\n\t\n\tString postConsistency(String filePath, String Url)\n\t\t\tthrows OWLOntologyCreationException, JsonProcessingException, Exception;\n\t\n\tString postUnsatisfaisableClasses( String filePath, String Url) throws Exception;\n    \n    \n}\n"]}
{"filename": "src/main/java/com/souslesens/Jowl/services/SWRLServiceImpl.java", "chunked_list": ["package com.souslesens.Jowl.services;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;", "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.semanticweb.owlapi.apibinding.OWLManager;\nimport org.semanticweb.owlapi.io.OWLOntologyDocumentSource;\nimport org.semanticweb.owlapi.io.StreamDocumentSource;\nimport org.semanticweb.owlapi.model.AddAxiom;\nimport org.semanticweb.owlapi.model.IRI;", "import org.semanticweb.owlapi.model.AddAxiom;\nimport org.semanticweb.owlapi.model.IRI;\nimport org.semanticweb.owlapi.model.MissingImportHandlingStrategy;\nimport org.semanticweb.owlapi.model.OWLClass;\nimport org.semanticweb.owlapi.model.OWLClassAssertionAxiom;\nimport org.semanticweb.owlapi.model.OWLDataFactory;\nimport org.semanticweb.owlapi.model.OWLDataProperty;\nimport org.semanticweb.owlapi.model.OWLIndividual;\nimport org.semanticweb.owlapi.model.OWLLiteral;\nimport org.semanticweb.owlapi.model.OWLNamedIndividual;", "import org.semanticweb.owlapi.model.OWLLiteral;\nimport org.semanticweb.owlapi.model.OWLNamedIndividual;\nimport org.semanticweb.owlapi.model.OWLObjectProperty;\nimport org.semanticweb.owlapi.model.OWLOntology;\nimport org.semanticweb.owlapi.model.OWLOntologyCreationException;\nimport org.semanticweb.owlapi.model.OWLOntologyLoaderConfiguration;\nimport org.semanticweb.owlapi.model.OWLOntologyManager;\nimport org.semanticweb.owlapi.model.OWLOntologyStorageException;\nimport org.semanticweb.owlapi.model.SWRLAtom;\nimport org.semanticweb.owlapi.model.SWRLBuiltInAtom;", "import org.semanticweb.owlapi.model.SWRLAtom;\nimport org.semanticweb.owlapi.model.SWRLBuiltInAtom;\nimport org.semanticweb.owlapi.model.SWRLClassAtom;\nimport org.semanticweb.owlapi.model.SWRLDArgument;\nimport org.semanticweb.owlapi.model.SWRLDataPropertyAtom;\nimport org.semanticweb.owlapi.model.SWRLLiteralArgument;\nimport org.semanticweb.owlapi.model.SWRLObjectPropertyAtom;\nimport org.semanticweb.owlapi.model.SWRLRule;\nimport org.semanticweb.owlapi.model.SWRLVariable;\nimport org.semanticweb.owlapi.reasoner.InferenceType;", "import org.semanticweb.owlapi.model.SWRLVariable;\nimport org.semanticweb.owlapi.reasoner.InferenceType;\nimport org.semanticweb.owlapi.reasoner.NodeSet;\nimport org.semanticweb.owlapi.reasoner.Node;\nimport org.semanticweb.owlapi.reasoner.OWLReasoner;\nimport org.semanticweb.owlapi.vocab.SWRLBuiltInsVocabulary;\nimport org.springframework.stereotype.Service;\nimport com.clarkparsia.pellet.owlapiv3.PelletReasonerFactory;\nimport com.google.gson.Gson;\nimport com.souslesens.Jowl.model.SWRLTypeEntityVariable;", "import com.google.gson.Gson;\nimport com.souslesens.Jowl.model.SWRLTypeEntityVariable;\nimport com.souslesens.Jowl.model.SWRLVariables;\n@Service\n\npublic class SWRLServiceImpl implements SWRLService {\n\n\n\t@Override\n\tpublic String SWRLruleReclassification(String filePath, String url, String[] reqBodies , String[] reqHead) throws Exception {\n\t\ttry {\n\t\t\t\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;\n", "\tpublic String SWRLruleReclassification(String filePath, String url, String[] reqBodies , String[] reqHead) throws Exception {\n\t\ttry {\n\t\t\t\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;\n\n\t\tif (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\n\t\t\tontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));", "\t\tif (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\n\t\t\tontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));\n\t\t} else if (filePath.isEmpty() == false && url == null) {\n\n\t\t\tontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\t// BLOC //\n\t\t\n\t\t\t\t// RULE : N { BODY } (x) -> N { Head } (x)\n\n\t\t\t\tOWLDataFactory factory = manager.getOWLDataFactory();\n\t\t\t\tSWRLVariable var = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#x\"));\n\t\t\t\tSet<SWRLAtom> bodyList = new HashSet<>();", "\t\t\t\tfor (String bodies : reqBodies) {\n\t\t\t\t\t\n\t\t\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(bodies));\n\t\t\t\t\tSWRLClassAtom bodyElement = factory.getSWRLClassAtom(classX, var);\n\t\t\t\t\tbodyList.add(bodyElement);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tSet<OWLClass> classes = new HashSet<>();\n\t\t\t\tSet<SWRLAtom> headList = new HashSet<>();\n\t\t\t\tfor (String headies : reqHead) {\n\t\t\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(headies));\n\t\t\t\t\tclasses.add(classX);\n\t\t\t\t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, var);\n\t\t\t\t\theadList.add(headElement);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\t\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t\t\tmanager.applyChange(addAxiom);\n\t\t\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\t\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t\t\treasoner.precomputeInferences(InferenceType.values());\n\n\t\t        Map<String, Set<String>> instances = new HashMap<>();", "\t\t\t\tfor (String headies : reqHead) {\n\t\t\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(headies));\n\t\t\t\t\tclasses.add(classX);\n\t\t\t\t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, var);\n\t\t\t\t\theadList.add(headElement);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\t\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t\t\tmanager.applyChange(addAxiom);\n\t\t\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\t\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t\t\treasoner.precomputeInferences(InferenceType.values());\n\n\t\t        Map<String, Set<String>> instances = new HashMap<>();", "\t\t\t\tfor (OWLClass cls : classes) {\n\t\t\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false); // false = only inferred\n\t\t            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {\n\t\t                for (OWLNamedIndividual individual : individualNode) {\n\t\t                \tSystem.out.println(individual.getIRI().getFragment() + \" is an instance of \" + cls.getIRI().getFragment());\n\t\t                \tinstances.computeIfAbsent(individual.getIRI().toString(), k -> new HashSet<>()).add(cls.getIRI().toString());\n\t\t                }\n\t\t            }\n\t\t\t\t}\n\t\t\t\t Gson gson = new Gson();\n\t\t         String json = gson.toJson(instances);\n\t\t\t\t return json;\n\t\t\t}catch (OWLOntologyCreationException e){\n\t\t\t\tGson gson = new Gson();\n\t\t\t\tString json = gson.toJson(e);\n\t\t\t\treturn json;\n\t\t\t}\n\t\t\n\t}\n\n\t@Override", "\tpublic String SWRLruleReclassificationB64(String ontologyContentDecoded64 ,  String[] reqBodies , String[] reqHead)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t\ttry {\n\t\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t\t//set silent imports\n\t\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\t\tOWLOntology ontology = null;\n\t\t\tSystem.out.println(instream.toString().isEmpty() == false);", "\t\t\tif (instream.available() > 0) {\n\t\t\t\tOWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t\t\tontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t\t}\n\t\t// RULE : N { BODY } (x) -> N { Head } (x)\n\n\t\tOWLDataFactory factory = manager.getOWLDataFactory();\n\t\t// Create SWRL Variable for classification\n\t\tSWRLVariable var = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#x\"));\n\t\tSet<SWRLAtom> bodyList = new HashSet<>();\n\t\tfor (String bodies : reqBodies) {\n\t\t\t\n\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(bodies));\n\t\t\tSWRLClassAtom bodyElement = factory.getSWRLClassAtom(classX, var);\n\t\t\tbodyList.add(bodyElement);\n\t\t\t\n\t\t}\n\t\tSet<OWLClass> classes = new HashSet<>();\n\t\tSet<SWRLAtom> headList = new HashSet<>();", "\t\tfor (String bodies : reqBodies) {\n\t\t\t\n\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(bodies));\n\t\t\tSWRLClassAtom bodyElement = factory.getSWRLClassAtom(classX, var);\n\t\t\tbodyList.add(bodyElement);\n\t\t\t\n\t\t}\n\t\tSet<OWLClass> classes = new HashSet<>();\n\t\tSet<SWRLAtom> headList = new HashSet<>();\n\t\tfor (String headies : reqHead) {\n\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(headies));\n\t\t\tclasses.add(classX);\n\t\t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, var);\n\t\t\theadList.add(headElement);\n\t\t\t\n\t\t}\n\t\t\n\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\tmanager.applyChange(addAxiom);\n\n\t\t// Creation reasoner \n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t//\n\t\t// Computing inferences\n\t\treasoner.precomputeInferences(InferenceType.values());\n\n        Map<String, Set<String>> instances = new HashMap<>();", "\t\tfor (String headies : reqHead) {\n\t\t\tOWLClass classX = factory.getOWLClass(IRI.create(headies));\n\t\t\tclasses.add(classX);\n\t\t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, var);\n\t\t\theadList.add(headElement);\n\t\t\t\n\t\t}\n\t\t\n\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\tmanager.applyChange(addAxiom);\n\n\t\t// Creation reasoner \n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t//\n\t\t// Computing inferences\n\t\treasoner.precomputeInferences(InferenceType.values());\n\n        Map<String, Set<String>> instances = new HashMap<>();", "\t\tfor (OWLClass cls : classes) {\n\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false);\n            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {\n                for (OWLNamedIndividual individual : individualNode) {\n                \tSystem.out.println(individual.getIRI().getFragment() + \" is an instance of \" + cls.getIRI().getFragment());\n                \tinstances.computeIfAbsent(individual.getIRI().toString(), k -> new HashSet<>()).add(cls.getIRI().toString());\n                }\n            }\n\t\t}\n\t\t Gson gson = new Gson();\n         String json = gson.toJson(instances);\n\t\t return json;\n\t}catch (OWLOntologyCreationException e){\n\t\tGson gson = new Gson();\n\t\tString json = gson.toJson(e);\n\t\treturn json;\n\t}\n\n\n\t}\n\t\n\t@Override", "\tpublic String SWRLruleVAB64(String ontologyContentDecoded64 , List<SWRLTypeEntityVariable> reqBodies , List<SWRLTypeEntityVariable> reqHead)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t\ttry {\n\t\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\t\tInputStream instream = new ByteArrayInputStream(ontologyContentDecoded64.getBytes());\n\t\t\t//set silent imports\n\t\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\t\tOWLOntology ontology = null;\n\t\t\tif (instream.available() > 0) {\n\t\t\t\tOWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t\t\tontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t\t}\n\n\t\t// RULE : N { BODY } (x) || N { BODY } (x,y) -> N { Head } (x) || N { BODY } (x,y)\n\n\t\t\tOWLDataFactory factory = manager.getOWLDataFactory();\n\t\t\tSet<SWRLAtom> bodyList = new HashSet<>();\n\t\t", "\t\t\tif (instream.available() > 0) {\n\t\t\t\tOWLOntologyDocumentSource documentSource = new StreamDocumentSource(instream);\n\t\t\t\tontology = manager.loadOntologyFromOntologyDocument(documentSource);\n\t\t\t}\n\n\t\t// RULE : N { BODY } (x) || N { BODY } (x,y) -> N { Head } (x) || N { BODY } (x,y)\n\n\t\t\tOWLDataFactory factory = manager.getOWLDataFactory();\n\t\t\tSet<SWRLAtom> bodyList = new HashSet<>();\n\t\t\n\t    \tfor (SWRLTypeEntityVariable swrlVariable1 : reqBodies) {", "\t    \tfor (SWRLTypeEntityVariable swrlVariable1 : reqBodies) {\n\t    \t    if( swrlVariable1.getType().equalsIgnoreCase(\"owl:Class\")){\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\tOWLClass classX =factory.getOWLClass(IRI.create(entity.getName()));\n\t    \t    \t\t String[] variables = entity.getVar();\n\t    \t    \t\t String[] literals = entity.getLiteral();\n\t    \t    \t        for (String table : variables ) {\n\t    \t    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));\n\t    \t    \t        \t\tSWRLClassAtom bodyElement = factory.getSWRLClassAtom(classX, swrlVar);\n\t    \t    \t        \t\tbodyList.add(bodyElement);\n\t    \t    \t        }\n\t    \t    \t}", "\t    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:ObjectProperty\")) {\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\tOWLObjectProperty ObjectPropertyX =factory.getOWLObjectProperty(IRI.create(entity.getName()));\n\t   \t    \t\t String[] variables = entity.getVar();\n\t\t    \t        if (variables.length != 2) {\n\t\t    \t            throw new IllegalArgumentException(\"The variable list must contains Variable\");\n\t\t    \t        }\n\t\t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t\t    \t            String variable1 = variables[v];\n\t\t    \t            String variable2 = variables[v + 1];\n\t\t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t\t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t\t    \t            SWRLObjectPropertyAtom bodyElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n\t\t    \t            bodyList.add(bodyElement);\n\t\t    \t        }\n\t    \t    \t}", "\t    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:DataProperty\")) {\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\tOWLDataProperty dataPropertyVar = factory.getOWLDataProperty(IRI.create(entity.getName()));\n\t   \t    \t\t String[] variables = entity.getVar();\n\t\t    \t        if (variables.length != 2) {\n\t\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t\t    \t        }\n\t\t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t\t    \t            String variable1 = variables[v];\n\t\t    \t            String variable2 = variables[v + 1];    \t            \n\t\t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t\t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t\t    \t            SWRLDataPropertyAtom  bodyElement = factory.getSWRLDataPropertyAtom(dataPropertyVar, swrlVar1, swrlVar2);\n\t\t    \t            System.out.println(bodyElement);\n\t\t    \t            bodyList.add(bodyElement);\n\t\t    \t        }\n\t    \t    \t}", "\t    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"swrlb:compare\")) {\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\t\n\t   \t    \t\t String[] variables = entity.getVar();\n\t   \t    \t\t String[] literal = entity.getLiteral();\n\t   \t    \t\t \n\t\t    \t        if (variables.length != 1) {\n\t\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t\t    \t        }\n\t\t    \t        if (literal.length != 1) {\n\t\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t\t    \t        }", "\t\t    \t        if (literal.length != 1) {\n\t\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t\t    \t        }\n\t\t    \t        for (String table : variables ) {\n\t\t    \t        \tSystem.out.println(\"gregerg\"+table);\n\t    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));   \t        \t\t\n\t\t    \t        \tfor (String Lit : literal) {\n\t\t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n\t\t    \t        \t\tOWLLiteral LitVar;\n\t\t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n\t\t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n\t\t    \t        \t\t\tSystem.out.println(covertedValue);\n\t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}", "\t\t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n\t\t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n\t\t    \t        \t\t\tSystem.out.println(covertedValue);\n\t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n\t\t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t\t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n\t\t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t\t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t\t    \t        \t\t\t}\n\t\t    \t        \t\t\t\n\t\t    \t        \t\t\telse {\n\t\t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n\t\t    \t        \t\t}\n\t\t    \t        \t\t\n\t\t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t\t    \t        \t\tList<SWRLDArgument> arguments = Arrays.asList(swrlVar, LitVarArg);    \t  \n\t\t    \t        \t\tSWRLBuiltInAtom bodyElement = null;", "\t\t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"greaterThanOrEqual\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.GREATER_THAN_OR_EQUAL.getIRI(), arguments);\n\t\t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"lessThanOrEqual\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.LESS_THAN_OR_EQUAL.getIRI(), arguments);\n\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"greaterThan\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.GREATER_THAN.getIRI(), arguments);\t\n\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"lessThan\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.LESS_THAN.getIRI(), arguments);\t\t\n\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"equal\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.EQUAL.getIRI(), arguments);\t\n\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"notEqual\")) {\n\t\t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.NOT_EQUAL.getIRI(), arguments);\t\n\t\t    \t        \t\t}\n\t\t    \t        \t\t System.out.println(bodyElement);\n\t\t    \t        \t\tbodyList.add(bodyElement);\n\t\t    \t        \t}\n\t\t    \t        \t\n\t    \t        \t\t\n\t\t    \t        }\n\t    \t    \t}", "\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"equal\")) {\n\t\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.EQUAL.getIRI(), arguments);\t\n\t\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"notEqual\")) {\n\t\t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.NOT_EQUAL.getIRI(), arguments);\t\n\t\t    \t        \t\t}\n\t\t    \t        \t\t System.out.println(bodyElement);\n\t\t    \t        \t\tbodyList.add(bodyElement);\n\t\t    \t        \t}\n\t\t    \t        \t\n\t    \t        \t\t\n\t\t    \t        }\n\t    \t    \t}", "\t    \t    }else if(swrlVariable1.getType().equalsIgnoreCase(\"swrlb:string\")) {\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\t\n\t      \t    \t\t String[] variables = entity.getVar();\n\t      \t    \t\t String[] literal = entity.getLiteral();\n\t      \t    \t\t \n\t   \t    \t        if (variables.length != 1) {\n\t   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t   \t    \t        }\n//\t   \t    \t        if (literal.length != 1) {\n//\t   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n//\t   \t    \t        }\n\t   \t    \t        ", "//\t   \t    \t        if (literal.length != 1) {\n//\t   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n//\t   \t    \t        }\n\t   \t    \t        \n\t   \t    \t        for (String table : variables ) {\n\t   \t    \t        \tSystem.out.println(\"gregerg\"+table);\n\t       \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));   \t        \t\t\n\t       \t        \t\tSWRLBuiltInAtom bodyElement = null;\n\t       \t        \t\tif(literal.length == 1){\n\t       \t        \t\tfor (String Lit : literal) {\n\t   \t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n\t   \t    \t        \t\tOWLLiteral LitVar;", "\t       \t        \t\tif(literal.length == 1){\n\t       \t        \t\tfor (String Lit : literal) {\n\t   \t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n\t   \t    \t        \t\tOWLLiteral LitVar;\n\t   \t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n\t   \t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n\t   \t    \t        \t\t\tSystem.out.println(covertedValue);\n\t   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n\t   \t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n\t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t    \t        \t\t\t}\n\t   \t    \t        \t\t\t\n\t   \t    \t        \t\t\telse {\n\t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n\t   \t    \t        \t\t}\n\t   \t    \t        \t\tSystem.out.println(\"ya VIPER\"+LitVar);\n\t   \t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t    \t        \t\tSystem.out.println(\"WTFMAN\"+LitVarArg);\n\t   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar, LitVarArg));    \t    \t    \t        \t\t", "\t   \t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n\t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t    \t        \t\t\t}\n\t   \t    \t        \t\t\t\n\t   \t    \t        \t\t\telse {\n\t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n\t   \t    \t        \t\t}\n\t   \t    \t        \t\tSystem.out.println(\"ya VIPER\"+LitVar);\n\t   \t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t    \t        \t\tSystem.out.println(\"WTFMAN\"+LitVarArg);\n\t   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar, LitVarArg));    \t    \t    \t        \t\t", "\t   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"contains\")) {\n\t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.CONTAINS.getIRI(), arguments);\n\t   \t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"containsIgnoreCase\")) {\n\t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.CONTAINS_IGNORE_CASE.getIRI(), arguments);\n\t   \t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"startsWith\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.STARTS_WITH.getIRI(), arguments);\n\t   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"endsWith\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.ENDS_WITH.getIRI(), arguments);\n\t   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"matches\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#matches\")), arguments);\n\t   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"stringEqualIgnoreCase\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_EQUALS_IGNORE_CASE.getIRI()), arguments);", "\t   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"matches\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#matches\")), arguments);\n\t   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"stringEqualIgnoreCase\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_EQUALS_IGNORE_CASE.getIRI()), arguments);\n\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"upperCase\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#upperCase\")), arguments);\n\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"lowerCase\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.LOWER_CASE.getIRI()), arguments);\n\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"stringLength\")) {\t\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_LENGTH.getIRI()) , arguments);\n\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"normalizeSpace\")) {\t\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.NORMALIZE_SPACE.getIRI()) , arguments);\n\t   \t   \t    \t        \t}\n\t       \t        \t\t}", "\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"stringLength\")) {\t\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_LENGTH.getIRI()) , arguments);\n\t   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"normalizeSpace\")) {\t\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.NORMALIZE_SPACE.getIRI()) , arguments);\n\t   \t   \t    \t        \t}\n\t       \t        \t\t}\n//\t   \t   \t    \t        \telse if(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n//\t   \t   \t    \t        \tOWLLiteral LitVar1 = factory.getOWLLiteral(\"ine\");\n//\t   \t   \t    \t        \tSWRLLiteralArgument LitVarArg1 = factory.getSWRLLiteralArgument(LitVar1);\n//\t   \t   \t    \t        \targuments.add(LitVarArg1);\n//\t   \t   \t    \t        \tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n//\t   \t   \t    \t        \t}\n\t   \t    \t        \t\tSystem.out.println(bodyElement);\n\t   \t    \t        \t\tbodyList.add(bodyElement);", "\t   \t    \t        \t}else if(literal.length == 2) {\n\t   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n\t   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));\n\t   \t    \t        \t\tfor (int i = 0; i < literal.length; i++) {\n\t   \t    \t        \t\t\tOWLLiteral LitVar;\n\t   \t   \t    \t        \t\tif(literal[i].matches(\"\\\\d+\")) {\n\t   \t   \t    \t        \t\t\tint covertedValue = Integer.parseInt(literal[i]);\n\t   \t   \t    \t        \t\t\tSystem.out.println(covertedValue);\n\t   \t   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n\t   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n\t   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t   \t    \t        \t\t\t}\n\t   \t   \t    \t        \t\t\t\n\t   \t   \t    \t        \t\t\telse {\n\t   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\tSystem.out.println(LitVar);\n\t   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n\t   \t   \t    \t        \t\t\n\t   \t   \t    \t        \t\targuments.add(LitVarArg);\n\t   \t   \t    \t        \t\tSystem.out.println(arguments);", "\t   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n\t   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t   \t    \t        \t\t\t}\n\t   \t   \t    \t        \t\t\t\n\t   \t   \t    \t        \t\t\telse {\n\t   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\tSystem.out.println(LitVar);\n\t   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n\t   \t   \t    \t        \t\t\n\t   \t   \t    \t        \t\targuments.add(LitVarArg);\n\t   \t   \t    \t        \t\tSystem.out.println(arguments);", "\t   \t   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substring\")) {\n\t   \t   \t    \t        \t\t\n\t   \t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING.getIRI()) , arguments);\n\t   \t   \t   \t    \t        \t\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"tokenize\")) {\n\t   \t   \t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.TOKENIZE.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringBefore\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_BEFORE.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringAfter\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_AFTER.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t\t}\n\t   \t    \t        \t\tSystem.out.println(bodyElement);\n\t   \t    \t        \t\tbodyList.add(bodyElement);", "\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringBefore\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_BEFORE.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringAfter\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_AFTER.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t\t}\n\t   \t    \t        \t\tSystem.out.println(bodyElement);\n\t   \t    \t        \t\tbodyList.add(bodyElement);\n\t   \t    \t        \t}else if(literal.length > 2) {\n\t   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n\t   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));", "\t   \t    \t        \t}else if(literal.length > 2) {\n\t   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n\t   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));\n\t   \t    \t        \t\tfor (int i = 0; i < literal.length; i++) {\n\t   \t    \t        \t\t\tOWLLiteral LitVar;\n\t   \t   \t    \t        \t\tif(literal[i].matches(\"\\\\d+\")) {\n\t   \t   \t    \t        \t\t\tint covertedValue = Integer.parseInt(literal[i]);\n\t   \t   \t    \t        \t\t\tSystem.out.println(covertedValue);\n\t   \t   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n\t   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n\t   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t   \t    \t        \t\t\t}\n\t   \t   \t    \t        \t\t\t\n\t   \t   \t    \t        \t\t\telse {\n\t   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\tSystem.out.println(LitVar);\n\t   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n\t   \t   \t    \t        \t\t\n\t   \t   \t    \t        \t\targuments.add(LitVarArg);\n\t   \t   \t    \t        \t\tSystem.out.println(arguments);", "\t   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n\t   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t   \t   \t    \t        \t\t\t}\n\t   \t   \t    \t        \t\t\t\n\t   \t   \t    \t        \t\t\telse {\n\t   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\tSystem.out.println(LitVar);\n\t   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n\t   \t   \t    \t        \t\t\n\t   \t   \t    \t        \t\targuments.add(LitVarArg);\n\t   \t   \t    \t        \t\tSystem.out.println(arguments);", "\t   \t   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substring\")) {\n\t   \t   \t   \t    \t        \tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING.getIRI()) , arguments); \t   \t    \t        \t\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"replace\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.REPLACE.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"translate\")) {\n\t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.TRANSLATE.getIRI()) , arguments);\n\t   \t   \t    \t        \t\t}\n\t   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t\t}\n\t   \t    \t        \t\tSystem.out.println(bodyElement);\n\t   \t    \t        \t\tbodyList.add(bodyElement);\n\t   \t    \t        \t}\n\t   \t    \t        \t\n\t       \t        \t\t\n\t   \t    \t        }\n\t       \t    \t}\n\t    \t    }\n\t    \t    System.out.println();\n\t    \t}\n\t\t\t\n\t\t\tSet<OWLClass> classes = new HashSet<>();\n\t\t\tSet<OWLObjectProperty> objectproperties = new HashSet<>();\n\t\t\tSet<SWRLAtom> headList = new HashSet<>();", "\t    \tfor (SWRLTypeEntityVariable swrlVariable1 : reqHead) {\n\t    \t    if( swrlVariable1.getType().equalsIgnoreCase(\"owl:Class\")){\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\tOWLClass classX =factory.getOWLClass(IRI.create(entity.getName()));\n\t    \t    \t\tclasses.add(classX);\n\t   \t    \t\t String[] variables = entity.getVar();\n\t\t    \t        for (String table : variables ) {\n\t\t    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));\n\t\t    \t        \t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, swrlVar);\n\t\t    \t        \t\theadList.add(headElement);\n\t\t    \t        }\n\t    \t    \t}", "\t    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:ObjectProperty\")) {\n\t    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n\t    \t    \t\tOWLObjectProperty ObjectPropertyX =factory.getOWLObjectProperty(IRI.create(entity.getName()));\n\t    \t    \t\tobjectproperties.add(ObjectPropertyX);\n\t    \t    \t\t String[] variables = entity.getVar();\n\t    \t    \t        if (variables.length != 2) {\n\t    \t    \t            throw new IllegalArgumentException(\"The variable list must contain an even number of elements\");\n\t    \t    \t        }\n\t    \t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t    \t    \t            String variable1 = variables[v];\n\t    \t    \t            String variable2 = variables[v + 1];\n\t    \t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t    \t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t    \t    \t            SWRLObjectPropertyAtom headElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n\t    \t    \t            headList.add(headElement);\n\t    \t    \t        }\n\t    \t    \t}\n\t    \t    }\n\t    \t    System.out.println();\n\t    \t}\n\t\t\t\n\t\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t\t// Add SWRL rule to ontology\n\t\t\tmanager.applyChange(addAxiom);\n\n\t\t\t// Creation reasoner \n\t\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t\t//\n\t\t\t// Computing inferences\n\t\t\treasoner.precomputeInferences(InferenceType.values());\n\t\t\t// Print out inferred instances", "\t    \t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t    \t    \t            String variable1 = variables[v];\n\t    \t    \t            String variable2 = variables[v + 1];\n\t    \t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t    \t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t    \t    \t            SWRLObjectPropertyAtom headElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n\t    \t    \t            headList.add(headElement);\n\t    \t    \t        }\n\t    \t    \t}\n\t    \t    }\n\t    \t    System.out.println();\n\t    \t}\n\t\t\t\n\t\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t\t// Add SWRL rule to ontology\n\t\t\tmanager.applyChange(addAxiom);\n\n\t\t\t// Creation reasoner \n\t\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t\t//\n\t\t\t// Computing inferences\n\t\t\treasoner.precomputeInferences(InferenceType.values());\n\t\t\t// Print out inferred instances", "\t\t\tfor (OWLClass owlClass : classes) {\n\t\t\t\t\n\t\t\t    Set<OWLIndividual> assertedInstances = new HashSet<>();\n\t\t\t    for (OWLClassAssertionAxiom axiom : ontology.getClassAssertionAxioms(owlClass)) {\n\t\t\t        assertedInstances.add(axiom.getIndividual());\n\t\t\t    }\n\t\t\t\t\n\t\t\t    NodeSet<OWLNamedIndividual> allInstances  = reasoner.getInstances(owlClass, false);\n\t\t\t    \n\t\t\t    Set<OWLNamedIndividual> inferredInstances = allInstances.getFlattened();\n\t\t\t    inferredInstances.removeAll(assertedInstances);\n\t\t\t    ", "\t\t\t    for (OWLNamedIndividual inferredInstance  : inferredInstances) {\n\t\t\t        System.out.println(inferredInstance + \" is an instance of \" + owlClass);\n\t\t\t    }\n\t\t\t}\n\t\t\tMap<String, Set<String>> propertyValues = new HashMap<>();\n\t\t\tfor (OWLObjectProperty objectproperty : objectproperties) {\n\t\t\t    for (OWLNamedIndividual individual : ontology.getIndividualsInSignature()) {\n\t\t\t        NodeSet<OWLNamedIndividual> objectPropertyValues = reasoner.getObjectPropertyValues(individual, objectproperty);\n\n\t\t\t        // If there are any values, add them to the map\n\t\t\t        for (OWLNamedIndividual value : objectPropertyValues.getFlattened()) {\n\t\t\t            String key = individual.getIRI().toString();\n\t\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(objectproperty.getIRI().toString());\n\t\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(value.getIRI().toString() );\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t        Map<String, Set<String>> instances = new HashMap<>();", "\t\t\t        for (OWLNamedIndividual value : objectPropertyValues.getFlattened()) {\n\t\t\t            String key = individual.getIRI().toString();\n\t\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(objectproperty.getIRI().toString());\n\t\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(value.getIRI().toString() );\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t        Map<String, Set<String>> instances = new HashMap<>();\n\t\t\tfor (OWLClass cls : classes) {\n\t\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false); // false = only inferred\n\t            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {", "\t\t\tfor (OWLClass cls : classes) {\n\t\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false); // false = only inferred\n\t            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {\n\t                for (OWLNamedIndividual individual : individualNode) {\n\t                \tinstances.computeIfAbsent(individual.getIRI().toString(), k -> new HashSet<>()).add(cls.getIRI().toString());\n\t                }\n\t            }\n\t\t\t}\n\t\t\tMap<String, Map<String, Set<String>>> finalMap = new HashMap<>();\n\t\t\tfinalMap.put(\"class\", instances);\n\t\t\tfinalMap.put(\"objectProperty\", propertyValues);\n\t\t\t Gson gson = new Gson();\n\t         String json = gson.toJson(finalMap);\n\t\t\t return json;\n\t\t}catch (OWLOntologyCreationException e){\n\t\t\tGson gson = new Gson();\n\t\t\tString json = gson.toJson(e);\n\t\t\treturn json;\n\t\t}\n\n\n\t\t}\n\n\t@Override", "\tpublic String SWRLruleVABUF(String filePath, String url, List<SWRLTypeEntityVariable> reqBodies,\n\t\t\tList<SWRLTypeEntityVariable> reqHead)\n\t\t\tthrows OWLOntologyCreationException, OWLOntologyStorageException, IOException, Exception {\n\t\ttry {\n\t\t\t\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\t//set silent imports\n\t\tOWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();\n\t\tconfig = config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tmanager.setOntologyLoaderConfiguration(config);\n\t\tOWLOntology ontology = null;\n", "\t\tif (filePath == null && url.isEmpty() == false && (url.startsWith(\"http\") || url.startsWith(\"ftp\"))) {\n\n\t\t\tontology = manager.loadOntologyFromOntologyDocument(IRI.create(url));\n\t\t} else if (filePath.isEmpty() == false && url == null) {\n\n\t\t\tontology = manager.loadOntologyFromOntologyDocument(new File(filePath));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\t// RULE : N { BODY } (x) || N { BODY } (x,y) -> N { Head } (x) || N { BODY } (x,y)\n\n\t\tOWLDataFactory factory = manager.getOWLDataFactory();\n\t\tSet<SWRLAtom> bodyList = new HashSet<>();\n\t", "    \tfor (SWRLTypeEntityVariable swrlVariable1 : reqBodies) {\n    \t    if( swrlVariable1.getType().equalsIgnoreCase(\"owl:Class\")){\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\tOWLClass classX =factory.getOWLClass(IRI.create(entity.getName()));\n    \t    \t\t String[] variables = entity.getVar();\n    \t    \t\t String[] literals = entity.getLiteral();\n    \t    \t        for (String table : variables ) {\n    \t    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));\n    \t    \t        \t\tSWRLClassAtom bodyElement = factory.getSWRLClassAtom(classX, swrlVar);\n    \t    \t        \t\tbodyList.add(bodyElement);\n    \t    \t        }\n    \t    \t}", "    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:ObjectProperty\")) {\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\tOWLObjectProperty ObjectPropertyX =factory.getOWLObjectProperty(IRI.create(entity.getName()));\n   \t    \t\t String[] variables = entity.getVar();\n\t    \t        if (variables.length != 2) {\n\t    \t            throw new IllegalArgumentException(\"The variable list must contains Variable\");\n\t    \t        }\n\t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t    \t            String variable1 = variables[v];\n\t    \t            String variable2 = variables[v + 1];\n\t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t    \t            SWRLObjectPropertyAtom bodyElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n\t    \t            bodyList.add(bodyElement);\n\t    \t        }\n    \t    \t}", "    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:DataProperty\")) {\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\tOWLDataProperty dataPropertyVar = factory.getOWLDataProperty(IRI.create(entity.getName()));\n   \t    \t\t String[] variables = entity.getVar();\n\t    \t        if (variables.length != 2) {\n\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t    \t        }\n\t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n\t    \t            String variable1 = variables[v];\n\t    \t            String variable2 = variables[v + 1];    \t            \n\t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n\t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n\t    \t            SWRLDataPropertyAtom  bodyElement = factory.getSWRLDataPropertyAtom(dataPropertyVar, swrlVar1, swrlVar2);\n\t    \t            System.out.println(bodyElement);\n\t    \t            bodyList.add(bodyElement);\n\t    \t        }\n    \t    \t}", "    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"swrlb:compare\")) {\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\t\n   \t    \t\t String[] variables = entity.getVar();\n   \t    \t\t String[] literal = entity.getLiteral();\n   \t    \t\t \n\t    \t        if (variables.length != 1) {\n\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t    \t        }\n\t    \t        if (literal.length != 1) {\n\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t    \t        }", "\t    \t        if (literal.length != 1) {\n\t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n\t    \t        }\n\t    \t        for (String table : variables ) {\n\t    \t        \tSystem.out.println(\"gregerg\"+table);\n    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));   \t        \t\t\n\t    \t        \tfor (String Lit : literal) {\n\t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n\t    \t        \t\tOWLLiteral LitVar;\n\t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n\t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n\t    \t        \t\t\tSystem.out.println(covertedValue);\n\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}", "\t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n\t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n\t    \t        \t\t\tSystem.out.println(covertedValue);\n\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n\t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n\t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n\t    \t        \t\t\t\tSystem.out.println(covertedValue);\n\t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n\t    \t        \t\t\t}\n\t    \t        \t\t\t\n\t    \t        \t\t\telse {\n\t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n\t    \t        \t\t}\n\t    \t        \t\t\n\t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n\t    \t        \t\tList<SWRLDArgument> arguments = Arrays.asList(swrlVar, LitVarArg);    \t  \n\t    \t        \t\tSWRLBuiltInAtom bodyElement = null;", "\t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"greaterThanOrEqual\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.GREATER_THAN_OR_EQUAL.getIRI(), arguments);\n\t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"lessThanOrEqual\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.LESS_THAN_OR_EQUAL.getIRI(), arguments);\n\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"greaterThan\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.GREATER_THAN.getIRI(), arguments);\t\n\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"lessThan\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.LESS_THAN.getIRI(), arguments);\t\t\n\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"equal\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.EQUAL.getIRI(), arguments);\t\n\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"notEqual\")) {\n\t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.NOT_EQUAL.getIRI(), arguments);\t\n\t    \t        \t\t}\n\t    \t        \t\t System.out.println(bodyElement);\n\t    \t        \t\tbodyList.add(bodyElement);\n\t    \t        \t}\n\t    \t        \t\n    \t        \t\t\n\t    \t        }\n    \t    \t}", "\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"equal\")) {\n\t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.EQUAL.getIRI(), arguments);\t\n\t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"notEqual\")) {\n\t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.NOT_EQUAL.getIRI(), arguments);\t\n\t    \t        \t\t}\n\t    \t        \t\t System.out.println(bodyElement);\n\t    \t        \t\tbodyList.add(bodyElement);\n\t    \t        \t}\n\t    \t        \t\n    \t        \t\t\n\t    \t        }\n    \t    \t}", "    \t    }else if(swrlVariable1.getType().equalsIgnoreCase(\"swrlb:string\")) {\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\t\n      \t    \t\t String[] variables = entity.getVar();\n      \t    \t\t String[] literal = entity.getLiteral();\n      \t    \t\t \n   \t    \t        if (variables.length != 1) {\n   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n   \t    \t        }\n//   \t    \t        if (literal.length != 1) {\n//   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n//   \t    \t        }\n   \t    \t        ", "//   \t    \t        if (literal.length != 1) {\n//   \t    \t            throw new IllegalArgumentException(\"The variable list must contains 2 arguemts\");\n//   \t    \t        }\n   \t    \t        \n   \t    \t        for (String table : variables ) {\n   \t    \t        \tSystem.out.println(\"gregerg\"+table);\n       \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));   \t        \t\t\n       \t        \t\tSWRLBuiltInAtom bodyElement = null;\n       \t        \t\tif(literal.length == 1){\n       \t        \t\tfor (String Lit : literal) {\n   \t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n   \t    \t        \t\tOWLLiteral LitVar;", "       \t        \t\tif(literal.length == 1){\n       \t        \t\tfor (String Lit : literal) {\n   \t    \t        \t\tSystem.out.println(\"gregerg\"+Lit);\n   \t    \t        \t\tOWLLiteral LitVar;\n   \t    \t        \t\tif(Lit.matches(\"\\\\d+\")) {\n   \t    \t        \t\t\tint covertedValue = Integer.parseInt(Lit);\n   \t    \t        \t\t\tSystem.out.println(covertedValue);\n   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n   \t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t    \t        \t\t\t}\n   \t    \t        \t\t\t\n   \t    \t        \t\t\telse {\n   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n   \t    \t        \t\t}\n   \t    \t        \t\tSystem.out.println(\"ya VIPER\"+LitVar);\n   \t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t    \t        \t\tSystem.out.println(\"WTFMAN\"+LitVarArg);\n   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar, LitVarArg));    \t    \t    \t        \t\t", "   \t    \t        \t\t\telse if (Lit.matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(Lit);\n   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t    \t        \t\t\t}\n   \t    \t        \t\t\t\n   \t    \t        \t\t\telse {\n   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(Lit);\n   \t    \t        \t\t}\n   \t    \t        \t\tSystem.out.println(\"ya VIPER\"+LitVar);\n   \t    \t        \t\tSWRLLiteralArgument LitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t    \t        \t\tSystem.out.println(\"WTFMAN\"+LitVarArg);\n   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar, LitVarArg));    \t    \t    \t        \t\t", "   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"contains\")) {\n   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.CONTAINS.getIRI(), arguments);\n   \t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"containsIgnoreCase\")) {\n   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.CONTAINS_IGNORE_CASE.getIRI(), arguments);\n   \t    \t        \t\t}else if (entity.getName().equalsIgnoreCase(\"startsWith\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.STARTS_WITH.getIRI(), arguments);\n   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"endsWith\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom(SWRLBuiltInsVocabulary.ENDS_WITH.getIRI(), arguments);\n   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"matches\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#matches\")), arguments);\n   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"stringEqualIgnoreCase\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_EQUALS_IGNORE_CASE.getIRI()), arguments);", "   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"matches\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#matches\")), arguments);\n   \t   \t    \t        \t}else if (entity.getName().equalsIgnoreCase(\"stringEqualIgnoreCase\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_EQUALS_IGNORE_CASE.getIRI()), arguments);\n   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"upperCase\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((IRI.create(\"http://www.w3.org/2003/11/swrlb#upperCase\")), arguments);\n   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"lowerCase\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.LOWER_CASE.getIRI()), arguments);\n   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"stringLength\")) {\t\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_LENGTH.getIRI()) , arguments);\n   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"normalizeSpace\")) {\t\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.NORMALIZE_SPACE.getIRI()) , arguments);\n   \t   \t    \t        \t}\n       \t        \t\t}", "   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"stringLength\")) {\t\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_LENGTH.getIRI()) , arguments);\n   \t   \t    \t        \t}else if(entity.getName().equalsIgnoreCase(\"normalizeSpace\")) {\t\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.NORMALIZE_SPACE.getIRI()) , arguments);\n   \t   \t    \t        \t}\n       \t        \t\t}\n//   \t   \t    \t        \telse if(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n//   \t   \t    \t        \tOWLLiteral LitVar1 = factory.getOWLLiteral(\"ine\");\n//   \t   \t    \t        \tSWRLLiteralArgument LitVarArg1 = factory.getSWRLLiteralArgument(LitVar1);\n//   \t   \t    \t        \targuments.add(LitVarArg1);\n//   \t   \t    \t        \tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n//   \t   \t    \t        \t}\n   \t    \t        \t\tSystem.out.println(bodyElement);\n   \t    \t        \t\tbodyList.add(bodyElement);", "   \t    \t        \t}else if(literal.length == 2) {\n   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));\n   \t    \t        \t\tfor (int i = 0; i < literal.length; i++) {\n   \t    \t        \t\t\tOWLLiteral LitVar;\n   \t   \t    \t        \t\tif(literal[i].matches(\"\\\\d+\")) {\n   \t   \t    \t        \t\t\tint covertedValue = Integer.parseInt(literal[i]);\n   \t   \t    \t        \t\t\tSystem.out.println(covertedValue);\n   \t   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t   \t    \t        \t\t\t}\n   \t   \t    \t        \t\t\t\n   \t   \t    \t        \t\t\telse {\n   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\tSystem.out.println(LitVar);\n   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n   \t   \t    \t        \t\t\n   \t   \t    \t        \t\targuments.add(LitVarArg);\n   \t   \t    \t        \t\tSystem.out.println(arguments);", "   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t   \t    \t        \t\t\t}\n   \t   \t    \t        \t\t\t\n   \t   \t    \t        \t\t\telse {\n   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\tSystem.out.println(LitVar);\n   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n   \t   \t    \t        \t\t\n   \t   \t    \t        \t\targuments.add(LitVarArg);\n   \t   \t    \t        \t\tSystem.out.println(arguments);", "   \t   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substring\")) {\n   \t   \t    \t        \t\t\n   \t   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING.getIRI()) , arguments);\n   \t   \t   \t    \t        \t\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"tokenize\")) {\n   \t   \t    \t        \t\t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.TOKENIZE.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringBefore\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_BEFORE.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringAfter\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_AFTER.getIRI()) , arguments);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t}\n   \t    \t        \t\tSystem.out.println(bodyElement);\n   \t    \t        \t\tbodyList.add(bodyElement);", "   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringBefore\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_BEFORE.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substringAfter\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING_AFTER.getIRI()) , arguments);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t}\n   \t    \t        \t\tSystem.out.println(bodyElement);\n   \t    \t        \t\tbodyList.add(bodyElement);\n   \t    \t        \t}else if(literal.length > 2) {\n   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));", "   \t    \t        \t}else if(literal.length > 2) {\n   \t    \t        \t\tSWRLLiteralArgument LitVarArg = null;\n   \t    \t        \t\tList<SWRLDArgument> arguments = new ArrayList<>(Arrays.asList(swrlVar));\n   \t    \t        \t\tfor (int i = 0; i < literal.length; i++) {\n   \t    \t        \t\t\tOWLLiteral LitVar;\n   \t   \t    \t        \t\tif(literal[i].matches(\"\\\\d+\")) {\n   \t   \t    \t        \t\t\tint covertedValue = Integer.parseInt(literal[i]);\n   \t   \t    \t        \t\t\tSystem.out.println(covertedValue);\n   \t   \t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);}\n   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t   \t    \t        \t\t\t}\n   \t   \t    \t        \t\t\t\n   \t   \t    \t        \t\t\telse {\n   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\tSystem.out.println(LitVar);\n   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n   \t   \t    \t        \t\t\n   \t   \t    \t        \t\targuments.add(LitVarArg);\n   \t   \t    \t        \t\tSystem.out.println(arguments);", "   \t   \t    \t        \t\t\telse if (literal[i].matches(\"^\\\\d*\\\\.?\\\\d+$\")){\n   \t   \t    \t        \t\t\t\tfloat covertedValue = Float.parseFloat(literal[i]);\n   \t   \t    \t        \t\t\t\tSystem.out.println(covertedValue);\n   \t   \t\t    \t        \t\t\tLitVar = factory.getOWLLiteral(covertedValue);\n   \t   \t    \t        \t\t\t}\n   \t   \t    \t        \t\t\t\n   \t   \t    \t        \t\t\telse {\n   \t   \t    \t        \t\t\t\tLitVar = factory.getOWLLiteral(literal[i]);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\tSystem.out.println(LitVar);\n   \t   \t    \t        \t\tLitVarArg = factory.getSWRLLiteralArgument(LitVar);\n   \t   \t    \t        \t\tSystem.out.println(\"AMINE\"+LitVarArg);\n   \t   \t    \t        \t\t\n   \t   \t    \t        \t\targuments.add(LitVarArg);\n   \t   \t    \t        \t\tSystem.out.println(arguments);", "   \t   \t    \t        \t\tif(entity.getName().equalsIgnoreCase(\"stringConcat\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.STRING_CONCAT.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"substring\")) {\n   \t   \t   \t    \t        \tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.SUBSTRING.getIRI()) , arguments); \t   \t    \t        \t\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"replace\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.REPLACE.getIRI()) , arguments);\n   \t   \t    \t        \t\t}else if(entity.getName().equalsIgnoreCase(\"translate\")) {\n   \t   \t    \t        \t\tbodyElement = factory.getSWRLBuiltInAtom((SWRLBuiltInsVocabulary.TRANSLATE.getIRI()) , arguments);\n   \t   \t    \t        \t\t}\n   \t   \t    \t        \t\t\t\n\t\t\t\t\t\t\t}\n   \t    \t        \t\tSystem.out.println(bodyElement);\n   \t    \t        \t\tbodyList.add(bodyElement);\n   \t    \t        \t}\n   \t    \t        \t\n       \t        \t\t\n   \t    \t        }\n       \t    \t}\n    \t    }\n    \t    System.out.println();\n    \t}\n\t\t\n\t\tSet<OWLClass> classes = new HashSet<>();\n\t\tSet<OWLObjectProperty> objectproperties = new HashSet<>();\n\t\tSet<SWRLAtom> headList = new HashSet<>();", "    \tfor (SWRLTypeEntityVariable swrlVariable1 : reqHead) {\n    \t    if( swrlVariable1.getType().equalsIgnoreCase(\"owl:Class\")){\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\tOWLClass classX =factory.getOWLClass(IRI.create(entity.getName()));\n    \t    \t\tclasses.add(classX);\n   \t    \t\t String[] variables = entity.getVar();\n\t    \t        for (String table : variables ) {\n\t    \t        \t\tSWRLVariable swrlVar = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\"+table));\n\t    \t        \t\tSWRLClassAtom headElement = factory.getSWRLClassAtom(classX, swrlVar);\n\t    \t        \t\theadList.add(headElement);\n\t    \t        }\n    \t    \t}", "    \t    }else if (swrlVariable1.getType().equalsIgnoreCase(\"owl:ObjectProperty\")) {\n    \t    \tfor (SWRLVariables entity : swrlVariable1.getEntities()) {\n    \t    \t\tOWLObjectProperty ObjectPropertyX =factory.getOWLObjectProperty(IRI.create(entity.getName()));\n    \t    \t\tobjectproperties.add(ObjectPropertyX);\n    \t    \t\t String[] variables = entity.getVar();\n    \t    \t        if (variables.length != 2) {\n    \t    \t            throw new IllegalArgumentException(\"The variable list must contain an even number of elements\");\n    \t    \t        }\n    \t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n    \t    \t            String variable1 = variables[v];\n    \t    \t            String variable2 = variables[v + 1];\n    \t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n    \t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n    \t    \t            SWRLObjectPropertyAtom headElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n    \t    \t            headList.add(headElement);\n    \t    \t        }\n    \t    \t}\n    \t    }\n    \t    System.out.println();\n    \t}\n\t\t\n\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t// Add SWRL rule to ontology\n\t\tmanager.applyChange(addAxiom);\n\n\t\t// Creation reasoner \n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t//\n\t\t// Computing inferences\n\t\treasoner.precomputeInferences(InferenceType.values());\n\t\t// Print out inferred instances", "    \t    \t        for (int v = 0 ; v<variables.length; v+=2) {\n    \t    \t            String variable1 = variables[v];\n    \t    \t            String variable2 = variables[v + 1];\n    \t    \t            SWRLVariable swrlVar1 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable1));\n    \t    \t            SWRLVariable swrlVar2 = factory.getSWRLVariable(IRI.create(ontology.getOntologyID().getOntologyIRI().get() + \"#\" + variable2));\n    \t    \t            SWRLObjectPropertyAtom headElement = factory.getSWRLObjectPropertyAtom(ObjectPropertyX, swrlVar1, swrlVar2);\n    \t    \t            headList.add(headElement);\n    \t    \t        }\n    \t    \t}\n    \t    }\n    \t    System.out.println();\n    \t}\n\t\t\n\t\tSWRLRule rule = factory.getSWRLRule(bodyList, headList);\n\t\tAddAxiom addAxiom = new AddAxiom(ontology, rule);\n\t\t// Add SWRL rule to ontology\n\t\tmanager.applyChange(addAxiom);\n\n\t\t// Creation reasoner \n\t\tPelletReasonerFactory reasonerFactory = new PelletReasonerFactory();\n\t\tOWLReasoner reasoner = reasonerFactory.createReasoner(ontology);\n\t\t//\n\t\t// Computing inferences\n\t\treasoner.precomputeInferences(InferenceType.values());\n\t\t// Print out inferred instances", "\t\tfor (OWLClass owlClass : classes) {\n\t\t\t\n\t\t    Set<OWLIndividual> assertedInstances = new HashSet<>();\n\t\t    for (OWLClassAssertionAxiom axiom : ontology.getClassAssertionAxioms(owlClass)) {\n\t\t        assertedInstances.add(axiom.getIndividual());\n\t\t    }\n\t\t\t\n\t\t    NodeSet<OWLNamedIndividual> allInstances  = reasoner.getInstances(owlClass, false);\n\t\t    \n\t\t    Set<OWLNamedIndividual> inferredInstances = allInstances.getFlattened();\n\t\t    inferredInstances.removeAll(assertedInstances);\n\t\t    ", "\t\t    for (OWLNamedIndividual inferredInstance  : inferredInstances) {\n\t\t        System.out.println(inferredInstance + \" is an instance of \" + owlClass);\n\t\t    }\n\t\t}\n\t\tMap<String, Set<String>> propertyValues = new HashMap<>();\n\t\tfor (OWLObjectProperty objectproperty : objectproperties) {\n\t\t    for (OWLNamedIndividual individual : ontology.getIndividualsInSignature()) {\n\t\t        NodeSet<OWLNamedIndividual> objectPropertyValues = reasoner.getObjectPropertyValues(individual, objectproperty);\n\n\t\t        // If there are any values, add them to the map\n\t\t        for (OWLNamedIndividual value : objectPropertyValues.getFlattened()) {\n\t\t            String key = individual.getIRI().toString();\n\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(objectproperty.getIRI().toString());\n\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(value.getIRI().toString() );\n\t\t        }\n\t\t    }\n\t\t}\n        Map<String, Set<String>> instances = new HashMap<>();", "\t\t        for (OWLNamedIndividual value : objectPropertyValues.getFlattened()) {\n\t\t            String key = individual.getIRI().toString();\n\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(objectproperty.getIRI().toString());\n\t\t            propertyValues.computeIfAbsent(key, k -> new HashSet<>()).add(value.getIRI().toString() );\n\t\t        }\n\t\t    }\n\t\t}\n        Map<String, Set<String>> instances = new HashMap<>();\n\t\tfor (OWLClass cls : classes) {\n\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false); // false = only inferred\n            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {", "\t\tfor (OWLClass cls : classes) {\n\t\t\tNodeSet<OWLNamedIndividual> inferredIndv = reasoner.getInstances(cls, false); // false = only inferred\n            for (Node<OWLNamedIndividual> individualNode : inferredIndv) {\n                for (OWLNamedIndividual individual : individualNode) {\n                \tinstances.computeIfAbsent(individual.getIRI().toString(), k -> new HashSet<>()).add(cls.getIRI().toString());\n                }\n            }\n\t\t}\n\t\tMap<String, Map<String, Set<String>>> finalMap = new HashMap<>();\n\t\tfinalMap.put(\"class\", instances);\n\t\tfinalMap.put(\"objectProperty\", propertyValues);\n\t\t Gson gson = new Gson();\n         String json = gson.toJson(finalMap);\n\t\t return json;\n\t}catch (OWLOntologyCreationException e){\n\t\tGson gson = new Gson();\n\t\tString json = gson.toJson(e);\n\t\treturn json;\n\t}\n\n\n\t}\n\n}\n"]}
