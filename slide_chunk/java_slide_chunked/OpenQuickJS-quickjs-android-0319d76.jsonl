{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSFunction.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\n/**\n * JavaScript function.\n */\npublic final class JSFunction extends JSObject {\n\n  JSFunction(long pointer, JSContext jsContext) {\n    super(pointer, jsContext, null);\n  }\n\n  /**\n   * Calls the JavaScript function.\n   */", "public final class JSFunction extends JSObject {\n\n  JSFunction(long pointer, JSContext jsContext) {\n    super(pointer, jsContext, null);\n  }\n\n  /**\n   * Calls the JavaScript function.\n   */\n  public JSValue invoke(@Nullable JSValue thisObj, JSValue[] args) {\n    // Check whether JSValues are from the same JSRuntime", "  public JSValue invoke(@Nullable JSValue thisObj, JSValue[] args) {\n    // Check whether JSValues are from the same JSRuntime\n    if (thisObj != null) checkSameJSContext(thisObj);\n    for (JSValue arg : args) checkSameJSContext(arg);\n\n    long[] valueArgs = new long[args.length];\n    for (int i = 0; i < args.length; i++) {\n      valueArgs[i] = args[i].pointer;\n    }\n\n    synchronized (jsContext.jsRuntime) {\n      long context = jsContext.checkClosed();\n      long ret = QuickJS.invokeValueFunction(context, pointer, thisObj != null ? thisObj.pointer : 0, valueArgs);\n      return jsContext.wrapAsJSValue(ret);\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSFunctionCallback.java", "chunked_list": ["/*\n * Copyright 2021 Hippo Seven\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;\n\npublic interface JSFunctionCallback {\n  JSValue invoke(JSContext context, JSValue[] args);\n}\n", "package com.shiqi.quickjs;\n\npublic interface JSFunctionCallback {\n  JSValue invoke(JSContext context, JSValue[] args);\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSArray.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript array.\n */\npublic final class JSArray extends JSObject {\n\n  JSArray(long pointer, JSContext jsContext) {\n    super(pointer, jsContext, null);\n  }\n\n  /**\n   * Returns the number of elements in an array.\n   */", "  public int getLength() {\n    return getProperty(\"length\").cast(JSNumber.class).getInt();\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JNIHelper.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport java.lang.reflect.Type;\n\nclass JNIHelper {\n\n  private static Type VOID_PRIMITIVE_TYPE = void.class;\n  private static Type CHAR_PRIMITIVE_TYPE = char.class;\n  private static Type BOOLEAN_PRIMITIVE_TYPE = boolean.class;", "  private static Type CHAR_PRIMITIVE_TYPE = char.class;\n  private static Type BOOLEAN_PRIMITIVE_TYPE = boolean.class;\n  private static Type BYTE_PRIMITIVE_TYPE = byte.class;\n  private static Type SHORT_PRIMITIVE_TYPE = short.class;\n  private static Type INT_PRIMITIVE_TYPE = int.class;\n  private static Type LONG_PRIMITIVE_TYPE = long.class;\n  private static Type FLOAT_PRIMITIVE_TYPE = float.class;\n  private static Type DOUBLE_PRIMITIVE_TYPE = double.class;\n\n  private static Object jsValueToJavaValue(JSContext jsContext, Type type, long value) {", "\n  private static Object jsValueToJavaValue(JSContext jsContext, Type type, long value) {\n    synchronized (jsContext.jsRuntime) {\n      JSValue jsValue = null;\n      try {\n        jsContext.checkClosed();\n        TypeAdapter<Object> adapter = jsContext.quickJS.getAdapter(type);\n        jsValue = jsContext.wrapAsJSValue(value);\n        return adapter.fromJSValue(jsContext, jsValue);\n      } finally {\n        if (jsValue == null) {\n          QuickJS.destroyValue(jsContext.pointer, value);\n        }\n      }\n    }\n  }\n\n  private static long javaValueToJSValue(JSContext jsContext, Type type, boolean value) { return javaValueToJSValue(jsContext, type, (Boolean) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, char value) { return javaValueToJSValue(jsContext, type, (Character) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, byte value) { return javaValueToJSValue(jsContext, type, (Byte) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, short value) { return javaValueToJSValue(jsContext, type, (Short) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, int value) { return javaValueToJSValue(jsContext, type, (Integer) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, long value) { return javaValueToJSValue(jsContext, type, (Long) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, float value) { return javaValueToJSValue(jsContext, type, (Float) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, double value) { return javaValueToJSValue(jsContext, type, (Double) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, Object value) {\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      TypeAdapter<Object> adapter = jsContext.quickJS.getAdapter(type);\n      return adapter.toJSValue(jsContext, value).pointer;\n    }\n  }\n\n  private static boolean isPrimitiveType(Type type) {\n    return type instanceof Class && ((Class<?>) type).isPrimitive();\n  }\n\n  @SuppressWarnings(\"EqualsReplaceableByObjectsCall\")\n  private static boolean isSameType(Type t1, Type t2) {\n    return (t1 == t2) || (t1 != null && t1.equals(t2));\n  }\n\n  private static boolean unbox(Boolean value) { return value; }\n  private static char unbox(Character value) { return value; }\n  private static byte unbox(Byte value) { return value; }\n  private static short unbox(Short value) { return value; }\n  private static int unbox(Integer value) { return value; }\n  private static long unbox(Long value) { return value; }\n  private static float unbox(Float value) { return value; }\n  private static double unbox(Double value) { return value; }\n}\n", "        if (jsValue == null) {\n          QuickJS.destroyValue(jsContext.pointer, value);\n        }\n      }\n    }\n  }\n\n  private static long javaValueToJSValue(JSContext jsContext, Type type, boolean value) { return javaValueToJSValue(jsContext, type, (Boolean) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, char value) { return javaValueToJSValue(jsContext, type, (Character) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, byte value) { return javaValueToJSValue(jsContext, type, (Byte) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, short value) { return javaValueToJSValue(jsContext, type, (Short) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, int value) { return javaValueToJSValue(jsContext, type, (Integer) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, long value) { return javaValueToJSValue(jsContext, type, (Long) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, float value) { return javaValueToJSValue(jsContext, type, (Float) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, double value) { return javaValueToJSValue(jsContext, type, (Double) value); }\n  private static long javaValueToJSValue(JSContext jsContext, Type type, Object value) {\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      TypeAdapter<Object> adapter = jsContext.quickJS.getAdapter(type);\n      return adapter.toJSValue(jsContext, value).pointer;\n    }\n  }\n\n  private static boolean isPrimitiveType(Type type) {\n    return type instanceof Class && ((Class<?>) type).isPrimitive();\n  }\n\n  @SuppressWarnings(\"EqualsReplaceableByObjectsCall\")\n  private static boolean isSameType(Type t1, Type t2) {\n    return (t1 == t2) || (t1 != null && t1.equals(t2));\n  }\n\n  private static boolean unbox(Boolean value) { return value; }\n  private static char unbox(Character value) { return value; }\n  private static byte unbox(Byte value) { return value; }\n  private static short unbox(Short value) { return value; }\n  private static int unbox(Integer value) { return value; }\n  private static long unbox(Long value) { return value; }\n  private static float unbox(Float value) { return value; }\n  private static double unbox(Double value) { return value; }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSEvaluationException.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * This exception is raised if QuickJS raises a JavaScript exception.\n */\npublic class JSEvaluationException extends RuntimeException {\n\n  private JSException jsException;\n\n  JSEvaluationException(JSException jsException) {\n    super(jsException.toString());\n  }\n", "  public JSException getJSException() {\n    return jsException;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/NativeCleaner.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport java.lang.ref.PhantomReference;\nimport java.lang.ref.ReferenceQueue;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * https://youtu.be/7_caITSjk1k", "/**\n * https://youtu.be/7_caITSjk1k\n */\nabstract class NativeCleaner<T> {\n\n  private final Set<NativeReference<T>> phantomReferences = new HashSet<>();\n  private final ReferenceQueue<T> referenceQueue = new ReferenceQueue<>();\n\n  /**\n   * Returns the size of not removed objects.", "  /**\n   * Returns the size of not removed objects.\n   */\n  public int size() {\n    return phantomReferences.size();\n  }\n\n  /**\n   * Registers the object and the native pointer to this cleaner.\n   *\n   * @param referent the object\n   * @param pointer the native pointer\n   */", "  public void register(T referent, long pointer) {\n    phantomReferences.add(new NativeReference<>(referent, pointer, referenceQueue));\n  }\n\n  /**\n   * Releases the native resources associated with the native pointer.\n   * It's called in {@link #clean()} on objects recycled by GC,\n   * or in {@link #forceClean()} on all objects.\n   * It's only called once on each object.\n   *\n   * @param pointer the native pointer\n   */", "  public abstract void onRemove(long pointer);\n\n  /**\n   * Calls {@link #onRemove(long)} on objects recycled by GC.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void clean() {\n    NativeReference<T> ref;\n    while ((ref = (NativeReference<T>) referenceQueue.poll()) != null) {\n      if (phantomReferences.contains(ref)) {\n        onRemove(ref.pointer);\n        phantomReferences.remove(ref);\n      }\n    }\n  }\n\n  /**\n   * Calls {@link #onRemove(long)} on all objects.\n   */", "    while ((ref = (NativeReference<T>) referenceQueue.poll()) != null) {\n      if (phantomReferences.contains(ref)) {\n        onRemove(ref.pointer);\n        phantomReferences.remove(ref);\n      }\n    }\n  }\n\n  /**\n   * Calls {@link #onRemove(long)} on all objects.\n   */", "  public void forceClean() {\n    for (NativeReference<T> ref : phantomReferences) {\n      onRemove(ref.pointer);\n    }\n    phantomReferences.clear();\n  }\n\n  private static class NativeReference<T> extends PhantomReference<T> {\n\n    private final long pointer;\n\n    private NativeReference(T referent, long pointer, ReferenceQueue<? super T> q) {\n      super(referent, q);\n      this.pointer = pointer;\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSException.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\n\n/**\n * The information of JavaScript exception.\n */\npublic class JSException {\n\n  private final boolean isError;\n  private final String exception;\n  private final String stack;\n\n  private JSException(boolean isError, String exception, String stack) {\n    this.isError = isError;\n    this.exception = exception;\n    this.stack = stack;\n  }\n", " */\npublic class JSException {\n\n  private final boolean isError;\n  private final String exception;\n  private final String stack;\n\n  private JSException(boolean isError, String exception, String stack) {\n    this.isError = isError;\n    this.exception = exception;\n    this.stack = stack;\n  }\n", "  public boolean isError() {\n    return isError;\n  }\n\n  /**\n   * The exception message.\n   */\n  @Nullable\n  public String getException() {\n    return exception;\n  }\n\n  /**\n   * The stack trace.\n   */\n  @Nullable", "  public String getException() {\n    return exception;\n  }\n\n  /**\n   * The stack trace.\n   */\n  @Nullable\n  public String getStack() {\n    return stack;\n  }\n\n  @NonNull\n  @Override", "  public String getStack() {\n    return stack;\n  }\n\n  @NonNull\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (!isError) {\n      sb.append(\"Throw: \");\n    }\n    sb.append(exception).append(\"\\n\");", "    if (!isError) {\n      sb.append(\"Throw: \");\n    }\n    sb.append(exception).append(\"\\n\");\n    if (stack != null) {\n      sb.append(stack);\n    }\n    return sb.toString();\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSNull.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript null.\n */\npublic final class JSNull extends JSValue {\n\n  JSNull(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSObject.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript object.\n */\npublic class JSObject extends JSValue {\n\n  public static int PROP_FLAG_CONFIGURABLE = 0b001;\n  public static int PROP_FLAG_WRITABLE = 0b010;\n  public static int PROP_FLAG_ENUMERABLE = 0b100;\n\n  private static final int PROP_FLAG_MASK = 0b111;\n\n  private final Object javaObject;\n\n  JSObject(long pointer, JSContext jsContext, Object javaObject) {\n    super(pointer, jsContext);\n    this.javaObject = javaObject;\n  }\n", "  public static int PROP_FLAG_CONFIGURABLE = 0b001;\n  public static int PROP_FLAG_WRITABLE = 0b010;\n  public static int PROP_FLAG_ENUMERABLE = 0b100;\n\n  private static final int PROP_FLAG_MASK = 0b111;\n\n  private final Object javaObject;\n\n  JSObject(long pointer, JSContext jsContext, Object javaObject) {\n    super(pointer, jsContext);\n    this.javaObject = javaObject;\n  }\n", "  public Object getJavaObject() {\n    return javaObject;\n  }\n\n  /**\n   * Returns the property as a JSValue.\n   *\n   * @throws JSEvaluationException if the cannot read property of this JSValue.\n   */\n  public JSValue getProperty(int index) {\n    synchronized (jsContext.jsRuntime) {\n      long context = jsContext.checkClosed();\n      long property = QuickJS.getValueProperty(context, pointer, index);\n      return jsContext.wrapAsJSValue(property);\n    }\n  }\n\n  /**\n   * Returns the property as a JSValue.\n   *\n   * @throws JSEvaluationException if the cannot read property of this JSValue.\n   */", "  public JSValue getProperty(int index) {\n    synchronized (jsContext.jsRuntime) {\n      long context = jsContext.checkClosed();\n      long property = QuickJS.getValueProperty(context, pointer, index);\n      return jsContext.wrapAsJSValue(property);\n    }\n  }\n\n  /**\n   * Returns the property as a JSValue.\n   *\n   * @throws JSEvaluationException if the cannot read property of this JSValue.\n   */", "  public JSValue getProperty(String name) {\n    synchronized (jsContext.jsRuntime) {\n      long context = jsContext.checkClosed();\n      long property = QuickJS.getValueProperty(context, pointer, name);\n      return jsContext.wrapAsJSValue(property);\n    }\n  }\n\n  /**\n   * Sets JSValue as a property.\n   */", "  public void setProperty(int index, JSValue jsValue) {\n    checkSameJSContext(jsValue);\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      if (!QuickJS.setValueProperty(jsContext.pointer, pointer, index, jsValue.pointer)) {\n        throw new JSEvaluationException(QuickJS.getException(jsContext.pointer));\n      }\n    }\n  }\n\n  /**\n   * Sets JSValue as a property.\n   */", "  public void setProperty(String name, JSValue jsValue) {\n    checkSameJSContext(jsValue);\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      if (!QuickJS.setValueProperty(jsContext.pointer, pointer, name, jsValue.pointer)) {\n        throw new JSEvaluationException(QuickJS.getException(jsContext.pointer));\n      }\n    }\n  }\n\n  /**\n   * Defines a new property directly on an object, or modifies an existing property on this object.\n   */", "  public void defineProperty(int index, JSValue jsValue, int flags) {\n    if ((flags & (~PROP_FLAG_MASK)) != 0) {\n      throw new IllegalArgumentException(\"Invalid flags: \" + flags);\n    }\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      if (!QuickJS.defineValueProperty(jsContext.pointer, pointer, index, jsValue.pointer, flags)) {\n        throw new JSEvaluationException(QuickJS.getException(jsContext.pointer));\n      }\n    }\n  }\n\n  /**\n   * Defines a new property directly on an object, or modifies an existing property on this object.\n   */", "  public void defineProperty(String name, JSValue jsValue, int flags) {\n    if ((flags & (~PROP_FLAG_MASK)) != 0) {\n      throw new IllegalArgumentException(\"Invalid flags: \" + flags);\n    }\n    synchronized (jsContext.jsRuntime) {\n      jsContext.checkClosed();\n      if (!QuickJS.defineValueProperty(jsContext.pointer, pointer, name, jsValue.pointer, flags)) {\n        throw new JSEvaluationException(QuickJS.getException(jsContext.pointer));\n      }\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JavaMethod.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Arrays;", "import java.lang.reflect.TypeVariable;\nimport java.util.Arrays;\n\n/**\n * Represents a java method or a java static method.\n */\npublic final class JavaMethod {\n\n  @Nullable\n  public static JavaMethod create(Type type, Method rawMethod) {\n    Class<?> rawType = JavaTypes.getRawType(type);\n    Type returnType = JavaTypes.resolve(type, rawType, rawMethod.getGenericReturnType());\n    // It's not resolved", "  public static JavaMethod create(Type type, Method rawMethod) {\n    Class<?> rawType = JavaTypes.getRawType(type);\n    Type returnType = JavaTypes.resolve(type, rawType, rawMethod.getGenericReturnType());\n    // It's not resolved\n    if (returnType instanceof TypeVariable) return null;\n\n    String name = rawMethod.getName();\n\n    Type[] originParameterTypes = rawMethod.getGenericParameterTypes();\n    Type[] parameterTypes = new Type[originParameterTypes.length];\n    for (int i = 0; i < parameterTypes.length; i++) {\n      parameterTypes[i] = JavaTypes.resolve(type, rawType, originParameterTypes[i]);\n      // It's not resolved", "    for (int i = 0; i < parameterTypes.length; i++) {\n      parameterTypes[i] = JavaTypes.resolve(type, rawType, originParameterTypes[i]);\n      // It's not resolved\n      if (parameterTypes[i] instanceof TypeVariable) return null;\n    }\n\n    return new JavaMethod(returnType, name, parameterTypes);\n  }\n\n  final Type returnType;\n  final String name;\n  final Type[] parameterTypes;\n\n  public JavaMethod(Type returnType, String name, Type[] parameterTypes) {\n    this.returnType = canonicalize(returnType);\n    this.name = name;\n    this.parameterTypes = new Type[parameterTypes.length];", "    for (int i = 0; i < parameterTypes.length; i++) {\n      this.parameterTypes[i] = canonicalize(parameterTypes[i]);\n    }\n  }\n\n  private static Type canonicalize(Type type) {\n    return JavaTypes.removeSubtypeWildcard(JavaTypes.canonicalize(type));\n  }\n\n  private static String getTypeSignature(Type type) {\n    // Array", "    if (type instanceof GenericArrayType) {\n      return \"[\" + getTypeSignature(((GenericArrayType) type).getGenericComponentType());\n    }\n\n    // Primitive\n    if (type instanceof Class && ((Class<?>) type).isPrimitive()) {\n      if (type == void.class) return \"V\";\n      if (type == boolean.class) return \"Z\";\n      if (type == byte.class) return \"B\";\n      if (type == char.class) return \"C\";\n      if (type == short.class) return \"S\";", "      if (type == byte.class) return \"B\";\n      if (type == char.class) return \"C\";\n      if (type == short.class) return \"S\";\n      if (type == int.class) return \"I\";\n      if (type == long.class) return \"J\";\n      if (type == float.class) return \"F\";\n      if (type == double.class) return \"D\";\n    }\n\n    // Class\n    Class<?> clazz = JavaTypes.getRawType(type);\n    String name = clazz.getName();\n    StringBuilder sb = new StringBuilder(name.length() + 2);\n    sb.append(\"L\");", "    for (int i = 0; i < name.length(); i++) {\n      char c = name.charAt(i);\n      sb.append(c == '.' ? '/' : c);\n    }\n    sb.append(\";\");\n    return sb.toString();\n  }\n\n  // For jni\n  String getSignature() {\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(\"(\");", "    for (Type parameterType : parameterTypes) {\n      sb.append(getTypeSignature(parameterType));\n    }\n    sb.append(\")\");\n    sb.append(getTypeSignature(returnType));\n\n    return sb.toString();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(returnType);\n    sb.append(\" \");\n    sb.append(name);\n    sb.append(\"(\");", "  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(returnType);\n    sb.append(\" \");\n    sb.append(name);\n    sb.append(\"(\");\n    for (int i = 0; i < parameterTypes.length; i++) {\n      if (i != 0) sb.append(\", \");\n      sb.append(parameterTypes[i]);\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }\n\n  @Override", "  public int hashCode() {\n    int result = 0;\n    result = 31 * result + returnType.hashCode();\n    result = 31 * result + name.hashCode();\n    result = 31 * result + Arrays.hashCode(parameterTypes);\n    return result;\n  }\n\n  @Override\n  public boolean equals(@Nullable Object obj) {\n    if (!(obj instanceof JavaMethod)) return false;\n    JavaMethod other = (JavaMethod) obj;\n    return returnType.equals(other.returnType)\n        && name.equals(other.name)\n        && Arrays.equals(parameterTypes, other.parameterTypes);\n  }\n}\n", "  public boolean equals(@Nullable Object obj) {\n    if (!(obj instanceof JavaMethod)) return false;\n    JavaMethod other = (JavaMethod) obj;\n    return returnType.equals(other.returnType)\n        && name.equals(other.name)\n        && Arrays.equals(parameterTypes, other.parameterTypes);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/PromiseExecutor.java", "chunked_list": ["/*\n * Copyright 2020 Hippo Seven\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;\n\npublic interface PromiseExecutor {\n  void execute(JSFunction resolve, JSFunction reject);\n}\n", "package com.shiqi.quickjs;\n\npublic interface PromiseExecutor {\n  void execute(JSFunction resolve, JSFunction reject);\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSNumber.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript number.\n */\npublic abstract class JSNumber extends JSValue {\n\n  JSNumber(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);\n  }\n\n  /**\n   * Returns byte value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Byte#MAX_VALUE},\n   *         or smaller than {@link Byte#MIN_VALUE}\n   */", "  public abstract byte getByte();\n\n  /**\n   * Returns short value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Short#MAX_VALUE},\n   *         or smaller than {@link Short#MIN_VALUE}\n   */\n  public abstract short getShort();\n\n  /**\n   * Return int value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Integer#MAX_VALUE},\n   *         or smaller than {@link Integer#MIN_VALUE}\n   */", "  public abstract short getShort();\n\n  /**\n   * Return int value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Integer#MAX_VALUE},\n   *         or smaller than {@link Integer#MIN_VALUE}\n   */\n  public abstract int getInt();\n\n  /**\n   * Return long value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Long#MAX_VALUE},\n   *         or smaller than {@link Long#MIN_VALUE}\n   */", "  public abstract int getInt();\n\n  /**\n   * Return long value.\n   *\n   * @throws JSDataException if it has decimal part, or bigger than {@link Long#MAX_VALUE},\n   *         or smaller than {@link Long#MIN_VALUE}\n   */\n  public abstract long getLong();\n\n  /**\n   * Return float value.\n   */", "  public abstract long getLong();\n\n  /**\n   * Return float value.\n   */\n  public abstract float getFloat();\n\n  /**\n   * Return double value.\n   */\n  public abstract double getDouble();\n}\n", "  public abstract double getDouble();\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSArrayBuffer.java", "chunked_list": ["/*\n * Copyright 2021 Hippo Seven\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;\n\npublic class JSArrayBuffer extends JSObject {\n\n  JSArrayBuffer(long pointer, JSContext jsContext) {\n    super(pointer, jsContext, null);\n  }\n", "package com.shiqi.quickjs;\n\npublic class JSArrayBuffer extends JSObject {\n\n  JSArrayBuffer(long pointer, JSContext jsContext) {\n    super(pointer, jsContext, null);\n  }\n\n  public int getByteLength() {\n    return getProperty(\"byteLength\").cast(JSNumber.class).getInt();\n  }\n\n  public boolean[] toBooleanArray() {\n    return QuickJS.toBooleanArray(jsContext.pointer, pointer);\n  }\n\n  public byte[] toByteArray() {\n    return QuickJS.toByteArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 2\n   */\n  public char[] toCharArray() {\n    return QuickJS.toCharArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 2\n   */\n  public short[] toShortArray() {\n    return QuickJS.toShortArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 4\n   */\n  public int[] toIntArray() {\n    return QuickJS.toIntArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 8\n   */\n  public long[] toLongArray() {\n    return QuickJS.toLongArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 4\n   */\n  public float[] toFloatArray() {\n    return QuickJS.toFloatArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 8\n   */\n  public double[] toDoubleArray() {\n    return QuickJS.toDoubleArray(jsContext.pointer, pointer);\n  }\n}\n", "  public int getByteLength() {\n    return getProperty(\"byteLength\").cast(JSNumber.class).getInt();\n  }\n\n  public boolean[] toBooleanArray() {\n    return QuickJS.toBooleanArray(jsContext.pointer, pointer);\n  }\n\n  public byte[] toByteArray() {\n    return QuickJS.toByteArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 2\n   */\n  public char[] toCharArray() {\n    return QuickJS.toCharArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 2\n   */\n  public short[] toShortArray() {\n    return QuickJS.toShortArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 4\n   */\n  public int[] toIntArray() {\n    return QuickJS.toIntArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 8\n   */\n  public long[] toLongArray() {\n    return QuickJS.toLongArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 4\n   */\n  public float[] toFloatArray() {\n    return QuickJS.toFloatArray(jsContext.pointer, pointer);\n  }\n\n  /**\n   * @throws IllegalStateException if its byteLength isn't a multiple of 8\n   */\n  public double[] toDoubleArray() {\n    return QuickJS.toDoubleArray(jsContext.pointer, pointer);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSSymbol.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript symbol.\n */\npublic final class JSSymbol extends JSValue {\n\n  JSSymbol(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/QuickJS.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n", "import java.util.concurrent.ConcurrentHashMap;\n\n/**\n * QuickJS is a resources container to create {@link JSRuntime}s.\n */\npublic class QuickJS {\n\n  private static final List<TypeAdapter.Factory> BUILT_IN_FACTORIES = new ArrayList<>(4);\n\n  static {\n    BUILT_IN_FACTORIES.add(StandardTypeAdapters.FACTORY);\n    BUILT_IN_FACTORIES.add(JSValueAdapter.FACTORY);\n    BUILT_IN_FACTORIES.add(ArrayTypeAdapter.FACTORY);\n    BUILT_IN_FACTORIES.add(InterfaceTypeAdapter.FACTORY);\n  }\n\n  private final List<TypeAdapter.Factory> factories;\n  private final Map<Type, TypeAdapter<?>> adapterCache;\n\n  private QuickJS(Builder builder) {\n    List<TypeAdapter.Factory> factories = new ArrayList<>(builder.factories.size() + BUILT_IN_FACTORIES.size());\n    factories.addAll(builder.factories);\n    factories.addAll(BUILT_IN_FACTORIES);\n    this.factories = Collections.unmodifiableList(factories);\n    this.adapterCache = new ConcurrentHashMap<>();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> TypeAdapter<T> getAdapter(Type type) {\n    // Canonicalize type\n    Type newType = JavaTypes.removeSubtypeWildcard(JavaTypes.canonicalize(type));\n\n    TypeAdapter<?> adapter = adapterCache.get(newType);", "    if (adapter != null) {\n      return (TypeAdapter<T>) adapter;\n    }\n\n    for (int i = 0, size = factories.size(); i < size; i++) {\n      adapter = factories.get(i).create(this, newType);\n      if (adapter != null) {\n        adapterCache.put(newType, adapter);\n        return (TypeAdapter<T>) adapter;\n      }\n    }\n\n    throw new IllegalArgumentException(\"Can't find TypeAdapter for \" + type);\n  }\n\n  /**\n   * Creates a JSRuntime with resources in this QuickJS.\n   */", "  public JSRuntime createJSRuntime() {\n    long runtime = QuickJS.createRuntime();\n    if (runtime == 0) {\n      throw new IllegalStateException(\"Cannot create JSRuntime instance\");\n    }\n    return new JSRuntime(runtime, this);\n  }\n\n  public static class Builder {\n\n    private final List<TypeAdapter.Factory> factories = new ArrayList<>();\n\n    public <T> Builder registerTypeAdapter(final Type type, final TypeAdapter<T> adapter) {\n      return registerTypeAdapterFactory((depot, targetType) -> {", "  public static class Builder {\n\n    private final List<TypeAdapter.Factory> factories = new ArrayList<>();\n\n    public <T> Builder registerTypeAdapter(final Type type, final TypeAdapter<T> adapter) {\n      return registerTypeAdapterFactory((depot, targetType) -> {\n        if (JavaTypes.equals(type, targetType)) {\n          return adapter;\n        }\n        return null;\n      });\n    }\n", "    public Builder registerTypeAdapterFactory(TypeAdapter.Factory factory) {\n      factories.add(factory);\n      return this;\n    }\n\n    public QuickJS build() {\n      return new QuickJS(this);\n    }\n  }\n\n  static {\n    System.loadLibrary(\"quickjs-android\");\n  }\n\n  static native long createRuntime();\n  static native void setRuntimeMallocLimit(long runtime, int mallocLimit);\n  static native void setRuntimeMaxStackSize(long runtime, int stackSize);\n  static native void setRuntimeInterruptHandler(long runtime, JSRuntime.InterruptHandler interruptHandler);\n  static native void destroyRuntime(long runtime);\n\n  static native long createContext(long runtime);\n  static native void destroyContext(long context);\n\n  static native long createValueUndefined(long context);\n  static native long createValueNull(long context);\n  static native long createValueBoolean(long context, boolean value);\n  static native long createValueInt(long context, int value);\n  static native long createValueFloat64(long context, double value);\n  static native long createValueString(long context, String value);\n  static native long createValueObject(long context);\n  static native long createValueArray(long context);\n  static native long createValueArrayBufferZ(long context, boolean[] array, int start, int length);\n  static native long createValueArrayBufferB(long context, byte[] array, int start, int length);\n  static native long createValueArrayBufferC(long context, char[] array, int start, int length);\n  static native long createValueArrayBufferS(long context, short[] array, int start, int length);\n  static native long createValueArrayBufferI(long context, int[] array, int start, int length);\n  static native long createValueArrayBufferJ(long context, long[] array, int start, int length);\n  static native long createValueArrayBufferF(long context, float[] array, int start, int length);\n  static native long createValueArrayBufferD(long context, double[] array, int start, int length);\n  static native long createValueFunction(long context, JSContext jsContext, Object instance, String methodName, String methodSign, Type returnType, Type[] argTypes, boolean isCallbackMethod);\n  static native long createValueFunctionS(long context, JSContext jsContext, String className, String methodName, String methodSign, Type returnType, Type[] argTypes);\n  static native long createValueJavaObject(long context, Object object);\n  static native long[] createValuePromise(long context);\n\n  static native int getValueTag(long value);\n  static native boolean isValueArray(long context, long value);\n  static native boolean isValueArrayBuffer(long context, long value);\n  static native boolean isValueFunction(long context, long value);\n  static native long getValueProperty(long context, long value, int index);\n  static native long getValueProperty(long context, long value, String name);\n  static native boolean setValueProperty(long context, long value, int index, long property);\n  static native boolean setValueProperty(long context, long value, String name, long property);\n  static native boolean[] toBooleanArray(long context, long value);\n  static native byte[] toByteArray(long context, long value);\n  static native char[] toCharArray(long context, long value);\n  static native short[] toShortArray(long context, long value);\n  static native int[] toIntArray(long context, long value);\n  static native long[] toLongArray(long context, long value);\n  static native float[] toFloatArray(long context, long value);\n  static native double[] toDoubleArray(long context, long value);\n  static native boolean getValueBoolean(long value);\n  static native int getValueInt(long value);\n  static native double getValueFloat64(long value);\n  static native String getValueString(long context, long value);\n  static native Object getValueJavaObject(long context, long value);\n  static native boolean defineValueProperty(long context, long value, int index, long property, int flags);\n  static native boolean defineValueProperty(long context, long value, String name, long property, int flags);\n  static native long invokeValueFunction(long context, long function, long thisObj, long[] args);\n  static native void destroyValue(long context, long value);\n\n  static native JSException getException(long context);\n  static native long getGlobalObject(long context);\n\n  static native long evaluate(long context, String sourceCode, String fileName, int flags);\n\n  static native void evaluateBytecode(long context, byte[] bytecode, int flags);\n  static native byte[] compileJsToBytecode(long context, String code);\n  static native int executePendingJob(long context);\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/InterfaceTypeAdapter.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Arrays;", "import java.lang.reflect.TypeVariable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass InterfaceTypeAdapter extends TypeAdapter<Object> {\n\n  /**\n   * Returns all methods in the interface type.\n   * Returns {@code null} if the type is not interface,", "   * Returns all methods in the interface type.\n   * Returns {@code null} if the type is not interface,\n   * or any method is overloaded, or any type can't be resolved.\n   */\n  @Nullable\n  static Map<String, JavaMethod> getInterfaceMethods(Type type) {\n    Class<?> rawType = JavaTypes.getRawType(type);\n    if (!rawType.isInterface()) return null;\n\n    Map<String, JavaMethod> methods = new HashMap<>();\n", "    for (Method method : rawType.getMethods()) {\n      Type returnType = JavaTypes.resolve(type, rawType, method.getGenericReturnType());\n      // It's not resolved\n      if (returnType instanceof TypeVariable) return null;\n\n      String name = method.getName();\n\n      Type[] originParameterTypes = method.getGenericParameterTypes();\n      Type[] parameterTypes = new Type[originParameterTypes.length];\n      for (int i = 0; i < parameterTypes.length; i++) {\n        parameterTypes[i] = JavaTypes.resolve(type, rawType, originParameterTypes[i]);\n        // It's not resolved", "      for (int i = 0; i < parameterTypes.length; i++) {\n        parameterTypes[i] = JavaTypes.resolve(type, rawType, originParameterTypes[i]);\n        // It's not resolved\n        if (parameterTypes[i] instanceof TypeVariable) return null;\n      }\n\n      JavaMethod oldMethod = methods.get(name);\n      if (oldMethod != null) {\n        if (!Arrays.equals(oldMethod.parameterTypes, parameterTypes)) {\n          // overload is not supported\n          return null;\n        }", "        if (!Arrays.equals(oldMethod.parameterTypes, parameterTypes)) {\n          // overload is not supported\n          return null;\n        }\n        if (returnType.equals(oldMethod.returnType)\n            || JavaTypes.getRawType(returnType).isAssignableFrom(JavaTypes.getRawType(oldMethod.returnType))) {\n          // The new method is overridden\n          continue;\n        }\n      }\n\n      methods.put(name, new JavaMethod(returnType, name, parameterTypes));\n    }\n\n    return methods;\n  }\n\n  static final Factory FACTORY = (depot, type) -> {\n    Map<String, JavaMethod> methods = getInterfaceMethods(type);", "    if (methods == null) return null;\n    return new InterfaceTypeAdapter(JavaTypes.getRawType(type), methods).nullable();\n  };\n\n  private final Class<?> rawType;\n  private final Map<String, JavaMethod> methods;\n\n  private InterfaceTypeAdapter(Class<?> rawType, Map<String, JavaMethod> methods) {\n    this.rawType = rawType;\n    this.methods = methods;\n  }\n\n  @Override", "  public JSValue toJSValue(JSContext context, Object value) {\n    if (value instanceof JSValueHolder) {\n      return ((JSValueHolder) value).getJSValue(JS_VALUE_HOLDER_TAG);\n    }\n\n    JSObject jo = context.createJSObject(value);\n    for (JavaMethod method : methods.values()) {\n      jo.setProperty(method.name, context.createJSFunction(value, method));\n    }\n    return jo;\n  }\n\n  @Override", "  public Object fromJSValue(JSContext context, JSValue value) {\n    JSObject jo = value.cast(JSObject.class);\n\n    Object object = jo.getJavaObject();\n    // TODO Check generic\n    if (rawType.isInstance(object)) return object;\n\n    return Proxy.newProxyInstance(rawType.getClassLoader(), new Class<?>[]{ rawType, JSValueHolder.class }, (proxy, method, args) -> {\n      // If the method is a method from Object then defer to normal invocation.\n      if (method.getDeclaringClass() == Object.class) {\n        return method.invoke(this, args);\n      }\n\n      // Check JSValueHolder.getJSValue(JSValueHolderTag)", "      if (method.getDeclaringClass() == Object.class) {\n        return method.invoke(this, args);\n      }\n\n      // Check JSValueHolder.getJSValue(JSValueHolderTag)\n      if (args != null && args.length == 1 && args[0] == JS_VALUE_HOLDER_TAG) {\n        return value;\n      }\n\n      String name = method.getName();\n      JavaMethod simpleMethod = methods.get(name);", "      if (simpleMethod == null) throw new NoSuchMethodException(\"Can't find method: \" + name);\n\n      int parameterNumber = args != null ? args.length : 0;\n      if (parameterNumber != simpleMethod.parameterTypes.length) throw new IllegalStateException(\"Parameter number doesn't match: \" + name);\n      JSValue[] parameters = new JSValue[parameterNumber];\n      for (int i = 0; i < parameterNumber; i++) {\n        Type type = simpleMethod.parameterTypes[i];\n        TypeAdapter<Object> adapter = context.quickJS.getAdapter(type);\n        parameters[i] = adapter.toJSValue(context, args[i]);\n      }\n\n      Type resultType = simpleMethod.returnType;\n      TypeAdapter<?> resultAdapter = context.quickJS.getAdapter(resultType);\n\n      JSFunction function = jo.getProperty(name).cast(JSFunction.class);\n\n      JSValue result = function.invoke(jo, parameters);\n\n      return resultAdapter.fromJSValue(context, result);\n    });\n  }\n\n  private interface JSValueHolder {\n    JSValue getJSValue(JSValueHolderTag tag);\n  }\n  private static class JSValueHolderTag { }\n  private static final JSValueHolderTag JS_VALUE_HOLDER_TAG = new JSValueHolderTag();\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSValue.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n// TODO Make JSValue closeable?\n\n/**\n * JSValue is a Javascript value.\n * It could be a number, a object, null, undefined or something else.\n */\npublic abstract class JSValue {\n\n  final long pointer;\n  final JSContext jsContext;\n\n  JSValue(long pointer, JSContext jsContext) {\n    this.pointer = pointer;\n    this.jsContext = jsContext;\n  }\n\n  /**\n   * Cast this JSValue to a special type.\n   *\n   * @throws JSDataException if it's not the type\n   */\n  @SuppressWarnings(\"unchecked\")\n  public final <T extends JSValue> T cast(Class<T> clazz) {", " */\npublic abstract class JSValue {\n\n  final long pointer;\n  final JSContext jsContext;\n\n  JSValue(long pointer, JSContext jsContext) {\n    this.pointer = pointer;\n    this.jsContext = jsContext;\n  }\n\n  /**\n   * Cast this JSValue to a special type.\n   *\n   * @throws JSDataException if it's not the type\n   */\n  @SuppressWarnings(\"unchecked\")\n  public final <T extends JSValue> T cast(Class<T> clazz) {", "    if (clazz.isInstance(this)) {\n      return (T) this;\n    } else {\n      throw new JSDataException(\"expected: \" + clazz.getSimpleName() + \", actual: \" + getClass().getSimpleName());\n    }\n  }\n\n  /**\n   * @throws IllegalStateException if two JSValues are not from the same JSContext\n   */\n  final void checkSameJSContext(JSValue jsValue) {", "    if (jsValue.jsContext != jsContext) {\n      throw new IllegalStateException(\"Two JSValues are not from the same JSContext\");\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/TypeAdapter.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.Type;\n\npublic abstract class TypeAdapter<T> {\n  /**\n   * Converts the java value to {@code JSValue}.\n   * Throws {@link JSDataException} if the value can't be handled.\n   */", "  public abstract JSValue toJSValue(JSContext context, T value);\n\n  /**\n   * Converts the {@code JSValue} to java value.\n   */\n  public abstract T fromJSValue(JSContext context, JSValue value);\n\n  /**\n   * Returns a TypeAdapter equal to this TypeAdapter,\n   * but with support for null java object and null/undefined javascript value.\n   */", "  public final TypeAdapter<T> nullable() {\n    return new NullableTypeAdapter<>(this);\n  }\n\n  private static class NullableTypeAdapter<T> extends TypeAdapter<T> {\n\n    private final TypeAdapter<T> delegate;\n\n    NullableTypeAdapter(TypeAdapter<T> delegate) {\n      this.delegate = delegate;\n    }\n\n    @Override", "    public JSValue toJSValue(JSContext context, T value) {\n      if (value == null) return context.createJSNull();\n      return delegate.toJSValue(context, value);\n    }\n\n    @Override\n    public T fromJSValue(JSContext context, JSValue value) {\n      if (value instanceof JSNull || value instanceof JSUndefined) return null;\n      return delegate.fromJSValue(context, value);\n    }\n  }\n", "  public interface Factory {\n    @Nullable\n    TypeAdapter<?> create(QuickJS quickJS, Type type);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JavaTypes.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n// https://github.com/square/moshi/blob/master/moshi/src/main/java/com/squareup/moshi/Types.java", "\n// https://github.com/square/moshi/blob/master/moshi/src/main/java/com/squareup/moshi/Types.java\n// https://github.com/square/moshi/blob/master/moshi/src/main/java/com/squareup/moshi/internal/Util.java\n\nclass JavaTypes {\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. Use this\n   * method if {@code rawType} is not enclosed in another type.\n   */\n  public static ParameterizedType newParameterizedType(Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(null, rawType, typeArguments);\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. Use this\n   * method if {@code rawType} is enclosed in {@code ownerType}.\n   */", "   * method if {@code rawType} is not enclosed in another type.\n   */\n  public static ParameterizedType newParameterizedType(Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(null, rawType, typeArguments);\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. Use this\n   * method if {@code rawType} is enclosed in {@code ownerType}.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /** Returns an array type whose elements are all instances of {@code componentType}. */", "  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /** Returns an array type whose elements are all instances of {@code componentType}. */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}. For example, if\n   * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\n   * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code\n   * ? extends Object}.\n   */", "  public static WildcardType subtypeOf(Type bound) {\n    return new WildcardTypeImpl(new Type[] { bound }, new Type[0]);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\n   * bound} is {@code String.class}, this returns {@code ? super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n  }\n", "  public static WildcardType supertypeOf(Type bound) {\n    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but\n      // suspects some pathological case related to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      return (Class<?>) rawType;\n", "    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but\n      // suspects some pathological case related to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType) type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n", "    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType) type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // We could use the variable's bounds, but that won't work if there are multiple. having a raw\n      // type that's more general than necessary is okay.\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  /** Returns true if {@code a} and {@code b} are equal. */\n  static boolean equals(@Nullable Type a, @Nullable Type b) {", "    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  /** Returns true if {@code a} and {@code b} are equal. */\n  static boolean equals(@Nullable Type a, @Nullable Type b) {", "    if (a == b) {\n      return true; // Also handles (a == null && b == null).\n\n    } else if (a instanceof Class) {\n      if (b instanceof GenericArrayType) {\n        return equals(((Class<?>) a).getComponentType(),\n            ((GenericArrayType) b).getGenericComponentType());\n      }\n      return a.equals(b); // Class already specifies equals().\n\n    } else if (a instanceof ParameterizedType) {", "    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) return false;\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      Type[] aTypeArguments = pa instanceof ParameterizedTypeImpl\n          ? ((ParameterizedTypeImpl) pa).typeArguments\n          : pa.getActualTypeArguments();\n      Type[] bTypeArguments = pb instanceof ParameterizedTypeImpl\n          ? ((ParameterizedTypeImpl) pb).typeArguments\n          : pb.getActualTypeArguments();\n      return equals(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(aTypeArguments, bTypeArguments);\n", "    } else if (a instanceof GenericArrayType) {\n      if (b instanceof Class) {\n        return equals(((Class<?>) b).getComponentType(),\n            ((GenericArrayType) a).getGenericComponentType());\n      }\n      if (!(b instanceof GenericArrayType)) return false;\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {", "    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) return false;\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) return false;\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a supported type.\n      return false;\n    }\n  }\n\n  /**\n   * Returns the element type of {@code type} if it is an array type, or null if it is not an\n   * array type.\n   */\n  static Type arrayComponentType(Type type) {", "      if (!(b instanceof TypeVariable)) return false;\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a supported type.\n      return false;\n    }\n  }\n\n  /**\n   * Returns the element type of {@code type} if it is an array type, or null if it is not an\n   * array type.\n   */\n  static Type arrayComponentType(Type type) {", "    if (type instanceof GenericArrayType) {\n      return ((GenericArrayType) type).getGenericComponentType();\n    } else if (type instanceof Class) {\n      return ((Class<?>) type).getComponentType();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal according to {@link\n   * Object#equals(Object) Object.equals()}.\n   */\n  static Type canonicalize(Type type) {", "    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      if (type instanceof ParameterizedTypeImpl) return type;\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {", "    } else if (type instanceof GenericArrayType) {\n      if (type instanceof GenericArrayTypeImpl) return type;\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      if (type instanceof WildcardTypeImpl) return type;\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      return type; // This type is unsupported!\n    }\n  }\n\n  /**\n   * If type is a \"? extends X\" wildcard, returns X; otherwise returns type unchanged.\n   */\n  static Type removeSubtypeWildcard(Type type) {", "    if (!(type instanceof WildcardType)) return type;\n\n    Type[] lowerBounds = ((WildcardType) type).getLowerBounds();\n    if (lowerBounds.length != 0) return type;\n\n    Type[] upperBounds = ((WildcardType) type).getUpperBounds();\n    if (upperBounds.length != 1) throw new IllegalArgumentException();\n\n    return upperBounds[0];\n  }\n\n  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    // This implementation is made a little more complicated in an attempt to avoid object-creation.", "    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) return toResolve;\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : new GenericArrayTypeImpl(newComponentType);\n", "      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : new GenericArrayTypeImpl(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();", "      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n            : original;\n", "          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n            : original;\n", "      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n          if (lowerBound != originalLowerBound[0]) {\n            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);", "        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n          if (upperBound != originalUpperBound[0]) {\n            return new WildcardTypeImpl(new Type[] { upperBound }, new Type[0]);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  private static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // We can't reduce this further.", "    if (declaredByRaw == null) return unknown;\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  private static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {", "    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes", "        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();", "    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (rawSupertype != null && toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  private static int hashCodeOrZero(@Nullable Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  private static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {", "    for (int i = 0; i < array.length; i++) {\n      if (toFind.equals(array[i])) return i;\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  @Nullable\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;\n  }\n\n  private static void checkNotPrimitive(Type type) {", "    if ((type instanceof Class<?>) && ((Class<?>) type).isPrimitive()) {\n      throw new IllegalArgumentException(\"Unexpected primitive \" + type + \". Use the boxed type.\");\n    }\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType {\n    @Nullable\n    private final Type ownerType;\n    private final Type rawType;\n    final Type[] typeArguments;\n\n    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {\n      // Require an owner type if the raw type needs it.", "      if (rawType instanceof Class<?>) {\n        Class<?> enclosingClass = ((Class<?>) rawType).getEnclosingClass();\n        if (ownerType != null) {\n          if (enclosingClass == null || JavaTypes.getRawType(ownerType) != enclosingClass) {\n            throw new IllegalArgumentException(\n                \"unexpected owner type for \" + rawType + \": \" + ownerType);\n          }\n        } else if (enclosingClass != null) {\n          throw new IllegalArgumentException(\n              \"unexpected owner type for \" + rawType + \": null\");\n        }\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();", "      for (int t = 0; t < this.typeArguments.length; t++) {\n        if (this.typeArguments[t] == null) throw new NullPointerException();\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    @NonNull\n    @Override\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    @NonNull\n    @Override", "    public Type getRawType() {\n      return rawType;\n    }\n\n    @Override\n    public @Nullable Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && JavaTypes.equals(this, (ParameterizedType) other);\n    }\n\n    @Override", "    public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && JavaTypes.equals(this, (ParameterizedType) other);\n    }\n\n    @Override\n    public int hashCode() {\n      return 31 * (31 * hashCodeOrZero(rawType) + hashCodeOrZero(ownerType)) +\n          Arrays.hashCode(typeArguments);\n    }\n\n    @Override", "    public String toString() {\n      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));\n      result.append(typeToString(rawType));\n\n      if (typeArguments.length == 0) {\n        return result.toString();\n      }\n\n      result.append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < typeArguments.length; i++) {\n        result.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return result.append(\">\").toString();\n    }\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType {\n    private final Type componentType;\n\n    GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    @NonNull\n    @Override", "      for (int i = 1; i < typeArguments.length; i++) {\n        result.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return result.append(\">\").toString();\n    }\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType {\n    private final Type componentType;\n\n    GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    @NonNull\n    @Override", "    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && JavaTypes.equals(this, (GenericArrayType) o);\n    }\n\n    @Override", "    public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override\n    public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only\n   * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper\n   * bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType {\n    private final Type upperBound;\n    @Nullable\n    private final Type lowerBound;\n\n    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {", "      if (lowerBounds.length > 1) throw new IllegalArgumentException();\n      if (upperBounds.length != 1) throw new IllegalArgumentException();\n\n      if (lowerBounds.length == 1) {\n        if (lowerBounds[0] == null) throw new NullPointerException();\n        checkNotPrimitive(lowerBounds[0]);\n        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {", "        if (upperBounds[0] == null) throw new NullPointerException();\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    @Override\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    @NonNull\n    @Override\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : new Type[0];\n    }\n\n    @Override", "    public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && JavaTypes.equals(this, (WildcardType) other);\n    }\n\n    @Override\n    public int hashCode() {\n      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override", "    public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSString.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript string.\n */\npublic final class JSString extends JSValue {\n\n  private final String value;\n\n  JSString(long pointer, JSContext jsContext, String value) {\n    super(pointer, jsContext);\n    this.value = value;\n  }\n", "  public String getString() {\n    return value;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSBoolean.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript boolean.\n */\npublic class JSBoolean extends JSValue {\n\n  private final boolean value;\n\n  JSBoolean(long pointer, JSContext jsContext, boolean value) {\n    super(pointer, jsContext);\n    this.value = value;\n  }\n\n  /**\n   * Returns boolean value.\n   */", "  public boolean getBoolean() {\n    return value;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JavaType.java", "chunked_list": ["/*\n * Copyright 2021 Hippo Seven\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;\n", "package com.shiqi.quickjs;\n\nimport androidx.annotation.NonNull;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\npublic abstract class JavaType<T> {\n  @NonNull\n  public Type type;\n\n  public JavaType() {\n    Type supertype = JavaTypes.canonicalize(getClass().getGenericSuperclass());", "  public Type type;\n\n  public JavaType() {\n    Type supertype = JavaTypes.canonicalize(getClass().getGenericSuperclass());\n    if (!(supertype instanceof ParameterizedType)) invalidJavaType();\n\n    Type[] types = ((ParameterizedType) supertype).getActualTypeArguments();\n    if (types.length != 1) invalidJavaType();\n\n    type = types[0];\n  }\n\n  private void invalidJavaType() {\n    throw new IllegalStateException(\n        \"Invalid JavaType. JavaType must be inherited by a anonymous class\");\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/StandardTypeAdapters.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.Type;\n\nclass StandardTypeAdapters {\n\n  static final TypeAdapter.Factory FACTORY = new TypeAdapter.Factory() {", "\n  static final TypeAdapter.Factory FACTORY = new TypeAdapter.Factory() {\n\n    @Nullable\n    @Override\n    public TypeAdapter<?> create(QuickJS quickJS, Type type) {\n      if (type == void.class) return VOID_TYPE_ADAPTER;\n      if (type == boolean.class) return BOOLEAN_TYPE_ADAPTER;\n      if (type == byte.class) return BYTE_TYPE_ADAPTER;\n      if (type == char.class) return CHARACTER_TYPE_ADAPTER;\n      if (type == short.class) return SHORT_TYPE_ADAPTER;", "      if (type == byte.class) return BYTE_TYPE_ADAPTER;\n      if (type == char.class) return CHARACTER_TYPE_ADAPTER;\n      if (type == short.class) return SHORT_TYPE_ADAPTER;\n      if (type == int.class) return INTEGER_TYPE_ADAPTER;\n      if (type == long.class) return LONG_TYPE_ADAPTER;\n      if (type == float.class) return FLOAT_TYPE_ADAPTER;\n      if (type == double.class) return DOUBLE_TYPE_ADAPTER;\n      if (type == Void.class) return VOID_TYPE_ADAPTER;\n      if (type == Boolean.class) return BOOLEAN_TYPE_ADAPTER.nullable();\n      if (type == Byte.class) return BYTE_TYPE_ADAPTER.nullable();\n      if (type == Character.class) return CHARACTER_TYPE_ADAPTER.nullable();", "      if (type == Boolean.class) return BOOLEAN_TYPE_ADAPTER.nullable();\n      if (type == Byte.class) return BYTE_TYPE_ADAPTER.nullable();\n      if (type == Character.class) return CHARACTER_TYPE_ADAPTER.nullable();\n      if (type == Short.class) return SHORT_TYPE_ADAPTER.nullable();\n      if (type == Integer.class) return INTEGER_TYPE_ADAPTER.nullable();\n      if (type == Long.class) return LONG_TYPE_ADAPTER.nullable();\n      if (type == Float.class) return FLOAT_TYPE_ADAPTER.nullable();\n      if (type == Double.class) return DOUBLE_TYPE_ADAPTER.nullable();\n      if (type == String.class) return STRING_TYPE_ADAPTER.nullable();\n      return null;\n    }\n  };\n\n  private static final TypeAdapter<Void> VOID_TYPE_ADAPTER = new TypeAdapter<Void>() {\n    @Override", "      if (type == String.class) return STRING_TYPE_ADAPTER.nullable();\n      return null;\n    }\n  };\n\n  private static final TypeAdapter<Void> VOID_TYPE_ADAPTER = new TypeAdapter<Void>() {\n    @Override\n    public JSValue toJSValue(JSContext context, Void value) {\n      return context.createJSNull();\n    }\n\n    @Override", "    public Void fromJSValue(JSContext context, JSValue value) {\n      if (value instanceof JSNull || value instanceof JSUndefined) return null;\n      throw new JSDataException(\"excepted: JSNull or JSUndefined, actual: \" + value.getClass().getSimpleName());\n    }\n  };\n\n  private static final TypeAdapter<Boolean> BOOLEAN_TYPE_ADAPTER = new TypeAdapter<Boolean>() {\n    @Override\n    public JSValue toJSValue(JSContext context, Boolean value) {\n      return context.createJSBoolean(value);\n    }\n\n    @Override", "    public JSValue toJSValue(JSContext context, Boolean value) {\n      return context.createJSBoolean(value);\n    }\n\n    @Override\n    public Boolean fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSBoolean.class).getBoolean();\n    }\n  };\n\n  private static final TypeAdapter<Byte> BYTE_TYPE_ADAPTER = new TypeAdapter<Byte>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Byte value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Byte fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getByte();\n    }\n  };\n\n  private static final TypeAdapter<Character> CHARACTER_TYPE_ADAPTER = new TypeAdapter<Character>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Character value) {\n      return context.createJSString(value.toString());\n    }\n\n    @Override\n    public Character fromJSValue(JSContext context, JSValue value) {\n      String str = value.cast(JSString.class).getString();\n      if (str.length() != 1) {\n        throw new JSDataException(\"Can't treat \\\"\" + str + \"\\\" as char\");\n      }\n      return str.charAt(0);\n    }\n  };\n\n  private static final TypeAdapter<Short> SHORT_TYPE_ADAPTER = new TypeAdapter<Short>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Short value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Short fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getShort();\n    }\n  };\n\n  private static final TypeAdapter<Integer> INTEGER_TYPE_ADAPTER = new TypeAdapter<Integer>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Integer value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Integer fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getInt();\n    }\n  };\n\n  private static final TypeAdapter<Long> LONG_TYPE_ADAPTER = new TypeAdapter<Long>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Long value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Long fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getLong();\n    }\n  };\n\n  private static final TypeAdapter<Float> FLOAT_TYPE_ADAPTER = new TypeAdapter<Float>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Float value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Float fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getFloat();\n    }\n  };\n\n  private static final TypeAdapter<Double> DOUBLE_TYPE_ADAPTER = new TypeAdapter<Double>() {\n    @Override", "    public JSValue toJSValue(JSContext context, Double value) {\n      return context.createJSNumber(value);\n    }\n\n    @Override\n    public Double fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSNumber.class).getDouble();\n    }\n  };\n\n  private static final TypeAdapter<String> STRING_TYPE_ADAPTER = new TypeAdapter<String>() {\n    @Override", "    public JSValue toJSValue(JSContext context, String value) {\n      return context.createJSString(value);\n    }\n\n    @Override\n    public String fromJSValue(JSContext context, JSValue value) {\n      return value.cast(JSString.class).getString();\n    }\n  };\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSDataException.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * This exception is raised if JSValue can't be convert to Java type.\n */\npublic class JSDataException extends RuntimeException {\n  public JSDataException(String message) {\n    super(message);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSRuntime.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.io.Closeable;\n\n// TODO Check all JSContext closed when closing JSRuntime\n\n/**", "\n/**\n * JSRuntime is a JavaScript runtime with a memory heap.\n * It can't evaluate JavaScript script.\n *\n * @see JSContext\n */\npublic class JSRuntime implements Closeable {\n\n  private long pointer;\n  private final QuickJS quickJS;\n\n  JSRuntime(long pointer, QuickJS quickJS) {\n    this.pointer = pointer;\n    this.quickJS = quickJS;\n  }\n\n  private void checkClosed() {", "    if (pointer == 0) {\n      throw new IllegalStateException(\"The JSRuntime is closed\");\n    }\n  }\n\n  /**\n   * Set the malloc limit for this JSRuntime.\n   * Only positive number and {@code -1} are accepted.\n   * {@code -1} for no limit.\n   */\n  public synchronized void setMallocLimit(int mallocLimit) {\n    checkClosed();\n", "  public synchronized void setMallocLimit(int mallocLimit) {\n    checkClosed();\n\n    if (mallocLimit == 0 || mallocLimit < -1) {\n      throw new IllegalArgumentException(\"Only positive number and -1 are accepted as malloc limit\");\n    }\n\n    QuickJS.setRuntimeMallocLimit(pointer, mallocLimit);\n  }\n\n  /**\n   * Set max stack size for this JSRuntime.\n   * Only positive number and {@code 0} are accepted.\n   * {@code 0} for no stack size check.\n   */", "  public synchronized void setMaxStackSize(int stackSize) {\n    checkClosed();\n\n    if (stackSize < 0) {\n      throw new IllegalArgumentException(\"Only positive number and 0 are accepted as max stack size\");\n    }\n\n    QuickJS.setRuntimeMaxStackSize(pointer, stackSize);\n  }\n\n  /**\n   * Set the InterruptHandler for this JSRuntime.\n   * {@link InterruptHandler#onInterrupt()} is called every 10000 js instructions.\n   */", "  public synchronized void setInterruptHandler(@Nullable InterruptHandler interruptHandler) {\n    checkClosed();\n    QuickJS.setRuntimeInterruptHandler(pointer, interruptHandler);\n  }\n\n  /**\n   * Creates a JSContext with the memory heap of this JSRuntime.\n   */\n  public synchronized JSContext createJSContext() {\n    checkClosed();\n    long context = QuickJS.createContext(pointer);", "  public synchronized JSContext createJSContext() {\n    checkClosed();\n    long context = QuickJS.createContext(pointer);\n    if (context == 0) {\n      throw new IllegalStateException(\"Cannot create JSContext instance\");\n    }\n    return new JSContext(context, quickJS, this);\n  }\n\n  @Override\n  public synchronized void close() {", "  public synchronized void close() {\n    if (pointer != 0) {\n      long runtimeToClose = pointer;\n      pointer = 0;\n      QuickJS.destroyRuntime(runtimeToClose);\n    }\n  }\n\n  public interface InterruptHandler {\n    /**\n     * Returns {@code true} to interrupt.\n     */\n    boolean onInterrupt();\n  }\n}\n", "  public interface InterruptHandler {\n    /**\n     * Returns {@code true} to interrupt.\n     */\n    boolean onInterrupt();\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSFloat64.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nfinal class JSFloat64 extends JSNumber {\n\n  private final double value;\n\n  JSFloat64(long pointer, JSContext jsContext, double value) {\n    super(pointer, jsContext);\n    this.value = value;", "    super(pointer, jsContext);\n    this.value = value;\n  }\n\n  private String wrongNumberMessage(String javaType, double value) {\n    return \"Can't treat \" + value + \" as \" + javaType;\n  }\n\n  @Override\n  public byte getByte() {\n    double value = this.value;\n    byte result = (byte) value;", "  @Override\n  public byte getByte() {\n    double value = this.value;\n    byte result = (byte) value;\n    if (result != value) {\n      throw new JSDataException(wrongNumberMessage(\"byte\", value));\n    }\n    return result;\n  }\n\n  @Override", "  public short getShort() {\n    double value = this.value;\n    short result = (short) value;\n    if (result != value) {\n      throw new JSDataException(wrongNumberMessage(\"short\", value));\n    }\n    return result;\n  }\n\n  @Override\n  public int getInt() {\n    double value = this.value;\n    int result = (int) value;", "  public int getInt() {\n    double value = this.value;\n    int result = (int) value;\n    if (result != value) {\n      throw new JSDataException(wrongNumberMessage(\"int\", value));\n    }\n    return result;\n  }\n\n  @Override\n  public long getLong() {\n    double value = this.value;\n    long result = (long) value;", "  public long getLong() {\n    double value = this.value;\n    long result = (long) value;\n    if (result != value) {\n      throw new JSDataException(wrongNumberMessage(\"long\", value));\n    }\n    return result;\n  }\n\n  @Override\n  public float getFloat() {\n    return (float) value;\n  }\n\n  @Override", "  public float getFloat() {\n    return (float) value;\n  }\n\n  @Override\n  public double getDouble() {\n    return value;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/ArrayTypeAdapter.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\n\nclass ArrayTypeAdapter extends TypeAdapter<Object> {\n\n  public static final Factory FACTORY = (depot, type) -> {\n    Type elementType = JavaTypes.arrayComponentType(type);\n    if (elementType == null) return null;\n    Class<?> elementClass = JavaTypes.getRawType(elementType);\n    TypeAdapter<Object> elementAdapter = depot.getAdapter(elementType);\n    return new ArrayTypeAdapter(elementClass, elementAdapter).nullable();\n  };\n\n  private final Class<?> elementClass;\n  private final TypeAdapter<Object> elementAdapter;\n\n  private ArrayTypeAdapter(Class<?> elementClass, TypeAdapter<Object> elementAdapter) {\n    this.elementClass = elementClass;\n    this.elementAdapter = elementAdapter;\n  }\n\n  @Override", "  public static final Factory FACTORY = (depot, type) -> {\n    Type elementType = JavaTypes.arrayComponentType(type);\n    if (elementType == null) return null;\n    Class<?> elementClass = JavaTypes.getRawType(elementType);\n    TypeAdapter<Object> elementAdapter = depot.getAdapter(elementType);\n    return new ArrayTypeAdapter(elementClass, elementAdapter).nullable();\n  };\n\n  private final Class<?> elementClass;\n  private final TypeAdapter<Object> elementAdapter;\n\n  private ArrayTypeAdapter(Class<?> elementClass, TypeAdapter<Object> elementAdapter) {\n    this.elementClass = elementClass;\n    this.elementAdapter = elementAdapter;\n  }\n\n  @Override", "  public JSValue toJSValue(JSContext context, Object value) {\n    JSArray result = context.createJSArray();\n    for (int i = 0, length = Array.getLength(value); i < length; i++) {\n      result.setProperty(i, elementAdapter.toJSValue(context, Array.get(value, i)));\n    }\n    return result;\n  }\n\n  @Override\n  public Object fromJSValue(JSContext context, JSValue value) {\n    JSArray array = value.cast(JSArray.class);\n    int length = array.getLength();\n    Object result = Array.newInstance(elementClass, length);", "  public Object fromJSValue(JSContext context, JSValue value) {\n    JSArray array = value.cast(JSArray.class);\n    int length = array.getLength();\n    Object result = Array.newInstance(elementClass, length);\n    for (int i = 0; i < length; i++) {\n      Array.set(result, i, elementAdapter.fromJSValue(context, array.getProperty(i)));\n    }\n    return result;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSUndefined.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * JavaScript undefined.\n */\npublic final class JSUndefined extends JSValue {\n\n  JSUndefined(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSValueAdapter.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport androidx.annotation.Nullable;\n\nimport java.lang.reflect.Type;\n\nclass JSValueAdapter {\n\n  static final TypeAdapter.Factory FACTORY = new TypeAdapter.Factory() {", "\n  static final TypeAdapter.Factory FACTORY = new TypeAdapter.Factory() {\n\n    @Nullable\n    @Override\n    public TypeAdapter<?> create(QuickJS quickJS, Type type) {\n      if (type == JSValue.class) return JS_VALUE_TYPE_ADAPTER;\n      return null;\n    }\n  };\n\n  private static final TypeAdapter<JSValue> JS_VALUE_TYPE_ADAPTER = new TypeAdapter<JSValue>() {\n    @Override", "    public JSValue toJSValue(JSContext context, JSValue value) {\n      if (value == null) throw new NullPointerException(\"value == null\");\n      return value;\n    }\n\n    @Override\n    public JSValue fromJSValue(JSContext context, JSValue value) {\n      return value;\n    }\n  };\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSInt.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nfinal class JSInt extends JSNumber {\n\n  private final int value;\n\n  JSInt(long pointer, JSContext jsContext, int value) {\n    super(pointer, jsContext);\n    this.value = value;", "    super(pointer, jsContext);\n    this.value = value;\n  }\n\n  private int getIntInRange(String javaType, int min, int max) {\n    int value = this.value;\n    if (min <= value && value <= max) {\n      return value;\n    } else {\n      throw new JSDataException(\"Can't treat \" + value + \" as \" + javaType);\n    }\n  }\n\n  @Override", "  public byte getByte() {\n    return (byte) getIntInRange(\"byte\", Byte.MIN_VALUE, Byte.MAX_VALUE);\n  }\n\n  @Override\n  public short getShort() {\n    return (short) getIntInRange(\"short\", Short.MIN_VALUE, Short.MAX_VALUE);\n  }\n\n  @Override\n  public int getInt() {\n    return value;\n  }\n\n  @Override", "  public int getInt() {\n    return value;\n  }\n\n  @Override\n  public long getLong() {\n    return value;\n  }\n\n  @Override\n  public float getFloat() {\n    return value;\n  }\n\n  @Override", "  public float getFloat() {\n    return value;\n  }\n\n  @Override\n  public double getDouble() {\n    return value;\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSContext.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\nimport android.util.Log;\n\nimport androidx.annotation.Nullable;\n\nimport java.io.Closeable;\nimport java.lang.reflect.Type;\n", "import java.lang.reflect.Type;\n\n/**\n * JSContext is a JavaScript context with its own global objects.\n * JSContexts in the same JSRuntime share the same memory heap.\n *\n * @see JSRuntime\n */\npublic class JSContext implements Closeable {\n\n  static final int TYPE_SYMBOL = -8;\n  static final int TYPE_STRING = -7;\n  static final int TYPE_OBJECT = -1;\n  static final int TYPE_INT = 0;\n  static final int TYPE_BOOLEAN = 1;\n  static final int TYPE_NULL = 2;\n  static final int TYPE_UNDEFINED = 3;\n  static final int TYPE_EXCEPTION = 6;\n  static final int TYPE_FLOAT64 = 7;\n\n  /**\n   * Global code.\n   */", "public class JSContext implements Closeable {\n\n  static final int TYPE_SYMBOL = -8;\n  static final int TYPE_STRING = -7;\n  static final int TYPE_OBJECT = -1;\n  static final int TYPE_INT = 0;\n  static final int TYPE_BOOLEAN = 1;\n  static final int TYPE_NULL = 2;\n  static final int TYPE_UNDEFINED = 3;\n  static final int TYPE_EXCEPTION = 6;\n  static final int TYPE_FLOAT64 = 7;\n\n  /**\n   * Global code.\n   */", "  public static final int EVAL_TYPE_GLOBAL = 0;\n\n  /**\n   * Module code.\n   */\n  public static final int EVAL_TYPE_MODULE = 1;\n\n  /**\n   * Force 'strict' mode.\n   */\n  public static final int EVAL_FLAG_STRICT = 0b01000;\n\n  /**\n   * Force 'strip' mode.\n   *\n   * Remove the debug information (including the source code\n   * of the functions) to save memory.\n   */", "  public static final int EVAL_FLAG_STRICT = 0b01000;\n\n  /**\n   * Force 'strip' mode.\n   *\n   * Remove the debug information (including the source code\n   * of the functions) to save memory.\n   */\n  public static final int EVAL_FLAG_STRIP = 0b10000;\n\n  private static final int EVAL_FLAG_MASK = 0b11000;\n\n  long pointer;\n  final QuickJS quickJS;\n  final JSRuntime jsRuntime;\n  private final NativeCleaner<JSValue> cleaner;\n  private static final String TAG = \"QuickJs JSContext\";\n\n  JSContext(long pointer, QuickJS quickJS, JSRuntime jsRuntime) {\n    this.pointer = pointer;\n    this.quickJS = quickJS;\n    this.jsRuntime = jsRuntime;\n    this.cleaner = new JSValueCleaner();\n  }\n\n  long checkClosed() {", "  public static final int EVAL_FLAG_STRIP = 0b10000;\n\n  private static final int EVAL_FLAG_MASK = 0b11000;\n\n  long pointer;\n  final QuickJS quickJS;\n  final JSRuntime jsRuntime;\n  private final NativeCleaner<JSValue> cleaner;\n  private static final String TAG = \"QuickJs JSContext\";\n\n  JSContext(long pointer, QuickJS quickJS, JSRuntime jsRuntime) {\n    this.pointer = pointer;\n    this.quickJS = quickJS;\n    this.jsRuntime = jsRuntime;\n    this.cleaner = new JSValueCleaner();\n  }\n\n  long checkClosed() {", "    if (pointer == 0) {\n      throw new IllegalStateException(\"The JSContext is closed\");\n    }\n\n    // Trigger cleaner\n    cleaner.clean();\n\n    return pointer;\n  }\n\n  public QuickJS getQuickJS() {\n    return quickJS;\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   */", "  public QuickJS getQuickJS() {\n    return quickJS;\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   */\n  public void evaluate(String script, String fileName) {\n    evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, null);\n  }\n\n  /**\n   * Evaluates the bytecode in this JSContext.\n   */", "  public void evaluateBytecode(byte[] bytecode) {\n    evaluateBytecodeInternal(bytecode, 0, null);\n  }\n\n  /**\n   * Compiles the given JavaScript code in this JSContext to bytecode.\n   */\n  public byte[] compileJsToBytecode(String code) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      return QuickJS.compileJsToBytecode(pointer, code);\n    }\n  }\n\n  /**\n   * Evaluates a snippet of anonymous JavaScript code.\n   */", "  public JSValue evaluate(String script) {\n    return evaluateInternal(script, \"anonymous.js\", EVAL_TYPE_GLOBAL, EVAL_FLAG_STRICT, null);\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   *\n   * @param type must be one of {@link #EVAL_TYPE_GLOBAL} and {@link #EVAL_TYPE_MODULE}\n   * @param flags must be logic and of {@link #EVAL_FLAG_STRICT} and {@link #EVAL_FLAG_STRIP}\n   */\n  public void evaluate(String script, String fileName, int type, int flags) {\n    evaluateInternal(script, fileName, type, flags, null);\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java class.\n   */\n  public <T> T evaluate(String script, String fileName, Class<T> clazz) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, quickJS.getAdapter(clazz));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java type.\n   */\n  public <T> T evaluate(String script, String fileName, Type type) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, quickJS.getAdapter(type));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result converted by the TypeAdapter.\n   */\n  public <T> T evaluate(String script, String fileName, TypeAdapter<T> adapter) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, adapter);\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java class.\n   *\n   * @param type must be one of {@link #EVAL_TYPE_GLOBAL} and {@link #EVAL_TYPE_MODULE}\n   * @param flags must be logic and of {@link #EVAL_FLAG_STRICT} and {@link #EVAL_FLAG_STRIP}\n   */\n  public <T> T evaluate(String script, String fileName, int type, int flags, Class<T> clazz) {\n    return evaluateInternal(script, fileName, type, flags, quickJS.getAdapter(clazz));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result converted by the TypeAdapter.\n   *\n   * @param type must be one of {@link #EVAL_TYPE_GLOBAL} and {@link #EVAL_TYPE_MODULE}\n   * @param flags must be logic and of {@link #EVAL_FLAG_STRICT} and {@link #EVAL_FLAG_STRIP}\n   */\n  public <T> T evaluate(String script, String fileName, int type, int flags, TypeAdapter<T> adapter) {\n    return evaluateInternal(script, fileName, type, flags, adapter);\n  }\n\n  private <T> T evaluateInternal(String script, String fileName, int type, int flags, @Nullable TypeAdapter<T> adapter) {", "  public void evaluate(String script, String fileName, int type, int flags) {\n    evaluateInternal(script, fileName, type, flags, null);\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java class.\n   */\n  public <T> T evaluate(String script, String fileName, Class<T> clazz) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, quickJS.getAdapter(clazz));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java type.\n   */\n  public <T> T evaluate(String script, String fileName, Type type) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, quickJS.getAdapter(type));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result converted by the TypeAdapter.\n   */\n  public <T> T evaluate(String script, String fileName, TypeAdapter<T> adapter) {\n    return evaluateInternal(script, fileName, EVAL_TYPE_GLOBAL, 0, adapter);\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result as the java class.\n   *\n   * @param type must be one of {@link #EVAL_TYPE_GLOBAL} and {@link #EVAL_TYPE_MODULE}\n   * @param flags must be logic and of {@link #EVAL_FLAG_STRICT} and {@link #EVAL_FLAG_STRIP}\n   */\n  public <T> T evaluate(String script, String fileName, int type, int flags, Class<T> clazz) {\n    return evaluateInternal(script, fileName, type, flags, quickJS.getAdapter(clazz));\n  }\n\n  /**\n   * Evaluates the script in this JSContext.\n   * Returns the result converted by the TypeAdapter.\n   *\n   * @param type must be one of {@link #EVAL_TYPE_GLOBAL} and {@link #EVAL_TYPE_MODULE}\n   * @param flags must be logic and of {@link #EVAL_FLAG_STRICT} and {@link #EVAL_FLAG_STRIP}\n   */\n  public <T> T evaluate(String script, String fileName, int type, int flags, TypeAdapter<T> adapter) {\n    return evaluateInternal(script, fileName, type, flags, adapter);\n  }\n\n  private <T> T evaluateInternal(String script, String fileName, int type, int flags, @Nullable TypeAdapter<T> adapter) {", "    if (type != EVAL_TYPE_GLOBAL && type != EVAL_TYPE_MODULE) {\n      throw new IllegalArgumentException(\"Invalid type: \" + type);\n    }\n    if ((flags & (~EVAL_FLAG_MASK)) != 0) {\n      throw new IllegalArgumentException(\"Invalid flags: \" + flags);\n    }\n\n    synchronized (jsRuntime) {\n      checkClosed();\n\n      long value = QuickJS.evaluate(pointer, script, fileName, type | flags);\n", "      if (adapter != null) {\n        JSValue jsValue = wrapAsJSValue(value);\n        return adapter.fromJSValue(this, jsValue);\n      } else {\n        // Only check exception\n        try {\n          if (QuickJS.getValueTag(value) == TYPE_EXCEPTION) {\n            throw new JSEvaluationException(QuickJS.getException(pointer));\n          }\n        } finally {\n          QuickJS.destroyValue(pointer, value);\n        }\n        return null;\n      }\n    }\n  }\n\n  private <T> void evaluateBytecodeInternal(byte[] bytecode, int flags, @Nullable TypeAdapter<T> adapter) {", "    if ((flags & (~EVAL_FLAG_MASK)) != 0) {\n      throw new IllegalArgumentException(\"Invalid flags: \" + flags);\n    }\n\n    synchronized (jsRuntime) {\n      checkClosed();\n\n      QuickJS.evaluateBytecode(pointer, bytecode, flags);\n\n      long value = QuickJS.getGlobalObject(pointer);\n", "      if (adapter != null) {\n        JSValue jsValue = wrapAsJSValue(value);\n        adapter.fromJSValue(this, jsValue);\n      } else {\n        // Only check exception\n        try {\n          throw new JSEvaluationException(QuickJS.getException(pointer));\n        } catch (Exception e) {\n          Log.e(TAG, \"evaluateBytecodeInternal: \" + e.getMessage());\n        } finally {\n          QuickJS.destroyValue(pointer, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute next pending job. Returns {@code false} if it has no pending job.\n   */", "  public boolean executePendingJob() {\n    synchronized (jsRuntime) {\n      checkClosed();\n\n      int code = QuickJS.executePendingJob(pointer);\n      if (code < 0) {\n        throw new JSEvaluationException(QuickJS.getException(pointer));\n      } else {\n        return code != 0;\n      }\n    }\n  }\n\n  /**\n   * Returns the global object.\n   */", "  public JSObject getGlobalObject() {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.getGlobalObject(pointer);\n      return wrapAsJSValue(val).cast(JSObject.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript undefined.\n   */", "  public JSUndefined createJSUndefined() {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueUndefined(pointer);\n      return wrapAsJSValue(val).cast(JSUndefined.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript null.\n   */", "  public JSNull createJSNull() {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueNull(pointer);\n      return wrapAsJSValue(val).cast(JSNull.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript boolean.\n   */", "  public JSBoolean createJSBoolean(boolean value) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueBoolean(pointer, value);\n      return wrapAsJSValue(val).cast(JSBoolean.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript number.\n   */", "  public JSNumber createJSNumber(int value) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueInt(pointer, value);\n      return wrapAsJSValue(val).cast(JSNumber.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript number.\n   */", "  public JSNumber createJSNumber(double value) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueFloat64(pointer, value);\n      return wrapAsJSValue(val).cast(JSNumber.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript string.\n   */", "  public JSString createJSString(String value) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueString(pointer, value);\n      return wrapAsJSValue(val).cast(JSString.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript object.\n   */", "  public JSObject createJSObject() {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueObject(pointer);\n      return wrapAsJSValue(val).cast(JSObject.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript object holding a java object.\n   */", "  public JSObject createJSObject(Object object) {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueJavaObject(pointer, object);\n      return wrapAsJSValue(val).cast(JSObject.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript array.\n   */", "  public JSArray createJSArray() {\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArray(pointer);\n      return wrapAsJSValue(val).cast(JSArray.class);\n    }\n  }\n\n  private void checkArrayBounds(int arrayLength, int start, int length) {\n    if (start < 0 || length <= 0 || start + length > arrayLength) {\n      throw new IndexOutOfBoundsException(\n        \"start = \" + start + \", length = \" + length + \", but array.length = \" + arrayLength\n      );\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java boolean array.\n   * The size of Java boolean is one byte.\n   */", "    if (start < 0 || length <= 0 || start + length > arrayLength) {\n      throw new IndexOutOfBoundsException(\n        \"start = \" + start + \", length = \" + length + \", but array.length = \" + arrayLength\n      );\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java boolean array.\n   * The size of Java boolean is one byte.\n   */", "  public JSArrayBuffer createJSArrayBuffer(boolean[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java boolean array.\n   * The size of Java boolean is one byte.\n   */\n  public JSArrayBuffer createJSArrayBuffer(boolean[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferZ(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java byte array.\n   * The size of Java byte is one byte.\n   */", "  public JSArrayBuffer createJSArrayBuffer(boolean[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferZ(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java byte array.\n   * The size of Java byte is one byte.\n   */", "  public JSArrayBuffer createJSArrayBuffer(byte[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java byte array.\n   * The size of Java byte is one byte.\n   */\n  public JSArrayBuffer createJSArrayBuffer(byte[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferB(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java char array.\n   * The size of Java char is two bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(byte[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferB(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java char array.\n   * The size of Java char is two bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(char[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java char array.\n   * The size of Java char is two bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(char[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferC(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java short array.\n   * The size of Java short is two bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(char[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferC(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java short array.\n   * The size of Java short is two bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(short[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java short array.\n   * The size of Java short is two bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(short[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferS(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java int array.\n   * The size of Java int is four bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(short[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferS(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java int array.\n   * The size of Java int is four bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(int[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java int array.\n   * The size of Java int is four bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(int[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferI(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java long array.\n   * The size of Java long is eight bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(int[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferI(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java long array.\n   * The size of Java long is eight bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(long[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java long array.\n   * The size of Java long is eight bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(long[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferJ(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java float array.\n   * The size of Java float is four bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(long[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferJ(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java float array.\n   * The size of Java float is four bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(float[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java float array.\n   * The size of Java float is four bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(float[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferF(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java double array.\n   * The size of Java double is eight bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(float[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferF(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java double array.\n   * The size of Java double is eight bytes.\n   */", "  public JSArrayBuffer createJSArrayBuffer(double[] array) {\n    return createJSArrayBuffer(array, 0, array.length);\n  }\n\n  /**\n   * Creates a JavaScript ArrayBuffer from a Java double array.\n   * The size of Java double is eight bytes.\n   */\n  public JSArrayBuffer createJSArrayBuffer(double[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferD(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Create a JavaScript function from a java non-static method.\n   */", "  public JSArrayBuffer createJSArrayBuffer(double[] array, int start, int length) {\n    checkArrayBounds(array.length, start, length);\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueArrayBufferD(pointer, array, start, length);\n      return wrapAsJSValue(val).cast(JSArrayBuffer.class);\n    }\n  }\n\n  /**\n   * Create a JavaScript function from a java non-static method.\n   */", "  public JSFunction createJSFunction(Object instance, JavaMethod method) {\n    if (instance == null) throw new NullPointerException(\"instance == null\");\n    if (method == null) throw new NullPointerException(\"method == null\");\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueFunction(pointer, this, instance, method.name, method.getSignature(), method.returnType, method.parameterTypes, false);\n      return wrapAsJSValue(val).cast(JSFunction.class);\n    }\n  }\n\n  /**\n   * Create a JavaScript function from a function callback.\n   */", "  public JSFunction createJSFunction(JSFunctionCallback callback) {\n    if (callback == null) throw new NullPointerException(\"callback == null\");\n    synchronized (jsRuntime) {\n      checkClosed();\n      String methodName = \"invoke\";\n      String methodSign = \"(Lcom/shiqi/quickjs/JSContext;[Lcom/shiqi/quickjs/JSValue;)Lcom/shiqi/quickjs/JSValue;\";\n      long val = QuickJS.createValueFunction(pointer, this, callback, methodName, methodSign, JSValue.class, new Class[] { JSContext.class, JSValue[].class }, true);\n      return wrapAsJSValue(val).cast(JSFunction.class);\n    }\n  }\n\n  /**\n   * Create a JavaScript function from a java static method.\n   */", "  public JSFunction createJSFunctionS(Class<?> clazz, JavaMethod method) {\n    if (clazz == null) throw new NullPointerException(\"clazz == null\");\n    if (method == null) throw new NullPointerException(\"method == null\");\n\n    String name = clazz.getName();\n    StringBuilder sb = new StringBuilder(name.length());\n    for (int i = 0; i < name.length(); i++) {\n      char c = name.charAt(i);\n      sb.append(c == '.' ? '/' : c);\n    }\n    String className = sb.toString();\n\n    synchronized (jsRuntime) {\n      checkClosed();\n      long val = QuickJS.createValueFunctionS(pointer, this, className, method.name, method.getSignature(), method.returnType, method.parameterTypes);\n      return wrapAsJSValue(val).cast(JSFunction.class);\n    }\n  }\n", "  public JSObject createJSPromise(PromiseExecutor executor) {\n    JSValue promise, resolve, reject;\n\n    synchronized (jsRuntime) {\n      checkClosed();\n      long[] values = QuickJS.createValuePromise(pointer);\n      if (values == null) throw new NullPointerException(\"result == null\");\n\n      // Check js exception\n      for (long value : values) {\n        int type = QuickJS.getValueTag(value);", "      for (long value : values) {\n        int type = QuickJS.getValueTag(value);\n        if (type == TYPE_EXCEPTION) {\n          for (long v : values) {\n            QuickJS.destroyValue(pointer, v);\n          }\n          throw new JSEvaluationException(QuickJS.getException(pointer));\n        }\n      }\n\n      promise = wrapAsJSValue(values[0]);\n      resolve = wrapAsJSValue(values[1]);\n      reject = wrapAsJSValue(values[2]);\n    }\n\n    executor.execute(resolve.cast(JSFunction.class), reject.cast(JSFunction.class));\n\n    return promise.cast(JSObject.class);\n  }\n\n  // TODO No need to save c pointers of JSNull, JSUndefined, JSBoolean, JSNumber and JSString.\n  //  Just save their types and values.\n  /**\n   * Wraps a JSValue c pointer as a Java JSValue.\n   *\n   * @throws JSEvaluationException if it's JS_EXCEPTION\n   */\n  JSValue wrapAsJSValue(long value) {", "    if (value == 0) {\n      throw new IllegalStateException(\"Can't wrap null pointer as JSValue\");\n    }\n\n    JSValue jsValue;\n\n    int type = QuickJS.getValueTag(value);\n    switch (type) {\n      case TYPE_SYMBOL:\n        jsValue = new JSSymbol(value, this);\n        break;\n      case TYPE_STRING:\n        jsValue = new JSString(value, this, QuickJS.getValueString(pointer, value));\n        break;\n      case TYPE_OBJECT:", "        if (QuickJS.isValueFunction(pointer, value)) {\n          jsValue = new JSFunction(value, this);\n        } else if (QuickJS.isValueArray(pointer, value)) {\n          jsValue = new JSArray(value, this);\n        } else if (QuickJS.isValueArrayBuffer(pointer, value)) {\n          jsValue = new JSArrayBuffer(value, this);\n        } else {\n          jsValue = new JSObject(value, this, QuickJS.getValueJavaObject(pointer, value));\n        }\n        break;\n      case TYPE_INT:\n        jsValue = new JSInt(value, this, QuickJS.getValueInt(value));\n        break;\n      case TYPE_BOOLEAN:\n        jsValue = new JSBoolean(value, this, QuickJS.getValueBoolean(value));\n        break;\n      case TYPE_NULL:\n        jsValue = new JSNull(value, this);\n        break;\n      case TYPE_UNDEFINED:\n        jsValue = new JSUndefined(value, this);\n        break;\n      case TYPE_EXCEPTION:\n        QuickJS.destroyValue(pointer, value);\n        throw new JSEvaluationException(QuickJS.getException(pointer));\n      case TYPE_FLOAT64:\n        jsValue = new JSFloat64(value, this, QuickJS.getValueFloat64(value));\n        break;\n      default:\n        jsValue = new JSInternal(value, this);\n        break;\n    }\n\n    // Register it to cleaner\n    cleaner.register(jsValue, value);\n\n    return jsValue;\n  }\n\n  int getNotRemovedJSValueCount() {\n    synchronized (jsRuntime) {\n      return cleaner.size();\n    }\n  }\n\n  @Override", "  public void close() {\n    synchronized (jsRuntime) {\n      if (pointer != 0) {\n        // Destroy all JSValue\n        cleaner.forceClean();\n        // Destroy self\n        long contextToClose = pointer;\n        pointer = 0;\n        QuickJS.destroyContext(contextToClose);\n      }\n    }\n  }\n\n  private class JSValueCleaner extends NativeCleaner<JSValue> {\n\n    @Override", "    public void onRemove(long pointer) {\n      QuickJS.destroyValue(JSContext.this.pointer, pointer);\n    }\n  }\n}\n"]}
{"filename": "quickjs-android/src/main/java/com/shiqi/quickjs/JSInternal.java", "chunked_list": ["/*\n * Copyright 2019 Hippo Seven\n * Copyright 2023-Present Shiqi Mei\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *", " *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.shiqi.quickjs;", "\npackage com.shiqi.quickjs;\n\n/**\n * Used internally in QuickJS.\n */\nclass JSInternal extends JSValue {\n\n  JSInternal(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);", "  JSInternal(long pointer, JSContext jsContext) {\n    super(pointer, jsContext);\n  }\n}\n"]}
