{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/FabricLoader.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader;\n", "package org.portinglab.fabricloader.legacyloader;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.portinglab.fabricloader.loader.impl.FabricLoaderImpl;\n\n/**\n * The main class for mod loading operations.", "/**\n * The main class for mod loading operations.\n *\n * @deprecated Use {@link org.portinglab.fabricloader.loader.api.FabricLoader}\n */\n@Deprecated\npublic abstract class FabricLoader implements org.portinglab.fabricloader.loader.api.FabricLoader {\n    /**\n     * @deprecated Use {@link org.portinglab.fabricloader.loader.api.FabricLoader#getInstance()} where possible,\n     * report missing areas as an issue.\n     */\n    @Deprecated", "    public static final FabricLoader INSTANCE = FabricLoaderImpl.InitHelper.get();\n\n    public File getModsDirectory() {\n        return getGameDir().resolve(\"mods\").toFile();\n    }\n\n    @Override\n    public abstract <T> List<T> getEntrypoints(String key, Class<T> type);\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public Collection<ModContainer> getModContainers() {\n        return (Collection) getAllMods();\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public List<ModContainer> getMods() {\n        return (List) getAllMods();\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/ModContainer.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader;\n", "package org.portinglab.fabricloader.legacyloader;\n\nimport org.portinglab.fabricloader.legacyloader.metadata.LoaderModMetadata;\n\nimport java.nio.file.Path;\nimport java.util.List;\n\n/**\n * @deprecated Use {@link org.portinglab.fabricloader.loader.api.ModContainer} instead\n */", " * @deprecated Use {@link org.portinglab.fabricloader.loader.api.ModContainer} instead\n */\n@Deprecated\npublic abstract class ModContainer implements org.portinglab.fabricloader.loader.api.ModContainer {\n    public abstract LoaderModMetadata getInfo();\n    protected abstract List<Path> getCodeSourcePaths();\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/metadata/EntrypointMetadata.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader.metadata;\n", "package org.portinglab.fabricloader.legacyloader.metadata;\n\n/**\n * @deprecated Internal API, do not use\n */\n@Deprecated\npublic interface EntrypointMetadata {\n    String getAdapter();\n    String getValue();\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/metadata/LoaderModMetadata.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader.metadata;\n", "package org.portinglab.fabricloader.legacyloader.metadata;\n\nimport net.minecraftforge.api.distmarker.Dist;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * @deprecated Use {@link org.portinglab.fabricloader.loader.api.metadata.ModMetadata} instead\n */", " * @deprecated Use {@link org.portinglab.fabricloader.loader.api.metadata.ModMetadata} instead\n */\n@Deprecated\npublic interface LoaderModMetadata extends org.portinglab.fabricloader.loader.api.metadata.ModMetadata {\n    boolean loadsInEnvironment(Dist type);\n    List<? extends EntrypointMetadata> getEntrypoints(String type);\n    Collection<String> getEntrypointKeys();\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/util/version/SemanticVersionImpl.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader.util.version;\n", "package org.portinglab.fabricloader.legacyloader.util.version;\n\nimport java.util.Optional;\n\nimport org.portinglab.fabricloader.loader.api.SemanticVersion;\nimport org.portinglab.fabricloader.loader.api.Version;\n\n/**\n * @deprecated Internal API, do not use\n */", " * @deprecated Internal API, do not use\n */\n@Deprecated\npublic class SemanticVersionImpl implements SemanticVersion {\n    private final SemanticVersion parent;\n\n    protected SemanticVersionImpl() {\n        parent = null;\n    }\n\n    public SemanticVersionImpl(String version, boolean storeX) throws VersionParsingException {\n        parent = SemanticVersion.parse(version);\n    }\n\n    @Override", "    public int getVersionComponentCount() {\n        return parent.getVersionComponentCount();\n    }\n\n    @Override\n    public int getVersionComponent(int pos) {\n        return parent.getVersionComponent(pos);\n    }\n\n    @Override\n    public Optional<String> getPrereleaseKey() {\n        return parent.getPrereleaseKey();\n    }\n\n    @Override\n    public Optional<String> getBuildKey() {\n        return parent.getBuildKey();\n    }\n\n    @Override", "    public String getFriendlyString() {\n        return parent.getFriendlyString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return parent.equals(o);\n    }\n\n    @Override\n    public int hashCode() {\n        return parent.hashCode();\n    }\n\n    @Override", "    public int hashCode() {\n        return parent.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return parent.toString();\n    }\n\n    @Override\n    public boolean hasWildcard() {\n        return parent.hasWildcard();\n    }\n", "    public boolean hasWildcard() {\n        return parent.hasWildcard();\n    }\n\n    public boolean equalsComponentsExactly(SemanticVersionImpl other) {\n        for (int i = 0; i < Math.max(getVersionComponentCount(), other.getVersionComponentCount()); i++) {\n            if (getVersionComponent(i) != other.getVersionComponent(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    @Override", "    public int compareTo(Version o) {\n        return parent.compareTo(o);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/legacyloader/util/version/VersionParsingException.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.legacyloader.util.version;\n", "package org.portinglab.fabricloader.legacyloader.util.version;\n\n/** @deprecated Replaced by {@link org.portinglab.fabricloader.loader.api.VersionParsingException} */\n@SuppressWarnings(\"serial\")\n@Deprecated\npublic class VersionParsingException extends Exception {\n    public VersionParsingException() {\n        super();\n    }\n\n    public VersionParsingException(Throwable t) {\n        super(t);\n    }\n\n    public VersionParsingException(String s) {\n        super(s);\n    }\n\n    public VersionParsingException(String s, Throwable t) {\n        super(s, t);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/EntrypointException.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\n/**\n * Represents an exception that arises when obtaining entrypoints.\n *\n * @see FabricLoader#getEntrypointContainers(String, Class)\n */\n@SuppressWarnings(\"serial\")\npublic class EntrypointException extends RuntimeException {\n    private final String key;\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(String key, Throwable cause) {\n        super(\"Exception while loading entries for entrypoint '\" + key + \"'!\", cause);\n        this.key = key;\n    }\n\n    /**\n     * @deprecated For internal use only, use regular exceptions!\n     */\n    @Deprecated\n    public EntrypointException(String key, String causingMod, Throwable cause) {\n        super(\"Exception while loading entries for entrypoint '\" + key + \"' provided by '\" + causingMod + \"'\", cause);\n        this.key = key;\n    }\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(String s) {\n        super(s);\n        this.key = \"\";\n    }\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(Throwable t) {\n        super(t);\n        this.key = \"\";\n    }\n\n    /**\n     * Returns the key of entrypoint in which the exception arose.\n     *\n     * @return the key\n     */", "public class EntrypointException extends RuntimeException {\n    private final String key;\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(String key, Throwable cause) {\n        super(\"Exception while loading entries for entrypoint '\" + key + \"'!\", cause);\n        this.key = key;\n    }\n\n    /**\n     * @deprecated For internal use only, use regular exceptions!\n     */\n    @Deprecated\n    public EntrypointException(String key, String causingMod, Throwable cause) {\n        super(\"Exception while loading entries for entrypoint '\" + key + \"' provided by '\" + causingMod + \"'\", cause);\n        this.key = key;\n    }\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(String s) {\n        super(s);\n        this.key = \"\";\n    }\n\n    /**\n     * @deprecated For internal use only, to be removed!\n     */\n    @Deprecated\n    public EntrypointException(Throwable t) {\n        super(t);\n        this.key = \"\";\n    }\n\n    /**\n     * Returns the key of entrypoint in which the exception arose.\n     *\n     * @return the key\n     */", "    public String getKey() {\n        return key;\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/SemanticVersion.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\nimport java.util.Optional;\n\nimport org.portinglab.fabricloader.loader.impl.util.version.VersionParser;\n\n/**\n * Represents a <a href=\"https://semver.org/\">Sematic Version</a>.\n *\n * <p>Compared to a regular {@link Version}, this type of version receives better support", " *\n * <p>Compared to a regular {@link Version}, this type of version receives better support\n * for version comparisons in dependency notations, and is preferred.</p>\n *\n * @see Version\n */\npublic interface SemanticVersion extends Version {\n    /**\n     * The value of {@linkplain #getVersionComponent(int) version component} that indicates\n     * a {@linkplain #hasWildcard() wildcard}.\n     */\n    int COMPONENT_WILDCARD = Integer.MIN_VALUE;\n\n    /**\n     * Returns the number of components in this version.\n     *\n     * <p>For example, {@code 1.3.x} has 3 components.</p>\n     *\n     * @return the number of components\n     */\n    int getVersionComponentCount();\n\n    /**\n     * Returns the version component at {@code pos}.\n     *\n     * <p>May return {@link #COMPONENT_WILDCARD} to indicate a wildcard component.</p>\n     *\n     * <p>If the pos exceeds the number of components, returns {@link #COMPONENT_WILDCARD}\n     * if the version {@linkplain #hasWildcard() has wildcard}; otherwise returns {@code 0}.</p>\n     *\n     * @param pos the position to check\n     * @return the version component\n     */\n    int getVersionComponent(int pos);\n\n    /**\n     * Returns the prerelease key in the version notation.\n     *\n     * <p>The prerelease key is indicated by a {@code -} before a {@code +} in\n     * the version notation.</p>\n     *\n     * @return the optional prerelease key\n     */\n    Optional<String> getPrereleaseKey();\n\n    /**\n     * Returns the build key in the version notation.\n     *\n     * <p>The build key is indicated by a {@code +} in the version notation.</p>\n     *\n     * @return the optional build key\n     */\n    Optional<String> getBuildKey();\n\n    /**\n     * Returns if a wildcard notation is present in this version.\n     *\n     * <p>A wildcard notation is a {@code x}, {@code X}, or {@code *} in the version string,\n     * such as {@code 2.5.*}.</p>\n     *\n     * @return whether this version has a wildcard notation\n     */\n    boolean hasWildcard();\n\n    /**\n     * @deprecated Use {@link #compareTo(Version)} instead\n     */\n    @Deprecated\n    default int compareTo(SemanticVersion o) {\n        return compareTo((Version) o);\n    }\n\n    /**\n     * Parses a semantic version from a string notation.\n     *\n     * @param s the string notation of the version\n     * @return the parsed version\n     * @throws VersionParsingException if a problem arises during version parsing\n     */\n    static SemanticVersion parse(String s) throws VersionParsingException {\n        return VersionParser.parseSemantic(s);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/FabricLoader.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\nimport java.io.File;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.portinglab.fabricloader.loader.api.entrypoint.EntrypointContainer;\nimport org.portinglab.fabricloader.loader.impl.FabricLoaderImpl;", "import org.portinglab.fabricloader.loader.api.entrypoint.EntrypointContainer;\nimport org.portinglab.fabricloader.loader.impl.FabricLoaderImpl;\nimport net.minecraftforge.api.distmarker.Dist;\n\n/**\n * The public-facing FabricLoader instance.\n *\n * <p>To obtain a working instance, call {@link #getInstance()}.</p>\n *\n * @since 0.4.0", " *\n * @since 0.4.0\n */\npublic interface FabricLoader {\n    /**\n     * Returns the public-facing Fabric Loader instance.\n     */\n    static FabricLoader getInstance() {\n        FabricLoader ret = FabricLoaderImpl.INSTANCE;\n\n        if (ret == null) {\n            throw new RuntimeException(\"Accessed FabricLoader too early!\");\n        }\n\n        return ret;\n    }\n\n    /**\n     * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.\n     *\n     * @param key  the key in entrypoint declaration in {@code fabric.mod.json}\n     * @param type the type of entrypoints\n     * @param <T>  the type of entrypoints\n     * @return the obtained entrypoints\n     * @see #getEntrypointContainers(String, Class)\n     */\n    <T> List<T> getEntrypoints(String key, Class<T> type);\n\n    /**\n     * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.\n     *\n     * <p>The entrypoint is declared in the {@code fabric.mod.json} as following:\n     * <pre><blockquote>\n     *   \"entrypoints\": {\n     *     \"&lt;a key&gt;\": [\n     *       &lt;a list of entrypoint declarations&gt;\n     *     ]\n     *   }\n     * </blockquote></pre>\n     * Multiple keys can be present in the {@code entrypoints} section.</p>\n     *\n     * <p>An entrypoint declaration indicates that an arbitrary notation is sent\n     * to a {@link LanguageAdapter} to offer an instance of entrypoint. It is\n     * either a string, or an object. An object declaration\n     * is of this form:<pre><blockquote>\n     *   {\n     *     \"adapter\": \"&lt;a custom adatper&gt;\"\n     *     \"value\": \"&lt;an arbitrary notation&gt;\"\n     *   }\n     * </blockquote></pre>\n     * A string declaration {@code <an arbitrary notation>} is equivalent to\n     * <pre><blockquote>\n     *   {\n     *     \"adapter\": \"default\"\n     *     \"value\": \"&lt;an arbitrary notation&gt;\"\n     *   }\n     * </blockquote></pre>\n     * where the {@code default} adapter is the {@linkplain LanguageAdapter adapter}\n     * offered by Fabric Loader. </p>\n     *\n     * @param key  the key in entrypoint declaration in {@code fabric.mod.json}\n     * @param type the type of entrypoints\n     * @param <T>  the type of entrypoints\n     * @return the entrypoint containers related to this key\n     * @throws EntrypointException if a problem arises during entrypoint creation\n     * @see LanguageAdapter\n     */\n    <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type);\n\n    /**\n     * Gets the container for a given mod.\n     *\n     * @param id the ID of the mod\n     * @return the mod container, if present\n     */\n    Optional<ModContainer> getModContainer(String id);\n\n    /**\n     * Gets all mod containers.\n     *\n     * @return a collection of all loaded mod containers\n     */\n    Collection<ModContainer> getAllMods();\n\n    /**\n     * Checks if a mod with a given ID is loaded.\n     *\n     * @param id the ID of the mod, as defined in {@code fabric.mod.json}\n     * @return whether or not the mod is present in this Fabric Loader instance\n     */\n    boolean isModLoaded(String id);\n\n    /**\n     * Checks if Fabric Loader is currently running in a \"development\"\n     * environment. Can be used for enabling debug mode or additional checks.\n     *\n     * <p>This should not be used to make assumptions on certain features,\n     * such as mappings, but as a toggle for certain functionalities.</p>\n     *\n     * @return whether or not Loader is currently in a \"development\"\n     * environment\n     */\n    boolean isDevelopmentEnvironment();\n\n    /**\n     * Get the current environment type.\n     *\n     * @return the current environment type\n     */\n    Dist getEnvironmentType();\n\n    /**\n     * Get the current game instance. Can represent a game client or\n     * server object. As such, the exact return is dependent on the\n     * current environment type.\n     *\n     * <p>The game instance may not always be available depending on the game version and {@link Dist environment}.\n     *\n     * @return A client or server instance object\n     * @deprecated This method is experimental and its use is discouraged.\n     */\n    /* @Nullable */\n    @Deprecated\n    Object getGameInstance();\n\n    /**\n     * Get the current game working directory.\n     *\n     * @return the working directory\n     */\n    Path getGameDir();\n\n    @Deprecated\n    File getGameDirectory();\n\n    /**\n     * Get the current directory for game configuration files.\n     *\n     * @return the configuration directory\n     */\n    Path getConfigDir();\n\n    @Deprecated\n    File getConfigDirectory();\n\n    /**\n     * Gets the command line arguments used to launch the game.\n     *\n     * <p>The implementation will try to strip or obscure sensitive data like authentication tokens if {@code sanitize}\n     * is set to true. Callers are highly encouraged to enable sanitization as compromising the information can easily\n     * happen with logging, exceptions, serialization or other causes.\n     *\n     * <p>There is no guarantee that {@code sanitize} covers everything, so the launch arguments should still not be\n     * logged or otherwise exposed routinely even if the parameter is set to {@code true}. In particular it won't\n     * necessarily strip all information that can be used to identify the user.\n     *\n     * @param sanitize Whether to try to remove or obscure sensitive information\n     * @return the launch arguments for the game\n     */\n    String[] getLaunchArguments(boolean sanitize);\n}\n", "        if (ret == null) {\n            throw new RuntimeException(\"Accessed FabricLoader too early!\");\n        }\n\n        return ret;\n    }\n\n    /**\n     * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.\n     *\n     * @param key  the key in entrypoint declaration in {@code fabric.mod.json}\n     * @param type the type of entrypoints\n     * @param <T>  the type of entrypoints\n     * @return the obtained entrypoints\n     * @see #getEntrypointContainers(String, Class)\n     */\n    <T> List<T> getEntrypoints(String key, Class<T> type);\n\n    /**\n     * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.\n     *\n     * <p>The entrypoint is declared in the {@code fabric.mod.json} as following:\n     * <pre><blockquote>\n     *   \"entrypoints\": {\n     *     \"&lt;a key&gt;\": [\n     *       &lt;a list of entrypoint declarations&gt;\n     *     ]\n     *   }\n     * </blockquote></pre>\n     * Multiple keys can be present in the {@code entrypoints} section.</p>\n     *\n     * <p>An entrypoint declaration indicates that an arbitrary notation is sent\n     * to a {@link LanguageAdapter} to offer an instance of entrypoint. It is\n     * either a string, or an object. An object declaration\n     * is of this form:<pre><blockquote>\n     *   {\n     *     \"adapter\": \"&lt;a custom adatper&gt;\"\n     *     \"value\": \"&lt;an arbitrary notation&gt;\"\n     *   }\n     * </blockquote></pre>\n     * A string declaration {@code <an arbitrary notation>} is equivalent to\n     * <pre><blockquote>\n     *   {\n     *     \"adapter\": \"default\"\n     *     \"value\": \"&lt;an arbitrary notation&gt;\"\n     *   }\n     * </blockquote></pre>\n     * where the {@code default} adapter is the {@linkplain LanguageAdapter adapter}\n     * offered by Fabric Loader. </p>\n     *\n     * @param key  the key in entrypoint declaration in {@code fabric.mod.json}\n     * @param type the type of entrypoints\n     * @param <T>  the type of entrypoints\n     * @return the entrypoint containers related to this key\n     * @throws EntrypointException if a problem arises during entrypoint creation\n     * @see LanguageAdapter\n     */\n    <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type);\n\n    /**\n     * Gets the container for a given mod.\n     *\n     * @param id the ID of the mod\n     * @return the mod container, if present\n     */\n    Optional<ModContainer> getModContainer(String id);\n\n    /**\n     * Gets all mod containers.\n     *\n     * @return a collection of all loaded mod containers\n     */\n    Collection<ModContainer> getAllMods();\n\n    /**\n     * Checks if a mod with a given ID is loaded.\n     *\n     * @param id the ID of the mod, as defined in {@code fabric.mod.json}\n     * @return whether or not the mod is present in this Fabric Loader instance\n     */\n    boolean isModLoaded(String id);\n\n    /**\n     * Checks if Fabric Loader is currently running in a \"development\"\n     * environment. Can be used for enabling debug mode or additional checks.\n     *\n     * <p>This should not be used to make assumptions on certain features,\n     * such as mappings, but as a toggle for certain functionalities.</p>\n     *\n     * @return whether or not Loader is currently in a \"development\"\n     * environment\n     */\n    boolean isDevelopmentEnvironment();\n\n    /**\n     * Get the current environment type.\n     *\n     * @return the current environment type\n     */\n    Dist getEnvironmentType();\n\n    /**\n     * Get the current game instance. Can represent a game client or\n     * server object. As such, the exact return is dependent on the\n     * current environment type.\n     *\n     * <p>The game instance may not always be available depending on the game version and {@link Dist environment}.\n     *\n     * @return A client or server instance object\n     * @deprecated This method is experimental and its use is discouraged.\n     */\n    /* @Nullable */\n    @Deprecated\n    Object getGameInstance();\n\n    /**\n     * Get the current game working directory.\n     *\n     * @return the working directory\n     */\n    Path getGameDir();\n\n    @Deprecated\n    File getGameDirectory();\n\n    /**\n     * Get the current directory for game configuration files.\n     *\n     * @return the configuration directory\n     */\n    Path getConfigDir();\n\n    @Deprecated\n    File getConfigDirectory();\n\n    /**\n     * Gets the command line arguments used to launch the game.\n     *\n     * <p>The implementation will try to strip or obscure sensitive data like authentication tokens if {@code sanitize}\n     * is set to true. Callers are highly encouraged to enable sanitization as compromising the information can easily\n     * happen with logging, exceptions, serialization or other causes.\n     *\n     * <p>There is no guarantee that {@code sanitize} covers everything, so the launch arguments should still not be\n     * logged or otherwise exposed routinely even if the parameter is set to {@code true}. In particular it won't\n     * necessarily strip all information that can be used to identify the user.\n     *\n     * @param sanitize Whether to try to remove or obscure sensitive information\n     * @return the launch arguments for the game\n     */\n    String[] getLaunchArguments(boolean sanitize);\n}\n"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/VersionParsingException.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\n@SuppressWarnings({ \"deprecation\", \"serial\" }) //Extending the deprecated one for backwards compatibility\npublic class VersionParsingException extends org.portinglab.fabricloader.legacyloader.util.version.VersionParsingException {\n    public VersionParsingException() {\n        super();\n    }\n\n    public VersionParsingException(Throwable t) {\n        super(t);\n    }\n\n    public VersionParsingException(String s) {\n        super(s);\n    }\n\n    public VersionParsingException(String s, Throwable t) {\n        super(s, t);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/ModContainer.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.portinglab.fabricloader.loader.api.metadata.ModMetadata;\n\n/**", "\n/**\n * Represents a mod.\n */\npublic interface ModContainer {\n    /**\n     * Returns the metadata of this mod.\n     */\n    ModMetadata getMetadata();\n\n    /**\n     * Returns the root directories of the mod (inside JAR/folder), exposing its contents.\n     *\n     * <p>The paths may point to regular folders or into mod JARs. Multiple root paths may occur in development\n     * environments with {@code -Dfabric.classPathGroups} as used in multi-project mod setups.\n     *\n     * <p>A path returned by this method may be incompatible with {@link Path#toFile} as its FileSystem doesn't\n     * necessarily represent the OS file system, but potentially a virtual view of jar contents or another abstraction.\n     *\n     * @return the root directories of the mod, may be empty for builtin or other synthetic mods\n     */\n    List<Path> getRootPaths();\n\n    /**\n     * Get the mod containing this mod (nested jar parent).\n     *\n     * @return mod containing this mod or empty if not nested\n     */\n    Optional<ModContainer> getContainingMod();\n\n    /**\n     * Get the active mods contained within this mod (nested jar children).\n     *\n     * @return active contained mods within this mod's jar\n     */\n    Collection<ModContainer> getContainedMods();\n\n    // deprecated methods\n\n    /**\n     * @deprecated use {@link #getRootPaths()} instead\n     */\n    @Deprecated\n    default Path getRoot() {\n        return getRootPath();\n    }\n\n    /**\n     * @deprecated use {@link #getRootPaths()} instead\n     */\n    @Deprecated\n    Path getRootPath();\n}\n"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/Version.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api;\n", "package org.portinglab.fabricloader.loader.api;\n\nimport org.portinglab.fabricloader.loader.impl.util.version.VersionParser;\n\n/**\n * Represents a version of a mod.\n *\n * @see org.portinglab.fabricloader.loader.api.metadata.ModMetadata#getVersion()\n */\npublic interface Version extends Comparable<Version> {\n    /**\n     * Returns the user-friendly representation of this version.\n     */\n    String getFriendlyString();\n\n    /**\n     * Parses a version from a string notation.\n     *\n     * @param string the string notation of the version\n     * @return the parsed version\n     * @throws VersionParsingException if a problem arises during version parsing\n     */\n    static Version parse(String string) throws VersionParsingException {\n        return VersionParser.parse(string, false);\n    }\n}", " */\npublic interface Version extends Comparable<Version> {\n    /**\n     * Returns the user-friendly representation of this version.\n     */\n    String getFriendlyString();\n\n    /**\n     * Parses a version from a string notation.\n     *\n     * @param string the string notation of the version\n     * @return the parsed version\n     * @throws VersionParsingException if a problem arises during version parsing\n     */\n    static Version parse(String string) throws VersionParsingException {\n        return VersionParser.parse(string, false);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/metadata/ModMetadata.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api.metadata;\n", "package org.portinglab.fabricloader.loader.api.metadata;\n\nimport java.util.Collection;\nimport java.util.Optional;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport org.portinglab.forgedfabric.loader.api.metadata.ForgeContact;\n\n/**\n * The metadata of a mod.", "/**\n * The metadata of a mod.\n */\npublic interface ModMetadata {\n    /**\n     * Returns the mod's ID.\n     *\n     * <p>A mod's id must have only lowercase letters, digits, {@code _}.</p>\n     *\n     * @return the mod's ID.\n     */\n    String getId();\n\n    /**\n     * Returns the mod's version.\n     */\n    String getVersion();\n\n    /**\n     * Returns the mod's environment.\n     */\n    Dist getEnvironment();\n\n    /**\n     * Returns the mod's display name.\n     */\n    String getName();\n\n    /**\n     * Returns the mod's description.\n     */\n    String getDescription();\n\n    /**\n     * Returns the mod's authors.\n     */\n    Collection<String> getAuthors();\n\n    /**\n     * Returns the mod's contact information.\n     */\n    ForgeContact getContact();\n\n    /**\n     * Returns the mod's licenses.\n     */\n    Collection<String> getLicense();\n\n    /**\n     * Gets the path to an icon.\n     *\n     * <p>The standard defines icons as square .PNG files, however their\n     * dimensions are not defined - in particular, they are not\n     * guaranteed to be a power of two.</p>\n     *\n     * <p>The preferred size is used in the following manner:\n     * <ul><li>the smallest image larger than or equal to the size\n     * is returned, if one is present;</li>\n     * <li>failing that, the largest image is returned.</li></ul></p>\n     *\n     * @param size the preferred size\n     * @return the icon path, if any\n     */\n    Optional<String> getIconPath(int size);\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/entrypoint/PreLaunchEntrypoint.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api.entrypoint;\n", "package org.portinglab.fabricloader.loader.api.entrypoint;\n\n/**\n * Entrypoint getting invoked just before launching the game.\n *\n * <p><b>Avoid interfering with the game from this!</b> Accessing anything needs careful consideration to avoid\n * interfering with its own initialization or otherwise harming its state. It is recommended to implement this interface\n * on its own class to avoid running static initializers too early, e.g. because they were referenced in field or method\n * signatures in the same class.\n *", " * signatures in the same class.\n *\n * <p>The entrypoint is exposed with {@code preLaunch} key in the mod json and runs for any environment. It usually\n * executes several seconds before the {@code main}/{@code client}/{@code server} entrypoints.\n *\n * @see org.portinglab.fabricloader.loader.api.FabricLoader#getEntrypointContainers(String, Class)\n */\n@FunctionalInterface\npublic interface PreLaunchEntrypoint {\n    /**\n     * Runs the entrypoint.\n     */\n    void onPreLaunch();\n}", "public interface PreLaunchEntrypoint {\n    /**\n     * Runs the entrypoint.\n     */\n    void onPreLaunch();\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/api/entrypoint/EntrypointContainer.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.api.entrypoint;\n", "package org.portinglab.fabricloader.loader.api.entrypoint;\n\nimport org.portinglab.fabricloader.loader.api.ModContainer;\n\n/**\n * A container holding both an entrypoint instance and the {@link ModContainer} which has provided the entrypoint.\n *\n * @param <T> The type of the entrypoint\n * @see org.portinglab.fabricloader.loader.api.FabricLoader#getEntrypointContainers(String, Class)\n */\npublic interface EntrypointContainer<T> {\n    /**\n     * Returns the entrypoint instance. It will be constructed the first time you call this method.\n     */\n    T getEntrypoint();\n\n    /**\n     * Returns the mod that provided this entrypoint.\n     */\n    ModContainer getProvider();\n}", " * @see org.portinglab.fabricloader.loader.api.FabricLoader#getEntrypointContainers(String, Class)\n */\npublic interface EntrypointContainer<T> {\n    /**\n     * Returns the entrypoint instance. It will be constructed the first time you call this method.\n     */\n    T getEntrypoint();\n\n    /**\n     * Returns the mod that provided this entrypoint.\n     */\n    ModContainer getProvider();\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/FabricLoaderImpl.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl;\n", "package org.portinglab.fabricloader.loader.impl;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;", "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.portinglab.fabricloader.loader.api.ModContainer;\nimport org.portinglab.fabricloader.loader.api.entrypoint.EntrypointContainer;\nimport org.portinglab.fabricloader.loader.impl.entrypoint.EntrypointStorage;\nimport net.minecraftforge.api.distmarker.Dist;", "import org.portinglab.fabricloader.loader.impl.entrypoint.EntrypointStorage;\nimport net.minecraftforge.api.distmarker.Dist;\nimport org.portinglab.forgedfabric.loader.api.ForgePatch;\nimport org.portinglab.forgedfabric.loader.api.launch.ForgeModEnv;\n\n@SuppressWarnings(\"deprecation\")\npublic final class FabricLoaderImpl extends org.portinglab.fabricloader.legacyloader.FabricLoader {\n    public static final FabricLoaderImpl INSTANCE = InitHelper.get();\n\n    protected final Map<String, ModContainer> modMap = new HashMap<>();\n    protected List<ModContainer> mods = new ArrayList<>();\n\n    private final EntrypointStorage entrypointStorage = new EntrypointStorage();\n\n    private Object gameInstance;\n\n    private Path gameDir;\n    private Path configDir;\n\n    private FabricLoaderImpl() {\n        setGameDir(ForgePatch.getGameDir());\n    }\n\n    private void setGameDir(Path gameDir) {\n        this.gameDir = gameDir;\n        this.configDir = gameDir.resolve(\"config\");\n    }\n    @Override", "    public Object getGameInstance() {\n        return gameInstance;\n    }\n\n    @Override\n    public Dist getEnvironmentType() {\n        return ForgeModEnv.getEnvironment().getEnvType();\n    }\n\n    /**\n     * @return The game instance's root directory.\n     */\n    @Override", "    public Path getGameDir() {\n        if (gameDir == null) throw new IllegalStateException(\"invoked too early?\");\n\n        return gameDir;\n    }\n\n    @Override\n    @Deprecated\n    public File getGameDirectory() {\n        return getGameDir().toFile();\n    }\n\n    /**\n     * @return The game instance's configuration directory.\n     */\n    @Override", "    public File getGameDirectory() {\n        return getGameDir().toFile();\n    }\n\n    /**\n     * @return The game instance's configuration directory.\n     */\n    @Override\n    public Path getConfigDir() {\n        if (!Files.exists(configDir)) {\n            try {\n                Files.createDirectories(configDir);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Creating config directory\", e);\n            }\n        }\n\n        return configDir;\n    }\n\n    @Override\n    @Deprecated", "    public Path getConfigDir() {\n        if (!Files.exists(configDir)) {\n            try {\n                Files.createDirectories(configDir);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Creating config directory\", e);\n            }\n        }\n\n        return configDir;\n    }\n\n    @Override\n    @Deprecated", "    public File getConfigDirectory() {\n        return getConfigDir().toFile();\n    }\n\n    @Override\n    public String[] getLaunchArguments(boolean sanitize) {\n        return new String[0];\n    }\n\n    public boolean hasEntrypoints(String key) {\n        return entrypointStorage.hasEntrypoints(key);\n    }\n\n    @Override\n    public <T> List<T> getEntrypoints(String key, Class<T> type) {\n        return entrypointStorage.getEntrypoints(key, type);\n    }\n\n    @Override\n    public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {\n        return entrypointStorage.getEntrypointContainers(key, type);\n    }\n\n    @Override\n    public Optional<ModContainer> getModContainer(String id) {\n        return Optional.ofNullable(modMap.get(id));\n    }\n\n    @Override\n    public Collection<ModContainer> getAllMods() {\n        return Collections.unmodifiableList(mods);\n    }\n\n    public List<ModContainer> getModsInternal() {\n        return mods;\n    }\n\n    @Override", "    public boolean hasEntrypoints(String key) {\n        return entrypointStorage.hasEntrypoints(key);\n    }\n\n    @Override\n    public <T> List<T> getEntrypoints(String key, Class<T> type) {\n        return entrypointStorage.getEntrypoints(key, type);\n    }\n\n    @Override\n    public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {\n        return entrypointStorage.getEntrypointContainers(key, type);\n    }\n\n    @Override\n    public Optional<ModContainer> getModContainer(String id) {\n        return Optional.ofNullable(modMap.get(id));\n    }\n\n    @Override\n    public Collection<ModContainer> getAllMods() {\n        return Collections.unmodifiableList(mods);\n    }\n\n    public List<ModContainer> getModsInternal() {\n        return mods;\n    }\n\n    @Override", "    public boolean isModLoaded(String id) {\n        return modMap.containsKey(id);\n    }\n\n    @Override\n    public boolean isDevelopmentEnvironment() {\n        return ForgeModEnv.getEnvironment().isDevelopment();\n    }\n\n    /**\n     * Sets the game instance. This is only used in 20w22a+ by the dedicated server and should not be called by anything else.\n     */", "    public void setGameInstance(Object gameInstance) {\n        if (getEnvironmentType() != Dist.DEDICATED_SERVER) {\n            throw new UnsupportedOperationException(\"Cannot set game instance on a client!\");\n        }\n\n        if (this.gameInstance != null) {\n            throw new UnsupportedOperationException(\"Cannot overwrite current game instance!\");\n        }\n\n        this.gameInstance = gameInstance;\n    }\n", "    public static class InitHelper {\n        private static FabricLoaderImpl instance;\n\n        public static FabricLoaderImpl get() {\n            if (instance == null) instance = new FabricLoaderImpl();\n\n            return instance;\n        }\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/metadata/ModMetadataImpl.java", "chunked_list": ["package org.portinglab.fabricloader.loader.impl.metadata;\n\nimport org.portinglab.fabricloader.loader.api.FabricLoader;\nimport org.portinglab.fabricloader.loader.api.ModContainer;\nimport org.portinglab.fabricloader.loader.api.metadata.ModMetadata;\nimport net.minecraftforge.api.distmarker.Dist;\nimport org.portinglab.forgedfabric.loader.api.launch.ForgeModEnv;\nimport org.portinglab.forgedfabric.loader.api.metadata.ForgeContact;\nimport org.portinglab.forgedfabric.loader.api.metadata.ForgeModMetadata;\n", "import org.portinglab.forgedfabric.loader.api.metadata.ForgeModMetadata;\n\nimport java.util.Collection;\nimport java.util.Optional;\n\npublic class ModMetadataImpl implements ModMetadata {\n    private final ModContainer modContainer;\n    private final ForgeModMetadata modMetadata;\n    public ModMetadataImpl(String id) {\n        this.modContainer = FabricLoader.getInstance().getModContainer(id).get();\n        this.modMetadata = (ForgeModMetadata) modContainer.getMetadata();\n    }\n    @Override", "    public String getId() {\n        return modMetadata.getId();\n    }\n\n    @Override\n    public String getVersion() {\n        return modMetadata.getVersion();\n    }\n\n    @Override\n    public Dist getEnvironment() {\n        return ForgeModEnv.getEnvironment().getEnvType();\n    }\n\n    @Override", "    public Dist getEnvironment() {\n        return ForgeModEnv.getEnvironment().getEnvType();\n    }\n\n    @Override\n    public String getName() {\n        return modMetadata.getName();\n    }\n\n    @Override\n    public String getDescription() {\n        return modMetadata.getDescription();\n    }\n\n    @Override\n    public Collection<String> getAuthors() {\n        return modMetadata.getAuthors();\n    }\n\n    @Override", "    public String getDescription() {\n        return modMetadata.getDescription();\n    }\n\n    @Override\n    public Collection<String> getAuthors() {\n        return modMetadata.getAuthors();\n    }\n\n    @Override\n    public ForgeContact getContact() {\n        return modMetadata.getContact();\n    }\n\n    @Override\n    public Collection<String> getLicense() {\n        return modMetadata.getLicense();\n    }\n\n    @Override\n    public Optional<String> getIconPath(int size) {\n        return modMetadata.getIconPath(size);\n    }\n}\n", "    public ForgeContact getContact() {\n        return modMetadata.getContact();\n    }\n\n    @Override\n    public Collection<String> getLicense() {\n        return modMetadata.getLicense();\n    }\n\n    @Override\n    public Optional<String> getIconPath(int size) {\n        return modMetadata.getIconPath(size);\n    }\n}\n"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/util/version/SemanticVersionImpl.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl.util.version;\n", "package org.portinglab.fabricloader.loader.impl.util.version;\n\nimport org.portinglab.fabricloader.loader.api.SemanticVersion;\nimport org.portinglab.fabricloader.loader.api.Version;\nimport org.portinglab.fabricloader.loader.api.VersionParsingException;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.StringTokenizer;", "import java.util.Optional;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\n/**\n * Parser for a superset of the semantic version format described at <a href=\"https://semver.org\">semver.org</a>.\n *\n * <p>This superset allows additionally\n * <ul><li>Arbitrary number of {@code <version core>} components, but at least 1\n * <li>{@code x}, {@code X} or {@code *} for the last {@code <version core>} component with {@code storeX} if not the first", " * <ul><li>Arbitrary number of {@code <version core>} components, but at least 1\n * <li>{@code x}, {@code X} or {@code *} for the last {@code <version core>} component with {@code storeX} if not the first\n * <li>Arbitrary {@code <build>} contents\n * </ul>\n */\n@SuppressWarnings(\"deprecation\")\npublic class SemanticVersionImpl extends org.portinglab.fabricloader.legacyloader.util.version.SemanticVersionImpl implements SemanticVersion {\n    private static final Pattern DOT_SEPARATED_ID = Pattern.compile(\"|[-0-9A-Za-z]+(\\\\.[-0-9A-Za-z]+)*\");\n    private static final Pattern UNSIGNED_INTEGER = Pattern.compile(\"0|[1-9][0-9]*\");\n    private final int[] components;\n    private final String prerelease;\n    private final String build;\n    private String friendlyName;\n\n    public SemanticVersionImpl(String version, boolean storeX) throws VersionParsingException {\n        int buildDelimPos = version.indexOf('+');\n", "        if (buildDelimPos >= 0) {\n            build = version.substring(buildDelimPos + 1);\n            version = version.substring(0, buildDelimPos);\n        } else {\n            build = null;\n        }\n\n        int dashDelimPos = version.indexOf('-');\n\n        if (dashDelimPos >= 0) {\n            prerelease = version.substring(dashDelimPos + 1);\n            version = version.substring(0, dashDelimPos);\n        } else {\n            prerelease = null;\n        }\n", "        if (dashDelimPos >= 0) {\n            prerelease = version.substring(dashDelimPos + 1);\n            version = version.substring(0, dashDelimPos);\n        } else {\n            prerelease = null;\n        }\n\n        if (prerelease != null && !DOT_SEPARATED_ID.matcher(prerelease).matches()) {\n            throw new VersionParsingException(\"Invalid prerelease string '\" + prerelease + \"'!\");\n        }\n", "        if (version.endsWith(\".\")) {\n            throw new VersionParsingException(\"Negative version number component found!\");\n        } else if (version.startsWith(\".\")) {\n            throw new VersionParsingException(\"Missing version component!\");\n        }\n\n        String[] componentStrings = version.split(\"\\\\.\");\n\n        if (componentStrings.length < 1) {\n            throw new VersionParsingException(\"Did not provide version numbers!\");\n        }\n\n        int[] components = new int[componentStrings.length];\n        int firstWildcardIdx = -1;\n", "        if (componentStrings.length < 1) {\n            throw new VersionParsingException(\"Did not provide version numbers!\");\n        }\n\n        int[] components = new int[componentStrings.length];\n        int firstWildcardIdx = -1;\n\n        for (int i = 0; i < componentStrings.length; i++) {\n            String compStr = componentStrings[i];\n\n            if (storeX) {", "            if (storeX) {\n                if (compStr.equals(\"x\") || compStr.equals(\"X\") || compStr.equals(\"*\")) {\n                    if (prerelease != null) {\n                        throw new VersionParsingException(\"Pre-release versions are not allowed to use X-ranges!\");\n                    }\n\n                    components[i] = COMPONENT_WILDCARD;\n                    if (firstWildcardIdx < 0) firstWildcardIdx = i;\n                    continue;\n                } else if (i > 0 && components[i - 1] == COMPONENT_WILDCARD) {\n                    throw new VersionParsingException(\"Interjacent wildcard (1.x.2) are disallowed!\");\n                }\n            }\n", "                } else if (i > 0 && components[i - 1] == COMPONENT_WILDCARD) {\n                    throw new VersionParsingException(\"Interjacent wildcard (1.x.2) are disallowed!\");\n                }\n            }\n\n            if (compStr.trim().isEmpty()) {\n                throw new VersionParsingException(\"Missing version number component!\");\n            }\n\n            try {\n                components[i] = Integer.parseInt(compStr);\n", "            try {\n                components[i] = Integer.parseInt(compStr);\n\n                if (components[i] < 0) {\n                    throw new VersionParsingException(\"Negative version number component '\" + compStr + \"'!\");\n                }\n            } catch (NumberFormatException e) {\n                throw new VersionParsingException(\"Could not parse version number component '\" + compStr + \"'!\", e);\n            }\n        }\n", "        if (storeX && components.length == 1 && components[0] == COMPONENT_WILDCARD) {\n            throw new VersionParsingException(\"Versions of form 'x' or 'X' not allowed!\");\n        }\n\n        // strip extra wildcards (1.x.x -> 1.x)\n        if (firstWildcardIdx > 0 && components.length > firstWildcardIdx + 1) {\n            components = Arrays.copyOf(components, firstWildcardIdx + 1);\n        }\n\n        this.components = components;\n\n        buildFriendlyName();\n    }\n\n    public SemanticVersionImpl(int[] components, String prerelease, String build) {", "        if (components.length == 0 || components[0] == COMPONENT_WILDCARD) throw new IllegalArgumentException(\"Invalid components: \"+Arrays.toString(components));\n\n        this.components = components;\n        this.prerelease = prerelease;\n        this.build = build;\n\n        buildFriendlyName();\n    }\n\n    private void buildFriendlyName() {\n        StringBuilder fnBuilder = new StringBuilder();\n        boolean first = true;\n", "        for (int i : components) {\n            if (first) {\n                first = false;\n            } else {\n                fnBuilder.append('.');\n            }\n\n            if (i == COMPONENT_WILDCARD) {\n                fnBuilder.append('x');\n            } else {\n                fnBuilder.append(i);\n            }\n        }\n", "        if (prerelease != null) {\n            fnBuilder.append('-').append(prerelease);\n        }\n\n        if (build != null) {\n            fnBuilder.append('+').append(build);\n        }\n\n        friendlyName = fnBuilder.toString();\n    }\n\n    @Override", "    public int getVersionComponentCount() {\n        return components.length;\n    }\n\n    @Override\n    public int getVersionComponent(int pos) {\n        if (pos < 0) {\n            throw new RuntimeException(\"Tried to access negative version number component!\");\n        } else if (pos >= components.length) {\n            // Repeat \"x\" if x-range, otherwise repeat \"0\".\n            return components[components.length - 1] == COMPONENT_WILDCARD ? COMPONENT_WILDCARD : 0;\n        } else {\n            return components[pos];\n        }\n    }\n\n    public int[] getVersionComponents() {\n        return components.clone();\n    }\n\n    @Override\n    public Optional<String> getPrereleaseKey() {\n        return Optional.ofNullable(prerelease);\n    }\n\n    @Override\n    public Optional<String> getBuildKey() {\n        return Optional.ofNullable(build);\n    }\n\n    @Override", "        } else if (pos >= components.length) {\n            // Repeat \"x\" if x-range, otherwise repeat \"0\".\n            return components[components.length - 1] == COMPONENT_WILDCARD ? COMPONENT_WILDCARD : 0;\n        } else {\n            return components[pos];\n        }\n    }\n\n    public int[] getVersionComponents() {\n        return components.clone();\n    }\n\n    @Override\n    public Optional<String> getPrereleaseKey() {\n        return Optional.ofNullable(prerelease);\n    }\n\n    @Override\n    public Optional<String> getBuildKey() {\n        return Optional.ofNullable(build);\n    }\n\n    @Override", "    public String getFriendlyString() {\n        return friendlyName;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof SemanticVersionImpl)) {\n            return false;\n        } else {\n            SemanticVersionImpl other = (SemanticVersionImpl) o;\n", "            if (!equalsComponentsExactly(other)) {\n                return false;\n            }\n\n            return Objects.equals(prerelease, other.prerelease) && Objects.equals(build, other.build);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(components) * 73 + (prerelease != null ? prerelease.hashCode() * 11 : 0) + (build != null ? build.hashCode() : 0);\n    }\n\n    @Override", "    public int hashCode() {\n        return Arrays.hashCode(components) * 73 + (prerelease != null ? prerelease.hashCode() * 11 : 0) + (build != null ? build.hashCode() : 0);\n    }\n\n    @Override\n    public String toString() {\n        return getFriendlyString();\n    }\n\n    @Override\n    public boolean hasWildcard() {", "    public boolean hasWildcard() {\n        for (int i : components) {\n            if (i < 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean equalsComponentsExactly(SemanticVersionImpl other) {", "    public boolean equalsComponentsExactly(SemanticVersionImpl other) {\n        for (int i = 0; i < Math.max(getVersionComponentCount(), other.getVersionComponentCount()); i++) {\n            if (getVersionComponent(i) != other.getVersionComponent(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    @Override", "    public int compareTo(Version other) {\n        if (!(other instanceof SemanticVersion)) {\n            return getFriendlyString().compareTo(other.getFriendlyString());\n        }\n\n        SemanticVersion o = (SemanticVersion) other;\n\n        for (int i = 0; i < Math.max(getVersionComponentCount(), o.getVersionComponentCount()); i++) {\n            int first = getVersionComponent(i);\n            int second = o.getVersionComponent(i);\n", "            if (first == COMPONENT_WILDCARD || second == COMPONENT_WILDCARD) {\n                continue;\n            }\n\n            int compare = Integer.compare(first, second);\n            if (compare != 0) return compare;\n        }\n\n        Optional<String> prereleaseA = getPrereleaseKey();\n        Optional<String> prereleaseB = o.getPrereleaseKey();\n", "        if (prereleaseA.isPresent() || prereleaseB.isPresent()) {\n            if (prereleaseA.isPresent() && prereleaseB.isPresent()) {\n                StringTokenizer prereleaseATokenizer = new StringTokenizer(prereleaseA.get(), \".\");\n                StringTokenizer prereleaseBTokenizer = new StringTokenizer(prereleaseB.get(), \".\");\n\n                while (prereleaseATokenizer.hasMoreElements()) {\n                    if (prereleaseBTokenizer.hasMoreElements()) {\n                        String partA = prereleaseATokenizer.nextToken();\n                        String partB = prereleaseBTokenizer.nextToken();\n\n                        if (UNSIGNED_INTEGER.matcher(partA).matches()) {", "                        if (UNSIGNED_INTEGER.matcher(partA).matches()) {\n                            if (UNSIGNED_INTEGER.matcher(partB).matches()) {\n                                int compare = Integer.compare(partA.length(), partB.length());\n                                if (compare != 0) return compare;\n                            } else {\n                                return -1;\n                            }\n                        } else {\n                            if (UNSIGNED_INTEGER.matcher(partB).matches()) {\n                                return 1;\n                            }\n                        }\n\n                        int compare = partA.compareTo(partB);", "                            if (UNSIGNED_INTEGER.matcher(partB).matches()) {\n                                return 1;\n                            }\n                        }\n\n                        int compare = partA.compareTo(partB);\n                        if (compare != 0) return compare;\n                    } else {\n                        return 1;\n                    }\n                }\n\n                return prereleaseBTokenizer.hasMoreElements() ? -1 : 0;", "            } else if (prereleaseA.isPresent()) {\n                return o.hasWildcard() ? 0 : -1;\n            } else { // prereleaseB.isPresent()\n                return hasWildcard() ? 0 : 1;\n            }\n        } else {\n            return 0;\n        }\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/util/version/StringVersion.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl.util.version;\n", "package org.portinglab.fabricloader.loader.impl.util.version;\n\nimport org.portinglab.fabricloader.loader.api.Version;\n\npublic class StringVersion implements Version {\n    private final String version;\n\n    public StringVersion(String version) {\n        this.version = version;\n    }\n\n    @Override", "    public String getFriendlyString() {\n        return version;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof StringVersion) {\n            return version.equals(((StringVersion) obj).version);\n        } else {\n            return false;\n        }\n    }\n\n    @Override", "    public int compareTo(Version o) {\n        return getFriendlyString().compareTo(o.getFriendlyString());\n    }\n\n    @Override\n    public String toString() {\n        return version;\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/util/version/VersionParser.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl.util.version;\n", "package org.portinglab.fabricloader.loader.impl.util.version;\n\nimport org.portinglab.fabricloader.loader.api.SemanticVersion;\nimport org.portinglab.fabricloader.loader.api.Version;\nimport org.portinglab.fabricloader.loader.api.VersionParsingException;\n\npublic final class VersionParser {\n    public static Version parse(String s, boolean storeX) throws VersionParsingException {\n        if (s == null || s.isEmpty()) {\n            throw new VersionParsingException(\"Version must be a non-empty string!\");\n        }\n\n        Version version;\n", "        if (s == null || s.isEmpty()) {\n            throw new VersionParsingException(\"Version must be a non-empty string!\");\n        }\n\n        Version version;\n\n        try {\n            version = new SemanticVersionImpl(s, storeX);\n        } catch (VersionParsingException e) {\n            version = new StringVersion(s);\n        }\n\n        return version;\n    }\n", "    public static SemanticVersion parseSemantic(String s) throws VersionParsingException {\n        if (s == null || s.isEmpty()) {\n            throw new VersionParsingException(\"Version must be a non-empty string!\");\n        }\n\n        return new SemanticVersionImpl(s, false);\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/entrypoint/EntrypointStorage.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl.entrypoint;\n", "package org.portinglab.fabricloader.loader.impl.entrypoint;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.portinglab.fabricloader.loader.api.EntrypointException;", "\nimport org.portinglab.fabricloader.loader.api.EntrypointException;\nimport org.portinglab.fabricloader.loader.api.ModContainer;\nimport org.portinglab.fabricloader.loader.api.entrypoint.EntrypointContainer;\n\npublic final class EntrypointStorage {\n    interface Entry {\n        <T> T getOrCreate(Class<T> type) throws Exception;\n        boolean isOptional();\n\n        ModContainer getModContainer();\n    }\n\n    @SuppressWarnings(\"deprecation\")", "    private static class OldEntry implements Entry {\n        private final ModContainer mod;\n        private final String value;\n        private Object object;\n\n        private OldEntry(ModContainer mod, String value) {\n            this.mod = mod;\n            this.value = value;\n        }\n\n        @Override", "        public String toString() {\n            return mod.getMetadata().getId() + \"->\" + value;\n        }\n\n        @SuppressWarnings({ \"unchecked\" })\n        @Override\n        public synchronized <T> T getOrCreate(Class<T> type) throws Exception {\n            if (object == null || !type.isAssignableFrom(object.getClass())) {\n                return null;\n            } else {\n                return (T) object;\n            }\n        }\n\n        @Override", "        public boolean isOptional() {\n            return true;\n        }\n\n        @Override\n        public ModContainer getModContainer() {\n            return mod;\n        }\n    }\n\n    private static final class NewEntry implements Entry {\n        private final ModContainer mod;\n        private final String value;\n        private final Map<Class<?>, Object> instanceMap;\n\n        NewEntry(ModContainer mod, String value) {\n            this.mod = mod;\n            this.value = value;\n            this.instanceMap = new IdentityHashMap<>(1);\n        }\n\n        @Override", "    private static final class NewEntry implements Entry {\n        private final ModContainer mod;\n        private final String value;\n        private final Map<Class<?>, Object> instanceMap;\n\n        NewEntry(ModContainer mod, String value) {\n            this.mod = mod;\n            this.value = value;\n            this.instanceMap = new IdentityHashMap<>(1);\n        }\n\n        @Override", "        public String toString() {\n            return mod.getMetadata().getId() + \"->(0.3.x)\" + value;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public synchronized <T> T getOrCreate(Class<T> type) throws Exception {\n            // this impl allows reentrancy (unlike computeIfAbsent)\n            T ret = (T) instanceMap.get(type);\n\n            if (ret == null) {\n                assert ret != null;\n                T prev = (T) instanceMap.putIfAbsent(type, ret);", "            if (ret == null) {\n                assert ret != null;\n                T prev = (T) instanceMap.putIfAbsent(type, ret);\n                if (prev != null) ret = prev;\n            }\n\n            return ret;\n        }\n\n        @Override\n        public boolean isOptional() {\n            return false;\n        }\n\n        @Override", "        public boolean isOptional() {\n            return false;\n        }\n\n        @Override\n        public ModContainer getModContainer() {\n            return mod;\n        }\n    }\n\n    private final Map<String, List<Entry>> entryMap = new HashMap<>();\n\n    private List<Entry> getOrCreateEntries(String key) {\n        return entryMap.computeIfAbsent(key, (z) -> new ArrayList<>());\n    }\n", "    public boolean hasEntrypoints(String key) {\n        return entryMap.containsKey(key);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    public <T> List<T> getEntrypoints(String key, Class<T> type) {\n        List<Entry> entries = entryMap.get(key);\n        if (entries == null) return Collections.emptyList();\n\n        EntrypointException exception = null;\n        List<T> results = new ArrayList<>(entries.size());\n", "        for (Entry entry : entries) {\n            try {\n                T result = entry.getOrCreate(type);\n\n                if (result != null) {\n                    results.add(result);\n                }\n            } catch (Throwable t) {\n                if (exception == null) {\n                    exception = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);\n                } else {\n                    exception.addSuppressed(t);\n                }\n            }\n        }\n", "                if (exception == null) {\n                    exception = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);\n                } else {\n                    exception.addSuppressed(t);\n                }\n            }\n        }\n\n        if (exception != null) {\n            throw exception;\n        }\n\n        return results;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {\n        List<Entry> entries = entryMap.get(key);", "        if (exception != null) {\n            throw exception;\n        }\n\n        return results;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {\n        List<Entry> entries = entryMap.get(key);\n        if (entries == null) return Collections.emptyList();\n\n        List<EntrypointContainer<T>> results = new ArrayList<>(entries.size());\n        EntrypointException exc = null;\n", "        if (entries == null) return Collections.emptyList();\n\n        List<EntrypointContainer<T>> results = new ArrayList<>(entries.size());\n        EntrypointException exc = null;\n\n        for (Entry entry : entries) {\n            EntrypointContainerImpl<T> container;\n\n            if (entry.isOptional()) {\n                try {\n                    T instance = entry.getOrCreate(type);", "            if (entry.isOptional()) {\n                try {\n                    T instance = entry.getOrCreate(type);\n                    if (instance == null) continue;\n\n                    container = new EntrypointContainerImpl<>(entry, instance);\n                } catch (Throwable t) {\n                    if (exc == null) {\n                        exc = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);\n                    } else {\n                        exc.addSuppressed(t);\n                    }\n\n                    continue;\n                }\n            } else {\n                container = new EntrypointContainerImpl<>(key, type, entry);\n            }\n\n            results.add(container);\n        }\n", "        if (exc != null) throw exc;\n\n        return results;\n    }\n\n    @SuppressWarnings(\"unchecked\") // return value allows \"throw\" declaration to end method\n    static <E extends Throwable> RuntimeException sneakyThrows(Throwable ex) throws E {\n        throw (E) ex;\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/fabricloader/loader/impl/entrypoint/EntrypointContainerImpl.java", "chunked_list": ["/*\n * Copyright 2016 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.portinglab.fabricloader.loader.impl.entrypoint;\n", "package org.portinglab.fabricloader.loader.impl.entrypoint;\n\nimport org.portinglab.fabricloader.loader.api.EntrypointException;\nimport org.portinglab.fabricloader.loader.api.ModContainer;\nimport org.portinglab.fabricloader.loader.api.entrypoint.EntrypointContainer;\n\npublic final class EntrypointContainerImpl<T> implements EntrypointContainer<T> {\n    private final String key;\n    private final Class<T> type;\n    private final EntrypointStorage.Entry entry;\n    private T instance;\n\n    /**\n     * Create EntrypointContainer with lazy init.\n     */\n    public EntrypointContainerImpl(String key, Class<T> type, EntrypointStorage.Entry entry) {\n        this.key = key;\n        this.type = type;\n        this.entry = entry;\n    }\n\n    /**\n     * Create EntrypointContainer without lazy init.\n     */\n    public EntrypointContainerImpl(EntrypointStorage.Entry entry, T instance) {\n        this.key = null;\n        this.type = null;\n        this.entry = entry;\n        this.instance = instance;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override", "    public synchronized T getEntrypoint() {\n        if (instance == null) {\n            try {\n                instance = entry.getOrCreate(type);\n                assert instance != null;\n            } catch (Exception ex) {\n                throw new EntrypointException(key, getProvider().getMetadata().getId(), ex);\n            }\n        }\n\n        return instance;\n    }\n\n    @Override", "    public ModContainer getProvider() {\n        return entry.getModContainer();\n    }\n}"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/ForgedFabricLoader.java", "chunked_list": ["package org.portinglab.forgedfabric.loader;\n\nimport net.minecraftforge.fml.common.Mod;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Mod(ForgedFabricLoader.MODID)\npublic class ForgedFabricLoader {\n    public static final String MODID = \"forgedfabricloader\";\n    public static final String MODNAME = \"ForgedFabricLoaderAPI\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MODNAME);\n\n    public ForgedFabricLoader() {\n\n    }\n}\n", "    public static final String MODID = \"forgedfabricloader\";\n    public static final String MODNAME = \"ForgedFabricLoaderAPI\";\n    public static final Logger LOGGER = LoggerFactory.getLogger(MODNAME);\n\n    public ForgedFabricLoader() {\n\n    }\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/api/ForgePatch.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.api;\n\nimport net.minecraftforge.fml.loading.FMLPaths;\n\nimport java.nio.file.Path;\n\npublic class ForgePatch {\n    public static final Path gameDir = FMLPaths.GAMEDIR.get();\n\n    public static Path getGameDir() {\n        return gameDir;\n    }\n", "    public static Path getGameDir() {\n        return gameDir;\n    }\n\n    public static Path getModDir() {\n        return getGameDir().resolve(\"mods\");\n    }\n\n    public static Path getConfigDir() {\n        return getGameDir().resolve(\"config\");\n    }\n\n\n}\n", "    public static Path getConfigDir() {\n        return getGameDir().resolve(\"config\");\n    }\n\n\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/api/launch/ForgeModEnv.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.api.launch;\n\npublic class ForgeModEnv {\n    private static ForgeEnv forgeEnv;\n    public static ForgeEnv getEnvironment() {\n        return forgeEnv;\n    }\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/api/launch/ForgeEnv.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.api.launch;\n\nimport net.minecraftforge.api.distmarker.Dist;\n\npublic interface ForgeEnv {\n    Dist getEnvType();\n    boolean isDevelopment();\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/api/metadata/ForgeContact.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.api.metadata;\n\nimport net.minecraftforge.forgespi.language.IConfigurable;\n\npublic interface ForgeContact extends IConfigurable {\n\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/api/metadata/ForgeModMetadata.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.api.metadata;\n\nimport java.util.Collection;\nimport java.util.Optional;\n\npublic interface ForgeModMetadata {\n    String getId();\n    String getVersion();\n    String getName();\n    String getDescription();\n    Collection<String> getAuthors();\n    Optional<String> getIssueTracker();\n    Optional<String> getModLink();\n    Collection<String> getLicense();\n    ForgeContact getContact();\n    Optional<String> getIconPath(int size);\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/impl/launch/ForgeEnvImpl.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.impl.launch;\n\nimport net.minecraftforge.api.distmarker.Dist;\nimport net.minecraftforge.fml.loading.FMLLoader;\nimport org.portinglab.forgedfabric.loader.api.launch.ForgeEnv;\n\npublic class ForgeEnvImpl implements ForgeEnv {\n    @Override\n    public Dist getEnvType() {\n        return FMLLoader.getDist();\n    }\n\n    @Override", "    public Dist getEnvType() {\n        return FMLLoader.getDist();\n    }\n\n    @Override\n    public boolean isDevelopment() {\n        return !FMLLoader.isProduction();\n    }\n}\n"]}
{"filename": "src/main/java/org/portinglab/forgedfabric/loader/impl/metadata/ForgeModMetadataImpl.java", "chunked_list": ["package org.portinglab.forgedfabric.loader.impl.metadata;\n\nimport net.minecraftforge.fml.ModList;\nimport net.minecraftforge.fml.loading.moddiscovery.ModFileInfo;\nimport net.minecraftforge.forgespi.language.IModFileInfo;\nimport net.minecraftforge.forgespi.language.IModInfo;\nimport org.portinglab.forgedfabric.loader.api.metadata.ForgeContact;\nimport org.portinglab.forgedfabric.loader.api.metadata.ForgeModMetadata;\n\nimport java.net.URL;", "\nimport java.net.URL;\nimport java.util.*;\n\npublic class ForgeModMetadataImpl implements ForgeModMetadata {\n    public final IModInfo modInfo;\n\n    public ForgeModMetadataImpl(String id) {\n        this.modInfo = ModList.get().getMods().stream().filter(modMetadata -> Objects.equals(modMetadata.getModId(), id)).findAny().orElseThrow();\n    }\n\n    @Override", "    public String getId() {\n        return modInfo.getModId();\n    }\n\n    @Override\n    public String getVersion() {\n        return modInfo.getVersion().toString();\n    }\n\n    @Override\n    public String getName() {\n        return modInfo.getDisplayName();\n    }\n\n    @Override", "    public String getName() {\n        return modInfo.getDisplayName();\n    }\n\n    @Override\n    public String getDescription() {\n        return modInfo.getDescription();\n    }\n\n    @Override\n    public Collection<String> getAuthors() {\n        Optional<String> optional = this.modInfo.getConfig().getConfigElement(\"authors\").map(String::valueOf);\n        return optional.isPresent() ? Collections.singleton(optional.get()) : Collections.emptyList();\n    }\n\n    @Override\n    public Optional<String> getIssueTracker() {\n        IModFileInfo owningFile = this.modInfo.getOwningFile();", "        if (owningFile instanceof ModFileInfo info) {\n            return Optional.ofNullable(info.getIssueURL())\n                    .map(URL::toString);\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public Optional<String> getModLink() {\n        return this.modInfo.getConfig().getConfigElement(\"displayURL\").map(String::valueOf);\n    }\n\n    @Override\n    public Collection<String> getLicense() {\n        return Collections.singleton(this.modInfo.getOwningFile().getLicense());\n    }\n\n    @Override", "    public ForgeContact getContact() {\n        return (ForgeContact) modInfo.getConfig();\n    }\n\n    @Override\n    public Optional<String> getIconPath(int size) {\n        return this.modInfo.getLogoFile();\n    }\n}\n"]}
