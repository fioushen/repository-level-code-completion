{"filename": "src/main/java/com/yhzdys/litchi/context/TransactionContext.java", "chunked_list": ["package com.yhzdys.litchi.context;\n\nimport com.yhzdys.litchi.transaction.TxId;\n\npublic class TransactionContext {\n\n    private static final ThreadLocal<TxId> HOLDER = new ThreadLocal<>();\n\n    public static TxId get() {\n        return HOLDER.get();\n    }\n", "    public static TxId get() {\n        return HOLDER.get();\n    }\n\n    public static TxId set(TxId tid) {\n        HOLDER.set(tid);\n        return tid;\n    }\n\n    public static void remove() {\n        HOLDER.remove();\n    }\n}\n", "    public static void remove() {\n        HOLDER.remove();\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/context/DataSourceContext.java", "chunked_list": ["package com.yhzdys.litchi.context;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class DataSourceContext {\n\n    private static final ThreadLocal<Deque<String>> HOLDER = ThreadLocal.withInitial(() -> new ArrayDeque<>(4));\n\n    private DataSourceContext() {\n    }\n\n    /**\n     * \u5f53\u524d\u6240\u4f7f\u7528\u7684\u6570\u636e\u6e90\n     *\n     * @return current datasource\n     */", "    public static String get() {\n        return HOLDER.get().peek();\n    }\n\n    /**\n     * \u8bbe\u7f6e\u5f53\u524d\u7ebf\u7a0b\u6570\u636e\u6e90\n     *\n     * @param datasource add datasource\n     */\n    public static void set(String datasource) {\n        HOLDER.get().push(datasource);\n    }\n\n    /**\n     * \u79fb\u9664\u5f53\u524d\u6570\u636e\u6e90\n     */", "    public static void set(String datasource) {\n        HOLDER.get().push(datasource);\n    }\n\n    /**\n     * \u79fb\u9664\u5f53\u524d\u6570\u636e\u6e90\n     */\n    public static void remove() {\n        Deque<String> deque = HOLDER.get();\n        deque.pop();\n        if (deque.isEmpty()) {\n            clear();\n        }\n    }\n\n    /**\n     * \u5f3a\u5236\u6e05\u7a7a\u672c\u5730\u7ebf\u7a0b\n     */", "        if (deque.isEmpty()) {\n            clear();\n        }\n    }\n\n    /**\n     * \u5f3a\u5236\u6e05\u7a7a\u672c\u5730\u7ebf\u7a0b\n     */\n    public static void clear() {\n        HOLDER.remove();\n    }\n}\n", "    public static void clear() {\n        HOLDER.remove();\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/context/TxConnectionContext.java", "chunked_list": ["package com.yhzdys.litchi.context;\n\nimport com.yhzdys.litchi.connection.TxConnectionWrapper;\nimport com.yhzdys.litchi.transaction.TxId;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TxConnectionContext {\n\n    private static final ThreadLocal<Map<TxId, Map<DataSource, TxConnectionWrapper>>> HOLDER = ThreadLocal.withInitial(() -> new HashMap<>(4));\n\n    /**\n     * save concurrent datasource connection, thread-unsafe\n     *\n     * @param tid        transactionId\n     * @param dataSource dataSource\n     * @param connection connection\n     */", "import java.util.Map;\n\npublic class TxConnectionContext {\n\n    private static final ThreadLocal<Map<TxId, Map<DataSource, TxConnectionWrapper>>> HOLDER = ThreadLocal.withInitial(() -> new HashMap<>(4));\n\n    /**\n     * save concurrent datasource connection, thread-unsafe\n     *\n     * @param tid        transactionId\n     * @param dataSource dataSource\n     * @param connection connection\n     */", "    public static void set(TxId tid, DataSource dataSource, TxConnectionWrapper connection) {\n        HOLDER.get()\n                .computeIfAbsent(tid, k -> new HashMap<>(2))\n                .putIfAbsent(dataSource, connection);\n    }\n\n    /**\n     * get concurrent datasource connection, thread-unsafe\n     *\n     * @param tid        transactionId\n     * @param dataSource dataSource\n     * @return connection\n     */", "    public static TxConnectionWrapper get(TxId tid, DataSource dataSource) {\n        Map<DataSource, TxConnectionWrapper> dsmap = HOLDER.get().get(tid);\n        if (dsmap == null || dsmap.isEmpty()) {\n            return null;\n        }\n        return dsmap.get(dataSource);\n    }\n\n    /**\n     * notify transaction result\n     *\n     * @param tid      transaction id\n     * @param rollback if {@code true} rollback otherwise commit\n     * @throws SQLException SQLException\n     */", "    public static void notify(TxId tid, boolean rollback) throws SQLException {\n        Map<TxId, Map<DataSource, TxConnectionWrapper>> tmap = HOLDER.get();\n        if (tmap == null || tmap.isEmpty()) {\n            return;\n        }\n        SQLException exception = null;\n        Map<DataSource, TxConnectionWrapper> dsmap = tmap.get(tid);\n        for (TxConnectionWrapper connection : dsmap.values()) {\n            try {\n                connection.notify(rollback);\n            } catch (SQLException e) {", "            try {\n                connection.notify(rollback);\n            } catch (SQLException e) {\n                if (exception == null) {\n                    exception = e;\n                }\n            }\n        }\n        tmap.remove(tid);\n        if (exception != null) {\n            throw exception;\n        }\n    }\n}\n", "        if (exception != null) {\n            throw exception;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/datasource/MultiDataSource.java", "chunked_list": ["package com.yhzdys.litchi.datasource;\n\nimport com.yhzdys.litchi.connection.ConnectionWrapper;\nimport com.yhzdys.litchi.connection.TxConnectionWrapper;\nimport com.yhzdys.litchi.context.DataSourceContext;\nimport com.yhzdys.litchi.context.TransactionContext;\nimport com.yhzdys.litchi.context.TxConnectionContext;\nimport com.yhzdys.litchi.transaction.TxId;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.jdbc.datasource.AbstractDataSource;", "import org.springframework.beans.factory.InitializingBean;\nimport org.springframework.jdbc.datasource.AbstractDataSource;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MultiDataSource extends AbstractDataSource implements InitializingBean {\n\n    private Map<String, DataSource> dataSources;\n\n    private String defaultDataSourceKey;\n\n    private DataSource defaultDataSource;\n", "import java.util.Map;\n\npublic class MultiDataSource extends AbstractDataSource implements InitializingBean {\n\n    private Map<String, DataSource> dataSources;\n\n    private String defaultDataSourceKey;\n\n    private DataSource defaultDataSource;\n\n    public final void setDataSources(Map<String, DataSource> dataSources) {\n        Map<String, DataSource> map = new HashMap<>(dataSources.size());\n        map.putAll(dataSources);\n        this.dataSources = Collections.unmodifiableMap(map);\n    }\n", "    public final void setDataSources(Map<String, DataSource> dataSources) {\n        Map<String, DataSource> map = new HashMap<>(dataSources.size());\n        map.putAll(dataSources);\n        this.dataSources = Collections.unmodifiableMap(map);\n    }\n\n    public final void setDefaultDataSource(String dataSource) {\n        this.defaultDataSourceKey = dataSource;\n    }\n\n    @Override", "    public final Connection getConnection() throws SQLException {\n        DataSource dataSource = this.determineDataSource();\n        return this.wrapConnection(dataSource, dataSource.getConnection());\n    }\n\n    @Override\n    public final Connection getConnection(String username, String password) throws SQLException {\n        DataSource dataSource = this.determineDataSource();\n        return this.wrapConnection(dataSource, dataSource.getConnection(username, password));\n    }\n\n    @Override", "    public final void afterPropertiesSet() {\n        if (dataSources == null) {\n            throw new IllegalArgumentException(\"DataSources is required\");\n        }\n        if (defaultDataSourceKey == null) {\n            throw new IllegalArgumentException(\"Default dataSource is required\");\n        }\n        defaultDataSource = dataSources.get(defaultDataSourceKey);\n    }\n\n    private DataSource determineDataSource() {\n        String dataSourceKey = DataSourceContext.get();\n        DataSource dataSource;", "        if (dataSourceKey == null || dataSourceKey.length() < 1) {\n            dataSource = defaultDataSource;\n        } else {\n            dataSource = dataSources.get(dataSourceKey);\n        }\n        if (dataSource == null) {\n            throw new IllegalStateException(\"Cannot determine DataSource for key [\" + dataSourceKey + \"]\");\n        } else {\n            return dataSource;\n        }\n    }\n\n    private ConnectionWrapper wrapConnection(DataSource dataSource, Connection connection) throws SQLException {\n        TxId tid = TransactionContext.get();\n        // no transaction existed", "        if (tid == null) {\n            return new ConnectionWrapper(connection);\n        }\n        TxConnectionWrapper txConnection = TxConnectionContext.get(tid, dataSource);\n        if (txConnection != null) {\n            return txConnection;\n        }\n        txConnection = new TxConnectionWrapper(connection);\n        TxConnectionContext.set(tid, dataSource, txConnection);\n        return txConnection;\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/transaction/Propagation.java", "chunked_list": ["package com.yhzdys.litchi.transaction;\n\n/**\n * Enumeration that represents transaction propagation behaviors\n * for use with the {@link com.yhzdys.litchi.annotation.MultiTransactional} annotation\n */\npublic enum Propagation {\n\n    /**\n     * \u652f\u6301\u5f53\u524d\u4e8b\u52a1\uff0c\u5982\u679c\u5f53\u524d\u6ca1\u6709\u4e8b\u52a1\uff0c\u5c31\u65b0\u5efa\u4e00\u4e2a\u4e8b\u52a1\u3002\n     */\n    REQUIRED,\n\n    /**\n     * \u652f\u6301\u5f53\u524d\u4e8b\u52a1\uff0c\u5982\u679c\u5f53\u524d\u6ca1\u6709\u4e8b\u52a1\uff0c\u5c31\u4ee5\u975e\u4e8b\u52a1\u65b9\u5f0f\u6267\u884c\u3002\n     */\n    SUPPORTS,\n\n    /**\n     * \u652f\u6301\u5f53\u524d\u4e8b\u52a1\uff0c\u5982\u679c\u5f53\u524d\u6ca1\u6709\u4e8b\u52a1\uff0c\u5c31\u629b\u51fa\u5f02\u5e38\u3002\n     */\n    MANDATORY,\n\n    /**\n     * \u65b0\u5efa\u4e8b\u52a1\uff0c\u5982\u679c\u5f53\u524d\u5b58\u5728\u4e8b\u52a1\uff0c\u628a\u5f53\u524d\u4e8b\u52a1\u6302\u8d77\u3002\n     */\n    REQUIRES_NEW,\n\n    /**\n     * \u4ee5\u975e\u4e8b\u52a1\u65b9\u5f0f\u6267\u884c\u64cd\u4f5c\uff0c\u5982\u679c\u5f53\u524d\u5b58\u5728\u4e8b\u52a1\uff0c\u5c31\u628a\u5f53\u524d\u4e8b\u52a1\u6302\u8d77\u3002\n     */\n    NOT_SUPPORTED,\n\n    /**\n     * \u4ee5\u975e\u4e8b\u52a1\u65b9\u5f0f\u6267\u884c\uff0c\u5982\u679c\u5f53\u524d\u5b58\u5728\u4e8b\u52a1\uff0c\u5219\u629b\u51fa\u5f02\u5e38\u3002\n     */\n    NEVER,\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/transaction/Transaction.java", "chunked_list": ["package com.yhzdys.litchi.transaction;\n\nimport com.yhzdys.litchi.annotation.MultiTransactional;\nimport org.aopalliance.intercept.MethodInvocation;\n\npublic class Transaction {\n\n    private final MethodInvocation invocation;\n\n    private final Class<? extends Throwable>[] rollbackFor;\n\n    private final Class<? extends Throwable>[] noRollbackFor;\n\n    private final Propagation propagation;\n\n    public Transaction(MethodInvocation invocation, MultiTransactional annotation) {\n        this.invocation = invocation;\n        this.rollbackFor = annotation.rollbackFor();\n        this.noRollbackFor = annotation.noRollbackFor();\n        this.propagation = annotation.propagation();\n    }\n\n    Object proceed() throws Throwable {\n        return invocation.proceed();\n    }\n\n    Class<? extends Throwable>[] getRollbackFor() {\n        return rollbackFor;\n    }\n\n    Class<? extends Throwable>[] getNoRollbackFor() {\n        return noRollbackFor;\n    }\n\n    Propagation getPropagation() {\n        return propagation;\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/transaction/TxExecutor.java", "chunked_list": ["package com.yhzdys.litchi.transaction;\n\nimport com.yhzdys.litchi.context.TransactionContext;\nimport com.yhzdys.litchi.context.TxConnectionContext;\nimport com.yhzdys.litchi.exception.TransactionException;\n\nimport java.util.Objects;\n\npublic class TxExecutor {\n\n    public static final TxExecutor INSTANCE = new TxExecutor();\n\n    private TxExecutor() {\n    }\n", "public class TxExecutor {\n\n    public static final TxExecutor INSTANCE = new TxExecutor();\n\n    private TxExecutor() {\n    }\n\n    public Object execute(Transaction transaction) throws Throwable {\n        Propagation propagation = transaction.getPropagation();\n        SuspendedTx suspended = null;\n        try {", "        try {\n            if (Propagation.REQUIRED == propagation) {\n                return this.doExecute(transaction);\n            }\n            if (Propagation.SUPPORTS == propagation) {\n                if (this.hasTransaction()) {\n                    return this.doExecute(transaction);\n                } else {\n                    return transaction.proceed();\n                }\n            }", "            if (Propagation.MANDATORY == propagation) {\n                if (this.hasTransaction()) {\n                    return this.doExecute(transaction);\n                } else {\n                    throw new TransactionException(\"No transaction found propagation[mandatory]\");\n                }\n            }\n            if (Propagation.REQUIRES_NEW == propagation) {\n                suspended = this.suspend();\n                return this.doExecute(transaction);\n            }", "            if (Propagation.NOT_SUPPORTED == propagation) {\n                suspended = this.suspend();\n                return transaction.proceed();\n            }\n            if (Propagation.NEVER == propagation) {\n                if (this.hasTransaction()) {\n                    throw new TransactionException(\"Transaction found with propagation[never]\");\n                } else {\n                    return transaction.proceed();\n                }\n            }\n            throw new TransactionException(\"Transaction propagation[\" + propagation + \"] not support\");\n        } finally {\n            this.resume(suspended);\n        }\n    }\n\n    private boolean hasTransaction() {\n        return TransactionContext.get() != null;\n    }\n\n    private SuspendedTx suspend() {\n        TxId tid = TransactionContext.get();", "        if (tid == null) {\n            return null;\n        }\n        TransactionContext.remove();\n        return new SuspendedTx(tid);\n    }\n\n    private Object doExecute(Transaction transaction) throws Throwable {\n        if (this.hasTransaction()) {\n            return transaction.proceed();\n        }\n        // \u5f00\u542f\u4e8b\u52a1\n        TxId tid = TransactionContext.set(new TxId());\n        boolean rollback = false;\n        Object result;", "        if (this.hasTransaction()) {\n            return transaction.proceed();\n        }\n        // \u5f00\u542f\u4e8b\u52a1\n        TxId tid = TransactionContext.set(new TxId());\n        boolean rollback = false;\n        Object result;\n        try {\n            result = transaction.proceed();\n        } catch (Throwable t) {\n            try {\n                rollback = this.shouldRollback(transaction, t);\n            } catch (Exception ignored) {\n            }\n            throw t;\n        } finally {\n            TransactionContext.remove();\n            // \u56de\u6edaor\u63d0\u4ea4\u4e8b\u52a1\n            TxConnectionContext.notify(tid, rollback);\n        }\n        return result;\n    }\n\n    /**\n     * \u786e\u8ba4\u629b\u51fa\u7684\u5f02\u5e38\u662f\u5426\u9700\u8981\u56de\u6eda\n     */\n    private boolean shouldRollback(Transaction transaction, Throwable t) {\n        Class<? extends Throwable>[] noRollbacks = transaction.getNoRollbackFor();", "            try {\n                rollback = this.shouldRollback(transaction, t);\n            } catch (Exception ignored) {\n            }\n            throw t;\n        } finally {\n            TransactionContext.remove();\n            // \u56de\u6edaor\u63d0\u4ea4\u4e8b\u52a1\n            TxConnectionContext.notify(tid, rollback);\n        }\n        return result;\n    }\n\n    /**\n     * \u786e\u8ba4\u629b\u51fa\u7684\u5f02\u5e38\u662f\u5426\u9700\u8981\u56de\u6eda\n     */\n    private boolean shouldRollback(Transaction transaction, Throwable t) {\n        Class<? extends Throwable>[] noRollbacks = transaction.getNoRollbackFor();", "        if (noRollbacks != null) {\n            for (Class<? extends Throwable> noRollbackEx : noRollbacks) {\n                int depth = this.getThrowableDeep(noRollbackEx, t.getClass());\n                if (depth >= 0) {\n                    return false;\n                }\n            }\n        }\n        Class<? extends Throwable>[] rollbacks = transaction.getRollbackFor();\n        if (rollbacks != null) {\n            for (Class<? extends Throwable> rollbackEx : rollbacks) {\n                int depth = this.getThrowableDeep(rollbackEx, t.getClass());", "        if (rollbacks != null) {\n            for (Class<? extends Throwable> rollbackEx : rollbacks) {\n                int depth = this.getThrowableDeep(rollbackEx, t.getClass());\n                if (depth >= 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int getThrowableDeep(Class<? extends Throwable> source, Class<?> threw) {", "        if (source == Throwable.class || source == Exception.class) {\n            return 0;\n        }\n        if (threw == Throwable.class) {\n            return -1;\n        }\n        if (Objects.equals(threw, source)) {\n            return 0;\n        }\n        return this.getThrowableDeep(source, threw.getSuperclass());\n    }\n\n    private void resume(SuspendedTx suspended) {", "        if (suspended == null) {\n            return;\n        }\n        TransactionContext.set(suspended.getTxId());\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/transaction/TxId.java", "chunked_list": ["package com.yhzdys.litchi.transaction;\n\npublic final class TxId {\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/transaction/SuspendedTx.java", "chunked_list": ["package com.yhzdys.litchi.transaction;\n\n/**\n * \u4e34\u65f6\u6302\u8d77\u7684\u4e8b\u52a1\n */\npublic class SuspendedTx {\n\n    private final TxId txId;\n\n    public SuspendedTx(TxId txId) {\n        this.txId = txId;\n    }\n", "    public TxId getTxId() {\n        return txId;\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/exception/LitchiException.java", "chunked_list": ["package com.yhzdys.litchi.exception;\n\npublic class LitchiException extends RuntimeException {\n\n    public LitchiException(Throwable cause) {\n        super(cause);\n    }\n\n    public LitchiException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/exception/TransactionException.java", "chunked_list": ["package com.yhzdys.litchi.exception;\n\npublic class TransactionException extends LitchiException {\n\n    public TransactionException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/mybatis/MapperFactoryBean.java", "chunked_list": ["package com.yhzdys.litchi.support.mybatis;\n\nimport com.yhzdys.litchi.annotation.RoutingDataSource;\n\nimport java.lang.reflect.Proxy;\n\npublic class MapperFactoryBean<T> extends org.mybatis.spring.mapper.MapperFactoryBean<T> {\n\n    public MapperFactoryBean() {\n    }\n\n    public MapperFactoryBean(Class<T> mapperInterface) {\n        super(mapperInterface);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")", "    public T getObject() throws Exception {\n        Class<T> mapper = super.getMapperInterface();\n        RoutingDataSource annotation = mapper.getAnnotation(RoutingDataSource.class);\n        String dataSource = annotation == null ? RoutingDataSource.DEFAULT : annotation.value();\n\n        return (T) Proxy.newProxyInstance(\n                mapper.getClassLoader(), new Class[]{mapper}, new MapperInvocationHandler(super.getObject(), dataSource)\n        );\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/mybatis/MultiDataSourceInterceptor.java", "chunked_list": ["package com.yhzdys.litchi.support.mybatis;\n\nimport com.yhzdys.litchi.annotation.RoutingDataSource;\nimport com.yhzdys.litchi.context.DataSourceContext;\nimport org.apache.ibatis.cache.CacheKey;\nimport org.apache.ibatis.executor.Executor;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.Interceptor;\nimport org.apache.ibatis.plugin.Intercepts;", "import org.apache.ibatis.plugin.Interceptor;\nimport org.apache.ibatis.plugin.Intercepts;\nimport org.apache.ibatis.plugin.Invocation;\nimport org.apache.ibatis.plugin.Plugin;\nimport org.apache.ibatis.plugin.Signature;\nimport org.apache.ibatis.session.ResultHandler;\nimport org.apache.ibatis.session.RowBounds;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextRefreshedEvent;", "import org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextRefreshedEvent;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**", "\n/**\n * mybatis\u63d2\u4ef6\uff0c\u652f\u6301\u5728mapper\u4e0a\u76f4\u63a5\u5b9a\u4e49\u6570\u636e\u6e90\u8def\u7531\n */\n@Intercepts(value = {\n        @Signature(type = Executor.class, method = \"update\", args = {MappedStatement.class, Object.class}),\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class}),\n        @Signature(type = Executor.class, method = \"queryCursor\", args = {MappedStatement.class, Object.class, RowBounds.class}),\n})\npublic class MultiDataSourceInterceptor implements Interceptor, ApplicationListener<ContextRefreshedEvent> {\n\n    /**\n     * [mapper, datasource]\n     */\n    private final Map<String, String> CACHE = new HashMap<>(128);\n\n    @Override", "        @Signature(type = Executor.class, method = \"queryCursor\", args = {MappedStatement.class, Object.class, RowBounds.class}),\n})\npublic class MultiDataSourceInterceptor implements Interceptor, ApplicationListener<ContextRefreshedEvent> {\n\n    /**\n     * [mapper, datasource]\n     */\n    private final Map<String, String> CACHE = new HashMap<>(128);\n\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        String dataSource = CACHE.get(((MappedStatement) invocation.getArgs()[0]).getId());", "    public Object intercept(Invocation invocation) throws Throwable {\n        String dataSource = CACHE.get(((MappedStatement) invocation.getArgs()[0]).getId());\n        if (dataSource == null) {\n            dataSource = RoutingDataSource.DEFAULT;\n        }\n        DataSourceContext.set(dataSource);\n        try {\n            return invocation.proceed();\n        } finally {\n            DataSourceContext.remove();\n        }\n    }\n\n    @Override", "    public Object plugin(Object target) {\n        return Plugin.wrap(target, this);\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n    }\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        Map<String, SqlSessionFactory> factories = event.getApplicationContext().getBeansOfType(SqlSessionFactory.class);", "    public void onApplicationEvent(ContextRefreshedEvent event) {\n        Map<String, SqlSessionFactory> factories = event.getApplicationContext().getBeansOfType(SqlSessionFactory.class);\n        if (factories.isEmpty()) {\n            return;\n        }\n        for (SqlSessionFactory factory : factories.values()) {\n            Collection<Class<?>> mappers = factory.getConfiguration().getMapperRegistry().getMappers();\n            for (Class<?> mapper : mappers) {\n                RoutingDataSource annotation = mapper.getAnnotation(RoutingDataSource.class);\n                String dataSource = annotation == null ? RoutingDataSource.DEFAULT : annotation.value();\n                Method[] methods = mapper.getMethods();", "                for (Method method : methods) {\n                    CACHE.put(mapper.getName() + \".\" + method.getName(), dataSource);\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/mybatis/MapperInvocationHandler.java", "chunked_list": ["package com.yhzdys.litchi.support.mybatis;\n\nimport com.yhzdys.litchi.context.DataSourceContext;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class MapperInvocationHandler implements InvocationHandler {\n\n    private final Object target;\n    private final String dataSource;\n\n    public MapperInvocationHandler(Object target, String dataSource) {\n        this.target = target;\n        this.dataSource = dataSource;\n    }\n\n    @Override", "    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        DataSourceContext.set(dataSource);\n        try {\n            return method.invoke(target, args);\n        } finally {\n            DataSourceContext.remove();\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/spring/MultiTransactionAdvisor.java", "chunked_list": ["package com.yhzdys.litchi.support.spring;\n\nimport org.aopalliance.aop.Advice;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.support.AbstractPointcutAdvisor;\nimport org.springframework.core.Ordered;\n\n/**\n * spring aop\u5207\u9762\u5b9a\u4e49\n */\npublic class MultiTransactionAdvisor extends AbstractPointcutAdvisor {\n\n    private final Advice advice = new TxInterceptor();\n\n    private final Pointcut pointcut = new TxPointcut();\n\n    @Override", " * spring aop\u5207\u9762\u5b9a\u4e49\n */\npublic class MultiTransactionAdvisor extends AbstractPointcutAdvisor {\n\n    private final Advice advice = new TxInterceptor();\n\n    private final Pointcut pointcut = new TxPointcut();\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n\n    @Override", "    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n\n    @Override\n    public Pointcut getPointcut() {\n        return pointcut;\n    }\n\n    @Override\n    public Advice getAdvice() {\n        return advice;\n    }\n}\n", "    public Advice getAdvice() {\n        return advice;\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/spring/TxPointcut.java", "chunked_list": ["package com.yhzdys.litchi.support.spring;\n\nimport com.yhzdys.litchi.annotation.MultiTransactional;\nimport org.springframework.aop.ClassFilter;\nimport org.springframework.aop.MethodMatcher;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.support.StaticMethodMatcher;\nimport org.springframework.core.annotation.AnnotationUtils;\n\nimport java.lang.reflect.Method;", "\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nclass TxPointcut implements Pointcut {\n\n    private final Matcher matcher = new Matcher();\n\n    @Override\n    public ClassFilter getClassFilter() {\n        return ClassFilter.TRUE;\n    }\n\n    @Override", "    @Override\n    public ClassFilter getClassFilter() {\n        return ClassFilter.TRUE;\n    }\n\n    @Override\n    public MethodMatcher getMethodMatcher() {\n        return matcher;\n    }\n\n    private static class Matcher extends StaticMethodMatcher {\n\n        @Override", "        public boolean matches(Method method, Class<?> targetClass) {\n            MultiTransactional annotation = method.getAnnotation(MultiTransactional.class);\n            if (annotation == null) {\n                if (Proxy.isProxyClass(targetClass)) {\n                    return false;\n                } else {\n                    annotation = AnnotationUtils.findAnnotation(method, MultiTransactional.class);\n                }\n            }\n            return annotation != null;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/support/spring/TxInterceptor.java", "chunked_list": ["package com.yhzdys.litchi.support.spring;\n\nimport com.yhzdys.litchi.annotation.MultiTransactional;\nimport com.yhzdys.litchi.transaction.Transaction;\nimport com.yhzdys.litchi.transaction.TxExecutor;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.springframework.core.annotation.AnnotationUtils;\n\n/**", "\n/**\n * \u4e8b\u52a1\u4ee3\u7406\u5bf9\u8c61\n */\nclass TxInterceptor implements MethodInterceptor {\n\n    private final TxExecutor executor = TxExecutor.INSTANCE;\n\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        MultiTransactional annotation = invocation.getMethod().getAnnotation(MultiTransactional.class);", "    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        MultiTransactional annotation = invocation.getMethod().getAnnotation(MultiTransactional.class);\n        if (annotation == null) {\n            annotation = AnnotationUtils.findAnnotation(invocation.getMethod(), MultiTransactional.class);\n        }\n        if (annotation == null) {\n            return invocation.proceed();\n        }\n        return executor.execute(new Transaction(invocation, annotation));\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/connection/ConnectionWrapper.java", "chunked_list": ["package com.yhzdys.litchi.connection;\n\nimport java.sql.Array;\nimport java.sql.Blob;\nimport java.sql.CallableStatement;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.NClob;\nimport java.sql.PreparedStatement;", "import java.sql.NClob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLClientInfoException;\nimport java.sql.SQLException;\nimport java.sql.SQLWarning;\nimport java.sql.SQLXML;\nimport java.sql.Savepoint;\nimport java.sql.Statement;\nimport java.sql.Struct;\nimport java.util.Map;", "import java.sql.Struct;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.Executor;\n\npublic class ConnectionWrapper implements Connection {\n\n    protected final Connection connection;\n\n    public ConnectionWrapper(Connection connection) {\n        this.connection = connection;\n    }\n\n    @Override", "    public Statement createStatement() throws SQLException {\n        return connection.createStatement();\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql) throws SQLException {\n        return connection.prepareStatement(sql);\n    }\n\n    @Override\n    public CallableStatement prepareCall(String sql) throws SQLException {\n        return connection.prepareCall(sql);\n    }\n\n    @Override", "    public CallableStatement prepareCall(String sql) throws SQLException {\n        return connection.prepareCall(sql);\n    }\n\n    @Override\n    public String nativeSQL(String sql) throws SQLException {\n        return connection.nativeSQL(sql);\n    }\n\n    @Override\n    public boolean getAutoCommit() throws SQLException {\n        return connection.getAutoCommit();\n    }\n\n    @Override", "    public boolean getAutoCommit() throws SQLException {\n        return connection.getAutoCommit();\n    }\n\n    @Override\n    public void setAutoCommit(boolean autoCommit) throws SQLException {\n        connection.setAutoCommit(autoCommit);\n    }\n\n    @Override\n    public void commit() throws SQLException {\n        connection.commit();\n    }\n\n    @Override", "    public void commit() throws SQLException {\n        connection.commit();\n    }\n\n    @Override\n    public void rollback() throws SQLException {\n        connection.rollback();\n    }\n\n    @Override\n    public void close() throws SQLException {\n        connection.close();\n    }\n\n    @Override", "    public void close() throws SQLException {\n        connection.close();\n    }\n\n    @Override\n    public boolean isClosed() throws SQLException {\n        return connection.isClosed();\n    }\n\n    @Override\n    public DatabaseMetaData getMetaData() throws SQLException {\n        return connection.getMetaData();\n    }\n\n    @Override", "    public DatabaseMetaData getMetaData() throws SQLException {\n        return connection.getMetaData();\n    }\n\n    @Override\n    public boolean isReadOnly() throws SQLException {\n        return connection.isReadOnly();\n    }\n\n    @Override\n    public void setReadOnly(boolean readOnly) throws SQLException {\n        connection.setReadOnly(readOnly);\n    }\n\n    @Override", "    public void setReadOnly(boolean readOnly) throws SQLException {\n        connection.setReadOnly(readOnly);\n    }\n\n    @Override\n    public String getCatalog() throws SQLException {\n        return connection.getCatalog();\n    }\n\n    @Override\n    public void setCatalog(String catalog) throws SQLException {\n        connection.setCatalog(catalog);\n    }\n\n    @Override", "    public void setCatalog(String catalog) throws SQLException {\n        connection.setCatalog(catalog);\n    }\n\n    @Override\n    public int getTransactionIsolation() throws SQLException {\n        return connection.getTransactionIsolation();\n    }\n\n    @Override\n    public void setTransactionIsolation(int level) throws SQLException {\n        connection.setTransactionIsolation(level);\n    }\n\n    @Override", "    public void setTransactionIsolation(int level) throws SQLException {\n        connection.setTransactionIsolation(level);\n    }\n\n    @Override\n    public SQLWarning getWarnings() throws SQLException {\n        return connection.getWarnings();\n    }\n\n    @Override\n    public void clearWarnings() throws SQLException {\n        connection.clearWarnings();\n    }\n\n    @Override", "    public void clearWarnings() throws SQLException {\n        connection.clearWarnings();\n    }\n\n    @Override\n    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\n        return connection.createStatement(resultSetType, resultSetConcurrency);\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\n        return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);\n    }\n\n    @Override", "    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\n        return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);\n    }\n\n    @Override\n    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\n        return connection.prepareCall(sql, resultSetType, resultSetConcurrency);\n    }\n\n    @Override\n    public Map<String, Class<?>> getTypeMap() throws SQLException {\n        return connection.getTypeMap();\n    }\n\n    @Override", "    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\n        connection.setTypeMap(map);\n    }\n\n    @Override\n    public int getHoldability() throws SQLException {\n        return connection.getHoldability();\n    }\n\n    @Override\n    public void setHoldability(int holdability) throws SQLException {\n        connection.setHoldability(holdability);\n    }\n\n    @Override", "    public void setHoldability(int holdability) throws SQLException {\n        connection.setHoldability(holdability);\n    }\n\n    @Override\n    public Savepoint setSavepoint() throws SQLException {\n        return connection.setSavepoint();\n    }\n\n    @Override\n    public Savepoint setSavepoint(String name) throws SQLException {\n        return connection.setSavepoint(name);\n    }\n\n    @Override", "    public Savepoint setSavepoint(String name) throws SQLException {\n        return connection.setSavepoint(name);\n    }\n\n    @Override\n    public void rollback(Savepoint savepoint) throws SQLException {\n        connection.rollback();\n    }\n\n    @Override\n    public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n        connection.releaseSavepoint(savepoint);\n    }\n\n    @Override", "    public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n        connection.releaseSavepoint(savepoint);\n    }\n\n    @Override\n    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\n        return connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\n        return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n    }\n\n    @Override", "    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\n        return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n    }\n\n    @Override\n    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\n        return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\n        return connection.prepareStatement(sql, autoGeneratedKeys);\n    }\n\n    @Override", "    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\n        return connection.prepareStatement(sql, autoGeneratedKeys);\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\n        return connection.prepareStatement(sql, columnIndexes);\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\n        return connection.prepareStatement(sql, columnNames);\n    }\n\n    @Override", "    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\n        return connection.prepareStatement(sql, columnNames);\n    }\n\n    @Override\n    public Clob createClob() throws SQLException {\n        return connection.createClob();\n    }\n\n    @Override\n    public Blob createBlob() throws SQLException {\n        return connection.createBlob();\n    }\n\n    @Override", "    public Blob createBlob() throws SQLException {\n        return connection.createBlob();\n    }\n\n    @Override\n    public NClob createNClob() throws SQLException {\n        return connection.createNClob();\n    }\n\n    @Override\n    public SQLXML createSQLXML() throws SQLException {\n        return connection.createSQLXML();\n    }\n\n    @Override", "    public SQLXML createSQLXML() throws SQLException {\n        return connection.createSQLXML();\n    }\n\n    @Override\n    public boolean isValid(int timeout) throws SQLException {\n        return connection.isValid(timeout);\n    }\n\n    @Override\n    public void setClientInfo(String name, String value) throws SQLClientInfoException {\n        connection.setClientInfo(name, value);\n    }\n\n    @Override", "    public void setClientInfo(String name, String value) throws SQLClientInfoException {\n        connection.setClientInfo(name, value);\n    }\n\n    @Override\n    public String getClientInfo(String name) throws SQLException {\n        return connection.getClientInfo(name);\n    }\n\n    @Override\n    public Properties getClientInfo() throws SQLException {\n        return connection.getClientInfo();\n    }\n\n    @Override", "    public Properties getClientInfo() throws SQLException {\n        return connection.getClientInfo();\n    }\n\n    @Override\n    public void setClientInfo(Properties properties) throws SQLClientInfoException {\n        connection.setClientInfo(properties);\n    }\n\n    @Override\n    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\n        return connection.createArrayOf(typeName, elements);\n    }\n\n    @Override", "    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\n        return connection.createArrayOf(typeName, elements);\n    }\n\n    @Override\n    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\n        return connection.createStruct(typeName, attributes);\n    }\n\n    @Override\n    public String getSchema() throws SQLException {\n        return connection.getSchema();\n    }\n\n    @Override", "    public String getSchema() throws SQLException {\n        return connection.getSchema();\n    }\n\n    @Override\n    public void setSchema(String schema) throws SQLException {\n        connection.setSchema(schema);\n    }\n\n    @Override\n    public void abort(Executor executor) throws SQLException {\n        connection.abort(executor);\n    }\n\n    @Override", "    public void abort(Executor executor) throws SQLException {\n        connection.abort(executor);\n    }\n\n    @Override\n    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\n        connection.setNetworkTimeout(executor, milliseconds);\n    }\n\n    @Override\n    public int getNetworkTimeout() throws SQLException {\n        return connection.getNetworkTimeout();\n    }\n\n    @Override\n    public <T> T unwrap(Class<T> iface) throws SQLException {\n        return connection.unwrap(iface);\n    }\n\n    @Override", "    public int getNetworkTimeout() throws SQLException {\n        return connection.getNetworkTimeout();\n    }\n\n    @Override\n    public <T> T unwrap(Class<T> iface) throws SQLException {\n        return connection.unwrap(iface);\n    }\n\n    @Override\n    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n        return connection.isWrapperFor(iface);\n    }\n}\n", "    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n        return connection.isWrapperFor(iface);\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/connection/TxConnectionWrapper.java", "chunked_list": ["package com.yhzdys.litchi.connection;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class TxConnectionWrapper extends ConnectionWrapper {\n\n    private final boolean autoCommit;\n\n    public TxConnectionWrapper(Connection connection) throws SQLException {\n        super(connection);\n        this.autoCommit = connection.getAutoCommit();", "        if (autoCommit) {\n            connection.setAutoCommit(false);\n        }\n    }\n\n    public void notify(boolean rollback) throws SQLException {\n        try {\n            if (rollback) {\n                connection.rollback();\n            } else {\n                connection.commit();\n            }\n        } finally {\n            connection.setAutoCommit(autoCommit);\n            connection.close();\n        }\n    }\n\n    @Override", "    public void commit() {\n        // do nothing\n    }\n\n    @Override\n    public void rollback() {\n        // do nothing\n    }\n\n    @Override\n    public void close() {\n        // do nothing\n    }\n}\n", "    public void close() {\n        // do nothing\n    }\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/annotation/RoutingDataSource.java", "chunked_list": ["package com.yhzdys.litchi.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RoutingDataSource {", "@Retention(RetentionPolicy.RUNTIME)\npublic @interface RoutingDataSource {\n\n    String DEFAULT = \"@DFT_DS\";\n\n    String value() default DEFAULT;\n}\n"]}
{"filename": "src/main/java/com/yhzdys/litchi/annotation/MultiTransactional.java", "chunked_list": ["package com.yhzdys.litchi.annotation;\n\nimport com.yhzdys.litchi.transaction.Propagation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)", "\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MultiTransactional {\n\n    Class<? extends Throwable>[] rollbackFor() default {Exception.class};\n\n    Class<? extends Throwable>[] noRollbackFor() default {};\n\n    Propagation propagation() default Propagation.REQUIRED;", "\n    Propagation propagation() default Propagation.REQUIRED;\n}\n"]}
