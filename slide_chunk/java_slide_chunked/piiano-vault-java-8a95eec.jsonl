{"filename": "sdk/client/src/test/java/com/piiano/vault/client/VaultClientTest.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.piiano.vault.client.model.AccessReason;\nimport com.piiano.vault.client.model.DefaultParams;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.model.*;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static com.piiano.vault.client.CollectionSetup.collectionName;\nimport static com.piiano.vault.client.DefaultClient.getDefaultClient;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class VaultClientTest {\n\n    private final ApiClient apiClient = getDefaultClient();\n\n    private final VaultClient vaultClient = new VaultClient(apiClient,\n            DefaultParams.builder().collection(collectionName).accessReason(AccessReason.AppFunctionality).build());\n\n    @BeforeEach", "public class VaultClientTest {\n\n    private final ApiClient apiClient = getDefaultClient();\n\n    private final VaultClient vaultClient = new VaultClient(apiClient,\n            DefaultParams.builder().collection(collectionName).accessReason(AccessReason.AppFunctionality).build());\n\n    @BeforeEach\n    public void beforeEach() throws ApiException {\n        CollectionSetup.setUp();\n    }\n\n    @AfterEach", "    public void beforeEach() throws ApiException {\n        CollectionSetup.setUp();\n    }\n\n    @AfterEach\n    public void afterEach() {\n        CollectionSetup.tearDown();\n    }\n\n    @Test\n    public void tokenizeTest() throws ApiException {\n        TokenizeRequest request = new TokenizeRequest()\n                .type(TokenType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        TokenValue result = vaultClient.tokensClient().tokenize(request);\n        assertNotNull(result.getTokenId());\n    }\n\n    @Test", "    public void tokenizeTest() throws ApiException {\n        TokenizeRequest request = new TokenizeRequest()\n                .type(TokenType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        TokenValue result = vaultClient.tokensClient().tokenize(request);\n        assertNotNull(result.getTokenId());\n    }\n\n    @Test\n    public void encryptionTest() throws ApiException {\n        EncryptionRequest request = new EncryptionRequest()\n                .type(EncryptionType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        EncryptedValue result = vaultClient.cryptoClint().encrypt(request);\n        assertNotNull(result);\n        assertNotNull(result.getCiphertext());\n    }\n}\n", "    public void encryptionTest() throws ApiException {\n        EncryptionRequest request = new EncryptionRequest()\n                .type(EncryptionType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        EncryptedValue result = vaultClient.cryptoClint().encrypt(request);\n        assertNotNull(result);\n        assertNotNull(result.getCiphertext());\n    }\n}\n"]}
{"filename": "sdk/client/src/test/java/com/piiano/vault/client/CollectionSetup.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.CollectionsApi;\nimport com.piiano.vault.client.openapi.Configuration;\nimport com.piiano.vault.client.openapi.model.Collection;\nimport com.piiano.vault.client.openapi.model.Property;\n\nimport java.util.Collections;", "\nimport java.util.Collections;\n\npublic class CollectionSetup {\n\n    public static final String collectionName = \"users_test\";\n\n    public static void setUp() throws ApiException {\n        addCollection();\n    }\n", "    public static void tearDown() {\n        deleteCollectionIfExists();\n    }\n\n    private static Collection addCollection() throws ApiException {\n\n        ApiClient pvaultClient = getApiClient();\n        CollectionsApi collectionsApi = new CollectionsApi(pvaultClient);\n\n        deleteCollectionIfExists();\n\n        Collection collection = createCollection();\n        return collectionsApi.addCollection(collection, \"json\", Collections.emptySet());\n    }\n\n    private static void deleteCollectionIfExists() {\n        ApiClient pvaultClient = getApiClient();\n        CollectionsApi collectionsApi = new CollectionsApi(pvaultClient);\n", "        try {\n            collectionsApi.deleteCollection(collectionName);\n        } catch (ApiException e) {\n            // Collection not found - do nothing.\n        }\n    }\n\n    public static Collection createCollection() {\n        return new Collection()\n                .name(collectionName)\n                .type(Collection.TypeEnum.PERSONS)\n                .addPropertiesItem(\n                        new Property().name(\"name\").dataTypeName(\"NAME\").description(\"Name\")\n                                .isEncrypted(true)\n                ).addPropertiesItem(\n                        new Property().name(\"phone_number\").dataTypeName(\"PHONE_NUMBER\").description(\"Phone number\")\n                                .isEncrypted(true).isNullable(true)\n                );\n    }\n\n    private static ApiClient getApiClient() {\n        // Create configuration, bearer auth and client API\n        ApiClient pvaultClient = Configuration.getDefaultApiClient();\n        pvaultClient.setBasePath(\"http://localhost:8123\");\n        pvaultClient.setBearerToken(\"pvaultauth\");\n        pvaultClient.addDefaultHeader(\"Content-Type\", \"application/json\");\n        return pvaultClient;\n    }\n}\n"]}
{"filename": "sdk/client/src/test/java/com/piiano/vault/client/DefaultClient.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.Configuration;\n\npublic class DefaultClient {\n\n    public static ApiClient getDefaultClient() {\n\n        // Create configuration, bearer auth and client API\n        ApiClient apiClient = Configuration.getDefaultApiClient();\n        apiClient.setBasePath(\"http://localhost:8123\");\n        apiClient.setBearerToken(\"pvaultauth\");\n        apiClient.addDefaultHeader(\"Content-Type\", \"application/json\");\n\n        return apiClient;\n    }\n}\n"]}
{"filename": "sdk/client/src/test/java/com/piiano/vault/client/CryptoClientTest.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.piiano.vault.client.model.AccessReason;\nimport com.piiano.vault.client.model.DefaultParams;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.model.EncryptedValue;\nimport com.piiano.vault.client.openapi.model.EncryptionRequest;\nimport com.piiano.vault.client.openapi.model.EncryptionType;", "import com.piiano.vault.client.openapi.model.EncryptionRequest;\nimport com.piiano.vault.client.openapi.model.EncryptionType;\nimport com.piiano.vault.client.openapi.model.InputObject;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static com.piiano.vault.client.CollectionSetup.collectionName;\nimport static com.piiano.vault.client.DefaultClient.getDefaultClient;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;", "import static com.piiano.vault.client.DefaultClient.getDefaultClient;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class CryptoClientTest {\n\n    private final ApiClient apiClient = getDefaultClient();\n\n    private final CryptoClient cryptoClient = new CryptoClient(apiClient,\n            DefaultParams.builder().collection(collectionName).accessReason(AccessReason.AppFunctionality).build());\n\n    @BeforeEach", "    public void beforeEach() throws ApiException {\n        CollectionSetup.setUp();\n    }\n\n    @AfterEach\n    public void afterEach() {\n        CollectionSetup.tearDown();\n    }\n\n    @Test\n    public void encryptionTest() throws ApiException {\n        EncryptionRequest request = new EncryptionRequest()\n                .type(EncryptionType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        EncryptedValue result = cryptoClient.encrypt(request);\n        assertNotNull(result);\n        assertNotNull(result.getCiphertext());\n    }\n}\n", "    public void encryptionTest() throws ApiException {\n        EncryptionRequest request = new EncryptionRequest()\n                .type(EncryptionType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        EncryptedValue result = cryptoClient.encrypt(request);\n        assertNotNull(result);\n        assertNotNull(result.getCiphertext());\n    }\n}\n"]}
{"filename": "sdk/client/src/test/java/com/piiano/vault/client/TokensClientTest.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.piiano.vault.client.model.AccessReason;\nimport com.piiano.vault.client.model.DefaultParams;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.model.InputObject;\nimport com.piiano.vault.client.openapi.model.TokenType;\nimport com.piiano.vault.client.openapi.model.TokenValue;", "import com.piiano.vault.client.openapi.model.TokenType;\nimport com.piiano.vault.client.openapi.model.TokenValue;\nimport com.piiano.vault.client.openapi.model.TokenizeRequest;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static com.piiano.vault.client.CollectionSetup.collectionName;\nimport static com.piiano.vault.client.DefaultClient.getDefaultClient;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;", "import static com.piiano.vault.client.DefaultClient.getDefaultClient;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class TokensClientTest {\n\n    private final ApiClient apiClient = getDefaultClient();\n\n    private final TokensClient tokensClient = new TokensClient(apiClient,\n            DefaultParams.builder().collection(collectionName).accessReason(AccessReason.AppFunctionality).build());\n\n    @BeforeEach", "    public void beforeEach() throws ApiException {\n        CollectionSetup.setUp();\n    }\n\n    @AfterEach\n    public void afterEach() {\n        CollectionSetup.tearDown();\n    }\n\n    @Test\n    public void tokenizeTest() throws ApiException {\n        TokenizeRequest request = new TokenizeRequest()\n                .type(TokenType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        TokenValue result = tokensClient.tokenize(request);\n        assertNotNull(result.getTokenId());\n    }\n}\n", "    public void tokenizeTest() throws ApiException {\n        TokenizeRequest request = new TokenizeRequest()\n                .type(TokenType.DETERMINISTIC)\n                ._object(new InputObject().fields(ImmutableMap.of(\"name\", \"John\")));\n\n        TokenValue result = tokensClient.tokenize(request);\n        assertNotNull(result.getTokenId());\n    }\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/VaultClient.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.piiano.vault.client.model.*;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Client for the Tokens API.\n */\npublic class VaultClient {\n\n    private final TokensClient tokensClient;\n    private final CryptoClient cryptoClient;\n\n    public VaultClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.tokensClient = new TokensClient(apiClient, defaultParams);\n        this.cryptoClient = new CryptoClient(apiClient, defaultParams);\n    }\n", " */\npublic class VaultClient {\n\n    private final TokensClient tokensClient;\n    private final CryptoClient cryptoClient;\n\n    public VaultClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.tokensClient = new TokensClient(apiClient, defaultParams);\n        this.cryptoClient = new CryptoClient(apiClient, defaultParams);\n    }\n", "    public TokensClient tokensClient() {\n        return tokensClient;\n    }\n\n    public CryptoClient cryptoClint() {\n        return cryptoClient;\n    }\n\n    public static ApiClient getPvaultClient() {\n        String pvaultUrl = System.getenv(\"pvault_url\");\n        if (StringUtils.isEmpty(pvaultUrl)) {\n            pvaultUrl = \"http://localhost:8123\";\n        }\n\n        String pvaultAuth = System.getenv(\"pvault_auth\");", "    public static ApiClient getPvaultClient() {\n        String pvaultUrl = System.getenv(\"pvault_url\");\n        if (StringUtils.isEmpty(pvaultUrl)) {\n            pvaultUrl = \"http://localhost:8123\";\n        }\n\n        String pvaultAuth = System.getenv(\"pvault_auth\");\n        if (StringUtils.isEmpty(pvaultAuth)) {\n            pvaultAuth = \"pvaultauth\";\n        }\n\n        ApiClient pvaultClient = com.piiano.vault.client.openapi.Configuration.getDefaultApiClient();\n        pvaultClient.setBasePath(pvaultUrl);\n        pvaultClient.setBearerToken(pvaultAuth);\n        pvaultClient.addDefaultHeader(\"Content-Type\", \"application/json\");\n        return pvaultClient;\n    }\n}"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/CryptoClient.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableList;\nimport com.piiano.vault.client.model.*;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.CryptoApi;\nimport com.piiano.vault.client.openapi.model.*;\n", "import com.piiano.vault.client.openapi.model.*;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Client for the Crypto API.\n */\npublic class CryptoClient {\n\n    private final CryptoApi cryptoApi;\n\n    private final DefaultParams defaultParams;\n\n    public CryptoClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.cryptoApi = new CryptoApi(apiClient);\n        this.defaultParams = defaultParams;\n    }\n", "public class CryptoClient {\n\n    private final CryptoApi cryptoApi;\n\n    private final DefaultParams defaultParams;\n\n    public CryptoClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.cryptoApi = new CryptoApi(apiClient);\n        this.defaultParams = defaultParams;\n    }\n", "    public CryptoApi openapi() {\n        return cryptoApi;\n    }\n\n    /**\n     * Encrypt\n     * Creates an encrypted blob.  You can encrypt:  1. Objects stored in Vault by providing their ID.  2. Fields not stored in Vault by providing a map of their properties and property values. However, fields must conform to the collection schema specified in the request.  3. Encrypted blob. This option enables you to create an encrypted blob with a subset of another encrypted object's properties or use a different encryption type or scope. To update the property values, use the [update encrypted](/api/operations/update-encrypted) operation.  :bulb: For brevity, this guide uses the term 'object' to refer to the content being encrypted.  If any request details are invalid, none of the objects are encrypted.  You can generate ciphertext for the encrypted object with a random initialization vector (randomized) or based on the collection name, input object, and scope (deterministic).  Using 'props', you can request that the encrypted object include a subset of the collection schema's properties.  However, if a property isn't present in the object or the property value is null, it is not included in the encrypted blob. Also, if you want to include built-in properties, you must explicitly include them in 'props'.  The role that performs this operation must have  the following capabilities:  - 'CapDataWriter' - 'CapDataReader' to encrypt objects stored in Vault, along with at least one allowing policy and no denying policies for the read operation for the collection and each property requested in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param encryptionRequest Details of the encryption request. (required)\n     * @return EncryptedValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public EncryptedValue encrypt(EncryptionRequest encryptionRequest) throws ApiException {\n\n        List<EncryptedValue> encryptedValues = this.cryptoApi.encrypt(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                ImmutableList.of(encryptionRequest),\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n", "        if (encryptedValues.size() == 0) {\n            return null;\n        }\n        return encryptedValues.get(0);\n    }\n\n    /**\n     * Encrypt\n     * Creates an encrypted blob.  You can encrypt:  1. Objects stored in Vault by providing their ID.  2. Fields not stored in Vault by providing a map of their properties and property values. However, fields must conform to the collection schema specified in the request.  3. Encrypted blob. This option enables you to create an encrypted blob with a subset of another encrypted object's properties or use a different encryption type or scope. To update the property values, use the [update encrypted](/api/operations/update-encrypted) operation.  :bulb: For brevity, this guide uses the term 'object' to refer to the content being encrypted.  If any request details are invalid, none of the objects are encrypted.  You can generate ciphertext for the encrypted object with a random initialization vector (randomized) or based on the collection name, input object, and scope (deterministic).  Using 'props', you can request that the encrypted object include a subset of the collection schema's properties.  However, if a property isn't present in the object or the property value is null, it is not included in the encrypted blob. Also, if you want to include built-in properties, you must explicitly include them in 'props'.  The role that performs this operation must have  the following capabilities:  - 'CapDataWriter' - 'CapDataReader' to encrypt objects stored in Vault, along with at least one allowing policy and no denying policies for the read operation for the collection and each property requested in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param encryptionRequest Details of the encryption request. (required)\n     * @param encryptParams Additional params for the request.\n     * @return EncryptedValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public EncryptedValue encrypt(EncryptionRequest encryptionRequest, EncryptParams encryptParams) throws ApiException {\n\n        AccessReason accessReason = encryptParams.getAccessReason() != null ? encryptParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        List<EncryptedValue> encryptedValues = this.cryptoApi.encrypt(\n                !Strings.isNullOrEmpty(encryptParams.getCollection()) ? encryptParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                ImmutableList.of(encryptionRequest),\n                encryptParams.getExpirationSecs(),\n                accessReason.getAdhocReason(),\n                encryptParams.getReloadCache() != null ? encryptParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n", "        if (encryptedValues.size() == 0) {\n            return null;\n        }\n        return encryptedValues.get(0);\n    }\n\n    /**\n     * Encrypt bulk\n     * Creates bulk of encrypted blobs.  You can encrypt:  1. Objects stored in Vault by providing their ID.  2. Fields not stored in Vault by providing a map of their properties and property values. However, fields must conform to the collection schema specified in the request.  3. Encrypted blob. This option enables you to create an encrypted blob with a subset of another encrypted object's properties or use a different encryption type or scope. To update the property values, use the [update encrypted](/api/operations/update-encrypted) operation.  :bulb: For brevity, this guide uses the term 'object' to refer to the content being encrypted.  If any request details are invalid, none of the objects are encrypted.  You can generate ciphertext for the encrypted object with a random initialization vector (randomized) or based on the collection name, input object, and scope (deterministic).  Using 'props', you can request that the encrypted object include a subset of the collection schema's properties.  However, if a property isn't present in the object or the property value is null, it is not included in the encrypted blob. Also, if you want to include built-in properties, you must explicitly include them in 'props'.  The role that performs this operation must have  the following capabilities:  - 'CapDataWriter' - 'CapDataReader' to encrypt objects stored in Vault, along with at least one allowing policy and no denying policies for the read operation for the collection and each property requested in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param encryptionRequests Details of the encryption requests. (required)\n     * @return List<EncryptedValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<EncryptedValue> encryptBulk(List<EncryptionRequest> encryptionRequests) throws ApiException {\n\n        return this.cryptoApi.encrypt(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                encryptionRequests,\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Encrypt bulk\n     * Creates bulk of encrypted blobs.  You can encrypt:  1. Objects stored in Vault by providing their ID.  2. Fields not stored in Vault by providing a map of their properties and property values. However, fields must conform to the collection schema specified in the request.  3. Encrypted blob. This option enables you to create an encrypted blob with a subset of another encrypted object's properties or use a different encryption type or scope. To update the property values, use the [update encrypted](/api/operations/update-encrypted) operation.  :bulb: For brevity, this guide uses the term 'object' to refer to the content being encrypted.  If any request details are invalid, none of the objects are encrypted.  You can generate ciphertext for the encrypted object with a random initialization vector (randomized) or based on the collection name, input object, and scope (deterministic).  Using 'props', you can request that the encrypted object include a subset of the collection schema's properties.  However, if a property isn't present in the object or the property value is null, it is not included in the encrypted blob. Also, if you want to include built-in properties, you must explicitly include them in 'props'.  The role that performs this operation must have  the following capabilities:  - 'CapDataWriter' - 'CapDataReader' to encrypt objects stored in Vault, along with at least one allowing policy and no denying policies for the read operation for the collection and each property requested in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param encryptionRequests Details of the encryption request. (required)\n     * @param encryptParams Additional params for the request.\n     * @return List<EncryptedValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<EncryptedValue> encryptBulk(List<EncryptionRequest> encryptionRequests, EncryptParams encryptParams) throws ApiException {\n\n        AccessReason accessReason = encryptParams.getAccessReason() != null ? encryptParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.cryptoApi.encrypt(\n                !Strings.isNullOrEmpty(encryptParams.getCollection()) ? encryptParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                encryptionRequests,\n                encryptParams.getExpirationSecs(),\n                accessReason.getAdhocReason(),\n                encryptParams.getReloadCache() != null ? encryptParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Decrypt\n     * Decrypts the ciphertext of an encrypted blob.  To decrypt an encrypted blob, the request must include the scope used when the blob was encrypted. By default, only blobs considered active are decrypted. A blob is considered active when its metadata 'expiration' property is for the current date or a date in the future. If 'options' is set to 'archived', the blob is only decrypted if its metadata 'expiration' property is for a date in the past.  By default, all property values from an encrypted blob are returned. Use 'props' to return a subset of the encrypted property values.  If any request details are invalid, none of the blobs are decrypted.  The role that performs this operation must have the 'CapDataReader' capability. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param decryptionRequest Details of the decryption request. (required)\n     * @param options Options for the operation. Options include: - 'archived' \u2013 whether to decrypt only archived objects. If not specified, decrypts only active objects. - 'include_metadata' - show the encrypted object metadata.  (optional)\n     * @return DecryptedObject\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public DecryptedObject decrypt(DecryptionRequest decryptionRequest, Set<String> options) throws ApiException {\n\n        List<DecryptedObject> decryptedObjects = this.cryptoApi.decrypt(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                ImmutableList.of(decryptionRequest),\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n", "        if (decryptedObjects.size() == 0) {\n            return null;\n        }\n        return decryptedObjects.get(0);\n    }\n\n    /**\n     * Decrypt\n     * Decrypts the ciphertext of an encrypted blob.  To decrypt an encrypted blob, the request must include the scope used when the blob was encrypted. By default, only blobs considered active are decrypted. A blob is considered active when its metadata 'expiration' property is for the current date or a date in the future. If 'options' is set to 'archived', the blob is only decrypted if its metadata 'expiration' property is for a date in the past.  By default, all property values from an encrypted blob are returned. Use 'props' to return a subset of the encrypted property values.  If any request details are invalid, none of the blobs are decrypted.  The role that performs this operation must have the 'CapDataReader' capability. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param decryptionRequest Details of the decryption request. (required)\n     * @param options Options for the operation. Options include: - 'archived' \u2013 whether to decrypt only archived objects. If not specified, decrypts only active objects. - 'include_metadata' - show the encrypted object metadata.  (optional)\n     * @param decryptParams Additional params for the request.\n     * @return DecryptedObject\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public DecryptedObject decrypt(DecryptionRequest decryptionRequest, Set<String> options, DecryptParams decryptParams) throws ApiException {\n\n        AccessReason accessReason = decryptParams.getAccessReason() != null ? decryptParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        List<DecryptedObject> decryptedObjects = this.cryptoApi.decrypt(\n                !Strings.isNullOrEmpty(decryptParams.getCollection()) ? decryptParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                ImmutableList.of(decryptionRequest),\n                options,\n                accessReason.getAdhocReason(),\n                decryptParams.getReloadCache() != null ? decryptParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n", "        if (decryptedObjects.size() == 0) {\n            return null;\n        }\n        return decryptedObjects.get(0);\n    }\n\n    /**\n     * Decrypt bulk\n     * Decrypts the ciphertext of an encrypted blob. Supports bulk operations.  To decrypt an encrypted blob, the request must include the scope used when the blob was encrypted. By default, only blobs considered active are decrypted. A blob is considered active when its metadata 'expiration' property is for the current date or a date in the future. If 'options' is set to 'archived', the blob is only decrypted if its metadata 'expiration' property is for a date in the past.  By default, all property values from an encrypted blob are returned. Use 'props' to return a subset of the encrypted property values.  If any request details are invalid, none of the blobs are decrypted.  The role that performs this operation must have the 'CapDataReader' capability. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param decryptionRequests Details of the decryption requests. (required)\n     * @param options Options for the operation. Options include: - 'archived' \u2013 whether to decrypt only archived objects. If not specified, decrypts only active objects. - 'include_metadata' - show the encrypted object metadata.  (optional)\n     * @return List<DecryptedObject>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<DecryptedObject> decryptBulk(List<DecryptionRequest> decryptionRequests, Set<String> options) throws ApiException {\n\n        return this.cryptoApi.decrypt(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                decryptionRequests,\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Decrypt bulk\n     * Decrypts the ciphertext of an encrypted blob. Supports bulk operations.  To decrypt an encrypted blob, the request must include the scope used when the blob was encrypted. By default, only blobs considered active are decrypted. A blob is considered active when its metadata 'expiration' property is for the current date or a date in the future. If 'options' is set to 'archived', the blob is only decrypted if its metadata 'expiration' property is for a date in the past.  By default, all property values from an encrypted blob are returned. Use 'props' to return a subset of the encrypted property values.  If any request details are invalid, none of the blobs are decrypted.  The role that performs this operation must have the 'CapDataReader' capability. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param decryptionRequests Details of the decryption request. (required)\n     * @param options Options for the operation. Options include: - 'archived' \u2013 whether to decrypt only archived objects. If not specified, decrypts only active objects. - 'include_metadata' - show the encrypted object metadata.  (optional)\n     * @param decryptParams Additional params for the request.\n     * @return List<DecryptedObject>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<DecryptedObject> decryptBulk(List<DecryptionRequest> decryptionRequests, Set<String> options, DecryptParams decryptParams) throws ApiException {\n\n        AccessReason accessReason = decryptParams.getAccessReason() != null ? decryptParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.cryptoApi.decrypt(\n                !Strings.isNullOrEmpty(decryptParams.getCollection()) ? decryptParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                decryptionRequests,\n                options,\n                accessReason.getAdhocReason(),\n                decryptParams.getReloadCache() != null ? decryptParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Update encrypted blob and metadata\n     * Creates an encrypted blob based on an encrypted blob.  The new encrypted blob can have different encryption type, scope, properties, or property values to the source blob. Any property values in the source blob not updated in the request are preserved in the new blob as long as they are included in &#x60;props&#x60;.  For example, if the source blob contains &#x60;first_name&#x60;, &#x60;last_name&#x60;, and &#x60;telephone_number&#x60; and &#x60;props&#x60; specifies &#x60;[first_name, last_name]&#x60;, then &#x60;telephone_number&#x60; isn't included in the new encrypted blob.  The request must include the scope used to encrypt the source blob.  If any request details are invalid, no encrypted blobs are created.  The role that performs this operation must have the &#x60;CapDataReader&#x60; and &#x60;CapDataWriter&#x60; capabilities. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param updateEncryptionRequest Details of the update encrypted object request. The request includes the encrypted object to update and the property values to update the encrypted object with.  (required)\n     * @param options Options for the request. - &#x60;archived&#x60; - whether to update only archived encrypted objects. If not specified, update only active encrypted objects.  (optional)\n     * @return EncryptedValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public EncryptedValue updateEncrypted(UpdateEncryptionRequest updateEncryptionRequest, Set<String> options) throws ApiException {\n\n        List<EncryptedValue> encryptedValues = this.cryptoApi.updateEncrypted(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                ImmutableList.of(updateEncryptionRequest),\n                options,\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n", "        if (encryptedValues.size() == 0) {\n            return null;\n        }\n        return encryptedValues.get(0);\n    }\n\n    /**\n     * Update encrypted blob and metadata\n     * Creates an encrypted blob based on an encrypted blob.  The new encrypted blob can have different encryption type, scope, properties, or property values to the source blob. Any property values in the source blob not updated in the request are preserved in the new blob as long as they are included in &#x60;props&#x60;.  For example, if the source blob contains &#x60;first_name&#x60;, &#x60;last_name&#x60;, and &#x60;telephone_number&#x60; and &#x60;props&#x60; specifies &#x60;[first_name, last_name]&#x60;, then &#x60;telephone_number&#x60; isn't included in the new encrypted blob.  The request must include the scope used to encrypt the source blob.  If any request details are invalid, no encrypted blobs are created.  The role that performs this operation must have the &#x60;CapDataReader&#x60; and &#x60;CapDataWriter&#x60; capabilities. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param updateEncryptionRequest Details of the update encrypted object request. The request includes the encrypted object to update and the property values to update the encrypted object with.  (required)\n     * @param options Options for the request. - &#x60;archived&#x60; - whether to update only archived encrypted objects. If not specified, update only active encrypted objects.  (optional)\n     * @param updateEncryptedParams Additional params for the request.\n     * @return EncryptedValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public EncryptedValue updateEncrypted(UpdateEncryptionRequest updateEncryptionRequest, Set<String> options, UpdateEncryptedParams updateEncryptedParams) throws ApiException {\n\n        AccessReason accessReason = updateEncryptedParams.getAccessReason() != null ? updateEncryptedParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        List<EncryptedValue> encryptedValues = this.cryptoApi.updateEncrypted(\n                !Strings.isNullOrEmpty(updateEncryptedParams.getCollection()) ? updateEncryptedParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                ImmutableList.of(updateEncryptionRequest),\n                options,\n                updateEncryptedParams.getExpirationSecs(),\n                accessReason.getAdhocReason(),\n                updateEncryptedParams.getReloadCache() != null ? updateEncryptedParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n", "        if (encryptedValues.size() == 0) {\n            return null;\n        }\n        return encryptedValues.get(0);\n    }\n\n    /**\n     * Update bulk encrypted blobs and metadata\n     * Creates an encrypted blob based on an encrypted blob. Supports bulk operations.  The new encrypted blob can have different encryption type, scope, properties, or property values to the source blob. Any property values in the source blob not updated in the request are preserved in the new blob as long as they are included in &#x60;props&#x60;.  For example, if the source blob contains &#x60;first_name&#x60;, &#x60;last_name&#x60;, and &#x60;telephone_number&#x60; and &#x60;props&#x60; specifies &#x60;[first_name, last_name]&#x60;, then &#x60;telephone_number&#x60; isn't included in the new encrypted blob.  The request must include the scope used to encrypt the source blob.  If any request details are invalid, no encrypted blobs are created.  The role that performs this operation must have the &#x60;CapDataReader&#x60; and &#x60;CapDataWriter&#x60; capabilities. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param updateEncryptionRequests Details of the update encrypted object request. The request includes the encrypted object to update and the property values to update the encrypted object with.  (required)\n     * @param options Options for the request. - &#x60;archived&#x60; - whether to update only archived encrypted objects. If not specified, update only active encrypted objects.  (optional)\n     * @return List<EncryptedValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<EncryptedValue> updateEncryptedBulk(List<UpdateEncryptionRequest> updateEncryptionRequests, Set<String> options) throws ApiException {\n\n        return this.cryptoApi.updateEncrypted(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                updateEncryptionRequests,\n                options,\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Update bulk encrypted blobs and metadata\n     * Creates an encrypted blob based on an encrypted blob. Supports bulk operations.  The new encrypted blob can have different encryption type, scope, properties, or property values to the source blob. Any property values in the source blob not updated in the request are preserved in the new blob as long as they are included in &#x60;props&#x60;.  For example, if the source blob contains &#x60;first_name&#x60;, &#x60;last_name&#x60;, and &#x60;telephone_number&#x60; and &#x60;props&#x60; specifies &#x60;[first_name, last_name]&#x60;, then &#x60;telephone_number&#x60; isn't included in the new encrypted blob.  The request must include the scope used to encrypt the source blob.  If any request details are invalid, no encrypted blobs are created.  The role that performs this operation must have the &#x60;CapDataReader&#x60; and &#x60;CapDataWriter&#x60; capabilities. See [identity and access management](/data-security/identity-and-access-management) for more information about how Vault uses capabilities to control access to operations and policies to control access to data.\n     * @param updateEncryptionRequests Details of the update encrypted object request. The request includes the encrypted object to update and the property values to update the encrypted object with.  (required)\n     * @param options Options for the request. - &#x60;archived&#x60; - whether to update only archived encrypted objects. If not specified, update only active encrypted objects.  (optional)\n     * @param updateEncryptedParams Additional params for the request.\n     * @return List<EncryptedValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or properties aren't found, or property values are invalid. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<EncryptedValue> updateEncryptedBulk(List<UpdateEncryptionRequest> updateEncryptionRequests, Set<String> options, UpdateEncryptedParams updateEncryptedParams) throws ApiException {\n\n        AccessReason accessReason = updateEncryptedParams.getAccessReason() != null ? updateEncryptedParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.cryptoApi.updateEncrypted(\n                !Strings.isNullOrEmpty(updateEncryptedParams.getCollection()) ? updateEncryptedParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                updateEncryptionRequests,\n                options,\n                updateEncryptedParams.getExpirationSecs(),\n                accessReason.getAdhocReason(),\n                updateEncryptedParams.getReloadCache() != null ? updateEncryptedParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Hash\n     * Creates a deterministic hash based on an object's property values, collection, and scope.  This operation is similar to using the [tokenize](/api/operations/tokenize) operation for a token of type &#x60;deterministic&#x60;. The hash value is identical to the token ID generated for the same combination of collection, object, property values, and scope. However, unlike the token, this hash is not stored in Vault's storage and, as such, cannot be detokenized, searched, or invalidated.\n     * @param hashObjectRequest Details of the hashing request. (required)\n     * @return TokenValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public TokenValue hash(HashObjectRequest hashObjectRequest) throws ApiException {\n\n        List<TokenValue> tokenValues = this.cryptoApi.hashObjects(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                ImmutableList.of(hashObjectRequest),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n\n        if (tokenValues.size() == 0) {\n            return null;\n        }\n        return tokenValues.get(0);\n    }\n\n    /**\n     * Hash\n     * Creates a deterministic hash based on an object's property values, collection, and scope. Supports bulk operations.  This operation is similar to using the [tokenize](/api/operations/tokenize) operation for a token of type &#x60;deterministic&#x60;. The hash value is identical to the token ID generated for the same combination of collection, object, property values, and scope. However, unlike the token, this hash is not stored in Vault's storage and, as such, cannot be detokenized, searched, or invalidated.\n     * @param hashObjectRequest Details of the hashing request. (required)\n     * @param hashParams Additional params for the request.\n     * @return TokenValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "        if (tokenValues.size() == 0) {\n            return null;\n        }\n        return tokenValues.get(0);\n    }\n\n    /**\n     * Hash\n     * Creates a deterministic hash based on an object's property values, collection, and scope. Supports bulk operations.  This operation is similar to using the [tokenize](/api/operations/tokenize) operation for a token of type &#x60;deterministic&#x60;. The hash value is identical to the token ID generated for the same combination of collection, object, property values, and scope. However, unlike the token, this hash is not stored in Vault's storage and, as such, cannot be detokenized, searched, or invalidated.\n     * @param hashObjectRequest Details of the hashing request. (required)\n     * @param hashParams Additional params for the request.\n     * @return TokenValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public TokenValue hash(HashObjectRequest hashObjectRequest, HashParams hashParams) throws ApiException {\n\n        AccessReason accessReason = hashParams.getAccessReason() != null ? hashParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        List<TokenValue> tokenValues = this.cryptoApi.hashObjects(\n                !Strings.isNullOrEmpty(hashParams.getCollection()) ? hashParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                ImmutableList.of(hashObjectRequest),\n                accessReason.getAdhocReason(),\n                hashParams.getReloadCache() != null ? hashParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n", "        if (tokenValues.size() == 0) {\n            return null;\n        }\n        return tokenValues.get(0);\n    }\n\n    /**\n     * Hash bulk\n     * Creates a deterministic hash based on an object's property values, collection, and scope. Supports bulk operations.  This operation is similar to using the [tokenize](/api/operations/tokenize) operation for a token of type &#x60;deterministic&#x60;. The hash value is identical to the token ID generated for the same combination of collection, object, property values, and scope. However, unlike the token, this hash is not stored in Vault's storage and, as such, cannot be detokenized, searched, or invalidated.\n     * @param hashObjectRequests Details of the hashing request. (required)\n     * @return List<TokenValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenValue> hashBulk(List<HashObjectRequest> hashObjectRequests) throws ApiException {\n\n        return this.cryptoApi.hashObjects(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                hashObjectRequests,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Hash bulk\n     * Creates a deterministic hash based on an object's property values, collection, and scope. Supports bulk operations.  This operation is similar to using the [tokenize](/api/operations/tokenize) operation for a token of type &#x60;deterministic&#x60;. The hash value is identical to the token ID generated for the same combination of collection, object, property values, and scope. However, unlike the token, this hash is not stored in Vault's storage and, as such, cannot be detokenized, searched, or invalidated.\n     * @param hashObjectRequests Details of the hashing request. (required)\n     * @param hashParams Additional params for the request.\n     * @return List<TokenValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenValue> hashBulk(List<HashObjectRequest> hashObjectRequests, HashParams hashParams) throws ApiException {\n\n        AccessReason accessReason = hashParams.getAccessReason() != null ? hashParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.cryptoApi.hashObjects(\n                !Strings.isNullOrEmpty(hashParams.getCollection()) ? hashParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                hashObjectRequests,\n                accessReason.getAdhocReason(),\n                hashParams.getReloadCache() != null ? hashParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/TokensClient.java", "chunked_list": ["package com.piiano.vault.client;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableList;\nimport com.piiano.vault.client.model.*;\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.TokensApi;\nimport com.piiano.vault.client.openapi.model.*;\n", "import com.piiano.vault.client.openapi.model.*;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Client for the Tokens API.\n */\npublic class TokensClient {\n\n    private final TokensApi tokensApi;\n\n    private final DefaultParams defaultParams;\n\n    public TokensClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.tokensApi = new TokensApi(apiClient);\n        this.defaultParams = defaultParams;\n    }\n", " */\npublic class TokensClient {\n\n    private final TokensApi tokensApi;\n\n    private final DefaultParams defaultParams;\n\n    public TokensClient(ApiClient apiClient, DefaultParams defaultParams) {\n        this.tokensApi = new TokensApi(apiClient);\n        this.defaultParams = defaultParams;\n    }\n", "    public TokensApi openapi() {\n        return tokensApi;\n    }\n\n    /**\n     * Tokenize\n     * Creates a token that reference the values of an object's properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive. Supports bulk operations.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token's current expiry date.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `tokenize` operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenizeRequest Details of the tokenization request. (required)\n     * @return TokenValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code {@code @http.response.details}}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public TokenValue tokenize(TokenizeRequest tokenizeRequest) throws ApiException {\n\n        List<TokenValue> tokenValues = this.tokensApi.tokenize(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                ImmutableList.of(tokenizeRequest),\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getTransactionId(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n", "        if (tokenValues.size() == 0) {\n            return null;\n        }\n        return tokenValues.get(0);\n    }\n\n    /**\n     * Tokenize\n     * Creates a token that reference the values of an object's properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive. Supports bulk operations.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token's current expiry date.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `tokenize` operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenizeRequest Details of the tokenization request. (required)\n     * @param tokenizeParams Additional params for the request.\n     * @return TokenValue\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public TokenValue tokenize(TokenizeRequest tokenizeRequest, TokenizeParams tokenizeParams) throws ApiException {\n\n        AccessReason accessReason = tokenizeParams.getAccessReason() != null ? tokenizeParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        List<TokenValue> tokenValues = this.tokensApi.tokenize(\n                !Strings.isNullOrEmpty(tokenizeParams.getCollection()) ? tokenizeParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                ImmutableList.of(tokenizeRequest),\n                !Strings.isNullOrEmpty(tokenizeParams.getExpirationSecs()) ? tokenizeParams.getExpirationSecs() : this.defaultParams.getExpirationSecs(),\n                !Strings.isNullOrEmpty(tokenizeParams.getTransactionId()) ? tokenizeParams.getTransactionId() : this.defaultParams.getTransactionId(),\n                accessReason.getAdhocReason(),\n                tokenizeParams.getReloadCache() != null ? tokenizeParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n", "        if (tokenValues.size() == 0) {\n            return null;\n        }\n        return tokenValues.get(0);\n    }\n\n    /**\n     * Tokenize bulk\n     * Creates a token that reference the values of an object's properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive. Supports bulk operations.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token's current expiry date.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `tokenize` operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenizeRequests Details of the tokenization requests. (required)\n     * @return List<TokenValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenValue> tokenizeBulk(List<TokenizeRequest> tokenizeRequests) throws ApiException {\n\n        return this.tokensApi.tokenize(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                tokenizeRequests,\n                this.defaultParams.getExpirationSecs(),\n                this.defaultParams.getTransactionId(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Tokenize bulk\n     * Creates a token that reference the values of an object's properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive. Supports bulk operations.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token's current expiry date.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `tokenize` operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenizeRequests Details of the tokenization requests. (required)\n     * @param tokenizeParams Additional params for the request.\n     * @return List<TokenValue>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, objects, or properties aren't found or are missing. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenValue> tokenizeBulk(List<TokenizeRequest> tokenizeRequests, TokenizeParams tokenizeParams) throws ApiException {\n\n        AccessReason accessReason = tokenizeParams.getAccessReason() != null ? tokenizeParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.tokensApi.tokenize(\n                !Strings.isNullOrEmpty(tokenizeParams.getCollection()) ? tokenizeParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                tokenizeRequests,\n                !Strings.isNullOrEmpty(tokenizeParams.getExpirationSecs()) ? tokenizeParams.getExpirationSecs() : this.defaultParams.getExpirationSecs(),\n                !Strings.isNullOrEmpty(tokenizeParams.getTransactionId()) ? tokenizeParams.getTransactionId() : this.defaultParams.getTransactionId(),\n                accessReason.getAdhocReason(),\n                tokenizeParams.getReloadCache() != null ? tokenizeParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Detokenize tokens\n     * Returns the object property values for tokens.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. The operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  The role performing this operation must have all of these: - The `CapTokensDetokenizer` capability. - Policies:   + At least one allowing policy and no denying policies for the `detokenize` operation for each of the collection properties that are tokenized by tokens specified in the query.   + At least one allowing policy and no denying policies for the `read` operation for each of the collection properties that are tokenized by tokens specified in the query.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken token_ids, object_ids, and tags to query the token.\n     * @param props The list of property names and transformers. To include multiple names and transformations, provide a comma-separated list. For example, `props&#x3D;first_name,last_name,email.mask`. If not set, return all property values. (optional)\n     * @param options Options for the operation. Options include: - `include_metadata` - show token metadata in the response.  (optional)\n     * @return List<DetokenizedToken>;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The requested resource is not found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<DetokenizedToken> detokenize(QueryToken queryToken, List<String> props, Set<String> options) throws ApiException {\n\n        return this.tokensApi.detokenize(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                queryToken.getObjectIds(), queryToken.getTags() , queryToken.getTokenIds(),\n                props,\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Detokenize tokens\n     * Returns the object property values for tokens.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. The operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  The role performing this operation must have all of these: - The `CapTokensDetokenizer` capability. - Policies:   + At least one allowing policy and no denying policies for the `detokenize` operation for each of the collection properties that are tokenized by tokens specified in the query.   + At least one allowing policy and no denying policies for the `read` operation for each of the collection properties that are tokenized by tokens specified in the query.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken token_ids, object_ids, and tags to query the token.\n     * @param props The list of property names and transformers. To include multiple names and transformations, provide a comma-separated list. For example, `props=first_name,last_name,email.mask`. If not set, return all property values. (optional)\n     * @param options Options for the operation. Options include: - `include_metadata` - show token metadata in the response.  (optional)\n     * @param detokenizeParams Additional params for the request.\n     * @return List<DetokenizedToken>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The requested resource is not found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<DetokenizedToken> detokenize(QueryToken queryToken, List<String> props, Set<String> options, DetokenizeParams detokenizeParams) throws ApiException {\n\n        AccessReason accessReason = detokenizeParams.getAccessReason() != null ? detokenizeParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.tokensApi.detokenize(\n                !Strings.isNullOrEmpty(detokenizeParams.getCollection()) ? detokenizeParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                queryToken.getObjectIds(), queryToken.getTags() , queryToken.getTokenIds(),\n                props,\n                options,\n                accessReason.getAdhocReason(),\n                detokenizeParams.getReloadCache() != null ? detokenizeParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Search tokens\n     * Lists tokens with their metadata.   The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. The operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.   The role performing this operation must have all of these: - The `CapTokensReader` capability. - At least one allowing policy and no denying policies for the `read` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken token_ids, object_ids, and tags to query the token. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to search only archived tokens. If not specified, search only active tokens.  (optional)\n     * @return List<TokenMetadata>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The requested resource is not found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenMetadata> searchTokens(QueryToken queryToken, Set<String> options) throws ApiException {\n\n        return this.tokensApi.searchTokens(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                queryToken,\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Search tokens\n     * Lists tokens with their metadata.   The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. The operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.   The role performing this operation must have all of these: - The `CapTokensReader` capability. - At least one allowing policy and no denying policies for the `read` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken The token query. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to search only archived tokens. If not specified, search only active tokens.  (optional)\n     * @param searchTokensParams Additional params for the request.\n     * @return List<TokenMetadata>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The requested resource is not found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public List<TokenMetadata> searchTokens(QueryToken queryToken, Set<String> options, SearchTokensParams searchTokensParams) throws ApiException {\n\n        AccessReason accessReason = searchTokensParams.getAccessReason() != null ? searchTokensParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.tokensApi.searchTokens(\n                !Strings.isNullOrEmpty(searchTokensParams.getCollection()) ? searchTokensParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                queryToken,\n                options,\n                accessReason.getAdhocReason(),\n                searchTokensParams.getReloadCache() != null ? searchTokensParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Update tokens\n     * Updates `tags` and `expiration` token metadata.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the collection specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. If no tokens are matched, status code 404 is returned. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.\n     * @param updateTokenRequest Update token request details. (required)\n     * @param queryToken token_ids, object_ids, and tags to query the token. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to update only archived tokens. If not specified, update only active tokens.  (optional)\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n     <table summary=\"Response Details\" border=\"1\">\n        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n        <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n        <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n        <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n        <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n        <tr><td> 404 </td><td> The collection or reason aren't found or are missing, the `reason` is set to `other` but no `adhoc_reason` is provided, no token query parameters are provided, or the query finds no matching tokens. </td><td>  -  </td></tr>\n        <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n        <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n        <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n     </table>\n     */", "    public void updateTokens(UpdateTokenRequest updateTokenRequest, QueryToken queryToken, Set<String> options) throws ApiException {\n\n        this.tokensApi.updateTokens(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                updateTokenRequest,\n                this.defaultParams.getExpirationSecs(),\n                queryToken.getObjectIds(), queryToken.getTags(), queryToken.getTokenIds(),\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Update tokens\n     * Updates `tags` and `expiration` token metadata.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the collection specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. If no tokens are matched, status code 404 is returned. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.\n     * @param updateTokenRequest Update token request details. (required)\n     * @param queryToken token_ids, object_ids, and tags to query the token. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to update only archived tokens. If not specified, update only active tokens.  (optional)\n     * @param updateTokensParams Additional params for the request.\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code {@code @http.response.details}}\n     <table summary=\"Response Details\" border=\"1\">\n        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n        <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n        <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n        <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n        <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n        <tr><td> 404 </td><td> The collection or reason aren't found or are missing, the `reason` is set to `other` but no `adhoc_reason` is provided, no token query parameters are provided, or the query finds no matching tokens. </td><td>  -  </td></tr>\n        <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n        <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n        <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n     </table>\n     */", "    public void updateTokens(UpdateTokenRequest updateTokenRequest, QueryToken queryToken, Set<String> options, UpdateTokensParams updateTokensParams) throws ApiException {\n\n        AccessReason accessReason = updateTokensParams.getAccessReason() != null ? updateTokensParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        this.tokensApi.updateTokens(\n                !Strings.isNullOrEmpty(updateTokensParams.getCollection()) ? updateTokensParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                updateTokenRequest,\n                updateTokensParams.getExpirationSecs(),\n                queryToken.getObjectIds(), queryToken.getTags(), queryToken.getTokenIds(),\n                options,\n                accessReason.getAdhocReason(),\n                updateTokensParams.getReloadCache() != null ? updateTokensParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Delete tokens\n     * Deletes tokens.  The tokens to delete are those that match all the criteria in the `token_ids`, `object_ids`,  and `tags` parameters. If the token query finds no matches, the operation returns a 404 error. tenant ID filter is null, can be set in DeleteTokensParams for the other method . See [search tokens](search-tokens) for more details.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `delete` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken token_ids, object_ids, and tags to query the token. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to delete only archived tokens. If not specified, delete only active tokens.  (optional)\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection or reason aren't found or are missing, the `reason` is set to `other` but no `adhoc_reason` is provided, no token query parameters are provided, or the query finds no matching tokens. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public void deleteTokens(QueryToken queryToken, Set<String> options) throws ApiException {\n\n        this.tokensApi.deleteTokens(\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                queryToken.getObjectIds(), queryToken.getTags() , queryToken.getTokenIds(),\n                null,\n                options,\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Delete tokens\n     * Deletes tokens.  The tokens to delete are those that match all the criteria in the `token_ids`, `object_ids`,  and `tags` parameters. If the token query finds no matches, the operation returns a 404 error. See [search tokens](search-tokens) for more details.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `delete` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param queryToken token_ids, object_ids, and tags to query the token. (required)\n     * @param options Options for the operation. Options include: - `archived` \u2013 whether to delete only archived tokens. If not specified, delete only active tokens.  (optional)\n     * @param deleteTokensParams Additional params for the request.\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code {@code @http.response.details}}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The requested resource is not found. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */", "    public void deleteTokens(QueryToken queryToken, Set<String> options, DeleteTokensParams deleteTokensParams) throws ApiException {\n\n        AccessReason accessReason = deleteTokensParams.getAccessReason() != null ? deleteTokensParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        this.tokensApi.deleteTokens(\n                !Strings.isNullOrEmpty(deleteTokensParams.getCollection()) ? deleteTokensParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                queryToken.getObjectIds(), queryToken.getTags() , queryToken.getTokenIds(),\n                deleteTokensParams.getTenantId(),\n                options,\n                accessReason.getAdhocReason(),\n                deleteTokensParams.getReloadCache() != null ? deleteTokensParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Rotate tokens\n     * Generates new token IDs for a list of tokens.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenIds Comma-separated list of token IDs. (required)\n     * @return Map<String, String>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, reason, or tokens aren't found or are missing or the `reason` is set to `other` but no `adhoc_reason` is provided. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public Map<String, String> rotateTokens(List<String> tokenIds) throws ApiException {\n\n        return this.tokensApi.rotateTokens(\n                tokenIds,\n                this.defaultParams.getCollection(),\n                this.defaultParams.getAccessReason().getReason(),\n                this.defaultParams.getAccessReason().getAdhocReason(),\n                this.defaultParams.isReloadCache()\n        );\n    }\n\n    /**\n     * Rotate tokens\n     * Generates new token IDs for a list of tokens.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.\n     * @param tokenIds Comma-separated list of token IDs. (required)\n     * @param rotateTokensParams Additional params for the request.\n     * @return Map<String, String>\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     * {@code @http.response.details}\n    <table summary=\"Response Details\" border=\"1\">\n    <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>\n    <tr><td> 200 </td><td> The request is successful. </td><td>  -  </td></tr>\n    <tr><td> 400 </td><td> The request is invalid. </td><td>  -  </td></tr>\n    <tr><td> 401 </td><td> Authentication credentials are incorrect or missing. </td><td>  -  </td></tr>\n    <tr><td> 403 </td><td> The caller doesn't have the required access rights. </td><td>  -  </td></tr>\n    <tr><td> 404 </td><td> The collection, reason, or tokens aren't found or are missing or the `reason` is set to `other` but no `adhoc_reason` is provided. </td><td>  -  </td></tr>\n    <tr><td> 409 </td><td> A conflict occurs. </td><td>  -  </td></tr>\n    <tr><td> 500 </td><td> An error occurs on the server. </td><td>  -  </td></tr>\n    <tr><td> 503 </td><td> The service is unavailable. </td><td>  -  </td></tr>\n    </table>\n     */\n    public Map<String, String> rotateTokens(List<String> tokenIds, RotateTokensParams rotateTokensParams) throws ApiException {\n\n        AccessReason accessReason = rotateTokensParams.getAccessReason() != null ? rotateTokensParams.getAccessReason() : this.defaultParams.getAccessReason();\n\n        return this.tokensApi.rotateTokens(\n                tokenIds,\n                !Strings.isNullOrEmpty(rotateTokensParams.getCollection()) ? rotateTokensParams.getCollection() : this.defaultParams.getCollection(),\n                accessReason.getReason(),\n                accessReason.getAdhocReason(),\n                rotateTokensParams.getReloadCache() != null ? rotateTokensParams.getReloadCache() : this.defaultParams.isReloadCache()\n        );\n    }\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/HashParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'hashObjects' API.\n */\n@Data\n@Builder\npublic class HashParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class HashParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/TokenizeParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'tokenize' API.\n */\n@Data\n@Builder\npublic class TokenizeParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n\n    /**\n     * transactionId The transaction ID to attach to the token.\n     */\n    private String transactionId;\n}\n", "@Data\n@Builder\npublic class TokenizeParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n\n    /**\n     * transactionId The transaction ID to attach to the token.\n     */\n    private String transactionId;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/DefaultParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Default parameters for the Vault Clients. These parameters are used by the Vault Client for\n * all requests unless set by the request parameters.\n */\n@Data", " */\n@Data\n@Builder\npublic class DefaultParams {\n\n    private String collection;\n\n    private AccessReason accessReason;\n\n    private String expirationSecs;\n\n    private boolean reloadCache;\n\n    private String transactionId;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/DetokenizeParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'detokenize' API.\n */\n@Data\n@Builder\npublic class DetokenizeParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class DetokenizeParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/AccessReason.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Getter;\n\n/**\n * Available values for the access reason, for \"Other\" an ad-hoc reason can be provided.\n */\n@Getter\npublic enum AccessReason {\n\n    AppFunctionality(\"AppFunctionality\"),\n    Analytics(\"Analytics\"),\n    Notifications(\"Notifications\"),\n    ThirdPartyMarketing(\"ThirdPartyMarketing\"),\n    Marketing(\"Marketing\"),\n    FraudPreventionSecurityAndCompliance(\"FraudPreventionSecurityAndCompliance\"),\n    AccountManagement(\"AccountManagement\"),\n    Maintenance(\"Maintenance\"),\n    DataSubjectRequest(\"DataSubjectRequest\"),\n    Other(\"Other\")\n            {", "public enum AccessReason {\n\n    AppFunctionality(\"AppFunctionality\"),\n    Analytics(\"Analytics\"),\n    Notifications(\"Notifications\"),\n    ThirdPartyMarketing(\"ThirdPartyMarketing\"),\n    Marketing(\"Marketing\"),\n    FraudPreventionSecurityAndCompliance(\"FraudPreventionSecurityAndCompliance\"),\n    AccountManagement(\"AccountManagement\"),\n    Maintenance(\"Maintenance\"),\n    DataSubjectRequest(\"DataSubjectRequest\"),\n    Other(\"Other\")\n            {", "                public AccessReason adhocReason(String adhocReason) {\n                    this.adhocReason = adhocReason;\n                    return this;\n                }\n\n                @Override\n                public String toString() {\n                    return \"Other:\" + this.adhocReason;\n                }\n            };\n\n    // Details of the access reason. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n    private final String reason;\n\n    // An ad-hoc reason for accessing the Vault data. (optional)\n    protected String adhocReason;\n\n\n    AccessReason(String reason) {\n        this.reason = reason;\n        this.adhocReason = null;\n    }\n", "    public AccessReason adhocReason(String adhocReason) {\n        if (Other == this) {\n            return Other.adhocReason(adhocReason);\n        }\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return String.valueOf(reason);\n    }\n}\n", "    public String toString() {\n        return String.valueOf(reason);\n    }\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/DecryptParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'decrypt' API.\n */\n@Data\n@Builder\npublic class DecryptParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class DecryptParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/RotateTokensParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'rotateTokens' API.\n */\n@Data\n@Builder\npublic class RotateTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class RotateTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/DeleteTokensParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'deleteTokens' API.\n */\n@Data\n@Builder\npublic class DeleteTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * tenantId The tenant ID of the owning object. (optional)\n     */\n    private String tenantId;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class DeleteTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * tenantId The tenant ID of the owning object. (optional)\n     */\n    private String tenantId;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/UpdateEncryptedParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'updateEncrypted' API.\n */\n@Data\n@Builder\npublic class UpdateEncryptedParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class UpdateEncryptedParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/EncryptParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'encrypt' API.\n */\n@Data\n@Builder\npublic class EncryptParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class EncryptParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/SearchTokensParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'searchTokens' API.\n */\n@Data\n@Builder\npublic class SearchTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class SearchTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/client/src/main/java/com/piiano/vault/client/model/UpdateTokensParams.java", "chunked_list": ["package com.piiano.vault.client.model;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n/**\n * Parameters for 'updateTokens' API.\n */\n@Data\n@Builder\npublic class UpdateTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n", "@Data\n@Builder\npublic class UpdateTokensParams {\n\n    /**\n     * collection The name of the collection containing the objects. (required)\n     */\n    private String collection;\n\n    /**\n     * expirationSecs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable. (optional)\n     */\n    private String expirationSecs;\n\n    /**\n     * accessReason Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false. (required)\n     */\n     private AccessReason accessReason;\n\n    /**\n     * reloadCache Reloads the cache before the action. (optional)\n     */\n    private Boolean reloadCache;\n}\n"]}
{"filename": "sdk/hibernate-encryption/src/main/java/com/piiano/vault/orm/encryption/TransformationInterceptor.java", "chunked_list": ["package com.piiano.vault.orm.encryption;\n\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.model.EncryptionType;\nimport lombok.AllArgsConstructor;\nimport org.hibernate.EmptyInterceptor;\nimport org.hibernate.annotations.Parameter;\nimport org.hibernate.type.Type;\nimport org.jetbrains.annotations.NotNull;\nimport org.springframework.stereotype.Component;", "import org.jetbrains.annotations.NotNull;\nimport org.springframework.stereotype.Component;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Field;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@Component\npublic class TransformationInterceptor extends EmptyInterceptor {\n\n    // Intercept the loading of the entity.\n    // onLoad is called after the Encrypted types are decrypted.\n    // In Encrypted.nullSafeGet, (see saveEncryptedValueOnOwner) the Encrypted instance set the encrypted value\n    // on the respective properties of the owner which is passed here in the first argument.\n    // onLoad reflects on the entity and discovers all the properties that are annotated with @Transformation.\n    // Let's call those the transformation fields.\n    // The Transformation annotation specifies the name of the encrypted field and the name of the transformer\n    // that should be applied to the decrypted value of that field in order to set the value of the transformation field.\n    // For each transformation field, the interceptor creates an instance of Encryptor and decrypts the value of the\n    // encrypted field specifying the transformer that should be applied. It then sets the value of the transformation\n    // field with the result.", "@Component\npublic class TransformationInterceptor extends EmptyInterceptor {\n\n    // Intercept the loading of the entity.\n    // onLoad is called after the Encrypted types are decrypted.\n    // In Encrypted.nullSafeGet, (see saveEncryptedValueOnOwner) the Encrypted instance set the encrypted value\n    // on the respective properties of the owner which is passed here in the first argument.\n    // onLoad reflects on the entity and discovers all the properties that are annotated with @Transformation.\n    // Let's call those the transformation fields.\n    // The Transformation annotation specifies the name of the encrypted field and the name of the transformer\n    // that should be applied to the decrypted value of that field in order to set the value of the transformation field.\n    // For each transformation field, the interceptor creates an instance of Encryptor and decrypts the value of the\n    // encrypted field specifying the transformer that should be applied. It then sets the value of the transformation\n    // field with the result.", "    public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) {\n        try {\n            calculateTransformationFields(entity);\n        } catch (ApiException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n        return super.onLoad(entity, id, state, propertyNames, types);\n    }\n\n    @AllArgsConstructor\n    static class TransformationField {\n        Field entityField; // The field defined in the entity that is annotated with Transformation (e.g. \"ssnMask\")\n        String dottedName; // The transformation binding that will be passed to Vault to get the value of the field (e.g. \"ssn.mask\")\n    }\n\n    static class TransformationMappings {\n        TransformationMappings(Field encryptedField) {\n            this.encryptedField = encryptedField;\n            this.transformations = new ArrayList<>();\n        }\n\n        Field encryptedField;\n        List<TransformationField> transformations;\n    }\n\n    private static void calculateTransformationFields(Object entity) throws ApiException, IllegalAccessException {\n        Class<?> clazz = entity.getClass();\n\n        // the table name is the default collection name unless overridden by the Encrypted annotation\n        calculateTransformationFields(\n            entity,\n            getTableName(clazz),\n            findTransformations(clazz));\n    }\n\n    @NotNull\n    private static Map<String, TransformationMappings> findTransformations(Class<?> clazz) {\n\n        // get all fields of the entity - including the transient ones that are not persisted.\n        // (these are assumed to be transformation fields)\n        Map<String, Field> allFields = Arrays.stream(clazz.getDeclaredFields())\n            .collect(Collectors.toMap(\n                Field::getName,\n                field -> field));\n\n        // find all the transformation fields and create a map of the encrypted field name to the transformation fields\n        // where the transformation field is a transformation of the encrypted field.\n        Map<String, TransformationMappings> transformationMap = new HashMap<>();\n", "        for (Field field : clazz.getDeclaredFields()) {\n            if (isTransformationAnnotated(field)) {\n                Transformation transformationAnnotation = getTransformationField(field);\n\n                TransformationMappings mappings = getTransformationMappings(\n                    transformationMap,\n                    allFields,\n                    transformationAnnotation.property());\n\n                mappings.transformations.add(\n                    getTransformationField(\n                        field,\n                        transformationAnnotation));\n            }\n        }\n        return transformationMap;\n    }\n\n    private static void calculateTransformationFields(\n        Object entity,\n        String defaultCollectionName,\n        Map<String, TransformationMappings> transformationMap) throws IllegalAccessException, ApiException {\n", "        for (TransformationMappings mappings : transformationMap.values()) {\n\n            Field encryptedField = mappings.encryptedField;\n\n            // The collection name is the default collection name unless overridden by the Encrypted annotation\n            String collectionName = getUpdatedCollectionName(defaultCollectionName, encryptedField);\n\n            // For each transformation field, the interceptor creates an instance of Encryptor and decrypts the value of the\n            for (TransformationField transformation : mappings.transformations) {\n                // Extract the encrypted value from the entity that was placed on the encrypted field by the Encrypted type\n                String encryptedValue = getFieldValue(entity, encryptedField);", "            for (TransformationField transformation : mappings.transformations) {\n                // Extract the encrypted value from the entity that was placed on the encrypted field by the Encrypted type\n                String encryptedValue = getFieldValue(entity, encryptedField);\n                if (encryptedValue == null) {\n                    // If the encrypted value is null (was not set), the transformation cannot be applied.\n                    continue;\n                }\n                // Decrypt the value using an Encryptor that calls Vault specifying the dotted name of the transformation.\n                String decryptedValue = getDecryptedValue(collectionName, transformation.dottedName, encryptedValue);\n                // Set the decrypted result of the transformation on the transformation field\n                setFieldValue(transformation.entityField, entity, decryptedValue);\n            }\n        }\n    }\n\n    private static String getUpdatedCollectionName(String defaultName, Field field) {\n        // The collection name is the default collection name unless overridden by the Encrypted annotation", "        if (isTypeAnnotated(field)) {\n            for (Parameter parameter : getTypeAnnotation(field).parameters()) {\n                if (isCollectionParameter(parameter)) {\n                    return parameter.value();\n                }\n            }\n        }\n        return defaultName;\n    }\n\n    // Create an Encryptor that calls Vault specifying the dotted name of the transformation and decrypt returning the transformed value.\n    private static String getDecryptedValue(String collectionName, String dottedName, String encryptedValue) throws ApiException {\n        Encryptor encryptor = new Encryptor(\n            EncryptionType.DETERMINISTIC,\n            collectionName,\n            dottedName);\n        return encryptor.decrypt(encryptedValue).toString();\n    }\n\n    @NotNull\n    private static TransformationField getTransformationField(Field field, Transformation transformation) {\n        return new TransformationField(\n            field,\n            String.format(\"%s.%s\", transformation.property(), transformation.transformer()));\n    }\n\n    private static TransformationMappings getTransformationMappings(\n        Map<String, TransformationMappings> transformationMap,\n        Map<String, Field> allFields,\n        String encryptedPropertyName) {\n", "        if (transformationMap.containsKey(encryptedPropertyName)) {\n            return transformationMap.get(encryptedPropertyName);\n        }\n\n        // If this is the first transformation of the encryptedPropertyName, create a new mapping.\n        Field encryptedField = allFields.get(encryptedPropertyName);\n\n        TransformationMappings mappings = new TransformationMappings(encryptedField);\n\n        // Add the mapping to the map of mappings\n        transformationMap.put(encryptedPropertyName, mappings);\n\n        return mappings;\n    }\n\n    private static void setFieldValue(Field entityField, Object entity, String decryptedValue) throws IllegalAccessException {\n        entityField.setAccessible(true);\n        entityField.set(entity, decryptedValue);\n    }\n\n    private static String getFieldValue(Object entity, Field field) throws IllegalAccessException {\n        field.setAccessible(true);\n        Object value = field.get(entity);", "        if (value == null) {\n            return null;\n        }\n        return value.toString();\n    }\n\n    // TODO: Assumes that the Type annotation is only used for the Encrypted type. This is not necessarily true.\n    private static boolean isTypeAnnotated(Field field) {\n        return field.isAnnotationPresent(org.hibernate.annotations.Type.class);\n    }\n\n    private static org.hibernate.annotations.Type getTypeAnnotation(Field field) {\n        return field.getAnnotation(org.hibernate.annotations.Type.class);\n    }\n\n    private static boolean isTransformationAnnotated(Field field) {\n        return field.isAnnotationPresent(Transformation.class);\n    }\n\n    private static Transformation getTransformationField(Field field) {\n        return field.getAnnotation(Transformation.class);\n    }\n\n    // We support getting the collection name from the Table annotation or the Encrypted annotation.\n    // Get the table name here. It may be overridden by the Encrypted annotation.\n    private static String getTableName(Class<?> clazz) {", "        if (clazz.isAnnotationPresent(javax.persistence.Table.class)) {\n            return clazz.getAnnotation(javax.persistence.Table.class).name();\n        }\n        return \"\";\n    }\n\n    private static boolean isCollectionParameter(Parameter parameter) {\n        return parameter.name().equals(Encrypted.COLLECTION);\n    }\n}\n"]}
{"filename": "sdk/hibernate-encryption/src/main/java/com/piiano/vault/orm/encryption/Transformation.java", "chunked_list": ["package com.piiano.vault.orm.encryption;\n\nimport java.lang.annotation.*;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Transformation{\n\n    // The property name of the field that is annotated as Encrypted and will be transformed (e.g. \"ssn\")\n    String property() default \"\";", "    // The property name of the field that is annotated as Encrypted and will be transformed (e.g. \"ssn\")\n    String property() default \"\";\n    // The name of the transformer to be used (e.g. \"mask\")\n    String transformer() default \"\";\n}"]}
{"filename": "sdk/hibernate-encryption/src/main/java/com/piiano/vault/orm/encryption/Encryptor.java", "chunked_list": ["package com.piiano.vault.orm.encryption;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.piiano.vault.client.CryptoClient;\nimport com.piiano.vault.client.model.AccessReason;\nimport com.piiano.vault.client.model.DefaultParams;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.model.*;\nimport lombok.Getter;", "import com.piiano.vault.client.openapi.model.*;\nimport lombok.Getter;\n\nimport java.util.Collections;\n\nimport static com.piiano.vault.client.VaultClient.getPvaultClient;\n\npublic class Encryptor {\n\n\tpublic static final String PREFIX_ENCRYPTED = \"encrypted_\";\n\n\tprivate final CryptoClient cryptoClient;\n\n\tprivate final EncryptionType encryptionType;\n\n\t@Getter\n\tprivate final String propertyName;\n\n\tpublic Encryptor(EncryptionType encryptionType, String collection, String propertyName) {\n\n\t\tthis.cryptoClient = new CryptoClient(getPvaultClient(), DefaultParams.builder()\n\t\t\t\t.collection(collection)\n\t\t\t\t.accessReason(AccessReason.AppFunctionality).build());\n\n\t\tthis.encryptionType = encryptionType;\n\t\tthis.propertyName = propertyName;\n\t}\n", "\tpublic static final String PREFIX_ENCRYPTED = \"encrypted_\";\n\n\tprivate final CryptoClient cryptoClient;\n\n\tprivate final EncryptionType encryptionType;\n\n\t@Getter\n\tprivate final String propertyName;\n\n\tpublic Encryptor(EncryptionType encryptionType, String collection, String propertyName) {\n\n\t\tthis.cryptoClient = new CryptoClient(getPvaultClient(), DefaultParams.builder()\n\t\t\t\t.collection(collection)\n\t\t\t\t.accessReason(AccessReason.AppFunctionality).build());\n\n\t\tthis.encryptionType = encryptionType;\n\t\tthis.propertyName = propertyName;\n\t}\n", "\tpublic boolean isEncrypted(String propValue) {\n\t\treturn propValue != null\n\t\t\t\t&& propValue.startsWith(PREFIX_ENCRYPTED);\n\t}\n\n\tpublic String encrypt(String propValue) throws ApiException {\n\n\t\tEncryptionRequest request = new EncryptionRequest()\n\t\t\t\t.type(this.encryptionType)\n\t\t\t\t._object(new InputObject().fields(ImmutableMap.of(this.propertyName, propValue)));\n\n\t\tEncryptedValue encrypted = this.cryptoClient.encrypt(request);\n", "\t\tif (encrypted != null) {\n\t\t\treturn PREFIX_ENCRYPTED + encrypted.getCiphertext();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic Object decrypt(String ciphertext) throws ApiException {\n\n\t\tif (ciphertext == null) {\n\t\t\tthrow new ApiException(\"ciphertext must not be null\");\n\t\t}\n", "\t\tif (ciphertext == null) {\n\t\t\tthrow new ApiException(\"ciphertext must not be null\");\n\t\t}\n\n\t\tif (isEncrypted(ciphertext)) {\n\t\t\tciphertext = ciphertext.substring(PREFIX_ENCRYPTED.length());\n\t\t}\n\n\t\tDecryptionRequest request = new DecryptionRequest().encryptedObject(\n\t\t\t\tnew EncryptedObjectInput().ciphertext(ciphertext)).props(ImmutableList.of(this.propertyName));\n\n\t\tDecryptedObject decrypted = this.cryptoClient.decrypt(request, Collections.emptySet());\n", "\t\tif (decrypted != null) {\n\t\t\treturn decrypted.getFields().get(this.propertyName);\n\t\t}\n\t\treturn null;\n\t}\n}\n"]}
{"filename": "sdk/hibernate-encryption/src/main/java/com/piiano/vault/orm/encryption/Encrypted.java", "chunked_list": ["package com.piiano.vault.orm.encryption;\n\nimport com.piiano.vault.client.openapi.model.EncryptionType;\nimport org.hibernate.HibernateException;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport javax.persistence.Column;\nimport java.io.Serializable;", "import javax.persistence.Column;\nimport java.io.Serializable;\nimport java.lang.reflect.Field;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.stream.Collectors;\n", "import java.util.stream.Collectors;\n\n/**\n * This class is used to tokenize a field of an entity. it implements the UserType interface\n * This class implements the nullSafeSet method which is called by the ORM before persisting the entity and\n * before executing the find queries\n * In the implementation of the nullSafeSet method, the field value is being replaced by the token id and\n * is set to the field.\n * The token id is calculated before the entity is persisted and is stored in the vault by using the hash\n * method of the TokenApi which retrieves equal token id for deterministic token for the same value.", " * The token id is calculated before the entity is persisted and is stored in the vault by using the hash\n * method of the TokenApi which retrieves equal token id for deterministic token for the same value.\n */\npublic class Encrypted implements UserType, DynamicParameterizedType {\n\n\tpublic static final String TYPE = \"type\";\n\tpublic static final String COLLECTION = \"collection\";\n\tpublic static final String PROPERTY = \"property\";\n\n\tprivate Encryptor encryptor;\n\n\t@Override\n\tpublic int[] sqlTypes() {\n\t\treturn new int[] { Types.VARCHAR };\n\t}\n\n\t@Override\n\tpublic Class<String> returnedClass() {\n\t\treturn String.class;\n\t}\n\n\t@Override", "\tpublic boolean equals(Object x, Object y) throws HibernateException {\n\t\treturn Objects.equals(x, y);\n\t}\n\n\t@Override\n\tpublic int hashCode(Object x) throws HibernateException {\n\t\treturn x != null ? x.hashCode() : 0;\n\t}\n\n\t@Override\n\tpublic Object deepCopy(Object value) throws HibernateException {\n\t\treturn value;\n\t}\n\n\t@Override", "\tpublic Object deepCopy(Object value) throws HibernateException {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic boolean isMutable() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Serializable disassemble(Object value) throws HibernateException {\n\t\tObject deepCopy = deepCopy(value);", "\tpublic Serializable disassemble(Object value) throws HibernateException {\n\t\tObject deepCopy = deepCopy(value);\n\t\tif ((deepCopy instanceof Serializable)) {\n\t\t\treturn (Serializable) deepCopy;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Object assemble(Serializable cached, Object owner) throws HibernateException {\n\t\treturn deepCopy(cached);\n\t}\n\n\t@Override", "\tpublic Object assemble(Serializable cached, Object owner) throws HibernateException {\n\t\treturn deepCopy(cached);\n\t}\n\n\t@Override\n\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException {\n\t\treturn deepCopy(original);\n\t}\n\n\t@Override\n\tpublic Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)\n\t\t\tthrows HibernateException, SQLException {\n", "\tpublic Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)\n\t\t\tthrows HibernateException, SQLException {\n\n\t\ttry {\n\t\t\tString value = rs.getString(names[0]);\n\n\t\t\tsaveEncryptedValueOnOwner(owner, value);\n\n\t\t\tif (encryptor.isEncrypted(value)) {\n\t\t\t\tvalue = encryptor.decrypt(value).toString();\n\t\t\t}\n\t\t\treturn value;\n\t\t} catch (Exception e) {\n\t\t\tthrow new HibernateException(e);\n\t\t}\n\t}\n\n\t@Override", "\t\t\tif (encryptor.isEncrypted(value)) {\n\t\t\t\tvalue = encryptor.decrypt(value).toString();\n\t\t\t}\n\t\t\treturn value;\n\t\t} catch (Exception e) {\n\t\t\tthrow new HibernateException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException, SQLException {\n", "\tpublic void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException, SQLException {\n\n\t\tif (value == null) {\n\t\t\tst.setNull(index, Types.VARCHAR);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tString propValue = value.toString();\n", "\t\ttry {\n\t\t\tString propValue = value.toString();\n\n\t\t\tif (propValue != null && !encryptor.isEncrypted(propValue)) {\n\t\t\t\tpropValue = encryptor.encrypt(propValue);\n\t\t\t}\n\n\t\t\tst.setString(index, propValue);\n\t\t} catch (Exception e) {\n\t\t\tthrow new HibernateException(e);\n\t\t}\n\t}\n\n\t@Override", "\tpublic void setParameterValues(Properties parameters) {\n\n\t\tEncryptionType encryptionType = EncryptionType.DETERMINISTIC;\n\t\tif (EncryptionType.RANDOMIZED.toString().equalsIgnoreCase(parameters.getProperty(TYPE))) {\n\t\t\tencryptionType = EncryptionType.RANDOMIZED;\n\t\t}\n\n\t\tParameterType parameterType = (ParameterType) parameters.get(DynamicParameterizedType.PARAMETER_TYPE);\n\n\t\tString collection = parameters.getProperty(COLLECTION) != null ?\n\t\t\t\tparameters.getProperty(COLLECTION) :\n\t\t\t\tparameterType.getTable();\n\n\t\tString propertyName = parameters.getProperty(PROPERTY);", "\t\tif (propertyName == null) {\n\t\t\tOptional<String> columnName =\n\t\t\t\t\tArrays.stream(parameterType.getAnnotationsMethod())\n\t\t\t\t\t\t\t.filter(a -> a.annotationType().isAssignableFrom(Column.class))\n\t\t\t\t\t\t\t.map(c -> ((Column) c).name())\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\tif (columnName.isPresent()) {\n\t\t\t\tpropertyName = columnName.get();\n\t\t\t}\n\t\t}\n\n\t\tencryptor = new Encryptor(encryptionType, collection, propertyName);\n\t}\n\n\tprivate void saveEncryptedValueOnOwner(Object owner, String encryptedValue) throws IllegalAccessException {\n\t\tClass<?> clazz = owner.getClass();\n\t\tOptional<Field> propertyField = Arrays.stream(clazz.getDeclaredFields())\n\t\t\t.filter(f -> f.getName().equals(encryptor.getPropertyName()))\n\t\t\t.collect(Collectors.toList())\n\t\t\t.stream().findFirst();\n", "\t\tif (propertyField.isPresent()) {\n\t\t\tField field = propertyField.get();\n\t\t\tfield.setAccessible(true);\n\t\t\tfield.set(owner, encryptedValue);\n\t\t}\n\t}\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/test/java/com/demo/app/CollectionSetup.java", "chunked_list": ["package com.demo.app;\n\nimport com.piiano.vault.client.openapi.ApiClient;\nimport com.piiano.vault.client.openapi.ApiException;\nimport com.piiano.vault.client.openapi.CollectionsApi;\nimport com.piiano.vault.client.openapi.Configuration;\nimport com.piiano.vault.client.openapi.model.Collection;\nimport com.piiano.vault.client.openapi.model.Property;\n\nimport java.util.Collections;", "\nimport java.util.Collections;\n\npublic class CollectionSetup {\n\n    private static final String collectionName = \"customers\";\n\n    public static void setUp() throws ApiException {\n        addCollection();\n    }\n", "    public static void tearDown() {\n        deleteCollectionIfExists();\n    }\n\n    private static Collection addCollection() throws ApiException {\n\n        ApiClient pvaultClient = getApiClient();\n        CollectionsApi collectionsApi = new CollectionsApi(pvaultClient);\n\n        deleteCollectionIfExists();\n\n        Collection collection = createCollection();\n        return collectionsApi.addCollection(collection, \"json\", Collections.emptySet());\n    }\n\n    private static void deleteCollectionIfExists() {\n        ApiClient pvaultClient = getApiClient();\n        CollectionsApi collectionsApi = new CollectionsApi(pvaultClient);\n", "        try {\n            collectionsApi.deleteCollection(collectionName);\n        } catch (ApiException e) {\n            // Collection not found - do nothing.\n        }\n    }\n\n    public static Collection createCollection() {\n        return new Collection()\n                .name(collectionName)\n                .type(Collection.TypeEnum.PERSONS)\n                .addPropertiesItem(\n                        new Property().name(\"name\").dataTypeName(\"NAME\").description(\"Name\")\n                                .isEncrypted(true)\n                ).addPropertiesItem(\n                        new Property().name(\"phone\").dataTypeName(\"PHONE_NUMBER\").description(\"Phone\")\n                                .isEncrypted(true).isNullable(true)\n                ).addPropertiesItem(\n                        new Property().name(\"ssn\").dataTypeName(\"SSN\").description(\"ssn\")\n                            .isEncrypted(true).isNullable(true)\n                ).addPropertiesItem(\n                new Property().name(\"email\").dataTypeName(\"EMAIL\").description(\"ssn\")\n                    .isEncrypted(true).isNullable(true)\n            );\n    }\n\n    private static ApiClient getApiClient() {\n        // Create configuration, bearer auth and client API\n        ApiClient pvaultClient = Configuration.getDefaultApiClient();\n        pvaultClient.setBasePath(\"http://localhost:8123\");\n        pvaultClient.setBearerToken(\"pvaultauth\");\n        pvaultClient.addDefaultHeader(\"Content-Type\", \"application/json\");\n        return pvaultClient;\n    }\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/test/java/com/demo/app/service/CustomerServiceTest.java", "chunked_list": ["package com.demo.app.service;\n\nimport com.demo.app.CollectionSetup;\nimport com.demo.app.dal.Customer;\nimport com.google.common.collect.ImmutableList;\nimport com.piiano.vault.client.openapi.ApiException;\nimport org.assertj.core.util.Lists;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.TestPropertySource;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n", "import java.util.stream.StreamSupport;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n@SpringBootTest\n@TestPropertySource(locations = \"classpath:application-test.properties\")\nclass CustomerServiceTest {\n\n    @Autowired\n    private CustomerService customerService;", "    @Autowired\n    private CustomerService customerService;\n\n    @BeforeEach\n    public void beforeEach() throws ApiException {\n        CollectionSetup.setUp();\n    }\n\n    @AfterEach\n    public void afterEach() {\n        CollectionSetup.tearDown();\n    }\n\n    @Test", "    public void afterEach() {\n        CollectionSetup.tearDown();\n    }\n\n    @Test\n    public void testCreateAndFindCustomer() {\n\n        customerService.addCustomer(getCustomer());\n\n        // Note that the customer name is \"John\" is marked as Encrypted and is therefore stored in your\n        // database as a ciphertext value. And yet you can search for it using the plaintext value.\n        List<Customer> results = customerService.findCustomerByName(\"John\");\n        assertEquals(1, results.size());\n        Customer actual = results.get(0);\n\n        assertEquals(\"John\", actual.getName());\n        assertEquals(\"123-45-6789\", actual.getSsn());\n        assertEquals(\"david@gmail.com\", actual.getEmail());\n        assertEquals(\"+888888888\", actual.getPhone());\n        assertEquals(\"CA\", actual.getState());\n        assertEquals(\"***-**-6789\", actual.getSsnMask());\n        assertEquals(\"d****@gmail.com\", actual.getEmailMask());\n\n        // Cleanup.\n\n        List<Integer> customerIds = results.stream()\n            .map(Customer::getId)\n            .collect(Collectors.toList());\n\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testCreateAndGetCustomer() {\n\n        customerService.addCustomer(getCustomer());\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(1, customerIds.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testCreateMultipleCustomers() {\n\n        List<Customer> customers = getCustomers();\n        customers.forEach(u -> customerService.addCustomer(u));\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(3, customerIds.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testFindCustomersByName() {\n\n        List<Customer> customers = Lists.newArrayList(getCustomers());\n        customers.add(getCustomer());\n\n        customers.forEach(u -> customerService.addCustomer(u));\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(4, customerIds.size());\n\n        List<Customer> personNamedJohn = customerService.findCustomerByName(\"John\");\n        assertEquals(2, personNamedJohn.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testFindCustomersByPhone() {\n\n        List<Customer> customers = Lists.newArrayList(getCustomers());\n        customers.add(getCustomer());\n\n        String phone = \"+12345678\";\n        for (int i = 0; i < customers.size(); i++) {\n            if (i == 0) {\n                continue;\n            }\n            customers.get(i).setPhone(phone);\n        }\n\n        customers.forEach(u -> customerService.addCustomer(u));\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(4, customerIds.size());\n\n        List<Customer> personNamedJohn = customerService.findCustomerByPhone(phone);\n        assertEquals(3, personNamedJohn.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testUpdateCustomer() {\n\n        List<Customer> customers = Lists.newArrayList(getCustomers());\n        customers.forEach(u -> customerService.addCustomer(u));\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(3, customerIds.size());\n\n        String newName = \"Steven\";\n        Customer customerToUpdate = new Customer();\n        customerToUpdate.setId(customerIds.get(0));\n        customerToUpdate.setName(newName);\n        customerService.updateCustomer(customerToUpdate);\n\n        List<Customer> customer = customerService.findCustomerByName(newName);\n        assertEquals(1, customer.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    @Test", "    public void testDeleteCustomer() {\n\n        List<Customer> customers = Lists.newArrayList(getCustomers());\n        customers.forEach(u -> customerService.addCustomer(u));\n\n        List<Integer> customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n\n        assertEquals(3, customerIds.size());\n\n        customerService.deleteCustomer(customerIds.get(0));\n\n        customerIds = StreamSupport.stream(customerService.getAllCustomers().spliterator(), false)\n                .map(Customer::getId)\n                .collect(Collectors.toList());\n        assertEquals(2, customerIds.size());\n\n        // Cleanup.\n        deleteCustomers(customerIds);\n    }\n\n    private static Customer getCustomer() {\n        Customer customer = new Customer();\n        customer.setName(\"John\");\n        customer.setPhone(\"+8-888-88888\");\n        customer.setState(\"CA\");\n        customer.setSsn(\"123-45-6789\");\n        customer.setEmail(\"david@gmail.com\");\n        return customer;\n    }\n\n    private static List<Customer> getCustomers() {\n        Customer customer1 = getCustomer();\n\n        Customer customer2 = new Customer();\n        customer2.setName(\"Alice\");\n        customer2.setPhone(\"+11111111\");\n        customer2.setState(\"NY\");\n        customer2.setSsn(\"123-45-6789\");\n\n        Customer customer3 = new Customer();\n        customer3.setName(\"Bob\");\n        customer3.setPhone(\"+22222222\");\n        customer3.setState(\"AZ\");\n        customer3.setSsn(\"321-45-6789\");\n\n        return ImmutableList.of(customer1, customer2, customer3);\n    }\n\n    private void deleteCustomers(List<Integer> customerIds) {\n        customerIds.forEach(id -> customerService.deleteCustomer(id));\n    }\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/DemoApplication.java", "chunked_list": ["package com.demo.app;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n", "    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/InterceptorConfig.java", "chunked_list": ["package com.demo.app;\n\nimport com.piiano.vault.orm.encryption.TransformationInterceptor;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// In order to support fields annotated @Transformation you must inject the TransformationInterceptor.\n// This configuration class is an example of how to do this.", "// In order to support fields annotated @Transformation you must inject the TransformationInterceptor.\n// This configuration class is an example of how to do this.\n@Configuration\n@ComponentScan(\" com.piiano.vault.orm.encryption\")\npublic class InterceptorConfig {\n    @Bean\n    public HibernatePropertiesCustomizer hibernatePropertiesCustomizer(TransformationInterceptor interceptor) {\n        return props -> props.put(\"hibernate.session_factory.interceptor\", interceptor);\n    }\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/dal/CustomerRepository.java", "chunked_list": ["package com.demo.app.dal;\n\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.List;\n\npublic interface CustomerRepository extends CrudRepository<Customer, Integer> {\n\n    List<Customer> findCustomerByName(String name);\n\n    List<Customer> findCustomerByPhone(String phone);\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/dal/Customer.java", "chunked_list": ["package com.demo.app.dal;\n\nimport com.piiano.vault.orm.encryption.Encrypted;\nimport com.piiano.vault.orm.encryption.Transformation;\nimport lombok.*;\nimport org.hibernate.annotations.Parameter;\nimport org.hibernate.annotations.Type;\nimport org.hibernate.annotations.TypeDef;\n\nimport javax.persistence.*;", "\nimport javax.persistence.*;\n\nimport static com.piiano.vault.orm.encryption.Encrypted.PROPERTY;\n\n@Table(name = \"customers\")\n@Entity\n@TypeDef(name = \"Encrypted\", typeClass = Encrypted.class)\n@Getter\n@Setter", "@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Customer {\n\n    // The following properties are persisted in the database.\n    // Those that are annotated with @Type(type = \"Encrypted\") will be encrypted by Vault and persisted as ciphertext.\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Integer id;\n\n    @Column(name = \"name\")\n    @Type(type = \"Encrypted\")\n    private String name;\n\n    @Column(name = \"email\")\n    @Type(type = \"Encrypted\")\n    private String email;\n\n    @Column(name = \"phone\")\n    @Type(type = \"Encrypted\")\n    private String phone;\n\n    @Column(name = \"ssn\")\n    @Type(type = \"Encrypted\")\n    private String ssn;\n\n    @Column(name = \"dob\")\n    @Type(type = \"Encrypted\")\n    private String dob;\n\n    @Column(name = \"state\")\n    private String state;\n\n    // The following properties are not persisted in the database.\n    // They are automatically calculated by calling Vault to decrypt the field named by \"property\",\n    // applying the transformer named by \"transformer\".\n    @Transient\n    @Transformation(property = \"ssn\", transformer = \"mask\")\n    private String ssnMask;\n\n    @Transient\n    @Transformation(property = \"email\", transformer = \"mask\")\n    private String emailMask;\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/controller/MainController.java", "chunked_list": ["package com.demo.app.controller;\n\nimport com.demo.app.dal.Customer;\nimport com.demo.app.service.CustomerService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;", "import org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.List;\n\n@Controller\n@RequestMapping(path=\"/demo\")\npublic class MainController {\n\n    @Autowired\n    private CustomerService customerService;\n\n    @GetMapping(path=\"/all\")\n    public @ResponseBody Iterable<Customer> getAllCustomers() {\n        return customerService.getAllCustomers();\n    }\n\n    @GetMapping(path=\"/add-customer\")\n    public @ResponseBody String addCustomer(Customer customer) {\n\n        customerService.addCustomer(customer);\n        return \"Saved\";\n    }\n\n    @GetMapping(path=\"/update-customer\")\n    public @ResponseBody String updateCustomer(Customer customer) {\n", "        if (customerService.updateCustomer(customer)) {\n            return \"Updated\";\n        }\n        return \"Not Found\";\n    }\n\n    @GetMapping(path=\"/delete-customer\")\n    public @ResponseBody String deleteCustomer(@RequestParam Integer id) {\n        if (customerService.deleteCustomer(id)) {\n            return \"Deleted\";\n        }\n        return \"Not Found\";\n    }\n\n    @GetMapping(path=\"/find-customer-by-name\")\n    public @ResponseBody List<Customer> findCustomerByName(@RequestParam String name) {\n\n        return customerService.findCustomerByName(name);\n    }\n\n    @GetMapping(path=\"/find-customer-by-phone\")\n    public @ResponseBody List<Customer> findCustomerByPhone(@RequestParam(name = \"phone\") String phone) {\n\n        return customerService.findCustomerByPhone(phone);\n    }\n}\n", "        if (customerService.deleteCustomer(id)) {\n            return \"Deleted\";\n        }\n        return \"Not Found\";\n    }\n\n    @GetMapping(path=\"/find-customer-by-name\")\n    public @ResponseBody List<Customer> findCustomerByName(@RequestParam String name) {\n\n        return customerService.findCustomerByName(name);\n    }\n\n    @GetMapping(path=\"/find-customer-by-phone\")\n    public @ResponseBody List<Customer> findCustomerByPhone(@RequestParam(name = \"phone\") String phone) {\n\n        return customerService.findCustomerByPhone(phone);\n    }\n}\n"]}
{"filename": "examples/demo-app-hibernate-encryption/src/main/java/com/demo/app/service/CustomerService.java", "chunked_list": ["package com.demo.app.service;\n\nimport com.demo.app.dal.Customer;\nimport com.demo.app.dal.CustomerRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n", "import java.util.Optional;\n\n@Service\npublic class CustomerService {\n\n    @Autowired\n    private CustomerRepository customerRepository;\n\n    public Iterable<Customer> getAllCustomers() {\n        return customerRepository.findAll();\n    }\n\n    public Optional<Customer> getCustomer(Integer id) {\n        return customerRepository.findById(id);\n    }\n", "    public void addCustomer(Customer customer) {\n        customerRepository.save(customer);\n    }\n\n    public boolean updateCustomer(Customer customer) {\n        if (customer.getId() != null && customerRepository.existsById(customer.getId())) {\n            customerRepository.save(customer);\n            return true;\n        }\n        return false;\n    }\n", "    public boolean deleteCustomer(Integer id) {\n        if (customerRepository.existsById(id)) {\n            customerRepository.deleteById(id);\n            return true;\n        }\n        return false;\n    }\n\n    public List<Customer> findCustomerByName(String name) {\n        return customerRepository.findCustomerByName(name);\n    }\n\n    public List<Customer> findCustomerByPhone(String phone) {\n        return customerRepository.findCustomerByPhone(phone);\n    }\n}\n"]}
