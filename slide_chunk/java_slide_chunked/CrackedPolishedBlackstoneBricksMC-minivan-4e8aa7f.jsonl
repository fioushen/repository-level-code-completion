{"filename": "demo/src/main/java/test/Test.java", "chunked_list": ["package test;\n\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.player.LocalPlayer;\n\n/**\n * Nonsensical code, but it uses some classes, methods, and fields from MC\n */\npublic class Test {\n\tprivate static final Minecraft mc = Minecraft.getInstance();\n\tstatic {\n\t\tLocalPlayer gamer = mc.player;", "public class Test {\n\tprivate static final Minecraft mc = Minecraft.getInstance();\n\tstatic {\n\t\tLocalPlayer gamer = mc.player;\n\t\tif(gamer != null) System.out.println(gamer.isFallFlying());\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/VersionManifest.java", "chunked_list": ["package agency.highlysuspect.minivan;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.annotations.SerializedName;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.nio.file.Files;", "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A per-version Minecraft version manifest.\n * <p>\n * This class is intended to be deserialized with Google GSON.", " * <p>\n * This class is intended to be deserialized with Google GSON.\n */\n@SuppressWarnings(\"unused\")\npublic class VersionManifest {\n\tpublic static VersionManifest read(Path path) throws IOException {\n\t\ttry(BufferedReader reader = Files.newBufferedReader(path)) {\n\t\t\treturn new Gson().fromJson(reader, VersionManifest.class);\n\t\t}\n\t}\n\t\n\tpublic List<Library> libraries;\n\tpublic Map<String, Downloads> downloads;", "\t@SerializedName(\"assetIndex\") public AssetIndexReference assetIndexReference;\n\tpublic String id; //version number\n\tpublic String mainClass;\n\tpublic String minecraftArguments;\n\t\n\tpublic String getUrl(String type) {\n\t\tDownloads dl = downloads.get(type);\n\t\t\n\t\tif(dl == null) {\n\t\t\tString message = \"No download of type '\" + type + \"' available in the Minecraft \" + id + \" version manifest.\";\n\t\t\tif(type.endsWith(\"_mappings\")) message += \"\\nIt looks like Mojang did not provide official mappings for this version.\";\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t\t\n\t\treturn dl.url;\n\t}\n\t", "\t\tif(dl == null) {\n\t\t\tString message = \"No download of type '\" + type + \"' available in the Minecraft \" + id + \" version manifest.\";\n\t\t\tif(type.endsWith(\"_mappings\")) message += \"\\nIt looks like Mojang did not provide official mappings for this version.\";\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t\t\n\t\treturn dl.url;\n\t}\n\t\n\tpublic static class Downloads {\n\t\tpublic String url;", "\tpublic static class Downloads {\n\t\tpublic String url;\n\t\tpublic String sha1;\n\t}\n\t\n\tpublic static class AssetIndexReference {\n\t\tpublic String id;\n\t\tpublic String sha1;\n\t\tpublic String url;\n\t}\n\t", "\t\tpublic String url;\n\t}\n\t\n\tpublic static class Library {\n\t\tpublic String name;\n\t\t@SerializedName(\"url\") public String forgeDownloadRoot; //used by Forge 1.6/1.7's version.json, i don't think it's vanilla\n\t\tpublic JsonObject natives;\n\t\tpublic JsonObject downloads;\n\t\tprivate Artifact artifact;\n\t\tpublic Rule[] rules;\n\t\t\n\t\t/** url pattern that can be appended to mojang's libraries.minecraft.net server */", "\t\tpublic String getURLSuffix() {\n\t\t\tString[] parts = this.name.split(\":\", 3);\n\t\t\treturn parts[0].replace(\".\", \"/\") + \"/\" + parts[1] + \"/\" + parts[2] + \"/\" + parts[1] + \"-\" + parts[2] + getClassifier() + \".jar\";\n\t\t}\n\t\t\n\t\tpublic Path getPath(Path basePath) {\n\t\t\treturn basePath.resolve(MinivanPlugin.filenameSafe(name) + \".jar\");\n\t\t}\n\t\t\n\t\tpublic String getSha1() {\n\t\t\tif (this.downloads == null) {\n\t\t\t\treturn \"\";", "\t\tpublic String getSha1() {\n\t\t\tif (this.downloads == null) {\n\t\t\t\treturn \"\";\n\t\t\t} else if (this.downloads.getAsJsonObject(\"artifact\") == null) {\n\t\t\t\treturn \"\";\n\t\t\t} else if (this.downloads.getAsJsonObject(\"artifact\").get(\"sha1\") == null) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\treturn this.downloads.getAsJsonObject(\"artifact\").get(\"sha1\").getAsString();\n\t\t\t}\n\t\t}\n\t\t", "\t\tpublic String getClassifier() {\n\t\t\tif (natives == null) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\tJsonElement element = natives.get(OperatingSystem.getOS().replace(\"${arch}\", OperatingSystem.getArch()));\n\t\t\t\t\n\t\t\t\tif (element == null) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn \"-\" + element.getAsString().replace(\"\\\"\", \"\").replace(\"${arch}\", OperatingSystem.getArch());\n\t\t\t}\n\t\t}\n\t\t", "\t\tpublic boolean isNative() {\n\t\t\treturn getClassifier().contains(\"natives\");\n\t\t}\n\t\t\n\t\tpublic boolean allowed() {\n\t\t\tif (this.rules == null || this.rules.length <= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tboolean success = false;\n\t\t\t", "\t\t\tfor (Rule rule : this.rules) {\n\t\t\t\tif (rule.os != null && rule.os.name != null) {\n\t\t\t\t\tif (rule.os.name.equalsIgnoreCase(OperatingSystem.getOS())) {\n\t\t\t\t\t\treturn rule.action.equalsIgnoreCase(\"allow\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsuccess = rule.action.equalsIgnoreCase(\"allow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn success;\n\t\t}\n\t\t", "\t\tpublic String getArtifactName() {\n\t\t\tif (artifact == null) {\n\t\t\t\tartifact = new Artifact(name);\n\t\t\t}\n\t\t\t\n\t\t\tif (natives != null) {\n\t\t\t\tJsonElement jsonElement = natives.get(OperatingSystem.getOS());\n\t\t\t\t\n\t\t\t\tif (jsonElement != null) {\n\t\t\t\t\treturn artifact.getArtifact(jsonElement.getAsString());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn artifact.getArtifact(artifact.classifier);\n\t\t}\n\t\t\n\t\tprivate static class Artifact {\n\t\t\tprivate final String domain, name, version, classifier, ext;\n\t\t\t\n\t\t\tArtifact(String name) {\n\t\t\t\tString[] splitedArtifact = name.split(\":\");\n\t\t\t\tint idx = splitedArtifact[splitedArtifact.length - 1].indexOf('@');\n\t\t\t\t", "\t\t\t\tif (jsonElement != null) {\n\t\t\t\t\treturn artifact.getArtifact(jsonElement.getAsString());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn artifact.getArtifact(artifact.classifier);\n\t\t}\n\t\t\n\t\tprivate static class Artifact {\n\t\t\tprivate final String domain, name, version, classifier, ext;\n\t\t\t\n\t\t\tArtifact(String name) {\n\t\t\t\tString[] splitedArtifact = name.split(\":\");\n\t\t\t\tint idx = splitedArtifact[splitedArtifact.length - 1].indexOf('@');\n\t\t\t\t", "\t\t\t\tif (idx != -1) {\n\t\t\t\t\text = splitedArtifact[splitedArtifact.length - 1].substring(idx + 1);\n\t\t\t\t\tsplitedArtifact[splitedArtifact.length - 1] = splitedArtifact[splitedArtifact.length - 1].substring(0, idx);\n\t\t\t\t} else {\n\t\t\t\t\text = \"jar\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.domain = splitedArtifact[0];\n\t\t\t\tthis.name = splitedArtifact[1];\n\t\t\t\tthis.version = splitedArtifact[2];\n\t\t\t\tthis.classifier = splitedArtifact.length > 3 ? splitedArtifact[3] : null;\n\t\t\t}\n\t\t\t", "\t\t\tpublic String getArtifact(String classifier) {\n\t\t\t\tString ret = domain + \":\" + name + \":\" + version;\n\t\t\t\t\n\t\t\t\tif (classifier != null && classifier.indexOf('$') > -1) {\n\t\t\t\t\tclassifier = classifier.replace(\"${arch}\", OperatingSystem.getArch());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (classifier != null) {\n\t\t\t\t\tret += \":\" + classifier;\n\t\t\t\t}\n\t\t\t\t", "\t\t\t\tif (!\"jar\".equals(ext)) {\n\t\t\t\t\tret += \"@\" + ext;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String getClassifier() {\n\t\t\t\treturn classifier;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static class Rule {", "\t\tpublic String action;\n\t\tpublic OS os;\n\t\t\n\t\tprivate static class OS {\n\t\t\tString name;\n\t\t}\n\t}\n\t\n\t//TODO: Pretty sure this is only used for native libraries, which I don't need in minivan\n\t// because native libraries are only needed for runtime I think\n\tprivate static class OperatingSystem {", "\t\tpublic static String getOS() {\n\t\t\tString osName = System.getProperty(\"os.name\").toLowerCase();\n\t\t\t\n\t\t\tif (osName.contains(\"win\")) {\n\t\t\t\treturn \"windows\";\n\t\t\t} else if (osName.contains(\"mac\")) {\n\t\t\t\treturn \"osx\";\n\t\t\t} else {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t}\n\t\t", "\t\tpublic static String getArch() {\n\t\t\tif (is64Bit()) {\n\t\t\t\treturn \"64\";\n\t\t\t} else {\n\t\t\t\treturn \"32\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static boolean is64Bit() {\n\t\t\treturn System.getProperty(\"sun.arch.data.model\").contains(\"64\");\n\t\t}\n\t}\n}", "\t\tpublic static boolean is64Bit() {\n\t\t\treturn System.getProperty(\"sun.arch.data.model\").contains(\"64\");\n\t\t}\n\t}\n}"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/MinivanExt.java", "chunked_list": ["package agency.highlysuspect.minivan;\n\nimport agency.highlysuspect.minivan.prov.MinecraftProvider;\nimport org.gradle.api.Project;\n\npublic class MinivanExt {\n\tpublic MinivanExt(Project project) {\n\t\tthis.project = project;\n\t\t\n\t\tthis.offline = project.getGradle().getStartParameter().isOffline() ||\n\t\t\tproject.hasProperty(\"minivan.offline\") ||\n\t\t\tSystem.getProperty(\"minivan.offline\") != null;\n\t\t\n\t\tthis.refreshDependencies = project.getGradle().getStartParameter().isRefreshDependencies() ||\n\t\t\tproject.hasProperty(\"minivan.refreshDependencies\") ||\n\t\t\tSystem.getProperty(\"minivan.refreshDependencies\") != null;\n\t}\n\t\n\tprivate final Project project;", "\tpublic boolean offline, refreshDependencies;\n\t\n\t/// VanillaGradle-ish API ///\n\t\n\tpublic String version = null;\n\t\n\t@SuppressWarnings(\"unused\")\n\tpublic MinivanExt version(String v) {\n\t\tversion = v;\n\t\treturn this;\n\t}\n\t\n\tvoid setupAfterEvaluate() {\n\t\t//this part is where the magic happens:\n\t\tproject.afterEvaluate(__ -> {", "\t\t\tif(version == null) return;\n\t\t\ttryGetMinecraft(version).installTo(project, \"compileOnly\");\n\t\t});\n\t}\n\t\n\t/// Lower-level, direct API ///\n\t\n\t@SuppressWarnings(\"unused\")\n\tpublic MinecraftProvider.Result getMinecraft(String version) throws Exception {\n\t\treturn new MinecraftProvider(project, version).getMinecraft();\n\t}\n\t\n\tpublic MinecraftProvider.Result tryGetMinecraft(String version) {", "\t\ttry {\n\t\t\treturn getMinecraft(version);\n\t\t} catch (Exception e) {\n\t\t\tproject.getLogger().error(\"problem getting Minecraft \" + version + \": \" + e.getMessage(), e);\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/MinivanPlugin.java", "chunked_list": ["package agency.highlysuspect.minivan;\n\nimport org.gradle.api.Plugin;\nimport org.gradle.api.Project;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;", "import java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\n\npublic class MinivanPlugin implements Plugin<Project> {\n\t@Override\n\tpublic void apply(Project project) {\n\t\tproject.getLogger().info(\"vroom vroom! applying minivan\");\n\t\t\n\t\tproject.getExtensions().create(\"minivan\", MinivanExt.class, project)\n\t\t\t.setupAfterEvaluate();\n\t\t\n\t\t//Free bonus Mavens, vanilla 3rdparty libraries are found here.\n\t\tproject.getRepositories().maven(repo -> {\n\t\t\trepo.setName(\"Mojang\");\n\t\t\trepo.setUrl(\"https://libraries.minecraft.net/\"); //and here\n\t\t});\n\t\tproject.getRepositories().mavenCentral();\n\t}\n\t\n\t//util\n\tprivate static final Pattern NON_FILENAME_SAFE = Pattern.compile(\"[^A-Za-z0-9.-]\");", "\tpublic static String filenameSafe(String in) {\n\t\treturn NON_FILENAME_SAFE.matcher(in).replaceAll(\"_\");\n\t}\n\t\n\tpublic static FileSystem openFs(Path path) throws IOException {\n\t\treturn FileSystems.newFileSystem(URI.create(\"jar:\" + path.toUri()), Collections.emptyMap());\n\t}\n\t\n\tpublic static FileSystem createFs(Path path) throws IOException {\n\t\treturn FileSystems.newFileSystem(URI.create(\"jar:\" + path.toUri()), Collections.singletonMap(\"create\", \"true\"));\n\t}\n}\n", "\tpublic static FileSystem createFs(Path path) throws IOException {\n\t\treturn FileSystems.newFileSystem(URI.create(\"jar:\" + path.toUri()), Collections.singletonMap(\"create\", \"true\"));\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/ManifestIndex.java", "chunked_list": ["package agency.highlysuspect.minivan;\n\nimport com.google.gson.Gson;\nimport com.google.gson.annotations.SerializedName;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;", "import java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@SuppressWarnings(\"CanBeFinal\") //google gson\npublic class ManifestIndex {\n\tpublic static ManifestIndex read(Path path) throws IOException {\n\t\ttry(BufferedReader reader = Files.newBufferedReader(path)) {\n\t\t\tManifestIndex manifestIndex = new Gson().fromJson(reader, ManifestIndex.class);\n\t\t\t\n\t\t\tmanifestIndex.versionList.forEach(v -> manifestIndex.versions.put(v.id, v));\n\t\t\t\n\t\t\treturn manifestIndex;\n\t\t}\n\t}\n\t\n\t@SerializedName(\"versions\") public List<VersionData> versionList = new ArrayList<>();", "\tpublic static ManifestIndex read(Path path) throws IOException {\n\t\ttry(BufferedReader reader = Files.newBufferedReader(path)) {\n\t\t\tManifestIndex manifestIndex = new Gson().fromJson(reader, ManifestIndex.class);\n\t\t\t\n\t\t\tmanifestIndex.versionList.forEach(v -> manifestIndex.versions.put(v.id, v));\n\t\t\t\n\t\t\treturn manifestIndex;\n\t\t}\n\t}\n\t\n\t@SerializedName(\"versions\") public List<VersionData> versionList = new ArrayList<>();", "\tpublic transient Map<String, VersionData> versions = new HashMap<>();\n\t\n\tpublic static class VersionData {\n\t\tpublic String id, url;\n\t}\n}"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/DownloadSession.java", "chunked_list": ["package agency.highlysuspect.minivan;\n\nimport agency.highlysuspect.minivan.MinivanExt;\nimport org.gradle.api.Project;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;", "import java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.time.Instant;\nimport java.time.temporal.TemporalAmount;\nimport java.util.zip.GZIPInputStream;", "import java.time.temporal.TemporalAmount;\nimport java.util.zip.GZIPInputStream;\n\n/**\n * Utilities for downloading files from HTTP servers.\n *\n * (Very largely based off of Loom's old DownloadUtil, but it's more builder-flavored now.\n * Also allows to turn off gzip support because java's gzipinputstream is a bit funky x))\n * \n * == Shamelessly ripped from Voldeloom ==", " * \n * == Shamelessly ripped from Voldeloom ==\n */\npublic class DownloadSession {\n\tpublic DownloadSession(Project project) {\n\t\tthis.project = project;\n\t\tthis.extension = project.getExtensions().getByType(MinivanExt.class);\n\t}\n\t\n\tpublic DownloadSession(String url, Project project) {\n\t\tthis(project);\n\t\turl(url);\n\t}\n\t\n\tprivate final Project project;\n\tprivate final MinivanExt extension;\n\t\n\tprivate URL url;\n\tprivate Path dest;\n\t//If the server sends an ETag, save it in an auxillary file and send it back to the server when rerequesting the file\n\tprivate boolean useEtag = false;\n\t//Send an Accept-Encoding: gzip header and decompress the file on the client\n\tprivate boolean requestGzip = true;\n\t\n\tprivate boolean skipIfExists = false;\n\t//private @Nullable String skipIfSha1 = null;\n\tprivate @Nullable TemporalAmount skipIfNewerThan = null;\n\t\n\tprivate boolean quiet;\n\t", "\tpublic DownloadSession url(String url) {\n\t\ttry {\n\t\t\tthis.url = new URL(url);\n\t\t} catch (MalformedURLException pls) {\n\t\t\tthrow new IllegalArgumentException(\"Skill issue\", pls);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic DownloadSession dest(Path dest) {\n\t\tthis.dest = dest;\n\t\treturn this;\n\t}\n\t", "\tpublic DownloadSession dest(Path dest) {\n\t\tthis.dest = dest;\n\t\treturn this;\n\t}\n\t\n\tpublic DownloadSession etag(boolean etag) {\n\t\tthis.useEtag = etag;\n\t\treturn this;\n\t}\n\t\n\tpublic DownloadSession gzip(boolean gzip) {\n\t\tthis.requestGzip = gzip;\n\t\treturn this;\n\t}\n\t", "\tpublic DownloadSession gzip(boolean gzip) {\n\t\tthis.requestGzip = gzip;\n\t\treturn this;\n\t}\n\t\n\tpublic DownloadSession skipIfExists() {\n\t\tthis.skipIfExists = true;\n\t\treturn this;\n\t}\n\t\n//\tpublic DownloadSession skipIfSha1Equals(@Nullable String skipIfSha1) {\n//\t\tthis.skipIfSha1 = skipIfSha1;\n//\t\treturn this;\n//\t}\n\t", "//\tpublic DownloadSession skipIfSha1Equals(@Nullable String skipIfSha1) {\n//\t\tthis.skipIfSha1 = skipIfSha1;\n//\t\treturn this;\n//\t}\n\t\n\tpublic DownloadSession skipIfNewerThan(@Nullable TemporalAmount skipIfNewerThan) { //e.g. \"Period.ofDays()\"\n\t\tthis.skipIfNewerThan = skipIfNewerThan;\n\t\treturn this;\n\t}\n\t\n\tpublic DownloadSession quiet() {\n\t\tthis.quiet = true;\n\t\treturn this;\n\t}\n\t", "\tpublic DownloadSession quiet() {\n\t\tthis.quiet = true;\n\t\treturn this;\n\t}\n\t\n\tpublic Path download() throws IOException {\n\t\tboolean destExists = Files.exists(dest);\n\t\t\n\t\t//If we're offline, assume the file is up-to-date enough; and if we don't have the file, there's no way to get it.\n\t\tif(extension.offline) {\n\t\t\tif(destExists) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists and we're in offline mode.\", url, dest);\n\t\t\t\treturn dest;\n\t\t\t} else throw new IllegalStateException(\"Need to download \" + url + \" to \" + dest + \", but Gradle was started in offline mode. Aborting.\");\n\t\t}\n\t\t\n\t\t//More fine-grained up-to-dateness checks that we skip in refreshDependencies mode.", "\t\tif(extension.offline) {\n\t\t\tif(destExists) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists and we're in offline mode.\", url, dest);\n\t\t\t\treturn dest;\n\t\t\t} else throw new IllegalStateException(\"Need to download \" + url + \" to \" + dest + \", but Gradle was started in offline mode. Aborting.\");\n\t\t}\n\t\t\n\t\t//More fine-grained up-to-dateness checks that we skip in refreshDependencies mode.\n\t\tif(destExists && !extension.refreshDependencies) {\n\t\t\tif(skipIfExists) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists.\", url, dest);\n\t\t\t\treturn dest;\n\t\t\t}", "\t\tif(destExists && !extension.refreshDependencies) {\n\t\t\tif(skipIfExists) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists.\", url, dest);\n\t\t\t\treturn dest;\n\t\t\t}\n//\t\t\tif(skipIfSha1 != null && Checksum.compareFileHexHash(dest, skipIfSha1, Checksum.SHA1.get())) {\n//\t\t\t\tinfo(\"Not connecting to {} because {} exists and has correct SHA-1 hash ({}).\", url, dest, skipIfSha1);\n//\t\t\t\treturn dest;\n//\t\t\t}\n\t\t\tif(skipIfNewerThan != null && Files.getLastModifiedTime(dest).toInstant().isAfter(Instant.now().minus(skipIfNewerThan))) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists and was downloaded within {}.\", url, dest, skipIfNewerThan);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection(); //doesnt actually open html connection yet\n\t\t\n\t\t//Read the locally known etag, if one exists, and set the etag header.\n\t\tString knownEtag = null;\n\t\tPath etagFile = dest.resolveSibling(dest.getFileName().toString() + \".etag\");", "\t\t\tif(skipIfNewerThan != null && Files.getLastModifiedTime(dest).toInstant().isAfter(Instant.now().minus(skipIfNewerThan))) {\n\t\t\t\tinfo(\"Not connecting to {} because {} exists and was downloaded within {}.\", url, dest, skipIfNewerThan);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection(); //doesnt actually open html connection yet\n\t\t\n\t\t//Read the locally known etag, if one exists, and set the etag header.\n\t\tString knownEtag = null;\n\t\tPath etagFile = dest.resolveSibling(dest.getFileName().toString() + \".etag\");", "\t\tif(useEtag && destExists && Files.exists(etagFile) && !extension.refreshDependencies) {\n\t\t\tknownEtag = new String(Files.readAllBytes(etagFile), StandardCharsets.UTF_8);\n\t\t\tconn.setRequestProperty(\"If-None-Match\", knownEtag);\n\t\t\tconn.setIfModifiedSince(Files.getLastModifiedTime(dest).toMillis());\n\t\t}\n\t\t\n\t\t//Request a gzip header, if compression was requested.\n\t\tif(requestGzip) conn.setRequestProperty(\"Accept-Encoding\", \"gzip\");\n\t\t\n\t\t//Actually connect.\n\t\tlifecycle(\"Establishing connection to {} (sending etag header: {}, gzip encoding: {})...\", url, knownEtag != null, requestGzip);\n\t\tconn.connect();\n\t\t\n\t\t//We'll take a 304, or something in the OK section.\n\t\tint code = conn.getResponseCode();", "\t\tif(code == HttpURLConnection.HTTP_NOT_MODIFIED) {\n\t\t\tlifecycle(\"\\\\-> Not Modified (etag match)\"); //The server *shouldn't* send a 304 if we didn't send an etag?\n\t\t\treturn dest;\n\t\t} else if(code / 100 != 2) {\n\t\t\tthrow new IOException(\"Got \" + code + \" \" + conn.getResponseMessage() + \" from connection to \" + url);\n\t\t}\n\t\t\n\t\t//Download the entire file and save it to disk.\n\t\tlifecycle(\"\\\\-> Saving to {} \", dest);\n\t\tFiles.createDirectories(dest.getParent());\n\t\ttry(InputStream in = \"gzip\".equals(conn.getContentEncoding()) ? new GZIPInputStream(conn.getInputStream()) : conn.getInputStream()) {\n\t\t\tFiles.copy(in, dest, StandardCopyOption.REPLACE_EXISTING);\n\t\t} catch (IOException e) {\n\t\t\t//don't keep a half-downloaded file, if we can", "\t\t\ttry { Files.deleteIfExists(dest); } catch (Exception ignored) {}\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\t//Save the etag to disk too, if one was sent alongside the file.\n\t\tString srvEtag = conn.getHeaderField(\"ETag\");\n\t\tif(useEtag && srvEtag != null) {\n\t\t\tinfo(\"\\\\-> Saving etag to {} \", etagFile);\n\t\t\tFiles.write(etagFile, srvEtag.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\t\t\n\t\treturn dest;\n\t}\n\t\n\tprivate void info(String x, Object... fmt) {", "\t\tif(!quiet) project.getLogger().info(x, fmt);\n\t}\n\t\n\tprivate void lifecycle(String x, Object... fmt) {\n\t\tif(!quiet) project.getLogger().lifecycle(x, fmt);\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/side/SideOnly.java", "chunked_list": ["package agency.highlysuspect.minivan.side;\n\npublic @interface SideOnly {\n\tSide value();\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/side/Side.java", "chunked_list": ["package agency.highlysuspect.minivan.side;\n\npublic enum Side {\n\tCLIENT, SERVER\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/prov/MiniProvider.java", "chunked_list": ["package agency.highlysuspect.minivan.prov;\n\nimport agency.highlysuspect.minivan.MinivanExt;\nimport org.gradle.api.Project;\nimport org.gradle.api.logging.Logger;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class MiniProvider {\n\tpublic MiniProvider(Project project) {\n\t\tthis.project = project;\n\t\tthis.ext = project.getExtensions().getByType(MinivanExt.class);\n\t\tthis.log = project.getLogger();\n\t}\n\t\n\tprotected final Project project;\n\tprotected final MinivanExt ext;\n\tprotected final Logger log;\n\t\n\tprotected Path cacheDir() throws IOException {\n\t\tPath cacheDir = project.getGradle().getGradleUserHomeDir().toPath().resolve(\"caches\").resolve(\"minivan-cache\");\n\t\tFiles.createDirectories(cacheDir);\n\t\treturn cacheDir;\n\t}\n\t\n\tprotected Path getOrCreate(Path p, ThrowyConsumer<Path> creator) throws Exception {", "import java.nio.file.Path;\n\npublic class MiniProvider {\n\tpublic MiniProvider(Project project) {\n\t\tthis.project = project;\n\t\tthis.ext = project.getExtensions().getByType(MinivanExt.class);\n\t\tthis.log = project.getLogger();\n\t}\n\t\n\tprotected final Project project;\n\tprotected final MinivanExt ext;\n\tprotected final Logger log;\n\t\n\tprotected Path cacheDir() throws IOException {\n\t\tPath cacheDir = project.getGradle().getGradleUserHomeDir().toPath().resolve(\"caches\").resolve(\"minivan-cache\");\n\t\tFiles.createDirectories(cacheDir);\n\t\treturn cacheDir;\n\t}\n\t\n\tprotected Path getOrCreate(Path p, ThrowyConsumer<Path> creator) throws Exception {", "\t\tif(ext.refreshDependencies) Files.deleteIfExists(p);\n\t\tif(Files.notExists(p)) {\n\t\t\tcreator.accept(p);\n\t\t\t\n\t\t\t//double-check that the file really does exist now\n\t\t\tif(Files.notExists(p)) throw new IllegalStateException(\"File at \" + p + \" wasn't created by \" + creator);\n\t\t}\n\t\treturn p;\n\t}\n\t\n\tprotected Path getOrCreate(String p, ThrowyConsumer<Path> creator) throws Exception {\n\t\treturn getOrCreate(cacheDir().resolve(p), creator);\n\t}\n\t\n\tprotected interface ThrowyConsumer<T> {\n\t\tvoid accept(T t) throws Exception;\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/prov/RemapperPrg.java", "chunked_list": ["package agency.highlysuspect.minivan.prov;\n\nimport net.fabricmc.tinyremapper.IMappingProvider;\nimport net.fabricmc.tinyremapper.OutputConsumerPath;\nimport net.fabricmc.tinyremapper.TinyRemapper;\nimport org.cadixdev.lorenz.MappingSet;\nimport org.cadixdev.lorenz.io.proguard.ProGuardFormat;\nimport org.cadixdev.lorenz.model.ClassMapping;\nimport org.cadixdev.lorenz.model.FieldMapping;\nimport org.cadixdev.lorenz.model.MethodMapping;", "import org.cadixdev.lorenz.model.FieldMapping;\nimport org.cadixdev.lorenz.model.MethodMapping;\nimport org.gradle.api.Project;\n\nimport java.nio.file.Path;\n\npublic class RemapperPrg extends MiniProvider {\n\tpublic RemapperPrg(Project project, Path inJar, Path mapFile, String outJarName) {\n\t\tsuper(project);\n\t\tthis.inJar = inJar;\n\t\tthis.mapFile = mapFile;\n\t\tthis.outJarName = outJarName;\n\t}\n\t", "\tpublic final Path inJar;\n\tpublic final Path mapFile;\n\tpublic final String outJarName;\n\t\n\tpublic Path remap() throws Exception {\n\t\tPath result = getOrCreate(outJarName, outJar -> {\n\t\t\tlog.lifecycle(\"Remapping {} to {} using {}\", inJar, outJar, mapFile);\n\t\t\t\n\t\t\t//lorenz\n\t\t\tMappingSet prg = new ProGuardFormat().createReader(mapFile).read().reverse();\n\t\t\t\n\t\t\t//tiny-remapper\n\t\t\tTinyRemapper remapper = TinyRemapper.newRemapper()\n\t\t\t\t.renameInvalidLocals(true)\n\t\t\t\t.rebuildSourceFilenames(true)\n\t\t\t\t.withMappings(acceptor -> prg.getTopLevelClassMappings().forEach(tlcm -> visitClass(acceptor, tlcm))) \n\t\t\t\t.build();\n\t\t\t\n\t\t\ttry(OutputConsumerPath oc = new OutputConsumerPath.Builder(outJar).assumeArchive(true).build()) {\n\t\t\t\toc.addNonClassFiles(inJar);\n\t\t\t\tremapper.readInputs(inJar);\n\t\t\t\tremapper.apply(oc);\n\t\t\t} finally {\n\t\t\t\tremapper.finish();\n\t\t\t}\n\t\t});\n\t\tlog.info(\"mapped: {}\", result);\n\t\treturn result;\n\t}\n\t\n\t//glue code between lorenz and tiny-remapper\n\tprivate void visitClass(IMappingProvider.MappingAcceptor acceptor, ClassMapping<?, ?> classMapping) {\n\t\tacceptor.acceptClass(classMapping.getFullObfuscatedName(), classMapping.getFullDeobfuscatedName());\n\t\t", "\t\tfor(FieldMapping fm : classMapping.getFieldMappings()) {\n\t\t\tacceptor.acceptField(new IMappingProvider.Member(\n\t\t\t\tclassMapping.getFullObfuscatedName(),\n\t\t\t\tfm.getObfuscatedName(),\n\t\t\t\tfm.getType().map(Object::toString).orElse(\"Ljava/lang/Void;\")\n\t\t\t), fm.getDeobfuscatedName());\n\t\t}\n\t\t\n\t\tfor(MethodMapping mm : classMapping.getMethodMappings()) {\n\t\t\tacceptor.acceptMethod(new IMappingProvider.Member(\n\t\t\t\tclassMapping.getFullObfuscatedName(),\n\t\t\t\tmm.getObfuscatedName(),\n\t\t\t\tmm.getObfuscatedDescriptor()\n\t\t\t), mm.getDeobfuscatedName());\n\t\t}\n\t\t\n\t\t//recurse into inner classes", "\t\tfor(MethodMapping mm : classMapping.getMethodMappings()) {\n\t\t\tacceptor.acceptMethod(new IMappingProvider.Member(\n\t\t\t\tclassMapping.getFullObfuscatedName(),\n\t\t\t\tmm.getObfuscatedName(),\n\t\t\t\tmm.getObfuscatedDescriptor()\n\t\t\t), mm.getDeobfuscatedName());\n\t\t}\n\t\t\n\t\t//recurse into inner classes\n\t\tfor(ClassMapping<?, ?> cm : classMapping.getInnerClassMappings()) {\n\t\t\tvisitClass(acceptor, cm);\n\t\t}\n\t}\n}\n", "\t\tfor(ClassMapping<?, ?> cm : classMapping.getInnerClassMappings()) {\n\t\t\tvisitClass(acceptor, cm);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/prov/VanillaJarFetcher.java", "chunked_list": ["package agency.highlysuspect.minivan.prov;\n\nimport agency.highlysuspect.minivan.DownloadSession;\nimport agency.highlysuspect.minivan.ManifestIndex;\nimport agency.highlysuspect.minivan.MinivanPlugin;\nimport agency.highlysuspect.minivan.VersionManifest;\nimport org.gradle.api.Project;\n\nimport java.nio.file.Path;\nimport java.time.Period;", "import java.nio.file.Path;\nimport java.time.Period;\n\npublic class VanillaJarFetcher extends MiniProvider {\n\tpublic VanillaJarFetcher(Project project, String version) {\n\t\tsuper(project);\n\t\tthis.version = version;\n\t\tthis.versionFilenameSafe = MinivanPlugin.filenameSafe(version);\n\t}\n\t\n\tprivate final String version, versionFilenameSafe;", "\tpublic static final String PISTON_META = \"https://piston-meta.mojang.com/mc/game/version_manifest_v2.json\";\n\t\n\tpublic Result fetch() throws Exception {\n\t\t//TODO same problem as voldeloom, the skipIfNewerThan happens only if the file doesn't exist so it's redundant\n\t\tPath versionManifestIndexJson = getOrCreate(\"version_manifest_v2.json\", to -> {\n\t\t\tlog.lifecycle(\"Downloading version_manifest.json to {}\", to);\n\t\t\tnew DownloadSession(project).url(PISTON_META).dest(to).etag(true).gzip(true).skipIfNewerThan(Period.ofDays(14)).download();\n\t\t});\n\t\tlog.info(\"version_manifest.json: {}\", versionManifestIndexJson);\n\t\t\n\t\tManifestIndex versionManifestIndex = ManifestIndex.read(versionManifestIndexJson);\n\t\tManifestIndex.VersionData selectedVersion = versionManifestIndex.versions.get(version);\n\t\t", "\t\tif(selectedVersion == null) {\n\t\t\tthrow new IllegalArgumentException(\"Could not find Minecraft version \" + version + \" in \" + versionManifestIndexJson);\n\t\t}\n\t\t\n\t\tPath thisVersionManifestJson = getOrCreate(\"minecraft-\" + versionFilenameSafe + \"-info.json\", to -> {\n\t\t\tlog.lifecycle(\"Downloading {} manifest to {}\", version, to);\n\t\t\tnew DownloadSession(project).url(selectedVersion.url).dest(to).etag(true).gzip(true).download();\n\t\t});\n\t\tlog.info(\"{} manifest: {}\", version, thisVersionManifestJson);\n\t\t\n\t\tVersionManifest vm = VersionManifest.read(thisVersionManifestJson);\n\t\t\n\t\t//Try to fetch mappings first, just to crash early if there are no official mappings available\n\t\tPath clientMap = getOrCreate(\"minecraft-\" + versionFilenameSafe + \"-client-mappings.txt\", to -> {\n\t\t\tlog.lifecycle(\"Downloading client mappings to {}\", to);\n\t\t\tnew DownloadSession(project).url(vm.getUrl(\"client_mappings\")).dest(to).etag(true).gzip(true).download();\n\t\t});\n\t\tPath serverMap = getOrCreate(\"minecraft-\" + versionFilenameSafe + \"-server-mappings.txt\", to -> {\n\t\t\tlog.lifecycle(\"Downloading server mappings to {}\", to);\n\t\t\tnew DownloadSession(project).url(vm.getUrl(\"server_mappings\")).dest(to).etag(true).gzip(true).download();\n\t\t});\n\t\t\n\t\t//We don't gzip minecraft jars in-flight, i've had bizarre issues with it in the past. Sorry\n\t\tPath clientJar = getOrCreate(\"minecraft-\" + versionFilenameSafe + \"-client.jar\", to -> {\n\t\t\tlog.lifecycle(\"Downloading client jar to {}\", to);\n\t\t\tnew DownloadSession(project).url(vm.getUrl(\"client\")).dest(to).etag(true).gzip(false).download();\n\t\t});\n\t\tPath serverJar = getOrCreate(\"minecraft-\" + versionFilenameSafe + \"-server.jar\", to -> {\n\t\t\tlog.lifecycle(\"Downloading server jar to {}\", to);\n\t\t\tnew DownloadSession(project).url(vm.getUrl(\"server\")).dest(to).etag(true).gzip(false).download();\n\t\t});\n\t\t\n\t\tlog.info(\"client: {}\", clientJar);\n\t\tlog.info(\"server: {}\", serverJar);\n\t\t\n\t\treturn new Result(clientJar, serverJar, clientMap, serverMap, vm);\n\t}\n\t", "\tpublic static class Result {\n\t\tpublic Result(Path client, Path server, Path clientMappings, Path serverMappings, VersionManifest versionManifest) {\n\t\t\tthis.client = client;\n\t\t\tthis.server = server;\n\t\t\tthis.clientMappings = clientMappings;\n\t\t\tthis.serverMappings = serverMappings;\n\t\t\tthis.versionManifest = versionManifest;\n\t\t}\n\t\t\n\t\tpublic final Path client, server;\n\t\tpublic final Path clientMappings, serverMappings;", "\t\tpublic final Path client, server;\n\t\tpublic final Path clientMappings, serverMappings;\n\t\tpublic final VersionManifest versionManifest;\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/prov/MinecraftProvider.java", "chunked_list": ["package agency.highlysuspect.minivan.prov;\n\nimport agency.highlysuspect.minivan.MinivanPlugin;\nimport agency.highlysuspect.minivan.VersionManifest;\nimport org.gradle.api.Project;\n\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MinecraftProvider extends MiniProvider {\n\tpublic MinecraftProvider(Project project, String version) {\n\t\tsuper(project);\n\t\tthis.version = version;\n\t}\n\t", "import java.util.List;\n\npublic class MinecraftProvider extends MiniProvider {\n\tpublic MinecraftProvider(Project project, String version) {\n\t\tsuper(project);\n\t\tthis.version = version;\n\t}\n\t\n\tpublic final String version;\n\t\n\tpublic Result getMinecraft() throws Exception {\n\t\tlog.info(\"getting minecraft {}\", version);\n\t\t\n\t\t//Fetch vanilla jars, official mappings, version manifest\n\t\tVanillaJarFetcher.Result vanillaJars = new VanillaJarFetcher(project, version).fetch();\n\t\t\n\t\t//Look for third-party libraries\n\t\tList<String> libs = new ArrayList<>();", "\tpublic final String version;\n\t\n\tpublic Result getMinecraft() throws Exception {\n\t\tlog.info(\"getting minecraft {}\", version);\n\t\t\n\t\t//Fetch vanilla jars, official mappings, version manifest\n\t\tVanillaJarFetcher.Result vanillaJars = new VanillaJarFetcher(project, version).fetch();\n\t\t\n\t\t//Look for third-party libraries\n\t\tList<String> libs = new ArrayList<>();\n\t\tfor(VersionManifest.Library lib : vanillaJars.versionManifest.libraries) {", "\t\tfor(VersionManifest.Library lib : vanillaJars.versionManifest.libraries) {\n\t\t\tif(lib.isNative() || !lib.allowed()) continue;\n\t\t\t\n\t\t\tif(lib.name.contains(\"mojang:logging\")) {\n\t\t\t\tcontinue; //TODO, this one is broken on my machine for some reason\n\t\t\t}\n\t\t\t\n\t\t\tlibs.add(lib.getArtifactName());\n\t\t\t\n\t\t\tlog.info(\"found vanilla dependency: {}\", lib.getArtifactName());\n\t\t}\n\t\t\n\t\t//Remap client and server using official names\n\t\tString minecraftPrefix = \"minecraft-\" + MinivanPlugin.filenameSafe(version);\n\t\tPath clientMapped = new RemapperPrg(project, vanillaJars.client, vanillaJars.clientMappings, minecraftPrefix + \"-client-mapped.jar\").remap();\n\t\tPath serverMapped = new RemapperPrg(project, vanillaJars.server, vanillaJars.serverMappings, minecraftPrefix + \"-server-mapped.jar\").remap();\n\t\t\n\t\t//Merge client and server\n\t\tPath merged = new Merger(project, clientMapped, serverMapped, minecraftPrefix + \"-merged.jar\").merge();\n\t\t\n\t\treturn new Result(vanillaJars, merged, libs);\n\t}\n\t", "\tpublic static class Result {\n\t\tpublic Result(VanillaJarFetcher.Result vanilla, Path minecraft, List<String> dependencies) {\n\t\t\tthis.vanilla = vanilla;\n\t\t\tthis.minecraft = minecraft;\n\t\t\tthis.dependencies = dependencies;\n\t\t}\n\t\t\n\t\tpublic final VanillaJarFetcher.Result vanilla;\n\t\tpublic final Path minecraft;\n\t\tpublic final List<String> dependencies;\n\t\t", "\t\tpublic final Path minecraft;\n\t\tpublic final List<String> dependencies;\n\t\t\n\t\tpublic void installTo(Project project, String configurationName) {\n\t\t\tinstallMinecraftTo(project, configurationName);\n\t\t\tinstallDependenciesTo(project, configurationName);\n\t\t}\n\t\t\n\t\tpublic void installMinecraftTo(Project project, String configurationName) {\n\t\t\tproject.getLogger().info(\"adding {} to configuration '{}'\", minecraft, configurationName);\n\t\t\tproject.getDependencies().add(configurationName, project.files(minecraft));\n\t\t}\n\t\t", "\t\tpublic void installMinecraftTo(Project project, String configurationName) {\n\t\t\tproject.getLogger().info(\"adding {} to configuration '{}'\", minecraft, configurationName);\n\t\t\tproject.getDependencies().add(configurationName, project.files(minecraft));\n\t\t}\n\t\t\n\t\tpublic void installDependenciesTo(Project project, String configurationName) {\n\t\t\tdependencies.forEach(dep -> {\n\t\t\t\tproject.getLogger().info(\"adding {} to configuration '{}'\", dep, configurationName);\n\t\t\t\tproject.getDependencies().add(configurationName, dep);\n\t\t\t});\n\t\t}\n\t\t\n\t\t@Override", "\t\tpublic String toString() {\n\t\t\treturn String.format(\"MinecraftProvider.Result{minecraft=%s, dependencies=[\\\"%s\\\"]}\", minecraft, String.join(\"\\\",\\\"\", dependencies));\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/prov/Merger.java", "chunked_list": ["package agency.highlysuspect.minivan.prov;\n\nimport agency.highlysuspect.minivan.MinivanPlugin;\nimport agency.highlysuspect.minivan.stitch.ClassMergerCooler;\nimport agency.highlysuspect.minivan.stitch.JarMergerCooler;\nimport org.gradle.api.Project;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;", "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class Merger extends MiniProvider {\n\tpublic Merger(Project project, Path client, Path server, String mergedName) {\n\t\tsuper(project);\n\t\tthis.client = client;\n\t\tthis.server = server;\n\t\tthis.mergedName = mergedName;\n\t}\n\t", "\tpublic final Path client, server;\n\tpublic final String mergedName;\n\t\n\tpublic Path merge() throws Exception {\n\t\tPath p = getOrCreate(mergedName, merged -> {\n\t\t\tlog.lifecycle(\"Merging {} and {} to {}\", client, server, merged);\n\t\t\t\n\t\t\ttry(\n\t\t\t\tFileSystem clientFs = MinivanPlugin.openFs(client);\n\t\t\t\tFileSystem serverFs = MinivanPlugin.openFs(server);\n\t\t\t\tFileSystem mergedFs = MinivanPlugin.createFs(merged);\n\t\t\t\tInputStream bonus1 = Merger.class.getResourceAsStream(\"/agency/highlysuspect/minivan/side/Side.class\");\n\t\t\t\tInputStream bonus2 = Merger.class.getResourceAsStream(\"/agency/highlysuspect/minivan/side/SideOnly.class\")\n\t\t\t) {\n\t\t\t\tJarMergerCooler merger = new JarMergerCooler(clientFs, serverFs, mergedFs);\n\t\t\t\tmerger.merge(new ClassMergerCooler()\n\t\t\t\t\t.sideEnum(\"Lagency/highlysuspect/minivan/side/Side;\")\n\t\t\t\t\t.sideDescriptorAnnotation(\"Lagency/highlysuspect/minivan/side/SideOnly;\")\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t//Free bonus classes:\n\t\t\t\tFiles.createDirectories(mergedFs.getPath(\"agency/highlysuspect/minivan/side\"));\n\t\t\t\tblah(bonus1, mergedFs.getPath(\"/agency/highlysuspect/minivan/side/Side.class\"));\n\t\t\t\tblah(bonus2, mergedFs.getPath(\"/agency/highlysuspect/minivan/side/SideOnly.class\"));\n\t\t\t}\n\t\t});\n\t\tlog.info(\"merged: {}\", p);\n\t\treturn p;\n\t}\n\t\n\tprivate static void blah(InputStream in, Path outPath) throws IOException {\n\t\ttry(OutputStream out = new BufferedOutputStream(Files.newOutputStream(outPath))) {\n\t\t\tbyte[] buf = new byte[4096];\n\t\t\tint read;", "\t\t\twhile((read = in.read(buf)) > 0) out.write(buf, 0, read);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/stitch/JarMergerCooler.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage agency.highlysuspect.minivan.stitch;\n", "package agency.highlysuspect.minivan.stitch;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;", "import java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Arrays;", "import java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;", "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/**\n * This is a modified copy of Stitch's JarMerger.\n *\n * Mainly I modified it to allow changing the annotatation types JarMerger adds to the jars, but also\n * to simplify it a bit and use regular FileSystems instead of the stitch FileSystemDelegate weird thing", " * Mainly I modified it to allow changing the annotatation types JarMerger adds to the jars, but also\n * to simplify it a bit and use regular FileSystems instead of the stitch FileSystemDelegate weird thing\n * because Tbh i have never ran into that issue in practice (close your darned file systems please)\n */\npublic class JarMergerCooler implements AutoCloseable {\n\tpublic JarMergerCooler(FileSystem inputClientFs, FileSystem inputServerFs, FileSystem outputFs) {\n\t\tthis.inputClientFs = inputClientFs;\n\t\tthis.inputServerFs = inputServerFs;\n\t\tthis.outputFs = outputFs;\n\t\t\n\t\tthis.entriesClient = new HashMap<>();\n\t\tthis.entriesServer = new HashMap<>();\n\t\tthis.entriesAll = new TreeSet<>();\n\t}\n\t\n\tprivate final FileSystem inputClientFs, inputServerFs, outputFs;\n\tprivate final Map<String, Entry> entriesClient, entriesServer;\n\tprivate final Set<String> entriesAll;\n//\tprivate boolean removeSnowmen = false;\n//\tprivate boolean offsetSyntheticsParams = false;\n\t", "\tpublic static class Entry {\n\t\tpublic final Path path;\n\t\tpublic final BasicFileAttributes metadata;\n\t\tpublic final byte[] data;\n\t\t\n\t\tpublic Entry(Path path, BasicFileAttributes metadata, byte[] data) {\n\t\t\tthis.path = path;\n\t\t\tthis.metadata = metadata;\n\t\t\tthis.data = data;\n\t\t}\n\t}\n", "//\tpublic void enableSnowmanRemoval() {\n//\t\tremoveSnowmen = true;\n//\t}\n//\t\n//\tpublic void enableSyntheticParamsOffset() {\n//\t\toffsetSyntheticsParams = true;\n//\t}\n\t\n\t@Override\n\tpublic void close() throws IOException {\n\t\tinputClientFs.close();\n\t\tinputServerFs.close();\n\t\toutputFs.close();\n\t}\n\t\n\tprivate void readToMap(Map<String, Entry> map, FileSystem input) {", "\tpublic void close() throws IOException {\n\t\tinputClientFs.close();\n\t\tinputServerFs.close();\n\t\toutputFs.close();\n\t}\n\t\n\tprivate void readToMap(Map<String, Entry> map, FileSystem input) {\n\t\ttry {\n\t\t\tFiles.walkFileTree(input.getPath(\"/\"), new SimpleFileVisitor<Path>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(Path path, BasicFileAttributes attr) throws IOException {", "\t\t\t\tpublic FileVisitResult visitFile(Path path, BasicFileAttributes attr) throws IOException {\n\t\t\t\t\tif (attr.isDirectory()) {\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!path.getFileName().toString().endsWith(\".class\")) {\n\t\t\t\t\t\tif (path.toString().equals(\"/META-INF/MANIFEST.MF\")) {\n\t\t\t\t\t\t\tmap.put(\"META-INF/MANIFEST.MF\", new Entry(path, attr,\n\t\t\t\t\t\t\t\t\"Manifest-Version: 1.0\\nMain-Class: net.minecraft.client.Main\\n\".getBytes(StandardCharsets.UTF_8)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (path.toString().startsWith(\"/META-INF/\")) {", "\t\t\t\t\t\t\tif (path.toString().startsWith(\"/META-INF/\")) {\n\t\t\t\t\t\t\t\tif (path.toString().endsWith(\".SF\") || path.toString().endsWith(\".RSA\")) {\n\t\t\t\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmap.put(path.toString().substring(1), new Entry(path, attr, null));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbyte[] output = Files.readAllBytes(path);\n\t\t\t\t\tmap.put(path.toString().substring(1), new Entry(path, attr, output));\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tprivate void add(Entry entry) throws IOException {\n\t\tPath outPath = outputFs.getPath(entry.path.toString());", "\t\tif (outPath.getParent() != null) {\n\t\t\tFiles.createDirectories(outPath.getParent());\n\t\t}\n\t\t\n\t\tif (entry.data != null) {\n\t\t\tFiles.write(outPath, entry.data, StandardOpenOption.CREATE_NEW);\n\t\t} else {\n\t\t\tFiles.copy(entry.path, outPath);\n\t\t}\n\t\t\n\t\tFiles.getFileAttributeView(outPath, BasicFileAttributeView.class)\n\t\t\t.setTimes(\n\t\t\t\tentry.metadata.creationTime(),\n\t\t\t\tentry.metadata.lastAccessTime(),\n\t\t\t\tentry.metadata.lastModifiedTime()\n\t\t\t);\n\t}\n\t", "\tpublic void merge(ClassMergerCooler classMergerCooler) throws IOException {\n\t\tExecutorService service = Executors.newFixedThreadPool(2);\n\t\tservice.submit(() -> readToMap(entriesClient, inputClientFs));\n\t\tservice.submit(() -> readToMap(entriesServer, inputServerFs));\n\t\tservice.shutdown();\n\t\ttry {\n\t\t\tboolean worked = service.awaitTermination(1, TimeUnit.HOURS);\n\t\t\tif(!worked) throw new RuntimeException(\"Merger did not complete in 1 hour\");\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tentriesAll.addAll(entriesClient.keySet());\n\t\tentriesAll.addAll(entriesServer.keySet());\n\t\t\n\t\tList<Entry> entries = entriesAll.parallelStream().map((entry) -> {\n\t\t\tboolean isClass = entry.endsWith(\".class\");\n\t\t\tboolean isMinecraft = entriesClient.containsKey(entry) || entry.startsWith(\"net/minecraft\") || !entry.contains(\"/\");\n\t\t\tEntry result;\n\t\t\tString side = null;\n\t\t\t\n\t\t\tEntry entry1 = entriesClient.get(entry);\n\t\t\tEntry entry2 = entriesServer.get(entry);\n\t\t\t", "\t\t\tif (entry1 != null && entry2 != null) {\n\t\t\t\tif (Arrays.equals(entry1.data, entry2.data)) {\n\t\t\t\t\tresult = entry1;\n\t\t\t\t} else {\n\t\t\t\t\tif (isClass) {\n\t\t\t\t\t\tresult = new Entry(entry1.path, entry1.metadata, classMergerCooler.merge(entry1.data, entry2.data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// FIXME: More heuristics?\n\t\t\t\t\t\tresult = entry1;\n\t\t\t\t\t}\n\t\t\t\t}", "\t\t\t} else if ((result = entry1) != null) {\n\t\t\t\tside = \"CLIENT\";\n\t\t\t} else if ((result = entry2) != null) {\n\t\t\t\tside = \"SERVER\";\n\t\t\t}\n\t\t\t\n\t\t\tif (isClass && !isMinecraft && \"SERVER\".equals(side)) {\n\t\t\t\t// Server bundles libraries, client doesn't - skip them\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t", "\t\t\tif (result != null) {\n\t\t\t\tif (isMinecraft && isClass) {\n\t\t\t\t\tbyte[] data = result.data;\n\t\t\t\t\tClassReader reader = new ClassReader(data);\n\t\t\t\t\tClassWriter writer = new ClassWriter(0);\n\t\t\t\t\tClassVisitor visitor = writer;\n\t\t\t\t\t\n\t\t\t\t\tif (side != null) {\n\t\t\t\t\t\tvisitor = classMergerCooler.new SidedClassVisitor(Opcodes.ASM9, visitor, side);\n\t\t\t\t\t}\n", "//\t\t\t\t\tif (removeSnowmen) {\n//\t\t\t\t\t\tvisitor = new SnowmanClassVisitor(StitchUtil.ASM_VERSION, visitor);\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t\tif (offsetSyntheticsParams) {\n//\t\t\t\t\t\tvisitor = new SyntheticParameterClassVisitor(StitchUtil.ASM_VERSION, visitor);\n//\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (visitor != writer) {\n\t\t\t\t\t\treader.accept(visitor, 0);\n\t\t\t\t\t\tdata = writer.toByteArray();\n\t\t\t\t\t\tresult = new Entry(result.path, result.metadata, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}).filter(Objects::nonNull).collect(Collectors.toList());\n\t\t", "\t\t\t\t\tif (visitor != writer) {\n\t\t\t\t\t\treader.accept(visitor, 0);\n\t\t\t\t\t\tdata = writer.toByteArray();\n\t\t\t\t\t\tresult = new Entry(result.path, result.metadata, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}).filter(Objects::nonNull).collect(Collectors.toList());\n\t\t", "\t\tfor (Entry e : entries) {\n\t\t\tadd(e);\n\t\t}\n\t}\n}\n"]}
{"filename": "src/main/java/agency/highlysuspect/minivan/stitch/ClassMergerCooler.java", "chunked_list": ["/*\n * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage agency.highlysuspect.minivan.stitch;\n", "package agency.highlysuspect.minivan.stitch;\n\nimport org.objectweb.asm.AnnotationVisitor;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldNode;", "import org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldNode;\nimport org.objectweb.asm.tree.InnerClassNode;\nimport org.objectweb.asm.tree.MethodNode;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;", "import java.util.Locale;\nimport java.util.Map;\n\n/**\n * This is a modified copy of Stitch's ClassMerger.\n *\n * Mainly I modified it to allow changing the annotatation types JarMerger adds to the jars, and to avoid adding\n * duplicate copies of those annotations when one already exists (Forge binpatches add annotations sometimes)\n */\npublic class ClassMergerCooler {\n\tprivate String sideEnum = \"Lnet/fabricmc/api/EnvType;\";\n\tprivate String sidedInterfaceAnnotation = \"Lnet/fabricmc/api/EnvironmentInterface;\";\n\tprivate String sidedInterfaceListAnnotation = \"Lnet/fabricmc/api/EnvironmentInterfaces;\";\n\tprivate String sideDescriptorAnnotation = \"Lnet/fabricmc/api/Environment;\";\n\t", " */\npublic class ClassMergerCooler {\n\tprivate String sideEnum = \"Lnet/fabricmc/api/EnvType;\";\n\tprivate String sidedInterfaceAnnotation = \"Lnet/fabricmc/api/EnvironmentInterface;\";\n\tprivate String sidedInterfaceListAnnotation = \"Lnet/fabricmc/api/EnvironmentInterfaces;\";\n\tprivate String sideDescriptorAnnotation = \"Lnet/fabricmc/api/Environment;\";\n\t\n\tpublic ClassMergerCooler sideEnum(String sideEnum) {\n\t\tthis.sideEnum = sideEnum;\n\t\treturn this;\n\t}\n\t", "\tpublic ClassMergerCooler sidedInterfaceAnnotation(String sidedInterfaceAnnotation) {\n\t\tthis.sidedInterfaceAnnotation = sidedInterfaceAnnotation;\n\t\treturn this;\n\t}\n\t\n\tpublic ClassMergerCooler sidedInterfaceListAnnotation(String sidedInterfaceListAnnotation) {\n\t\tthis.sidedInterfaceListAnnotation = sidedInterfaceListAnnotation;\n\t\treturn this;\n\t}\n\t\n\tpublic ClassMergerCooler sideDescriptorAnnotation(String sideDescriptorAnnotation) {\n\t\tthis.sideDescriptorAnnotation = sideDescriptorAnnotation;\n\t\treturn this;\n\t}\n\t\n\tprivate abstract static class Merger<T> {\n\t\tprivate final Map<String, T> entriesClient, entriesServer;\n\t\tprivate final List<String> entryNames;\n\t\t\n\t\tpublic Merger(List<T> entriesClient, List<T> entriesServer) {\n\t\t\tthis.entriesClient = new LinkedHashMap<>();\n\t\t\tthis.entriesServer = new LinkedHashMap<>();\n\t\t\t\n\t\t\tList<String> listClient = toMap(entriesClient, this.entriesClient);\n\t\t\tList<String> listServer = toMap(entriesServer, this.entriesServer);\n\t\t\t\n\t\t\tthis.entryNames = mergePreserveOrder(listClient, listServer);\n\t\t}\n\t\t", "\tpublic ClassMergerCooler sideDescriptorAnnotation(String sideDescriptorAnnotation) {\n\t\tthis.sideDescriptorAnnotation = sideDescriptorAnnotation;\n\t\treturn this;\n\t}\n\t\n\tprivate abstract static class Merger<T> {\n\t\tprivate final Map<String, T> entriesClient, entriesServer;\n\t\tprivate final List<String> entryNames;\n\t\t\n\t\tpublic Merger(List<T> entriesClient, List<T> entriesServer) {\n\t\t\tthis.entriesClient = new LinkedHashMap<>();\n\t\t\tthis.entriesServer = new LinkedHashMap<>();\n\t\t\t\n\t\t\tList<String> listClient = toMap(entriesClient, this.entriesClient);\n\t\t\tList<String> listServer = toMap(entriesServer, this.entriesServer);\n\t\t\t\n\t\t\tthis.entryNames = mergePreserveOrder(listClient, listServer);\n\t\t}\n\t\t", "\t\tpublic abstract String getName(T entry);\n\t\tpublic abstract void applySide(T entry, String side);\n\t\t\n\t\tprivate List<String> toMap(List<T> entries, Map<String, T> map) {\n\t\t\tList<String> list = new ArrayList<>(entries.size());\n\t\t\tfor (T entry : entries) {\n\t\t\t\tString name = getName(entry);\n\t\t\t\tmap.put(name, entry);\n\t\t\t\tlist.add(name);\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t\t", "\t\tpublic void merge(List<T> list) {\n\t\t\tfor (String s : entryNames) {\n\t\t\t\tT entryClient = entriesClient.get(s);\n\t\t\t\tT entryServer = entriesServer.get(s);\n\t\t\t\t\n\t\t\t\tif (entryClient != null && entryServer != null) {\n\t\t\t\t\tlist.add(entryClient);\n\t\t\t\t} else if (entryClient != null) {\n\t\t\t\t\tapplySide(entryClient, \"CLIENT\"); //the name of the enum constant in `sideEnum`; should probably be configurable\n\t\t\t\t\tlist.add(entryClient);\n\t\t\t\t} else {\n\t\t\t\t\tapplySide(entryServer, \"SERVER\"); //the name of the enum constant in `sideEnum`; should probably be configurable\n\t\t\t\t\tlist.add(entryServer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void visitSideAnnotation(AnnotationVisitor av, String side) {\n\t\tav.visitEnum(\"value\", sideEnum, side.toUpperCase(Locale.ROOT));\n\t\tav.visitEnd();\n\t}\n\t\n\tprivate void visitItfAnnotation(AnnotationVisitor av, String side, List<String> itfDescriptors) {", "\t\tfor (String itf : itfDescriptors) {\n\t\t\tAnnotationVisitor avItf = av.visitAnnotation(null, sidedInterfaceAnnotation);\n\t\t\tavItf.visitEnum(\"value\", sideEnum, side.toUpperCase(Locale.ROOT));\n\t\t\tavItf.visit(\"itf\", Type.getType(\"L\" + itf + \";\"));\n\t\t\tavItf.visitEnd();\n\t\t}\n\t}\n\t\n\tpublic class SidedClassVisitor extends ClassVisitor {\n\t\tprivate final String side;\n\t\tprivate boolean alreadyHasOne = false;\n\t\t\n\t\tpublic SidedClassVisitor(int api, ClassVisitor cv, String side) {\n\t\t\tsuper(api, cv);\n\t\t\tthis.side = side;\n\t\t}\n\t\t\n\t\t@Override", "\tpublic class SidedClassVisitor extends ClassVisitor {\n\t\tprivate final String side;\n\t\tprivate boolean alreadyHasOne = false;\n\t\t\n\t\tpublic SidedClassVisitor(int api, ClassVisitor cv, String side) {\n\t\t\tsuper(api, cv);\n\t\t\tthis.side = side;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n\t\t\t//avoid adding duplicate annotations where a forge binpatch already added one", "\t\tpublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n\t\t\t//avoid adding duplicate annotations where a forge binpatch already added one\n\t\t\tif(descriptor.equals(sideDescriptorAnnotation)) alreadyHasOne = true;\n\t\t\t\n\t\t\treturn super.visitAnnotation(descriptor, visible);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void visitEnd() {\n\t\t\tif(!alreadyHasOne) {\n\t\t\t\tAnnotationVisitor av = cv.visitAnnotation(sideDescriptorAnnotation, true);\n\t\t\t\tvisitSideAnnotation(av, side);\n\t\t\t}\n\t\t\tsuper.visitEnd();\n\t\t}\n\t}\n\t\n\tpublic byte[] merge(byte[] classClient, byte[] classServer) {\n\t\tClassReader readerC = new ClassReader(classClient);\n\t\tClassReader readerS = new ClassReader(classServer);\n\t\tClassWriter writer = new ClassWriter(0);\n\t\t\n\t\tClassNode nodeC = new ClassNode(Opcodes.ASM9);\n\t\treaderC.accept(nodeC, 0);\n\t\t\n\t\tClassNode nodeS = new ClassNode(Opcodes.ASM9);\n\t\treaderS.accept(nodeS, 0);\n\t\t\n\t\tClassNode nodeOut = new ClassNode(Opcodes.ASM9);\n\t\tnodeOut.version = nodeC.version;\n\t\tnodeOut.access = nodeC.access;\n\t\tnodeOut.name = nodeC.name;\n\t\tnodeOut.signature = nodeC.signature;\n\t\tnodeOut.superName = nodeC.superName;\n\t\tnodeOut.sourceFile = nodeC.sourceFile;\n\t\tnodeOut.sourceDebug = nodeC.sourceDebug;\n\t\tnodeOut.outerClass = nodeC.outerClass;\n\t\tnodeOut.outerMethod = nodeC.outerMethod;\n\t\tnodeOut.outerMethodDesc = nodeC.outerMethodDesc;\n\t\tnodeOut.module = nodeC.module;\n\t\tnodeOut.nestHostClass = nodeC.nestHostClass;\n\t\tnodeOut.nestMembers = nodeC.nestMembers;\n\t\tnodeOut.attrs = nodeC.attrs;\n\t\t", "\t\tpublic void visitEnd() {\n\t\t\tif(!alreadyHasOne) {\n\t\t\t\tAnnotationVisitor av = cv.visitAnnotation(sideDescriptorAnnotation, true);\n\t\t\t\tvisitSideAnnotation(av, side);\n\t\t\t}\n\t\t\tsuper.visitEnd();\n\t\t}\n\t}\n\t\n\tpublic byte[] merge(byte[] classClient, byte[] classServer) {\n\t\tClassReader readerC = new ClassReader(classClient);\n\t\tClassReader readerS = new ClassReader(classServer);\n\t\tClassWriter writer = new ClassWriter(0);\n\t\t\n\t\tClassNode nodeC = new ClassNode(Opcodes.ASM9);\n\t\treaderC.accept(nodeC, 0);\n\t\t\n\t\tClassNode nodeS = new ClassNode(Opcodes.ASM9);\n\t\treaderS.accept(nodeS, 0);\n\t\t\n\t\tClassNode nodeOut = new ClassNode(Opcodes.ASM9);\n\t\tnodeOut.version = nodeC.version;\n\t\tnodeOut.access = nodeC.access;\n\t\tnodeOut.name = nodeC.name;\n\t\tnodeOut.signature = nodeC.signature;\n\t\tnodeOut.superName = nodeC.superName;\n\t\tnodeOut.sourceFile = nodeC.sourceFile;\n\t\tnodeOut.sourceDebug = nodeC.sourceDebug;\n\t\tnodeOut.outerClass = nodeC.outerClass;\n\t\tnodeOut.outerMethod = nodeC.outerMethod;\n\t\tnodeOut.outerMethodDesc = nodeC.outerMethodDesc;\n\t\tnodeOut.module = nodeC.module;\n\t\tnodeOut.nestHostClass = nodeC.nestHostClass;\n\t\tnodeOut.nestMembers = nodeC.nestMembers;\n\t\tnodeOut.attrs = nodeC.attrs;\n\t\t", "\t\tif (nodeC.invisibleAnnotations != null) {\n\t\t\tnodeOut.invisibleAnnotations = new ArrayList<>();\n\t\t\tnodeOut.invisibleAnnotations.addAll(nodeC.invisibleAnnotations);\n\t\t}\n\t\tif (nodeC.invisibleTypeAnnotations != null) {\n\t\t\tnodeOut.invisibleTypeAnnotations = new ArrayList<>();\n\t\t\tnodeOut.invisibleTypeAnnotations.addAll(nodeC.invisibleTypeAnnotations);\n\t\t}\n\t\tif (nodeC.visibleAnnotations != null) {\n\t\t\tnodeOut.visibleAnnotations = new ArrayList<>();\n\t\t\tnodeOut.visibleAnnotations.addAll(nodeC.visibleAnnotations);\n\t\t}", "\t\tif (nodeC.visibleAnnotations != null) {\n\t\t\tnodeOut.visibleAnnotations = new ArrayList<>();\n\t\t\tnodeOut.visibleAnnotations.addAll(nodeC.visibleAnnotations);\n\t\t}\n\t\tif (nodeC.visibleTypeAnnotations != null) {\n\t\t\tnodeOut.visibleTypeAnnotations = new ArrayList<>();\n\t\t\tnodeOut.visibleTypeAnnotations.addAll(nodeC.visibleTypeAnnotations);\n\t\t}\n\t\t\n\t\tList<String> itfs = mergePreserveOrder(nodeC.interfaces, nodeS.interfaces);\n\t\tnodeOut.interfaces = new ArrayList<>();\n\t\t\n\t\tList<String> clientItfs = new ArrayList<>();\n\t\tList<String> serverItfs = new ArrayList<>();\n\t\t", "\t\tfor (String s : itfs) {\n\t\t\tboolean nc = nodeC.interfaces.contains(s);\n\t\t\tboolean ns = nodeS.interfaces.contains(s);\n\t\t\tnodeOut.interfaces.add(s);\n\t\t\tif (nc && !ns) {\n\t\t\t\tclientItfs.add(s);\n\t\t\t} else if (ns && !nc) {\n\t\t\t\tserverItfs.add(s);\n\t\t\t}\n\t\t}\n\t\t", "\t\tif (!clientItfs.isEmpty() || !serverItfs.isEmpty()) {\n\t\t\tAnnotationVisitor envInterfaces = nodeOut.visitAnnotation(sidedInterfaceListAnnotation, false);\n\t\t\tAnnotationVisitor eiArray = envInterfaces.visitArray(\"value\");\n\t\t\t\n\t\t\tif (!clientItfs.isEmpty()) {\n\t\t\t\tvisitItfAnnotation(eiArray, \"CLIENT\", clientItfs);\n\t\t\t}\n\t\t\tif (!serverItfs.isEmpty()) {\n\t\t\t\tvisitItfAnnotation(eiArray, \"SERVER\", serverItfs);\n\t\t\t}\n\t\t\teiArray.visitEnd();\n\t\t\tenvInterfaces.visitEnd();\n\t\t}\n\t\t\n\t\tnew Merger<InnerClassNode>(nodeC.innerClasses, nodeS.innerClasses) {\n\t\t\t@Override", "\t\t\tpublic String getName(InnerClassNode entry) {\n\t\t\t\treturn entry.name;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void applySide(InnerClassNode entry, String side) {\n\t\t\t}\n\t\t}.merge(nodeOut.innerClasses);\n\t\t\n\t\tnew Merger<FieldNode>(nodeC.fields, nodeS.fields) {\n\t\t\t@Override", "\t\t\tpublic String getName(FieldNode entry) {\n\t\t\t\treturn entry.name + \";;\" + entry.desc;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void applySide(FieldNode entry, String side) {\n\t\t\t\t//avoid adding duplicate annotations where a forge binpatch already added one\n\t\t\t\tif(entry.visibleAnnotations == null || entry.visibleAnnotations.stream().noneMatch(a -> a.desc.equals(sideDescriptorAnnotation))) {\n\t\t\t\t\tAnnotationVisitor av = entry.visitAnnotation(sideDescriptorAnnotation, false);\n\t\t\t\t\tvisitSideAnnotation(av, side);\n\t\t\t\t}\n\t\t\t}\n\t\t}.merge(nodeOut.fields);\n\t\t\n\t\tnew Merger<MethodNode>(nodeC.methods, nodeS.methods) {\n\t\t\t@Override", "\t\t\tpublic String getName(MethodNode entry) {\n\t\t\t\treturn entry.name + entry.desc;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void applySide(MethodNode entry, String side) {\n\t\t\t\t//avoid adding duplicate annotations where a forge binpatch already added one\n\t\t\t\tif(entry.visibleAnnotations == null || entry.visibleAnnotations.stream().noneMatch(a -> a.desc.equals(sideDescriptorAnnotation))) {\n\t\t\t\t\tAnnotationVisitor av = entry.visitAnnotation(sideDescriptorAnnotation, false);\n\t\t\t\t\tvisitSideAnnotation(av, side);\n\t\t\t\t}\n\t\t\t}\n\t\t}.merge(nodeOut.methods);\n\t\t\n\t\tnodeOut.accept(writer);\n\t\treturn writer.toByteArray();\n\t}\n\t", "\tpublic static List<String> mergePreserveOrder(List<String> first, List<String> second) {\n\t\tList<String> out = new ArrayList<>();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t\n\t\twhile (i < first.size() || j < second.size()) {\n\t\t\twhile (i < first.size() && j < second.size()\n\t\t\t\t&& first.get(i).equals(second.get(j))) {\n\t\t\t\tout.add(first.get(i));\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t", "\t\t\twhile (i < first.size() && !second.contains(first.get(i))) {\n\t\t\t\tout.add(first.get(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (j < second.size() && !first.contains(second.get(j))) {\n\t\t\t\tout.add(second.get(j));\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn out;\n\t}\n}\n"]}
