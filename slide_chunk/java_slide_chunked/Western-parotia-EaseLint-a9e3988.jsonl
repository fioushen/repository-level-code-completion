{"filename": "AndroidLint-7.4.2/lint-plugin/lint-code-backup/ArtifactsImplProxy.java", "chunked_list": ["package com.buildsrc.lint;\n\nimport com.android.build.api.artifact.impl.ArtifactsImpl;\nimport com.android.build.gradle.internal.scope.InternalArtifactType;\n\nimport org.gradle.api.Task;\nimport org.gradle.api.file.FileSystemLocation;\nimport org.gradle.api.file.FileSystemLocationProperty;\nimport org.gradle.api.tasks.TaskProvider;\n", "import org.gradle.api.tasks.TaskProvider;\n\n\nimport kotlin.jvm.functions.Function1;\n\n/**\n * \u901a\u8fc7java \u6587\u4ef6\u8bbf\u95eekotlin \u7684 internal \u65b9\u6cd5\uff0c\u5173\u95ed \u7f16\u8bd1\u9519\u8bef\n * \u53e6\u4e00\u79cd\u662f\u901a\u8fc7\u53cd\u5c04\uff0c\u8303\u578b\u591a\u7684\u65f6\u5019\u53cd\u5c04\u8fc7\u4e8e\u9ebb\u70e6\n */\npublic class ArtifactsImplProxy {\n\n    final String LINT_PRINT_STACKTRACE_ENVIRONMENT_VARIABLE = \"LINT_PRINT_STACKTRACE\";\n    final String ANDROID_LINT_JARS_ENVIRONMENT_VARIABLE = \"ANDROID_LINT_JARS\";\n    final String PARTIAL_RESULTS_DIR_NAME = \"out\";\n\n    public <FILE_TYPE extends FileSystemLocation, TASK extends Task> void proxy(TaskProvider<TASK> taskProvider,\n                                                                                Function1<? super TASK, ? extends FileSystemLocationProperty<FILE_TYPE>> property,\n                                                                                ArtifactsImpl artifacts,\n                                                                                InternalArtifactType<FILE_TYPE> internalArtifactType) {\n        artifacts\n                .setInitialProvider(taskProvider, property)\n                .withName(PARTIAL_RESULTS_DIR_NAME)\n                .on(internalArtifactType);\n    }\n\n}\n", " */\npublic class ArtifactsImplProxy {\n\n    final String LINT_PRINT_STACKTRACE_ENVIRONMENT_VARIABLE = \"LINT_PRINT_STACKTRACE\";\n    final String ANDROID_LINT_JARS_ENVIRONMENT_VARIABLE = \"ANDROID_LINT_JARS\";\n    final String PARTIAL_RESULTS_DIR_NAME = \"out\";\n\n    public <FILE_TYPE extends FileSystemLocation, TASK extends Task> void proxy(TaskProvider<TASK> taskProvider,\n                                                                                Function1<? super TASK, ? extends FileSystemLocationProperty<FILE_TYPE>> property,\n                                                                                ArtifactsImpl artifacts,\n                                                                                InternalArtifactType<FILE_TYPE> internalArtifactType) {\n        artifacts\n                .setInitialProvider(taskProvider, property)\n                .withName(PARTIAL_RESULTS_DIR_NAME)\n                .on(internalArtifactType);\n    }\n\n}\n"]}
{"filename": "AndroidLint-7.4.2/lint-plugin/app/src/main/java/com/easelint/gradle/JavaLog.java", "chunked_list": ["package com.easelint.gradle;\n\nimport android.util.Log;\n\n/**\n * create by zhusw on 11/1/21 15:54\n */\npublic class JavaLog {\n    static void foo() {\n        Log.d(\"\", \"cccc\");\n        Log.e(\"\", \"cccc\");\n    }\n}\n"]}
{"filename": "AndroidLint-7.4.2/lint-plugin/app/src/main/java/com/easelint/gradle/JavaParse.java", "chunked_list": ["package com.easelint.gradle;\n\npublic class JavaParse {\n    void foo() {\n        int a = Integer.valueOf(\"1\");\n    }\n}\n"]}
{"filename": "AndroidLint-7.4.2/lint-plugin/app/src/main/java/com/easelint/gradle/JavaPrint.java", "chunked_list": ["package com.easelint.gradle;\n\n/**\n * create by zhusw on 11/1/21 15:54\n */\npublic class JavaPrint {\n    static void foo() {\n        System.out.println(\"this is foo log\");\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-checks/app/src/main/java/com/zsw/devopshsyq/parcelable/LintParcelableJavaInnerClass.java", "chunked_list": ["package com.zsw.devopshsyq.parcelable;\n\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\nimport java.io.Serializable;\n\npublic class LintParcelableJavaInnerClass implements Serializable {\n    String name;\n\n    Body body;\n\n    class Body {\n\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-checks/app/src/main/java/com/zsw/devopshsyq/parcelable/LintParcelableJava.java", "chunked_list": ["package com.zsw.devopshsyq.parcelable;\n\nimport android.os.Parcel;\nimport android.os.Parcelable;\npublic class LintParcelableJava implements Parcelable {\n    String name;\n    int age;\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override", "    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-checks/app/src/main/java/com/zsw/devopshsyq/parcelable/ParcelableChild.java", "chunked_list": ["package com.zsw.devopshsyq.parcelable;\n\nimport android.graphics.Color;\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\npublic class ParcelableChild implements Parcelable {\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override", "    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-checks/app/src/main/java/com/zsw/devopshsyq/parcelable/LintParcelableJava2.java", "chunked_list": ["package com.zsw.devopshsyq.parcelable;\n\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\nimport java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\npublic class LintParcelableJava2<T> implements Parcelable {\n    String name;\n    int age;\n    Integer height;\n    MyReference reference;\n    Child empty;\n    SerializableChild serializableChild;\n\n    static MyReference reference1;\n\n    List<String> list = null;\n\n    HashMap<String, MyReference> map2 = null;\n\n    HashMap<String, Integer> map1 = null;\n\n    LinkedHashMap<String, Object> lMap = null;\n    ArrayDeque<Object> a = null;\n\n    List<List<List<Object>>> l = null;\n    List<T> t = null;\n\n\n    @Override", "import java.util.List;\n\npublic class LintParcelableJava2<T> implements Parcelable {\n    String name;\n    int age;\n    Integer height;\n    MyReference reference;\n    Child empty;\n    SerializableChild serializableChild;\n\n    static MyReference reference1;\n\n    List<String> list = null;\n\n    HashMap<String, MyReference> map2 = null;\n\n    HashMap<String, Integer> map1 = null;\n\n    LinkedHashMap<String, Object> lMap = null;\n    ArrayDeque<Object> a = null;\n\n    List<List<List<Object>>> l = null;\n    List<T> t = null;\n\n\n    @Override", "    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(this.name);\n\n//        dest.writeParcelableList();\n    }\n", "    public void readFromParcel(Parcel source) {\n        this.name = source.readString();\n//        source.readParcelableList()\n    }\n\n    public LintParcelableJava2() {\n    }\n\n    protected LintParcelableJava2(Parcel in) {\n        this.name = in.readString();\n    }\n", "    public static final Creator<LintParcelableJava2> CREATOR = new Creator<LintParcelableJava2>() {\n        @Override\n        public LintParcelableJava2 createFromParcel(Parcel source) {\n            return new LintParcelableJava2(source);\n        }\n\n        @Override\n        public LintParcelableJava2[] newArray(int size) {\n            return new LintParcelableJava2[size];\n        }\n    };\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-checks/app/src/main/java/com/zsw/devopshsyq/log/TestLog.java", "chunked_list": ["package com.zsw.devopshsyq.log;\n\nimport android.util.Log;\n\n/**\n * create by zhusw on 11/1/21 15:54\n */\npublic class TestLog {\n\n    static void foo() {\n        Log.d(\"\", \"cccc\");\n        System.out.println(\"this is foo log\");\n        System.out.println(\"this is foo log\");\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-plugin/temp/src/main/java/com/practice/temp/JavaLog.java", "chunked_list": ["package com.practice.temp;\n\nimport android.util.Log;\n\n/**\n * create by zhusw on 11/1/21 15:54\n */\npublic class JavaLog {\n    static void foo() {\n        Log.d(\"\", \"cccc\");\n        Log.e(\"\", \"cccc\");\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-plugin/temp/src/main/java/com/practice/temp/JavaParse.java", "chunked_list": ["package com.practice.temp;\n\npublic class JavaParse {\n    void foo() {\n        int a = Integer.valueOf(\"1\");\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-plugin/temp/src/main/java/com/practice/temp/JavaPrint.java", "chunked_list": ["package com.practice.temp;\n\n/**\n * create by zhusw on 11/1/21 15:54\n */\npublic class JavaPrint {\n    static void foo() {\n        System.out.println(\"this is foo log\");\n        int a = 1;\n        System.out.println(\"this is foo log\" + a);\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-plugin/subModule/src/main/java/com/practice/temp/JavaParse.java", "chunked_list": ["package com.practice.temp;\n\npublic class JavaParse {\n    void foo() {\n        int a = Integer.valueOf(\"1\");\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-plugin/buildSrc/src/main/java/com/buildsrc/easelint/lint/task/EaseLintPerVariantTask.java", "chunked_list": ["package com.buildsrc.easelint.lint.task;\n\nimport com.android.annotations.NonNull;\nimport com.android.annotations.Nullable;\nimport com.android.build.api.component.impl.ComponentPropertiesImpl;\nimport com.android.build.api.variant.impl.VariantPropertiesImpl;\nimport com.android.build.gradle.internal.tasks.VariantAwareTask;\nimport com.android.build.gradle.options.BooleanOption;\nimport com.android.build.gradle.tasks.LintBaseTask;\nimport com.android.utils.StringHelper;", "import com.android.build.gradle.tasks.LintBaseTask;\nimport com.android.utils.StringHelper;\nimport com.buildsrc.easelint.lint.helper.LintOptionsInjector;\n\nimport org.gradle.api.file.ConfigurableFileCollection;\nimport org.gradle.api.file.FileCollection;\nimport org.gradle.api.tasks.InputFiles;\nimport org.gradle.api.tasks.Internal;\nimport org.gradle.api.tasks.Optional;\nimport org.gradle.api.tasks.PathSensitive;", "import org.gradle.api.tasks.Optional;\nimport org.gradle.api.tasks.PathSensitive;\nimport org.gradle.api.tasks.PathSensitivity;\nimport org.gradle.api.tasks.TaskAction;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class EaseLintPerVariantTask extends LintBaseTask implements VariantAwareTask {\n    private VariantInputs variantInputs;\n    private ConfigurableFileCollection allInputs;\n    private boolean fatalOnly;\n\n    private String variantName;\n\n    @Internal\n    @NonNull\n    @Override", "\npublic abstract class EaseLintPerVariantTask extends LintBaseTask implements VariantAwareTask {\n    private VariantInputs variantInputs;\n    private ConfigurableFileCollection allInputs;\n    private boolean fatalOnly;\n\n    private String variantName;\n\n    @Internal\n    @NonNull\n    @Override", "    public String getVariantName() {\n        return variantName;\n    }\n\n    @Override\n    public void setVariantName(String variantName) {\n        this.variantName = variantName;\n    }\n\n    @InputFiles\n    @PathSensitive(PathSensitivity.ABSOLUTE)\n    @Optional", "    public FileCollection getAllInputs() {\n        return allInputs;\n    }\n\n    @TaskAction\n    public void lint() {\n        runLint(new LintPerVariantTaskDescriptor());\n    }\n\n    @Override\n    protected void runLint(LintBaseTaskDescriptor descriptor) {\n        //\u6bcf\u6b21run lint \u65f6 \u540c\u6b65\u6700\u65b0\u7684lintOptions\n        new LintOptionsInjector().inject(getProject(), lintOptions);\n\n        //\u4f7f\u7528\u81ea\u5df1\u7684ReflectiveLintRunner\uff0c\u9700\u8981\u901a\u8fc7\u53cd\u5c04\u8bbe\u7f6e\u6587\u4ef6\u7684\u7b5b\u9009\u6761\u4ef6\n        FileCollection lintClassPath = getLintClassPath();", "        if (lintClassPath != null) {\n            new EaseLintReflectiveLintRunner().runLint(\n                    getProject().getGradle(),\n                    descriptor,\n                    lintClassPath.getFiles(),\n                    getProject());\n        }\n    }\n\n    private class LintPerVariantTaskDescriptor extends LintBaseTaskDescriptor {\n        @Nullable\n        @Override", "        public String getVariantName() {\n            return EaseLintPerVariantTask.this.getVariantName();\n        }\n\n        @Nullable\n        @Override\n        public VariantInputs getVariantInputs(@NonNull String variantName) {\n            assert variantName.equals(getVariantName());\n            return variantInputs;\n        }\n\n        @NonNull\n        @Override\n        public Set<String> getVariantNames() {\n            return Collections.singleton(variantName);\n        }\n\n        @Override", "        public boolean isFatalOnly() {\n            return fatalOnly;\n        }\n    }\n\n    public static class CreationAction extends BaseCreationAction<EaseLintPerVariantTask> {\n\n        private final VariantPropertiesImpl variantProperties;\n        private final List<? extends VariantPropertiesImpl> allVariants;\n\n        public CreationAction(\n                @NonNull VariantPropertiesImpl variantProperties,\n                @NonNull List<? extends VariantPropertiesImpl> allVariants) {\n            super(variantProperties.getGlobalScope());\n            this.variantProperties = variantProperties;\n            this.allVariants = allVariants;\n        }\n\n        @Override\n        @NonNull", "        public String getName() {\n            return variantProperties.computeTaskName(\"lint\");\n        }\n\n        @Override\n        @NonNull\n        public Class<EaseLintPerVariantTask> getType() {\n            return EaseLintPerVariantTask.class;\n        }\n\n        @Override", "        public void configure(@NonNull EaseLintPerVariantTask lint) {\n            super.configure(lint);\n\n            lint.setVariantName(variantProperties.getName());\n            lint.allInputs = globalScope.getProject().files();\n\n            lint.variantInputs = new VariantInputs(variantProperties);\n            lint.allInputs.from(lint.variantInputs.getAllInputs());\n\n            for (VariantPropertiesImpl variant : allVariants) {\n                addModelArtifactsToInputs(lint.allInputs, variant);\n            }\n\n            lint.setDescription(\n                    StringHelper.appendCapitalized(\n                            \"Runs lint on the \", lint.getVariantName(), \" build.\"));\n            lint.getEnableGradleWorkers()\n                    .set(\n                            variantProperties\n                                    .getServices()\n                                    .getProjectOptions()\n                                    .get(BooleanOption.ENABLE_GRADLE_WORKERS));\n        }\n    }\n", "            for (VariantPropertiesImpl variant : allVariants) {\n                addModelArtifactsToInputs(lint.allInputs, variant);\n            }\n\n            lint.setDescription(\n                    StringHelper.appendCapitalized(\n                            \"Runs lint on the \", lint.getVariantName(), \" build.\"));\n            lint.getEnableGradleWorkers()\n                    .set(\n                            variantProperties\n                                    .getServices()\n                                    .getProjectOptions()\n                                    .get(BooleanOption.ENABLE_GRADLE_WORKERS));\n        }\n    }\n", "    public static class VitalCreationAction extends BaseCreationAction<EaseLintPerVariantTask> {\n\n        private final ComponentPropertiesImpl componentProperties;\n        private final List<? extends VariantPropertiesImpl> allComponentsWithLint;\n\n        public VitalCreationAction(\n                @NonNull ComponentPropertiesImpl componentProperties,\n                @NonNull List<? extends VariantPropertiesImpl> allComponentsWithLint) {\n            super(componentProperties.getGlobalScope());\n            this.componentProperties = componentProperties;\n            this.allComponentsWithLint = allComponentsWithLint;\n        }\n\n        @NonNull\n        @Override", "        public String getName() {\n            return componentProperties.computeTaskName(\"lintVital\");\n        }\n\n        @NonNull\n        @Override\n        public Class<EaseLintPerVariantTask> getType() {\n            return EaseLintPerVariantTask.class;\n        }\n\n        @Override", "        public void configure(@NonNull EaseLintPerVariantTask task) {\n            super.configure(task);\n\n            task.setVariantName(componentProperties.getName());\n            task.allInputs = globalScope.getProject().files();\n\n            task.variantInputs = new VariantInputs(componentProperties);\n            task.allInputs.from(task.variantInputs.getAllInputs());\n\n            for (ComponentPropertiesImpl component : allComponentsWithLint) {\n                addModelArtifactsToInputs(task.allInputs, component);\n            }\n\n            task.fatalOnly = true;\n            task.setDescription(\n                    \"Runs lint on just the fatal issues in the \"\n                            + task.getVariantName()\n                            + \" build.\");\n            task.getEnableGradleWorkers()\n                    .set(\n                            componentProperties\n                                    .getServices()\n                                    .getProjectOptions()\n                                    .get(BooleanOption.ENABLE_GRADLE_WORKERS));\n        }\n    }\n}\n", "            for (ComponentPropertiesImpl component : allComponentsWithLint) {\n                addModelArtifactsToInputs(task.allInputs, component);\n            }\n\n            task.fatalOnly = true;\n            task.setDescription(\n                    \"Runs lint on just the fatal issues in the \"\n                            + task.getVariantName()\n                            + \" build.\");\n            task.getEnableGradleWorkers()\n                    .set(\n                            componentProperties\n                                    .getServices()\n                                    .getProjectOptions()\n                                    .get(BooleanOption.ENABLE_GRADLE_WORKERS));\n        }\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-gradle-api/lintGradle/src/main/java/com/android/tools/lint/annotations/Extractor.java", "chunked_list": ["package com.android.tools.lint.annotations;\n\nimport static com.android.SdkConstants.AMP_ENTITY;\nimport static com.android.SdkConstants.ANDROIDX_PKG_PREFIX;\nimport static com.android.SdkConstants.APOS_ENTITY;\nimport static com.android.SdkConstants.ATTR_NAME;\nimport static com.android.SdkConstants.ATTR_VALUE;\nimport static com.android.SdkConstants.DOT_CLASS;\nimport static com.android.SdkConstants.DOT_JAR;\nimport static com.android.SdkConstants.DOT_JAVA;", "import static com.android.SdkConstants.DOT_JAR;\nimport static com.android.SdkConstants.DOT_JAVA;\nimport static com.android.SdkConstants.DOT_KT;\nimport static com.android.SdkConstants.DOT_XML;\nimport static com.android.SdkConstants.DOT_ZIP;\nimport static com.android.SdkConstants.GT_ENTITY;\nimport static com.android.SdkConstants.INT_DEF_ANNOTATION;\nimport static com.android.SdkConstants.LONG_DEF_ANNOTATION;\nimport static com.android.SdkConstants.LT_ENTITY;\nimport static com.android.SdkConstants.QUOT_ENTITY;", "import static com.android.SdkConstants.LT_ENTITY;\nimport static com.android.SdkConstants.QUOT_ENTITY;\nimport static com.android.SdkConstants.STRING_DEF_ANNOTATION;\nimport static com.android.SdkConstants.SUPPORT_ANNOTATIONS_PREFIX;\nimport static com.android.SdkConstants.TYPE_DEF_FLAG_ATTRIBUTE;\nimport static com.android.SdkConstants.TYPE_DEF_VALUE_ATTRIBUTE;\nimport static com.android.SdkConstants.VALUE_TRUE;\nimport static com.android.tools.lint.checks.AnnotationDetector.INT_RANGE_ANNOTATION;\nimport static com.android.tools.lint.detector.api.Lint.assertionsEnabled;\n", "import static com.android.tools.lint.detector.api.Lint.assertionsEnabled;\n\nimport com.android.annotations.NonNull;\nimport com.android.annotations.Nullable;\nimport com.android.builder.packaging.TypedefRemover;\nimport com.android.support.AndroidxName;\nimport com.android.tools.lint.client.api.AnnotationLookup;\nimport com.android.tools.lint.detector.api.ConstantEvaluator;\nimport com.android.tools.lint.detector.api.Lint;\nimport com.android.tools.lint.gradle.api.ReflectiveLintRunner;", "import com.android.tools.lint.detector.api.Lint;\nimport com.android.tools.lint.gradle.api.ReflectiveLintRunner;\nimport com.android.utils.FileUtils;\nimport com.android.utils.XmlUtils;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.Closeables;\nimport com.google.common.io.Files;", "import com.google.common.io.Closeables;\nimport com.google.common.io.Files;\nimport com.google.common.xml.XmlEscapers;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.StandardFileSystems;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.openapi.vfs.VirtualFileSystem;\nimport com.intellij.psi.PsiAnnotation;\nimport com.intellij.psi.PsiAnnotationMemberValue;\nimport com.intellij.psi.PsiClass;", "import com.intellij.psi.PsiAnnotationMemberValue;\nimport com.intellij.psi.PsiClass;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiField;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.psi.PsiManager;\nimport com.intellij.psi.PsiMethod;\nimport com.intellij.psi.PsiModifierList;\nimport com.intellij.psi.PsiNameValuePair;\nimport com.intellij.psi.PsiParameter;", "import com.intellij.psi.PsiNameValuePair;\nimport com.intellij.psi.PsiParameter;\nimport com.intellij.psi.PsiParameterList;\nimport com.intellij.psi.PsiType;\nimport com.intellij.psi.PsiVariable;\nimport com.intellij.psi.javadoc.PsiDocComment;\n\nimport org.jetbrains.uast.UAnnotated;\nimport org.jetbrains.uast.UAnnotation;\nimport org.jetbrains.uast.UAnonymousClass;", "import org.jetbrains.uast.UAnnotation;\nimport org.jetbrains.uast.UAnonymousClass;\nimport org.jetbrains.uast.UBinaryExpressionWithType;\nimport org.jetbrains.uast.UCallExpression;\nimport org.jetbrains.uast.UClass;\nimport org.jetbrains.uast.UClassInitializer;\nimport org.jetbrains.uast.UComment;\nimport org.jetbrains.uast.UElement;\nimport org.jetbrains.uast.UExpression;\nimport org.jetbrains.uast.UField;", "import org.jetbrains.uast.UExpression;\nimport org.jetbrains.uast.UField;\nimport org.jetbrains.uast.UFile;\nimport org.jetbrains.uast.ULiteralExpression;\nimport org.jetbrains.uast.UMethod;\nimport org.jetbrains.uast.UNamedExpression;\nimport org.jetbrains.uast.UParameter;\nimport org.jetbrains.uast.UReferenceExpression;\nimport org.jetbrains.uast.UastEmptyExpression;\nimport org.jetbrains.uast.UastFacade;", "import org.jetbrains.uast.UastEmptyExpression;\nimport org.jetbrains.uast.UastFacade;\nimport org.jetbrains.uast.UastVisibility;\nimport org.jetbrains.uast.java.JavaUAnnotation;\nimport org.jetbrains.uast.java.expressions.JavaUAnnotationCallExpression;\nimport org.jetbrains.uast.util.UastExpressionUtils;\nimport org.jetbrains.uast.visitor.AbstractUastVisitor;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;", "import org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;", "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;", "import java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;", "import java.util.Map;\nimport java.util.Set;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.jar.JarOutputStream;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\n\nimport kotlin.io.FilesKt;", "\nimport kotlin.io.FilesKt;\nimport kotlin.text.Charsets;\n\n/**\n * Annotation extractor which looks for annotations in parsed compilation units and writes the\n * annotations into a format suitable for use by IntelliJ and Android Studio etc; it's basically an\n * XML file, organized by package, which lists the signatures for fields and methods in classes in\n * the given package, and identifiers method parameters by index, and lists the annotations\n * annotated on that element.", " * the given package, and identifiers method parameters by index, and lists the annotations\n * annotated on that element.\n *\n * <p>This is primarily intended for use in Android libraries such as the support library, where you\n * want to use the resource int ({@code StringRes}, {@code DrawableRes}, and so on) annotations to\n * indicate what types of id's are expected, or the {@code IntDef} or {@code StringDef} annotations\n * to record which specific constants are allowed in int and String parameters.\n *\n * <p>However, the code is also used to extract SDK annotations from the platform, where the package\n * names of the annotations differ slightly (and where the nullness annotations do not have class", " * <p>However, the code is also used to extract SDK annotations from the platform, where the package\n * names of the annotations differ slightly (and where the nullness annotations do not have class\n * retention for example). Therefore, this code contains some extra support not needed when\n * extracting annotations in an Android library, such as code to skip annotations for any\n * method/field not mentioned in the API database, and code to rewrite the android.jar file to\n * insert annotations in the generated bytecode.\n *\n * <p>\n */\npublic class Extractor {\n    /**\n     * If true, remove typedefs (even public ones) if they are marked with {@code @hide}. This is\n     * disabled because for some reason, the ECJ nodes do not provide valid contents of javadoc\n     * entries for classes.\n     */", " */\npublic class Extractor {\n    /**\n     * If true, remove typedefs (even public ones) if they are marked with {@code @hide}. This is\n     * disabled because for some reason, the ECJ nodes do not provide valid contents of javadoc\n     * entries for classes.\n     */\n    public static final boolean REMOVE_HIDDEN_TYPEDEFS = false;\n\n    /**\n     * Whether to sort annotation attributes (otherwise their declaration order is used)\n     */\n    private final boolean sortAnnotations;\n\n    /**\n     * Whether we should include class-retention annotations into the extracted file; we don't need\n     * {@code android.support.annotation.Nullable} to be in the extracted XML file since it has\n     * class retention and will appear in the compiled .jar version of the library\n     */\n    private final boolean includeClassRetentionAnnotations;\n\n    /**\n     * Whether we should skip nullable annotations in merged in annotations zip files (these are\n     * typically from infer nullity, which sometimes is a bit aggressive in assuming something\n     * should be marked as nullable; see for example issue #66999 or all the manual removals of\n     * findViewById @Nullable return value annotations\n     */\n    private static final boolean INCLUDE_INFERRED_NULLABLE = false;\n", "    public static final String ANDROIDX_NULLABLE = \"androidx.annotation.Nullable\";\n    public static final String ANDROIDX_NOTNULL = \"androidx.annotation.NonNull\";\n    public static final String ANDROID_ANNOTATIONS_PREFIX = \"android.annotation.\";\n    public static final String ANDROID_NULLABLE = \"android.annotation.Nullable\";\n    public static final String SUPPORT_NULLABLE = \"android.support.annotation.Nullable\";\n    public static final String SUPPORT_KEEP = \"android.support.annotation.Keep\";\n    public static final String RESOURCE_TYPE_ANNOTATIONS_SUFFIX = \"Res\";\n    public static final String ANDROID_NOTNULL = \"android.annotation.NonNull\";\n    public static final String SUPPORT_NOTNULL = \"android.support.annotation.NonNull\";\n    public static final String ANDROID_INT_DEF = \"android.annotation.IntDef\";\n    public static final String ANDROID_LONG_DEF = \"android.annotation.LongDef\";", "    public static final String SUPPORT_NOTNULL = \"android.support.annotation.NonNull\";\n    public static final String ANDROID_INT_DEF = \"android.annotation.IntDef\";\n    public static final String ANDROID_LONG_DEF = \"android.annotation.LongDef\";\n    public static final String ANDROID_INT_RANGE = \"android.annotation.IntRange\";\n    public static final String ANDROID_STRING_DEF = \"android.annotation.StringDef\";\n    public static final AndroidxName REQUIRES_PERMISSION =\n            AndroidxName.of(SUPPORT_ANNOTATIONS_PREFIX, \"RequiresPermission\");\n    public static final AndroidxName SYSTEM_SERVICE =\n            AndroidxName.of(SUPPORT_ANNOTATIONS_PREFIX, \"SystemService\");\n    public static final String ANDROID_REQUIRES_PERMISSION =\n            \"android.annotation.RequiresPermission\";", "    public static final String ANDROID_REQUIRES_PERMISSION =\n            \"android.annotation.RequiresPermission\";\n    public static final String IDEA_NULLABLE = \"org.jetbrains.annotations.Nullable\";\n    public static final String IDEA_NOTNULL = \"org.jetbrains.annotations.NotNull\";\n    public static final String IDEA_MAGIC = \"org.intellij.lang.annotations.MagicConstant\";\n    public static final String IDEA_CONTRACT = \"org.jetbrains.annotations.Contract\";\n    public static final String IDEA_NON_NLS = \"org.jetbrains.annotations.NonNls\";\n    public static final String ATTR_VAL = \"val\";\n    public static final String ATTR_PURE = \"pure\";\n\n    private static final ImmutableSet<String> MAGIC_CONSTANT_ANNOTATIONS =\n            ImmutableSet.<String>builder()\n                    .add(INT_DEF_ANNOTATION.oldName())\n                    .add(INT_DEF_ANNOTATION.newName())\n                    .add(LONG_DEF_ANNOTATION.oldName())\n                    .add(LONG_DEF_ANNOTATION.newName())\n                    .add(STRING_DEF_ANNOTATION.oldName())\n                    .add(STRING_DEF_ANNOTATION.newName())\n                    .add(INT_RANGE_ANNOTATION.oldName())\n                    .add(INT_RANGE_ANNOTATION.newName())\n                    .add(ANDROID_INT_RANGE)\n                    .add(ANDROID_INT_DEF)\n                    .add(ANDROID_LONG_DEF)\n                    .add(ANDROID_STRING_DEF)\n                    .build();\n\n    @NonNull\n    private final Map<String, List<AnnotationData>> types = new HashMap<>();\n\n    @NonNull\n    private final Set<String> irrelevantAnnotations = new HashSet<>();\n\n    private final Collection<File> classDir;\n\n    /**\n     * Map from package to map from class to items\n     */\n    @NonNull\n    private final Map<String, Map<String, List<Item>>> itemMap = new HashMap<>();\n\n    private Map<String, PackageItem> packageMap;\n\n    @Nullable\n    private final ApiDatabase apiFilter;\n\n    private final boolean displayInfo;\n\n    private final Map<String, Integer> stats = new HashMap<>();\n    private int filteredCount;\n    private int mergedCount;\n\n    private final Set<String> ignoredAnnotations = new HashSet<>();\n    private boolean listIgnored;\n    private List<String> typedefsToRemove;\n    private Map<String, Boolean> sourceRetention;\n    private final List<Item> keepItems = new ArrayList<>();\n", "    public static final String ATTR_PURE = \"pure\";\n\n    private static final ImmutableSet<String> MAGIC_CONSTANT_ANNOTATIONS =\n            ImmutableSet.<String>builder()\n                    .add(INT_DEF_ANNOTATION.oldName())\n                    .add(INT_DEF_ANNOTATION.newName())\n                    .add(LONG_DEF_ANNOTATION.oldName())\n                    .add(LONG_DEF_ANNOTATION.newName())\n                    .add(STRING_DEF_ANNOTATION.oldName())\n                    .add(STRING_DEF_ANNOTATION.newName())\n                    .add(INT_RANGE_ANNOTATION.oldName())\n                    .add(INT_RANGE_ANNOTATION.newName())\n                    .add(ANDROID_INT_RANGE)\n                    .add(ANDROID_INT_DEF)\n                    .add(ANDROID_LONG_DEF)\n                    .add(ANDROID_STRING_DEF)\n                    .build();\n\n    @NonNull\n    private final Map<String, List<AnnotationData>> types = new HashMap<>();\n\n    @NonNull\n    private final Set<String> irrelevantAnnotations = new HashSet<>();\n\n    private final Collection<File> classDir;\n\n    /**\n     * Map from package to map from class to items\n     */\n    @NonNull\n    private final Map<String, Map<String, List<Item>>> itemMap = new HashMap<>();\n\n    private Map<String, PackageItem> packageMap;\n\n    @Nullable\n    private final ApiDatabase apiFilter;\n\n    private final boolean displayInfo;\n\n    private final Map<String, Integer> stats = new HashMap<>();\n    private int filteredCount;\n    private int mergedCount;\n\n    private final Set<String> ignoredAnnotations = new HashSet<>();\n    private boolean listIgnored;\n    private List<String> typedefsToRemove;\n    private Map<String, Boolean> sourceRetention;\n    private final List<Item> keepItems = new ArrayList<>();\n", "    public static List<? extends PsiFile> createUnitsForFiles(\n            @NonNull Project project, @NonNull List<File> specificSources) {\n        List<PsiFile> units = new ArrayList<>(specificSources.size());\n        VirtualFileSystem fileSystem = StandardFileSystems.local();\n        PsiManager manager = PsiManager.getInstance(project);\n\n        for (File source : specificSources) {\n            VirtualFile virtualFile = fileSystem.findFileByPath(source.getPath());\n            if (virtualFile != null) {\n                PsiFile psiFile = manager.findFile(virtualFile);\n                if (psiFile != null) {\n                    units.add(psiFile);\n                }\n            }\n        }\n        return units;\n    }\n", "            if (virtualFile != null) {\n                PsiFile psiFile = manager.findFile(virtualFile);\n                if (psiFile != null) {\n                    units.add(psiFile);\n                }\n            }\n        }\n        return units;\n    }\n\n    public static List<? extends PsiFile> createUnitsInDirectories(\n            @NonNull Project project, @NonNull List<File> sourceDirs) {\n        List<File> specificSources = gatherSources(sourceDirs);\n        return createUnitsForFiles(project, specificSources);\n    }\n", "    public static List<? extends PsiFile> createUnitsInDirectories(\n            @NonNull Project project, @NonNull List<File> sourceDirs) {\n        List<File> specificSources = gatherSources(sourceDirs);\n        return createUnitsForFiles(project, specificSources);\n    }\n\n    public static void addJavaSources(@NonNull List<File> list, @NonNull File file) {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    addJavaSources(list, child);\n                }\n            }\n        } else {", "            if (files != null) {\n                for (File child : files) {\n                    addJavaSources(list, child);\n                }\n            }\n        } else {\n            if (file.isFile()) {\n                String path = file.getPath();\n                if (path.endsWith(DOT_JAVA) || path.endsWith(DOT_KT)) {\n                    list.add(file);\n                }\n            }\n        }\n    }\n", "                if (path.endsWith(DOT_JAVA) || path.endsWith(DOT_KT)) {\n                    list.add(file);\n                }\n            }\n        }\n    }\n\n    public static List<File> gatherSources(List<File> sourcePath) {\n        List<File> sources = new ArrayList<>();\n        for (File file : sourcePath) {\n            addJavaSources(sources, file);\n        }\n        return sources;\n    }\n\n    public Extractor(\n            @Nullable ApiDatabase apiFilter,\n            @Nullable Collection<File> classDir,\n            boolean displayInfo,\n            boolean includeClassRetentionAnnotations,\n            boolean sortAnnotations) {\n        this.apiFilter = apiFilter;\n        this.listIgnored = apiFilter != null;\n        this.classDir = classDir;\n        this.displayInfo = displayInfo;\n        this.includeClassRetentionAnnotations = includeClassRetentionAnnotations;\n        this.sortAnnotations = sortAnnotations;\n    }\n", "        for (File file : sourcePath) {\n            addJavaSources(sources, file);\n        }\n        return sources;\n    }\n\n    public Extractor(\n            @Nullable ApiDatabase apiFilter,\n            @Nullable Collection<File> classDir,\n            boolean displayInfo,\n            boolean includeClassRetentionAnnotations,\n            boolean sortAnnotations) {\n        this.apiFilter = apiFilter;\n        this.listIgnored = apiFilter != null;\n        this.classDir = classDir;\n        this.displayInfo = displayInfo;\n        this.includeClassRetentionAnnotations = includeClassRetentionAnnotations;\n        this.sortAnnotations = sortAnnotations;\n    }\n", "    public void extractFromProjectSource(List<? extends PsiFile> units) {\n        if (units.isEmpty()) {\n            return;\n        }\n\n        Project project = units.get(0).getProject();\n        AnnotationVisitor visitor = new AnnotationVisitor(false, true);\n\n        for (PsiFile unit : units) {\n            UElement uFile = UastFacade.INSTANCE.convertElementWithParent(unit, UFile.class);\n            if (uFile == null) {\n                System.out.println(\"Warning: Could not convert \" + unit.getName() + \" with UAST\");\n                continue;\n            }\n            uFile.accept(visitor);\n        }\n\n        typedefsToRemove = visitor.getPrivateTypedefClasses();\n    }\n", "        for (PsiFile unit : units) {\n            UElement uFile = UastFacade.INSTANCE.convertElementWithParent(unit, UFile.class);\n            if (uFile == null) {\n                System.out.println(\"Warning: Could not convert \" + unit.getName() + \" with UAST\");\n                continue;\n            }\n            uFile.accept(visitor);\n        }\n\n        typedefsToRemove = visitor.getPrivateTypedefClasses();\n    }\n", "    public void removeTypedefClasses() {\n        if (classDir != null\n                && !classDir.isEmpty()\n                && typedefsToRemove != null\n                && !typedefsToRemove.isEmpty()) {\n            // Perform immediately\n            boolean quiet = false;\n            boolean verbose = false;\n            boolean dryRun = false;\n            //noinspection ConstantConditions\n            TypedefRemover remover = new TypedefRemover(quiet, verbose, dryRun);\n            remover.remove(classDir, typedefsToRemove);\n        }\n    }\n", "    public void writeTypedefFile(@NonNull File file) throws IOException {\n        // Write typedef recipe file for later processing\n        String desc = \"\";\n        if (typedefsToRemove != null) {\n            Collections.sort(typedefsToRemove);\n            StringBuilder sb = new StringBuilder(typedefsToRemove.size() * 100);\n            for (String cls : typedefsToRemove) {\n                sb.append(\"D \");\n                sb.append(cls);\n                sb.append(\"\\n\");\n            }\n            desc = sb.toString();\n        }\n        FileUtils.deleteIfExists(file);\n        Files.createParentDirs(file);\n        FilesKt.writeText(file, desc, Charsets.UTF_8);\n    }\n", "    public static void removeTypedefClasses(\n            @NonNull Collection<File> classDirs, @NonNull File typedefFile) {\n        // Perform immediately\n        boolean quiet = false;\n        boolean verbose = false;\n        boolean dryRun = false;\n        //noinspection ConstantConditions\n        TypedefRemover remover = new TypedefRemover(quiet, verbose, dryRun);\n        remover.removeFromTypedefFile(classDirs, typedefFile);\n    }\n", "    public void export(@Nullable File annotationsZip, @Nullable File proguardCfg)\n            throws IOException {\n        if (proguardCfg != null) {\n            if (keepItems.isEmpty()) {\n                if (proguardCfg.exists()) {\n                    //noinspection ResultOfMethodCallIgnored\n                    proguardCfg.delete();\n                }\n            } else if (writeKeepRules(proguardCfg)) {\n                info(\"ProGuard keep rules written to \" + proguardCfg);\n            }\n        }\n", "            } else if (writeKeepRules(proguardCfg)) {\n                info(\"ProGuard keep rules written to \" + proguardCfg);\n            }\n        }\n\n        if (annotationsZip != null) {\n            if (itemMap.isEmpty() && packageMap == null) {\n                FileUtils.deleteIfExists(annotationsZip);\n            } else {\n                writeExternalAnnotations(annotationsZip);\n                writeStats();\n                info(\"Annotations written to \" + annotationsZip);\n            }\n        }\n    }\n", "    public void writeStats() {\n        if (!displayInfo) {\n            return;\n        }\n\n        if (!stats.isEmpty()) {\n            List<String> annotations = new ArrayList<>(stats.keySet());\n            annotations.sort(\n                    (s1, s2) -> {\n                        int frequency1 = stats.get(s1);\n                        int frequency2 = stats.get(s2);\n                        int delta = frequency2 - frequency1;", "                        if (delta != 0) {\n                            return delta;\n                        }\n                        return s1.compareTo(s2);\n                    });\n            Map<String, String> fqnToName = new HashMap<>();\n            int max = 0;\n            int count = 0;\n            for (String fqn : annotations) {\n                String name = fqn.substring(fqn.lastIndexOf('.') + 1);\n                fqnToName.put(fqn, name);\n                max = Math.max(max, name.length());\n                count += stats.get(fqn);\n            }\n\n            StringBuilder sb = new StringBuilder(200);\n            sb.append(\"Extracted \").append(count).append(\" Annotations:\");", "            for (String fqn : annotations) {\n                String name = fqn.substring(fqn.lastIndexOf('.') + 1);\n                fqnToName.put(fqn, name);\n                max = Math.max(max, name.length());\n                count += stats.get(fqn);\n            }\n\n            StringBuilder sb = new StringBuilder(200);\n            sb.append(\"Extracted \").append(count).append(\" Annotations:\");\n            for (String fqn : annotations) {\n                sb.append('\\n');\n                String name = fqnToName.get(fqn);", "            for (String fqn : annotations) {\n                sb.append('\\n');\n                String name = fqnToName.get(fqn);\n                for (int i = 0, n = max - name.length() + 1; i < n; i++) {\n                    sb.append(' ');\n                }\n                sb.append('@');\n                sb.append(name);\n                sb.append(':').append(' ');\n                sb.append(Integer.toString(stats.get(fqn)));\n            }", "            if (sb.length() > 0) {\n                info(sb.toString());\n            }\n        }\n\n        if (filteredCount > 0) {\n            info(filteredCount + \" of these were filtered out (not in API database file)\");\n        }\n        if (mergedCount > 0) {\n            info(mergedCount + \" additional annotations were merged in\");\n        }\n    }\n\n    @SuppressWarnings(\"UseOfSystemOutOrSystemErr\")\n    void info(final String message) {", "        if (mergedCount > 0) {\n            info(mergedCount + \" additional annotations were merged in\");\n        }\n    }\n\n    @SuppressWarnings(\"UseOfSystemOutOrSystemErr\")\n    void info(final String message) {\n        if (displayInfo) {\n            System.out.println(message);\n        }\n    }\n\n    @SuppressWarnings(\"UseOfSystemOutOrSystemErr\")\n    static void error(String message) {\n        System.err.println(\"Error: \" + message);\n    }\n\n    @SuppressWarnings(\"UseOfSystemOutOrSystemErr\")\n    static void warning(String message) {\n        System.out.println(\"Warning: \" + message);\n    }\n\n    @Nullable\n    private static String getFqn(@NonNull UAnnotation annotation) {\n        return annotation.getQualifiedName();\n    }\n\n    private PsiClass lastClass; // Cache for getFqn(PsiClass)\n    private String lastFqn; // Cache for getFqn(PsiClass)\n\n    @Nullable\n    private String getFqn(@Nullable PsiClass cls) {", "        if (cls != null) {\n            if (cls.equals(lastClass)) {\n                return lastFqn;\n            }\n            lastClass = cls;\n            lastFqn = cls.getQualifiedName();\n            return lastFqn;\n        }\n\n        return null;\n    }\n\n    private boolean hasSourceRetention(@NonNull String fqn, @Nullable UAnnotation annotation) {", "        if (sourceRetention == null) {\n            sourceRetention = Maps.newHashMapWithExpectedSize(20);\n            // The @IntDef and @String annotations have always had source retention,\n            // and always must (because we can't express fully qualified field references\n            // in a .class file.)\n            sourceRetention.put(INT_DEF_ANNOTATION.oldName(), true);\n            sourceRetention.put(INT_DEF_ANNOTATION.newName(), true);\n            sourceRetention.put(STRING_DEF_ANNOTATION.oldName(), true);\n            sourceRetention.put(STRING_DEF_ANNOTATION.newName(), true);\n            sourceRetention.put(LONG_DEF_ANNOTATION.oldName(), true);\n            sourceRetention.put(LONG_DEF_ANNOTATION.newName(), true);\n            // The @Nullable and @NonNull annotations have always had class retention\n            sourceRetention.put(SUPPORT_NOTNULL, false);\n            sourceRetention.put(SUPPORT_NULLABLE, false);\n            sourceRetention.put(ANDROID_NOTNULL, false);\n            sourceRetention.put(ANDROID_NULLABLE, false);\n            sourceRetention.put(ANDROIDX_NOTNULL, false);\n            sourceRetention.put(ANDROIDX_NULLABLE, false);\n        }\n\n        Boolean source = sourceRetention.get(fqn);\n", "        if (source != null) {\n            return source;\n        }\n\n        if (annotation == null) {\n            return false;\n        }\n\n        boolean hasSourceRetention = false;\n        PsiClass annotationClass = annotation.resolve();\n        if (annotationClass != null) {\n            hasSourceRetention = hasSourceRetention(annotationClass);\n        }\n        sourceRetention.put(fqn, hasSourceRetention);\n\n        return hasSourceRetention;\n    }\n\n    static boolean hasSourceRetention(@NonNull UAnnotation annotation) {\n        String qualifiedName = annotation.getQualifiedName();", "        if (annotationClass != null) {\n            hasSourceRetention = hasSourceRetention(annotationClass);\n        }\n        sourceRetention.put(fqn, hasSourceRetention);\n\n        return hasSourceRetention;\n    }\n\n    static boolean hasSourceRetention(@NonNull UAnnotation annotation) {\n        String qualifiedName = annotation.getQualifiedName();\n        if (\"java.lang.annotation.Retention\".equals(qualifiedName)\n                || \"kotlin.annotation.Retention\".equals(qualifiedName)) {\n            List<UNamedExpression> attributes = annotation.getAttributeValues();", "        if (\"java.lang.annotation.Retention\".equals(qualifiedName)\n                || \"kotlin.annotation.Retention\".equals(qualifiedName)) {\n            List<UNamedExpression> attributes = annotation.getAttributeValues();\n            if (attributes.size() != 1) {\n                error(\"Expected exactly one parameter passed to @Retention\");\n                return false;\n            }\n            UExpression value = attributes.get(0).getExpression();\n            if (value instanceof UReferenceExpression) {\n                UReferenceExpression expression = (UReferenceExpression) value;\n                try {\n                    PsiElement element = expression.resolve();", "            if (value instanceof UReferenceExpression) {\n                UReferenceExpression expression = (UReferenceExpression) value;\n                try {\n                    PsiElement element = expression.resolve();\n                    if (element instanceof PsiField) {\n                        PsiField field = (PsiField) element;\n                        if (\"SOURCE\".equals(field.getName())) {\n                            return true;\n                        }\n                    }\n                } catch (Throwable t) {\n                    String s = expression.asSourceString();\n                    return s.contains(\"SOURCE\");\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static boolean hasSourceRetention(PsiClass cls) {\n        PsiModifierList modifierList = cls.getModifierList();", "        if (modifierList != null) {\n            for (PsiAnnotation psiAnnotation : modifierList.getAnnotations()) {\n                UAnnotation annotation = JavaUAnnotation.wrap(psiAnnotation);\n                if (hasSourceRetention(annotation)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void addAnnotations(@Nullable UAnnotated annotated, @NonNull Item item) {", "        if (annotated != null) {\n            for (UAnnotation annotation : annotated.getAnnotations()) {\n                if (isRelevantAnnotation(annotation)) {\n                    String fqn = getFqn(annotation);\n                    if (SUPPORT_KEEP.equals(fqn)) {\n                        // Put keep rules in a different place; we don't want to write\n                        // these out into the external annotations database, they go\n                        // into a special proguard file\n                        keepItems.add(item);\n                    } else {\n                        addAnnotation(annotation, fqn, item.annotations);\n                    }\n                }\n            }\n        }\n    }\n\n    private void addAnnotation(\n            @NonNull UAnnotation annotation,\n            @Nullable String fqn,\n            @NonNull List<AnnotationData> list) {", "        if (fqn == null) {\n            return;\n        }\n\n        if (fqn.equals(ANDROID_NULLABLE) || fqn.equals(SUPPORT_NULLABLE)) {\n            recordStats(fqn);\n            list.add(new AnnotationData(SUPPORT_NULLABLE));\n            return;\n        }\n\n        if (fqn.equals(ANDROID_NOTNULL) || fqn.equals(SUPPORT_NOTNULL)) {\n            recordStats(fqn);\n            list.add(new AnnotationData(SUPPORT_NOTNULL));\n            return;\n        }\n", "        if (fqn.equals(ANDROID_NOTNULL) || fqn.equals(SUPPORT_NOTNULL)) {\n            recordStats(fqn);\n            list.add(new AnnotationData(SUPPORT_NOTNULL));\n            return;\n        }\n\n        if (SUPPORT_ANNOTATIONS_PREFIX.isPrefix(fqn)\n                && fqn.endsWith(RESOURCE_TYPE_ANNOTATIONS_SUFFIX)) {\n            recordStats(fqn);\n            list.add(new AnnotationData(fqn));\n            return;\n        }\n", "        if (fqn.startsWith(ANDROID_ANNOTATIONS_PREFIX)) {\n            // System annotations: translate to support library annotations\n            if (fqn.endsWith(RESOURCE_TYPE_ANNOTATIONS_SUFFIX)) {\n                // Translate e.g. android.annotation.DrawableRes to\n                //    android.support.annotation.DrawableRes\n                String resAnnotation =\n                        SUPPORT_ANNOTATIONS_PREFIX.defaultName()\n                                + fqn.substring(ANDROID_ANNOTATIONS_PREFIX.length());\n                if (!includeClassRetentionAnnotations && !hasSourceRetention(resAnnotation, null)) {\n                    return;\n                }\n                recordStats(resAnnotation);\n                list.add(new AnnotationData(resAnnotation));\n                return;", "                if (!includeClassRetentionAnnotations && !hasSourceRetention(resAnnotation, null)) {\n                    return;\n                }\n                recordStats(resAnnotation);\n                list.add(new AnnotationData(resAnnotation));\n                return;\n            } else if (isRelevantFrameworkAnnotation(fqn)) {\n                // Translate other android.annotation annotations into corresponding\n                // support annotations\n                String supportAnnotation =\n                        SUPPORT_ANNOTATIONS_PREFIX.defaultName()\n                                + fqn.substring(ANDROID_ANNOTATIONS_PREFIX.length());", "                if (!includeClassRetentionAnnotations\n                        && !hasSourceRetention(supportAnnotation, null)) {\n                    return;\n                }\n                recordStats(supportAnnotation);\n                list.add(createData(supportAnnotation, annotation));\n            }\n        }\n\n        if (SUPPORT_ANNOTATIONS_PREFIX.isPrefix(fqn)) {\n            recordStats(fqn);\n            list.add(createData(fqn, annotation));\n            return;\n        }\n", "        if (SUPPORT_ANNOTATIONS_PREFIX.isPrefix(fqn)) {\n            recordStats(fqn);\n            list.add(createData(fqn, annotation));\n            return;\n        }\n\n        if (isMagicConstant(annotation, fqn)) {\n            List<AnnotationData> indirect = types.get(fqn);\n            if (indirect != null) {\n                list.addAll(indirect);\n            }\n        }\n    }\n\n    private void recordStats(String fqn) {\n        Integer count = stats.get(fqn);", "            if (indirect != null) {\n                list.addAll(indirect);\n            }\n        }\n    }\n\n    private void recordStats(String fqn) {\n        Integer count = stats.get(fqn);\n        if (count == null) {\n            count = 0;\n        }\n        stats.put(fqn, count + 1);\n    }\n\n    private boolean hasRelevantAnnotations(@Nullable UAnnotated annotated) {", "        if (count == null) {\n            count = 0;\n        }\n        stats.put(fqn, count + 1);\n    }\n\n    private boolean hasRelevantAnnotations(@Nullable UAnnotated annotated) {\n        if (annotated != null) {\n            for (UAnnotation annotation : annotated.getAnnotations()) {\n                if (isRelevantAnnotation(annotation)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isRelevantAnnotation(@NonNull UAnnotation annotation) {\n        String fqn = getFqn(annotation);", "            for (UAnnotation annotation : annotated.getAnnotations()) {\n                if (isRelevantAnnotation(annotation)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isRelevantAnnotation(@NonNull UAnnotation annotation) {\n        String fqn = getFqn(annotation);", "        if (fqn == null || fqn.startsWith(\"java.lang.\")) {\n            return false;\n        }\n        if (SUPPORT_ANNOTATIONS_PREFIX.isPrefix(fqn)) {\n            if (fqn.equals(SUPPORT_KEEP)) {\n                return true; // even with class file retention we want to process these\n            }\n\n            //noinspection PointlessBooleanExpression,ConstantConditions,RedundantIfStatement\n            if (!includeClassRetentionAnnotations && !hasSourceRetention(fqn, annotation)) {\n                return false;\n            }\n\n            return true;", "            if (!includeClassRetentionAnnotations && !hasSourceRetention(fqn, annotation)) {\n                return false;\n            }\n\n            return true;\n        } else if (fqn.startsWith(ANDROID_ANNOTATIONS_PREFIX)) {\n            return isRelevantFrameworkAnnotation(fqn);\n        }\n        if (fqn.equals(ANDROID_NULLABLE)\n                || fqn.equals(ANDROID_NOTNULL)\n                || isMagicConstant(annotation, fqn)) {\n            return true;", "        if (fqn.equals(ANDROID_NULLABLE)\n                || fqn.equals(ANDROID_NOTNULL)\n                || isMagicConstant(annotation, fqn)) {\n            return true;\n        } else if (fqn.equals(IDEA_CONTRACT)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private static boolean isRelevantFrameworkAnnotation(@NonNull String fqn) {\n        return fqn.startsWith(ANDROID_ANNOTATIONS_PREFIX)\n                && !fqn.endsWith(\".Widget\")\n                && !fqn.endsWith(\".TargetApi\")\n                && !fqn.endsWith(\".SystemApi\")\n                && !fqn.endsWith(\".TestApi\")\n                && !fqn.endsWith(\".SuppressAutoDoc\")\n                && !fqn.endsWith(\".SuppressLint\")\n                && !fqn.endsWith(\".SdkConstant\");\n    }\n\n    boolean isMagicConstant(@NonNull UAnnotation annotation, @NonNull String typeName) {", "        if (irrelevantAnnotations.contains(typeName)\n                || typeName.startsWith(\"java.lang.\")) { // @Override, @SuppressWarnings, etc.\n            return false;\n        }\n        if (types.containsKey(typeName)) {\n            return true;\n        }\n        if (MAGIC_CONSTANT_ANNOTATIONS.contains(typeName)) {\n            return true;\n        }\n\n        // See if this annotation is itself annotated.\n        // We only support a single level of IntDef type annotations, not arbitrary nesting\n        PsiClass resolved = annotation.resolve();", "        if (resolved != null) {\n            PsiModifierList modifierList = resolved.getModifierList();\n            if (modifierList != null) {\n                boolean match = false;\n                for (PsiAnnotation pa : modifierList.getAnnotations()) {\n                    String fqn = pa.getQualifiedName();\n                    if (isNestedAnnotation(fqn)) {\n                        UAnnotation a = annotationLookup.findRealAnnotation(pa, resolved, null);\n                        List<AnnotationData> list =\n                                types.computeIfAbsent(typeName, k -> new ArrayList<>(2));\n                        addAnnotation(a, fqn, list);\n                        match = true; // can't break yet: there could be multiple, e.g.\n                        // both intdef and intrange\n                    }\n                }", "                if (match) {\n                    return true;\n                }\n            }\n        }\n\n        irrelevantAnnotations.add(typeName);\n\n        return false;\n    }\n\n    private AnnotationLookup annotationLookup = new AnnotationLookup();\n\n    static boolean isNestedAnnotation(@Nullable String fqn) {\n        return (fqn != null\n                && (INT_DEF_ANNOTATION.isEquals(fqn)\n                || LONG_DEF_ANNOTATION.isEquals(fqn)\n                || STRING_DEF_ANNOTATION.isEquals(fqn)\n                || REQUIRES_PERMISSION.isEquals(fqn)\n                || fqn.equals(ANDROID_REQUIRES_PERMISSION)\n                || INT_RANGE_ANNOTATION.isEquals(fqn)\n                || fqn.equals(ANDROID_INT_RANGE)\n                || fqn.equals(ANDROID_INT_DEF)\n                || fqn.equals(ANDROID_LONG_DEF)\n                || fqn.equals(ANDROID_STRING_DEF)));\n    }\n\n    private boolean writeKeepRules(@NonNull File proguardCfg) {", "        if (!keepItems.isEmpty()) {\n            try {\n                try (Writer writer = new BufferedWriter(new FileWriter(proguardCfg))) {\n                    Collections.sort(keepItems);\n                    for (Item item : keepItems) {\n                        writer.write(item.getKeepRule());\n                        writer.write('\\n');\n                    }\n                }\n            } catch (IOException ioe) {\n                error(ioe.toString());\n                return true;\n            }\n\n            // Now that we've handled these items, remove them from the list\n            // such that we don't accidentally also emit them into the annotations.zip\n            // file, where they are not needed", "            for (Item item : keepItems) {\n                removeItem(item.getQualifiedClassName(), item);\n            }\n        } else if (proguardCfg.exists()) {\n            //noinspection ResultOfMethodCallIgnored\n            proguardCfg.delete();\n        }\n        return false;\n    }\n\n    private void writeExternalAnnotations(@NonNull File annotationsZip) throws IOException {\n        try (FileOutputStream fileOutputStream = new FileOutputStream(annotationsZip);\n             JarOutputStream zos =\n                     new JarOutputStream(new BufferedOutputStream(fileOutputStream))) {\n            List<String> sortedPackages = new ArrayList<>(itemMap.keySet());\n", "            if (packageMap != null) {\n                for (String pkg : packageMap.keySet()) {\n                    if (!itemMap.containsKey(pkg)) {\n                        sortedPackages.add(pkg);\n                    }\n                }\n            }\n\n            Collections.sort(sortedPackages);\n            for (String pkg : sortedPackages) {\n                // Note: Using / rather than File.separator: jar lib requires it\n                String name = pkg.replace('.', '/') + \"/annotations.xml\";\n\n                JarEntry outEntry = new JarEntry(name);\n                outEntry.setTime(0);\n                zos.putNextEntry(outEntry);\n\n                try (StringPrintWriter writer = StringPrintWriter.create()) {\n                    writer.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<root>\");\n\n                    Map<String, List<Item>> classMap = itemMap.get(pkg);\n", "            for (String pkg : sortedPackages) {\n                // Note: Using / rather than File.separator: jar lib requires it\n                String name = pkg.replace('.', '/') + \"/annotations.xml\";\n\n                JarEntry outEntry = new JarEntry(name);\n                outEntry.setTime(0);\n                zos.putNextEntry(outEntry);\n\n                try (StringPrintWriter writer = StringPrintWriter.create()) {\n                    writer.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<root>\");\n\n                    Map<String, List<Item>> classMap = itemMap.get(pkg);\n", "                    if (classMap == null) {\n                        // package only contains package-info.java annotations\n                        classMap = Collections.emptyMap();\n                    }\n\n                    // Export package items first\n                    if (packageMap != null) {\n                        PackageItem item = packageMap.get(pkg);\n                        if (item != null) {\n                            item.write(writer);\n                        }\n                    }\n\n                    List<String> classes = new ArrayList<>(classMap.keySet());\n                    Collections.sort(classes);", "                        if (item != null) {\n                            item.write(writer);\n                        }\n                    }\n\n                    List<String> classes = new ArrayList<>(classMap.keySet());\n                    Collections.sort(classes);\n                    for (String cls : classes) {\n                        List<Item> items = classMap.get(cls);\n                        Collections.sort(items);\n                        for (Item item : items) {\n                            item.write(writer);\n                        }\n                    }\n\n                    writer.println(\"</root>\\n\");\n                    writer.close();\n                    String xml = writer.getContents();\n\n                    // Validate", "                        for (Item item : items) {\n                            item.write(writer);\n                        }\n                    }\n\n                    writer.println(\"</root>\\n\");\n                    writer.close();\n                    String xml = writer.getContents();\n\n                    // Validate\n                    if (assertionsEnabled()) {\n                        Document document = checkDocument(pkg, xml, false);", "                    if (assertionsEnabled()) {\n                        Document document = checkDocument(pkg, xml, false);\n                        if (document == null) {\n                            error(\n                                    \"Could not parse XML document back in for entry \"\n                                            + name\n                                            + \": invalid XML?\\n\\\"\\\"\\\"\\n\"\n                                            + xml\n                                            + \"\\n\\\"\\\"\\\"\\n\");\n                        }\n                    }\n                    byte[] bytes = xml.getBytes(Charsets.UTF_8);\n                    zos.write(bytes);\n                    zos.closeEntry();\n                }\n            }\n        }\n    }\n\n    private void addPackage(@NonNull String pkg, @NonNull PackageItem item) {\n        // Not part of the API?", "        if (apiFilter != null && item.isFiltered(apiFilter)) {\n            if (isListIgnored()) {\n                info(\"Skipping API because it is not part of the API file: \" + item);\n            }\n\n            filteredCount++;\n            return;\n        }\n\n        if (packageMap == null) {\n            packageMap = new HashMap<>();\n        }\n\n        packageMap.put(pkg, item);\n    }\n\n    private void addItem(@NonNull String fqn, @NonNull Item item) {\n        // Not part of the API?", "        if (packageMap == null) {\n            packageMap = new HashMap<>();\n        }\n\n        packageMap.put(pkg, item);\n    }\n\n    private void addItem(@NonNull String fqn, @NonNull Item item) {\n        // Not part of the API?\n        if (apiFilter != null && item.isFiltered(apiFilter)) {\n            if (isListIgnored()) {\n                info(\"Skipping API because it is not part of the API file: \" + item);\n            }\n\n            filteredCount++;\n            return;\n        }\n\n        addItemUnconditionally(fqn, item);\n    }\n\n    private void addItemUnconditionally(@NonNull String fqn, @NonNull Item item) {\n        String pkg = getPackage(fqn);\n        Map<String, List<Item>> classMap = itemMap.get(pkg);", "        if (apiFilter != null && item.isFiltered(apiFilter)) {\n            if (isListIgnored()) {\n                info(\"Skipping API because it is not part of the API file: \" + item);\n            }\n\n            filteredCount++;\n            return;\n        }\n\n        addItemUnconditionally(fqn, item);\n    }\n\n    private void addItemUnconditionally(@NonNull String fqn, @NonNull Item item) {\n        String pkg = getPackage(fqn);\n        Map<String, List<Item>> classMap = itemMap.get(pkg);", "        if (classMap == null) {\n            classMap = Maps.newHashMapWithExpectedSize(100);\n            itemMap.put(pkg, classMap);\n        }\n        List<Item> items = classMap.get(fqn);\n        if (items == null) {\n            items = new ArrayList<>();\n            classMap.put(fqn, items);\n        }\n\n        items.add(item);\n    }\n\n    private void removeItem(@NonNull String classFqn, @NonNull Item item) {\n        String pkg = getPackage(classFqn);\n        Map<String, List<Item>> classMap = itemMap.get(pkg);", "        if (classMap != null) {\n            List<Item> items = classMap.get(classFqn);\n            if (items != null) {\n                items.remove(item);\n                if (items.isEmpty()) {\n                    classMap.remove(classFqn);\n                    if (classMap.isEmpty()) {\n                        itemMap.remove(pkg);\n                    }\n                }\n            }\n        }\n    }\n\n    @Nullable\n    private Item findItem(@NonNull String fqn, @NonNull Item item) {\n        String pkg = getPackage(fqn);\n        Map<String, List<Item>> classMap = itemMap.get(pkg);", "        if (classMap == null) {\n            return null;\n        }\n        List<Item> items = classMap.get(fqn);\n        if (items == null) {\n            return null;\n        }\n        for (Item existing : items) {\n            if (existing.equals(item)) {\n                return existing;\n            }\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private static Document checkDocument(\n            @NonNull String pkg, @NonNull String xml, boolean namespaceAware) {", "            if (existing.equals(item)) {\n                return existing;\n            }\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private static Document checkDocument(\n            @NonNull String pkg, @NonNull String xml, boolean namespaceAware) {", "        try {\n            return XmlUtils.parseDocument(xml, namespaceAware);\n        } catch (SAXException sax) {\n            warning(\"Failed to parse document for package \" + pkg + \": \" + sax.toString());\n        } catch (Exception e) {\n            // pass\n            // This method is deliberately silent; will return null\n        }\n\n        return null;\n    }\n", "    public void mergeExisting(@NonNull File file) {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    mergeExisting(child);\n                }\n            }\n        } else if (file.isFile()) {\n            if (file.getPath().endsWith(DOT_JAR) || file.getPath().endsWith(DOT_ZIP)) {\n                mergeFromJar(file);", "        } else if (file.isFile()) {\n            if (file.getPath().endsWith(DOT_JAR) || file.getPath().endsWith(DOT_ZIP)) {\n                mergeFromJar(file);\n            } else if (file.getPath().endsWith(DOT_XML)) {\n                try {\n                    String xml = FilesKt.readText(file, Charsets.UTF_8);\n                    mergeAnnotationsXml(file.getPath(), xml);\n                } catch (Exception e) {\n                    error(\"Aborting: I/O problem during transform: \" + e.toString());\n                }\n            }\n        }\n    }\n\n    private void mergeFromJar(@NonNull File jar) {\n        // Reads in an existing annotations jar and merges in entries found there\n        // with the annotations analyzed from source.\n        JarInputStream zis = null;", "        try {\n            @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n            FileInputStream fis = new FileInputStream(jar);\n            zis = new JarInputStream(fis);\n            ZipEntry entry = zis.getNextEntry();\n            while (entry != null) {\n                if (entry.getName().endsWith(\".xml\")) {\n                    byte[] bytes = ByteStreams.toByteArray(zis);\n                    String xml = new String(bytes, Charsets.UTF_8);\n                    mergeAnnotationsXml(jar.getPath() + \": \" + entry, xml);\n                }\n                entry = zis.getNextEntry();\n            }\n        } catch (IOException e) {\n            error(\"Aborting: I/O problem during transform: \" + e.toString());\n        } finally {\n            //noinspection deprecation", "            try {\n                Closeables.close(zis, true /* swallowIOException */);\n            } catch (IOException e) {\n                // cannot happen\n            }\n        }\n    }\n\n    private void mergeAnnotationsXml(@NonNull String path, @NonNull String xml) {\n        try {\n            Document document = XmlUtils.parseDocument(xml, false);\n            mergeDocument(document);\n        } catch (Exception e) {\n            String message = \"Failed to merge \" + path + \": \" + e.toString();", "        try {\n            Document document = XmlUtils.parseDocument(xml, false);\n            mergeDocument(document);\n        } catch (Exception e) {\n            String message = \"Failed to merge \" + path + \": \" + e.toString();\n            if (e instanceof SAXParseException) {\n                SAXParseException spe = (SAXParseException) e;\n                message =\n                        \"Line \"\n                                + spe.getLineNumber()\n                                + \":\"\n                                + spe.getColumnNumber()\n                                + \": \"\n                                + message;\n            }\n            error(message);", "            if (!(e instanceof IOException)) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void mergeDocument(@NonNull Document document) {\n        @SuppressWarnings(\"SpellCheckingInspection\") final Pattern XML_SIGNATURE =\n                Pattern.compile(\n                        // Class (FieldName | Type? Name(ArgList) Argnum?)\n                        //\"(\\\\S+) (\\\\S+|(.*)\\\\s+(\\\\S+)\\\\((.*)\\\\)( \\\\d+)?)\");\n                        \"(\\\\S+) (\\\\S+|((.*)\\\\s+)?(\\\\S+)\\\\((.*)\\\\)( \\\\d+)?)\");\n\n        Element root = document.getDocumentElement();\n        String rootTag = root.getTagName();\n        assert rootTag.equals(\"root\") : rootTag;\n", "        for (Element item : getChildren(root)) {\n            String signature = item.getAttribute(ATTR_NAME);\n            if (signature == null || signature.equals(\"null\")) {\n                continue; // malformed item\n            }\n\n            if (!hasRelevantAnnotations(item)) {\n                continue;\n            }\n\n            signature = unescapeXml(signature);", "            if (signature.equals(\"java.util.Calendar int get(int)\")) {\n                // https://youtrack.jetbrains.com/issue/IDEA-137385\n                continue;\n            } else if (signature.equals(\"java.util.Calendar void set(int, int, int) 1\")\n                    || signature.equals(\"java.util.Calendar void set(int, int, int, int, int) 1\")\n                    || signature.equals(\n                    \"java.util.Calendar void set(int, int, int, int, int, int) 1\")) {\n                // http://b.android.com/76090\n                continue;\n            }\n\n            Matcher matcher = XML_SIGNATURE.matcher(signature);", "            if (matcher.matches()) {\n                String containingClass = matcher.group(1);\n                if (containingClass == null) {\n                    warning(\"Could not find class for \" + signature);\n                }\n                String methodName = matcher.group(5);\n                if (methodName != null) {\n                    String type = matcher.group(4);\n                    boolean isConstructor = type == null;\n                    String parameters = matcher.group(6);\n                    mergeMethodOrParameter(\n                            item,\n                            matcher,\n                            containingClass,\n                            methodName,\n                            type,\n                            isConstructor,\n                            parameters);\n                } else {\n                    String fieldName = matcher.group(2);\n                    mergeField(item, containingClass, fieldName);\n                }\n            } else {", "                if (signature.indexOf(' ') != -1 || signature.indexOf('.') == -1) {\n                    warning(\"No merge match for signature \" + signature);\n                } // else: probably just a class signature, e.g. for @NonNls\n            }\n        }\n    }\n\n    @NonNull\n    private static String unescapeXml(@NonNull String escaped) {\n        String workingString = escaped.replace(QUOT_ENTITY, \"\\\"\");\n        workingString = workingString.replace(LT_ENTITY, \"<\");\n        workingString = workingString.replace(GT_ENTITY, \">\");\n        workingString = workingString.replace(APOS_ENTITY, \"'\");\n        workingString = workingString.replace(AMP_ENTITY, \"&\");\n\n        return workingString;\n    }\n\n    @NonNull\n    private static String escapeXml(@NonNull String unescaped) {\n        return XmlEscapers.xmlAttributeEscaper().escape(unescaped);\n    }\n\n    /**\n     * Returns true if this XML entry contains historic metadata, e.g. has an api attribute which\n     * designates that this API may no longer be in the SDK, but the annotations should be preserved\n     * for older API levels\n     */\n    private static boolean hasHistoricData(@NonNull Element item) {\n        Node curr = item.getFirstChild();", "        while (curr != null) {\n            // Example:\n            // <item name=\"android.provider.Browser BOOKMARKS_URI\">\n            //   <annotation name=\"android.support.annotation.RequiresPermission.Read\">\n            //     <val name=\"value\" val=\"&quot;com.android.browser.permission.READ_HISTORY_BOOKMARKS&quot;\" />\n            //     <val name=\"apis\" val=\"&quot;..22&quot;\" />\n            //   </annotation>\n            //   ..\n            if (curr.getNodeType() == Node.ELEMENT_NODE\n                    && \"annotation\".equals(curr.getNodeName())) {\n                Node inner = curr.getFirstChild();", "            if (curr.getNodeType() == Node.ELEMENT_NODE\n                    && \"annotation\".equals(curr.getNodeName())) {\n                Node inner = curr.getFirstChild();\n                while (inner != null) {\n                    if (inner.getNodeType() == Node.ELEMENT_NODE\n                            && \"val\".equals(inner.getNodeName())\n                            && \"apis\".equals(((Element) inner).getAttribute(\"name\"))) {\n                        return true;\n                    }\n                    inner = inner.getNextSibling();\n                }\n            }\n            curr = curr.getNextSibling();\n        }\n\n        return false;\n    }\n\n    private void mergeField(Element item, String containingClass, String fieldName) {", "        if (apiFilter != null\n                && !hasHistoricData(item)\n                && !apiFilter.hasField(containingClass, fieldName)) {\n            if (isListIgnored()) {\n                info(\n                        \"Skipping imported element because it is not part of the API file: \"\n                                + containingClass\n                                + \"#\"\n                                + fieldName);\n            }\n            filteredCount++;\n        } else {\n            FieldItem fieldItem = new FieldItem(null, containingClass, fieldName, null);\n            Item existing = findItem(containingClass, fieldItem);", "            if (existing != null) {\n                mergedCount += mergeAnnotations(item, existing);\n            } else {\n                addItemUnconditionally(containingClass, fieldItem);\n                mergedCount += addAnnotations(item, fieldItem);\n            }\n        }\n    }\n\n    private void mergeMethodOrParameter(\n            Element item,\n            Matcher matcher,\n            String containingClass,\n            String methodName,\n            String type,\n            boolean constructor,\n            String parameters) {\n        parameters = fixParameterString(parameters);\n", "        if (apiFilter != null\n                && !hasHistoricData(item)\n                && !apiFilter.hasMethod(containingClass, methodName, parameters)) {\n            if (isListIgnored()) {\n                info(\n                        \"Skipping imported element because it is not part of the API file: \"\n                                + containingClass\n                                + \"#\"\n                                + methodName\n                                + \"(\"\n                                + parameters\n                                + \")\");\n            }\n            filteredCount++;\n            return;\n        }\n\n        String argNum = matcher.group(7);", "        if (argNum != null) {\n            argNum = argNum.trim();\n            ParameterItem parameterItem =\n                    new ParameterItem(\n                            null,\n                            containingClass,\n                            type,\n                            methodName,\n                            parameters,\n                            constructor,\n                            argNum);\n            Item existing = findItem(containingClass, parameterItem);\n", "            if (\"java.util.Calendar\".equals(containingClass)\n                    && \"set\".equals(methodName)\n                    && Integer.parseInt(argNum) > 0) {\n                // Skip the metadata for Calendar.set(int, int, int+); see\n                // https://code.google.com/p/android/issues/detail?id=73982\n                return;\n            }\n\n            if (existing != null) {\n                mergedCount += mergeAnnotations(item, existing);\n            } else {\n                addItemUnconditionally(containingClass, parameterItem);\n                mergedCount += addAnnotations(item, parameterItem);\n            }\n        } else {\n            MethodItem methodItem =\n                    new MethodItem(\n                            null, containingClass, type, methodName, parameters, constructor);\n            Item existing = findItem(containingClass, methodItem);", "            if (existing != null) {\n                mergedCount += mergeAnnotations(item, existing);\n            } else {\n                addItemUnconditionally(containingClass, parameterItem);\n                mergedCount += addAnnotations(item, parameterItem);\n            }\n        } else {\n            MethodItem methodItem =\n                    new MethodItem(\n                            null, containingClass, type, methodName, parameters, constructor);\n            Item existing = findItem(containingClass, methodItem);", "            if (existing != null) {\n                mergedCount += mergeAnnotations(item, existing);\n            } else {\n                addItemUnconditionally(containingClass, methodItem);\n                mergedCount += addAnnotations(item, methodItem);\n            }\n        }\n    }\n\n    // The parameter declaration used in XML files should not have duplicated spaces,\n    // and there should be no space after commas (we can't however strip out all spaces,\n    // since for example the spaces around the \"extends\" keyword needs to be there in\n    // types like Map<String,? extends Number>\n    private static String fixParameterString(String parameters) {\n        return parameters\n                .replace(\"  \", \" \")\n                .replace(\", \", \",\")\n                .replace(\"?super\", \"? super \")\n                .replace(\"?extends\", \"? extends \");\n    }\n\n    private boolean hasRelevantAnnotations(Element item) {", "        for (Element annotationElement : getChildren(item)) {\n            if (isRelevantAnnotation(annotationElement)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isRelevantAnnotation(Element annotationElement) {\n        AnnotationData annotation = createAnnotation(annotationElement);", "        if (annotation == null) {\n            // Unsupported annotation in import\n            return false;\n        }\n        if (isNullable(annotation.name)\n                || isNonNull(annotation.name)\n                || annotation.name.startsWith(ANDROID_ANNOTATIONS_PREFIX)\n                || SUPPORT_ANNOTATIONS_PREFIX.isPrefix(annotation.name)) {\n            return true;\n        } else if (annotation.name.equals(IDEA_CONTRACT)) {\n            return true;", "        } else if (annotation.name.equals(IDEA_CONTRACT)) {\n            return true;\n        } else if (annotation.name.equals(IDEA_NON_NLS)) {\n            return false;\n        } else {\n            if (!ignoredAnnotations.contains(annotation.name)) {\n                ignoredAnnotations.add(annotation.name);\n                if (isListIgnored()) {\n                    info(\"(Ignoring merge annotation \" + annotation.name + \")\");\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @NonNull\n    private static List<Element> getChildren(@NonNull Element element) {\n        NodeList itemList = element.getChildNodes();\n        int length = itemList.getLength();\n        List<Element> result = new ArrayList<>(Math.max(5, length / 2 + 1));", "        for (int i = 0; i < length; i++) {\n            Node node = itemList.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n\n            result.add((Element) node);\n        }\n\n        return result;\n    }\n\n    private int addAnnotations(Element itemElement, Item item) {\n        int count = 0;", "        for (Element annotationElement : getChildren(itemElement)) {\n            if (!isRelevantAnnotation(annotationElement)) {\n                continue;\n            }\n            AnnotationData annotation = createAnnotation(annotationElement);\n            if (annotation == null) {\n                continue;\n            }\n\n            if (!includeClassRetentionAnnotations && !hasSourceRetention(annotation.name, null)) {\n                continue;\n            }\n\n            item.annotations.add(annotation);\n            count++;\n        }\n        return count;\n    }\n\n    private int mergeAnnotations(Element itemElement, Item item) {\n        int count = 0;\n        loop:", "            if (!includeClassRetentionAnnotations && !hasSourceRetention(annotation.name, null)) {\n                continue;\n            }\n\n            item.annotations.add(annotation);\n            count++;\n        }\n        return count;\n    }\n\n    private int mergeAnnotations(Element itemElement, Item item) {\n        int count = 0;\n        loop:", "        for (Element annotationElement : getChildren(itemElement)) {\n            if (!isRelevantAnnotation(annotationElement)) {\n                continue;\n            }\n            AnnotationData annotation = createAnnotation(annotationElement);\n            if (annotation == null) {\n                continue;\n            }\n\n            if (!includeClassRetentionAnnotations && !hasSourceRetention(annotation.name, null)) {\n                continue;\n            }\n\n            boolean haveNullable = false;\n            boolean haveNotNull = false;", "            if (!includeClassRetentionAnnotations && !hasSourceRetention(annotation.name, null)) {\n                continue;\n            }\n\n            boolean haveNullable = false;\n            boolean haveNotNull = false;\n            for (AnnotationData existing : item.annotations) {\n                if (isNonNull(existing.name)) {\n                    haveNotNull = true;\n                }\n                if (isNullable(existing.name)) {\n                    haveNullable = true;\n                }", "                if (isNullable(existing.name)) {\n                    haveNullable = true;\n                }\n                if (existing.equals(annotation)) {\n                    continue loop;\n                }\n            }\n\n            // Make sure we don't have a conflict between nullable and not nullable\n            if (isNonNull(annotation.name) && haveNullable\n                    || isNullable(annotation.name) && haveNotNull) {\n                warning(\"Found both @Nullable and @NonNull after import for \" + item);\n                continue;\n            }\n\n            item.annotations.add(annotation);\n            count++;\n        }\n\n        return count;\n    }\n\n    private static boolean isNonNull(String name) {\n        return name.equals(IDEA_NOTNULL)\n                || name.equals(ANDROID_NOTNULL)\n                || name.equals(ANDROIDX_NOTNULL)\n                || name.equals(SUPPORT_NOTNULL);\n    }\n\n    private static boolean isNullable(String name) {\n        return name.equals(IDEA_NULLABLE)\n                || name.equals(ANDROID_NULLABLE)\n                || name.equals(ANDROIDX_NULLABLE)\n                || name.equals(SUPPORT_NULLABLE);\n    }\n\n    private AnnotationData createAnnotation(Element annotationElement) {\n        String tagName = annotationElement.getTagName();\n        assert tagName.equals(\"annotation\") : tagName;\n        String name = annotationElement.getAttribute(ATTR_NAME);\n        assert name != null && !name.isEmpty();\n        AnnotationData annotation;", "            if (isNonNull(annotation.name) && haveNullable\n                    || isNullable(annotation.name) && haveNotNull) {\n                warning(\"Found both @Nullable and @NonNull after import for \" + item);\n                continue;\n            }\n\n            item.annotations.add(annotation);\n            count++;\n        }\n\n        return count;\n    }\n\n    private static boolean isNonNull(String name) {\n        return name.equals(IDEA_NOTNULL)\n                || name.equals(ANDROID_NOTNULL)\n                || name.equals(ANDROIDX_NOTNULL)\n                || name.equals(SUPPORT_NOTNULL);\n    }\n\n    private static boolean isNullable(String name) {\n        return name.equals(IDEA_NULLABLE)\n                || name.equals(ANDROID_NULLABLE)\n                || name.equals(ANDROIDX_NULLABLE)\n                || name.equals(SUPPORT_NULLABLE);\n    }\n\n    private AnnotationData createAnnotation(Element annotationElement) {\n        String tagName = annotationElement.getTagName();\n        assert tagName.equals(\"annotation\") : tagName;\n        String name = annotationElement.getAttribute(ATTR_NAME);\n        assert name != null && !name.isEmpty();\n        AnnotationData annotation;", "        if (IDEA_MAGIC.equals(name)) {\n            List<Element> children = getChildren(annotationElement);\n            assert children.size() == 1 : children.size();\n            Element valueElement = children.get(0);\n            String valName = valueElement.getAttribute(ATTR_NAME);\n            String value = valueElement.getAttribute(ATTR_VAL);\n            boolean flagsFromClass = valName.equals(\"flagsFromClass\");\n            boolean flag = valName.equals(\"flags\") || flagsFromClass;\n            if (valName.equals(\"valuesFromClass\") || flagsFromClass) {\n                // Not supported\n                boolean found = false;", "            if (valName.equals(\"valuesFromClass\") || flagsFromClass) {\n                // Not supported\n                boolean found = false;\n                if (value.endsWith(DOT_CLASS)) {\n                    String clsName = value.substring(0, value.length() - DOT_CLASS.length());\n                    StringBuilder sb = new StringBuilder();\n                    sb.append('{');\n\n                    Field[] reflectionFields = null;\n                    try {\n                        Class<?> cls = Class.forName(clsName);\n                        reflectionFields = cls.getDeclaredFields();\n                    } catch (Exception ignore) {\n                        // Class not available: not a problem. We'll rely on API filter.\n                        // It's mainly used for sorting anyway.\n                    }", "                    try {\n                        Class<?> cls = Class.forName(clsName);\n                        reflectionFields = cls.getDeclaredFields();\n                    } catch (Exception ignore) {\n                        // Class not available: not a problem. We'll rely on API filter.\n                        // It's mainly used for sorting anyway.\n                    }\n                    if (apiFilter != null) {\n                        // Search in API database\n                        Set<String> fields = apiFilter.getDeclaredIntFields(clsName);\n                        if (\"java.util.zip.ZipEntry\".equals(clsName)) {\n                            // The metadata says valuesFromClass ZipEntry, and unfortunately\n                            // that class implements ZipConstants and therefore imports a large\n                            // number of irrelevant constants that aren't valid here. Instead,\n                            // only allow these two:\n                            fields = ImmutableSet.of(\"STORED\", \"DEFLATED\");\n                        }\n", "                        if (\"java.util.zip.ZipEntry\".equals(clsName)) {\n                            // The metadata says valuesFromClass ZipEntry, and unfortunately\n                            // that class implements ZipConstants and therefore imports a large\n                            // number of irrelevant constants that aren't valid here. Instead,\n                            // only allow these two:\n                            fields = ImmutableSet.of(\"STORED\", \"DEFLATED\");\n                        }\n\n                        if (fields != null) {\n                            List<String> sorted = new ArrayList<>(fields);\n                            Collections.sort(sorted);", "                        if (fields != null) {\n                            List<String> sorted = new ArrayList<>(fields);\n                            Collections.sort(sorted);\n                            if (reflectionFields != null) {\n                                final Map<String, Integer> rank = new HashMap<>();\n                                for (int i = 0, n = sorted.size(); i < n; i++) {\n                                    rank.put(sorted.get(i), reflectionFields.length + i);\n                                }\n                                for (int i = 0, n = reflectionFields.length; i < n; i++) {\n                                    rank.put(reflectionFields[i].getName(), i);\n                                }\n                                sorted.sort(\n                                        (o1, o2) -> {\n                                            int rank1 = rank.get(o1);\n                                            int rank2 = rank.get(o2);\n                                            int delta = rank1 - rank2;", "                                for (int i = 0, n = reflectionFields.length; i < n; i++) {\n                                    rank.put(reflectionFields[i].getName(), i);\n                                }\n                                sorted.sort(\n                                        (o1, o2) -> {\n                                            int rank1 = rank.get(o1);\n                                            int rank2 = rank.get(o2);\n                                            int delta = rank1 - rank2;\n                                            if (delta != 0) {\n                                                return delta;\n                                            }\n                                            return o1.compareTo(o2);\n                                        });\n                            }\n                            boolean first = true;", "                                            if (delta != 0) {\n                                                return delta;\n                                            }\n                                            return o1.compareTo(o2);\n                                        });\n                            }\n                            boolean first = true;\n                            for (String field : sorted) {\n                                if (first) {\n                                    first = false;\n                                } else {\n                                    sb.append(',').append(' ');\n                                }\n                                sb.append(clsName).append('.').append(field);\n                            }\n                            found = true;\n                        }\n                    }\n                    // Attempt to sort in reflection order", "                                if (first) {\n                                    first = false;\n                                } else {\n                                    sb.append(',').append(' ');\n                                }\n                                sb.append(clsName).append('.').append(field);\n                            }\n                            found = true;\n                        }\n                    }\n                    // Attempt to sort in reflection order", "                    if (!found\n                            && reflectionFields != null\n                            && (apiFilter == null || apiFilter.hasClass(clsName))) {\n                        // Attempt with reflection\n                        boolean first = true;\n                        for (Field field : reflectionFields) {\n                            if (field.getType() == Integer.TYPE || field.getType() == int.class) {\n                                if (first) {\n                                    first = false;\n                                } else {\n                                    sb.append(',').append(' ');\n                                }\n                                sb.append(clsName).append('.').append(field.getName());\n                            }\n                        }\n                    }\n                    sb.append('}');\n                    value = sb.toString();", "                    if (sb.length() > 2) { // 2: { }\n                        found = true;\n                    }\n                }\n\n                if (!found) {\n                    return null;\n                }\n            }\n\n            //noinspection VariableNotUsedInsideIf", "            if (apiFilter != null) {\n                value = removeFiltered(value);\n                while (value.contains(\", ,\")) {\n                    value = value.replace(\", ,\", \",\");\n                }\n                if (value.startsWith(\", \")) {\n                    value = value.substring(2);\n                }\n            }\n\n            annotation =\n                    new AnnotationData(\n                            valName.equals(\"stringValues\")\n                                    ? STRING_DEF_ANNOTATION.defaultName()\n                                    : INT_DEF_ANNOTATION.defaultName(),\n                            new String[]{\n                                    TYPE_DEF_VALUE_ATTRIBUTE,\n                                    value,\n                                    flag ? TYPE_DEF_FLAG_ATTRIBUTE : null,\n                                    flag ? VALUE_TRUE : null\n                            });", "        } else if (STRING_DEF_ANNOTATION.isEquals(name)\n                || ANDROID_STRING_DEF.equals(name)\n                || INT_DEF_ANNOTATION.isEquals(name)\n                || ANDROID_INT_DEF.equals(name)\n                || LONG_DEF_ANNOTATION.isEquals(name)\n                || ANDROID_LONG_DEF.equals(name)) {\n            List<Element> children = getChildren(annotationElement);\n            Element valueElement = children.get(0);\n            String valName = valueElement.getAttribute(ATTR_NAME);\n            assert TYPE_DEF_VALUE_ATTRIBUTE.equals(valName);\n            String value = valueElement.getAttribute(ATTR_VAL);\n            boolean flag = false;", "            if (children.size() == 2) {\n                valueElement = children.get(1);\n                assert TYPE_DEF_FLAG_ATTRIBUTE.equals(valueElement.getAttribute(ATTR_NAME));\n                flag = VALUE_TRUE.equals(valueElement.getAttribute(ATTR_VAL));\n            }\n            boolean intDef = INT_DEF_ANNOTATION.isEquals(name) || ANDROID_INT_DEF.equals(name);\n            boolean longDef = LONG_DEF_ANNOTATION.isEquals(name) || ANDROID_LONG_DEF.equals(name);\n\n            String annotationName;\n            if (intDef) {\n                annotationName =\n                        name.startsWith(ANDROIDX_PKG_PREFIX)\n                                ? INT_DEF_ANNOTATION.oldName()\n                                : INT_DEF_ANNOTATION.oldName();", "            if (intDef) {\n                annotationName =\n                        name.startsWith(ANDROIDX_PKG_PREFIX)\n                                ? INT_DEF_ANNOTATION.oldName()\n                                : INT_DEF_ANNOTATION.oldName();\n            } else if (longDef) {\n                annotationName =\n                        name.startsWith(ANDROIDX_PKG_PREFIX)\n                                ? LONG_DEF_ANNOTATION.oldName()\n                                : LONG_DEF_ANNOTATION.oldName();\n            } else {\n                annotationName =\n                        name.startsWith(ANDROIDX_PKG_PREFIX)\n                                ? STRING_DEF_ANNOTATION.newName()\n                                : STRING_DEF_ANNOTATION.oldName();\n            }\n\n            annotation =\n                    new AnnotationData(\n                            annotationName,\n                            new String[]{\n                                    TYPE_DEF_VALUE_ATTRIBUTE,\n                                    value,\n                                    flag ? TYPE_DEF_FLAG_ATTRIBUTE : null,\n                                    flag ? VALUE_TRUE : null\n                            });", "        } else if (IDEA_CONTRACT.equals(name)) {\n            List<Element> children = getChildren(annotationElement);\n            Element valueElement = children.get(0);\n            String value = valueElement.getAttribute(ATTR_VAL);\n            String pure = valueElement.getAttribute(ATTR_PURE);\n            if (pure != null && !pure.isEmpty()) {\n                annotation =\n                        new AnnotationData(\n                                name,\n                                new String[]{\n                                        TYPE_DEF_VALUE_ATTRIBUTE, value,\n                                        ATTR_PURE, pure\n                                });\n            } else {\n                annotation =\n                        new AnnotationData(name, new String[]{TYPE_DEF_VALUE_ATTRIBUTE, value});\n            }", "        } else if (isNonNull(name)) {\n            annotation = new AnnotationData(SUPPORT_NOTNULL);\n        } else if (isNullable(name)) {\n            //noinspection PointlessBooleanExpression,ConstantConditions\n            if (!INCLUDE_INFERRED_NULLABLE && IDEA_NULLABLE.equals(name)) {\n                return null;\n            }\n            annotation = new AnnotationData(SUPPORT_NULLABLE);\n        } else {\n            List<Element> children = getChildren(annotationElement);\n            if (children.isEmpty()) {\n                return new AnnotationData(name);\n            }\n            List<String> attributeStrings = new ArrayList<>();", "            if (children.isEmpty()) {\n                return new AnnotationData(name);\n            }\n            List<String> attributeStrings = new ArrayList<>();\n            for (Element valueElement : children) {\n                attributeStrings.add(valueElement.getAttribute(ATTR_NAME));\n                attributeStrings.add(valueElement.getAttribute(ATTR_VAL));\n            }\n            annotation = new AnnotationData(name, attributeStrings.toArray(new String[0]));\n        }\n        return annotation;\n    }\n\n    private String removeFiltered(String value) {\n        assert apiFilter != null;", "        if (value.startsWith(\"{\")) {\n            value = value.substring(1);\n        }\n        if (value.endsWith(\"}\")) {\n            value = value.substring(0, value.length() - 1);\n        }\n        value = value.trim();\n        StringBuilder sb = new StringBuilder(value.length());\n        sb.append('{');\n        for (String fqn : Splitter.on(',').omitEmptyStrings().trimResults().split(value)) {\n            fqn = unescapeXml(fqn);", "        for (String fqn : Splitter.on(',').omitEmptyStrings().trimResults().split(value)) {\n            fqn = unescapeXml(fqn);\n            if (fqn.startsWith(\"\\\"\")) {\n                continue;\n            }\n            int index = fqn.lastIndexOf('.');\n            String cls = fqn.substring(0, index);\n            String field = fqn.substring(index + 1);\n            if (apiFilter.hasField(cls, field)) {\n                if (sb.length() > 1) { // 0: '{'\n                    sb.append(\", \");\n                }\n                sb.append(fqn);", "            if (apiFilter.hasField(cls, field)) {\n                if (sb.length() > 1) { // 0: '{'\n                    sb.append(\", \");\n                }\n                sb.append(fqn);\n            } else if (isListIgnored()) {\n                info(\"Skipping constant from typedef because it is not part of the SDK: \" + fqn);\n            }\n        }\n        sb.append('}');\n        return escapeXml(sb.toString());\n    }\n\n    private static String getPackage(String fqn) {\n        // Extract package from the given fqn. Attempts to handle inner classes;\n        // e.g.  \"foo.bar.Foo.Bar will return \"foo.bar\".\n        int index = 0;\n        int last = 0;", "        while (true) {\n            index = fqn.indexOf('.', index);\n            if (index == -1) {\n                break;\n            }\n            last = index;\n            if (index < fqn.length() - 1) {\n                char next = fqn.charAt(index + 1);\n                if (Character.isUpperCase(next)) {\n                    break;\n                }\n            }\n            index++;\n        }\n\n        return fqn.substring(0, last);\n    }\n", "                if (Character.isUpperCase(next)) {\n                    break;\n                }\n            }\n            index++;\n        }\n\n        return fqn.substring(0, last);\n    }\n\n    public void setListIgnored(boolean listIgnored) {\n        this.listIgnored = listIgnored;\n    }\n", "    public void setListIgnored(boolean listIgnored) {\n        this.listIgnored = listIgnored;\n    }\n\n    public boolean isListIgnored() {\n        return listIgnored;\n    }\n\n    public AnnotationData createData(@NonNull String name, @NonNull UAnnotation annotation) {\n        List<UNamedExpression> pairs = annotation.getAttributeValues();\n        if (pairs.isEmpty()) {\n            return new AnnotationData(name);\n        }\n        return new AnnotationData(name, pairs);\n    }\n\n    /**\n     * A writer which stores all its contents into a string and has the ability to mark a certain\n     * freeze point and then reset back to it\n     */\n    private static class StringPrintWriter extends PrintWriter {\n        private final StringWriter stringWriter;\n        private int mark;\n\n        private StringPrintWriter(@NonNull StringWriter stringWriter) {\n            super(stringWriter);\n            this.stringWriter = stringWriter;\n        }\n", "    public AnnotationData createData(@NonNull String name, @NonNull UAnnotation annotation) {\n        List<UNamedExpression> pairs = annotation.getAttributeValues();\n        if (pairs.isEmpty()) {\n            return new AnnotationData(name);\n        }\n        return new AnnotationData(name, pairs);\n    }\n\n    /**\n     * A writer which stores all its contents into a string and has the ability to mark a certain\n     * freeze point and then reset back to it\n     */\n    private static class StringPrintWriter extends PrintWriter {\n        private final StringWriter stringWriter;\n        private int mark;\n\n        private StringPrintWriter(@NonNull StringWriter stringWriter) {\n            super(stringWriter);\n            this.stringWriter = stringWriter;\n        }\n", "        public void mark() {\n            flush();\n            mark = stringWriter.getBuffer().length();\n        }\n\n        public void reset() {\n            stringWriter.getBuffer().setLength(mark);\n        }\n\n        @NonNull\n        public String getContents() {\n            return stringWriter.toString();\n        }\n\n        @Override", "        public String getContents() {\n            return stringWriter.toString();\n        }\n\n        @Override\n        public String toString() {\n            return getContents();\n        }\n\n        public static StringPrintWriter create() {\n            return new StringPrintWriter(new StringWriter(1000));\n        }\n    }\n\n    private class AnnotationData {\n        @NonNull", "        public static StringPrintWriter create() {\n            return new StringPrintWriter(new StringWriter(1000));\n        }\n    }\n\n    private class AnnotationData {\n        @NonNull\n        public final String name;\n\n        @Nullable\n        public String[] attributeStrings;\n\n        @Nullable\n        public List<UNamedExpression> attributes;\n\n        private AnnotationData(@NonNull String name) {\n            this.name = name;\n        }\n\n        private AnnotationData(@NonNull String name, @Nullable List<UNamedExpression> pairs) {\n            this(name);\n            attributes = pairs;\n            assert attributes == null || !attributes.isEmpty();\n        }\n\n        private AnnotationData(@NonNull String name, @Nullable String[] attributeStrings) {\n            this(name);\n            this.attributeStrings = attributeStrings;\n            assert attributeStrings != null && attributeStrings.length > 0;\n        }\n\n        void write(StringPrintWriter writer) {\n            writer.mark();\n            writer.print(\"    <annotation name=\\\"\");\n            writer.print(name);\n", "            if (attributes != null) {\n                writer.print(\"\\\">\");\n                writer.println();\n                //noinspection PointlessBooleanExpression,ConstantConditions\n                if (attributes.size() > 1 && sortAnnotations) {\n                    // Ensure that the value attribute is written first\n                    attributes = new ArrayList<>(attributes); // make list mutable\n                    attributes.sort(\n                            new Comparator<UNamedExpression>() {\n                                private String getName(UNamedExpression pair) {\n                                    String name = pair.getName();", "                                    if (name == null) {\n                                        return ATTR_VALUE;\n                                    } else {\n                                        return name;\n                                    }\n                                }\n\n                                private int rank(UNamedExpression pair) {\n                                    return ATTR_VALUE.equals(getName(pair)) ? -1 : 0;\n                                }\n\n                                @Override", "                                public int compare(UNamedExpression o1, UNamedExpression o2) {\n                                    int r1 = rank(o1);\n                                    int r2 = rank(o2);\n                                    int delta = r1 - r2;\n                                    if (delta != 0) {\n                                        return delta;\n                                    }\n                                    return getName(o1).compareTo(getName(o2));\n                                }\n                            });\n                }\n\n                List<UNamedExpression> attributes = this.attributes;\n", "                if (attributes.size() == 1 && REQUIRES_PERMISSION.isPrefix(name, true)) {\n                    UExpression expression = attributes.get(0).getExpression();\n                    if (expression instanceof UAnnotation) {\n                        // The external annotations format does not allow for nested/complex annotations.\n                        // However, these special annotations (@RequiresPermission.Read,\n                        // @RequiresPermission.Write, etc) are known to only be simple containers with a\n                        // single permission child, so instead we \"inline\" the content:\n                        //  @Read(@RequiresPermission(allOf={P1,P2},conditional=true)\n                        //     =>\n                        //      @RequiresPermission.Read(allOf({P1,P2},conditional=true)\n                        // That's setting attributes that don't actually exist on the container permission,\n                        // but we'll counteract that on the read-annotations side.\n                        UAnnotation annotation = (UAnnotation) expression;\n                        attributes = annotation.getAttributeValues();", "                    } else if (expression instanceof JavaUAnnotationCallExpression) {\n                        JavaUAnnotationCallExpression callExpression =\n                                (JavaUAnnotationCallExpression) expression;\n                        UAnnotation annotation = callExpression.getUAnnotation();\n                        attributes = annotation.getAttributeValues();\n                    } else if (expression instanceof UastEmptyExpression\n                            && attributes.get(0).getPsi() instanceof PsiNameValuePair) {\n                        PsiAnnotationMemberValue memberValue =\n                                ((PsiNameValuePair) attributes.get(0).getPsi()).getValue();\n                        if (memberValue instanceof PsiAnnotation) {\n                            UAnnotation annotation =\n                                    JavaUAnnotation.wrap((PsiAnnotation) memberValue);\n                            attributes = annotation.getAttributeValues();\n                        }\n                    }\n                }\n\n                boolean empty = true;", "                        if (memberValue instanceof PsiAnnotation) {\n                            UAnnotation annotation =\n                                    JavaUAnnotation.wrap((PsiAnnotation) memberValue);\n                            attributes = annotation.getAttributeValues();\n                        }\n                    }\n                }\n\n                boolean empty = true;\n                for (UNamedExpression pair : attributes) {\n                    UExpression expression = pair.getExpression();\n                    String value = attributeString(expression);", "                for (UNamedExpression pair : attributes) {\n                    UExpression expression = pair.getExpression();\n                    String value = attributeString(expression);\n                    if (value == null) {\n                        continue;\n                    }\n                    empty = false;\n                    String name = pair.getName();\n                    if (name == null) {\n                        name = ATTR_VALUE; // default name\n                    }\n\n                    // Platform typedef annotations now declare a prefix attribute for\n                    // documentation generation purposes; this should not be part of the\n                    // extracted metadata.", "                    if (name == null) {\n                        name = ATTR_VALUE; // default name\n                    }\n\n                    // Platform typedef annotations now declare a prefix attribute for\n                    // documentation generation purposes; this should not be part of the\n                    // extracted metadata.\n                    if ((\"prefix\".equals(name) || \"suffix\".equals(name))\n                            && (INT_DEF_ANNOTATION.isEquals(this.name)\n                            || LONG_DEF_ANNOTATION.isEquals(this.name)\n                            || STRING_DEF_ANNOTATION.isEquals(this.name)\n                            || ANDROID_INT_DEF.equals(this.name)\n                            || ANDROID_LONG_DEF.equals(this.name)\n                            || ANDROID_STRING_DEF.equals(this.name))) {\n                        continue;\n                    }\n\n                    writer.print(\"      <val name=\\\"\");\n                    writer.print(name);\n                    writer.print(\"\\\" val=\\\"\");\n                    writer.print(escapeXml(value));\n                    writer.println(\"\\\" />\");\n                }\n", "                if (empty) {\n                    // All items were filtered out: don't write the annotation at all\n                    writer.reset();\n                    return;\n                }\n\n                writer.println(\"    </annotation>\");\n\n            } else if (attributeStrings != null) {\n                writer.print(\"\\\">\");\n                writer.println();", "            } else if (attributeStrings != null) {\n                writer.print(\"\\\">\");\n                writer.println();\n                for (int i = 0; i < attributeStrings.length; i += 2) {\n                    String name = attributeStrings[i];\n                    String value = attributeStrings[i + 1];\n                    if (name == null) {\n                        continue;\n                    }\n                    writer.print(\"      <val name=\\\"\");\n                    writer.print(name);\n                    writer.print(\"\\\" val=\\\"\");\n                    writer.print(escapeXml(value));\n                    writer.println(\"\\\" />\");\n                }\n                writer.println(\"    </annotation>\");\n            } else {\n                writer.println(\"\\\" />\");\n            }\n        }\n\n        @Override", "        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            AnnotationData that = (AnnotationData) o;\n\n            return name.equals(that.name);\n        }\n\n        @Override", "        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Nullable\n        private String attributeString(@Nullable UExpression value) {\n            StringBuilder sb = new StringBuilder();\n            if (value != null && appendExpression(sb, value)) {\n                return sb.toString();\n            } else {\n                return null;\n            }\n        }\n\n        private boolean appendExpression(\n                @NonNull StringBuilder sb, @NonNull UExpression expression) {", "            if (UastExpressionUtils.isArrayInitializer(expression)) {\n                UCallExpression call = (UCallExpression) expression;\n                List<UExpression> initializers = call.getValueArguments();\n                sb.append('{');\n                boolean first = true;\n                int initialLength = sb.length();\n                for (UExpression e : initializers) {\n                    int length = sb.length();\n                    if (first) {\n                        first = false;\n                    } else {\n                        sb.append(\", \");\n                    }\n                    boolean appended = appendExpression(sb, e);", "                    if (first) {\n                        first = false;\n                    } else {\n                        sb.append(\", \");\n                    }\n                    boolean appended = appendExpression(sb, e);\n                    if (!appended) {\n                        // trunk off comma if it bailed for some reason (e.g. constant\n                        // filtered out by API etc)\n                        sb.setLength(length);\n                        if (length == initialLength) {\n                            first = true;\n                        }\n                    }\n                }\n                sb.append('}');", "                        if (length == initialLength) {\n                            first = true;\n                        }\n                    }\n                }\n                sb.append('}');\n                if (sb.length() == 2) {\n                    // All values filtered out\n                    return false;\n                }\n                return true;", "            } else if (expression instanceof UReferenceExpression) {\n                UReferenceExpression referenceExpression = (UReferenceExpression) expression;\n                PsiElement resolved = referenceExpression.resolve();\n                if (resolved instanceof PsiField) {\n                    PsiField field = (PsiField) resolved;\n                    if (!isInlinedConstant()) {\n                        // Inline constants\n                        Object value = field.computeConstantValue();\n                        if (appendLiteralValue(sb, value)) {\n                            return true;\n                        }\n                    }\n\n                    PsiClass declaringClass = field.getContainingClass();", "                        if (appendLiteralValue(sb, value)) {\n                            return true;\n                        }\n                    }\n\n                    PsiClass declaringClass = field.getContainingClass();\n                    if (declaringClass == null) {\n                        error(\"No containing class found for \" + field.getName());\n                        return false;\n                    }\n                    String qualifiedName = declaringClass.getQualifiedName();\n                    String fieldName = field.getName();", "                    if (qualifiedName != null && fieldName != null) {\n                        if (apiFilter != null && !apiFilter.hasField(qualifiedName, fieldName)) {\n                            if (isListIgnored()) {\n                                info(\n                                        \"Filtering out typedef constant \"\n                                                + qualifiedName\n                                                + \".\"\n                                                + fieldName\n                                                + \"\");\n                            }\n                            return false;\n                        }\n                        sb.append(qualifiedName);\n                        sb.append('.');\n                        sb.append(fieldName);\n                        return true;\n                    }\n                    return false;\n                } else {\n                    warning(\"Unexpected reference to \" + resolved);\n                    return false;\n                }", "            } else if (expression instanceof ULiteralExpression) {\n                ULiteralExpression literal = (ULiteralExpression) expression;\n                Object literalValue = literal.getValue();\n                if (appendLiteralValue(sb, literalValue)) {\n                    return true;\n                }\n            } else if (expression instanceof UBinaryExpressionWithType) {\n                if (UastExpressionUtils.isTypeCast(expression)) {\n                    UBinaryExpressionWithType cast = (UBinaryExpressionWithType) expression;\n                    UExpression operand = cast.getOperand();\n                    return appendExpression(sb, operand);\n                }\n                return false;\n            }\n\n            // For example, binary expressions like 3 + 4\n            Object literalValue = ConstantEvaluator.evaluate(null, expression);", "            if (literalValue != null) {\n                if (appendLiteralValue(sb, literalValue)) {\n                    return true;\n                }\n            }\n\n            warning(\n                    \"Unexpected annotation expression of type \"\n                            + expression.getClass()\n                            + \" and is \"\n                            + expression);\n\n            return false;\n        }\n\n        private boolean isInlinedConstant() { // TODO: Add android.* versions of these\n            return INT_DEF_ANNOTATION.isEquals(name)\n                    || LONG_DEF_ANNOTATION.isEquals(name)\n                    || STRING_DEF_ANNOTATION.isEquals(name)\n                    || SYSTEM_SERVICE.isEquals(name);\n        }\n    }\n\n    private static boolean appendLiteralValue(\n            @NonNull StringBuilder sb, @Nullable Object literalValue) {", "        if (literalValue instanceof Number || literalValue instanceof Boolean) {\n            sb.append(literalValue.toString());\n            return true;\n        } else if (literalValue instanceof String || literalValue instanceof Character) {\n            sb.append('\"');\n            XmlUtils.appendXmlAttributeValue(sb, literalValue.toString());\n            sb.append('\"');\n            return true;\n        }\n        return false;\n    }\n", "    public enum ClassKind {\n        CLASS,\n        INTERFACE,\n        ENUM,\n        ANNOTATION;\n\n        @NonNull\n        public static ClassKind forClass(@Nullable PsiClass declaration) {\n            if (declaration == null) {\n                return CLASS;\n            }", "            if (declaration == null) {\n                return CLASS;\n            }\n            if (declaration.isEnum()) {\n                return ENUM;\n            } else if (declaration.isAnnotationType()) {\n                return ANNOTATION;\n            } else if (declaration.isInterface()) {\n                return INTERFACE;\n            } else {\n                return CLASS;\n            }\n        }\n", "        public String getKeepType() {\n            // See http://proguard.sourceforge.net/manual/usage.html#classspecification\n            switch (this) {\n                case INTERFACE:\n                    return \"interface\";\n                case ENUM:\n                    return \"enum\";\n\n                case ANNOTATION:\n                case CLASS:\n                default:\n                    return \"class\";\n            }\n        }\n\n        @Override", "        public String toString() {\n            return getKeepType();\n        }\n    }\n\n    /**\n     * An item in the XML file: this corresponds to a method, a field, or a method parameter, and\n     * has an associated set of annotations\n     */\n    private abstract static class Item implements Comparable<Item> {\n        @NonNull", "        public final String containingClass;\n        @Nullable\n        public final PsiClass psiClass;\n\n        public Item(@Nullable PsiClass psiClass, @NonNull String containingClass) {\n            this.psiClass = psiClass;\n            this.containingClass = containingClass;\n        }\n\n        public final List<AnnotationData> annotations = new ArrayList<>();\n\n        void write(StringPrintWriter writer) {", "        public final List<AnnotationData> annotations = new ArrayList<>();\n\n        void write(StringPrintWriter writer) {\n            if (annotations.isEmpty()) {\n                return;\n            }\n            writer.print(\"  <item name=\\\"\");\n            writer.print(getSignature());\n            writer.println(\"\\\">\");\n\n            for (AnnotationData annotation : annotations) {\n                annotation.write(writer);\n            }\n            writer.print(\"  </item>\");\n            writer.println();\n        }\n\n        abstract boolean isFiltered(@NonNull ApiDatabase database);\n\n        @NonNull\n        abstract String getSignature();\n\n        @Override", "            for (AnnotationData annotation : annotations) {\n                annotation.write(writer);\n            }\n            writer.print(\"  </item>\");\n            writer.println();\n        }\n\n        abstract boolean isFiltered(@NonNull ApiDatabase database);\n\n        @NonNull\n        abstract String getSignature();\n\n        @Override", "        public int compareTo(@SuppressWarnings(\"NullableProblems\") @NonNull Item item) {\n            String signature1 = getSignature();\n            String signature2 = item.getSignature();\n\n            // IntelliJ's sorting order is not on the escaped HTML but the original\n            // signatures, which means android.os.AsyncTask<Params,Progress,Result>\n            // should appear *after* android.os.AsyncTask.Status, which when the <'s are\n            // escaped it does not\n            signature1 = signature1.replace('&', '.');\n            signature2 = signature2.replace('&', '.');\n\n            return signature1.compareTo(signature2);\n        }\n\n        @NonNull", "        public abstract String getKeepRule();\n\n        @NonNull\n        public abstract String getQualifiedClassName();\n    }\n\n    private static class ClassItem extends Item {\n        private ClassItem(@Nullable PsiClass psiClass, @NonNull String containingClass) {\n            super(psiClass, containingClass);\n        }\n\n        @NonNull\n        static ClassItem create(@Nullable PsiClass psiClass, @NonNull String classFqn) {\n            return new ClassItem(psiClass, classFqn);\n        }\n\n        @Override\n        boolean isFiltered(@NonNull ApiDatabase database) {\n            return !database.hasClass(containingClass);\n        }\n\n        @NonNull\n        @Override\n        String getSignature() {\n            return escapeXml(containingClass);\n        }\n\n        @NonNull\n        @Override", "        public String getKeepRule() {\n            // See http://proguard.sourceforge.net/manual/usage.html#classspecification\n            return \"-keep \"\n                    + ClassKind.forClass(psiClass).getKeepType()\n                    + \" \"\n                    + containingClass\n                    + \"\\n\";\n        }\n\n        @NonNull\n        @Override", "        public String getQualifiedClassName() {\n            return containingClass;\n        }\n\n        @Override\n        public String toString() {\n            return \"Class \" + containingClass;\n        }\n\n        @Override\n        public boolean equals(Object o) {", "        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            ClassItem that = (ClassItem) o;\n\n            return containingClass.equals(that.containingClass);\n        }\n\n        @Override", "        public int hashCode() {\n            return containingClass.hashCode();\n        }\n    }\n\n    private static class PackageItem extends Item {\n        private PackageItem(@NonNull String containingClass) {\n            super(null, containingClass);\n        }\n\n        @NonNull\n        static PackageItem create(@NonNull String fqn) {\n            return new PackageItem(fqn);\n        }\n\n        @Override\n        boolean isFiltered(@NonNull ApiDatabase database) {\n            return !database.hasPackage(containingClass);\n        }\n\n        @NonNull\n        @Override\n        String getSignature() {\n            return escapeXml(containingClass);\n        }\n\n        @NonNull\n        @Override", "        public String getKeepRule() {\n            return \"\";\n        }\n\n        @NonNull\n        @Override\n        public String getQualifiedClassName() {\n            return containingClass;\n        }\n\n        @Override", "        public String toString() {\n            return \"Package \" + containingClass;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PackageItem that = (PackageItem) o;\n\n            return containingClass.equals(that.containingClass);\n        }\n\n        @Override", "            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PackageItem that = (PackageItem) o;\n\n            return containingClass.equals(that.containingClass);\n        }\n\n        @Override\n        public int hashCode() {\n            return containingClass.hashCode();\n        }\n    }\n\n    private static class FieldItem extends Item {\n\n        @NonNull", "        public int hashCode() {\n            return containingClass.hashCode();\n        }\n    }\n\n    private static class FieldItem extends Item {\n\n        @NonNull\n        public final String fieldName;\n\n        @Nullable", "        public final String fieldName;\n\n        @Nullable\n        public final String fieldType;\n\n        private FieldItem(\n                @Nullable PsiClass psiClass,\n                @NonNull String containingClass,\n                @NonNull String fieldName,\n                @Nullable String fieldType) {\n            super(psiClass, containingClass);\n            this.fieldName = fieldName;\n            this.fieldType = fieldType;\n        }\n\n        @Nullable\n        static FieldItem create(\n                @Nullable PsiClass psiClass, @Nullable String classFqn, @NonNull PsiField field) {", "            if (classFqn == null) {\n                return null;\n            }\n            String name = field.getName();\n            String type = getVariableType(field);\n            if (name != null && type != null) {\n                return new FieldItem(psiClass, classFqn, name, type);\n            }\n            return null;\n        }\n\n        @Override\n        boolean isFiltered(@NonNull ApiDatabase database) {\n            return !database.hasField(containingClass, fieldName);\n        }\n\n        @NonNull\n        @Override\n        String getSignature() {\n            return escapeXml(containingClass) + ' ' + fieldName;\n        }\n\n        @NonNull\n        @Override", "        public String getKeepRule() {\n            if (fieldType == null) {\n                return \"\"; // imported item; these can't have keep rules\n            }\n            // See http://proguard.sourceforge.net/manual/usage.html#classspecification\n            return \"-keep \"\n                    + ClassKind.forClass(psiClass).getKeepType()\n                    + \" \"\n                    + containingClass\n                    + \" {\\n    \"\n                    + fieldType\n                    + \" \"\n                    + fieldName\n                    + \"\\n}\\n\";\n        }\n\n        @NonNull\n        @Override", "        public String getQualifiedClassName() {\n            return containingClass;\n        }\n\n        @Override\n        public String toString() {\n            return \"Field \" + containingClass + \"#\" + fieldName;\n        }\n\n        @Override\n        public boolean equals(Object o) {", "        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            FieldItem that = (FieldItem) o;\n\n            return containingClass.equals(that.containingClass) && fieldName.equals(that.fieldName);\n        }\n\n        @Override", "        public int hashCode() {\n            int result = fieldName.hashCode();\n            result = 31 * result + containingClass.hashCode();\n            return result;\n        }\n    }\n\n    private static class MethodItem extends Item {\n\n        @NonNull\n        public final String methodName;\n\n        @NonNull", "        public final String methodName;\n\n        @NonNull\n        public final String parameterList;\n\n        @Nullable\n        public final String returnType;\n\n        public final boolean isConstructor;\n\n        private MethodItem(\n                @Nullable PsiClass psiClass,\n                @NonNull String containingClass,\n                @Nullable String returnType,\n                @NonNull String methodName,\n                @NonNull String parameterList,\n                boolean isConstructor) {\n            super(psiClass, containingClass);\n            this.returnType = returnType;\n            this.methodName = methodName;\n            this.parameterList = parameterList;\n            this.isConstructor = isConstructor;\n        }\n\n        @NonNull", "        public final boolean isConstructor;\n\n        private MethodItem(\n                @Nullable PsiClass psiClass,\n                @NonNull String containingClass,\n                @Nullable String returnType,\n                @NonNull String methodName,\n                @NonNull String parameterList,\n                boolean isConstructor) {\n            super(psiClass, containingClass);\n            this.returnType = returnType;\n            this.methodName = methodName;\n            this.parameterList = parameterList;\n            this.isConstructor = isConstructor;\n        }\n\n        @NonNull", "        public String getName() {\n            return methodName;\n        }\n\n        @Nullable\n        static MethodItem create(\n                @Nullable PsiClass psiClass,\n                @Nullable String classFqn,\n                @NonNull PsiMethod declaration) {\n            if (classFqn == null) {\n                return null;\n            }\n            String returnType = getReturnType(declaration);\n            String methodName = getMethodName(declaration);", "            if (classFqn == null) {\n                return null;\n            }\n            String returnType = getReturnType(declaration);\n            String methodName = getMethodName(declaration);\n            if (returnType == null) {\n                return null;\n            }\n            String parameterList = getParameterList(declaration);\n\n            return new MethodItem(\n                    psiClass,\n                    classFqn,\n                    returnType,\n                    methodName,\n                    parameterList,\n                    declaration.isConstructor());\n        }\n\n        @NonNull\n        @Override\n        String getSignature() {\n            StringBuilder sb = new StringBuilder(100);\n            sb.append(escapeXml(containingClass));\n            sb.append(' ');\n", "            if (isConstructor) {\n                sb.append(escapeXml(methodName));\n            } else {\n                assert returnType != null;\n                sb.append(escapeXml(returnType));\n                sb.append(' ');\n                sb.append(escapeXml(methodName));\n            }\n\n            sb.append('(');\n\n            // The signature must match *exactly* the formatting used by IDEA,\n            // since it looks up external annotations in a map by this key.\n            // Therefore, it is vital that the parameter list uses exactly one\n            // space after each comma between parameters, and *no* spaces between\n            // generics variables, e.g. foo(Map<A,B>, int)\n\n            // Insert spaces between commas, but not in generics signatures\n            int balance = 0;", "            for (int i = 0, n = parameterList.length(); i < n; i++) {\n                char c = parameterList.charAt(i);\n                if (c == '<') {\n                    balance++;\n                    sb.append(\"&lt;\");\n                } else if (c == '>') {\n                    balance--;\n                    sb.append(\"&gt;\");\n                } else if (c == ',') {\n                    sb.append(',');\n                    if (balance == 0) {\n                        sb.append(' ');\n                    }\n                } else {\n                    sb.append(c);\n                }\n            }\n            sb.append(')');\n            return sb.toString();\n        }\n\n        @Override\n        boolean isFiltered(@NonNull ApiDatabase database) {\n            return !database.hasMethod(containingClass, methodName, parameterList);\n        }\n\n        @Override", "                } else if (c == ',') {\n                    sb.append(',');\n                    if (balance == 0) {\n                        sb.append(' ');\n                    }\n                } else {\n                    sb.append(c);\n                }\n            }\n            sb.append(')');\n            return sb.toString();\n        }\n\n        @Override\n        boolean isFiltered(@NonNull ApiDatabase database) {\n            return !database.hasMethod(containingClass, methodName, parameterList);\n        }\n\n        @Override", "        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            MethodItem that = (MethodItem) o;\n\n            return isConstructor == that.isConstructor\n                    && containingClass.equals(that.containingClass)\n                    && methodName.equals(that.methodName)\n                    && parameterList.equals(that.parameterList);\n        }\n\n        @Override", "        public int hashCode() {\n            int result = methodName.hashCode();\n            result = 31 * result + containingClass.hashCode();\n            result = 31 * result + parameterList.hashCode();\n            result = 31 * result + (returnType != null ? returnType.hashCode() : 0);\n            result = 31 * result + (isConstructor ? 1 : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"Method \" + containingClass + \"#\" + methodName;\n        }\n\n        @NonNull\n        @Override", "        public String toString() {\n            return \"Method \" + containingClass + \"#\" + methodName;\n        }\n\n        @NonNull\n        @Override\n        public String getKeepRule() {\n            // See http://proguard.sourceforge.net/manual/usage.html#classspecification\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"-keep \");\n            sb.append(ClassKind.forClass(psiClass).getKeepType());\n            sb.append(\" \");\n            sb.append(containingClass);\n            sb.append(\" {\\n\");\n            sb.append(\"    \");", "            if (isConstructor) {\n                sb.append(\"<init>\");\n            } else {\n                sb.append(returnType);\n                sb.append(\" \");\n                sb.append(methodName);\n            }\n            sb.append(\"(\");\n            sb.append(parameterList);\n            sb.append(\")\\n\");\n            sb.append(\"}\\n\");\n\n            return sb.toString();\n        }\n\n        @NonNull\n        @Override", "        public String getQualifiedClassName() {\n            return containingClass;\n        }\n    }\n\n    @Nullable\n    private static String getReturnType(PsiMethod method) {\n        if (method.isConstructor()) {\n            PsiClass containingClass = method.getContainingClass();\n            if (containingClass != null) {\n                return containingClass.getName();\n            }\n        } else {\n            PsiType returnType = method.getReturnType();", "            if (containingClass != null) {\n                return containingClass.getName();\n            }\n        } else {\n            PsiType returnType = method.getReturnType();\n            if (returnType != null) {\n                return returnType.getCanonicalText();\n            }\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private static String getVariableType(PsiVariable variable) {\n        PsiType type = variable.getType();\n        return type.getCanonicalText();\n    }\n\n    private static String getMethodName(@NonNull PsiMethod method) {", "        if (method.isConstructor()) {\n            return method.getName();\n        }\n\n        return method.getName();\n    }\n\n    @NonNull\n    private static String getParameterList(PsiMethod method) {\n        // Create compact type signature (no spaces around commas or generics arguments)\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        PsiParameterList parameterList = method.getParameterList();", "        for (PsiParameter parameter : parameterList.getParameters()) {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(',');\n            }\n\n            PsiType type = parameter.getType();\n            sb.append(type.getCanonicalText());\n        }\n        return sb.toString();\n    }\n\n    private static class ParameterItem extends MethodItem {\n        @NonNull", "        public final String argIndex;\n\n        private ParameterItem(\n                @Nullable PsiClass psiClass,\n                @NonNull String containingClass,\n                @Nullable String returnType,\n                @NonNull String methodName,\n                @NonNull String parameterList,\n                boolean isConstructor,\n                @NonNull String argIndex) {\n            super(psiClass, containingClass, returnType, methodName, parameterList, isConstructor);\n            this.argIndex = argIndex;\n        }\n\n        @Nullable\n        static ParameterItem create(\n                @Nullable PsiClass psiClass,\n                @Nullable String classFqn,\n                @NonNull PsiMethod method,\n                @NonNull PsiParameter parameter,\n                int index) {", "            if (classFqn == null) {\n                return null;\n            }\n\n            String methodName = getMethodName(method);\n            String returnType = getReturnType(method);\n            if (methodName == null || returnType == null) {\n                return null;\n            }\n            String parameterList = getParameterList(method);\n            String argNum = Integer.toString(index);\n\n            return new ParameterItem(\n                    psiClass,\n                    classFqn,\n                    returnType,\n                    methodName,\n                    parameterList,\n                    method.isConstructor(),\n                    argNum);\n        }\n\n        @NonNull\n        @Override\n        String getSignature() {\n            return super.getSignature() + ' ' + argIndex;\n        }\n\n        @Override", "        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            if (!super.equals(o)) {\n                return false;\n            }\n\n            ParameterItem that = (ParameterItem) o;\n\n            return argIndex.equals(that.argIndex);\n        }\n\n        @Override", "        public int hashCode() {\n            int result = super.hashCode();\n            result = 31 * result + argIndex.hashCode();\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"Parameter #\" + argIndex + \" in \" + super.toString();\n        }\n\n        @NonNull\n        @Override", "        public String getKeepRule() {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns true if the given javadoc contains a {@code @hide} marker\n     *\n     * @param docComment the javadoc\n     * @return true if the javadoc contains a hide marker\n     */\n    private static boolean javadocContainsHide(@Nullable PsiDocComment docComment) {", "        if (docComment != null) {\n            String text = docComment.getText();\n            if (text.contains(\"@hide\")) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the given javadoc contains a {@code @hide} marker\n     *\n     * @param element the documented element\n     * @return true if the javadoc contains a hide marker\n     */\n    private static boolean javadocContainsHide(@NonNull UElement element) {\n        List<UComment> comments = element.getComments();", "        for (UComment comment : comments) {\n            String text = comment.getText();\n            if (text.contains(\"@hide\")) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if this type declaration for a typedef is hidden (e.g. should not be extracted\n     * into an external annotation database)\n     *\n     * @param declaration the type declaration\n     * @return true if the type is hidden\n     */\n    @SuppressWarnings(\"RedundantIfStatement\")", "    public static boolean isHiddenTypeDef(@NonNull UClass declaration) {\n        if (declaration.getVisibility() != UastVisibility.PUBLIC) {\n            return true;\n        }\n\n        if (REMOVE_HIDDEN_TYPEDEFS && javadocContainsHide(declaration)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private class AnnotationVisitor extends AbstractUastVisitor {\n        private List<String> privateTypedefs = new ArrayList<>();\n        private final boolean requireHide;\n        private final boolean requireSourceRetention;\n\n        public AnnotationVisitor(boolean requireHide, boolean requireSourceRetention) {\n            this.requireHide = requireHide;\n            this.requireSourceRetention = requireSourceRetention;\n        }\n\n        public List<String> getPrivateTypedefClasses() {\n            return privateTypedefs;\n        }\n\n        @Override", "        public boolean visitMethod(UMethod method) {\n            PsiClass containingClass = method.getContainingClass();\n\n            // Not calling super: don't recurse inside methods\n            if (hasRelevantAnnotations(method)) {\n                String fqn = getFqn(containingClass);\n                MethodItem item = MethodItem.create(containingClass, fqn, method);\n                if (item != null) {\n                    addItem(fqn, item);\n\n                    // Deliberately skip findViewById()'s return nullability\n                    // for now; it's true that findViewById can return null,\n                    // but that means all code which does findViewById(R.id.foo).something()\n                    // will be flagged as potentially throwing an NPE, and many developers\n                    // will do this when they *know* that the id exists (in which case\n                    // the method won't return null.)\n                    boolean skipReturnAnnotations = false;", "                    if (\"findViewById\".equals(item.getName())) {\n                        skipReturnAnnotations = true;\n                        if (item.annotations.isEmpty()) {\n                            // No other annotations so far: just remove it\n                            removeItem(fqn, item);\n                        }\n                    }\n\n                    if (!skipReturnAnnotations) {\n                        addAnnotations(method, item);\n                    }\n                }\n            }\n\n            List<UParameter> parameters = method.getUastParameters();\n            int index = 0;", "                    if (!skipReturnAnnotations) {\n                        addAnnotations(method, item);\n                    }\n                }\n            }\n\n            List<UParameter> parameters = method.getUastParameters();\n            int index = 0;\n            for (UParameter parameter : parameters) {\n                if (hasRelevantAnnotations(parameter)) {\n                    String fqn = getFqn(containingClass);\n                    Item item =\n                            ParameterItem.create(containingClass, fqn, method, parameter, index);", "            for (UParameter parameter : parameters) {\n                if (hasRelevantAnnotations(parameter)) {\n                    String fqn = getFqn(containingClass);\n                    Item item =\n                            ParameterItem.create(containingClass, fqn, method, parameter, index);\n                    if (item != null) {\n                        addItem(fqn, item);\n                        addAnnotations(parameter, item);\n                    }\n                }\n                index++;\n            }\n\n            return true;\n        }\n\n        @Override", "        public boolean visitField(UField field) {\n            // Not calling super: don't recurse inside field (e.g. field initializer)\n            //super.visitField(field);\n            if (hasRelevantAnnotations(field)) {\n                PsiClass containingClass = field.getContainingClass();\n                if (containingClass != null) {\n                    String fqn = getFqn(containingClass);\n                    Item item = FieldItem.create(containingClass, fqn, field);\n                    if (item != null) {\n                        addItem(fqn, item);\n                        addAnnotations(field, item);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        @Override", "                    if (item != null) {\n                        addItem(fqn, item);\n                        addAnnotations(field, item);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        @Override", "        public boolean visitInitializer(UClassInitializer initializer) {\n            // Don't look inside\n            return true;\n        }\n\n        @Override\n        public boolean visitFile(UFile node) {\n            // Extract package. PSI doesn't expose the fact that for a package-info\n            // the modifier list is one of the children of the package statement\n            // Is it a package-info.java file?\n", "            if (hasRelevantAnnotations(node)) {\n                String fqn = node.getPackageName();\n                PackageItem item = PackageItem.create(fqn);\n                addPackage(fqn, item);\n                addAnnotations(node, item);\n            }\n\n            return super.visitFile(node);\n        }\n\n        @Override", "        public boolean visitClass(UClass aClass) {\n            super.visitClass(aClass);\n\n            if (aClass instanceof UAnonymousClass) {\n                return true;\n            }\n\n            if (aClass.isAnnotationType()) {\n                // Let's see if it's a typedef\n                //noinspection RedundantCast\n                for (UAnnotation annotation : ((UAnnotated) aClass).getAnnotations()) {\n                    String fqn = annotation.getQualifiedName();", "                for (UAnnotation annotation : ((UAnnotated) aClass).getAnnotations()) {\n                    String fqn = annotation.getQualifiedName();\n                    if (isNestedAnnotation(fqn)) {\n                        if (requireHide && !javadocContainsHide(aClass)) {\n                            Extractor.warning(\n                                    aClass.getQualifiedName()\n                                            + \": This typedef annotation should specify @hide in a \"\n                                            + \"doc comment\");\n                        }\n                        if (requireSourceRetention && !hasSourceRetention(aClass)) {\n                            String message =\n                                    aClass.getQualifiedName()\n                                            + \": The typedef annotation should have \"\n                                            + \"@Retention(RetentionPolicy.SOURCE)\";", "                        if (requireSourceRetention && !hasSourceRetention(aClass)) {\n                            String message =\n                                    aClass.getQualifiedName()\n                                            + \": The typedef annotation should have \"\n                                            + \"@Retention(RetentionPolicy.SOURCE)\";\n                            if (VALUE_TRUE.equals(\n                                    System.getProperty(\"android.typedef.enforce-retention\"))) {\n                                throw new ReflectiveLintRunner.ExtractErrorException(message);\n                            } else {\n                                Extractor.warning(message);\n                            }\n                        }", "                        if (isHiddenTypeDef(aClass)) {\n                            String cls = Lint.getInternalName(aClass);\n                            privateTypedefs.add(cls);\n                        }\n\n                        break;\n                    }\n                }\n            }\n            if (aClass.isAnnotationType()\n                    // Public typedef annotation need to be kept; they're not\n                    // removed by TypedefCollector#recordTypedefs so users may\n                    // end up referencing the typedef annotation itself\n                    && isHiddenTypeDef(aClass)) {\n                return false;\n            }\n", "            if (aClass.isAnnotationType()\n                    // Public typedef annotation need to be kept; they're not\n                    // removed by TypedefCollector#recordTypedefs so users may\n                    // end up referencing the typedef annotation itself\n                    && isHiddenTypeDef(aClass)) {\n                return false;\n            }\n\n            if (hasRelevantAnnotations(aClass)) {\n                String fqn = getFqn(aClass);\n                if (fqn != null) {\n                    Item item = ClassItem.create(aClass, fqn);\n                    addItem(fqn, item);\n                    addAnnotations(aClass, item);\n                }\n            }\n\n            return false;\n        }\n    }\n}\n", "            if (hasRelevantAnnotations(aClass)) {\n                String fqn = getFqn(aClass);\n                if (fqn != null) {\n                    Item item = ClassItem.create(aClass, fqn);\n                    addItem(fqn, item);\n                    addAnnotations(aClass, item);\n                }\n            }\n\n            return false;\n        }\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-gradle-api/lintGradle/src/main/java/com/android/tools/lint/annotations/ApiDatabase.java", "chunked_list": ["package com.android.tools.lint.annotations;\n\nimport com.android.annotations.NonNull;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.Files;", "import com.google.common.collect.Sets;\nimport com.google.common.io.Files;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;", "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Reads a signature file in the format of the new API files in frameworks/base/api\n */\npublic class ApiDatabase {\n    @NonNull\n    private final List<String> lines;\n    /**\n     * Map from class name to set of field names\n     */\n    @NonNull\n    private final Map<String, Set<String>> fieldMap = Maps.newHashMapWithExpectedSize(4000);\n    /**\n     * Map from class name to map of method names whose values are overloaded signatures\n     */\n    @NonNull\n    private final Map<String, Map<String, List<String>>> methodMap =\n            Maps.newHashMapWithExpectedSize(4000);\n\n    @NonNull\n    private final Map<String, List<String>> inheritsFrom = Maps.newHashMapWithExpectedSize(4000);\n\n    @NonNull\n    private final Map<String, Set<String>> intFieldMap = Maps.newHashMapWithExpectedSize(4000);\n\n    @NonNull\n    private final Set<String> classSet = Sets.newHashSetWithExpectedSize(4000);\n    private final Set<String> packageSet = Sets.newHashSetWithExpectedSize(300);\n\n    public ApiDatabase(@NonNull List<String> lines) {\n        this.lines = lines;\n        readApi();\n    }\n\n    public ApiDatabase(@NonNull File api) throws IOException {\n        this(Files.readLines(api, Charsets.UTF_8));\n    }\n", "    public boolean hasMethod(String className, String methodName, String arguments) {\n        // Perform raw lookup\n        className = getRawClass(className);\n        methodName = getRawMethod(methodName);\n        arguments = getRawParameterList(arguments);\n\n        Map<String, List<String>> methods = methodMap.get(className);\n        if (methods != null) {\n            List<String> strings = methods.get(methodName);\n            if (strings != null && strings.contains(arguments)) {\n                return true;\n            }\n        }\n\n        List<String> inheritsFrom = this.inheritsFrom.get(className);", "            if (strings != null && strings.contains(arguments)) {\n                return true;\n            }\n        }\n\n        List<String> inheritsFrom = this.inheritsFrom.get(className);\n        if (inheritsFrom != null) {\n            for (String clz : inheritsFrom) {\n                if (hasMethod(clz, methodName, arguments)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n", "                if (hasMethod(clz, methodName, arguments)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean hasField(String className, String fieldName) {\n        Set<String> fields = fieldMap.get(className);", "    public boolean hasField(String className, String fieldName) {\n        Set<String> fields = fieldMap.get(className);\n        if (fields != null && fields.contains(fieldName)) {\n            return true;\n        }\n\n        List<String> inheritsFrom = this.inheritsFrom.get(className);\n        if (inheritsFrom != null) {\n            for (String clz : inheritsFrom) {\n                if (hasField(clz, fieldName)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n", "            for (String clz : inheritsFrom) {\n                if (hasField(clz, fieldName)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean hasClass(String className) {\n        return classSet.contains(className);\n    }\n\n    @NonNull\n    private static String stripTypeArgs(@NonNull String line) {\n        StringBuilder sb = new StringBuilder(line.length());\n        int balance = 0;", "    public boolean hasClass(String className) {\n        return classSet.contains(className);\n    }\n\n    @NonNull\n    private static String stripTypeArgs(@NonNull String line) {\n        StringBuilder sb = new StringBuilder(line.length());\n        int balance = 0;\n        for (int i = 0, n = line.length(); i < n; i++) {\n            char c = line.charAt(i);\n            if (c == '<') {\n                balance++;", "        for (int i = 0, n = line.length(); i < n; i++) {\n            char c = line.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            } else if (balance == 0) {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    public Set<String> getDeclaredIntFields(String className) {\n        return intFieldMap.get(className);\n    }\n\n    private void readApi() {\n        String MODIFIERS =\n                \"((deprecated|public|static|private|protected|final|abstract|\\\\s*)\\\\s+)*\";\n        Pattern PACKAGE = Pattern.compile(\"package (\\\\S+) \\\\{\");\n        Pattern CLASS =\n                Pattern.compile(\n                        MODIFIERS\n                                + \"(class|interface|enum)\\\\s+(\\\\S+)\\\\s+(extends\\\\s+(\\\\S+))?(implements\\\\s+(.+))?(.*)\\\\{\");\n        Pattern METHOD =\n                Pattern.compile(\n                        \"(method|ctor)\\\\s+\" + MODIFIERS + \"(.+)??\\\\s+(\\\\S+)\\\\s*\\\\((.*)\\\\)(.*);\");\n        Pattern CTOR = Pattern.compile(\"(method|ctor)\\\\s+.*\\\\((.*)\\\\)(.*);\");\n        Pattern FIELD =\n                Pattern.compile(\"(enum_constant|field)\\\\s+\" + MODIFIERS + \"(.+)\\\\s+(\\\\S+)\\\\s*;\");\n\n        String currentPackage = null;\n        String currentClass = null;\n", "        for (String line : lines) {\n            line = line.trim();\n            if (line.isEmpty() || line.equals(\"}\")) {\n                continue;\n            }\n            line = stripTypeArgs(line);\n            if (line.startsWith(\"method \")) {\n                Matcher matcher = METHOD.matcher(line);\n                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a member: \" + line);\n                } else {\n                    assert currentClass != null;\n                    Map<String, List<String>> memberMap = methodMap.get(currentClass);", "                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a member: \" + line);\n                } else {\n                    assert currentClass != null;\n                    Map<String, List<String>> memberMap = methodMap.get(currentClass);\n                    if (memberMap == null) {\n                        memberMap = Maps.newHashMap();\n                        methodMap.put(currentClass, memberMap);\n                        methodMap.put(getRawClass(currentClass), memberMap);\n                    }\n                    String methodName = matcher.group(5);\n                    List<String> signatures = memberMap.get(methodName);", "                    if (signatures == null) {\n                        signatures = Lists.newArrayList();\n                        memberMap.put(methodName, signatures);\n                        memberMap.put(getRawMethod(methodName), signatures);\n                    }\n                    String signature = matcher.group(6);\n                    signature = signature.trim().replace(\" \", \"\").replace(\" \", \"\");\n                    // normalize varargs: allow lookup with both formats\n                    signatures.add(signature);\n                    if (signature.endsWith(\"...\")) {\n                        signatures.add(signature.substring(0, signature.length() - 3) + \"[]\");", "                    if (signature.endsWith(\"...\")) {\n                        signatures.add(signature.substring(0, signature.length() - 3) + \"[]\");\n                    } else if (signature.endsWith(\"[]\") && !signature.endsWith(\"[][]\")) {\n                        signatures.add(signature.substring(0, signature.length() - 2) + \"...\");\n                    }\n                    String raw = getRawParameterList(signature);\n                    if (!signatures.contains(raw)) {\n                        signatures.add(raw);\n                    }\n                }\n            } else if (line.startsWith(\"ctor \")) {\n                Matcher matcher = CTOR.matcher(line);", "            } else if (line.startsWith(\"ctor \")) {\n                Matcher matcher = CTOR.matcher(line);\n                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a member: \" + line);\n                } else {\n                    assert currentClass != null;\n                    Map<String, List<String>> memberMap = methodMap.get(currentClass);\n                    if (memberMap == null) {\n                        memberMap = Maps.newHashMap();\n                        methodMap.put(currentClass, memberMap);\n                        methodMap.put(getRawClass(currentClass), memberMap);\n                    }\n                    @SuppressWarnings(\"UnnecessaryLocalVariable\")\n                    String methodName = currentClass;\n                    List<String> signatures = memberMap.get(methodName);", "                    if (signatures == null) {\n                        signatures = Lists.newArrayList();\n                        memberMap.put(methodName, signatures);\n                        String constructor = methodName.substring(methodName.lastIndexOf('.') + 1);\n                        memberMap.put(constructor, signatures);\n                        memberMap.put(getRawMethod(methodName), signatures);\n                        memberMap.put(getRawMethod(constructor), signatures);\n                    }\n                    String signature = matcher.group(2);\n                    signature = signature.trim().replace(\" \", \"\").replace(\" \", \"\");\n                    if (signature.endsWith(\"...\")) {\n                        signatures.add(signature.substring(0, signature.length() - 3) + \"[]\");", "                    if (signature.endsWith(\"...\")) {\n                        signatures.add(signature.substring(0, signature.length() - 3) + \"[]\");\n                    } else if (signature.endsWith(\"[]\") && !signature.endsWith(\"[][]\")) {\n                        signatures.add(signature.substring(0, signature.length() - 2) + \"...\");\n                    }\n                    signatures.add(signature);\n                    String raw = getRawMethod(signature);\n                    if (!signatures.contains(raw)) {\n                        signatures.add(raw);\n                    }\n                }", "            } else if (line.startsWith(\"enum_constant \") || line.startsWith(\"field \")) {\n                int equals = line.indexOf('=');\n                if (equals != -1) {\n                    line = line.substring(0, equals).trim();\n                    int semi = line.indexOf(';');\n                    if (semi == -1) {\n                        line = line + ';';\n                    }\n                } else if (!line.endsWith(\";\")) {\n                    int semi = line.indexOf(';');\n                    if (semi != -1) {\n                        line = line.substring(0, semi + 1);\n                    }\n                }\n                Matcher matcher = FIELD.matcher(line);", "                } else if (!line.endsWith(\";\")) {\n                    int semi = line.indexOf(';');\n                    if (semi != -1) {\n                        line = line.substring(0, semi + 1);\n                    }\n                }\n                Matcher matcher = FIELD.matcher(line);\n                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a member: \" + line);\n                } else {\n                    assert currentClass != null;\n                    String fieldName = matcher.group(5);\n                    Set<String> fieldSet = fieldMap.get(currentClass);", "                    if (fieldSet == null) {\n                        fieldSet = Sets.newHashSet();\n                        fieldMap.put(currentClass, fieldSet);\n                    }\n                    fieldSet.add(fieldName);\n                    String type = matcher.group(4);\n                    if (type.equals(\"int\")) {\n                        fieldSet = intFieldMap.get(currentClass);\n                        if (fieldSet == null) {\n                            fieldSet = Sets.newHashSet();\n                            intFieldMap.put(currentClass, fieldSet);\n                        }\n                        fieldSet.add(fieldName);\n                    }\n                }", "                        if (fieldSet == null) {\n                            fieldSet = Sets.newHashSet();\n                            intFieldMap.put(currentClass, fieldSet);\n                        }\n                        fieldSet.add(fieldName);\n                    }\n                }\n            } else if (line.startsWith(\"package \")) {\n                Matcher matcher = PACKAGE.matcher(line);\n                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a package: \" + line);\n                } else {\n                    currentPackage = matcher.group(1);\n                    packageSet.add(currentPackage);\n                }\n            } else {\n                Matcher matcher = CLASS.matcher(line);", "                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a package: \" + line);\n                } else {\n                    currentPackage = matcher.group(1);\n                    packageSet.add(currentPackage);\n                }\n            } else {\n                Matcher matcher = CLASS.matcher(line);\n                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a class/interface: \" + line);\n                } else {\n                    currentClass = currentPackage + '.' + matcher.group(4);\n                    classSet.add(currentClass);\n\n                    String superClass = matcher.group(6);", "                if (!matcher.matches()) {\n                    Extractor.warning(\"Warning: Did not match as a class/interface: \" + line);\n                } else {\n                    currentClass = currentPackage + '.' + matcher.group(4);\n                    classSet.add(currentClass);\n\n                    String superClass = matcher.group(6);\n                    if (superClass != null) {\n                        Splitter splitter = Splitter.on(' ').trimResults().omitEmptyStrings();\n                        for (String from : splitter.split(superClass)) {\n                            addInheritsFrom(currentClass, from);\n                        }\n                        addInheritsFrom(currentClass, superClass.trim());\n                    }\n                    String implementsList = matcher.group(9);", "                        for (String from : splitter.split(superClass)) {\n                            addInheritsFrom(currentClass, from);\n                        }\n                        addInheritsFrom(currentClass, superClass.trim());\n                    }\n                    String implementsList = matcher.group(9);\n                    if (implementsList != null) {\n                        Splitter splitter = Splitter.on(' ').trimResults().omitEmptyStrings();\n                        for (String from : splitter.split(implementsList)) {\n                            if (from.equals(\"implements\")) { // workaround for broken regexp\n                                continue;\n                            }\n                            addInheritsFrom(currentClass, from);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void addInheritsFrom(String cls, String inheritsFrom) {\n        List<String> list = this.inheritsFrom.get(cls);", "                        for (String from : splitter.split(implementsList)) {\n                            if (from.equals(\"implements\")) { // workaround for broken regexp\n                                continue;\n                            }\n                            addInheritsFrom(currentClass, from);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void addInheritsFrom(String cls, String inheritsFrom) {\n        List<String> list = this.inheritsFrom.get(cls);", "        if (list == null) {\n            list = Lists.newArrayList();\n            this.inheritsFrom.put(cls, list);\n        }\n        list.add(inheritsFrom);\n    }\n\n    /**\n     * Drop generic type variables from a class name\n     */\n    @VisibleForTesting\n    static String getRawClass(@NonNull String name) {\n        int index = name.indexOf('<');", "        if (index != -1) {\n            int end = name.indexOf('>', index + 1);\n            if (end == -1 || end == name.length() - 1) {\n                return name.substring(0, index);\n            } else {\n                // e.g. test.pkg.ArrayAdapter<T>.Inner\n                return name.substring(0, index) + name.substring(end + 1);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * Drop generic type variables from a method or constructor name\n     */\n    @VisibleForTesting\n    static String getRawMethod(@NonNull String name) {\n        int index = name.indexOf('<');", "        if (index != -1) {\n            return name.substring(0, index);\n        }\n        return name;\n    }\n\n    /**\n     * Drop generic type variables and varargs to produce a raw signature\n     */\n    @VisibleForTesting\n    static String getRawParameterList(String signature) {", "        if (signature.indexOf('<') == -1 && !signature.endsWith(\"...\")) {\n            return signature;\n        }\n\n        int n = signature.length();\n        StringBuilder sb = new StringBuilder(n);\n        int start = 0;\n        while (true) {\n            int index = signature.indexOf('<', start);\n            if (index == -1) {\n                sb.append(signature.substring(start));\n                break;\n            }\n            sb.append(signature.substring(start, index));\n            int balance = 1;", "            if (index == -1) {\n                sb.append(signature.substring(start));\n                break;\n            }\n            sb.append(signature.substring(start, index));\n            int balance = 1;\n            for (int i = index + 1; i < n; i++) {\n                char c = signature.charAt(i);\n                if (c == '<') {\n                    balance++;\n                } else if (c == '>') {\n                    balance--;", "                if (c == '<') {\n                    balance++;\n                } else if (c == '>') {\n                    balance--;\n                    if (balance == 0) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Normalize varargs... to []", "        if (sb.length() > 3\n                && sb.charAt(sb.length() - 1) == '.'\n                && sb.charAt(sb.length() - 2) == '.'\n                && sb.charAt(sb.length() - 3) == '.') {\n            sb.setLength(sb.length() - 3);\n            sb.append('[').append(']');\n        }\n\n        return sb.toString();\n    }\n", "    public boolean hasPackage(String pkg) {\n        return packageSet.contains(pkg);\n    }\n}\n"]}
{"filename": "AndroidLint-4.1.0/lint-gradle-api/lintGradle/src/main/java/com/android/tools/lint/gradle/GroovyGradleVisitor.java", "chunked_list": ["package com.android.tools.lint.gradle;\n\nimport com.android.annotations.NonNull;\nimport com.android.tools.lint.checks.GradleDetector;\nimport com.android.tools.lint.client.api.GradleVisitor;\nimport com.android.tools.lint.detector.api.Context;\nimport com.android.tools.lint.detector.api.DefaultPosition;\nimport com.android.tools.lint.detector.api.GradleContext;\nimport com.android.tools.lint.detector.api.GradleScanner;\nimport com.android.tools.lint.detector.api.Location;", "import com.android.tools.lint.detector.api.GradleScanner;\nimport com.android.tools.lint.detector.api.Location;\nimport com.android.utils.Pair;\n\nimport org.codehaus.groovy.ast.ASTNode;\nimport org.codehaus.groovy.ast.CodeVisitorSupport;\nimport org.codehaus.groovy.ast.GroovyCodeVisitor;\nimport org.codehaus.groovy.ast.builder.AstBuilder;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;", "import org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.MapEntryExpression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.ast.expr.NamedArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.TupleExpression;\nimport org.codehaus.groovy.ast.stmt.BlockStatement;\nimport org.codehaus.groovy.ast.stmt.ExpressionStatement;\nimport org.codehaus.groovy.ast.stmt.ReturnStatement;", "import org.codehaus.groovy.ast.stmt.ExpressionStatement;\nimport org.codehaus.groovy.ast.stmt.ReturnStatement;\nimport org.codehaus.groovy.ast.stmt.Statement;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**", "\n/**\n * Implementation of the {@link GradleDetector} using a real Groovy AST, which the Gradle plugin has\n * access to.\n */\npublic class GroovyGradleVisitor extends GradleVisitor {\n    @Override\n    public void visitBuildScript(\n            @NonNull GradleContext context, @NonNull List<? extends GradleScanner> detectors) {\n        try {\n            visitQuietly(context, detectors);\n        } catch (Throwable t) {\n            // else: ignore\n            // Parsing the build script can involve class loading that we sometimes can't\n            // handle. This happens for example when running lint in build-system/tests/api/.\n            // This is a lint limitation rather than a user error, so don't complain\n            // about these. Consider reporting a Issue#LINT_ERROR.\n        }\n    }\n\n    private static void visitQuietly(\n            @NonNull final GradleContext context,\n            @NonNull final List<? extends GradleScanner> detectors) {\n        CharSequence sequence = context.getContents();", "        try {\n            visitQuietly(context, detectors);\n        } catch (Throwable t) {\n            // else: ignore\n            // Parsing the build script can involve class loading that we sometimes can't\n            // handle. This happens for example when running lint in build-system/tests/api/.\n            // This is a lint limitation rather than a user error, so don't complain\n            // about these. Consider reporting a Issue#LINT_ERROR.\n        }\n    }\n\n    private static void visitQuietly(\n            @NonNull final GradleContext context,\n            @NonNull final List<? extends GradleScanner> detectors) {\n        CharSequence sequence = context.getContents();", "        if (sequence == null) {\n            return;\n        }\n\n        final String source = sequence.toString();\n        List<ASTNode> astNodes = new AstBuilder().buildFromString(source);\n        GroovyCodeVisitor visitor =\n                new CodeVisitorSupport() {\n                    private final List<MethodCallExpression> mMethodCallStack = new ArrayList<>();\n\n                    @Override", "                    public void visitMethodCallExpression(MethodCallExpression expression) {\n                        mMethodCallStack.add(expression);\n                        super.visitMethodCallExpression(expression);\n                        assert !mMethodCallStack.isEmpty();\n                        assert mMethodCallStack.get(mMethodCallStack.size() - 1) == expression;\n                        mMethodCallStack.remove(mMethodCallStack.size() - 1);\n                    }\n\n                    @Override\n                    public void visitTupleExpression(TupleExpression tupleExpression) {\n                        if (!mMethodCallStack.isEmpty()) {\n                            MethodCallExpression call =\n                                    mMethodCallStack.get(mMethodCallStack.size() - 1);", "                    public void visitTupleExpression(TupleExpression tupleExpression) {\n                        if (!mMethodCallStack.isEmpty()) {\n                            MethodCallExpression call =\n                                    mMethodCallStack.get(mMethodCallStack.size() - 1);\n                            if (call.getArguments() == tupleExpression) {\n                                String parent = call.getMethodAsString();\n                                String parentParent = getParentParent();\n                                String parent3 = getParentN(2);\n                                if (tupleExpression instanceof ArgumentListExpression) {\n                                    ArgumentListExpression ale =\n                                            (ArgumentListExpression) tupleExpression;\n                                    List<Expression> expressions = ale.getExpressions();", "                                if (tupleExpression instanceof ArgumentListExpression) {\n                                    ArgumentListExpression ale =\n                                            (ArgumentListExpression) tupleExpression;\n                                    List<Expression> expressions = ale.getExpressions();\n                                    if (expressions.size() == 1\n                                            && expressions.get(0) instanceof ClosureExpression) {\n                                        ClosureExpression closureExpression =\n                                                (ClosureExpression) expressions.get(0);\n                                        Statement block = closureExpression.getCode();\n                                        if (block instanceof BlockStatement) {\n                                            BlockStatement bs = (BlockStatement) block;", "                                        if (block instanceof BlockStatement) {\n                                            BlockStatement bs = (BlockStatement) block;\n                                            for (Statement statement : bs.getStatements()) {\n                                                if (statement instanceof ExpressionStatement) {\n                                                    ExpressionStatement e =\n                                                            (ExpressionStatement) statement;\n                                                    if (e.getExpression()\n                                                            instanceof MethodCallExpression) {\n                                                        checkDslProperty(\n                                                                parent,\n                                                                (MethodCallExpression)\n                                                                        e.getExpression(),\n                                                                parentParent,\n                                                                detectors);\n                                                    }", "                                                } else if (statement instanceof ReturnStatement) {\n                                                    // Single item in block\n                                                    ReturnStatement e = (ReturnStatement) statement;\n                                                    if (e.getExpression()\n                                                            instanceof MethodCallExpression) {\n                                                        checkDslProperty(\n                                                                parent,\n                                                                (MethodCallExpression)\n                                                                        e.getExpression(),\n                                                                parentParent,\n                                                                detectors);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } else {\n                                        Map<String, String> namedArguments = new HashMap<>();\n                                        List<String> unnamedArguments = new ArrayList<>();\n                                        extractMethodCallArguments(tupleExpression,\n                                                unnamedArguments, namedArguments);", "                                        for (GradleScanner scanner : detectors) {\n                                            scanner.checkMethodCall(\n                                                    context,\n                                                    parent,\n                                                    parentParent,\n                                                    parent3,\n                                                    namedArguments,\n                                                    unnamedArguments,\n                                                    call);\n                                        }\n                                    }\n                                } else {\n                                    Map<String, String> namedArguments = new HashMap<>();\n                                    List<String> unnamedArguments = new ArrayList<>();\n                                    extractMethodCallArguments(tupleExpression, unnamedArguments,\n                                            namedArguments);", "                                    for (GradleScanner scanner : detectors) {\n                                        scanner.checkMethodCall(\n                                                context,\n                                                parent,\n                                                parentParent,\n                                                parent3,\n                                                namedArguments,\n                                                unnamedArguments,\n                                                call);\n                                    }\n                                }\n                            }\n                        }\n\n                        super.visitTupleExpression(tupleExpression);\n                    }\n\n                    private void extractMethodCallArguments(TupleExpression tupleExpression,\n                                                            List<String> unnamedArguments,\n                                                            Map<String, String> namedArguments) {", "                        for (Expression subExpr : tupleExpression.getExpressions()) {\n                            if (subExpr instanceof NamedArgumentListExpression) {\n                                NamedArgumentListExpression nale =\n                                        (NamedArgumentListExpression) subExpr;\n                                for (MapEntryExpression mae :\n                                        nale.getMapEntryExpressions()) {\n                                    namedArguments.put(\n                                            mae.getKeyExpression().getText(),\n                                            mae.getValueExpression().getText());\n                                }\n                            }\n                        }\n                    }\n\n                    private String getParentN(int n) {\n                        int nParent = 0;", "                        for (int i = mMethodCallStack.size() - 2; i >= 0; i--) {\n                            MethodCallExpression expression = mMethodCallStack.get(i);\n                            Expression arguments = expression.getArguments();\n                            if (arguments instanceof ArgumentListExpression) {\n                                ArgumentListExpression ale = (ArgumentListExpression) arguments;\n                                List<Expression> expressions = ale.getExpressions();\n                                if (expressions.size() == 1\n                                        && expressions.get(0) instanceof ClosureExpression) {\n                                    nParent += 1;\n                                }\n                            }", "                            if (nParent == n) {\n                                return expression.getMethodAsString();\n                            }\n                        }\n                        return null;\n                    }\n\n                    private String getParentParent() {\n                        return getParentN(1);\n                    }\n\n                    private void checkDslProperty(\n                            String parent,\n                            MethodCallExpression c,\n                            String parentParent,\n                            @NonNull List<? extends GradleScanner> detectors) {\n                        String property = c.getMethodAsString();\n                        String value = getText(c.getArguments());", "                        for (GradleScanner scanner : detectors) {\n                            scanner.checkDslPropertyAssignment(\n                                    context,\n                                    property,\n                                    value,\n                                    parent,\n                                    parentParent,\n                                    c.getMethod(),\n                                    c,\n                                    c);\n                        }\n                    }\n\n                    private String getText(ASTNode node) {\n                        Pair<Integer, Integer> offsets = getOffsets(node, context);\n                        return source.substring(offsets.getFirst(), offsets.getSecond());\n                    }\n                };\n", "        for (ASTNode node : astNodes) {\n            node.visit(visitor);\n        }\n    }\n\n    @NonNull\n    private static Pair<Integer, Integer> getOffsets(ASTNode node, Context context) {\n        if (node.getLastLineNumber() == -1 && node instanceof TupleExpression) {\n            // Workaround: TupleExpressions yield bogus offsets, so use its\n            // children instead\n            TupleExpression exp = (TupleExpression) node;\n            List<Expression> expressions = exp.getExpressions();", "            if (!expressions.isEmpty()) {\n                return Pair.of(\n                        getOffsets(expressions.get(0), context).getFirst(),\n                        getOffsets(expressions.get(expressions.size() - 1), context).getSecond());\n            }\n        }\n\n        if (node instanceof ArgumentListExpression) {\n            List<Expression> expressions = ((ArgumentListExpression) node).getExpressions();\n            if (expressions.size() == 1) {\n                return getOffsets(expressions.get(0), context);\n            }\n        }\n\n        CharSequence source = context.getContents();\n        assert source != null; // because we successfully parsed\n        int start = 0;\n        int end = source.length();\n        int line = 1;\n        int startLine = node.getLineNumber();\n        int startColumn = node.getColumnNumber();\n        int endLine = node.getLastLineNumber();\n        int endColumn = node.getLastColumnNumber();\n        int column = 1;", "            if (expressions.size() == 1) {\n                return getOffsets(expressions.get(0), context);\n            }\n        }\n\n        CharSequence source = context.getContents();\n        assert source != null; // because we successfully parsed\n        int start = 0;\n        int end = source.length();\n        int line = 1;\n        int startLine = node.getLineNumber();\n        int startColumn = node.getColumnNumber();\n        int endLine = node.getLastLineNumber();\n        int endColumn = node.getLastColumnNumber();\n        int column = 1;", "        for (int index = 0, len = end; index < len; index++) {\n            if (line == startLine && column == startColumn) {\n                start = index;\n            }\n            if (line == endLine && column == endColumn) {\n                end = index;\n                break;\n            }\n\n            char c = source.charAt(index);\n            if (c == '\\n') {\n                line++;\n                column = 1;\n            } else {\n                column++;\n            }\n        }\n\n        return Pair.of(start, end);\n    }\n\n    @Override", "            if (c == '\\n') {\n                line++;\n                column = 1;\n            } else {\n                column++;\n            }\n        }\n\n        return Pair.of(start, end);\n    }\n\n    @Override", "    public int getStartOffset(@NonNull GradleContext context, @NonNull Object cookie) {\n        ASTNode node = (ASTNode) cookie;\n        Pair<Integer, Integer> offsets = getOffsets(node, context);\n        return offsets.getFirst();\n    }\n\n    @NonNull\n    @Override\n    public Location createLocation(@NonNull GradleContext context, @NonNull Object cookie) {\n        ASTNode node = (ASTNode) cookie;\n        Pair<Integer, Integer> offsets = getOffsets(node, context);\n        int fromLine = node.getLineNumber() - 1;\n        int fromColumn = node.getColumnNumber() - 1;\n        int toLine = node.getLastLineNumber() - 1;\n        int toColumn = node.getLastColumnNumber() - 1;\n        return Location.create(\n                context.file,\n                new DefaultPosition(fromLine, fromColumn, offsets.getFirst()),\n                new DefaultPosition(toLine, toColumn, offsets.getSecond()));\n    }\n\n    @NonNull\n    @Override", "    public Location createLocation(@NonNull GradleContext context, @NonNull Object cookie) {\n        ASTNode node = (ASTNode) cookie;\n        Pair<Integer, Integer> offsets = getOffsets(node, context);\n        int fromLine = node.getLineNumber() - 1;\n        int fromColumn = node.getColumnNumber() - 1;\n        int toLine = node.getLastLineNumber() - 1;\n        int toColumn = node.getLastColumnNumber() - 1;\n        return Location.create(\n                context.file,\n                new DefaultPosition(fromLine, fromColumn, offsets.getFirst()),\n                new DefaultPosition(toLine, toColumn, offsets.getSecond()));\n    }\n\n    @NonNull\n    @Override", "    public Object getPropertyKeyCookie(@NonNull Object cookie) {\n        return cookie;\n    }\n\n    @NonNull\n    @Override\n    public Object getPropertyPairCookie(@NonNull Object cookie) {\n        return cookie;\n    }\n}\n"]}
