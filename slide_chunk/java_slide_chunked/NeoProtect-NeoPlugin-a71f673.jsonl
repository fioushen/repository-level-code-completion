{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/Startup.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee;\n\nimport de.cubeattack.neoprotect.bungee.command.NeoProtectCommand;\nimport de.cubeattack.neoprotect.bungee.listener.ChatListener;\nimport de.cubeattack.neoprotect.bungee.listener.DisconnectListener;\nimport de.cubeattack.neoprotect.bungee.listener.LoginListener;\nimport de.cubeattack.neoprotect.bungee.proxyprotocol.ProxyProtocol;\nimport net.md_5.bungee.api.ProxyServer;\nimport net.md_5.bungee.api.plugin.PluginManager;\n\npublic class Startup {\n\n    public Startup(NeoProtectBungee instance) {\n        register(instance);\n        new ProxyProtocol(instance);\n    }\n\n    private void register(NeoProtectBungee instance) {\n        PluginManager pm = ProxyServer.getInstance().getPluginManager();\n        pm.registerCommand(instance, new NeoProtectCommand(instance, \"neoprotect\", \"neoprotect.admin\", \"np\"));\n\n        pm.registerListener(instance, new ChatListener(instance));\n        pm.registerListener(instance, new LoginListener(instance));\n        pm.registerListener(instance, new DisconnectListener(instance));\n    }\n}\n", "import net.md_5.bungee.api.plugin.PluginManager;\n\npublic class Startup {\n\n    public Startup(NeoProtectBungee instance) {\n        register(instance);\n        new ProxyProtocol(instance);\n    }\n\n    private void register(NeoProtectBungee instance) {\n        PluginManager pm = ProxyServer.getInstance().getPluginManager();\n        pm.registerCommand(instance, new NeoProtectCommand(instance, \"neoprotect\", \"neoprotect.admin\", \"np\"));\n\n        pm.registerListener(instance, new ChatListener(instance));\n        pm.registerListener(instance, new LoginListener(instance));\n        pm.registerListener(instance, new DisconnectListener(instance));\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/NeoProtectBungee.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee;\n\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.Core;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.Permission;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport de.cubeattack.neoprotect.core.model.debugtool.KeepAliveResponseKey;\nimport net.md_5.bungee.api.CommandSender;\nimport net.md_5.bungee.api.chat.ClickEvent;", "import net.md_5.bungee.api.CommandSender;\nimport net.md_5.bungee.api.chat.ClickEvent;\nimport net.md_5.bungee.api.chat.HoverEvent;\nimport net.md_5.bungee.api.chat.TextComponent;\nimport net.md_5.bungee.api.chat.hover.content.Text;\nimport net.md_5.bungee.api.connection.ProxiedPlayer;\nimport net.md_5.bungee.api.plugin.Plugin;\nimport net.md_5.bungee.protocol.packet.KeepAlive;\nimport org.bstats.bungeecord.Metrics;\nimport org.bstats.charts.SimplePie;", "import org.bstats.bungeecord.Metrics;\nimport org.bstats.charts.SimplePie;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic final class NeoProtectBungee extends Plugin implements NeoProtectPlugin {\n\n    private static Core core;\n\n    @Override", "    public void onLoad() {\n        Metrics metrics = new Metrics(this, 18726);\n        metrics.addCustomChart(new SimplePie(\"language\", Config::getLanguage));\n    }\n\n    @Override\n    public void onEnable() {\n        core = new Core(this);\n        new Startup(this);\n    }\n", "    public Core getCore() {\n        return core;\n    }\n\n    @Override\n    public Stats getStats() {\n        return new Stats(\n                getPluginType(),\n                getProxy().getVersion(),\n                getProxy().getName(),\n                System.getProperty(\"java.version\"),\n                System.getProperty(\"os.name\"),\n                System.getProperty(\"os.arch\"),\n                System.getProperty(\"os.version\"),\n                getDescription().getVersion(),\n                getCore().getVersionResult().getVersionStatus().toString(),\n                Config.getAutoUpdaterSettings().toString(),\n                getCore().isSetup() ? getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\",\n                Arrays.toString(getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray()),\n                getProxy().getOnlineCount(),\n                getProxy().getServers().size(),\n                Runtime.getRuntime().availableProcessors(),\n                getProxy().getConfig().isOnlineMode(),\n                Config.isProxyProtocol()\n        );\n    }\n\n    @Override", "    public void sendMessage(Object receiver, String text) {\n        sendMessage(receiver, text, null, null, null, null);\n    }\n\n    @Override\n    public void sendMessage(Object receiver, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        TextComponent msg = new TextComponent(core.getPrefix() + text);\n\n        if (clickAction != null)\n            msg.setClickEvent(new ClickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));\n        if (hoverAction != null)\n            msg.setHoverEvent(new HoverEvent(HoverEvent.Action.valueOf(hoverAction), Collections.singletonList(new Text(hoverMsg))));", "        if (clickAction != null)\n            msg.setClickEvent(new ClickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));\n        if (hoverAction != null)\n            msg.setHoverEvent(new HoverEvent(HoverEvent.Action.valueOf(hoverAction), Collections.singletonList(new Text(hoverMsg))));\n        if (receiver instanceof CommandSender) ((CommandSender) receiver).sendMessage(msg);\n    }\n\n    @Override\n    public void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        getProxy().getPlayers().forEach(receiver -> {\n            if (receiver.hasPermission(\"neoprotect.admin\") || receiver.hasPermission(permission.value))\n                sendMessage(receiver, text, clickAction, clickMsg, hoverAction, hoverMsg);\n        });\n    }\n\n    @Override", "    public void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        getProxy().getPlayers().forEach(receiver -> {\n            if (receiver.hasPermission(\"neoprotect.admin\") || receiver.hasPermission(permission.value))\n                sendMessage(receiver, text, clickAction, clickMsg, hoverAction, hoverMsg);\n        });\n    }\n\n    @Override\n    public void sendKeepAliveMessage(Object receiver, long id) {\n        if (receiver instanceof ProxiedPlayer) {\n            ((ProxiedPlayer) receiver).unsafe().sendPacket(new KeepAlive(id));\n            getCore().getPingMap().put(new KeepAliveResponseKey(((ProxiedPlayer) receiver).getSocketAddress(), id), System.currentTimeMillis());\n        }\n    }\n\n    @Override", "    public void sendKeepAliveMessage(Object receiver, long id) {\n        if (receiver instanceof ProxiedPlayer) {\n            ((ProxiedPlayer) receiver).unsafe().sendPacket(new KeepAlive(id));\n            getCore().getPingMap().put(new KeepAliveResponseKey(((ProxiedPlayer) receiver).getSocketAddress(), id), System.currentTimeMillis());\n        }\n    }\n\n    @Override\n    public long sendKeepAliveMessage(long id) {\n        for (ProxiedPlayer player : this.getProxy().getPlayers()) {\n            sendKeepAliveMessage(player, id);\n        }\n        return id;\n    }\n\n    @Override\n    public ArrayList<String> getPlugins() {\n        ArrayList<String> plugins = new ArrayList<>();\n        getProxy().getPluginManager().getPlugins().forEach(p -> plugins.add(p.getDescription().getName()));\n        return plugins;\n    }\n\n    @Override", "    public long sendKeepAliveMessage(long id) {\n        for (ProxiedPlayer player : this.getProxy().getPlayers()) {\n            sendKeepAliveMessage(player, id);\n        }\n        return id;\n    }\n\n    @Override\n    public ArrayList<String> getPlugins() {\n        ArrayList<String> plugins = new ArrayList<>();\n        getProxy().getPluginManager().getPlugins().forEach(p -> plugins.add(p.getDescription().getName()));\n        return plugins;\n    }\n\n    @Override", "    public PluginType getPluginType() {\n        return PluginType.BUNGEECORD;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        return getDescription().getVersion();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/proxyprotocol/ProxyProtocol.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.proxyprotocol;\n\nimport de.cubeattack.api.util.JavaUtils;\nimport de.cubeattack.neoprotect.bungee.NeoProtectBungee;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.model.debugtool.DebugPingResponse;\nimport de.cubeattack.neoprotect.core.model.debugtool.KeepAliveResponseKey;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;", "import io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.epoll.EpollSocketChannel;\nimport io.netty.channel.epoll.EpollTcpInfo;\nimport io.netty.handler.codec.haproxy.HAProxyMessage;\nimport io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\nimport net.md_5.bungee.BungeeCord;\nimport net.md_5.bungee.UserConnection;", "import net.md_5.bungee.BungeeCord;\nimport net.md_5.bungee.UserConnection;\nimport net.md_5.bungee.api.connection.ProxiedPlayer;\nimport net.md_5.bungee.netty.ChannelWrapper;\nimport net.md_5.bungee.netty.HandlerBoss;\nimport net.md_5.bungee.netty.PipelineUtils;\nimport net.md_5.bungee.protocol.PacketWrapper;\nimport net.md_5.bungee.protocol.packet.KeepAlive;\nimport sun.misc.Unsafe;\n", "import sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.logging.Level;\n\npublic class ProxyProtocol {\n    private final Reflection.FieldAccessor<ChannelWrapper> channelWrapperAccessor = Reflection.getField(HandlerBoss.class, \"channel\", ChannelWrapper.class);\n    private final ChannelInitializer<Channel> bungeeChannelInitializer = PipelineUtils.SERVER_CHILD;\n    private final Reflection.MethodInvoker initChannelMethod = Reflection.getMethod(bungeeChannelInitializer.getClass(), \"initChannel\", Channel.class);\n\n    public ProxyProtocol(NeoProtectBungee instance) {\n\n        instance.getLogger().info(\"Proceeding with the server channel injection...\");\n", "import java.util.logging.Level;\n\npublic class ProxyProtocol {\n    private final Reflection.FieldAccessor<ChannelWrapper> channelWrapperAccessor = Reflection.getField(HandlerBoss.class, \"channel\", ChannelWrapper.class);\n    private final ChannelInitializer<Channel> bungeeChannelInitializer = PipelineUtils.SERVER_CHILD;\n    private final Reflection.MethodInvoker initChannelMethod = Reflection.getMethod(bungeeChannelInitializer.getClass(), \"initChannel\", Channel.class);\n\n    public ProxyProtocol(NeoProtectBungee instance) {\n\n        instance.getLogger().info(\"Proceeding with the server channel injection...\");\n", "        try {\n            ChannelInitializer<Channel> channelInitializer = new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel channel) {\n                    try {\n\n                        instance.getCore().debug(\"Open channel (\" + channel.remoteAddress().toString() + \")\");\n\n                        initChannelMethod.invoke(bungeeChannelInitializer, channel);\n\n                        AtomicReference<InetSocketAddress> playerAddress = new AtomicReference<>();\n                        String sourceAddress = ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress();\n", "                        if (channel.localAddress().toString().startsWith(\"local:\") || sourceAddress.equals(Config.getGeyserServerIP())) {\n                            instance.getCore().debug(\"Detected bedrock player (return)\");\n                            return;\n                        }\n\n                        if (!instance.getCore().getDirectConnectWhitelist().contains(sourceAddress)) {\n                            if (instance.getCore().isSetup() && (instance.getCore().getRestAPI().getNeoServerIPs() == null ||\n                                    instance.getCore().getRestAPI().getNeoServerIPs().toList().stream().noneMatch(ipRange -> isIPInRange((String) ipRange, sourceAddress)))) {\n                                channel.close();\n                                instance.getCore().debug(\"Close connection IP (\" + channel.remoteAddress() + \") doesn't match to Neo-IPs (close / return)\");\n                                return;\n                            }\n\n                            instance.getCore().debug(\"Adding handler...\");\n", "                            if (instance.getCore().isSetup() && Config.isProxyProtocol()) {\n                                addProxyProtocolHandler(channel, playerAddress);\n                                instance.getCore().debug(\"Plugin is setup & ProxyProtocol is on (Added proxyProtocolHandler)\");\n                            }\n\n                            addKeepAlivePacketHandler(channel, playerAddress, instance);\n                            instance.getCore().debug(\"Added KeepAlivePacketHandler\");\n                        }\n\n                        instance.getCore().debug(\"Connecting finished\");\n\n                    } catch (Exception ex) {\n                        instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);\n                    }\n                }\n            };\n\n            Field serverChild = PipelineUtils.class.getField(\"SERVER_CHILD\");\n            serverChild.setAccessible(true);\n", "            if (JavaUtils.javaVersionCheck() == 8) {\n                Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n                modifiersField.setAccessible(true);\n                modifiersField.setInt(serverChild, serverChild.getModifiers() & ~Modifier.FINAL);\n\n                serverChild.set(PipelineUtils.class, channelInitializer);\n            } else {\n                Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n                unsafeField.setAccessible(true);\n\n                Unsafe unsafe = (Unsafe) unsafeField.get(null);\n                unsafe.putObject(unsafe.staticFieldBase(serverChild), unsafe.staticFieldOffset(serverChild), channelInitializer);\n            }\n\n            instance.getLogger().info(\"Found the server channel and added the handler. Injection successfully!\");\n\n        } catch (Exception ex) {\n            instance.getLogger().log(Level.SEVERE, \"An unknown error has occurred\", ex);\n        }\n    }\n", "    public void addProxyProtocolHandler(Channel channel, AtomicReference<InetSocketAddress> inetAddress) {\n        channel.pipeline().names().forEach((n) -> {\n            if (n.equals(\"HAProxyMessageDecoder#0\"))\n                channel.pipeline().remove(\"HAProxyMessageDecoder#0\");\n        });\n\n        channel.pipeline().addFirst(\"haproxy-decoder\", new HAProxyMessageDecoder());\n        channel.pipeline().addAfter(\"haproxy-decoder\", \"haproxy-handler\", new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof HAProxyMessage) {\n                    HAProxyMessage message = (HAProxyMessage) msg;\n                    inetAddress.set(new InetSocketAddress(message.sourceAddress(), message.sourcePort()));\n                    channelWrapperAccessor.get(channel.pipeline().get(HandlerBoss.class)).setRemoteAddress(inetAddress.get());\n                } else {\n                    super.channelRead(ctx, msg);\n                }\n            }\n        });\n    }\n", "            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof HAProxyMessage) {\n                    HAProxyMessage message = (HAProxyMessage) msg;\n                    inetAddress.set(new InetSocketAddress(message.sourceAddress(), message.sourcePort()));\n                    channelWrapperAccessor.get(channel.pipeline().get(HandlerBoss.class)).setRemoteAddress(inetAddress.get());\n                } else {\n                    super.channelRead(ctx, msg);\n                }\n            }\n        });\n    }\n", "    public void addKeepAlivePacketHandler(Channel channel, AtomicReference<InetSocketAddress> inetAddress, NeoProtectPlugin instance) {\n        channel.pipeline().addAfter(PipelineUtils.PACKET_DECODER, \"neo-keep-alive-handler\", new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                super.channelRead(ctx, msg);\n\n                if (!(msg instanceof PacketWrapper)) {\n                    return;\n                }\n                if (!(((PacketWrapper) msg).packet instanceof KeepAlive)) {\n                    return;\n                }\n\n                KeepAlive keepAlive = (KeepAlive) ((PacketWrapper) msg).packet;\n                ConcurrentHashMap<KeepAliveResponseKey, Long> pingMap = instance.getCore().getPingMap();\n\n                instance.getCore().debug(\"Received KeepAlivePackets (\" + keepAlive.getRandomId() + \")\");\n", "                if (!(((PacketWrapper) msg).packet instanceof KeepAlive)) {\n                    return;\n                }\n\n                KeepAlive keepAlive = (KeepAlive) ((PacketWrapper) msg).packet;\n                ConcurrentHashMap<KeepAliveResponseKey, Long> pingMap = instance.getCore().getPingMap();\n\n                instance.getCore().debug(\"Received KeepAlivePackets (\" + keepAlive.getRandomId() + \")\");\n\n                for (KeepAliveResponseKey keepAliveResponseKey : pingMap.keySet()) {\n", "                for (KeepAliveResponseKey keepAliveResponseKey : pingMap.keySet()) {\n\n                    if (!keepAliveResponseKey.getAddress().equals(inetAddress.get()) || !(keepAliveResponseKey.getId() == keepAlive.getRandomId())) {\n                        continue;\n                    }\n\n                    instance.getCore().debug(\"KeepAlivePackets matched to DebugKeepAlivePacket\");\n\n                    for (ProxiedPlayer player : BungeeCord.getInstance().getPlayers()) {\n\n                        if (!(player).getPendingConnection().getSocketAddress().equals(inetAddress.get())) {\n                            continue;\n                        }\n\n                        instance.getCore().debug(\"Player matched to DebugKeepAlivePacket (loading data...)\");\n\n                        EpollTcpInfo tcpInfo = ((EpollSocketChannel) channel).tcpInfo();\n                        EpollTcpInfo tcpInfoBackend = ((EpollSocketChannel) ((UserConnection) player).getServer().getCh().getHandle()).tcpInfo();\n\n                        long ping = System.currentTimeMillis() - pingMap.get(keepAliveResponseKey);\n                        long neoRTT = 0;\n                        long backendRTT = 0;\n", "                    for (ProxiedPlayer player : BungeeCord.getInstance().getPlayers()) {\n\n                        if (!(player).getPendingConnection().getSocketAddress().equals(inetAddress.get())) {\n                            continue;\n                        }\n\n                        instance.getCore().debug(\"Player matched to DebugKeepAlivePacket (loading data...)\");\n\n                        EpollTcpInfo tcpInfo = ((EpollSocketChannel) channel).tcpInfo();\n                        EpollTcpInfo tcpInfoBackend = ((EpollSocketChannel) ((UserConnection) player).getServer().getCh().getHandle()).tcpInfo();\n\n                        long ping = System.currentTimeMillis() - pingMap.get(keepAliveResponseKey);\n                        long neoRTT = 0;\n                        long backendRTT = 0;\n", "                        if (tcpInfo != null) {\n                            neoRTT = tcpInfo.rtt() / 1000;\n                        }\n                        if (tcpInfoBackend != null) {\n                            backendRTT = tcpInfoBackend.rtt() / 1000;\n                        }\n\n                        ConcurrentHashMap<String, ArrayList<DebugPingResponse>> map = instance.getCore().getDebugPingResponses();\n\n                        if (!map.containsKey(player.getName())) {\n                            instance.getCore().getDebugPingResponses().put(player.getName(), new ArrayList<>());\n                        }\n\n                        map.get(player.getName()).add(new DebugPingResponse(ping, neoRTT, backendRTT, inetAddress.get(), channel.remoteAddress()));\n\n                        instance.getCore().debug(\"Loading completed\");\n                        instance.getCore().debug(\" \");\n                    }\n                    instance.getCore().getPingMap().remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n", "                        if (!map.containsKey(player.getName())) {\n                            instance.getCore().getDebugPingResponses().put(player.getName(), new ArrayList<>());\n                        }\n\n                        map.get(player.getName()).add(new DebugPingResponse(ping, neoRTT, backendRTT, inetAddress.get(), channel.remoteAddress()));\n\n                        instance.getCore().debug(\"Loading completed\");\n                        instance.getCore().debug(\" \");\n                    }\n                    instance.getCore().getPingMap().remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n", "    public static boolean isIPInRange(String ipRange, String ipAddress) {\n        if (!ipRange.contains(\"/\")) {\n            ipRange = ipRange + \"/32\";\n        }\n\n        long targetIntAddress = ipToDecimal(ipAddress);\n\n        int range = Integer.parseInt(ipRange.split(\"/\")[1]);\n        String startIP = ipRange.split(\"/\")[0];\n\n        long startIntAddress = ipToDecimal(startIP);\n\n        return targetIntAddress <= (startIntAddress + (long) Math.pow(2, (32 - range))) && targetIntAddress >= startIntAddress;\n    }\n", "    public static long ipToDecimal(String ipAddress) throws IllegalArgumentException {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return -1;\n        }\n\n        long decimal = 0;\n        for (int i = 0; i < 4; i++) {\n            int octet = Integer.parseInt(parts[i]);\n            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n", "            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/proxyprotocol/Reflection.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.proxyprotocol;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**", "\n/**\n * @author Kristian\n */\npublic final class Reflection {\n    /**\n     * An interface for invoking a specific constructor.\n     */\n    public interface ConstructorInvoker {\n        /**\n         * Invoke a constructor for a specific class.\n         *\n         * @param arguments - the arguments to pass to the constructor.\n         * @return The constructed object.\n         */\n        Object invoke(Object... arguments);\n    }\n\n    /**\n     * An interface for invoking a specific method.\n     */", "    public interface ConstructorInvoker {\n        /**\n         * Invoke a constructor for a specific class.\n         *\n         * @param arguments - the arguments to pass to the constructor.\n         * @return The constructed object.\n         */\n        Object invoke(Object... arguments);\n    }\n\n    /**\n     * An interface for invoking a specific method.\n     */", "    public interface MethodInvoker {\n        /**\n         * Invoke a method on a specific target object.\n         *\n         * @param target    - the target object, or NULL for a static method.\n         * @param arguments - the arguments to pass to the method.\n         * @return The return value, or NULL if is void.\n         */\n        Object invoke(Object target, Object... arguments);\n    }\n\n    /**\n     * An interface for retrieving the field content.\n     *\n     * @param <T> - field type.\n     */", "    public interface FieldAccessor<T> {\n        /**\n         * Retrieve the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @return The value of the field.\n         */\n        T get(Object target);\n\n        /**\n         * Set the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @param value  - the new value of the field.\n         */\n        void set(Object target, Object value);\n\n        /**\n         * Determine if the given object has this field.\n         *\n         * @param target - the object to test.\n         * @return TRUE if it does, FALSE otherwise.\n         */\n        boolean hasField(Object target);\n    }\n\n    // Deduce the net.minecraft.server.v* package\n\n\n    // Variable replacement\n    private static final Pattern MATCH_VARIABLE = Pattern.compile(\"\\\\{([^\\\\}]+)\\\\}\");\n\n    private Reflection() {\n        // Seal class\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> Reflection.FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType) {\n        return getField(target, name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> Reflection.FieldAccessor<T> getField(String className, String name, Class<T> fieldType) {\n        return getField(getClass(className), name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> Reflection.FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, int index) {\n        return getField(target, null, fieldType, index);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> Reflection.FieldAccessor<T> getField(String className, Class<T> fieldType, int index) {\n        return getField(getClass(className), fieldType, index);\n    }\n\n    // Common method\n    private static <T> Reflection.FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType, int index) {", "        for (final Field field : target.getDeclaredFields()) {\n            if ((name == null || field.getName().equals(name)) && fieldType.isAssignableFrom(field.getType()) && index-- <= 0) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new Reflection.FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")\n                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes", "                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes\n        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), name, fieldType, index);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    public static <T> Reflection.FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, String fieldContainedName) {", "        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), name, fieldType, index);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    public static <T> Reflection.FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, String fieldContainedName) {\n        for (final Field field : target.getDeclaredFields()) {\n            if (fieldType.isAssignableFrom(field.getType()) && field.getName().contains(fieldContainedName)) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new Reflection.FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")", "            if (fieldType.isAssignableFrom(field.getType()) && field.getName().contains(fieldContainedName)) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new Reflection.FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")\n                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes", "                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes\n        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), fieldType, fieldContainedName);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param className  - lookup name of the class, see {@link #getClass(String)}.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), fieldType, fieldContainedName);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param className  - lookup name of the class, see {@link #getClass(String)}.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static Reflection.MethodInvoker getMethod(String className, String methodName, Class<?>... params) {\n        return getTypedMethod(getClass(className), methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static Reflection.MethodInvoker getMethod(Class<?> clazz, String methodName, Class<?>... params) {\n        return getTypedMethod(clazz, methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param returnType - the expected return type, or NULL to ignore.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static Reflection.MethodInvoker getTypedMethod(Class<?> clazz, String methodName, Class<?> returnType, Class<?>... params) {\n        for (final Method method : clazz.getDeclaredMethods()) {\n            if ((methodName == null || method.getName().equals(methodName))\n                    && (returnType == null || method.getReturnType().equals(returnType))\n                    && Arrays.equals(method.getParameterTypes(), params)) {\n                method.setAccessible(true);\n\n                return (target, arguments) -> {\n                    try {\n                        return method.invoke(target, arguments);\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Cannot invoke method \" + method, e);\n                    }\n                };\n            }\n        }\n\n        // Search in every superclass", "                    try {\n                        return method.invoke(target, arguments);\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Cannot invoke method \" + method, e);\n                    }\n                };\n            }\n        }\n\n        // Search in every superclass\n        if (clazz.getSuperclass() != null)\n            return getMethod(clazz.getSuperclass(), methodName, params);\n\n        throw new IllegalStateException(String.format(\"Unable to find method %s (%s).\", methodName, Arrays.asList(params)));\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param params    - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "        if (clazz.getSuperclass() != null)\n            return getMethod(clazz.getSuperclass(), methodName, params);\n\n        throw new IllegalStateException(String.format(\"Unable to find method %s (%s).\", methodName, Arrays.asList(params)));\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param params    - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static Reflection.ConstructorInvoker getConstructor(String className, Class<?>... params) {\n        return getConstructor(getClass(className), params);\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param clazz  - a class to start with.\n     * @param params - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static Reflection.ConstructorInvoker getConstructor(Class<?> clazz, Class<?>... params) {\n        for (final Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n            if (Arrays.equals(constructor.getParameterTypes(), params)) {\n                constructor.setAccessible(true);\n\n                return arguments -> {\n                    try {\n                        return constructor.newInstance(arguments);\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Cannot invoke constructor \" + constructor, e);\n                    }\n                };\n            }\n        }\n\n        throw new IllegalStateException(String.format(\"Unable to find constructor for %s (%s).\", clazz, Arrays.asList(params)));\n    }\n\n    /**\n     * Retrieve a class from its full name, without knowing its type on compile time.\n     * <p>\n     * This is useful when looking up fields by a NMS or OBC type.\n     * <p>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The class.\n     * @see {@link #getClass()} for more information.\n     */", "    public static Class<Object> getUntypedClass(String lookupName) {\n        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n        Class<Object> clazz = (Class) getClass(lookupName);\n        return clazz;\n    }\n\n\n    /**\n     * @param lookupName - the class name with variables.\n     * @return The looked up class.\n     * @throws IllegalArgumentException If a variable or class could not be found.\n     */", "    public static Class<?> getClass(String lookupName) {\n        return getCanonicalClass(expandVariables(lookupName));\n    }\n\n    /**\n     * Retrieve a class by its canonical name.\n     *\n     * @param canonicalName - the canonical name.\n     * @return The class.\n     */\n    private static Class<?> getCanonicalClass(String canonicalName) {", "        try {\n            return Class.forName(canonicalName);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Cannot find \" + canonicalName, e);\n        }\n    }\n\n    /**\n     * Expand variables such as \"{nms}\" and \"{obc}\" to their corresponding packages.\n     *\n     * @param name - the full name of the class.\n     * @return The expanded string.\n     */", "    public static String expandVariables(String name) {\n        StringBuffer output = new StringBuffer();\n        Matcher matcher = MATCH_VARIABLE.matcher(name);\n        matcher.appendTail(output);\n        return output.toString();\n    }\n}\n\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/command/NeoProtectCommand.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.command;\n\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport net.md_5.bungee.api.CommandSender;\nimport net.md_5.bungee.api.connection.ProxiedPlayer;\nimport net.md_5.bungee.api.plugin.Command;\nimport net.md_5.bungee.api.plugin.TabExecutor;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\n\npublic class NeoProtectCommand extends Command implements TabExecutor {\n\n    private final NeoProtectPlugin instance;\n\n    public NeoProtectCommand(NeoProtectPlugin instance, String name, String permission, String... aliases) {\n        super(name, permission, aliases);\n        this.instance = instance;\n    }\n\n    @Override", "    public void execute(CommandSender sender, String[] args) {\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .viaConsole(!(sender instanceof ProxiedPlayer))\n                .local((sender instanceof ProxiedPlayer) ? ((ProxiedPlayer) sender).getLocale() : Locale.ENGLISH)\n                .neoProtectPlugin(instance)\n                .sender(sender)\n                .args(args)\n                .executeCommand();\n    }\n\n    @Override\n    public Iterable<String> onTabComplete(CommandSender commandSender, String[] args) {\n        List<String> list = new ArrayList<>();\n        List<String> completorList = new ArrayList<>();\n", "        if (args.length == 2) {\n            if (args[0].equalsIgnoreCase(\"debugtool\")) {\n                for (int i = 10; i <= 100; i = i + 10) {\n                    list.add(String.valueOf(i));\n                }\n                list.add(\"cancel\");\n            }\n\n            if ((args[0].equalsIgnoreCase(\"whitelist\") || args[0].equalsIgnoreCase(\"blacklist\"))) {\n                list.add(\"add\");\n                list.add(\"remove\");\n            }\n", "            if ((args[0].equalsIgnoreCase(\"whitelist\") || args[0].equalsIgnoreCase(\"blacklist\"))) {\n                list.add(\"add\");\n                list.add(\"remove\");\n            }\n\n            if (args[0].equalsIgnoreCase(\"toggle\")) {\n                list.add(\"antiVPN\");\n                list.add(\"anycast\");\n                list.add(\"motdCache\");\n                list.add(\"blockForge\");\n                list.add(\"ipWhitelist\");\n                list.add(\"ipBlacklist\");\n                list.add(\"secureProfiles\");\n                list.add(\"advancedAntiBot\");\n            }\n        }\n", "        if (args.length <= 1) {\n\n            list.add(\"setup\");\n\n            if (instance.getCore().isSetup()) {\n                list.add(\"directConnectWhitelist\");\n                list.add(\"setgameshield\");\n                list.add(\"setbackend\");\n                list.add(\"analytics\");\n                list.add(\"debugTool\");\n                list.add(\"whitelist\");\n                list.add(\"blacklist\");\n                list.add(\"ipanic\");\n                list.add(\"toggle\");\n            }\n        }\n", "        for (String tab : list) {\n\n            if (args.length == 0) {\n                completorList.add(tab);\n                continue;\n            }\n\n            if (tab.toLowerCase().startsWith(args[args.length - 1].toLowerCase())) {\n                completorList.add(tab);\n            }\n        }\n        return completorList;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/listener/ChatListener.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.listener;\n\nimport de.cubeattack.neoprotect.bungee.NeoProtectBungee;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport net.md_5.bungee.api.CommandSender;\nimport net.md_5.bungee.api.connection.ProxiedPlayer;\nimport net.md_5.bungee.api.event.ChatEvent;\nimport net.md_5.bungee.api.plugin.Listener;\nimport net.md_5.bungee.event.EventHandler;\n\npublic class ChatListener implements Listener {\n\n    private final NeoProtectBungee instance;\n\n    public ChatListener(NeoProtectBungee instance) {\n        this.instance = instance;\n    }\n\n    @EventHandler", "import net.md_5.bungee.event.EventHandler;\n\npublic class ChatListener implements Listener {\n\n    private final NeoProtectBungee instance;\n\n    public ChatListener(NeoProtectBungee instance) {\n        this.instance = instance;\n    }\n\n    @EventHandler", "    public void onChat(ChatEvent event) {\n        CommandSender sender = (CommandSender) event.getSender();\n\n        if (!sender.hasPermission(\"neoprotect.admin\") || !instance.getCore().getPlayerInSetup().contains(sender) || event.isCommand())\n            return;\n\n        event.setCancelled(true);\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .local(((ProxiedPlayer) sender).getLocale())\n                .neoProtectPlugin(instance)\n                .sender(event.getSender())\n                .msg(event.getMessage())\n                .executeChatEvent();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/listener/DisconnectListener.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.listener;\n\nimport de.cubeattack.neoprotect.bungee.NeoProtectBungee;\nimport net.md_5.bungee.api.event.PlayerDisconnectEvent;\nimport net.md_5.bungee.api.plugin.Listener;\nimport net.md_5.bungee.event.EventHandler;\n\npublic class DisconnectListener implements Listener {\n\n    private final NeoProtectBungee instance;\n\n    public DisconnectListener(NeoProtectBungee instance) {\n        this.instance = instance;\n    }\n\n    @EventHandler", "    public void onDisconnect(PlayerDisconnectEvent event) {\n        instance.getCore().getPlayerInSetup().remove(event.getPlayer());\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/bungee/listener/LoginListener.java", "chunked_list": ["package de.cubeattack.neoprotect.bungee.listener;\n\nimport de.cubeattack.api.language.Localization;\nimport de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.bungee.NeoProtectBungee;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport net.md_5.bungee.api.connection.ProxiedPlayer;\nimport net.md_5.bungee.api.event.PostLoginEvent;\nimport net.md_5.bungee.api.plugin.Listener;", "import net.md_5.bungee.api.event.PostLoginEvent;\nimport net.md_5.bungee.api.plugin.Listener;\nimport net.md_5.bungee.event.EventHandler;\n\nimport java.text.MessageFormat;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class LoginListener implements Listener {\n\n    private final NeoProtectBungee instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectBungee instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @EventHandler(priority = 6)", "import java.util.TimerTask;\n\npublic class LoginListener implements Listener {\n\n    private final NeoProtectBungee instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectBungee instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @EventHandler(priority = 6)", "    public void onLogin(PostLoginEvent event) {\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                ProxiedPlayer player = event.getPlayer();\n                Locale locale = (player.getLocale() != null) ? player.getLocale() : Locale.ENGLISH;\n\n                if (!player.hasPermission(\"neoprotect.admin\") && !instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfig().isOnlineMode()))\n                    return;\n\n                VersionUtils.Result result = instance.getCore().getVersionResult();", "                if (result.getVersionStatus().equals(VersionUtils.VersionStatus.OUTDATED)) {\n                    instance.sendMessage(player, localization.get(locale, result.getCurrentVersion(), result.getLatestVersion()));\n                    instance.sendMessage(player, MessageFormat.format(\"\u00a77-> \u00a7b{0}\",\n                                    result.getReleaseUrl().replace(\"/NeoPlugin\", \"\").replace(\"/releases/tag\", \"\")),\n                            \"OPEN_URL\", result.getReleaseUrl(), null, null);\n                }\n\n                if (result.getVersionStatus().equals(VersionUtils.VersionStatus.REQUIRED_RESTART)) {\n                    instance.sendMessage(player, localization.get(locale, \"plugin.restart-required.message\", result.getCurrentVersion(), result.getLatestVersion()));\n                }\n", "                if (!instance.getCore().isSetup() && instance.getCore().getPlayerInSetup().isEmpty()) {\n                    instance.sendMessage(player, localization.get(locale, \"setup.required.first\"));\n                    instance.sendMessage(player, localization.get(locale, \"setup.required.second\"));\n                }\n\n                if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfig().isOnlineMode())) {\n                    Stats stats = instance.getStats();\n                    String infos =\n                            \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                                    \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                                    \"\u00a7bPluginVersion\u00a77: \" + stats.getPluginVersion() + \" \\n\" +\n                                    \"\u00a7bVersionStatus\u00a77: \" + instance.getCore().getVersionResult().getVersionStatus() + \" \\n\" +\n                                    \"\u00a7bUpdateSetting\u00a77: \" + Config.getAutoUpdaterSettings() + \" \\n\" +\n                                    \"\u00a7bProxyProtocol\u00a77: \" + Config.isProxyProtocol() + \" \\n\" +\n                                    \"\u00a7bNeoProtectPlan\u00a77: \" + (instance.getCore().isSetup() ? instance.getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\") + \" \\n\" +\n                                    \"\u00a7bBungeecordName\u00a77: \" + stats.getServerName() + \" \\n\" +\n                                    \"\u00a7bBungeecordVersion\u00a77: \" + stats.getServerVersion()+ \" \\n\" +\n                                    \"\u00a7bBungeecordPlugins\u00a77: \" + Arrays.toString(instance.getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray());\n\n                    instance.sendMessage(player, \"\u00a7bHello \" + player.getName() + \" ;)\", null, null, \"SHOW_TEXT\", infos);\n                    instance.sendMessage(player, \"\u00a7bThis server uses your NeoPlugin\", null, null, \"SHOW_TEXT\", infos);\n                }\n            }\n        }, 500);\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/Startup.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity;\n\nimport com.velocitypowered.api.command.CommandManager;\nimport com.velocitypowered.api.event.EventManager;\nimport de.cubeattack.neoprotect.velocity.command.NeoProtectCommand;\nimport de.cubeattack.neoprotect.velocity.listener.ChatListener;\nimport de.cubeattack.neoprotect.velocity.listener.DisconnectListener;\nimport de.cubeattack.neoprotect.velocity.listener.LoginListener;\nimport de.cubeattack.neoprotect.velocity.messageunsign.JoinListener;\nimport de.cubeattack.neoprotect.velocity.messageunsign.SessionChatListener;", "import de.cubeattack.neoprotect.velocity.messageunsign.JoinListener;\nimport de.cubeattack.neoprotect.velocity.messageunsign.SessionChatListener;\nimport de.cubeattack.neoprotect.velocity.proxyprotocol.ProxyProtocol;\n\npublic class Startup {\n\n    public Startup(NeoProtectVelocity instance) {\n        register(instance);\n        new ProxyProtocol(instance);\n    }\n\n    private void register(NeoProtectVelocity instance) {\n        EventManager em = instance.getProxy().getEventManager();\n        CommandManager cm = instance.getProxy().getCommandManager();\n\n        cm.register(cm.metaBuilder(\"neoprotect\").aliases(\"np\").build(), new NeoProtectCommand(instance));\n\n        em.register(instance, new ChatListener(instance));\n        em.register(instance, new JoinListener(instance));\n        em.register(instance, new LoginListener(instance));\n        em.register(instance, new DisconnectListener(instance));\n        em.register(instance, new SessionChatListener(instance));\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/NeoProtectVelocity.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity;\n\nimport com.google.inject.Inject;\nimport com.velocitypowered.api.command.CommandSource;\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.proxy.ProxyInitializeEvent;\nimport com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.api.proxy.ProxyServer;\nimport com.velocitypowered.proxy.connection.client.ConnectedPlayer;\nimport com.velocitypowered.proxy.protocol.packet.KeepAlive;", "import com.velocitypowered.proxy.connection.client.ConnectedPlayer;\nimport com.velocitypowered.proxy.protocol.packet.KeepAlive;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.Core;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.Permission;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport de.cubeattack.neoprotect.core.model.debugtool.KeepAliveResponseKey;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.TextComponent;", "import net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.TextComponent;\nimport net.kyori.adventure.text.event.ClickEvent;\nimport net.kyori.adventure.text.event.HoverEvent;\nimport org.bstats.charts.SimplePie;\nimport org.bstats.velocity.Metrics;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Objects;", "import java.util.Arrays;\nimport java.util.Objects;\nimport java.util.logging.Logger;\n\npublic class NeoProtectVelocity implements NeoProtectPlugin {\n\n    private final Metrics.Factory metricsFactory;\n    private final Logger logger;\n    private final ProxyServer proxy;\n    private Core core;\n\n    @Inject\n    public NeoProtectVelocity(ProxyServer proxy, Logger logger, Metrics.Factory metricsFactory) {\n        this.proxy = proxy;\n        this.logger = logger;\n        this.metricsFactory = metricsFactory;\n    }\n\n    @Subscribe", "    public void onProxyInitialize(ProxyInitializeEvent event) {\n        Metrics metrics = metricsFactory.make(this, 18727);\n        metrics.addCustomChart(new SimplePie(\"language\", Config::getLanguage));\n        core = new Core(this);\n        new Startup(this);\n    }\n\n    public Core getCore() {\n        return core;\n    }\n\n    @Override", "    public Stats getStats() {\n        return new Stats(\n                getPluginType(),\n                getProxy().getVersion().getVersion(),\n                getProxy().getVersion().getName(),\n                System.getProperty(\"java.version\"),\n                System.getProperty(\"os.name\"),\n                System.getProperty(\"os.arch\"),\n                System.getProperty(\"os.version\"),\n                getPluginVersion(),\n                getCore().getVersionResult().getVersionStatus().toString(),\n                Config.getAutoUpdaterSettings().toString(),\n                getCore().isSetup() ? getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\",\n                Arrays.toString(getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray()),\n                getProxy().getPlayerCount(),\n                getProxy().getAllServers().size(),\n                Runtime.getRuntime().availableProcessors(),\n                getProxy().getConfiguration().isOnlineMode(),\n                Config.isProxyProtocol()\n        );\n    }\n", "    public ProxyServer getProxy() {\n        return proxy;\n    }\n\n    @Override\n    public void sendMessage(Object receiver, String text) {\n        sendMessage(receiver, text, null, null, null, null);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")", "    public void sendMessage(Object receiver, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        TextComponent msg = Component.text(core.getPrefix() + text);\n\n        if (clickAction != null)\n            msg = msg.clickEvent(ClickEvent.clickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));\n        if (hoverAction != null)\n            msg = msg.hoverEvent(HoverEvent.hoverEvent((HoverEvent.Action<Object>) Objects.requireNonNull(HoverEvent.Action.NAMES.value(hoverAction.toLowerCase())),\n                    Component.text(hoverMsg)));\n\n        if (receiver instanceof CommandSource) ((CommandSource) receiver).sendMessage(msg);\n    }\n\n    @Override", "        if (receiver instanceof CommandSource) ((CommandSource) receiver).sendMessage(msg);\n    }\n\n    @Override\n    public void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        getProxy().getAllPlayers().forEach(receiver -> {\n            if (receiver.hasPermission(\"neoprotect.admin\") || receiver.hasPermission(permission.value))\n                sendMessage(receiver, text, clickAction, clickMsg, hoverAction, hoverMsg);\n        });\n    }\n\n    @Override", "    public void sendKeepAliveMessage(Object receiver, long id) {\n        if (receiver instanceof Player) {\n            KeepAlive keepAlive = new KeepAlive();\n            keepAlive.setRandomId(id);\n            ((ConnectedPlayer) receiver).getConnection().getChannel().writeAndFlush(keepAlive);\n            getCore().getPingMap().put(new KeepAliveResponseKey(((Player) receiver).getRemoteAddress(), id), System.currentTimeMillis());\n        }\n    }\n\n    @Override\n    public long sendKeepAliveMessage(long id) {", "    public long sendKeepAliveMessage(long id) {\n        for (Player player : this.proxy.getAllPlayers()) {\n            sendKeepAliveMessage(player, id);\n        }\n        return id;\n    }\n\n    @Override\n    public Logger getLogger() {\n        return logger;\n    }\n\n    @Override\n    public ArrayList<String> getPlugins() {\n        ArrayList<String> plugins = new ArrayList<>();\n        getProxy().getPluginManager().getPlugins().forEach(p -> plugins.add(p.getDescription().getName().orElseThrow(null)));\n        return plugins;\n    }\n\n    @Override", "    public Logger getLogger() {\n        return logger;\n    }\n\n    @Override\n    public ArrayList<String> getPlugins() {\n        ArrayList<String> plugins = new ArrayList<>();\n        getProxy().getPluginManager().getPlugins().forEach(p -> plugins.add(p.getDescription().getName().orElseThrow(null)));\n        return plugins;\n    }\n\n    @Override", "    public PluginType getPluginType() {\n        return PluginType.VELOCITY;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        return proxy.getPluginManager().ensurePluginContainer(this).getDescription().getVersion().orElse(\"\");\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/proxyprotocol/ProxyProtocol.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.proxyprotocol;\n\nimport com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.proxy.VelocityServer;\nimport com.velocitypowered.proxy.connection.MinecraftConnection;\nimport com.velocitypowered.proxy.connection.client.ConnectedPlayer;\nimport com.velocitypowered.proxy.network.ConnectionManager;\nimport com.velocitypowered.proxy.network.Connections;\nimport com.velocitypowered.proxy.network.ServerChannelInitializerHolder;\nimport com.velocitypowered.proxy.protocol.packet.KeepAlive;", "import com.velocitypowered.proxy.network.ServerChannelInitializerHolder;\nimport com.velocitypowered.proxy.protocol.packet.KeepAlive;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.model.debugtool.DebugPingResponse;\nimport de.cubeattack.neoprotect.core.model.debugtool.KeepAliveResponseKey;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;", "import io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.epoll.EpollSocketChannel;\nimport io.netty.channel.epoll.EpollTcpInfo;\nimport io.netty.handler.codec.haproxy.HAProxyMessage;\nimport io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n\nimport java.lang.reflect.Field;\nimport java.net.InetSocketAddress;", "import java.lang.reflect.Field;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.ArrayList;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.logging.Level;\n\npublic class ProxyProtocol {\n\n    private final Reflection.MethodInvoker initChannelMethod = Reflection.getMethod(ChannelInitializer.class, \"initChannel\", Channel.class);\n\n    public ProxyProtocol(NeoProtectVelocity instance) {\n\n        instance.getLogger().info(\"Proceeding with the server channel injection...\");\n", "public class ProxyProtocol {\n\n    private final Reflection.MethodInvoker initChannelMethod = Reflection.getMethod(ChannelInitializer.class, \"initChannel\", Channel.class);\n\n    public ProxyProtocol(NeoProtectVelocity instance) {\n\n        instance.getLogger().info(\"Proceeding with the server channel injection...\");\n\n        try {\n\n            VelocityServer velocityServer = (VelocityServer) instance.getProxy();\n            Reflection.FieldAccessor<ConnectionManager> connectionManagerFieldAccessor = Reflection.getField(VelocityServer.class, ConnectionManager.class, 0);\n            ConnectionManager connectionManager = connectionManagerFieldAccessor.get(velocityServer);\n            ChannelInitializer<?> oldInitializer = connectionManager.getServerChannelInitializer().get();\n\n            ChannelInitializer<Channel> channelInitializer = new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel channel) {\n", "        try {\n\n            VelocityServer velocityServer = (VelocityServer) instance.getProxy();\n            Reflection.FieldAccessor<ConnectionManager> connectionManagerFieldAccessor = Reflection.getField(VelocityServer.class, ConnectionManager.class, 0);\n            ConnectionManager connectionManager = connectionManagerFieldAccessor.get(velocityServer);\n            ChannelInitializer<?> oldInitializer = connectionManager.getServerChannelInitializer().get();\n\n            ChannelInitializer<Channel> channelInitializer = new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel channel) {\n", "                    try {\n\n                        instance.getCore().debug(\"Open channel (\" + channel.remoteAddress().toString() + \")\");\n\n                        initChannelMethod.getMethod().setAccessible(true);\n                        initChannelMethod.invoke(oldInitializer, channel);\n\n                        AtomicReference<InetSocketAddress> playerAddress = new AtomicReference<>();\n                        String sourceAddress = ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress();\n\n                        if (channel.localAddress().toString().startsWith(\"local:\") || sourceAddress.equals(Config.getGeyserServerIP())) {\n                            instance.getCore().debug(\"Detected bedrock player (return)\");\n                            return;\n                        }\n", "                        if (channel.localAddress().toString().startsWith(\"local:\") || sourceAddress.equals(Config.getGeyserServerIP())) {\n                            instance.getCore().debug(\"Detected bedrock player (return)\");\n                            return;\n                        }\n\n                        if (!instance.getCore().getDirectConnectWhitelist().contains(sourceAddress)) {\n                            if (instance.getCore().isSetup() && (instance.getCore().getRestAPI().getNeoServerIPs() == null ||\n                                    instance.getCore().getRestAPI().getNeoServerIPs().toList().stream().noneMatch(ipRange -> isIPInRange((String) ipRange, sourceAddress)))) {\n                                channel.close();\n                                instance.getCore().debug(\"Close connection IP (\" + channel.remoteAddress() + \") doesn't match to Neo-IPs (close / return)\");\n                                return;\n                            }\n\n                            instance.getCore().debug(\"Adding handler...\");\n", "                            if (instance.getCore().isSetup() && Config.isProxyProtocol()) {\n                                addProxyProtocolHandler(channel, playerAddress);\n                                instance.getCore().debug(\"Plugin is setup & ProxyProtocol is on (Added proxyProtocolHandler)\");\n                            }\n\n                            addKeepAlivePacketHandler(channel, playerAddress, velocityServer, instance);\n                            instance.getCore().debug(\"Added KeepAlivePacketHandler\");\n                        }\n\n                        instance.getCore().debug(\"Connecting finished\");\n\n                    } catch (Exception ex) {\n                        instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);\n                    }\n                }\n            };\n\n            ServerChannelInitializerHolder newChannelHolder = (ServerChannelInitializerHolder) Reflection.getConstructor(ServerChannelInitializerHolder.class, ChannelInitializer.class).invoke(channelInitializer);\n            Reflection.FieldAccessor<ServerChannelInitializerHolder> serverChannelInitializerHolderFieldAccessor = Reflection.getField(ConnectionManager.class, ServerChannelInitializerHolder.class, 0);\n            Field channelInitializerHolderField = serverChannelInitializerHolderFieldAccessor.getField();\n\n            channelInitializerHolderField.setAccessible(true);\n            channelInitializerHolderField.set(connectionManager, newChannelHolder);\n\n            instance.getLogger().info(\"Found the server channel and added the handler. Injection successfully!\");\n\n        } catch (Exception ex) {\n            instance.getLogger().log(Level.SEVERE, \"An unknown error has occurred\", ex);\n        }\n    }\n", "    public void addProxyProtocolHandler(Channel channel, AtomicReference<InetSocketAddress> inetAddress) {\n        channel.pipeline().names().forEach((n) -> {\n            if (n.equals(\"HAProxyMessageDecoder#0\"))\n                channel.pipeline().remove(\"HAProxyMessageDecoder#0\");\n            if (n.equals(\"ProxyProtocol$1#0\"))\n                channel.pipeline().remove(\"ProxyProtocol$1#0\");\n        });\n\n        channel.pipeline().addFirst(\"haproxy-decoder\", new HAProxyMessageDecoder());\n        channel.pipeline().addAfter(\"haproxy-decoder\", \"haproxy-handler\", new ChannelInboundHandlerAdapter() {\n            @Override", "            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof HAProxyMessage) {\n                    HAProxyMessage message = (HAProxyMessage) msg;\n                    Reflection.FieldAccessor<SocketAddress> fieldAccessor = Reflection.getField(MinecraftConnection.class, SocketAddress.class, 0);\n                    inetAddress.set(new InetSocketAddress(message.sourceAddress(), message.sourcePort()));\n                    fieldAccessor.set(channel.pipeline().get(Connections.HANDLER), inetAddress.get());\n                } else {\n                    super.channelRead(ctx, msg);\n                }\n            }\n        });\n    }\n", "    public void addKeepAlivePacketHandler(Channel channel, AtomicReference<InetSocketAddress> inetAddress, VelocityServer velocityServer, NeoProtectPlugin instance) {\n\n        channel.pipeline().addAfter(\"minecraft-decoder\", \"neo-keep-alive-handler\", new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                super.channelRead(ctx, msg);\n\n                if (!(msg instanceof KeepAlive)) {\n                    return;\n                }\n\n                KeepAlive keepAlive = (KeepAlive) msg;\n                ConcurrentHashMap<KeepAliveResponseKey, Long> pingMap = instance.getCore().getPingMap();\n\n                instance.getCore().debug(\"Received KeepAlivePackets (\" + keepAlive.getRandomId() + \")\");\n", "                for (KeepAliveResponseKey keepAliveResponseKey : pingMap.keySet()) {\n\n                    if (!keepAliveResponseKey.getAddress().equals(inetAddress.get()) || !(keepAliveResponseKey.getId() == keepAlive.getRandomId())) {\n                        continue;\n                    }\n\n                    instance.getCore().debug(\"KeepAlivePackets matched to DebugKeepAlivePacket\");\n\n                    for (Player player : velocityServer.getAllPlayers()) {\n\n                        if (!(player).getRemoteAddress().equals(inetAddress.get())) {\n                            continue;\n                        }\n\n                        instance.getCore().debug(\"Player matched to DebugKeepAlivePacket (loading data...)\");\n\n                        EpollTcpInfo tcpInfo = ((EpollSocketChannel) channel).tcpInfo();\n                        EpollTcpInfo tcpInfoBackend = ((EpollSocketChannel) ((ConnectedPlayer) player).getConnection().getChannel()).tcpInfo();\n\n                        long ping = System.currentTimeMillis() - pingMap.get(keepAliveResponseKey);\n                        long neoRTT = 0;\n                        long backendRTT = 0;\n", "                    for (Player player : velocityServer.getAllPlayers()) {\n\n                        if (!(player).getRemoteAddress().equals(inetAddress.get())) {\n                            continue;\n                        }\n\n                        instance.getCore().debug(\"Player matched to DebugKeepAlivePacket (loading data...)\");\n\n                        EpollTcpInfo tcpInfo = ((EpollSocketChannel) channel).tcpInfo();\n                        EpollTcpInfo tcpInfoBackend = ((EpollSocketChannel) ((ConnectedPlayer) player).getConnection().getChannel()).tcpInfo();\n\n                        long ping = System.currentTimeMillis() - pingMap.get(keepAliveResponseKey);\n                        long neoRTT = 0;\n                        long backendRTT = 0;\n", "                        if (tcpInfo != null) {\n                            neoRTT = tcpInfo.rtt() / 1000;\n                        }\n                        if (tcpInfoBackend != null) {\n                            backendRTT = tcpInfoBackend.rtt() / 1000;\n                        }\n\n                        ConcurrentHashMap<String, ArrayList<DebugPingResponse>> map = instance.getCore().getDebugPingResponses();\n\n                        if (!map.containsKey(player.getUsername())) {\n                            instance.getCore().getDebugPingResponses().put(player.getUsername(), new ArrayList<>());\n                        }\n\n                        map.get(player.getUsername()).add(new DebugPingResponse(ping, neoRTT, backendRTT, inetAddress.get(), channel.remoteAddress()));\n\n                        instance.getCore().debug(\"Loading completed\");\n                        instance.getCore().debug(\" \");\n\n                    }\n                    pingMap.remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n", "                        if (!map.containsKey(player.getUsername())) {\n                            instance.getCore().getDebugPingResponses().put(player.getUsername(), new ArrayList<>());\n                        }\n\n                        map.get(player.getUsername()).add(new DebugPingResponse(ping, neoRTT, backendRTT, inetAddress.get(), channel.remoteAddress()));\n\n                        instance.getCore().debug(\"Loading completed\");\n                        instance.getCore().debug(\" \");\n\n                    }\n                    pingMap.remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n", "    public static boolean isIPInRange(String ipRange, String ipAddress) {\n        if (!ipRange.contains(\"/\")) {\n            ipRange = ipRange + \"/32\";\n        }\n\n        long targetIntAddress = ipToDecimal(ipAddress);\n\n        int range = Integer.parseInt(ipRange.split(\"/\")[1]);\n        String startIP = ipRange.split(\"/\")[0];\n\n        long startIntAddress = ipToDecimal(startIP);\n\n        return targetIntAddress <= (startIntAddress + (long) Math.pow(2, (32 - range))) && targetIntAddress >= startIntAddress;\n    }\n", "    public static long ipToDecimal(String ipAddress) throws IllegalArgumentException {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return -1;\n        }\n\n        long decimal = 0;\n        for (int i = 0; i < 4; i++) {\n            int octet = Integer.parseInt(parts[i]);\n            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n", "            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/proxyprotocol/Reflection.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.proxyprotocol;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**", "\n/**\n * @author Kristian\n */\npublic final class Reflection {\n    /**\n     * An interface for invoking a specific constructor.\n     */\n    public interface ConstructorInvoker {\n        /**\n         * Invoke a constructor for a specific class.\n         *\n         * @param arguments - the arguments to pass to the constructor.\n         * @return The constructed object.\n         */\n        Object invoke(Object... arguments);\n    }\n\n    /**\n     * An interface for invoking a specific method.\n     */", "    public interface ConstructorInvoker {\n        /**\n         * Invoke a constructor for a specific class.\n         *\n         * @param arguments - the arguments to pass to the constructor.\n         * @return The constructed object.\n         */\n        Object invoke(Object... arguments);\n    }\n\n    /**\n     * An interface for invoking a specific method.\n     */", "    public interface MethodInvoker {\n        /**\n         * Invoke a method on a specific target object.\n         *\n         * @param target    - the target object, or NULL for a static method.\n         * @param arguments - the arguments to pass to the method.\n         * @return The return value, or NULL if is void.\n         */\n        Object invoke(Object target, Object... arguments);\n\n        /**\n         * @return the method itself\n         */\n        Method getMethod();\n    }\n\n    /**\n     * An interface for retrieving the field content.\n     *\n     * @param <T> - field type.\n     */", "    public interface FieldAccessor<T> {\n        /**\n         * Retrieve the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @return The value of the field.\n         */\n        T get(Object target);\n\n        /**\n         * Set the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @param value  - the new value of the field.\n         */\n        void set(Object target, Object value);\n\n        /**\n         * Determine if the given object has this field.\n         *\n         * @param target - the object to test.\n         * @return TRUE if it does, FALSE otherwise.\n         */\n        boolean hasField(Object target);\n\n        /**\n         * Get the actual field\n         *\n         * @return the field\n         */\n        Field getField();\n    }\n\n    // Deduce the net.minecraft.server.v* package\n\n\n    // Variable replacement\n    private static final Pattern MATCH_VARIABLE = Pattern.compile(\"\\\\{([^\\\\}]+)\\\\}\");\n\n    private Reflection() {\n        // Seal class\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType) {\n        return getField(target, name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(String className, String name, Class<T> fieldType) {\n        return getField(getClass(className), name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, int index) {\n        return getField(target, null, fieldType, index);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(String className, Class<T> fieldType, int index) {\n        return getField(getClass(className), fieldType, index);\n    }\n\n    // Common method\n    private static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType, int index) {", "        for (final Field field : target.getDeclaredFields()) {\n            if ((name == null || field.getName().equals(name)) && fieldType.isAssignableFrom(field.getType()) && index-- <= 0) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")\n                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n\n                    @Override", "                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n\n                    @Override\n                    public Field getField() {\n                        return field;\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes", "        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), name, fieldType, index);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    public static <T> FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, String fieldContainedName) {\n        for (final Field field : target.getDeclaredFields()) {\n            if (fieldType.isAssignableFrom(field.getType()) && field.getName().contains(fieldContainedName)) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")", "            if (fieldType.isAssignableFrom(field.getType()) && field.getName().contains(fieldContainedName)) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")\n                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n\n                    @Override", "                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n\n                    @Override\n                    public Field getField() {\n                        return field;\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes", "        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), fieldType, fieldContainedName);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param className  - lookup name of the class, see {@link #getClass(String)}.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getMethod(String className, String methodName, Class<?>... params) {\n        return getTypedMethod(getClass(className), methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getMethod(Class<?> clazz, String methodName, Class<?>... params) {\n        return getTypedMethod(clazz, methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param returnType - the expected return type, or NULL to ignore.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getTypedMethod(Class<?> clazz, String methodName, Class<?> returnType, Class<?>... params) {\n        for (final Method method : clazz.getDeclaredMethods()) {\n            if ((methodName == null || method.getName().equals(methodName))\n                    && (returnType == null || method.getReturnType().equals(returnType))\n                    && Arrays.equals(method.getParameterTypes(), params)) {\n                method.setAccessible(true);\n\n                return new MethodInvoker() {\n\n                    @Override\n                    public Object invoke(Object target, Object... arguments) {", "                    public Object invoke(Object target, Object... arguments) {\n                        try {\n                            return method.invoke(target, arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke method \" + method, e);\n                        }\n                    }\n\n                    @Override\n                    public Method getMethod() {\n                        return method;\n                    }\n                };\n            }\n        }\n\n        // Search in every superclass", "                    public Method getMethod() {\n                        return method;\n                    }\n                };\n            }\n        }\n\n        // Search in every superclass\n        if (clazz.getSuperclass() != null)\n            return getMethod(clazz.getSuperclass(), methodName, params);\n\n        throw new IllegalStateException(String.format(\"Unable to find method %s (%s).\", methodName, Arrays.asList(params)));\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param params    - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "        if (clazz.getSuperclass() != null)\n            return getMethod(clazz.getSuperclass(), methodName, params);\n\n        throw new IllegalStateException(String.format(\"Unable to find method %s (%s).\", methodName, Arrays.asList(params)));\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param params    - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static ConstructorInvoker getConstructor(String className, Class<?>... params) {\n        return getConstructor(getClass(className), params);\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param clazz  - a class to start with.\n     * @param params - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static ConstructorInvoker getConstructor(Class<?> clazz, Class<?>... params) {\n        for (final Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n            if (Arrays.equals(constructor.getParameterTypes(), params)) {\n                constructor.setAccessible(true);\n\n                return new ConstructorInvoker() {\n\n                    @Override\n                    public Object invoke(Object... arguments) {\n                        try {\n                            return constructor.newInstance(arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke constructor \" + constructor, e);\n                        }\n                    }\n\n                };\n            }\n        }\n\n        throw new IllegalStateException(String.format(\"Unable to find constructor for %s (%s).\", clazz, Arrays.asList(params)));\n    }\n\n    /**\n     * Retrieve a class from its full name, without knowing its type on compile time.\n     * <p>\n     * This is useful when looking up fields by a NMS or OBC type.\n     * <p>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The class.\n     * @see {@link #getClass()} for more information.\n     */", "                    public Object invoke(Object... arguments) {\n                        try {\n                            return constructor.newInstance(arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke constructor \" + constructor, e);\n                        }\n                    }\n\n                };\n            }\n        }\n\n        throw new IllegalStateException(String.format(\"Unable to find constructor for %s (%s).\", clazz, Arrays.asList(params)));\n    }\n\n    /**\n     * Retrieve a class from its full name, without knowing its type on compile time.\n     * <p>\n     * This is useful when looking up fields by a NMS or OBC type.\n     * <p>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The class.\n     * @see {@link #getClass()} for more information.\n     */", "    public static Class<Object> getUntypedClass(String lookupName) {\n        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n        Class<Object> clazz = (Class) getClass(lookupName);\n        return clazz;\n    }\n\n\n    /**\n     * @param lookupName - the class name with variables.\n     * @return The looked up class.\n     * @throws IllegalArgumentException If a variable or class could not be found.\n     */", "    public static Class<?> getClass(String lookupName) {\n        return getCanonicalClass(expandVariables(lookupName));\n    }\n\n    /**\n     * Retrieve a class by its canonical name.\n     *\n     * @param canonicalName - the canonical name.\n     * @return The class.\n     */\n    private static Class<?> getCanonicalClass(String canonicalName) {", "        try {\n            return Class.forName(canonicalName);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Cannot find \" + canonicalName, e);\n        }\n    }\n\n    /**\n     * Expand variables such as \"{nms}\" and \"{obc}\" to their corresponding packages.\n     *\n     * @param name - the full name of the class.\n     * @return The expanded string.\n     */", "    public static String expandVariables(String name) {\n        StringBuffer output = new StringBuffer();\n        Matcher matcher = MATCH_VARIABLE.matcher(name);\n\n        while (matcher.find()) {\n            String variable = matcher.group(1);\n            String replacement = \"\";\n            // Assume the expanded variables are all packages, and append a dot\n            if (replacement.length() > 0 && matcher.end() < name.length() && name.charAt(matcher.end()) != '.')\n                replacement += \".\";\n            matcher.appendReplacement(output, Matcher.quoteReplacement(replacement));\n        }\n\n        matcher.appendTail(output);\n        return output.toString();\n    }\n}\n\n", "            if (replacement.length() > 0 && matcher.end() < name.length() && name.charAt(matcher.end()) != '.')\n                replacement += \".\";\n            matcher.appendReplacement(output, Matcher.quoteReplacement(replacement));\n        }\n\n        matcher.appendTail(output);\n        return output.toString();\n    }\n}\n\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/command/NeoProtectCommand.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.command;\n\nimport com.velocitypowered.api.command.SimpleCommand;\nimport com.velocitypowered.api.proxy.Player;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;", "import java.util.List;\nimport java.util.Locale;\nimport java.util.concurrent.CompletableFuture;\n\npublic class NeoProtectCommand implements SimpleCommand {\n\n    private final NeoProtectVelocity instance;\n\n    public NeoProtectCommand(NeoProtectVelocity instance) {\n        this.instance = instance;\n    }\n\n    @Override", "    public void execute(Invocation invocation) {\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .viaConsole(!(invocation.source() instanceof Player))\n                .local((invocation.source() instanceof Player) ? ((Player) invocation.source()).getEffectiveLocale() : Locale.ENGLISH)\n                .neoProtectPlugin(instance)\n                .sender(invocation.source())\n                .args(invocation.arguments())\n                .executeCommand();\n    }\n\n    @Override\n    public List<String> suggest(Invocation invocation) {\n        return SimpleCommand.super.suggest(invocation);\n    }\n\n    @Override\n    public CompletableFuture<List<String>> suggestAsync(Invocation invocation) {\n        return CompletableFuture.supplyAsync(() -> {\n            List<String> list = new ArrayList<>();\n            List<String> completorList = new ArrayList<>();\n            String[] args = invocation.arguments();\n", "            if (args.length == 2) {\n                if (args[0].equalsIgnoreCase(\"debugtool\")) {\n                    for (int i = 10; i <= 100; i = i + 10) {\n                        list.add(String.valueOf(i));\n                    }\n                    list.add(\"cancel\");\n                }\n\n                if ((args[0].equalsIgnoreCase(\"whitelist\") || args[0].equalsIgnoreCase(\"blacklist\"))) {\n                    list.add(\"add\");\n                    list.add(\"remove\");\n                }\n", "                if ((args[0].equalsIgnoreCase(\"whitelist\") || args[0].equalsIgnoreCase(\"blacklist\"))) {\n                    list.add(\"add\");\n                    list.add(\"remove\");\n                }\n\n                if (args[0].equalsIgnoreCase(\"toggle\")) {\n                    list.add(\"antiVPN\");\n                    list.add(\"anycast\");\n                    list.add(\"motdCache\");\n                    list.add(\"blockForge\");\n                    list.add(\"ipWhitelist\");\n                    list.add(\"ipBlacklist\");\n                    list.add(\"secureProfiles\");\n                    list.add(\"advancedAntiBot\");\n                }\n            }\n", "            if (args.length <= 1) {\n\n                list.add(\"setup\");\n\n                if (instance.getCore().isSetup()) {\n                    list.add(\"directConnectWhitelist\");\n                    list.add(\"setgameshield\");\n                    list.add(\"setbackend\");\n                    list.add(\"analytics\");\n                    list.add(\"debugTool\");\n                    list.add(\"whitelist\");\n                    list.add(\"blacklist\");\n                    list.add(\"ipanic\");\n                    list.add(\"toggle\");\n                }\n            }\n", "            for (String tab : list) {\n\n                if (args.length == 0) {\n                    completorList.add(tab);\n                    continue;\n                }\n\n                if (tab.toLowerCase().startsWith(args[args.length - 1].toLowerCase())) {\n                    completorList.add(tab);\n                }\n            }\n\n            return completorList;\n        });\n    }\n\n    @Override", "    public boolean hasPermission(Invocation invocation) {\n        return invocation.source().hasPermission(\"neoprotect.admin\");\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/listener/ChatListener.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.listener;\n\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.player.PlayerChatEvent;\nimport com.velocitypowered.api.proxy.Player;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\n\npublic class ChatListener {\n\n    private final NeoProtectVelocity instance;\n\n    public ChatListener(NeoProtectVelocity instance) {\n        this.instance = instance;\n    }\n\n    @Subscribe", "public class ChatListener {\n\n    private final NeoProtectVelocity instance;\n\n    public ChatListener(NeoProtectVelocity instance) {\n        this.instance = instance;\n    }\n\n    @Subscribe\n    public void onChat(PlayerChatEvent event) {\n\n        Player player = event.getPlayer();\n", "    public void onChat(PlayerChatEvent event) {\n\n        Player player = event.getPlayer();\n\n        if (!player.hasPermission(\"neoprotect.admin\") || !instance.getCore().getPlayerInSetup().contains(player))\n            return;\n\n        event.setResult(PlayerChatEvent.ChatResult.denied());\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .local(player.getEffectiveLocale())\n                .neoProtectPlugin(instance)\n                .sender(event.getPlayer())\n                .msg(event.getMessage())\n                .executeChatEvent();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/listener/DisconnectListener.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.listener;\n\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.connection.DisconnectEvent;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\n\npublic class DisconnectListener {\n\n    private final NeoProtectVelocity instance;\n\n    public DisconnectListener(NeoProtectVelocity instance) {\n        this.instance = instance;\n    }\n\n    @Subscribe", "    public void onDisconnect(DisconnectEvent event) {\n        instance.getCore().getPlayerInSetup().remove(event.getPlayer());\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/listener/LoginListener.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.listener;\n\nimport com.velocitypowered.api.event.PostOrder;\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.connection.PostLoginEvent;\nimport com.velocitypowered.api.proxy.Player;\nimport de.cubeattack.api.language.Localization;\nimport de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.model.Stats;", "import de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\n\nimport java.text.MessageFormat;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class LoginListener {\n\n    private final NeoProtectVelocity instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectVelocity instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @Subscribe(order = PostOrder.LAST)", "import java.util.TimerTask;\n\npublic class LoginListener {\n\n    private final NeoProtectVelocity instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectVelocity instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @Subscribe(order = PostOrder.LAST)", "    public void onPostLogin(PostLoginEvent event) {\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                Player player = event.getPlayer();\n                Locale locale = (player.getEffectiveLocale() != null) ? player.getEffectiveLocale() : Locale.ENGLISH;\n\n                if (!player.hasPermission(\"neoprotect.admin\") && !instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode()))\n                    return;\n\n                VersionUtils.Result result = instance.getCore().getVersionResult();", "                if (result.getVersionStatus().equals(VersionUtils.VersionStatus.OUTDATED)) {\n                    instance.sendMessage(player, localization.get(locale, \"plugin.outdated.message\", result.getCurrentVersion(), result.getLatestVersion()));\n                    instance.sendMessage(player, MessageFormat.format(\"\u00a77-> \u00a7b{0}\",\n                                    result.getReleaseUrl().replace(\"/NeoPlugin\", \"\").replace(\"/releases/tag\", \"\")),\n                            \"OPEN_URL\", result.getReleaseUrl(), null, null);\n                }\n\n                if (result.getVersionStatus().equals(VersionUtils.VersionStatus.REQUIRED_RESTART)) {\n                    instance.sendMessage(player, localization.get(locale, \"plugin.restart-required.message\", result.getCurrentVersion(), result.getLatestVersion()));\n                }\n", "                if (!instance.getCore().isSetup() && instance.getCore().getPlayerInSetup().isEmpty()) {\n                    instance.sendMessage(player, localization.get(locale, \"setup.required.first\"));\n                    instance.sendMessage(player, localization.get(locale, \"setup.required.second\"));\n                }\n\n                if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {\n                    Stats stats = instance.getStats();\n                    String infos =\n                            \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                                    \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                                    \"\u00a7bPluginVersion\u00a77: \" + stats.getPluginVersion() + \" \\n\" +\n                                    \"\u00a7bVersionStatus\u00a77: \" + instance.getCore().getVersionResult().getVersionStatus() + \" \\n\" +\n                                    \"\u00a7bUpdateSetting\u00a77: \" + Config.getAutoUpdaterSettings() + \" \\n\" +\n                                    \"\u00a7bProxyProtocol\u00a77: \" + Config.isProxyProtocol() + \" \\n\" +\n                                    \"\u00a7bNeoProtectPlan\u00a77: \" + (instance.getCore().isSetup() ? instance.getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\") + \" \\n\" +\n                                    \"\u00a7bVelocityName\u00a77: \" + stats.getServerName() + \" \\n\" +\n                                    \"\u00a7bVelocityVersion\u00a77: \" + stats.getServerVersion() + \" \\n\" +\n                                    \"\u00a7bVelocityPlugins\u00a77: \" + Arrays.toString(instance.getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray());\n\n                    instance.sendMessage(player, \"\u00a7bHello \" + player.getUsername() + \" ;)\", null, null, \"SHOW_TEXT\", infos);\n                    instance.sendMessage(player, \"\u00a7bThis server uses your NeoPlugin\", null, null, \"SHOW_TEXT\", infos);\n                }\n            }\n        }, 500);\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/messageunsign/PacketReceiveEvent.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.messageunsign;\n\nimport com.velocitypowered.api.event.ResultedEvent;\nimport com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.proxy.protocol.MinecraftPacket;\n\nimport static java.util.Objects.requireNonNull;\n\npublic final class PacketReceiveEvent implements ResultedEvent<ResultedEvent.GenericResult> {\n    private GenericResult result = GenericResult.allowed();\n\n    private final MinecraftPacket packet;\n    private final Player player;\n\n    public PacketReceiveEvent(final MinecraftPacket packet, final Player player) {\n        this.packet = packet;\n        this.player = player;\n    }\n\n    @Override", "public final class PacketReceiveEvent implements ResultedEvent<ResultedEvent.GenericResult> {\n    private GenericResult result = GenericResult.allowed();\n\n    private final MinecraftPacket packet;\n    private final Player player;\n\n    public PacketReceiveEvent(final MinecraftPacket packet, final Player player) {\n        this.packet = packet;\n        this.player = player;\n    }\n\n    @Override", "    public GenericResult getResult() {\n        return result;\n    }\n\n    @Override\n    public void setResult(final GenericResult result) {\n        this.result = requireNonNull(result);\n    }\n\n    public MinecraftPacket getPacket() {\n        return this.packet;\n    }\n", "    public MinecraftPacket getPacket() {\n        return this.packet;\n    }\n\n    public Player getPlayer() {\n        return this.player;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/messageunsign/JoinListener.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.messageunsign;\n\nimport com.velocitypowered.api.event.Continuation;\nimport com.velocitypowered.api.event.EventTask;\nimport com.velocitypowered.api.event.PostOrder;\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.connection.DisconnectEvent;\nimport com.velocitypowered.api.event.connection.PostLoginEvent;\nimport com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.proxy.connection.client.ConnectedPlayer;", "import com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.proxy.connection.client.ConnectedPlayer;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\nimport io.netty.channel.Channel;\n\npublic class JoinListener {\n\n    NeoProtectVelocity neoProtectVelocity;\n\n    public JoinListener(NeoProtectVelocity neoProtectVelocity) {\n        this.neoProtectVelocity = neoProtectVelocity;\n    }\n\n    @Subscribe\n    void onJoin(PostLoginEvent event, Continuation continuation) {\n        injectPlayer(event.getPlayer());\n        continuation.resume();\n    }\n\n    @Subscribe(order = PostOrder.LAST)\n    EventTask onDisconnect(DisconnectEvent event) {", "        if (event.getLoginStatus() == DisconnectEvent.LoginStatus.CONFLICTING_LOGIN)\n            return null;\n        return EventTask.async(() -> removePlayer(event.getPlayer()));\n    }\n\n    private void injectPlayer(Player player) {\n        ConnectedPlayer p = (ConnectedPlayer) player;\n        p.getConnection()\n                .getChannel()\n                .pipeline()\n                .addBefore(\"handler\", \"packetevents\", new PlayerChannelHandler(player, neoProtectVelocity.getProxy().getEventManager(), neoProtectVelocity.getLogger()));\n    }\n\n    private void removePlayer(Player player) {\n        ConnectedPlayer p = (ConnectedPlayer) player;\n        Channel channel = p.getConnection().getChannel();\n        channel.eventLoop().submit(() -> channel.pipeline().remove(\"packetevents\"));\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/messageunsign/PlayerChannelHandler.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.messageunsign;\n\nimport com.velocitypowered.api.event.EventManager;\nimport com.velocitypowered.api.proxy.Player;\nimport com.velocitypowered.proxy.protocol.MinecraftPacket;\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.logging.Level;", "\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic final class PlayerChannelHandler extends ChannelDuplexHandler {\n    private final Player player;\n\n    private final EventManager eventManager;\n\n    private final Logger logger;\n\n    public PlayerChannelHandler(Player player, EventManager eventManager, Logger logger) {\n        this.player = player;\n        this.eventManager = eventManager;\n        this.logger = logger;\n    }\n", "    public void channelRead(@NotNull ChannelHandlerContext ctx, @NotNull Object packet) throws Exception {\n        MinecraftPacket minecraftPacket;\n        if (!(packet instanceof MinecraftPacket)) {\n            super.channelRead(ctx, packet);\n            return;\n        }\n\n        minecraftPacket = (MinecraftPacket) packet;\n\n        boolean allowed = this.eventManager.fire(new PacketReceiveEvent(minecraftPacket, this.player)).handle((event, ex) -> {\n            if (ex != null) {\n                this.logger.log(Level.SEVERE, \"An error has occurred while reading packet \" + packet, ex);\n                return Boolean.FALSE;\n            }\n            return event.getResult().isAllowed();\n        }).join();", "            if (ex != null) {\n                this.logger.log(Level.SEVERE, \"An error has occurred while reading packet \" + packet, ex);\n                return Boolean.FALSE;\n            }\n            return event.getResult().isAllowed();\n        }).join();\n        if (allowed)\n            super.channelRead(ctx, packet);\n    }\n}\n\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/velocity/messageunsign/SessionChatListener.java", "chunked_list": ["package de.cubeattack.neoprotect.velocity.messageunsign;\n\nimport com.velocitypowered.api.event.ResultedEvent;\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.player.PlayerChatEvent;\nimport com.velocitypowered.proxy.connection.client.ConnectedPlayer;\nimport com.velocitypowered.proxy.protocol.packet.chat.session.SessionPlayerChat;\nimport de.cubeattack.neoprotect.velocity.NeoProtectVelocity;\n\npublic final class SessionChatListener {\n\n    private final NeoProtectVelocity plugin;\n\n    public SessionChatListener(NeoProtectVelocity plugin) {\n        this.plugin = plugin;\n    }\n\n    @Subscribe", "\npublic final class SessionChatListener {\n\n    private final NeoProtectVelocity plugin;\n\n    public SessionChatListener(NeoProtectVelocity plugin) {\n        this.plugin = plugin;\n    }\n\n    @Subscribe\n    public void onChat(PacketReceiveEvent event) {\n", "    public void onChat(PacketReceiveEvent event) {\n\n        if (!(event.getPacket() instanceof SessionPlayerChat)) {\n            return;\n        }\n\n        SessionPlayerChat chatPacket = (SessionPlayerChat) event.getPacket();\n        ConnectedPlayer player = (ConnectedPlayer) event.getPlayer();\n        String chatMessage = chatPacket.getMessage();\n\n        if (!checkConnection(player)) return;\n\n        event.setResult(ResultedEvent.GenericResult.denied());\n\n        player.getChatQueue().queuePacket(\n                plugin.getProxy().getEventManager().fire(new PlayerChatEvent(player, chatMessage))\n                        .thenApply(PlayerChatEvent::getResult)\n                        .thenApply(result -> {", "        if (!checkConnection(player)) return;\n\n        event.setResult(ResultedEvent.GenericResult.denied());\n\n        player.getChatQueue().queuePacket(\n                plugin.getProxy().getEventManager().fire(new PlayerChatEvent(player, chatMessage))\n                        .thenApply(PlayerChatEvent::getResult)\n                        .thenApply(result -> {\n                            if (!result.isAllowed()) {\n                                return null;\n                            }\n\n                            final boolean isModified = result\n                                    .getMessage()\n                                    .map(str -> !str.equals(chatMessage))\n                                    .orElse(false);\n", "                            if (!result.isAllowed()) {\n                                return null;\n                            }\n\n                            final boolean isModified = result\n                                    .getMessage()\n                                    .map(str -> !str.equals(chatMessage))\n                                    .orElse(false);\n\n                            if (isModified) {\n                                return player.getChatBuilderFactory()\n                                        .builder()\n                                        .message(result.getMessage().get())\n                                        .setTimestamp(chatPacket.getTimestamp())\n                                        .toServer();\n                            }\n                            return chatPacket;\n                        }),\n                chatPacket.getTimestamp()\n        );\n    }\n", "                            if (isModified) {\n                                return player.getChatBuilderFactory()\n                                        .builder()\n                                        .message(result.getMessage().get())\n                                        .setTimestamp(chatPacket.getTimestamp())\n                                        .toServer();\n                            }\n                            return chatPacket;\n                        }),\n                chatPacket.getTimestamp()\n        );\n    }\n", "    public boolean checkConnection(final ConnectedPlayer player) {\n        try {\n            player.ensureAndGetCurrentServer().ensureConnected();\n            return true;\n        } catch (final IllegalStateException e) {\n            return false;\n        }\n    }\n}"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/Config.java", "chunked_list": ["package de.cubeattack.neoprotect.core;\n\nimport de.cubeattack.api.util.FileUtils;\nimport de.cubeattack.api.util.versioning.VersionUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\n\n@SuppressWarnings(\"unused\")\npublic class Config {\n\n    private static String APIKey;\n    private static String language;\n    private static boolean proxyProtocol;\n    private static String gameShieldID;\n    private static String backendID;\n    private static String geyserBackendID;\n    private static boolean updateIP;\n    private static boolean debugMode;\n    private static String geyserServerIP;\n    private static String updateSetting;\n\n    private static Core core;\n    private static FileUtils fileUtils;\n", "\n@SuppressWarnings(\"unused\")\npublic class Config {\n\n    private static String APIKey;\n    private static String language;\n    private static boolean proxyProtocol;\n    private static String gameShieldID;\n    private static String backendID;\n    private static String geyserBackendID;\n    private static boolean updateIP;\n    private static boolean debugMode;\n    private static String geyserServerIP;\n    private static String updateSetting;\n\n    private static Core core;\n    private static FileUtils fileUtils;\n", "    public static void loadConfig(Core core, FileUtils config) {\n\n        Config.core = core;\n        fileUtils = config;\n\n        APIKey = config.getString(\"APIKey\", \"\");\n        language = config.getString(\"defaultLanguage\", Locale.ENGLISH.toLanguageTag());\n        proxyProtocol = config.getBoolean(\"ProxyProtocol\", true);\n        gameShieldID = config.getString(\"gameshield.serverId\", \"\");\n        backendID = config.getString(\"gameshield.backendId\", \"\");\n        geyserBackendID = config.getString(\"gameshield.geyserBackendId\", \"\");\n        updateIP = config.getBoolean(\"gameshield.autoUpdateIP\", false);\n        debugMode = config.getBoolean(\"DebugMode\", false);\n        geyserServerIP = config.getString(\"geyserServerIP\", \"127.0.0.1\");\n", "        if (APIKey.length() != 64) {\n            core.severe(\"Failed to load API-Key. Key is null or not valid\");\n            return;\n        }\n        if (gameShieldID.isEmpty()) {\n            core.severe(\"Failed to load GameshieldID. ID is null\");\n            return;\n        }\n        if (backendID.isEmpty()) {\n            core.severe(\"Failed to load BackendID. ID is null\");\n            return;\n        }\n\n        core.info(\"API-Key loaded successful '\" + \"******************************\" + APIKey.substring(32) + \"'\");\n        core.info(\"GameshieldID loaded successful '\" + gameShieldID + \"'\");\n        core.info(\"BackendID loaded successful '\" + backendID + \"'\");\n    }\n", "        if (backendID.isEmpty()) {\n            core.severe(\"Failed to load BackendID. ID is null\");\n            return;\n        }\n\n        core.info(\"API-Key loaded successful '\" + \"******************************\" + APIKey.substring(32) + \"'\");\n        core.info(\"GameshieldID loaded successful '\" + gameShieldID + \"'\");\n        core.info(\"BackendID loaded successful '\" + backendID + \"'\");\n    }\n\n    public static String getAPIKey() {\n        return APIKey;\n    }\n", "    public static String getAPIKey() {\n        return APIKey;\n    }\n\n    public static String getLanguage() {\n        return language;\n    }\n\n    public static String getGameShieldID() {\n        return gameShieldID;\n    }\n", "    public static String getGameShieldID() {\n        return gameShieldID;\n    }\n\n    public static String getBackendID() {\n        return backendID;\n    }\n\n    public static String getGeyserBackendID() {\n        return geyserBackendID;\n    }\n", "    public static String getGeyserBackendID() {\n        return geyserBackendID;\n    }\n\n    public static boolean isProxyProtocol() {\n        return proxyProtocol;\n    }\n\n    public static boolean isUpdateIP() {\n        return updateIP;\n    }\n", "    public static boolean isUpdateIP() {\n        return updateIP;\n    }\n\n    public static boolean isDebugMode() {\n        return debugMode;\n    }\n\n    public static String getGeyserServerIP() {\n        return geyserServerIP;\n    }\n", "    public static String getGeyserServerIP() {\n        return geyserServerIP;\n    }\n\n    public static VersionUtils.UpdateSetting getAutoUpdaterSettings() {\n        return VersionUtils.UpdateSetting.getByNameOrDefault(updateSetting);\n    }\n\n    public static void setAPIKey(String key) {\n        fileUtils.set(\"APIKey\", key);\n        fileUtils.save();\n        APIKey = key;\n    }\n", "    public static void setAPIKey(String key) {\n        fileUtils.set(\"APIKey\", key);\n        fileUtils.save();\n        APIKey = key;\n    }\n\n    public static void setGameShieldID(String id) {\n        fileUtils.set(\"gameshield.serverId\", id);\n        fileUtils.save();\n        gameShieldID = id;\n    }\n", "    public static void setBackendID(String id) {\n        fileUtils.set(\"gameshield.backendId\", id);\n        fileUtils.save();\n        backendID = id;\n    }\n\n    public static void setGeyserBackendID(String id) {\n        fileUtils.set(\"gameshield.geyserBackendId\", id);\n        fileUtils.save();\n        geyserBackendID = id;\n    }\n", "    public static void addAutoUpdater(boolean basicPlan) {\n\n        if (basicPlan) {\n            fileUtils.remove(\"AutoUpdater\");\n        } else if (!fileUtils.getConfig().isSet(\"AutoUpdater\")) {\n            fileUtils.getConfig().set(\"AutoUpdater\", \"ENABLED\");\n        }\n\n        List<String> description = new ArrayList<>();\n        description.add(\"This setting is only for paid costumer and allow you to disable the AutoUpdater\");\n        description.add(\"'ENABLED'  (Recommended/Default) Update/Downgrade plugin to the current version  \");\n        description.add(\"'DISABLED' AutoUpdater just disabled\");\n        description.add(\"'DEV'      Only update to the latest version (Please never use this)\");\n\n        fileUtils.getConfig().setComments(\"AutoUpdater\", description);\n\n        fileUtils.save();\n        updateSetting = fileUtils.getString(\"AutoUpdater\", \"ENABLED\");\n    }\n}\n\n\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/Core.java", "chunked_list": ["package de.cubeattack.neoprotect.core;\n\nimport de.cubeattack.api.language.Localization;\nimport de.cubeattack.api.logger.LogManager;\nimport de.cubeattack.api.util.FileUtils;\nimport de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.core.model.debugtool.DebugPingResponse;\nimport de.cubeattack.neoprotect.core.model.debugtool.KeepAliveResponseKey;\nimport de.cubeattack.neoprotect.core.request.RestAPIRequests;\n", "import de.cubeattack.neoprotect.core.request.RestAPIRequests;\n\nimport java.io.File;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;", "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n@SuppressWarnings(\"unused\")\npublic class Core {\n\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final String prefix = \"\u00a78[\u00a7bNeo\u00a73Protect\u00a78] \u00a77\";\n    private final UUID maintainerOnlineUUID = UUID.fromString(\"201e5046-24df-4830-8b4a-82b635eb7cc7\");\n    private final UUID maintainerOfflineeUUID = UUID.fromString(\"8c07bf89-9c8f-304c-9216-4666b670223b\");\n    private final RestAPIRequests restAPIRequests;\n    private final NeoProtectPlugin plugin;\n    private final Localization localization;\n    private final List<Object> playerInSetup = new ArrayList<>();\n    private final List<String> directConnectWhitelist= new ArrayList<>();\n    private final ConcurrentHashMap<KeepAliveResponseKey, Long> pingMap = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<Long, Timestamp> timestampsMap = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<String, ArrayList<DebugPingResponse>> debugPingResponses = new ConcurrentHashMap<>();\n\n    private VersionUtils.Result versionResult;\n    private boolean isDebugRunning = false;\n\n    public Core(NeoProtectPlugin plugin) {\n        LogManager.getLogger().setLogger(plugin.getLogger());\n\n        this.plugin = plugin;\n        this.versionResult = VersionUtils.checkVersion(\"NeoProtect\", \"NeoPlugin\", \"v\" + plugin.getPluginVersion(), VersionUtils.UpdateSetting.DISABLED).message();\n\n        FileUtils config = new FileUtils(Core.class.getResourceAsStream(\"/config.yml\"), \"plugins/NeoProtect\", \"config.yml\", false);\n        FileUtils languageEN = new FileUtils(Core.class.getResourceAsStream(\"/language_en.properties\"), \"plugins/NeoProtect/languages\", \"language_en.properties\", true);\n        FileUtils languageDE = new FileUtils(Core.class.getResourceAsStream(\"/language_de.properties\"), \"plugins/NeoProtect/languages\", \"language_de.properties\", true);\n        FileUtils languageRU = new FileUtils(Core.class.getResourceAsStream(\"/language_ru.properties\"), \"plugins/NeoProtect/languages\", \"language_ru.properties\", true);\n        FileUtils languageUA = new FileUtils(Core.class.getResourceAsStream(\"/language_ua.properties\"), \"plugins/NeoProtect/languages\", \"language_ua.properties\", true);\n\n        Config.loadConfig(this, config);\n\n        this.localization = new Localization(\"language\", Locale.forLanguageTag(Config.getLanguage()), new File(\"plugins/NeoProtect/languages/\"));\n\n        restAPIRequests = new RestAPIRequests(this);\n    }\n", "    public void debug(String output) {\n        if (Config.isDebugMode()) ((Logger) LogManager.getLogger().logger).log(Level.SEVERE, output);\n    }\n\n    public void info(String output) {\n        LogManager.getLogger().info(output);\n    }\n\n    public void warn(String output) {\n        LogManager.getLogger().warn(output);\n    }\n", "    public void warn(String output) {\n        LogManager.getLogger().warn(output);\n    }\n\n    public void severe(String output) {\n        LogManager.getLogger().error(output);\n    }\n    public void severe(String output, Throwable t) {\n        LogManager.getLogger().error(output, t);\n    }\n", "    public String getPrefix() {\n        return prefix;\n    }\n\n    public boolean isDebugRunning() {\n        return isDebugRunning;\n    }\n\n    public void setDebugRunning(boolean debugRunning) {\n        isDebugRunning = debugRunning;\n    }\n", "    public void setDebugRunning(boolean debugRunning) {\n        isDebugRunning = debugRunning;\n    }\n\n    public NeoProtectPlugin getPlugin() {\n        return plugin;\n    }\n\n    public Localization getLocalization() {\n        return localization;\n    }\n", "    public Localization getLocalization() {\n        return localization;\n    }\n\n    public RestAPIRequests getRestAPI() {\n        return restAPIRequests;\n    }\n\n    public boolean isSetup() {\n        return restAPIRequests.isSetup();\n    }\n\n    public List<Object> getPlayerInSetup() {\n        return playerInSetup;\n    }\n\n    public List<String> getDirectConnectWhitelist() {\n        return directConnectWhitelist;\n    }\n\n    public ConcurrentHashMap<KeepAliveResponseKey, Long> getPingMap() {\n        return pingMap;\n    }\n\n    public ConcurrentHashMap<Long, Timestamp> getTimestampsMap() {\n        return timestampsMap;\n    }\n\n    public ConcurrentHashMap<String, ArrayList<DebugPingResponse>> getDebugPingResponses() {\n        return debugPingResponses;\n    }\n\n    public VersionUtils.Result getVersionResult() {\n        return versionResult;\n    }\n", "    public boolean isSetup() {\n        return restAPIRequests.isSetup();\n    }\n\n    public List<Object> getPlayerInSetup() {\n        return playerInSetup;\n    }\n\n    public List<String> getDirectConnectWhitelist() {\n        return directConnectWhitelist;\n    }\n\n    public ConcurrentHashMap<KeepAliveResponseKey, Long> getPingMap() {\n        return pingMap;\n    }\n\n    public ConcurrentHashMap<Long, Timestamp> getTimestampsMap() {\n        return timestampsMap;\n    }\n\n    public ConcurrentHashMap<String, ArrayList<DebugPingResponse>> getDebugPingResponses() {\n        return debugPingResponses;\n    }\n\n    public VersionUtils.Result getVersionResult() {\n        return versionResult;\n    }\n", "    public void setVersionResult(VersionUtils.Result versionResult) {\n        this.versionResult = versionResult;\n    }\n\n    public boolean isPlayerMaintainer(UUID playerUUID, boolean onlineMode) {\n        return (onlineMode && playerUUID.equals(maintainerOnlineUUID)) || (!onlineMode && playerUUID.equals(maintainerOfflineeUUID));\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/Permission.java", "chunked_list": ["package de.cubeattack.neoprotect.core;\n\npublic enum Permission {\n\n    ADMIN(\"neoprotect.admin\"),\n    NOTIFY(\"neoprotect.notify\");\n\n    public final String value;\n\n    Permission(String permission) {\n        this.value = permission;\n    }\n\n    @Override", "    public String toString() {\n        return this.value;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/JsonBuilder.java", "chunked_list": ["package de.cubeattack.neoprotect.core;\n\n@SuppressWarnings(\"unused\")\npublic class JsonBuilder {\n\n    private StringBuilder builder = new StringBuilder();\n\n    private boolean hasAtLeastOneField = false;\n\n    public JsonBuilder() {\n        builder.append(\"{\");\n    }\n", "    public JsonBuilder appendNull(String key) {\n        appendFieldUnescaped(key, \"null\");\n        return this;\n    }\n\n    public JsonBuilder appendField(String key, String value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"JSON value must not be null\");\n        }\n        appendFieldUnescaped(key, \"\\\"\" + escape(value) + \"\\\"\");\n        return this;\n    }\n", "    public JsonBuilder appendField(String key, int value) {\n        appendFieldUnescaped(key, String.valueOf(value));\n        return this;\n    }\n\n    private void appendFieldUnescaped(String key, String escapedValue) {\n        if (builder == null) {\n            throw new IllegalStateException(\"JSON has already been built\");\n        }\n        if (key == null) {\n            throw new IllegalArgumentException(\"JSON key must not be null\");\n        }", "        if (key == null) {\n            throw new IllegalArgumentException(\"JSON key must not be null\");\n        }\n        if (hasAtLeastOneField) {\n            builder.append(\",\");\n        }\n        builder.append(\"\\\"\").append(escape(key)).append(\"\\\":\").append(escapedValue);\n        hasAtLeastOneField = true;\n    }\n\n    public JsonBuilder.JsonObject build() {", "        if (builder == null) {\n            throw new IllegalStateException(\"JSON has already been built\");\n        }\n        JsonBuilder.JsonObject object = new JsonBuilder.JsonObject(builder.append(\"}\").toString());\n        builder = null;\n        return object;\n    }\n\n\n    private static String escape(String value) {\n        final StringBuilder builder = new StringBuilder();", "        for (int i = 0; i < value.length(); i++) {\n            char c = value.charAt(i);\n            if (c == '\"') {\n                builder.append(\"\\\\\\\"\");\n            } else if (c == '\\\\') {\n                builder.append(\"\\\\\\\\\");\n            } else if (c <= '\\u000F') {\n                builder.append(\"\\\\u000\").append(Integer.toHexString(c));\n            } else if (c <= '\\u001F') {\n                builder.append(\"\\\\u00\").append(Integer.toHexString(c));\n            } else {\n                builder.append(c);\n            }\n        }\n        return builder.toString();\n    }\n", "            } else if (c <= '\\u001F') {\n                builder.append(\"\\\\u00\").append(Integer.toHexString(c));\n            } else {\n                builder.append(c);\n            }\n        }\n        return builder.toString();\n    }\n\n    public static class JsonObject {\n\n        private final String value;\n\n        private JsonObject(String value) {\n            this.value = value;\n        }\n\n        @Override", "    public static class JsonObject {\n\n        private final String value;\n\n        private JsonObject(String value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n}\n", "        public String toString() {\n            return value;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/NeoProtectPlugin.java", "chunked_list": ["package de.cubeattack.neoprotect.core;\n\nimport de.cubeattack.neoprotect.core.model.Stats;\n\nimport java.util.ArrayList;\nimport java.util.logging.Logger;\n\npublic interface NeoProtectPlugin {\n\n    void sendMessage(Object receiver, String text);\n\n    void sendMessage(Object receiver, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg);\n\n    void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg);\n\n    long sendKeepAliveMessage(long id);\n\n    void sendKeepAliveMessage(Object receiver, long id);\n\n    Core getCore();\n\n    Stats getStats();\n\n    Logger getLogger();\n\n    ArrayList<String> getPlugins();\n\n    PluginType getPluginType();\n\n    String getPluginVersion();\n\n    enum PluginType {\n        SPIGOT,\n        VELOCITY,\n        BUNGEECORD,\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/executor/NeoProtectExecutor.java", "chunked_list": ["package de.cubeattack.neoprotect.core.executor;\n\nimport de.cubeattack.api.API;\nimport de.cubeattack.api.language.Localization;\nimport de.cubeattack.api.libraries.org.bspfsystems.yamlconfiguration.file.YamlConfiguration;\nimport de.cubeattack.api.libraries.org.json.JSONObject;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.model.Backend;\nimport de.cubeattack.neoprotect.core.model.Gameshield;", "import de.cubeattack.neoprotect.core.model.Backend;\nimport de.cubeattack.neoprotect.core.model.Gameshield;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport de.cubeattack.neoprotect.core.model.debugtool.DebugPingResponse;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.sql.Timestamp;\nimport java.text.DecimalFormat;\nimport java.util.*;", "import java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class NeoProtectExecutor {\n\n    private static Timer debugTimer = new Timer();\n    private NeoProtectPlugin instance;\n    private Localization localization;\n\n    private Object sender;\n    private Locale locale;\n    private String msg;\n    private String[] args;\n    private boolean isViaConsole;\n\n    private void initials(ExecutorBuilder executeBuilder) {\n        this.instance = executeBuilder.getInstance();\n        this.localization = instance.getCore().getLocalization();\n\n        this.sender = executeBuilder.getSender();\n        this.locale = executeBuilder.getLocal();\n        this.args = executeBuilder.getArgs();\n        this.msg = executeBuilder.getMsg();\n        this.isViaConsole = executeBuilder.isViaConsole();\n    }\n\n    private void chatEvent(ExecutorBuilder executorBuilder) {\n        initials(executorBuilder);\n", "        if (instance.getCore().getRestAPI().isAPIInvalid(msg)) {\n            instance.sendMessage(sender, localization.get(locale, \"apikey.invalid\"));\n            return;\n        }\n\n        Config.setAPIKey(msg);\n\n        instance.sendMessage(sender, localization.get(locale, \"apikey.valid\"));\n\n        gameshieldSelector();\n    }\n\n    private void command(ExecutorBuilder executorBuilder) {\n\n        initials(executorBuilder);\n", "        if (args.length == 0) {\n            showHelp();\n            return;\n        }\n\n        if (!instance.getCore().isSetup() & !args[0].equals(\"setup\") & !args[0].equals(\"setgameshield\") & !args[0].equals(\"setbackend\")) {\n            instance.sendMessage(sender, localization.get(locale, \"setup.command.required\"));\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n\n            case \"setup\": {", "                if (isViaConsole) {\n                    instance.sendMessage(sender, localization.get(Locale.getDefault(), \"console.command\"));\n                } else {\n                    setup();\n                }\n                break;\n            }\n\n            case \"ipanic\": {\n                iPanic(args);\n                break;\n            }\n\n            case \"directconnectwhitelist\": {\n                directConnectWhitelist(args);\n                break;\n            }\n\n            case \"toggle\": {\n                toggle(args);\n                break;\n            }\n\n            case \"analytics\": {\n                analytics();\n                break;\n            }\n\n            case \"whitelist\":\n            case \"blacklist\": {\n                firewall(args);\n                break;\n            }\n\n            case \"debugtool\": {\n                debugTool(args);\n                break;\n            }\n\n            case \"setgameshield\": {", "                if (args.length == 1 && !isViaConsole) {\n                    gameshieldSelector();\n                } else if (args.length == 2) {\n                    setGameshield(args);\n                } else {\n                    instance.sendMessage(sender, localization.get(locale, \"usage.setgameshield\"));\n                }\n                break;\n            }\n\n            case \"setbackend\": {", "                if (args.length == 1 && !isViaConsole) {\n                    javaBackendSelector();\n                } else if (args.length == 2) {\n                    setJavaBackend(args);\n                } else {\n                    instance.sendMessage(sender, localization.get(locale, \"usage.setbackend\"));\n                }\n                break;\n            }\n\n            case \"setgeyserbackend\": {", "                if (args.length == 1 && !isViaConsole) {\n                    bedrockBackendSelector();\n                } else if (args.length == 2) {\n                    setBedrockBackend(args);\n                } else {\n                    instance.sendMessage(sender, localization.get(locale, \"usage.setgeyserbackend\"));\n                }\n                break;\n            }\n            default: {\n                showHelp();\n            }\n        }\n    }\n\n\n    private void setup() {\n        instance.getCore().getPlayerInSetup().add(sender);\n        instance.sendMessage(sender, localization.get(locale, \"command.setup\") + localization.get(locale, \"utils.click\"),\n                \"OPEN_URL\", \"https://panel.neoprotect.net/profile\",\n                \"SHOW_TEXT\", localization.get(locale, \"apikey.find\"));\n    }\n\n    private void iPanic(String[] args) {", "        if (args.length != 1) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.ipanic\"));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"command.ipanic\",\n                    localization.get(locale, instance.getCore().getRestAPI().togglePanicMode() ? \"utils.activated\" : \"utils.deactivated\")));\n        }\n    }\n\n    private void directConnectWhitelist(String[] args) {\n        if (args.length == 2) {\n            instance.getCore().getDirectConnectWhitelist().add(args[1]);\n            instance.sendMessage(sender, localization.get(locale, \"command.directconnectwhitelist\", args[1]));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.directconnectwhitelist\"));\n        }\n    }\n\n    private void toggle(String[] args) {", "        if (args.length == 2) {\n            instance.getCore().getDirectConnectWhitelist().add(args[1]);\n            instance.sendMessage(sender, localization.get(locale, \"command.directconnectwhitelist\", args[1]));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.directconnectwhitelist\"));\n        }\n    }\n\n    private void toggle(String[] args) {\n        if (args.length != 2) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.toggle\"));\n        } else {\n            int response = instance.getCore().getRestAPI().toggle(args[1]);\n", "        if (args.length != 2) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.toggle\"));\n        } else {\n            int response = instance.getCore().getRestAPI().toggle(args[1]);\n\n            if (response == 403) {\n                instance.sendMessage(sender, localization.get(locale, \"err.upgrade-plan\"));\n                return;\n            }\n\n            if (response == 429) {\n                instance.sendMessage(sender, localization.get(locale, \"err.rate-limit\"));\n                return;\n            }\n", "            if (response == 429) {\n                instance.sendMessage(sender, localization.get(locale, \"err.rate-limit\"));\n                return;\n            }\n\n            if (response == -1) {\n                instance.sendMessage(sender, \"\u00a7cCan not found setting '\" + args[1] + \"'\");\n                return;\n            }\n\n            instance.sendMessage(sender, localization.get(locale, \"command.toggle\", args[1],\n                    localization.get(locale, response == 1 ? \"utils.activated\" : \"utils.deactivated\")));\n        }\n    }\n\n    private void analytics() {\n        instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7bAnalytics \u00a77\u00a7l---------\");\n        JSONObject analytics = instance.getCore().getRestAPI().getAnalytics();\n        instance.getCore().getRestAPI().getAnalytics().keySet().forEach(ak -> {", "            if (ak.equals(\"bandwidth\")) {\n                return;\n            }\n\n            if (ak.equals(\"traffic\")) {\n                instance.sendMessage(sender, ak.replace(\"traffic\", \"bandwidth\") + \": \" +\n                        new DecimalFormat(\"#.####\").format((float) analytics.getInt(ak) * 8 / (1000 * 1000)) + \" mbit/s\");\n                JSONObject traffic = instance.getCore().getRestAPI().getTraffic();\n\n                AtomicReference<String> trafficUsed = new AtomicReference<>();\n                AtomicReference<String> trafficAvailable = new AtomicReference<>();\n                traffic.keySet().forEach(bk -> {", "                    if (bk.equals(\"used\")) {\n                        trafficUsed.set(traffic.getFloat(bk) / (1000 * 1000 * 1000) + \" gb\");\n                    }\n                    if (bk.equals(\"available\")) {\n                        trafficAvailable.set(String.valueOf(traffic.getLong(bk)).equals(\"999999999\") ? \"unlimited\" : traffic.getLong(bk) + \" gb\");\n                    }\n                });\n                instance.sendMessage(sender, \"bandwidth used\" + \": \" + trafficUsed.get() + \"/\" + trafficAvailable.get());\n\n                return;\n            }\n\n            instance.sendMessage(sender, ak\n                    .replace(\"onlinePlayers\", \"online players\")\n                    .replace(\"cps\", \"connections/s\") + \": \" + analytics.get(ak));\n        });\n    }\n\n    private void firewall(String[] args) {", "        if (args.length == 1) {\n            instance.sendMessage(sender, \"\u00a77\u00a7l----- \u00a7bFirewall (\" + args[0].toUpperCase() + \")\u00a77\u00a7l -----\");\n            instance.getCore().getRestAPI().getFirewall(args[0]).forEach((firewall ->\n                    instance.sendMessage(sender, \"IP: \" + firewall.getIp() + \" ID(\" + firewall.getId() + \")\")));\n        } else if (args.length == 3) {\n            String ip = args[2];\n            String action = args[1];\n            String mode = args[0].toUpperCase();\n            int response = instance.getCore().getRestAPI().updateFirewall(ip, action, mode);\n\n            if (response == -1) {\n                instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n                return;\n            }\n", "            if (response == -1) {\n                instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n                return;\n            }\n\n            if (response == 0) {\n                instance.sendMessage(sender, localization.get(locale, \"command.firewall.notfound\", ip, mode));\n                return;\n            }\n\n            if (response == 400) {\n                instance.sendMessage(sender, localization.get(locale, \"command.firewall.ip-invalid\", ip));\n                return;\n            }\n", "            if (response == 400) {\n                instance.sendMessage(sender, localization.get(locale, \"command.firewall.ip-invalid\", ip));\n                return;\n            }\n\n            if (response == 403) {\n                instance.sendMessage(sender, localization.get(locale, \"err.upgrade-plan\"));\n                return;\n            }\n\n            if (response == 429) {\n                instance.sendMessage(sender, localization.get(locale, \"err.rate-limit\"));\n                return;\n            }\n\n            instance.sendMessage(sender, (action.equalsIgnoreCase(\"add\") ? \"Added '\" : \"Removed '\") + ip + \"' to firewall (\" + mode + \")\");\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n        }\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private void debugTool(String[] args) {\n", "            if (response == 429) {\n                instance.sendMessage(sender, localization.get(locale, \"err.rate-limit\"));\n                return;\n            }\n\n            instance.sendMessage(sender, (action.equalsIgnoreCase(\"add\") ? \"Added '\" : \"Removed '\") + ip + \"' to firewall (\" + mode + \")\");\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n        }\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private void debugTool(String[] args) {\n", "        if (instance.getPluginType() == NeoProtectPlugin.PluginType.SPIGOT) {\n            instance.sendMessage(sender, localization.get(locale, \"debug.spigot\"));\n            return;\n        }\n\n        if (args.length == 2) {\n            if (args[1].equals(\"cancel\")) {\n                debugTimer.cancel();\n                instance.getCore().setDebugRunning(false);\n                instance.sendMessage(sender, localization.get(locale, \"debug.cancelled\"));\n                return;\n            }\n", "            if (!isInteger(args[1])) {\n                instance.sendMessage(sender, localization.get(locale, \"usage.debug\"));\n                return;\n            }\n        }\n\n        if (instance.getCore().isDebugRunning()) {\n            instance.sendMessage(sender, localization.get(locale, \"debug.running\"));\n            return;\n        }\n\n        instance.getCore().setDebugRunning(true);\n        instance.sendMessage(sender, localization.get(locale, \"debug.starting\"));\n\n        int amount = args.length == 2 ? (Integer.parseInt(args[1]) <= 0 ? 1 : Integer.parseInt(args[1])) : 5;\n\n        debugTimer = new Timer();\n\n        debugTimer.schedule(new TimerTask() {\n            int counter = 0;\n\n            @Override", "            public void run() {\n                counter++;\n                instance.getCore().getTimestampsMap().put(instance.sendKeepAliveMessage(new Random().nextInt(90) * 10000 + 1337), new Timestamp(System.currentTimeMillis()));\n                instance.sendMessage(sender, localization.get(locale, \"debug.sendingPackets\") + \" (\" + counter + \"/\" + amount + \")\");\n                if (counter >= amount) this.cancel();\n            }\n        }, 500, 2000);\n\n        debugTimer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                API.getExecutorService().submit(() -> {", "            public void run() {\n                API.getExecutorService().submit(() -> {\n                    try {\n                        long startTime = System.currentTimeMillis();\n                        Stats stats = instance.getStats();\n                        File file = new File(\"plugins/NeoProtect/debug\" + \"/\" + new Timestamp(System.currentTimeMillis()) + \".yml\");\n                        YamlConfiguration configuration = new YamlConfiguration();\n\n                        if (!file.exists()) {\n                            file.getParentFile().mkdirs();\n                            file.createNewFile();\n                        }\n\n                        configuration.load(file);\n\n                        configuration.set(\"general.osName\", System.getProperty(\"os.name\"));\n                        configuration.set(\"general.javaVersion\", System.getProperty(\"java.version\"));\n                        configuration.set(\"general.pluginVersion\", stats.getPluginVersion());\n                        configuration.set(\"general.ProxyName\", stats.getServerName());\n                        configuration.set(\"general.ProxyVersion\", stats.getServerVersion());\n                        configuration.set(\"general.ProxyPlugins\", instance.getPlugins());\n\n                        instance.getCore().getDebugPingResponses().keySet().forEach((playerName -> {\n                            List<DebugPingResponse> list = instance.getCore().getDebugPingResponses().get(playerName);\n\n                            long maxPlayerToProxyLatenz = 0;\n                            long maxNeoToProxyLatenz = 0;\n                            long maxProxyToBackendLatenz = 0;\n                            long maxPlayerToNeoLatenz = 0;\n\n                            long avgPlayerToProxyLatenz = 0;\n                            long avgNeoToProxyLatenz = 0;\n                            long avgProxyToBackendLatenz = 0;\n                            long avgPlayerToNeoLatenz = 0;\n\n                            long minPlayerToProxyLatenz = Long.MAX_VALUE;\n                            long minNeoToProxyLatenz = Long.MAX_VALUE;\n                            long minProxyToBackendLatenz = Long.MAX_VALUE;\n                            long minPlayerToNeoLatenz = Long.MAX_VALUE;\n\n\n                            configuration.set(\"players.\" + playerName + \".playerAddress\", list.get(0).getPlayerAddress());\n                            configuration.set(\"players.\" + playerName + \".neoAddress\", list.get(0).getNeoAddress());\n", "                        if (!file.exists()) {\n                            file.getParentFile().mkdirs();\n                            file.createNewFile();\n                        }\n\n                        configuration.load(file);\n\n                        configuration.set(\"general.osName\", System.getProperty(\"os.name\"));\n                        configuration.set(\"general.javaVersion\", System.getProperty(\"java.version\"));\n                        configuration.set(\"general.pluginVersion\", stats.getPluginVersion());\n                        configuration.set(\"general.ProxyName\", stats.getServerName());\n                        configuration.set(\"general.ProxyVersion\", stats.getServerVersion());\n                        configuration.set(\"general.ProxyPlugins\", instance.getPlugins());\n\n                        instance.getCore().getDebugPingResponses().keySet().forEach((playerName -> {\n                            List<DebugPingResponse> list = instance.getCore().getDebugPingResponses().get(playerName);\n\n                            long maxPlayerToProxyLatenz = 0;\n                            long maxNeoToProxyLatenz = 0;\n                            long maxProxyToBackendLatenz = 0;\n                            long maxPlayerToNeoLatenz = 0;\n\n                            long avgPlayerToProxyLatenz = 0;\n                            long avgNeoToProxyLatenz = 0;\n                            long avgProxyToBackendLatenz = 0;\n                            long avgPlayerToNeoLatenz = 0;\n\n                            long minPlayerToProxyLatenz = Long.MAX_VALUE;\n                            long minNeoToProxyLatenz = Long.MAX_VALUE;\n                            long minProxyToBackendLatenz = Long.MAX_VALUE;\n                            long minPlayerToNeoLatenz = Long.MAX_VALUE;\n\n\n                            configuration.set(\"players.\" + playerName + \".playerAddress\", list.get(0).getPlayerAddress());\n                            configuration.set(\"players.\" + playerName + \".neoAddress\", list.get(0).getNeoAddress());\n", "                            for (DebugPingResponse response : list) {\n                                if (maxPlayerToProxyLatenz < response.getPlayerToProxyLatenz())\n                                    maxPlayerToProxyLatenz = response.getPlayerToProxyLatenz();\n                                if (maxNeoToProxyLatenz < response.getNeoToProxyLatenz())\n                                    maxNeoToProxyLatenz = response.getNeoToProxyLatenz();\n                                if (maxProxyToBackendLatenz < response.getProxyToBackendLatenz())\n                                    maxProxyToBackendLatenz = response.getProxyToBackendLatenz();\n                                if (maxPlayerToNeoLatenz < response.getPlayerToNeoLatenz())\n                                    maxPlayerToNeoLatenz = response.getPlayerToNeoLatenz();\n\n                                avgPlayerToProxyLatenz = avgPlayerToProxyLatenz + response.getPlayerToProxyLatenz();\n                                avgNeoToProxyLatenz = avgNeoToProxyLatenz + response.getNeoToProxyLatenz();\n                                avgProxyToBackendLatenz = avgProxyToBackendLatenz + response.getProxyToBackendLatenz();\n                                avgPlayerToNeoLatenz = avgPlayerToNeoLatenz + response.getPlayerToNeoLatenz();\n", "                                if (minPlayerToProxyLatenz > response.getPlayerToProxyLatenz())\n                                    minPlayerToProxyLatenz = response.getPlayerToProxyLatenz();\n                                if (minNeoToProxyLatenz > response.getNeoToProxyLatenz())\n                                    minNeoToProxyLatenz = response.getNeoToProxyLatenz();\n                                if (minProxyToBackendLatenz > response.getProxyToBackendLatenz())\n                                    minProxyToBackendLatenz = response.getProxyToBackendLatenz();\n                                if (minPlayerToNeoLatenz > response.getPlayerToNeoLatenz())\n                                    minPlayerToNeoLatenz = response.getPlayerToNeoLatenz();\n                            }\n\n                            configuration.set(\"players.\" + playerName + \".ping.max.PlayerToProxyLatenz\", maxPlayerToProxyLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.max.NeoToProxyLatenz\", maxNeoToProxyLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.max.ProxyToBackendLatenz\", maxProxyToBackendLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.max.PlayerToNeoLatenz\", maxPlayerToNeoLatenz);\n\n                            configuration.set(\"players.\" + playerName + \".ping.average.PlayerToProxyLatenz\", avgPlayerToProxyLatenz / list.size());\n                            configuration.set(\"players.\" + playerName + \".ping.average.NeoToProxyLatenz\", avgNeoToProxyLatenz / list.size());\n                            configuration.set(\"players.\" + playerName + \".ping.average.ProxyToBackendLatenz\", avgProxyToBackendLatenz / list.size());\n                            configuration.set(\"players.\" + playerName + \".ping.average.PlayerToNeoLatenz\", avgPlayerToNeoLatenz / list.size());\n\n                            configuration.set(\"players.\" + playerName + \".ping.min.PlayerToProxyLatenz\", minPlayerToProxyLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.min.NeoToProxyLatenz\", minNeoToProxyLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.min.ProxyToBackendLatenz\", minProxyToBackendLatenz);\n                            configuration.set(\"players.\" + playerName + \".ping.min.PlayerToNeoLatenz\", minPlayerToNeoLatenz);\n\n                        }));\n                        configuration.save(file);\n\n                        final String content = new String(Files.readAllBytes(file.toPath()));\n                        final String pasteKey = instance.getCore().getRestAPI().paste(content);\n\n                        instance.getCore().getDebugPingResponses().clear();\n                        instance.sendMessage(sender, localization.get(locale, \"debug.finished.first\") + \" (took \" + (System.currentTimeMillis() - startTime) + \"ms)\");", "                        if(pasteKey != null) {\n                            final String url = \"https://paste.neoprotect.net/\" + pasteKey + \".yml\";\n                            instance.sendMessage(sender, localization.get(locale, \"debug.finished.url\") + url + localization.get(locale, \"utils.open\"), \"OPEN_URL\", url, null, null);\n                        } else {\n                            instance.sendMessage(sender, localization.get(locale, \"debug.finished.file\") + file.getAbsolutePath() + localization.get(locale, \"utils.copy\"), \"COPY_TO_CLIPBOARD\", file.getAbsolutePath(), null, null);\n                        }\n                        instance.getCore().setDebugRunning(false);\n                    } catch (Exception ex) {\n                        instance.getCore().severe(ex.getMessage(), ex);\n                    }\n                });\n            }\n        }, 2000L * amount + 500);\n    }\n\n    private void gameshieldSelector() {\n        instance.sendMessage(sender, localization.get(locale, \"select.gameshield\"));\n\n        List<Gameshield> gameshieldList = instance.getCore().getRestAPI().getGameshields();\n", "        for (Gameshield gameshield : gameshieldList) {\n            instance.sendMessage(sender, \"\u00a75\" + gameshield.getName() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setgameshield \" + gameshield.getId(),\n                    \"SHOW_TEXT\", localization.get(locale, \"hover.gameshield\", gameshield.getName(), gameshield.getId()));\n        }\n    }\n\n    private void setGameshield(String[] args) {\n\n        if (instance.getCore().getRestAPI().isGameshieldInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.gameshield\", args[1]));\n            return;\n        }\n\n        Config.setGameShieldID(args[1]);\n        instance.sendMessage(sender, localization.get(locale, \"set.gameshield\", args[1]));\n\n        javaBackendSelector();\n    }\n\n\n    private void javaBackendSelector() {\n        List<Backend> backendList = instance.getCore().getRestAPI().getBackends();\n\n        instance.sendMessage(sender, localization.get(locale, \"select.backend\", \"java\"));\n", "        if (instance.getCore().getRestAPI().isGameshieldInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.gameshield\", args[1]));\n            return;\n        }\n\n        Config.setGameShieldID(args[1]);\n        instance.sendMessage(sender, localization.get(locale, \"set.gameshield\", args[1]));\n\n        javaBackendSelector();\n    }\n\n\n    private void javaBackendSelector() {\n        List<Backend> backendList = instance.getCore().getRestAPI().getBackends();\n\n        instance.sendMessage(sender, localization.get(locale, \"select.backend\", \"java\"));\n", "        for (Backend backend : backendList) {\n            if(backend.isGeyser())continue;\n            instance.sendMessage(sender, \"\u00a75\" + backend.getIp() + \":\" + backend.getPort() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setbackend \" + backend.getId(),\n                    \"SHOW_TEXT\", localization.get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));\n        }\n    }\n\n    private void setJavaBackend(String[] args) {\n\n        if (instance.getCore().getRestAPI().isBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.backend\", \"java\", args[1]));\n            return;\n        }\n\n        Config.setBackendID(args[1]);\n\n        instance.sendMessage(sender, localization.get(locale, \"set.backend\", \"java\", args[1]));\n        instance.getCore().getRestAPI().testCredentials();\n\n        bedrockBackendSelector();\n    }\n\n    private void bedrockBackendSelector() {\n        List<Backend> backendList = instance.getCore().getRestAPI().getBackends();\n", "        if (instance.getCore().getRestAPI().isBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.backend\", \"java\", args[1]));\n            return;\n        }\n\n        Config.setBackendID(args[1]);\n\n        instance.sendMessage(sender, localization.get(locale, \"set.backend\", \"java\", args[1]));\n        instance.getCore().getRestAPI().testCredentials();\n\n        bedrockBackendSelector();\n    }\n\n    private void bedrockBackendSelector() {\n        List<Backend> backendList = instance.getCore().getRestAPI().getBackends();\n", "        if(backendList.stream().noneMatch(Backend::isGeyser))return;\n\n        instance.sendMessage(sender, localization.get(locale, \"select.backend\", \"geyser\"));\n\n        for (Backend backend : backendList) {\n            if(!backend.isGeyser())continue;\n            instance.sendMessage(sender, \"\u00a75\" + backend.getIp() + \":\" + backend.getPort() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setgeyserbackend \" + backend.getId(),\n                    \"SHOW_TEXT\", localization.get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));\n        }\n    }\n\n    private void setBedrockBackend(String[] args) {\n", "        if (instance.getCore().getRestAPI().isBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.backend\", \"geyser\",  args[1]));\n            return;\n        }\n\n        Config.setGeyserBackendID(args[1]);\n        instance.sendMessage(sender, localization.get(locale, \"set.backend\",\"geyser\",  args[1]));\n\n        if (instance.getCore().getPlayerInSetup().remove(sender)) {\n            instance.sendMessage(sender, localization.get(locale, \"setup.finished\"));\n        }\n\n    }\n\n    private void showHelp() {\n        instance.sendMessage(sender, localization.get(locale, \"available.commands\"));\n        instance.sendMessage(sender, \" - /np setup\");\n        instance.sendMessage(sender, \" - /np ipanic\");\n        instance.sendMessage(sender, \" - /np analytics\");\n        instance.sendMessage(sender, \" - /np toggle (option)\");\n        instance.sendMessage(sender, \" - /np whitelist (add/remove) (ip)\");\n        instance.sendMessage(sender, \" - /np blacklist (add/remove) (ip)\");\n        instance.sendMessage(sender, \" - /np debugTool (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np directConnectWhitelist (ip)\");\n        instance.sendMessage(sender, \" - /np setgameshield [id]\");\n        instance.sendMessage(sender, \" - /np setbackend [id]\");\n        instance.sendMessage(sender, \" - /np setgeyserbackend [id]\");\n    }\n", "        if (instance.getCore().getPlayerInSetup().remove(sender)) {\n            instance.sendMessage(sender, localization.get(locale, \"setup.finished\"));\n        }\n\n    }\n\n    private void showHelp() {\n        instance.sendMessage(sender, localization.get(locale, \"available.commands\"));\n        instance.sendMessage(sender, \" - /np setup\");\n        instance.sendMessage(sender, \" - /np ipanic\");\n        instance.sendMessage(sender, \" - /np analytics\");\n        instance.sendMessage(sender, \" - /np toggle (option)\");\n        instance.sendMessage(sender, \" - /np whitelist (add/remove) (ip)\");\n        instance.sendMessage(sender, \" - /np blacklist (add/remove) (ip)\");\n        instance.sendMessage(sender, \" - /np debugTool (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np directConnectWhitelist (ip)\");\n        instance.sendMessage(sender, \" - /np setgameshield [id]\");\n        instance.sendMessage(sender, \" - /np setbackend [id]\");\n        instance.sendMessage(sender, \" - /np setgeyserbackend [id]\");\n    }\n", "    public static class ExecutorBuilder {\n        private NeoProtectPlugin instance;\n        private Object sender;\n        private String[] args;\n        private Locale local;\n        private String msg;\n        private boolean viaConsole;\n\n        public ExecutorBuilder neoProtectPlugin(NeoProtectPlugin instance) {\n            this.instance = instance;\n            return this;\n        }\n", "        public ExecutorBuilder neoProtectPlugin(NeoProtectPlugin instance) {\n            this.instance = instance;\n            return this;\n        }\n\n        public ExecutorBuilder sender(Object sender) {\n            this.sender = sender;\n            return this;\n        }\n\n        public ExecutorBuilder args(String[] args) {\n            this.args = args;\n            return this;\n        }\n", "        public ExecutorBuilder args(String[] args) {\n            this.args = args;\n            return this;\n        }\n\n        public ExecutorBuilder local(Locale local) {\n            this.local = local;\n            return this;\n        }\n\n        public ExecutorBuilder msg(String msg) {\n            this.msg = msg;\n            return this;\n        }\n", "        public ExecutorBuilder msg(String msg) {\n            this.msg = msg;\n            return this;\n        }\n\n        public ExecutorBuilder viaConsole(boolean viaConsole) {\n            this.viaConsole = viaConsole;\n            return this;\n        }\n\n        public void executeChatEvent() {\n            API.getExecutorService().submit(() -> new NeoProtectExecutor().chatEvent(this));\n        }\n", "        public void executeChatEvent() {\n            API.getExecutorService().submit(() -> new NeoProtectExecutor().chatEvent(this));\n        }\n\n        public void executeCommand() {\n            API.getExecutorService().submit(() -> new NeoProtectExecutor().command(this));\n        }\n\n        public NeoProtectPlugin getInstance() {\n            return instance;\n        }\n", "        public NeoProtectPlugin getInstance() {\n            return instance;\n        }\n\n        public Object getSender() {\n            return sender;\n        }\n\n        public String[] getArgs() {\n            return args;\n        }\n", "        public Locale getLocal() {\n            return local;\n        }\n\n        public String getMsg() {\n            return msg;\n        }\n\n        public boolean isViaConsole() {\n            return viaConsole;\n        }\n    }\n", "        public boolean isViaConsole() {\n            return viaConsole;\n        }\n    }\n\n    public static boolean isInteger(String input) {\n        try {\n            Integer.parseInt(input);\n            return true;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/Backend.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model;\n\npublic class Backend {\n\n    private final String id;\n    private String ip;\n    private final String port;\n    private final boolean geyser;\n\n    public Backend(String id, String ip, String port, boolean geyser) {\n        this.id = id;\n        this.ip = ip;\n        this.port = port;\n        this.geyser = geyser;\n    }\n", "    public boolean compareById(String otherId) {\n        return id.equals(otherId);\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getIp() {\n        return ip;\n    }\n", "    public String getIp() {\n        return ip;\n    }\n\n    public boolean isGeyser() {\n        return geyser;\n    }\n\n    public void setIp(String ip) {\n        this.ip = ip;\n    }\n", "    public void setIp(String ip) {\n        this.ip = ip;\n    }\n\n    public String getPort() {\n        return port;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/Gameshield.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model;\n\npublic class Gameshield {\n\n    private final String id;\n    private final String name;\n\n    public Gameshield(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n", "    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/Firewall.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model;\n\npublic class Firewall {\n    String ip;\n    String id;\n\n    public Firewall(String ip, String id) {\n        this.ip = ip;\n        this.id = id;\n    }\n", "    public String getIp() {\n        return ip;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/Stats.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model;\n\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\n\n@SuppressWarnings(\"unused\")\npublic class Stats {\n\n    private final String serverType;\n    private final String serverVersion;\n    private final String serverName;\n    private final String javaVersion;\n    private final String osName;\n    private final String osArch;\n    private final String osVersion;\n    private final String pluginVersion;\n    private final String versionStatus;\n    private final String updateSetting;\n    private final String neoProtectPlan;\n    private final String serverPlugins;\n\n    private final int playerAmount;\n    private final int managedServers;\n    private final int coreCount;\n\n    private final boolean onlineMode;\n    private final boolean proxyProtocol;\n\n    public Stats(NeoProtectPlugin.PluginType serverType, String serverVersion, String serverName, String javaVersion, String osName, String osArch, String osVersion, String pluginVersion, String versionStatus, String updateSetting, String neoProtectPlan, String serverPlugins, int playerAmount, int managedServers, int coreCount, boolean onlineMode, boolean proxyProtocol) {\n        this.serverType = serverType.name().toLowerCase();\n        this.serverVersion = serverVersion;\n        this.serverName = serverName;\n        this.javaVersion = javaVersion;\n        this.osName = osName;\n        this.osArch = osArch;\n        this.osVersion = osVersion;\n        this.pluginVersion = pluginVersion;\n        this.versionStatus = versionStatus;\n        this.updateSetting = updateSetting;\n        this.neoProtectPlan = neoProtectPlan;\n        this.serverPlugins = serverPlugins;\n        this.playerAmount = playerAmount;\n        this.managedServers = managedServers;\n        this.coreCount = coreCount;\n        this.onlineMode = onlineMode;\n        this.proxyProtocol = proxyProtocol;\n    }\n", "    public String getServerType() {\n        return serverType;\n    }\n\n    public String getServerVersion() {\n        return serverVersion;\n    }\n\n    public String getServerName() {\n        return serverName;\n    }\n", "    public String getServerName() {\n        return serverName;\n    }\n\n    public String getJavaVersion() {\n        return javaVersion;\n    }\n\n    public String getOsName() {\n        return osName;\n    }\n", "    public String getOsName() {\n        return osName;\n    }\n\n    public String getOsArch() {\n        return osArch;\n    }\n\n    public String getOsVersion() {\n        return osVersion;\n    }\n", "    public String getOsVersion() {\n        return osVersion;\n    }\n\n    public String getPluginVersion() {\n        return pluginVersion;\n    }\n\n    public String getVersionStatus() {\n        return versionStatus;\n    }\n", "    public String getVersionStatus() {\n        return versionStatus;\n    }\n\n    public String getUpdateSetting() {\n        return updateSetting;\n    }\n\n    public String getNeoProtectPlan() {\n        return neoProtectPlan;\n    }\n", "    public String getNeoProtectPlan() {\n        return neoProtectPlan;\n    }\n\n    public String getServerPlugins() {\n        return serverPlugins;\n    }\n\n    public int getPlayerAmount() {\n        return playerAmount;\n    }\n", "    public int getPlayerAmount() {\n        return playerAmount;\n    }\n\n    public int getManagedServers() {\n        return managedServers;\n    }\n\n    public int getCoreCount() {\n        return coreCount;\n    }\n", "    public int getCoreCount() {\n        return coreCount;\n    }\n\n    public boolean isOnlineMode() {\n        return onlineMode;\n    }\n\n    public boolean isProxyProtocol() {\n        return proxyProtocol;\n    }\n}\n", "    public boolean isProxyProtocol() {\n        return proxyProtocol;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/debugtool/KeepAliveResponseKey.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model.debugtool;\n\nimport java.net.SocketAddress;\n\npublic class KeepAliveResponseKey {\n\n    private final SocketAddress address;\n    private final long id;\n\n    public KeepAliveResponseKey(SocketAddress address, long id) {\n        this.address = address;\n        this.id = id;\n    }\n", "    public SocketAddress getAddress() {\n        return address;\n    }\n\n    public long getId() {\n        return id;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/model/debugtool/DebugPingResponse.java", "chunked_list": ["package de.cubeattack.neoprotect.core.model.debugtool;\n\nimport java.net.SocketAddress;\n\n@SuppressWarnings(\"unused\")\npublic class DebugPingResponse {\n\n    private final long proxyToBackendLatenz;\n    private final long playerToProxyLatenz;\n    private final long neoToProxyLatenz;\n    private final SocketAddress playerAddress;\n    private final SocketAddress neoAddress;\n\n    public DebugPingResponse(long playerToProxyLatenz, long neoToProxyLatenz, long proxyToBackendLatenz, SocketAddress playerAddress, SocketAddress neoAddress) {\n        this.proxyToBackendLatenz = proxyToBackendLatenz;\n        this.playerToProxyLatenz = playerToProxyLatenz;\n        this.neoToProxyLatenz = neoToProxyLatenz;\n        this.playerAddress = playerAddress;\n        this.neoAddress = neoAddress;\n    }\n", "    public long getPlayerToProxyLatenz() {\n        return playerToProxyLatenz;\n    }\n\n    public long getNeoToProxyLatenz() {\n        return neoToProxyLatenz;\n    }\n\n    public long getProxyToBackendLatenz() {\n        return proxyToBackendLatenz;\n    }\n", "    public long getProxyToBackendLatenz() {\n        return proxyToBackendLatenz;\n    }\n\n    public long getPlayerToNeoLatenz() {\n        return playerToProxyLatenz - neoToProxyLatenz;\n    }\n\n    public String getPlayerAddress() {\n        return playerAddress.toString();\n    }\n", "    public String getPlayerAddress() {\n        return playerAddress.toString();\n    }\n\n    public String getNeoAddress() {\n        return neoAddress.toString();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/request/ResponseManager.java", "chunked_list": ["package de.cubeattack.neoprotect.core.request;\n\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.ResponseBody;\nimport de.cubeattack.api.libraries.org.json.JSONArray;\nimport de.cubeattack.api.libraries.org.json.JSONException;\nimport de.cubeattack.api.libraries.org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;", "import java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.Objects;\n\npublic class ResponseManager extends JSONObject {\n\n    private final String responseBody;\n    private final Response response;\n    private final int code;\n\n    public ResponseManager(Response response) {\n        this.responseBody = getBody(response);\n        this.response = response;\n        this.code = getCode();\n    }\n\n    private String getBody(Response response) {\n        try (ResponseBody body = response.body()) {\n            return body.string();\n        } catch (NullPointerException | SocketTimeoutException ignored) {\n            return \"{}\";\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "    public boolean checkCode(int code) {\n        return Objects.equals(this.code, code);\n    }\n\n    public int getCode() {\n        try {\n            return response.code();\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n", "    public String getResponseBody() {\n        return responseBody;\n    }\n\n    public JSONObject getResponseBodyObject() {\n        try {\n            return new JSONObject(responseBody);\n        } catch (JSONException ignored) {}\n        return new JSONObject();\n    }\n", "    public JSONArray getResponseBodyArray() {\n        try {\n            return new JSONArray(responseBody);\n        } catch (JSONException ignored) {}\n        return new JSONArray();\n    }\n\n    @Override\n    public String getString(String key) {\n        return super.getString(key);\n    }\n}\n", "    public String getString(String key) {\n        return super.getString(key);\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/request/RestAPIManager.java", "chunked_list": ["package de.cubeattack.neoprotect.core.request;\n\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.RequestBody;\nimport com.squareup.okhttp.Response;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.Core;\n\nimport java.net.SocketException;", "\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\nimport java.util.Formatter;\nimport java.util.concurrent.TimeUnit;\n\npublic class RestAPIManager {\n\n    private final OkHttpClient client = new OkHttpClient();\n    private final String baseURL = \"https://api.neoprotect.net/v2\";\n    private final Core core;\n\n    public RestAPIManager(Core core) {\n        this.core = core;\n    }\n\n    {\n        client.setConnectTimeout(4, TimeUnit.SECONDS);\n    }\n\n    protected ResponseManager request(RequestType type, RequestBody requestBody, Object... value) {", "        if (type.toString().startsWith(\"GET\")) {\n            return new ResponseManager(callRequest(defaultBuilder().url(baseURL + getSubDirectory(type, value)).build()));\n        } else if (type.toString().startsWith(\"POST\")) {\n            return new ResponseManager(callRequest(defaultBuilder().url(baseURL + getSubDirectory(type, value)).post(requestBody).build()));\n        } else {\n            return new ResponseManager(callRequest(defaultBuilder().url(baseURL + getSubDirectory(type, value)).delete().build()));\n        }\n    }\n\n    protected Response callRequest(Request request) {\n        try {\n            return client.newCall(request).execute();\n        } catch (UnknownHostException | SocketTimeoutException | SocketException connectionException) {", "        try {\n            return client.newCall(request).execute();\n        } catch (UnknownHostException | SocketTimeoutException | SocketException connectionException) {\n            if(!request.url().toString().equals(core.getRestAPI().getStatsServer())) {\n                core.severe(request + \" failed cause (\" + connectionException + \")\");\n            }else\n                core.debug(request + \" failed cause (\" + connectionException + \")\");\n        } catch (Exception exception) {\n            core.severe(exception.getMessage(), exception);\n        }\n        return null;\n    }\n\n    protected Request.Builder defaultBuilder() {\n        return defaultBuilder(Config.getAPIKey());\n    }\n\n    protected Request.Builder defaultBuilder(String apiKey) {\n        return new Request.Builder()\n                .addHeader(\"accept\", \"*/*\")\n                .addHeader(\"Authorization\", \"Bearer \" + apiKey)\n                .addHeader(\"Content-Type\", \"application/json\");\n    }\n\n    protected String getSubDirectory(RequestType type, Object... values) {\n\n        switch (type) {\n\n            case GET_ATTACKS: {\n                return new Formatter().format(\"/attacks\", values).toString();\n            }\n            case GET_ATTACKS_GAMESHIELD: {\n                return new Formatter().format(\"/attacks/gameshield/%s\", values).toString();\n            }\n\n            case GET_GAMESHIELD_BACKENDS: {\n                return new Formatter().format(\"/gameshields/%s/backends\", values).toString();\n            }\n            case POST_GAMESHIELD_BACKEND_CREATE: {\n                return new Formatter().format(\"/gameshields/%s/backends\", values).toString();\n            }\n            case POST_GAMESHIELD_BACKEND_UPDATE: {\n                return new Formatter().format(\"/gameshields/%s/backends/%s\", values).toString();\n            }\n            case DELETE_GAMESHIELD_BACKEND_UPDATE: {\n                return new Formatter().format(\"/gameshields/%s/backends/%s\", values).toString();\n            }\n            case POST_GAMESHIELD_BACKEND_AVAILABLE: {\n                return new Formatter().format(\"/gameshield/backends/available\", values).toString();\n            }\n\n            case GET_GAMESHIELD_DOMAINS: {\n                return new Formatter().format(\"/gameshields/domains/%s\", values).toString();\n            }\n            case POST_GAMESHIELD_DOMAIN_CREATE: {\n                return new Formatter().format(\"/gameshields/domains/%s\", values).toString();\n            }\n            case POST_GAMESHIELD_DOMAIN_AVAILABLE: {\n                return new Formatter().format(\"/gameshields/domains/available\", values).toString();\n            }\n            case DELETE_GAMESHIELD_DOMAIN: {\n                return new Formatter().format(\"/gameshields/domains/%s\", values).toString();\n            }\n\n            case GET_GAMESHIELD_FRONTENDS: {\n                return new Formatter().format(\"/gameshields/%s/frontends\", values).toString();\n            }\n            case POST_GAMESHIELD_FRONTEND_CREATE: {\n                return new Formatter().format(\"/gameshields/%s/frontends\", values).toString();\n            }\n\n            case GET_GAMESHIELDS: {\n                return new Formatter().format(\"/gameshields\", values).toString();\n            }\n            case POST_GAMESHIELD_CREATE: {\n                return new Formatter().format(\"/gameshields\", values).toString();\n            }\n            case POST_GAMESHIELD_UPDATE: {\n                return new Formatter().format(\"/gameshields/%s/settings\", values).toString();\n            }\n            case POST_GAMESHIELD_UPDATE_REGION: {\n                return new Formatter().format(\"/gameshields/%s/region/%s\", values).toString();\n            }\n            case GET_GAMESHIELD_PLAN: {\n                return new Formatter().format(\"/gameshields/%s/plan\", values).toString();\n            }\n            case POST_GAMESHIELD_PLAN_UPGRADE: {\n                return new Formatter().format(\"/gameshields/%s/plan\", values).toString();\n            }\n            case POST_GAMESHIELD_UPDATE_NAME: {\n                return new Formatter().format(\"/gameshields/%s/name\", values).toString();\n            }\n            case POST_GAMESHIELD_UPDATE_ICON: {\n                return new Formatter().format(\"/gameshields/%s/icon\", values).toString();\n            }\n            case DELETE_GAMESHIELD_UPDATE_ICON: {\n                return new Formatter().format(\"/gameshields/%s/icon\", values).toString();\n            }\n            case POST_GAMESHIELD_UPDATE_BANNER: {\n                return new Formatter().format(\"/gameshields/%s/banner\", values).toString();\n            }\n            case DELETE_GAMESHIELD_BANNER: {\n                return new Formatter().format(\"/gameshields/%s/banner\", values).toString();\n            }\n            case POST_GAMESHIELD_AVAILABLE: {\n                return new Formatter().format(\"/gameshields/available\", values).toString();\n            }\n            case GET_GAMESHIELD_INFO: {\n                return new Formatter().format(\"/gameshields/%s\", values).toString();\n            }\n            case DELETE_GAMESHIELD: {\n                return new Formatter().format(\"/gameshields/%s\", values).toString();\n            }\n            case GET_GAMESHIELD_LASTSTATS: {\n                return new Formatter().format(\"/gameshields/%s/lastStats\", values).toString();\n            }\n            case GET_GAMESHIELD_ISUNDERATTACK: {\n                return new Formatter().format(\"/gameshields/%s/isUnderAttack\", values).toString();\n            }\n            case GET_GAMESHIELD_BANDWIDTH: {\n                return new Formatter().format(\"/gameshields/%s/bandwidth\", values).toString();\n            }\n            case GET_GAMESHIELD_ANALYTICS: {\n                return new Formatter().format(\"/gameshields/%s/analytics/%s\", values).toString();\n            }\n\n            case GET_FIREWALLS: {\n                return new Formatter().format(\"/firewall/gameshield/%s/%s\", values).toString();\n            }\n            case POST_FIREWALL_CREATE: {\n                return new Formatter().format(\"/firewall/gameshield/%s/%s\", values).toString();\n            }\n            case DELETE_FIREWALL: {\n                return new Formatter().format(\"/firewall/gameshield/%s/%s\", values).toString();\n            }\n\n            case GET_PLANS_AVAILABLE: {\n                return new Formatter().format(\"/plans/gameshield\", values).toString();\n            }\n\n            case GET_PROFILE_TRANSACTIONS: {\n                return new Formatter().format(\"/profile/transactions\", values).toString();\n            }\n            case GET_PROFILE_INFOS: {\n                return new Formatter().format(\"/profile/infos\", values).toString();\n            }\n            case GET_PROFILE_GENERALINFORMATION: {\n                return new Formatter().format(\"/profile/generalInformation\", values).toString();\n            }\n\n            case GET_NEO_SERVER_IPS: {\n                return new Formatter().format(\"/public/servers\", values).toString();\n            }\n            case GET_NEO_SERVER_REGIONS: {\n                return new Formatter().format(\"/public/regions\", values).toString();\n            }\n\n            case GET_VULNERABILITIES_GAMESHIELD: {\n                return new Formatter().format(\"/vulnerabilities/%s\", values).toString();\n            }\n            case POST_VULNERABILITIES: {\n                return new Formatter().format(\"/vulnerabilities/%s\", values).toString();\n            }\n            case GET_VULNERABILITIES_ALL: {\n                return new Formatter().format(\"/vulnerabilities\", values).toString();\n            }\n            case DELETE_VULNERABILITIES: {\n                return new Formatter().format(\"/vulnerabilities/%s\", values).toString();\n            }\n\n            case GET_WEBHOOKS: {\n                return new Formatter().format(\"/webhooks/%s\", values).toString();\n            }\n            case POST_WEBHOOK_CREATE: {\n                return new Formatter().format(\"/webhooks/%s\", values).toString();\n            }\n            case POST_WEBHOOK_TEST: {\n                return new Formatter().format(\"/webhooks/%s/%s/test\", values).toString();\n            }\n            case DELETE_WEBHOOK: {\n                return new Formatter().format(\"/webhooks/%s/%s\", values).toString();\n            }\n            default: {\n                return null;\n            }\n        }\n    }\n", "    public String getBaseURL() {\n        return baseURL;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/request/RequestType.java", "chunked_list": ["package de.cubeattack.neoprotect.core.request;\n\n@SuppressWarnings(\"unused\")\npublic enum RequestType {\n\n    GET_ATTACKS,\n    GET_ATTACKS_GAMESHIELD,\n\n    GET_GAMESHIELD_BACKENDS,\n    POST_GAMESHIELD_BACKEND_CREATE,\n    POST_GAMESHIELD_BACKEND_UPDATE,\n    DELETE_GAMESHIELD_BACKEND_UPDATE,\n    POST_GAMESHIELD_BACKEND_AVAILABLE,\n\n    GET_GAMESHIELD_DOMAINS,\n    POST_GAMESHIELD_DOMAIN_CREATE,\n    POST_GAMESHIELD_DOMAIN_AVAILABLE,\n    DELETE_GAMESHIELD_DOMAIN,\n\n    GET_GAMESHIELD_FRONTENDS,\n    POST_GAMESHIELD_FRONTEND_CREATE,\n\n    GET_GAMESHIELDS,\n    POST_GAMESHIELD_CREATE,\n    POST_GAMESHIELD_UPDATE,\n    POST_GAMESHIELD_UPDATE_REGION,\n    GET_GAMESHIELD_PLAN,\n    POST_GAMESHIELD_PLAN_UPGRADE,\n    POST_GAMESHIELD_UPDATE_NAME,\n    POST_GAMESHIELD_UPDATE_ICON,\n    DELETE_GAMESHIELD_UPDATE_ICON,\n    POST_GAMESHIELD_UPDATE_BANNER,\n    DELETE_GAMESHIELD_BANNER,\n    POST_GAMESHIELD_AVAILABLE,\n    GET_GAMESHIELD_INFO,\n    DELETE_GAMESHIELD,\n    GET_GAMESHIELD_LASTSTATS,\n    GET_GAMESHIELD_ISUNDERATTACK,\n    GET_GAMESHIELD_BANDWIDTH,\n    GET_GAMESHIELD_ANALYTICS,\n\n    GET_FIREWALLS,\n    POST_FIREWALL_CREATE,\n    DELETE_FIREWALL,\n\n    GET_PLANS_AVAILABLE,\n\n    GET_PROFILE_TRANSACTIONS,\n    GET_PROFILE_INFOS,\n    GET_PROFILE_GENERALINFORMATION,\n\n    GET_NEO_SERVER_IPS,\n    GET_NEO_SERVER_REGIONS,\n\n    GET_VULNERABILITIES_GAMESHIELD,\n    POST_VULNERABILITIES,\n    GET_VULNERABILITIES_ALL,\n    DELETE_VULNERABILITIES,\n\n    GET_WEBHOOKS,\n    POST_WEBHOOK_CREATE,\n    POST_WEBHOOK_TEST,\n    DELETE_WEBHOOK\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/core/request/RestAPIRequests.java", "chunked_list": ["package de.cubeattack.neoprotect.core.request;\n\nimport com.google.gson.Gson;\nimport com.squareup.okhttp.MediaType;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.RequestBody;\nimport de.cubeattack.api.libraries.org.json.JSONArray;\nimport de.cubeattack.api.libraries.org.json.JSONObject;\nimport de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.core.Config;", "import de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.Core;\nimport de.cubeattack.neoprotect.core.JsonBuilder;\nimport de.cubeattack.neoprotect.core.Permission;\nimport de.cubeattack.neoprotect.core.model.Backend;\nimport de.cubeattack.neoprotect.core.model.Firewall;\nimport de.cubeattack.neoprotect.core.model.Gameshield;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class RestAPIRequests {\n\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final String ipGetter = \"https://api4.my-ip.io/ip.json\";\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final String pasteServer = \"https://paste.neoprotect.net/documents\";\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final String statsServer = \"https://metrics.einfachesache.de/api/stats/plugin\";\n    private JSONArray neoServerIPs = null;\n    private boolean setup = false;\n    private final Core core;\n    private final RestAPIManager rest;\n\n    public RestAPIRequests(Core core) {\n        this.core = core;\n        this.rest = new RestAPIManager(core);\n\n        testCredentials();\n        attackCheckSchedule();\n        statsUpdateSchedule();\n        versionCheckSchedule();\n        neoServerIPsUpdateSchedule();\n", "        if (Config.isUpdateIP()) {\n            backendServerIPUpdater();\n        }\n    }\n\n    private String getIpv4() {\n        try {\n            return new ResponseManager(rest.callRequest(new Request.Builder().url(ipGetter).build())).getResponseBodyObject().getString(\"ip\");\n        }catch (Exception ignore){}\n        return null;\n    }\n\n    private JSONArray getNeoIPs() {\n        return new ResponseManager(rest.callRequest(rest.defaultBuilder().url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_NEO_SERVER_IPS)).build())).getResponseBodyArray();\n    }\n", "    public boolean isAPIInvalid(String apiKey) {\n        return !new ResponseManager(rest.callRequest(rest.defaultBuilder(apiKey).url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_ATTACKS)).build())).checkCode(200);\n    }\n\n    public boolean isGameshieldInvalid(String gameshieldID) {\n        return !new ResponseManager(rest.callRequest(rest.defaultBuilder().url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_GAMESHIELD_INFO, gameshieldID)).build())).checkCode(200);\n    }\n\n    public boolean isBackendInvalid(String backendID) {\n        return getBackends().stream().noneMatch(e -> e.compareById(backendID));\n    }\n\n    private boolean isAttack() {\n        return rest.request(RequestType.GET_GAMESHIELD_ISUNDERATTACK, null, Config.getGameShieldID()).getResponseBody().equals(\"true\");\n    }\n", "    public boolean isBackendInvalid(String backendID) {\n        return getBackends().stream().noneMatch(e -> e.compareById(backendID));\n    }\n\n    private boolean isAttack() {\n        return rest.request(RequestType.GET_GAMESHIELD_ISUNDERATTACK, null, Config.getGameShieldID()).getResponseBody().equals(\"true\");\n    }\n\n    public String getPlan() {\n        try {\n            return rest.request(RequestType.GET_GAMESHIELD_PLAN, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"gameShieldPlan\").getJSONObject(\"options\").getString(\"name\");\n        }catch (Exception ignore){}\n        return null;\n    }\n\n    private boolean updateStats(RequestBody requestBody, String gameshieldID, String backendID) {\n        return new ResponseManager(rest.callRequest(new Request.Builder().url(statsServer).header(\"GameshieldID\", gameshieldID).header(\"BackendID\", backendID).post(requestBody).build())).checkCode(200);\n    }\n\n    private boolean updateBackend(RequestBody requestBody, String backendID) {\n        return rest.request(RequestType.POST_GAMESHIELD_BACKEND_UPDATE, requestBody, Config.getGameShieldID(),backendID).checkCode(200);\n    }\n", "    public String getPlan() {\n        try {\n            return rest.request(RequestType.GET_GAMESHIELD_PLAN, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"gameShieldPlan\").getJSONObject(\"options\").getString(\"name\");\n        }catch (Exception ignore){}\n        return null;\n    }\n\n    private boolean updateStats(RequestBody requestBody, String gameshieldID, String backendID) {\n        return new ResponseManager(rest.callRequest(new Request.Builder().url(statsServer).header(\"GameshieldID\", gameshieldID).header(\"BackendID\", backendID).post(requestBody).build())).checkCode(200);\n    }\n\n    private boolean updateBackend(RequestBody requestBody, String backendID) {\n        return rest.request(RequestType.POST_GAMESHIELD_BACKEND_UPDATE, requestBody, Config.getGameShieldID(),backendID).checkCode(200);\n    }\n", "    public void setProxyProtocol(boolean setting) {\n        rest.request(RequestType.POST_GAMESHIELD_UPDATE, RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"proxyProtocol\", String.valueOf(setting)).build().toString()), Config.getGameShieldID());\n    }\n\n    public JSONObject getAnalytics() {\n        return rest.request(RequestType.GET_GAMESHIELD_LASTSTATS, null, Config.getGameShieldID()).getResponseBodyObject();\n    }\n\n    public JSONObject getTraffic() {\n        return rest.request(RequestType.GET_GAMESHIELD_BANDWIDTH, null, Config.getGameShieldID()).getResponseBodyObject();\n    }\n", "    public JSONObject getTraffic() {\n        return rest.request(RequestType.GET_GAMESHIELD_BANDWIDTH, null, Config.getGameShieldID()).getResponseBodyObject();\n    }\n\n    public void testCredentials() {\n\n        if (isAPIInvalid(Config.getAPIKey())) {\n            core.severe(\"API is not valid! Please run /neoprotect setup to set the API Key\");\n            setup = false;\n            return;\n        } else if (isGameshieldInvalid(Config.getGameShieldID())) {\n            core.severe(\"Gameshield is not valid! Please run /neoprotect setgameshield to set the gameshield\");\n            setup = false;\n            return;", "        } else if (isGameshieldInvalid(Config.getGameShieldID())) {\n            core.severe(\"Gameshield is not valid! Please run /neoprotect setgameshield to set the gameshield\");\n            setup = false;\n            return;\n        } else if (isBackendInvalid(Config.getBackendID())) {\n            core.severe(\"Backend is not valid! Please run /neoprotect setbackend to set the backend\");\n            setup = false;\n            return;\n        }\n\n        this.setup = true;\n        setProxyProtocol(Config.isProxyProtocol());\n\n        Config.addAutoUpdater(getPlan().equalsIgnoreCase(\"Basic\"));\n    }\n", "    public String paste(String content) {\n        try {\n            return new ResponseManager(rest.callRequest(new Request.Builder().url(pasteServer)\n                    .post(RequestBody.create(MediaType.parse(\"text/plain\"), content)).build())).getResponseBodyObject().getString(\"key\");\n        } catch (Exception ignore) {}\n        return null;\n    }\n\n    public boolean togglePanicMode() {\n        JSONObject settings = rest.request(RequestType.GET_GAMESHIELD_INFO, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"gameShieldSettings\");\n        String mitigationSensitivity = settings.getString(\"mitigationSensitivity\");\n", "    public boolean togglePanicMode() {\n        JSONObject settings = rest.request(RequestType.GET_GAMESHIELD_INFO, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"gameShieldSettings\");\n        String mitigationSensitivity = settings.getString(\"mitigationSensitivity\");\n\n        if (mitigationSensitivity.equals(\"UNDER_ATTACK\")) {\n            rest.request(RequestType.POST_GAMESHIELD_UPDATE,\n                    RequestBody.create(MediaType.parse(\"application/json\"), settings.put(\"mitigationSensitivity\", \"MEDIUM\").toString()),\n                    Config.getGameShieldID());\n            return false;\n        } else {\n            rest.request(RequestType.POST_GAMESHIELD_UPDATE,\n                    RequestBody.create(MediaType.parse(\"application/json\"), settings.put(\"mitigationSensitivity\", \"UNDER_ATTACK\").toString()),\n                    Config.getGameShieldID());\n            return true;\n        }\n    }\n", "    public int toggle(String mode) {\n        JSONObject settings = rest.request(RequestType.GET_GAMESHIELD_INFO, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"gameShieldSettings\");\n\n        if(!settings.has(mode)) return -1;\n\n        boolean mitigationSensitivity = settings.getBoolean(mode);\n\n        if (mitigationSensitivity) {\n            int code = rest.request(RequestType.POST_GAMESHIELD_UPDATE,\n                    RequestBody.create(MediaType.parse(\"application/json\"), settings.put(mode, false).toString()),\n                    Config.getGameShieldID()).getCode();\n\n            return code == 200 ? 0 : code;\n        } else {\n            int code = rest.request(RequestType.POST_GAMESHIELD_UPDATE,\n                    RequestBody.create(MediaType.parse(\"application/json\"), settings.put(mode, true).toString()),\n                    Config.getGameShieldID()).getCode();\n\n            return code == 200 ? 1 : code;\n        }\n    }\n\n    public List<Gameshield> getGameshields() {\n        List<Gameshield> list = new ArrayList<>();\n\n        JSONArray gameshields = rest.request(RequestType.GET_GAMESHIELDS, null).getResponseBodyArray();\n", "        for (Object object : gameshields) {\n            JSONObject jsonObject = (JSONObject) object;\n            list.add(new Gameshield(jsonObject.getString(\"id\"), jsonObject.getString(\"name\")));\n        }\n\n        return list;\n    }\n\n    public List<Backend> getBackends() {\n        List<Backend> list = new ArrayList<>();\n        JSONArray backends = rest.request(RequestType.GET_GAMESHIELD_BACKENDS, null, Config.getGameShieldID()).getResponseBodyArray();\n", "        for (Object object : backends) {\n            JSONObject jsonObject = (JSONObject) object;\n            list.add(new Backend(jsonObject.getString(\"id\"), jsonObject.getString(\"ipv4\"), String.valueOf(jsonObject.getInt(\"port\")), jsonObject.getBoolean(\"geyser\")));\n        }\n\n        return list;\n    }\n\n    public List<Firewall> getFirewall(String mode) {\n        List<Firewall> list = new ArrayList<>();\n        JSONArray firewalls = rest.request(RequestType.GET_FIREWALLS, null, Config.getGameShieldID(), mode.toUpperCase()).getResponseBodyArray();\n", "        for (Object object : firewalls) {\n            JSONObject firewallJSON = (JSONObject) object;\n            list.add(new Firewall(firewallJSON.getString(\"ip\"), firewallJSON.get(\"id\").toString()));\n        }\n\n        return list;\n    }\n\n    public int updateFirewall(String ip, String action, String mode) {\n        if(action.equalsIgnoreCase(\"REMOVE\")){\n            Firewall firewall = getFirewall(mode).stream().filter(f -> f.getIp().equals(ip)).findFirst().orElse(null);\n", "    public int updateFirewall(String ip, String action, String mode) {\n        if(action.equalsIgnoreCase(\"REMOVE\")){\n            Firewall firewall = getFirewall(mode).stream().filter(f -> f.getIp().equals(ip)).findFirst().orElse(null);\n\n            if(firewall == null){\n                return 0;\n            }\n\n            return rest.request(RequestType.DELETE_FIREWALL, null, Config.getGameShieldID(), firewall.getId()).getCode();\n        }else if(action.equalsIgnoreCase(\"ADD\")){\n            RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"entry\", ip).build().toString());\n            return rest.request(RequestType.POST_FIREWALL_CREATE, requestBody, Config.getGameShieldID(), mode).getCode();\n        }\n        return -1;\n    }\n\n    private void statsUpdateSchedule() {\n\n        core.info(\"StatsUpdate scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n            @Override", "        }else if(action.equalsIgnoreCase(\"ADD\")){\n            RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"entry\", ip).build().toString());\n            return rest.request(RequestType.POST_FIREWALL_CREATE, requestBody, Config.getGameShieldID(), mode).getCode();\n        }\n        return -1;\n    }\n\n    private void statsUpdateSchedule() {\n\n        core.info(\"StatsUpdate scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n            @Override", "            public void run() {\n\n                if (!setup) return;\n\n                RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), new Gson().toJson(core.getPlugin().getStats()));\n                if(!updateStats(requestBody, Config.getGameShieldID(),Config.getBackendID()))\n                    core.debug(\"Request to Update stats failed\");\n            }\n        }, 1000, 1000 * 5);\n    }\n\n    private void neoServerIPsUpdateSchedule() {\n\n        core.info(\"NeoServerIPsUpdate scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n            @Override", "            public void run() {\n                JSONArray IPs = getNeoIPs();\n                neoServerIPs = IPs.isEmpty() ? neoServerIPs : IPs;\n            }\n        }, 0, 1000 * 60);\n    }\n\n    private void versionCheckSchedule() {\n\n        core.info(\"VersionCheck scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n            @Override", "            public void run() {\n                core.setVersionResult(VersionUtils.checkVersion(\"NeoProtect\", \"NeoPlugin\", \"v\" + core.getPlugin().getPluginVersion(), Config.getAutoUpdaterSettings()));\n            }\n        }, 1000 * 10, 1000 * 60 * 5);\n    }\n\n    private void attackCheckSchedule() {\n\n        core.info(\"AttackCheck scheduler started\");\n\n        final Boolean[] attackRunning = {false};\n\n        new Timer().schedule(new TimerTask() {\n            @Override", "            public void run() {\n\n                if (!setup) return;\n\n                if (!isAttack()) {\n                    attackRunning[0] = false;\n                    return;\n                }\n\n                if (!attackRunning[0]) {\n                    core.warn(\"Gameshield ID '\" + Config.getGameShieldID() + \"' is under attack\");\n                    core.getPlugin().sendAdminMessage(Permission.NOTIFY, \"Gameshield ID '\" + Config.getGameShieldID() + \"' is under attack\", null, null, null, null);\n                    attackRunning[0] = true;\n                }\n            }\n        }, 1000 * 5, 1000 * 10);\n    }\n\n    private void backendServerIPUpdater() {\n\n        core.info(\"BackendServerIPUpdate scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n\n            @Override", "                if (!attackRunning[0]) {\n                    core.warn(\"Gameshield ID '\" + Config.getGameShieldID() + \"' is under attack\");\n                    core.getPlugin().sendAdminMessage(Permission.NOTIFY, \"Gameshield ID '\" + Config.getGameShieldID() + \"' is under attack\", null, null, null, null);\n                    attackRunning[0] = true;\n                }\n            }\n        }, 1000 * 5, 1000 * 10);\n    }\n\n    private void backendServerIPUpdater() {\n\n        core.info(\"BackendServerIPUpdate scheduler started\");\n\n        new Timer().schedule(new TimerTask() {\n\n            @Override", "            public void run() {\n\n                if (!setup) return;\n\n                Backend javaBackend = getBackends().stream().filter(unFilteredBackend -> unFilteredBackend.compareById(Config.getBackendID())).findAny().orElse(null);\n                Backend geyserBackend = getBackends().stream().filter(unFilteredBackend -> unFilteredBackend.compareById(Config.getGeyserBackendID())).findAny().orElse(null);\n\n                String ip = getIpv4();\n                if (ip == null) return;\n\n                if (javaBackend != null) {", "                if (ip == null) return;\n\n                if (javaBackend != null) {\n                    if (!ip.equals(javaBackend.getIp())) {\n                        RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"ipv4\", ip).build().toString());\n\n                        if (!updateBackend(requestBody, Config.getBackendID())) {\n                            core.warn(\"Update java backendserver ID '\" + Config.getBackendID() + \"' to IP '\" + ip + \"' failed\");\n                        } else {\n                            core.info(\"Update java backendserver ID '\" + Config.getBackendID() + \"' to IP '\" + ip + \"' success\");\n                            javaBackend.setIp(ip);\n                        }\n                    }\n                }\n", "                if (geyserBackend != null) {\n                    if (!ip.equals(geyserBackend.getIp())) {\n                        RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"ipv4\", ip).build().toString());\n\n                        if (!updateBackend(requestBody, Config.getGeyserBackendID())) {\n                            core.warn(\"Update geyser backendserver ID '\" + Config.getGeyserBackendID() + \"' to IP '\" + ip + \"' failed\");\n                        } else {\n                            core.info(\"Update geyser backendserver ID '\" + Config.getGeyserBackendID() + \"' to IP '\" + ip + \"' success\");\n                            geyserBackend.setIp(ip);\n                        }\n                    }\n                }\n            }\n        }, 1000, 1000 * 20);\n    }\n", "    public JSONArray getNeoServerIPs() {\n        return neoServerIPs;\n    }\n\n    public String getStatsServer() {\n        return statsServer;\n    }\n\n    public boolean isSetup() {\n        return setup;\n    }\n}\n", "    public boolean isSetup() {\n        return setup;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/Startup.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot;\n\nimport de.cubeattack.neoprotect.spigot.command.NeoProtectCommand;\nimport de.cubeattack.neoprotect.spigot.command.NeoProtectTabCompleter;\nimport de.cubeattack.neoprotect.spigot.listener.ChatListener;\nimport de.cubeattack.neoprotect.spigot.listener.DisconnectListener;\nimport de.cubeattack.neoprotect.spigot.listener.LoginListener;\nimport de.cubeattack.neoprotect.spigot.proxyprotocol.ProxyProtocol;\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.PluginManager;", "import org.bukkit.Bukkit;\nimport org.bukkit.plugin.PluginManager;\n\nimport java.util.Objects;\n\npublic class Startup {\n\n    public Startup(NeoProtectSpigot instance) {\n        register(instance);\n        new ProxyProtocol(instance);\n    }\n\n    private void register(NeoProtectSpigot instance) {\n        PluginManager pm = Bukkit.getPluginManager();\n        Objects.requireNonNull(instance.getCommand(\"neoprotect\")).setExecutor(new NeoProtectCommand(instance));\n        Objects.requireNonNull(instance.getCommand(\"neoprotect\")).setTabCompleter(new NeoProtectTabCompleter(instance));\n\n        pm.registerEvents(new ChatListener(instance), instance);\n        pm.registerEvents(new LoginListener(instance), instance);\n        pm.registerEvents(new DisconnectListener(instance), instance);\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/NeoProtectSpigot.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot;\n\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.Core;\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport de.cubeattack.neoprotect.core.Permission;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport net.md_5.bungee.api.chat.ClickEvent;\nimport net.md_5.bungee.api.chat.ComponentBuilder;\nimport net.md_5.bungee.api.chat.HoverEvent;", "import net.md_5.bungee.api.chat.ComponentBuilder;\nimport net.md_5.bungee.api.chat.HoverEvent;\nimport net.md_5.bungee.api.chat.TextComponent;\nimport org.bstats.bukkit.Metrics;\nimport org.bstats.charts.SimplePie;\nimport org.bukkit.command.ConsoleCommandSender;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.ArrayList;", "\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class NeoProtectSpigot extends JavaPlugin implements NeoProtectPlugin {\n\n    private static Core core;\n\n    @Override\n    public void onLoad() {\n        Metrics metrics = new Metrics(this, 18725);\n        metrics.addCustomChart(new SimplePie(\"language\", Config::getLanguage));\n    }\n\n    @Override", "    public void onLoad() {\n        Metrics metrics = new Metrics(this, 18725);\n        metrics.addCustomChart(new SimplePie(\"language\", Config::getLanguage));\n    }\n\n    @Override\n    public void onEnable() {\n        core = new Core(this);\n        new Startup(this);\n    }\n", "    public Core getCore() {\n        return core;\n    }\n\n    @Override\n    public Stats getStats() {\n        return new Stats(\n                getPluginType(),\n                getServer().getVersion(),\n                getServer().getName(),\n                System.getProperty(\"java.version\"),\n                System.getProperty(\"os.name\"),\n                System.getProperty(\"os.arch\"),\n                System.getProperty(\"os.version\"),\n                getPluginVersion(),\n                getCore().getVersionResult().getVersionStatus().toString(),\n                Config.getAutoUpdaterSettings().toString(),\n                getCore().isSetup() ? getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\",\n                Arrays.toString(getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray()),\n                getServer().getOnlinePlayers().size(),\n                0,\n                Runtime.getRuntime().availableProcessors(),\n                getServer().getOnlineMode(),\n                Config.isProxyProtocol()\n        );\n    }\n\n    @Override", "    public void sendMessage(Object receiver, String text) {\n        sendMessage(receiver, text, null, null, null, null);\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public void sendMessage(Object receiver, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        TextComponent msg = new TextComponent(core.getPrefix() + text);\n\n        if (clickAction != null)\n            msg.setClickEvent(new ClickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));", "        if (clickAction != null)\n            msg.setClickEvent(new ClickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));\n        if (hoverAction != null)\n            msg.setHoverEvent(new HoverEvent(HoverEvent.Action.valueOf(hoverAction), new ComponentBuilder(hoverMsg).create()));\n        if (receiver instanceof ConsoleCommandSender) ((ConsoleCommandSender) receiver).sendMessage(msg.toLegacyText());\n        if (receiver instanceof Player) ((Player) receiver).spigot().sendMessage(msg);\n    }\n\n    @Override\n    public void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        getServer().getOnlinePlayers().forEach(pp -> {", "    public void sendAdminMessage(Permission permission, String text, String clickAction, String clickMsg, String hoverAction, String hoverMsg) {\n        getServer().getOnlinePlayers().forEach(pp -> {\n            if (pp.hasPermission(\"neoprotect.admin\") || pp.hasPermission(permission.value))\n                sendMessage(pp, text, clickAction, clickMsg, hoverAction, hoverMsg);\n        });\n    }\n\n    @Override\n    public void sendKeepAliveMessage(Object sender, long id) {}\n\n    @Override", "    public void sendKeepAliveMessage(Object sender, long id) {}\n\n    @Override\n    public long sendKeepAliveMessage(long id) {\n        return id;\n    }\n\n\n    @Override\n    public ArrayList<String> getPlugins() {\n        ArrayList<String> plugins = new ArrayList<>();\n        Arrays.stream(getServer().getPluginManager().getPlugins()).forEach(p -> plugins.add(p.getName()));\n        return plugins;\n    }\n\n    @Override", "    public PluginType getPluginType() {\n        return PluginType.SPIGOT;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        return getDescription().getVersion();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/proxyprotocol/ProxyProtocol.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.proxyprotocol;\n\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.spigot.NeoProtectSpigot;\nimport io.netty.channel.*;\nimport io.netty.handler.codec.haproxy.HAProxyMessage;\nimport io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\nimport org.bukkit.Bukkit;\nimport org.bukkit.scheduler.BukkitRunnable;\n", "import org.bukkit.scheduler.BukkitRunnable;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\n\n/**\n * Represents a very tiny alternative to ProtocolLib.\n * <p>\n * It now supports intercepting packets during login and status ping (such as OUT_SERVER_PING)!", " * <p>\n * It now supports intercepting packets during login and status ping (such as OUT_SERVER_PING)!\n *\n * @author Kristian // Love ya <3 ~ytendx\n */\npublic class ProxyProtocol {\n\n    // Looking up ServerConnection\n    private final Class<Object> minecraftServerClass = Reflection.getUntypedClass(\"{nms}.MinecraftServer\");\n    private final Class<Object> serverConnectionClass = Reflection.getUntypedClass(\"{nms}\" + (Reflection.isNewerPackage() ? \".network\" : \"\") + \".ServerConnection\");\n    private final Reflection.FieldAccessor<Object> getMinecraftServer = Reflection.getField(\"{obc}.CraftServer\", minecraftServerClass, 0);\n    private final Reflection.FieldAccessor<Object> getServerConnection = Reflection.getField(minecraftServerClass, serverConnectionClass, 0);\n    private final Reflection.MethodInvoker getNetworkMarkers = !Reflection.isNewerPackage() && !Reflection.VERSION.contains(\"16\") ? Reflection.getTypedMethod(serverConnectionClass, null, List.class, serverConnectionClass) : null;\n    private final Reflection.FieldAccessor<List> networkManagersFieldAccessor = Reflection.isNewerPackage() || Reflection.VERSION.contains(\"16\") ? Reflection.getField(serverConnectionClass, List.class, 0) : null;\n    private final Class<Object> networkManager = Reflection.getUntypedClass(Reflection.isNewerPackage() ? \"net.minecraft.network.NetworkManager\" : \"{nms}.NetworkManager\");\n    private final Reflection.FieldAccessor<SocketAddress> socketAddressFieldAccessor = Reflection.getField(networkManager, SocketAddress.class, 0);\n\n    private List<Object> networkManagers;\n    private ServerChannelInitializer serverChannelHandler;\n    private ChannelInitializer<Channel> beginInitProtocol;\n    private ChannelInitializer<Channel> endInitProtocol;\n\n    protected NeoProtectSpigot instance;\n\n    /**\n     * Construct a new instance of TinyProtocol, and start intercepting packets for all connected clients and future clients.\n     * <p>\n     * You can construct multiple instances per plugin.\n     *\n     * @param instance - the plugin.\n     */\n    public ProxyProtocol(NeoProtectSpigot instance) {\n        this.instance = instance;\n", "        try {\n            instance.getCore().info(\"Proceeding with the server channel injection...\");\n            registerChannelHandler();\n        } catch (IllegalArgumentException ex) {\n            // Damn you, late bind\n            instance.getCore().info(\"Delaying server channel injection due to late bind.\");\n\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    registerChannelHandler();\n                    instance.getCore().info(\"Late bind injection successful.\");\n                }\n            }.runTask(instance);\n        }\n    }\n\n    private void createServerChannelHandler() {\n        // Handle connected channels\n        endInitProtocol = new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel channel) {\n", "                public void run() {\n                    registerChannelHandler();\n                    instance.getCore().info(\"Late bind injection successful.\");\n                }\n            }.runTask(instance);\n        }\n    }\n\n    private void createServerChannelHandler() {\n        // Handle connected channels\n        endInitProtocol = new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel channel) {\n", "                if (!Config.isProxyProtocol() | !instance.getCore().isSetup() | instance.getCore().getDirectConnectWhitelist().contains(((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress())) {\n                    instance.getCore().debug(\"Plugin is not setup / ProxyProtocol is off / Player is on DirectConnectWhitelist (return)\");\n                    return;\n                }\n\n                if (instance.getCore().isSetup() && (instance.getCore().getRestAPI().getNeoServerIPs() == null ||\n                        instance.getCore().getRestAPI().getNeoServerIPs().toList().stream().noneMatch(ipRange -> isIPInRange((String) ipRange, ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress())))) {\n                    channel.close();\n                    instance.getCore().debug(\"Player connected over IP (\" + channel.remoteAddress() + \") doesn't match to Neo-IPs (warning)\");\n                    return;\n                }\n", "                try {\n                    instance.getCore().debug(\"Adding Handler...\");\n                    synchronized (networkManagers) {\n                        // Adding the decoder to the pipeline\n                        channel.pipeline().addFirst(\"haproxy-decoder\", new HAProxyMessageDecoder());\n                        // Adding the proxy message handler to the pipeline too\n                        channel.pipeline().addAfter(\"haproxy-decoder\", \"haproxy-handler\", HAPROXY_MESSAGE_HANDLER);\n                    }\n\n                    instance.getCore().debug(\"Connecting finished\");\n\n                } catch (Exception ex) {\n                    instance.getCore().severe(\"Cannot inject incoming channel \" + channel, ex);\n                }\n            }\n\n        };\n\n        // This is executed before Minecraft's channel handler\n        beginInitProtocol = new ChannelInitializer<Channel>() {\n\n            @Override\n            protected void initChannel(Channel channel) {\n                channel.pipeline().addLast(endInitProtocol);\n            }\n\n        };\n\n        serverChannelHandler = new ServerChannelInitializer();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void registerChannelHandler() {\n        Object mcServer = getMinecraftServer.get(Bukkit.getServer());\n        Object serverConnection = getServerConnection.get(mcServer);\n        boolean looking = true;\n\n        // We need to synchronize against this list\n        networkManagers = Reflection.isNewerPackage() || Reflection.VERSION.contains(\"16\") ? networkManagersFieldAccessor.get(serverConnection) : (List<Object>) getNetworkMarkers.invoke(null, serverConnection);\n        createServerChannelHandler();\n\n        // Find the correct list, or implicitly throw an exception", "        for (int i = 0; looking; i++) {\n            List<Object> list = Reflection.getField(serverConnection.getClass(), List.class, i).get(serverConnection);\n\n            for (Object item : list) {\n                if (!(item instanceof ChannelFuture))\n                    break;\n\n                // Channel future that contains the server connection\n                Channel serverChannel = ((ChannelFuture) item).channel();\n\n\n                serverChannel.pipeline().addFirst(serverChannelHandler);\n                looking = false;\n\n                this.instance.getCore().info(\"Found the server channel and added the handler. Injection successfully!\");\n            }\n        }\n    }\n\n    private final HAProxyMessageHandler HAPROXY_MESSAGE_HANDLER = new HAProxyMessageHandler();\n\n    @ChannelHandler.Sharable", "    public class HAProxyMessageHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HAProxyMessage)) {\n                super.channelRead(ctx, msg);\n                return;\n            }\n\n            try {\n                final HAProxyMessage message = (HAProxyMessage) msg;\n\n                // Set the SocketAddress field of the NetworkManager (\"packet_handler\" handler) to the client address\n                socketAddressFieldAccessor.set(ctx.channel().pipeline().get(\"packet_handler\"), new InetSocketAddress(message.sourceAddress(), message.sourcePort()));\n            } catch (Exception exception) {\n                // Closing the channel because we do not want people on the server with a proxy ip\n                ctx.channel().close();\n\n                // Logging for the lovely server admins :)\n                instance.getCore().severe(\"Error: The server was unable to set the IP address from the 'HAProxyMessage'. Therefore we closed the channel.\", exception);\n            }\n        }\n    }\n\n    @ChannelHandler.Sharable\n    class ServerChannelInitializer extends ChannelInboundHandlerAdapter {\n        @Override", "            try {\n                final HAProxyMessage message = (HAProxyMessage) msg;\n\n                // Set the SocketAddress field of the NetworkManager (\"packet_handler\" handler) to the client address\n                socketAddressFieldAccessor.set(ctx.channel().pipeline().get(\"packet_handler\"), new InetSocketAddress(message.sourceAddress(), message.sourcePort()));\n            } catch (Exception exception) {\n                // Closing the channel because we do not want people on the server with a proxy ip\n                ctx.channel().close();\n\n                // Logging for the lovely server admins :)\n                instance.getCore().severe(\"Error: The server was unable to set the IP address from the 'HAProxyMessage'. Therefore we closed the channel.\", exception);\n            }\n        }\n    }\n\n    @ChannelHandler.Sharable\n    class ServerChannelInitializer extends ChannelInboundHandlerAdapter {\n        @Override", "        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            Channel channel = (Channel) msg;\n\n            instance.getCore().debug(\"Open channel (\" + channel.remoteAddress().toString() + \")\");\n\n            if (channel.localAddress().toString().startsWith(\"local:\") || ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress().equals(Config.getGeyserServerIP())) {\n                instance.getCore().debug(\"Detected bedrock player (return)\");\n                return;\n            }\n\n            // Prepare to initialize ths channel\n            channel.pipeline().addFirst(beginInitProtocol);\n            ctx.fireChannelRead(msg);\n        }\n    }\n", "    public static boolean isIPInRange(String ipRange, String ipAddress) {\n        if(!ipRange.contains(\"/\")){\n            ipRange = ipRange + \"/32\";\n        }\n\n        long targetIntAddress = ipToDecimal(ipAddress);\n\n        int range = Integer.parseInt(ipRange.split(\"/\")[1]);\n        String startIP = ipRange.split(\"/\")[0];\n\n        long startIntAddress = ipToDecimal(startIP);\n\n        return targetIntAddress <= (startIntAddress + (long) Math.pow(2, (32 - range))) && targetIntAddress >= startIntAddress;\n    }\n", "    public static long ipToDecimal(String ipAddress) throws IllegalArgumentException {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return -1;\n        }\n\n        long decimal = 0;\n        for (int i = 0; i < 4; i++) {\n            int octet = Integer.parseInt(parts[i]);\n            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n", "            if (octet < 0 || octet > 255) {\n                return -1;\n            }\n            decimal += (long) (octet * Math.pow(256, 3 - i));\n        }\n\n        return decimal;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/proxyprotocol/Reflection.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.proxyprotocol;\n\nimport org.bukkit.Bukkit;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;", "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * An utility class that simplifies reflection in Bukkit plugins.\n *\n * @author Kristian\n */\npublic final class Reflection {\n    /**\n     * An interface for invoking a specific constructor.\n     */", "public final class Reflection {\n    /**\n     * An interface for invoking a specific constructor.\n     */\n    public interface ConstructorInvoker {\n        /**\n         * Invoke a constructor for a specific class.\n         *\n         * @param arguments - the arguments to pass to the constructor.\n         * @return The constructed object.\n         */\n        Object invoke(Object... arguments);\n    }\n\n    /**\n     * An interface for invoking a specific method.\n     */", "    public interface MethodInvoker {\n        /**\n         * Invoke a method on a specific target object.\n         *\n         * @param target    - the target object, or NULL for a static method.\n         * @param arguments - the arguments to pass to the method.\n         * @return The return value, or NULL if is void.\n         */\n        Object invoke(Object target, Object... arguments);\n    }\n\n    /**\n     * An interface for retrieving the field content.\n     *\n     * @param <T> - field type.\n     */", "    public interface FieldAccessor<T> {\n        /**\n         * Retrieve the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @return The value of the field.\n         */\n        T get(Object target);\n\n        /**\n         * Set the content of a field.\n         *\n         * @param target - the target object, or NULL for a static field.\n         * @param value  - the new value of the field.\n         */\n        void set(Object target, Object value);\n\n        /**\n         * Determine if the given object has this field.\n         *\n         * @param target - the object to test.\n         * @return TRUE if it does, FALSE otherwise.\n         */\n        boolean hasField(Object target);\n    }\n\n    // Deduce the net.minecraft.server.v* package", "    public static String OBC_PREFIX = Bukkit.getServer().getClass().getPackage().getName();\n    public static String VERSION = OBC_PREFIX.replace(\"org.bukkit.craftbukkit\", \"\").replace(\".\", \"\");\n    public static String NMS_PREFIX = (Reflection.isNewerPackage() ?\n            OBC_PREFIX.replace(\"org.bukkit.craftbukkit\", \"net.minecraft.server\").replace(VERSION, \"\") :\n            OBC_PREFIX.replace(\"org.bukkit.craftbukkit\", \"net.minecraft.server\"));\n\n    // Variable replacement\n    private static final Pattern MATCH_VARIABLE = Pattern.compile(\"\\\\{([^\\\\}]+)\\\\}\");\n\n    private Reflection() {\n        // Seal class\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType) {\n        return getField(target, name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param name      - the name of the field, or NULL to ignore.\n     * @param fieldType - a compatible field type.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(String className, String name, Class<T> fieldType) {\n        return getField(getClass(className), name, fieldType, 0);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param target    - the target type.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, int index) {\n        return getField(target, null, fieldType, index);\n    }\n\n    /**\n     * Retrieve a field accessor for a specific field type and name.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param fieldType - a compatible field type.\n     * @param index     - the number of compatible fields to skip.\n     * @return The field accessor.\n     */\n    public static <T> FieldAccessor<T> getField(String className, Class<T> fieldType, int index) {\n        return getField(getClass(className), fieldType, index);\n    }\n\n    // Common method\n    private static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType, int index) {", "        for (final Field field : target.getDeclaredFields()) {\n            if ((name == null || field.getName().equals(name)) && fieldType.isAssignableFrom(field.getType()) && index-- <= 0) {\n                field.setAccessible(true);\n\n                // A function for retrieving a specific field value\n                return new FieldAccessor<T>() {\n\n                    @Override\n                    @SuppressWarnings(\"unchecked\")\n                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public T get(Object target) {\n                        try {\n                            return (T) field.get(target);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override", "                    public void set(Object target, Object value) {\n                        try {\n                            field.set(target, value);\n                        } catch (IllegalAccessException e) {\n                            throw new RuntimeException(\"Cannot access reflection.\", e);\n                        }\n                    }\n\n                    @Override\n                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes", "                    public boolean hasField(Object target) {\n                        // target instanceof DeclaringClass\n                        return field.getDeclaringClass().isAssignableFrom(target.getClass());\n                    }\n                };\n            }\n        }\n\n        // Search in parent classes\n        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), name, fieldType, index);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param className  - lookup name of the class, see {@link #getClass(String)}.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "        if (target.getSuperclass() != null)\n            return getField(target.getSuperclass(), name, fieldType, index);\n\n        throw new IllegalArgumentException(\"Cannot find field with type \" + fieldType);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param className  - lookup name of the class, see {@link #getClass(String)}.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getMethod(String className, String methodName, Class<?>... params) {\n        return getTypedMethod(getClass(className), methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getMethod(Class<?> clazz, String methodName, Class<?>... params) {\n        return getTypedMethod(clazz, methodName, null, params);\n    }\n\n    /**\n     * Search for the first publicly and privately defined method of the given name and parameter count.\n     *\n     * @param clazz      - a class to start with.\n     * @param methodName - the method name, or NULL to skip.\n     * @param returnType - the expected return type, or NULL to ignore.\n     * @param params     - the expected parameters.\n     * @return An object that invokes this specific method.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static MethodInvoker getTypedMethod(Class<?> clazz, String methodName, Class<?> returnType, Class<?>... params) {\n        for (final Method method : clazz.getDeclaredMethods()) {\n            if ((methodName == null || method.getName().equals(methodName))\n                    && (returnType == null || method.getReturnType().equals(returnType))\n                    && Arrays.equals(method.getParameterTypes(), params)) {\n                method.setAccessible(true);\n\n                return new MethodInvoker() {\n\n                    @Override\n                    public Object invoke(Object target, Object... arguments) {", "                    public Object invoke(Object target, Object... arguments) {\n                        try {\n                            return method.invoke(target, arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke method \" + method, e);\n                        }\n                    }\n\n                };\n            }\n        }\n\n        // Search in every superclass", "        if (clazz.getSuperclass() != null)\n            return getMethod(clazz.getSuperclass(), methodName, params);\n\n        throw new IllegalStateException(String.format(\"Unable to find method %s (%s).\", methodName, Arrays.asList(params)));\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param className - lookup name of the class, see {@link #getClass(String)}.\n     * @param params    - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static ConstructorInvoker getConstructor(String className, Class<?>... params) {\n        return getConstructor(getClass(className), params);\n    }\n\n    /**\n     * Search for the first publically and privately defined constructor of the given name and parameter count.\n     *\n     * @param clazz  - a class to start with.\n     * @param params - the expected parameters.\n     * @return An object that invokes this constructor.\n     * @throws IllegalStateException If we cannot find this method.\n     */", "    public static ConstructorInvoker getConstructor(Class<?> clazz, Class<?>... params) {\n        for (final Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n            if (Arrays.equals(constructor.getParameterTypes(), params)) {\n                constructor.setAccessible(true);\n\n                return new ConstructorInvoker() {\n\n                    @Override\n                    public Object invoke(Object... arguments) {\n                        try {\n                            return constructor.newInstance(arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke constructor \" + constructor, e);\n                        }\n                    }\n\n                };\n            }\n        }\n\n        throw new IllegalStateException(String.format(\"Unable to find constructor for %s (%s).\", clazz, Arrays.asList(params)));\n    }\n\n    /**\n     * Retrieve a class from its full name, without knowing its type on compile time.\n     * <p>\n     * This is useful when looking up fields by a NMS or OBC type.\n     * <p>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The class.\n     * @see {@link #getClass()} for more information.\n     */", "                    public Object invoke(Object... arguments) {\n                        try {\n                            return constructor.newInstance(arguments);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Cannot invoke constructor \" + constructor, e);\n                        }\n                    }\n\n                };\n            }\n        }\n\n        throw new IllegalStateException(String.format(\"Unable to find constructor for %s (%s).\", clazz, Arrays.asList(params)));\n    }\n\n    /**\n     * Retrieve a class from its full name, without knowing its type on compile time.\n     * <p>\n     * This is useful when looking up fields by a NMS or OBC type.\n     * <p>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The class.\n     * @see {@link #getClass()} for more information.\n     */", "    public static Class<Object> getUntypedClass(String lookupName) {\n        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n        Class<Object> clazz = (Class) getClass(lookupName);\n        return clazz;\n    }\n\n    /**\n     * Retrieve a class from its full name.\n     * <p>\n     * Strings enclosed with curly brackets - such as {TEXT} - will be replaced according to the following table:\n     * <p>\n     * <table border=\"1\">\n     * <tr>\n     * <th>Variable</th>\n     * <th>Content</th>\n     * </tr>\n     * <tr>\n     * <td>{nms}</td>\n     * <td>Actual package name of net.minecraft.server.VERSION</td>\n     * </tr>\n     * <tr>\n     * <td>{obc}</td>\n     * <td>Actual pacakge name of org.bukkit.craftbukkit.VERSION</td>\n     * </tr>\n     * <tr>\n     * <td>{version}</td>\n     * <td>The current Minecraft package VERSION, if any.</td>\n     * </tr>\n     * </table>\n     *\n     * @param lookupName - the class name with variables.\n     * @return The looked up class.\n     * @throws IllegalArgumentException If a variable or class could not be found.\n     */", "    public static Class<?> getClass(String lookupName) {\n        return getCanonicalClass(expandVariables(lookupName));\n    }\n\n    /**\n     * Retrieve a class in the net.minecraft.server.VERSION.* package.\n     *\n     * @param name - the name of the class, excluding the package.\n     * @throws IllegalArgumentException If the class doesn't exist.\n     */\n    public static Class<?> getMinecraftClass(String name) {\n        return getCanonicalClass(NMS_PREFIX + \".\" + name);\n    }\n\n    /**\n     * Retrieve a class in the org.bukkit.craftbukkit.VERSION.* package.\n     *\n     * @param name - the name of the class, excluding the package.\n     * @throws IllegalArgumentException If the class doesn't exist.\n     */", "    public static Class<?> getMinecraftClass(String name) {\n        return getCanonicalClass(NMS_PREFIX + \".\" + name);\n    }\n\n    /**\n     * Retrieve a class in the org.bukkit.craftbukkit.VERSION.* package.\n     *\n     * @param name - the name of the class, excluding the package.\n     * @throws IllegalArgumentException If the class doesn't exist.\n     */\n    public static Class<?> getCraftBukkitClass(String name) {\n        return getCanonicalClass(OBC_PREFIX + \".\" + name);\n    }\n\n    /**\n     * Retrieve a class by its canonical name.\n     *\n     * @param canonicalName - the canonical name.\n     * @return The class.\n     */\n    private static Class<?> getCanonicalClass(String canonicalName) {", "    public static Class<?> getCraftBukkitClass(String name) {\n        return getCanonicalClass(OBC_PREFIX + \".\" + name);\n    }\n\n    /**\n     * Retrieve a class by its canonical name.\n     *\n     * @param canonicalName - the canonical name.\n     * @return The class.\n     */\n    private static Class<?> getCanonicalClass(String canonicalName) {", "        try {\n            return Class.forName(canonicalName);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Cannot find \" + canonicalName, e);\n        }\n    }\n\n    public static boolean isNewerPackage() {\n        return VERSION.contains(\"17\") || VERSION.contains(\"18\") || VERSION.contains(\"19\") || VERSION.contains(\"20\");\n    }\n\n    /**\n     * Expand variables such as \"{nms}\" and \"{obc}\" to their corresponding packages.\n     *\n     * @param name - the full name of the class.\n     * @return The expanded string.\n     */", "    public static String expandVariables(String name) {\n        StringBuffer output = new StringBuffer();\n        Matcher matcher = MATCH_VARIABLE.matcher(name);\n\n        while (matcher.find()) {\n            String variable = matcher.group(1);\n            String replacement = \"\";\n\n            // Expand all detected variables\n            if (\"nms\".equalsIgnoreCase(variable))\n                replacement = isNewerPackage() ? \"net.minecraft.server\" : NMS_PREFIX;", "            if (\"nms\".equalsIgnoreCase(variable))\n                replacement = isNewerPackage() ? \"net.minecraft.server\" : NMS_PREFIX;\n            else if (\"obc\".equalsIgnoreCase(variable))\n                replacement = OBC_PREFIX;\n            else if (\"version\".equalsIgnoreCase(variable))\n                replacement = VERSION;\n            else\n                throw new IllegalArgumentException(\"Unknown variable: \" + variable);\n\n            // Assume the expanded variables are all packages, and append a dot\n            if (replacement.length() > 0 && matcher.end() < name.length() && name.charAt(matcher.end()) != '.')\n                replacement += \".\";\n            matcher.appendReplacement(output, Matcher.quoteReplacement(replacement));\n        }\n\n        matcher.appendTail(output);\n        return output.toString();\n    }\n}\n", "            if (replacement.length() > 0 && matcher.end() < name.length() && name.charAt(matcher.end()) != '.')\n                replacement += \".\";\n            matcher.appendReplacement(output, Matcher.quoteReplacement(replacement));\n        }\n\n        matcher.appendTail(output);\n        return output.toString();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/command/NeoProtectTabCompleter.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.command;\n\nimport de.cubeattack.neoprotect.core.NeoProtectPlugin;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.ArrayList;\nimport java.util.List;", "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NeoProtectTabCompleter implements TabCompleter {\n\n    private final NeoProtectPlugin instance;\n\n    public NeoProtectTabCompleter(NeoProtectPlugin instance) {\n        this.instance = instance;\n    }\n\n    @Override\n    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command cmd, @NotNull String label, @NotNull String[] args) {\n        List<String> list = new ArrayList<>();\n        List<String> completorList = new ArrayList<>();\n", "        if (args.length == 2 && args[0].equalsIgnoreCase(\"toggle\")) {\n            completorList.add(\"antiVPN\");\n            completorList.add(\"anycast\");\n            completorList.add(\"motdCache\");\n            completorList.add(\"blockForge\");\n            completorList.add(\"ipWhitelist\");\n            completorList.add(\"ipBlacklist\");\n            completorList.add(\"secureProfiles\");\n            completorList.add(\"advancedAntiBot\");\n            return completorList;\n        }\n", "        if (args.length >= 2 && (args[0].equalsIgnoreCase(\"whitelist\") || args[0].equalsIgnoreCase(\"blacklist\"))) {\n            completorList.add(\"add\");\n            completorList.add(\"remove\");\n        }\n\n        if (args.length != 1) {\n            return completorList;\n        }\n\n        list.add(\"setup\");\n", "        if (instance.getCore().isSetup()) {\n            list.add(\"directConnectWhitelist\");\n            list.add(\"setgameshield\");\n            list.add(\"setbackend\");\n            list.add(\"analytics\");\n            list.add(\"whitelist\");\n            list.add(\"blacklist\");\n            list.add(\"ipanic\");\n            list.add(\"toggle\");\n        }\n", "        for (String tab : list) {\n            if (tab.toLowerCase().startsWith(args[args.length - 1].toLowerCase())) {\n                completorList.add(tab);\n            }\n        }\n        return completorList;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/command/NeoProtectCommand.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.command;\n\nimport de.cubeattack.api.util.JavaUtils;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport de.cubeattack.neoprotect.spigot.NeoProtectSpigot;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;", "import org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Locale;\n\n\npublic class NeoProtectCommand implements CommandExecutor {\n\n    private final NeoProtectSpigot instance;\n\n    public NeoProtectCommand(NeoProtectSpigot instance) {\n        this.instance = instance;\n    }\n\n    @Override", "    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command cmd, @NotNull String label, @NotNull String[] args) {\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .viaConsole(!(sender instanceof Player))\n                .local(JavaUtils.javaVersionCheck() != 8 ? ((sender instanceof Player) ? Locale.forLanguageTag(((Player) sender).getLocale()) : Locale.ENGLISH) : Locale.ENGLISH)\n                .neoProtectPlugin(instance)\n                .sender(sender)\n                .args(args)\n                .executeCommand();\n\n        return false;\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/listener/ChatListener.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.listener;\n\nimport de.cubeattack.api.util.JavaUtils;\nimport de.cubeattack.neoprotect.core.executor.NeoProtectExecutor;\nimport de.cubeattack.neoprotect.spigot.NeoProtectSpigot;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\n", "import org.bukkit.event.player.AsyncPlayerChatEvent;\n\nimport java.util.Locale;\n\npublic class ChatListener implements Listener {\n\n    private final NeoProtectSpigot instance;\n\n    public ChatListener(NeoProtectSpigot instance) {\n        this.instance = instance;\n    }\n\n    @EventHandler", "    public void onChat(AsyncPlayerChatEvent event) {\n        Player player = event.getPlayer();\n\n        if (!player.hasPermission(\"neoprotect.admin\") || !instance.getCore().getPlayerInSetup().contains(player))\n            return;\n\n        event.setCancelled(true);\n\n        new NeoProtectExecutor.ExecutorBuilder()\n                .local(JavaUtils.javaVersionCheck() != 8 ? Locale.forLanguageTag(player.getLocale()) : Locale.ENGLISH)\n                .neoProtectPlugin(instance)\n                .sender(event.getPlayer())\n                .msg(event.getMessage())\n                .executeChatEvent();\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/listener/DisconnectListener.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.listener;\n\nimport de.cubeattack.neoprotect.spigot.NeoProtectSpigot;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerQuitEvent;\n\npublic class DisconnectListener implements Listener {\n\n    private final NeoProtectSpigot instance;\n\n    public DisconnectListener(NeoProtectSpigot instance) {\n        this.instance = instance;\n    }\n\n    @EventHandler", "    public void onDisconnect(PlayerQuitEvent event) {\n        instance.getCore().getPlayerInSetup().remove(event.getPlayer());\n    }\n}\n"]}
{"filename": "src/main/java/de/cubeattack/neoprotect/spigot/listener/LoginListener.java", "chunked_list": ["package de.cubeattack.neoprotect.spigot.listener;\n\nimport de.cubeattack.api.language.Localization;\nimport de.cubeattack.api.util.JavaUtils;\nimport de.cubeattack.api.util.versioning.VersionUtils;\nimport de.cubeattack.neoprotect.core.Config;\nimport de.cubeattack.neoprotect.core.model.Stats;\nimport de.cubeattack.neoprotect.spigot.NeoProtectSpigot;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;", "import org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\n\nimport java.text.MessageFormat;\nimport java.util.Arrays;\nimport java.util.Locale;\n\npublic class LoginListener implements Listener {\n\n    private final NeoProtectSpigot instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectSpigot instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @EventHandler(priority = EventPriority.HIGHEST)", "import java.util.Locale;\n\npublic class LoginListener implements Listener {\n\n    private final NeoProtectSpigot instance;\n    private final Localization localization;\n\n    public LoginListener(NeoProtectSpigot instance) {\n        this.instance = instance;\n        this.localization = instance.getCore().getLocalization();\n    }\n\n    @EventHandler(priority = EventPriority.HIGHEST)", "    public void onLogin(PlayerJoinEvent event) {\n        Player player = event.getPlayer();\n        Locale locale = JavaUtils.javaVersionCheck() != 8 ? Locale.forLanguageTag(player.getLocale()) : Locale.ENGLISH;\n\n        if (!player.hasPermission(\"neoprotect.admin\") && !instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode()))\n            return;\n\n        VersionUtils.Result result = instance.getCore().getVersionResult();\n        if (result.getVersionStatus().equals(VersionUtils.VersionStatus.OUTDATED)) {\n            instance.sendMessage(player, localization.get(locale, \"plugin.outdated.message\", result.getCurrentVersion(), result.getLatestVersion()));\n            instance.sendMessage(player, MessageFormat.format(\"\u00a77-> \u00a7b{0}\",\n                            result.getReleaseUrl().replace(\"/NeoPlugin\", \"\").replace(\"/releases/tag\", \"\")),\n                    \"OPEN_URL\", result.getReleaseUrl(), null, null);\n        }\n", "        if (result.getVersionStatus().equals(VersionUtils.VersionStatus.OUTDATED)) {\n            instance.sendMessage(player, localization.get(locale, \"plugin.outdated.message\", result.getCurrentVersion(), result.getLatestVersion()));\n            instance.sendMessage(player, MessageFormat.format(\"\u00a77-> \u00a7b{0}\",\n                            result.getReleaseUrl().replace(\"/NeoPlugin\", \"\").replace(\"/releases/tag\", \"\")),\n                    \"OPEN_URL\", result.getReleaseUrl(), null, null);\n        }\n\n        if (result.getVersionStatus().equals(VersionUtils.VersionStatus.REQUIRED_RESTART)) {\n            instance.sendMessage(player, localization.get(locale, \"plugin.restart-required.message\", result.getCurrentVersion(), result.getLatestVersion()));\n        }\n", "        if (!instance.getCore().isSetup() && instance.getCore().getPlayerInSetup().isEmpty()) {\n            instance.sendMessage(player, localization.get(locale, \"setup.required.first\"));\n            instance.sendMessage(player, localization.get(locale, \"setup.required.second\"));\n        }\n\n        if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode())) {\n            Stats stats = instance.getStats();\n            String infos =\n                    \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                            \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                            \"\u00a7bPluginVersion\u00a77: \" + stats.getPluginVersion() + \" \\n\" +\n                            \"\u00a7bVersionStatus\u00a77: \" + instance.getCore().getVersionResult().getVersionStatus() + \" \\n\" +\n                            \"\u00a7bUpdateSetting\u00a77: \" + Config.getAutoUpdaterSettings() + \" \\n\" +\n                            \"\u00a7bProxyProtocol\u00a77: \" + Config.isProxyProtocol() + \" \\n\" +\n                            \"\u00a7bNeoProtectPlan\u00a77: \" + (instance.getCore().isSetup() ? instance.getCore().getRestAPI().getPlan() : \"\u00a7cNOT CONNECTED\") + \" \\n\" +\n                            \"\u00a7bSpigotName\u00a77: \" + stats.getServerName() + \" \\n\" +\n                            \"\u00a7bSpigotVersion\u00a77: \" + stats.getServerVersion() + \" \\n\" +\n                            \"\u00a7bSpigotPlugins\u00a77: \" + Arrays.toString(instance.getPlugins().stream().filter(p -> !p.startsWith(\"cmd_\") && !p.equals(\"reconnect_yaml\")).toArray());\n\n            instance.sendMessage(player, \"\u00a7bHello \" + player.getName() + \" ;)\", null, null, \"SHOW_TEXT\", infos);\n            instance.sendMessage(player, \"\u00a7bThis server uses your NeoPlugin\", null, null, \"SHOW_TEXT\", infos);\n        }\n    }\n}\n"]}
