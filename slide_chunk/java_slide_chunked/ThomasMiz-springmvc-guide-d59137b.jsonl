{"filename": "persistence/src/test/java/ar/edu/itba/paw/persistence/UserDaoJpaTest.java", "chunked_list": ["package ar.edu.itba.paw.persistence;\n\nimport ar.edu.itba.paw.models.User;\nimport ar.edu.itba.paw.persistence.config.TestConfig;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;", "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.jdbc.JdbcTestUtils;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.PersistenceContext;\nimport javax.sql.DataSource;", "import javax.persistence.PersistenceContext;\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = TestConfig.class)\n@Transactional\npublic class UserDaoJpaTest {\n\n    private static final long ID = 1;\n    private static final String EMAIL = \"pedro@mcpedro.com\";\n    private static final String PASSWORD = \"pedrito3333\";\n\n    @Autowired\n    private DataSource ds;\n\n    @Autowired\n    private UserDaoJpa userDao;\n\n    @PersistenceContext\n    private EntityManager em;\n\n    private JdbcTemplate jdbcTemplate;\n\n    @Before", "public class UserDaoJpaTest {\n\n    private static final long ID = 1;\n    private static final String EMAIL = \"pedro@mcpedro.com\";\n    private static final String PASSWORD = \"pedrito3333\";\n\n    @Autowired\n    private DataSource ds;\n\n    @Autowired\n    private UserDaoJpa userDao;\n\n    @PersistenceContext\n    private EntityManager em;\n\n    private JdbcTemplate jdbcTemplate;\n\n    @Before", "    public void setup() {\n        jdbcTemplate = new JdbcTemplate(ds);\n\n        // Todos los tests arrancan con la tabla de users vac\u00eda\n        JdbcTestUtils.deleteFromTables(jdbcTemplate, \"users\");\n    }\n\n    @Test\n    public void testFindById() throws SQLException {\n        // 1. Precondiciones\n        jdbcTemplate.execute(\"INSERT INTO users (user_id, email, password) VALUES (\" + ID + \", '\" + EMAIL + \"', '\" + PASSWORD + \"')\");\n\n        // 2. Ejercitar\n        Optional<User> maybeUser = userDao.findById(ID);\n\n        // 3. Postcondiciones\n        Assert.assertTrue(maybeUser.isPresent());\n        Assert.assertEquals(ID, maybeUser.get().getUserId());\n        Assert.assertEquals(EMAIL, maybeUser.get().getEmail());\n        Assert.assertEquals(PASSWORD, maybeUser.get().getPassword());\n    }\n\n    @Test", "    public void testFindById() throws SQLException {\n        // 1. Precondiciones\n        jdbcTemplate.execute(\"INSERT INTO users (user_id, email, password) VALUES (\" + ID + \", '\" + EMAIL + \"', '\" + PASSWORD + \"')\");\n\n        // 2. Ejercitar\n        Optional<User> maybeUser = userDao.findById(ID);\n\n        // 3. Postcondiciones\n        Assert.assertTrue(maybeUser.isPresent());\n        Assert.assertEquals(ID, maybeUser.get().getUserId());\n        Assert.assertEquals(EMAIL, maybeUser.get().getEmail());\n        Assert.assertEquals(PASSWORD, maybeUser.get().getPassword());\n    }\n\n    @Test", "    public void testFindByIdDoesNotExist() throws SQLException {\n        // 1. Precondiciones\n\n        // 2. Ejercitar\n        Optional<User> maybeUser = userDao.findById(ID);\n\n        // 3. Postcondiciones\n        Assert.assertFalse(maybeUser.isPresent());\n    }\n\n    @Test", "    public void testCreate() {\n        // 1. Precondiciones\n\n        // 2. Ejercitar\n        User user = userDao.create(EMAIL, PASSWORD);\n\n        // 3. Postcondiciones\n        Assert.assertNotNull(user);\n        Assert.assertEquals(EMAIL, user.getEmail());\n        Assert.assertEquals(PASSWORD, user.getPassword());\n        // El UserDaoJpa y JdbcTestUtils usan diferentes conexiones a la db, y como el test es @Transactional\n        // entonces no se pueden ver estas diferencias.\n        // Assert.assertEquals(1, JdbcTestUtils.countRowsInTable(jdbcTemplate, \"users\"));\n        Assert.assertNotNull(em.find(User.class, user.getUserId()));\n    }\n\n}\n"]}
{"filename": "persistence/src/test/java/ar/edu/itba/paw/persistence/config/TestConfig.java", "chunked_list": ["package ar.edu.itba.paw.persistence.config;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.Resource;\nimport org.springframework.jdbc.datasource.SimpleDriverDataSource;\nimport org.springframework.jdbc.datasource.init.DataSourceInitializer;\nimport org.springframework.jdbc.datasource.init.DatabasePopulator;", "import org.springframework.jdbc.datasource.init.DataSourceInitializer;\nimport org.springframework.jdbc.datasource.init.DatabasePopulator;\nimport org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.persistence.EntityManagerFactory;", "\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\nimport java.util.Properties;\n\n@ComponentScan(\"ar.edu.itba.paw.persistence\")\n@Configuration\n@EnableTransactionManagement\npublic class TestConfig {\n\n    @Value(\"classpath:hsqldb.sql\") // Le pedimos que nos traiga este archivo en resources\n    private Resource hsqldbSql; // (leer el comentario enorme en dataSource() para entender esto\n\n    @Value(\"classpath:schema.sql\")\n    private Resource schemaSql;\n\n    @Bean", "public class TestConfig {\n\n    @Value(\"classpath:hsqldb.sql\") // Le pedimos que nos traiga este archivo en resources\n    private Resource hsqldbSql; // (leer el comentario enorme en dataSource() para entender esto\n\n    @Value(\"classpath:schema.sql\")\n    private Resource schemaSql;\n\n    @Bean\n    public DataSource dataSource() {\n        final SimpleDriverDataSource ds = new SimpleDriverDataSource();\n\n        ds.setDriverClass(org.hsqldb.jdbcDriver.class);\n        ds.setUrl(\"jdbc:hsqldb:mem:pawtest\");\n        ds.setUsername(\"ha\");\n        ds.setPassword(\"\");\n\n        // Por default HSQLDB no tiene soporte para cosas que estamos usando, como por ejemplo el tipo de dato SERIAL\n        // en la columna \"id\" de la tabla \"users\". Peero HSQLDB nos permite interpretar estas cosas correctamente\n        // pidi\u00e9ndole que emule alguna base de datos en particular. Por suerte, esto incluye soporte para PostgreSQL.\n\n        // OBVIAMENTE ESTO NO SIMULA FULL POSTGRES, Cosas como triggers y funciones NO EST\u00c1N.\n        // Hay dos formas de usar esto:\n        // 1. Agregar a la clase test (ej. UserDaoJpaTest) un\n        //    @Sql(scripts = { \"classpath:hsqldb.sql\", \"classpath:schema.sql\" }) siendo estos archivos los que\n        //    agregamos en persistence/src/test/resources/hsqldb.sql y persistence/src/main/resources/schema.sql\n        // 2. Como queremos correr schema.sql tambi\u00e9n en runtime, usamos un DataSourceInitializer. Definimos un @Bean\n        //    siguiente a esta funci\u00f3n que inicializa una base de datos.\n\n        return ds;\n    }\n\n    @Bean", "    public DataSource dataSource() {\n        final SimpleDriverDataSource ds = new SimpleDriverDataSource();\n\n        ds.setDriverClass(org.hsqldb.jdbcDriver.class);\n        ds.setUrl(\"jdbc:hsqldb:mem:pawtest\");\n        ds.setUsername(\"ha\");\n        ds.setPassword(\"\");\n\n        // Por default HSQLDB no tiene soporte para cosas que estamos usando, como por ejemplo el tipo de dato SERIAL\n        // en la columna \"id\" de la tabla \"users\". Peero HSQLDB nos permite interpretar estas cosas correctamente\n        // pidi\u00e9ndole que emule alguna base de datos en particular. Por suerte, esto incluye soporte para PostgreSQL.\n\n        // OBVIAMENTE ESTO NO SIMULA FULL POSTGRES, Cosas como triggers y funciones NO EST\u00c1N.\n        // Hay dos formas de usar esto:\n        // 1. Agregar a la clase test (ej. UserDaoJpaTest) un\n        //    @Sql(scripts = { \"classpath:hsqldb.sql\", \"classpath:schema.sql\" }) siendo estos archivos los que\n        //    agregamos en persistence/src/test/resources/hsqldb.sql y persistence/src/main/resources/schema.sql\n        // 2. Como queremos correr schema.sql tambi\u00e9n en runtime, usamos un DataSourceInitializer. Definimos un @Bean\n        //    siguiente a esta funci\u00f3n que inicializa una base de datos.\n\n        return ds;\n    }\n\n    @Bean", "    public PlatformTransactionManager transactionManager(final EntityManagerFactory emf) {\n        return new JpaTransactionManager(emf);\n    }\n\n    @Bean\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n        final LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n\n        factoryBean.setPackagesToScan(\"ar.edu.itba.paw.models\");\n        factoryBean.setDataSource(dataSource());\n\n        final HibernateJpaVendorAdapter jpaAdapter = new HibernateJpaVendorAdapter();\n        factoryBean.setJpaVendorAdapter(jpaAdapter);\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.HSQLDialect\");\n        properties.setProperty(\"hibernate.hbm2ddl.auto\", \"update\");\n        factoryBean.setJpaProperties(properties);\n\n        return factoryBean;\n    }\n\n    @Bean", "    public DataSourceInitializer dataSourceInitializer(final DataSource ds) {\n        final DataSourceInitializer dsi = new DataSourceInitializer();\n        dsi.setDataSource(ds);\n        dsi.setDatabasePopulator(databasePopulator());\n\n        return dsi;\n    }\n\n    private DatabasePopulator databasePopulator() {\n        final ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScript(hsqldbSql);\n        populator.addScript(schemaSql);\n\n        return populator;\n    }\n}\n"]}
{"filename": "persistence/src/main/java/ar/edu/itba/paw/persistence/UserDaoJpa.java", "chunked_list": ["package ar.edu.itba.paw.persistence;\n\nimport ar.edu.itba.paw.interfaces.persistence.UserDao;\nimport ar.edu.itba.paw.models.User;\nimport org.springframework.stereotype.Repository;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.PersistenceContext;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;", "import javax.persistence.Query;\nimport javax.persistence.TypedQuery;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\n@Repository\npublic class UserDaoJpa implements UserDao {\n    @PersistenceContext\n    // @PersistenceContext es parecido al autowired, pero tiene informaci\u00f3n de contexto; da instancias distintas en\n    // threads distintos.\n    private EntityManager em;\n\n    @Override", "public class UserDaoJpa implements UserDao {\n    @PersistenceContext\n    // @PersistenceContext es parecido al autowired, pero tiene informaci\u00f3n de contexto; da instancias distintas en\n    // threads distintos.\n    private EntityManager em;\n\n    @Override\n    public User create(final String email, final String password) {\n        final User user = new User(email, password);\n        em.persist(user);\n        return user;\n    }\n\n    @Override\n    public Optional<User> findById(long userId) {\n        return Optional.ofNullable(em.find(User.class, userId));\n    }\n\n    @Override\n    public Optional<User> findByEmail(String email) {\n        // Si quiero usar un query SQL, puedo hacerlo con em.createNativeQuery, pero nosotros vamos a usar createQuery:\n        // createQuery no usa SQL sino JPA Query Language (JQL), tambi\u00e9n conocido como Hibernate Query Language (HQL).\n        // Estos lenguajes se parecen a SQL, pero en vez de hablar de tablas y columnas hablan de clases y atributos.\n        TypedQuery<User> query = em.createQuery(\"FROM User WHERE email = :email\", User.class);\n        query.setParameter(\"email\", email);\n\n        return query.getResultList().stream().findFirst();\n    }\n\n    @Override\n    public List<User> getAll(int pageNumber, int pageSize) {\n        // final TypedQuery<User> query = em.createQuery(\"FROM User\", User.class);\n        // query.setMaxResults(pageSize);\n        // query.setFirstResult((pageNumber - 1) * pageSize);\n        // return query.getResultList();\n        // HACER ESTO AS\u00cd ES PELIGROSO! El tema es que setMaxResults y setFirstResult hablan en t\u00e9rminos de ROWS, pero\n        // el query habla en t\u00e9rminos de entidades y el mapeno no necesariamente es 1 a 1.\n        // Si yo estoy trayendo mis users con listas de issues, puede ser que haga un OUTER JOIN para traer ambos en\n        // una sola query, en ese caso si usamos setMaxResults y setFirstResults pueden cortar el resultset en el medio\n        // de una lista!\n        // Pero si yo solo estoy haciendo \"SELECT * FROM users\", el mapeo filas-entidades seguro es 1 a 1 y esto no\n        // va a tener ning\u00fan problema.\n\n        // Para evitar este error, Hibernate hizo que cuando la query subyacente precisa hacer un JOIN, entonces en vez\n        // de usar LIMIT ? OFFSET ?, va a CARGAR LA QUERY ENTERA A MEMORIA y despu\u00e9s aplicar paginaci\u00f3n.\n        // SI HACES ESTO EST\u00c1 MAL. ES TERRIBLEMENTE INEFICIENTE.\n\n        // Y si pensas \"Ah, pero no pasa nada, mi 'FROM User' no hace joins, no tengo de qu\u00e9 preocuparme!\" entonces\n        // te expones al riesgo de que si en un futuro si empieza a hacer JOINs, sin warning ni nada caes en el\n        // problema de eficiencia. No podes confiar en que no hacen JOINs!\n\n        // Para paginar entonces vamos a usar el modelo de \"1+1 queries\". Hacemos dos queries; uno de paginaci\u00f3n y otro\n        // de traer los datos. La query de paginaci\u00f3n es nativeQuery, es SQL, entonces me aseguro 100% que no hay JOINs.\n        //\n        Query nativeQuery = em.createNativeQuery(\"SELECT user_id FROM users\");\n        nativeQuery.setMaxResults(pageSize);\n        nativeQuery.setFirstResult((pageNumber - 1) * pageSize);\n\n        final List<Long> idList = (List<Long>) nativeQuery.getResultList()\n                .stream().map(n -> (Long)((Number)n).longValue()).collect(Collectors.toList());\n\n        // Sino el siguiente query falla, no te deja hacer IN de una lista vac\u00eda.", "        if (idList.isEmpty())\n            return Collections.emptyList();\n\n        final TypedQuery<User> query = em.createQuery(\"FROM User WHERE userId IN :ids\", User.class);\n        query.setParameter(\"ids\", idList);\n\n        return query.getResultList();\n    }\n\n    @Override\n    public void changePassword(String email, String password) {\n        Optional<User> maybeUser = findByEmail(email);", "    public void changePassword(String email, String password) {\n        Optional<User> maybeUser = findByEmail(email);\n        if (maybeUser.isPresent()) {\n            final User user = maybeUser.get();\n            user.setPassword(password);\n            em.persist(user);\n        }\n    }\n\n    public void changePassword(User user, String password) {\n        // Si yo quiero hacer un changePassword que tome un User, no puedo simplemente hacer\n        // user.setPassword(password);\n        // Porque si no estoy dentro de un @Transactional, esto cambia el modelo en memoria pero no toca la db.\n        // Una alternativa es decirle al EntityManager que incorpore esta entidad al contexto de persistencia:\n        user = em.merge(user);\n        // OJO! merge() retorna una nueva instancia! Ahora si puedo hacer el setPassword:\n        user.setPassword(password);\n        // Si sus m\u00e9todos siempre usan @Transactional para este tipo de operaciones, nunca van a necesitar merge.\n    }\n}\n", "    public void changePassword(User user, String password) {\n        // Si yo quiero hacer un changePassword que tome un User, no puedo simplemente hacer\n        // user.setPassword(password);\n        // Porque si no estoy dentro de un @Transactional, esto cambia el modelo en memoria pero no toca la db.\n        // Una alternativa es decirle al EntityManager que incorpore esta entidad al contexto de persistencia:\n        user = em.merge(user);\n        // OJO! merge() retorna una nueva instancia! Ahora si puedo hacer el setPassword:\n        user.setPassword(password);\n        // Si sus m\u00e9todos siempre usan @Transactional para este tipo de operaciones, nunca van a necesitar merge.\n    }\n}\n"]}
{"filename": "interfaces/src/main/java/ar/edu/itba/paw/interfaces/persistence/UserDao.java", "chunked_list": ["package ar.edu.itba.paw.interfaces.persistence;\n\nimport ar.edu.itba.paw.models.User;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface UserDao {\n    User create(final String email, final String password);\n\n    Optional<User> findById(long userId);\n\n    Optional<User> findByEmail(String email);\n\n    List<User> getAll(int pageNumber, int pageSize);\n\n    void changePassword(String email, String password);\n}\n"]}
{"filename": "interfaces/src/main/java/ar/edu/itba/paw/interfaces/services/UserService.java", "chunked_list": ["package ar.edu.itba.paw.interfaces.services;\n\nimport ar.edu.itba.paw.models.User;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface UserService {\n    User create(final String email, final String password);\n\n    Optional<User> findById(long userId);\n\n    Optional<User> findByEmail(String email);\n\n    List<User> getAll(int pageNumber, int pageSize);\n\n    void changePassword(String email, String password);\n\n    void sendWelcomeEmail(String email);\n\n    void someScheduledOperation();\n}\n"]}
{"filename": "interfaces/src/main/java/ar/edu/itba/paw/interfaces/services/IssueService.java", "chunked_list": ["package ar.edu.itba.paw.interfaces.services;\n\nimport ar.edu.itba.paw.models.Issue;\nimport ar.edu.itba.paw.models.Priority;\n\npublic interface IssueService {\n    Issue reportIssue(String userEmail, String title, String description, Priority priority);\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/exceptions/UserNotFoundException.java", "chunked_list": ["package ar.edu.itba.paw.exceptions;\n\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException() {\n    }\n\n    public UserNotFoundException(String message) {\n        super(message);\n    }\n\n    public UserNotFoundException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public UserNotFoundException(Throwable cause) {\n        super(cause);\n    }\n\n    public UserNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n        super(message, cause, enableSuppression, writableStackTrace);\n    }\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/InsuranceCompany.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\npublic enum InsuranceCompany {\n    OSDE,\n    SWISS_MEDICAL,\n    MEDICUS\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/Patient.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\nimport javax.persistence.*;\n\n// @DiscriminatorValue(\"PATIENT\")\n@Entity\npublic class Patient extends User {\n    @Column(nullable = false)\n    @Enumerated(EnumType.STRING)\n    private InsuranceCompany insurance;\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/Issue.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\nimport javax.persistence.*;\n\n@Entity\n@Table(name = \"issues\")\npublic class Issue {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"issues_issue_id_seq\")\n    @SequenceGenerator(sequenceName = \"issues_issue_id_seq\", name = \"issues_issue_id_seq\", allocationSize = 1)\n    @Column(name = \"issue_id\")\n    private Long id;\n\n    @Column(nullable = false)\n    private String title;\n\n    @Column(nullable = false)\n    private String description;\n\n    // El \"reportedBy\" es una relaci\u00f3n de cardinalidad N:1. Esto se hace con un @ManyToOne\n    // OJO QUE ES DISTINTO QUE EL @OneToMany!!\n    // @ManyToOne(targetEntity = User.class) // Puedo especificar la clase target, pero en este caso no\n    // necesitamos. \u00datil cando tenes un set, o en vez de un User quiero una clase que extiende de User.\n    // Otras opciones son \"cascade\", las reglas de cascadeo y \"fetch\", un tema de c\u00f3mo implementa la query.\n    @ManyToOne(fetch = FetchType.EAGER, optional = false)\n    private User reportedBy;\n\n    @ManyToOne(fetch = FetchType.EAGER, optional = true)\n    private User assignedTo;\n\n    @Enumerated(EnumType.ORDINAL)\n    private Priority priority;\n\n    Issue() {\n\n    }\n\n    public Issue(String title, String description, User reportedBy, User assignedTo, Priority priority) {\n        this.id = null;\n        this.title = title;\n        this.description = description;\n        this.reportedBy = reportedBy;\n        this.assignedTo = assignedTo;\n        this.priority = priority;\n    }\n", "    public Long getId() {\n        return id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n", "    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n", "    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public User getReportedBy() {\n        return reportedBy;\n    }\n\n    public void setReportedBy(User reportedBy) {\n        this.reportedBy = reportedBy;\n    }\n", "    public void setReportedBy(User reportedBy) {\n        this.reportedBy = reportedBy;\n    }\n\n    public User getAssignedTo() {\n        return assignedTo;\n    }\n\n    public void setAssignedTo(User assignedTo) {\n        this.assignedTo = assignedTo;\n    }\n", "    public void setAssignedTo(User assignedTo) {\n        this.assignedTo = assignedTo;\n    }\n\n    public Priority getPriority() {\n        return priority;\n    }\n\n    public void setPriority(Priority priority) {\n        this.priority = priority;\n    }\n}\n", "    public void setPriority(Priority priority) {\n        this.priority = priority;\n    }\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/User.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\nimport javax.persistence.*;\nimport java.util.List;\n\n// Hay tres formas de mappear herencia del modelo objetos al modelo relacional. Mezclar todas las entidades\n// en una sola tabla (SINGLE_TABLE), con una tabla por entidad concreta (la tabla de Patient tendr\u00eda los\n// mismos campos que la tabla de user, m\u00e1s algunos otros) (TABLE_PER_CLASS), y pasar los campos de las\n// subclases a una tabla aparte por subclase (JOINED).\n// @Inheritance(strategy = InheritanceType.JOINED)", "// subclases a una tabla aparte por subclase (JOINED).\n// @Inheritance(strategy = InheritanceType.JOINED)\n\n// Si preferimos usar SINGLE_TABLE. Para que funcione esto, tenemos que agregar una \"discriminator column\",\n// que Hibernate usa para saber, para cada fila, que tipo de subclase es.\n// A cada subclase, le damos un @DiscriminatorValue especificando su valor para la columna discrimininador.\n// En vez de usar una columna con valores predefinidos, Hibernate nos deja usar una formula SQL para saber\n// como diferenciar: @DiscriminatorFormula(\"CASE WHEN insurance IS NULL THEN 'DOCTOR' ELSE 'PATIENT' END\")\n// @Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n// @DiscriminatorColumn(name = \"user_type\", discriminatorType = DiscriminatorType.STRING)", "// @Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n// @DiscriminatorColumn(name = \"user_type\", discriminatorType = DiscriminatorType.STRING)\n\n// Si usamos TABLE_PER_CLASS, no necesitamos los discriminadores, y las queries Hibernate las resuelve\n// haciendo JOINs de todas las tablas creadas. NOTAR QUE AS\u00cd NOS CREA LA TABLA inheritance_users!! No\n// hicimos User abstract entonces la crea. Si la hacemos abstract, la deja de crear.\n// @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n// @Entity\n// @Table(name = \"inheritance_users\")\n// public abstract class User {\n\n// Dato: Poner estas tres annotations es lo mismo que usar @MappedSuperclass (User puede ser o no abstract)\n// Nota: Los TypedQuery-s, ahora cuando hacemos em.createQuery(..., User.class) nos puede traer instancias de Doctor\n// y/o Patient.\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n@Entity\n@Table(name = \"users\")", "// @Table(name = \"inheritance_users\")\n// public abstract class User {\n\n// Dato: Poner estas tres annotations es lo mismo que usar @MappedSuperclass (User puede ser o no abstract)\n// Nota: Los TypedQuery-s, ahora cuando hacemos em.createQuery(..., User.class) nos puede traer instancias de Doctor\n// y/o Patient.\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n@Entity\n@Table(name = \"users\")\npublic class User {\n\n    @Id // Indico que este atributo es la primary key\n    // @GeneratedValue() // Indico que este valor es autogenerado y no debe insertarse\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"users_user_id_seq\")\n    @SequenceGenerator(sequenceName = \"users_user_id_seq\", name = \"users_user_id_seq\", allocationSize = 1)\n    @Column(name = \"user_id\")\n    private Long userId;\n    // Esto debe ser Long y no long, porque esto se usa en el dao para saber si el usuario existe o si se debe crear.\n\n    // NOTAR: Por default, para @GeneratedValue de entero, Hibernate crea UN \u00daNICO SEQUENCE PARA TODOS, por ende todos\n    // los objetos tienen ID \u00fanico. Esto tiene que ver por c\u00f3mo se mappea herencia, es la \u00fanica configuraci\u00f3n que\n    // asegura que funciona siempre, y por ende lo hicieron el default.\n    // Nosotros NO QUEREMOS ESTO, porque ya tenemos datos insertados en las tablas! Entonces no usamos @GeneratedValue\n    // solo, sino que le pasamos strategy y generator, y especificamos un @SequenceGenerator. No te olvides el\n    // allocationSize porque por default incrementa de a 50!\n    // Si queres saber c\u00f3mo se llama tu sequence ya creado en postgres, abr\u00ed el psql y escrib\u00ed \"\\ds\".\n\n    @Column(length = 100, nullable = false, unique = true)\n    // No necesitamos poner un name = \"email\" en el @Column porque la columna se llama igual que el campo.\n    private String email;\n\n    @Column(length = 60, nullable = false)\n    private String password;\n\n    // Igual que en Issue agregu\u00e9 los reportedBy y assignedTo, ac\u00e1 puedo (si quiero) agregar el otro lado\n    // de la relaci\u00f3n. Solo que en vez de @ManyToOne, ac\u00e1 va a ser un @OneToMany.\n    // En vez de opci\u00f3n de \"optional\" ac\u00e1 me da \"orphanRemoval\", que es \"qu\u00e9 queres que haga si elimino un\n    // elemento de la lista?\" Lo borro de la tabla? O lo dejo vivo?\n    // Otro par\u00e1metro importante es el mappedBy. Hibernate no tiene forma de saber que esto y lo que pusimos\n    // en Issue son dos lados de la misma relaci\u00f3n! Entonces lo especificamos con el mappedBy.\n    @OneToMany(mappedBy = \"reportedBy\", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Issue> reportedIssues;\n\n    @OneToMany(mappedBy = \"assignedTo\", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = false)\n    private List<Issue> assignedIssues;\n\n    // El FetchType es cu\u00e1ndo se trae los datos. Con EAGER trae las listas de issues cuando carga el usuario, pero con\n    // LAZY la trae cuando se hace el get. El problema es que este lazy solo va a funcionar si e get se hace dentro del\n    // @Transactional, entonces si vos en tu service traes un User sin los issues cargados, lo retornas, y en el\n    // controller intentas acceder a los reportedIssues, no va a poder traerlos!\n    // La soluci\u00f3n que te hace reprobar es cargarlos forzadamente, en el service o en el dao:\n    // Optional<User> user = findById\n    // user.ifPresent(u -> u.getReportedIssues().size()); // Fuerzo que se tenga que cargar la colecci\u00f3n\n    // return user;\n\n    // Para crear una instancia, Hibernate en vez de usar un constructor con los datos nos obliga a poner un\n    // constructor default, y luego usa reflection para settear los valores de los campos\n    User() {\n        // El constructor no necesita ser p\u00fablico, a Hibernate le ancanza con que sea package-private. De todos modos,\n        // esto nos impide ponerle el \"final\" a los campos.\n    }\n\n    public User(final String email, final String password) {\n        this.userId = null;\n        this.email = email;\n        this.password = password;\n    }\n\n    public User(final Long userId, final String email, final String password) {\n        this.userId = userId;\n        this.email = email;\n        this.password = password;\n    }\n", "public class User {\n\n    @Id // Indico que este atributo es la primary key\n    // @GeneratedValue() // Indico que este valor es autogenerado y no debe insertarse\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"users_user_id_seq\")\n    @SequenceGenerator(sequenceName = \"users_user_id_seq\", name = \"users_user_id_seq\", allocationSize = 1)\n    @Column(name = \"user_id\")\n    private Long userId;\n    // Esto debe ser Long y no long, porque esto se usa en el dao para saber si el usuario existe o si se debe crear.\n\n    // NOTAR: Por default, para @GeneratedValue de entero, Hibernate crea UN \u00daNICO SEQUENCE PARA TODOS, por ende todos\n    // los objetos tienen ID \u00fanico. Esto tiene que ver por c\u00f3mo se mappea herencia, es la \u00fanica configuraci\u00f3n que\n    // asegura que funciona siempre, y por ende lo hicieron el default.\n    // Nosotros NO QUEREMOS ESTO, porque ya tenemos datos insertados en las tablas! Entonces no usamos @GeneratedValue\n    // solo, sino que le pasamos strategy y generator, y especificamos un @SequenceGenerator. No te olvides el\n    // allocationSize porque por default incrementa de a 50!\n    // Si queres saber c\u00f3mo se llama tu sequence ya creado en postgres, abr\u00ed el psql y escrib\u00ed \"\\ds\".\n\n    @Column(length = 100, nullable = false, unique = true)\n    // No necesitamos poner un name = \"email\" en el @Column porque la columna se llama igual que el campo.\n    private String email;\n\n    @Column(length = 60, nullable = false)\n    private String password;\n\n    // Igual que en Issue agregu\u00e9 los reportedBy y assignedTo, ac\u00e1 puedo (si quiero) agregar el otro lado\n    // de la relaci\u00f3n. Solo que en vez de @ManyToOne, ac\u00e1 va a ser un @OneToMany.\n    // En vez de opci\u00f3n de \"optional\" ac\u00e1 me da \"orphanRemoval\", que es \"qu\u00e9 queres que haga si elimino un\n    // elemento de la lista?\" Lo borro de la tabla? O lo dejo vivo?\n    // Otro par\u00e1metro importante es el mappedBy. Hibernate no tiene forma de saber que esto y lo que pusimos\n    // en Issue son dos lados de la misma relaci\u00f3n! Entonces lo especificamos con el mappedBy.\n    @OneToMany(mappedBy = \"reportedBy\", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Issue> reportedIssues;\n\n    @OneToMany(mappedBy = \"assignedTo\", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = false)\n    private List<Issue> assignedIssues;\n\n    // El FetchType es cu\u00e1ndo se trae los datos. Con EAGER trae las listas de issues cuando carga el usuario, pero con\n    // LAZY la trae cuando se hace el get. El problema es que este lazy solo va a funcionar si e get se hace dentro del\n    // @Transactional, entonces si vos en tu service traes un User sin los issues cargados, lo retornas, y en el\n    // controller intentas acceder a los reportedIssues, no va a poder traerlos!\n    // La soluci\u00f3n que te hace reprobar es cargarlos forzadamente, en el service o en el dao:\n    // Optional<User> user = findById\n    // user.ifPresent(u -> u.getReportedIssues().size()); // Fuerzo que se tenga que cargar la colecci\u00f3n\n    // return user;\n\n    // Para crear una instancia, Hibernate en vez de usar un constructor con los datos nos obliga a poner un\n    // constructor default, y luego usa reflection para settear los valores de los campos\n    User() {\n        // El constructor no necesita ser p\u00fablico, a Hibernate le ancanza con que sea package-private. De todos modos,\n        // esto nos impide ponerle el \"final\" a los campos.\n    }\n\n    public User(final String email, final String password) {\n        this.userId = null;\n        this.email = email;\n        this.password = password;\n    }\n\n    public User(final Long userId, final String email, final String password) {\n        this.userId = userId;\n        this.email = email;\n        this.password = password;\n    }\n", "    public long getUserId() {\n        return userId;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n", "    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public List<Issue> getReportedIssues() {\n        return reportedIssues;\n    }\n\n    public List<Issue> getAssignedIssues() {\n        return assignedIssues;\n    }\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/Specialty.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\npublic enum Specialty {\n    GENERAL_DIAGNOSIS,\n    CARDIOLOGY,\n    TRAUMATOLOGY\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/Doctor.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\nimport javax.persistence.*;\n\n// @DiscriminatorValue(\"DOCTOR\")\n@Entity\npublic class Doctor extends User {\n    @Column(nullable = false)\n    @Enumerated(EnumType.STRING)\n    private Specialty specialty;\n}\n"]}
{"filename": "models/src/main/java/ar/edu/itba/paw/models/Priority.java", "chunked_list": ["package ar.edu.itba.paw.models;\n\npublic enum Priority {\n    LOW,\n    MEDIUM,\n    HIGH,\n    UNBREAK_NOW;\n}\n"]}
{"filename": "services/src/test/java/ar/edu/itba/paw/services/UserServiceImplTest.java", "chunked_list": ["package ar.edu.itba.paw.services;\n\nimport ar.edu.itba.paw.interfaces.persistence.UserDao;\nimport ar.edu.itba.paw.models.User;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.Spy;", "import org.mockito.Mock;\nimport org.mockito.Spy;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\nimport java.util.Optional;\n\nimport static org.mockito.Mockito.*;\n", "import static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class) // Le decimos a JUnit que corra los tests con el runner de Mockito\npublic class UserServiceImplTest {\n\n    private static final long ID = 1;\n    private static final String EMAIL = \"pedro@mcpedro.com\";\n    private static final String PASSWORD = \"pedrito3333\";\n\n    // private final UserServiceImpl us = new UserServiceImpl(null);\n    // Qu\u00e9 usamos como UserDao para el UserServiceImpl? No queremos conectarlo al Postgres de verdad, es una p\u00e9rdida de\n    // tiempo escribir un propio, por ejemplo, InMemoryTestUserDao que guarde los usuarios en un mapa en memoria...\n    // Para esto generamos un mock con Mockito, y le pedimos que nos cree el UserServiceImpl inyectando la clase\n    // mock-eada:\n    @Mock // Le pedimos que nos genere una clase mock de UserDao\n    private UserDao userDao;\n    @Spy\n    private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();\n    @InjectMocks // Le pedimos que cree un UserServiceImpl, y que en el ctor (que toma un UserDao) inyecte un mock.\n    private UserServiceImpl us;\n\n    @Test", "    public void testCreate() {\n        // 1. Precondiciones\n        // Defino el comportamiento de la clase mock de UserDao\n        when(userDao.create(anyString(), anyString())).thenReturn(new User(Long.valueOf(0), EMAIL, PASSWORD));\n\n        // 2. Ejercitar\n        // Pruebo la funcionalidad de usuarios\n        User newUser = us.create(EMAIL, PASSWORD);\n\n        // 3. Postcondiciones\n        Assert.assertNotNull(newUser);\n        Assert.assertEquals(newUser.getEmail(), EMAIL);\n        Assert.assertEquals(newUser.getPassword(), PASSWORD);\n\n        // Verifico que se haya llamado create del UserDao una vez\n        // NUNCA HAGAN ESTO, PORQUE ESTAS PROBANDO EL UserServiceImpl QUE TE IMPORTA C\u00d3MO EL USA EL UserDao\n        // Mockito.verify(userDao, times(1)).create(EMAIL, PASSWORD);\n    }\n\n    @Test(expected = RuntimeException.class) // \"Espero que este test lance y falle con una exception tal\"", "    public void testCreateAlreadyExists() {\n        // 1. Precondiciones\n        // Defino el comportamiento de la clase mock de UserDao\n        when(userDao.create(eq(EMAIL), eq(passwordEncoder.encode(PASSWORD)))).thenThrow(RuntimeException.class);\n\n        // 2. Ejercitar\n        User newUser = us.create(EMAIL, PASSWORD);\n\n        // 3. Postcondiciones\n        // (Nada, espero que lo anterior tire exception)\n    }\n\n    @Test", "    public void testFindById() {\n        // 1. Precondiciones\n        // Defino el comportamiento de la clase mock de UserDao\n        when(userDao.findById(eq(ID))).thenReturn(Optional.of(new User(ID, EMAIL, PASSWORD)));\n\n        // 2. Ejercitar\n        Optional<User> newUser = us.findById(ID);\n\n        // 3. Postcondiciones\n        Assert.assertTrue(newUser.isPresent());\n        Assert.assertEquals(ID, newUser.get().getUserId());\n    }\n}\n"]}
{"filename": "services/src/main/java/ar/edu/itba/paw/services/IssueServiceImpl.java", "chunked_list": ["package ar.edu.itba.paw.services;\n\nimport ar.edu.itba.paw.exceptions.UserNotFoundException;\nimport ar.edu.itba.paw.interfaces.services.IssueService;\nimport ar.edu.itba.paw.interfaces.services.UserService;\nimport ar.edu.itba.paw.models.Issue;\nimport ar.edu.itba.paw.models.Priority;\nimport ar.edu.itba.paw.models.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;", "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class IssueServiceImpl implements IssueService {\n\n    private final UserService userService;\n\n    @Autowired\n    public IssueServiceImpl(final UserService userService) {\n        this.userService = userService;\n    }\n\n    @Transactional\n    @Override", "    public Issue reportIssue(String userEmail, String title, String description, Priority priority) {\n        final User user = userService.findByEmail(userEmail).orElseThrow(UserNotFoundException::new);\n\n        // Pero c\u00f3mo se est\u00e1 insertando este issue?? Si yo ni siquiera tengo un IssueDao??\n        // Es porque en el UserDaoJpa pusimos un @PersistenceContext en el EntityManager! Esto guarda un estado que\n        // le permite a Hibernate hacer mucha magia como esta. Tambi\u00e9n le permite que si yo pido la misma entidad\n        // varias veces, en vez de hacer la misma query varias veces te retorna siempre la misma.\n        // Se acuerda \"Cu\u00e1les son las entidades con las que estoy trabajando ahora mismo?\". Pero qu\u00e9 es \"Ahora mismo?\"\n        // Es el contexto transaccional! Una vez que termina la transacci\u00f3n del @Transactional, Hibernate se fija si\n        // alguna de estas entidades fueron manipuladas. Si cambias, por ejemplo, el mail y/o password de un User,\n        // entonces actualiza la DB y se asegura que refleje este estado. Para que pase esto, en el @OneToMany del User\n        // tuvimos que poner el cascade = CascadeType.ALL, sino no funciona!\n        final Issue issue = new Issue(title, description, user, null, priority);\n        user.getReportedIssues().add(issue);\n\n        // Un tema con esto es que estamos violando nuestra divisi\u00f3n de capas; Estamos creando e insertando algo desde\n        // el service, sin pasar por persistence! Aparte hay un tema de performance; estamos haciendo un SELECT de un\n        // user para crear un issue, cuando en realidad podr\u00edamos hacer el insert de issue directamente.\n        // Para evitar ese select, podemos en findById() hacer un em.getReference(User.class, id), que retorna un User\n        // vac\u00edo, pero con la primary key. Otra alternativa es agregar m\u00e9todos al service como initReportedIssues()\n        // que los carga, pero esto queda feo, tenes que ser declarativo en \"qu\u00e9 cargo y qu\u00e9 no\".\n\n        // Otra alternativa, es que mi contexto de persistencia sea m\u00e1s grande. Podemos agregar al web.xml un <filter>\n        // para que abra la sesi\u00f3n al iniciar un request, y la cierre al terminar. Otra alternativa ser\u00eda usar usar un\n        // interceptor del dispatcher. Con la alternativa xml es m\u00e1s dificil excluir archivos est\u00e1ticos, pero la vamos\n        // a usar igual. Ahora cuando webapp est\u00e1 renderizando la vista, intenta acceder a los issues de un user y se\n        // hace el query en el momento!\n\n        // DESVENTAJA: Perdimos mucho control sobre qu\u00e9 query se ejecuta en qu\u00e9 momento! No est\u00e1 mal visto usar esto,\n        // pero algunos prefieren cargar las cosas explicitamente antes de retornar al controller.\n\n        return issue;\n    }\n}\n"]}
{"filename": "services/src/main/java/ar/edu/itba/paw/services/UserServiceImpl.java", "chunked_list": ["package ar.edu.itba.paw.services;\n\nimport ar.edu.itba.paw.interfaces.persistence.UserDao;\nimport ar.edu.itba.paw.interfaces.services.UserService;\nimport ar.edu.itba.paw.models.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;", "import org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\nimport java.util.Optional;\n\n// Podemos usar @Transaction para transformar un m\u00e9todo en transacci\u00f3n, o podemos ponerle @Transaction a la clase para\n// hacer que TODOS Los m\u00e9todos sean transaccionales.\n// NOTAR: Los \u00fanicos m\u00e9todos a los que se les puede aplicar @Transactional son M\u00c9TODOS DE INTERFAZ, ya que la forma en", "// hacer que TODOS Los m\u00e9todos sean transaccionales.\n// NOTAR: Los \u00fanicos m\u00e9todos a los que se les puede aplicar @Transactional son M\u00c9TODOS DE INTERFAZ, ya que la forma en\n// la que Spring hace esto es con una CLASE PROXY, que implementa UserService y internamente redirige las llamadas a\n// dichos m\u00e9todos a una instancia de UserServiceImpl. Esto le permite, al llamar cualquier m\u00e9todo de UserService,\n// ejecutar c\u00f3digo antes y/o despu\u00e9s. PERO entonces si nosotros, desde adentro de UserServiceImpl, llamamos a uno de\n// nuestros m\u00e9todos, esto no va a funcionar, pues no lo estamos llamando a traves de la clase proxy.\n// Ejemplo:\n// public void foo() { bar(); }\n// @Transactional public void bar() { ... }\n// Ambos m\u00e9todos hacen lo mismo, pero si yo desde afuera de UserServiceImpl llamo a UserService.foo() no va a ser\n// transaccional, pero si llamo a bar() si va a serlo.\n// Una posible soluci\u00f3n es poner @Transactional a toda la clase y listo, pero eso cuesta performance...\n\n// @Transactional // Esto hace que TODOS los m\u00e9todos de la clase sean transacciones. Ac\u00e1 prefiero hacerlo por-m\u00e9todo.\n@Service", "// @Transactional public void bar() { ... }\n// Ambos m\u00e9todos hacen lo mismo, pero si yo desde afuera de UserServiceImpl llamo a UserService.foo() no va a ser\n// transaccional, pero si llamo a bar() si va a serlo.\n// Una posible soluci\u00f3n es poner @Transactional a toda la clase y listo, pero eso cuesta performance...\n\n// @Transactional // Esto hace que TODOS los m\u00e9todos de la clase sean transacciones. Ac\u00e1 prefiero hacerlo por-m\u00e9todo.\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Transactional // Podes configurarle par\u00e1metros (readOnly, timeout, isolation, c\u00f3mo hace rollback, y m\u00e1s)\n    @Override", "    public User create(final String email, final String password) {\n        return userDao.create(email, passwordEncoder.encode(password));\n    }\n\n    @Override\n    public Optional<User> findById(long userId) {\n        return userDao.findById(userId);\n    }\n\n    @Override\n    public Optional<User> findByEmail(String email) {\n        return userDao.findByEmail(email);\n    }\n\n    @Override\n    public List<User> getAll(int pageNumber, int pageSize) {\n        return userDao.getAll(pageNumber, pageSize);\n    }\n\n    @Transactional\n    @Override", "    public void changePassword(String email, String password) {\n        userDao.changePassword(email, passwordEncoder.encode(password));\n    }\n\n    @Async\n    @Override\n    public void sendWelcomeEmail(String email) {\n        try {\n            // Simular alguna operaci\u00f3n larga que corre en background.\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    @Scheduled(initialDelay = 5000, fixedRate = 1000) // delays en milisegundos\n    @Override", "    public void someScheduledOperation() /*throws InterruptedException*/ {\n        // 5 segundos despu\u00e9s de que inicie el servidor, este m\u00e9todo se llama y se deja correr en background cada 1\n        // segundo.\n        // Por default, no se invoca el m\u00e9todo si el anterior sigue corriendo. Si queremos cambiar este comporamiento,\n        // le podemos agregar un throws InterruptedException al m\u00e9todo\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/auth/PawUserDetailsService.java", "chunked_list": ["package ar.edu.itba.paw.webapp.auth;\n\nimport ar.edu.itba.paw.interfaces.services.UserService;\nimport ar.edu.itba.paw.models.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;", "import org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\n// Para que el motor de dependencias de spring (por ej, el @Autowired) funcione en esta clase, necesitamos dos cosas:\n// 1. Que tenga el @Component o un @Algo donde Algo extiende a Component\n// Que est\u00e9 dentro de un paquete en el @ComponentScan de una clase de @Configuration", "// 1. Que tenga el @Component o un @Algo donde Algo extiende a Component\n// Que est\u00e9 dentro de un paquete en el @ComponentScan de una clase de @Configuration\n\n@Component\npublic class PawUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserService us;\n\n    @Override\n    public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {\n        final User user = us.findByEmail(username).orElseThrow(() -> new UsernameNotFoundException(\"No user for email \" + username));\n\n        // Creamos la lista de roles que tiene este usuario\n        final Collection<GrantedAuthority> authorities = new HashSet<>();\n        authorities.add(new SimpleGrantedAuthority(\"ROLE_EDITOR\"));\n        authorities.add(new SimpleGrantedAuthority(\"ROLE_USER_ADMIN\"));\n\n        // Creamos una implementaci\u00f3n de UserDetails con los datos de nuestro usuario.\n        return new PawAuthUserDetails(user.getEmail(), user.getPassword(), authorities);\n\n        // Mirar el otro constructor de PawAuthUser. Tiene una banda de par\u00e1metros para especificar si el usuario est\u00e1\n        // habilitado, expirado, o blockeado.\n    }\n}\n", "    public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {\n        final User user = us.findByEmail(username).orElseThrow(() -> new UsernameNotFoundException(\"No user for email \" + username));\n\n        // Creamos la lista de roles que tiene este usuario\n        final Collection<GrantedAuthority> authorities = new HashSet<>();\n        authorities.add(new SimpleGrantedAuthority(\"ROLE_EDITOR\"));\n        authorities.add(new SimpleGrantedAuthority(\"ROLE_USER_ADMIN\"));\n\n        // Creamos una implementaci\u00f3n de UserDetails con los datos de nuestro usuario.\n        return new PawAuthUserDetails(user.getEmail(), user.getPassword(), authorities);\n\n        // Mirar el otro constructor de PawAuthUser. Tiene una banda de par\u00e1metros para especificar si el usuario est\u00e1\n        // habilitado, expirado, o blockeado.\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/auth/PawAuthUserDetails.java", "chunked_list": ["package ar.edu.itba.paw.webapp.auth;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.User;\n\nimport java.util.Collection;\n\n// Esta clase nos permite guardar los datos de un models.User en un userdetails.User, una clase de spring security.\n// Una alternativa es hacer nuestra propia clase que implemente la interfaz userdetails.UserDetails.\npublic class PawAuthUserDetails extends User {\n    public PawAuthUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities) {\n        super(username, password, authorities);\n    }\n\n    public PawAuthUserDetails(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {\n        super(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);\n    }\n}\n", "// Una alternativa es hacer nuestra propia clase que implemente la interfaz userdetails.UserDetails.\npublic class PawAuthUserDetails extends User {\n    public PawAuthUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities) {\n        super(username, password, authorities);\n    }\n\n    public PawAuthUserDetails(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {\n        super(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/config/WebConfig.java", "chunked_list": ["package ar.edu.itba.paw.webapp.config;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.MessageSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.support.ReloadableResourceBundleMessageSource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.jdbc.datasource.SimpleDriverDataSource;", "import org.springframework.core.io.Resource;\nimport org.springframework.jdbc.datasource.SimpleDriverDataSource;\nimport org.springframework.jdbc.datasource.init.DataSourceInitializer;\nimport org.springframework.jdbc.datasource.init.DatabasePopulator;\nimport org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\nimport org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.annotation.EnableScheduling;", "import org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\nimport org.springframework.web.servlet.view.JstlView;", "import org.springframework.web.servlet.view.InternalResourceViewResolver;\nimport org.springframework.web.servlet.view.JstlView;\n\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Properties;\nimport java.util.concurrent.TimeUnit;\n\n// Con el @ComponentScan(), yo le puedo decir a d\u00f3nde tiene que ir a buscar componentes, como controllers y services.", "\n// Con el @ComponentScan(), yo le puedo decir a d\u00f3nde tiene que ir a buscar componentes, como controllers y services.\n\n@EnableScheduling\n@EnableAsync\n@EnableTransactionManagement\n@EnableWebMvc\n@ComponentScan({\"ar.edu.itba.paw.webapp.controller\", \"ar.edu.itba.paw.services\", \"ar.edu.itba.paw.persistence\"})\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Value(\"classpath:schema.sql\")\n    private Resource schemaSql;\n\n    // Con @Bean, yo b\u00e1sicamente le digo a sprint \"Che, si alguien te pide un ViewResolver, en vez de darle el default,\n    // dale este. Por default, genera una sola instancia y siempre se le da a todos esa misma instancia.\n    // Yo no se qu\u00e9 clase va a usar este ViewResolver, y dicha clase tampoco sabe de d\u00f3nde sali\u00f3 ese ViewResolver.\n    @Bean", "@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Value(\"classpath:schema.sql\")\n    private Resource schemaSql;\n\n    // Con @Bean, yo b\u00e1sicamente le digo a sprint \"Che, si alguien te pide un ViewResolver, en vez de darle el default,\n    // dale este. Por default, genera una sola instancia y siempre se le da a todos esa misma instancia.\n    // Yo no se qu\u00e9 clase va a usar este ViewResolver, y dicha clase tampoco sabe de d\u00f3nde sali\u00f3 ese ViewResolver.\n    @Bean\n    public ViewResolver viewResolver() {\n        final InternalResourceViewResolver vr = new InternalResourceViewResolver();\n        vr.setViewClass(JstlView.class);\n        vr.setPrefix(\"/WEB-INF/jsp/\");\n        vr.setSuffix(\".jsp\");\n        return vr;\n    }\n\n    // La otra forma es no definiendo un @Bean, sino agregando el nombre de paquete en el @ComponentScan y dejando que\n    // spring detecte solo las clases que tengan @Controller, @Service, @Repository, etc.\n\n\n    // Aca definimos un bean para la persistencia de datos. Este DataSource ser\u00e1 inyectado en runtime a la capa de\n    // persistencia.\n    @Bean", "    public ViewResolver viewResolver() {\n        final InternalResourceViewResolver vr = new InternalResourceViewResolver();\n        vr.setViewClass(JstlView.class);\n        vr.setPrefix(\"/WEB-INF/jsp/\");\n        vr.setSuffix(\".jsp\");\n        return vr;\n    }\n\n    // La otra forma es no definiendo un @Bean, sino agregando el nombre de paquete en el @ComponentScan y dejando que\n    // spring detecte solo las clases que tengan @Controller, @Service, @Repository, etc.\n\n\n    // Aca definimos un bean para la persistencia de datos. Este DataSource ser\u00e1 inyectado en runtime a la capa de\n    // persistencia.\n    @Bean", "    public DataSource dataSource() {\n        final SimpleDriverDataSource ds = new SimpleDriverDataSource();\n        ds.setDriverClass(org.postgresql.Driver.class);\n        ds.setUrl(\"jdbc:postgresql://localhost/pawtest\"); // We set the address and database to connect to\n        ds.setUsername(\"postgres\"); // We set the username and password for the database\n        ds.setPassword(\"postgres\");\n        // NOTE: It is recommended you keep these in a separate file such as resources/application.properties\n\n        return ds;\n    }\n\n    @Bean", "    public PlatformTransactionManager transactionManager(final EntityManagerFactory emf) {\n        // Este transaction manager no nos sirve m\u00e1s! Ahora que tenemos object-relational-mapping de Hibernate\n        // necesitamos un transaction manager que entienda JPA.\n        // return new DataSourceTransactionManager(ds);\n\n        return new JpaTransactionManager(emf);\n    }\n\n    @Bean\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n        final LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n\n        factoryBean.setPackagesToScan(\"ar.edu.itba.paw.models\");\n        factoryBean.setDataSource(dataSource());\n\n        final HibernateJpaVendorAdapter jpaAdapter = new HibernateJpaVendorAdapter();\n        factoryBean.setJpaVendorAdapter(jpaAdapter);\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.PostgreSQL92Dialect\");\n        // Con la setting hibernate.hbm2ddl.auto le decimos a hibernate c\u00f3mo asegurarse que las tablas de la base de\n        // datos sean iguales a los modelos que tiene. Si pongo \"create\", le digo que re-cree las tablas Y SE PIERDEN\n        // TODOS LOS DATOS. Si pongo \"update\", que hace lo mejor que pueda para ALTER-ar las tablas a los modelos.\n        // Si agregaste un CHECK (cosa > 0) probablemente lo ignore, pero si agregaste una columna nueva la agrega.\n        // Si no queres que haga nada, lo pones en \"none\".\n        properties.setProperty(\"hibernate.hbm2ddl.auto\", \"update\");\n        // NOTA: Si decidis usar esto, deberias sacar los @Bean de dataSourceInitializer y databasePopulator, ya que\n        // Hibernate se estar\u00e1 encargando de crear las tablas.\n\n        // Esto imprime a STDOUT las consultas SQL (SI LO PONES EN PRODUCCI\u00d3N REPROBAS):\n        // properties.setProperty(\"hibernate.show_sql\", \"true\");\n        // properties.setProperty(\"format_sql\", \"true\");\n\n        factoryBean.setJpaProperties(properties);\n\n        return factoryBean;\n    }\n\n    @Bean", "    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n        final LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n\n        factoryBean.setPackagesToScan(\"ar.edu.itba.paw.models\");\n        factoryBean.setDataSource(dataSource());\n\n        final HibernateJpaVendorAdapter jpaAdapter = new HibernateJpaVendorAdapter();\n        factoryBean.setJpaVendorAdapter(jpaAdapter);\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.PostgreSQL92Dialect\");\n        // Con la setting hibernate.hbm2ddl.auto le decimos a hibernate c\u00f3mo asegurarse que las tablas de la base de\n        // datos sean iguales a los modelos que tiene. Si pongo \"create\", le digo que re-cree las tablas Y SE PIERDEN\n        // TODOS LOS DATOS. Si pongo \"update\", que hace lo mejor que pueda para ALTER-ar las tablas a los modelos.\n        // Si agregaste un CHECK (cosa > 0) probablemente lo ignore, pero si agregaste una columna nueva la agrega.\n        // Si no queres que haga nada, lo pones en \"none\".\n        properties.setProperty(\"hibernate.hbm2ddl.auto\", \"update\");\n        // NOTA: Si decidis usar esto, deberias sacar los @Bean de dataSourceInitializer y databasePopulator, ya que\n        // Hibernate se estar\u00e1 encargando de crear las tablas.\n\n        // Esto imprime a STDOUT las consultas SQL (SI LO PONES EN PRODUCCI\u00d3N REPROBAS):\n        // properties.setProperty(\"hibernate.show_sql\", \"true\");\n        // properties.setProperty(\"format_sql\", \"true\");\n\n        factoryBean.setJpaProperties(properties);\n\n        return factoryBean;\n    }\n\n    @Bean", "    public DataSourceInitializer dataSourceInitializer(final DataSource ds) {\n        final DataSourceInitializer dsi = new DataSourceInitializer();\n        dsi.setDataSource(ds);\n        dsi.setDatabasePopulator(databasePopulator());\n\n        return dsi;\n    }\n\n    private DatabasePopulator databasePopulator() {\n        final ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScript(schemaSql);\n\n        return populator;\n    }\n\n    @Bean", "    public MessageSource messageSource() {\n        // Para internacionalizaci\u00f3n, usamos archivos .properties que guardan los strings a usar en diferentes idiomas.\n        // Esto es localizaci\u00f3n, por ende se divide no en idiomas pero en LOCALES, que son idioma y regi\u00f3n.\n\n        // Para saber que locale usar, Spring se fija para cada request el header HTTP \"Accept-Language\", que puede ser\n        // por ejemplo, \"Accept-Language: en_US, en, es\", que significa \"quiero que me des el sitio en ingl\u00e9s de EEUU,\n        // si no tenes eso ingl\u00e9s (sin importar regi\u00f3n), y si no ten\u00e9s eso dame espa\u00f1ol. Spring entonces va a, por cada\n        // string a traducir, buscar a ver si tiene el string en cada locale por ese orden.\n\n        // Tambi\u00e9n se tiene que definir un \"archivo base\", el \"messages.properties\" sin traducci\u00f3n que se usa si no se\n        // pide nada en particular. Como para nosotros este est\u00e1 en ingl\u00e9s, no tiene sentido poner otro separado en\n        // ingl\u00e9s \"messages_en.properties\". PERO podemos crear otros para en_US y en_UK para cambiar, por ejemplo,\n        // \"color\" a \"colour\".\n\n        final ReloadableResourceBundleMessageSource ms = new ReloadableResourceBundleMessageSource();\n\n        ms.setCacheSeconds((int) TimeUnit.MINUTES.toSeconds(5));\n        ms.setBasename(\"classpath:i18n/messages\");\n        ms.setDefaultEncoding(StandardCharsets.UTF_8.name());\n\n        return ms;\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/config/WebAuthConfig.java", "chunked_list": ["package ar.edu.itba.paw.webapp.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;", "import org.springframework.security.config.annotation.web.builders.WebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\nimport java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeUnit;\n\n@EnableWebSecurity\n@ComponentScan({\"ar.edu.itba.paw.webapp.auth\"})\n@Configuration\npublic class WebAuthConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    // Hasta ahora la contrase\u00f1a la guardamos en texto plano. Esto est\u00e1 recontra mal, y lo vamos a solucionar guardando\n    // la contrase\u00f1a hasheada con bcrypt. Esto lo vamos a hacer con la interfaz PasswordEncoder.\n    @Bean", "    public PasswordEncoder passwordEncoder() {\n        // Hay tres implementaciones default de PasswordEncoder. La primera es NoOpPasswordEncoder, que no hace nada,\n        // la segunda es StandardPasswordEncoder que permite utilizar algoritmos que trae spring-security por default.\n        // La tercera y la que vamos a usar es BCryptPasswordEncoder, la recomendada por Spring.\n        return new BCryptPasswordEncoder();\n        // Nota: Las contrase\u00f1as hasheadas con bcrypt siguen el patron \"\\\\A\\\\$2a?\\\\$\\\\d\\\\d\\\\$[./0-9A-Za-z]{53}\".\n        // Si queremos usar regex, podemos usar la clase java.util.regex.Pattern.\n        // Si nuestra db ya tiene contrase\u00f1as en texto plana y queremos migrar a bcrypt, podemos usar esta regex para\n        // fijarnos cuando alguien hace login si la contrase\u00f1a guardada no matchea ese patr\u00f3n, y si no lo hace la\n        // hasheamos y guardamos antes de proceguir.\n    }\n\n    // Tengo que configurar el UserDetailsService del auth para que sepa como usar nuestra base de datos. Le proveemos\n    // al auth un UserDetailsService. ES IMPORTANT\u00cdSIMO ESPECIFICARLO PORQUE SI NO AGARRA E INTENTA ACCEDER A LA DB DE\n    // FORMA DIRECTA ASUMIENDO UNA TABLA CON CIERTO ESQUEMA.\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        // Especificamos que la autenticaci\u00f3n se hace con el userDetailsService, y especificamos nuestro\n        // PasswordEncoder para que sepa que estamos hasheando las contrase\u00f1as con bcrypt.\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n    }\n\n    @Override", "    public void configure(final HttpSecurity http) throws Exception {\n        // Spring security pone un filtro a todos los requests y los pasa por las reglas que estamos por especificar.\n        // Armamos un \"filter chain\", de reglas que se verifican de forma ordenada, para ver si un request pasa o no.\n        // DEBEMOS CONFIGURAR UN FILTRO EN webapp/WEB-INF/web.xml PARA QUE ESTO FUNCIONE.\n\n        http.sessionManagement()\n                // No usamos m\u00e1s el .invalidSessionUrl(). No vamos a usar m\u00e1s endpoints de /login o /register, el login\n                // se puede hacer desde cualquier endpoint, y el register es un POST a /users. Es un API REST!\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n\n                // Ahora voy a especificar como se autorizan los requests. Notar que se validan en orden especificado:\n                .and().authorizeRequests()\n                // Especifico que \"/login\" y \"/register\" solo son v\u00e1lidas para usuarios an\u00f3nimos:\n                .antMatchers(\"/login\", \"/register\").anonymous()\n                // (Estos dos siguientes los dejo comentados como ejemplo)\n                // El endpoint \"/posts/review\" solo lo pueden acceder usuarios con el rol de EDITOR:\n                // .antMatchers(\"/posts/review\").hasRole(\"EDITOR\")\n                // El endpoint \"user/ban\" solo lo pueden acceder usuarios con el rol de USER_ADMIN:\n                // .antMatchers(\"/user/ban\").hasRole(\"USER_ADMIN\");\n                // Este tipo de filtros de \"o si o no\" no siempre es suficiente. A veces queremos que, por ejemplo,\n                // todos los EDITORs puedan entrar a /posts/review, pero tambi\u00e9n el usuario que cre\u00f3 el post. Para esto\n                // existe un Expression Language en spring security que te permite definir cosas m\u00e1s precisas:\n                // .antMatchers(\"/posts/review\").access(\"@AccessHelper.canEdit\") // No los vamos a ver en clase igual\n\n                // Todos los demas accesos a cualquier cosa en \"/**\" piden solo autentiaci\u00f3n (ESTO SIEMPRE AL FINAL!)\n                .antMatchers(\"/**\").permitAll() // POR SIMPLICIDAD POR AHORA LO DEJAMOS EN PERMITR ALL\n\n\n\n                // Ahora vamos a configurar el manejo de exceptions:\n                .and().exceptionHandling()\n                // En el caso de una excepci\u00f3n, redirig\u00ed a la p\u00e1gina de access denied, que es \"/errors/403\":\n                .accessDeniedPage(\"/errors/403\")\n                // IMPORTANTE: Configuramos en el WebSecurity abajo que todos puedan acceder a 403 sin problemas.\n\n                // Deshabilitar las reglas de cross-site-request-forgery. No explicaron por qu\u00e9 lo necesitamos:\n                .and().csrf().disable();\n\n        // Notemos igual que spring security no sabe c\u00f3mo guardamos estos datos para persistencia. Para esto, vamos a\n        // tener que inyectarle algo de l\u00f3gica para que sepa c\u00f3mo usar nuestra base de datos. Para esto, tenemos que\n        // implementar la interfaz org.springframework.security.core.userdetails.UserDetailsService.\n        // Ver: ar.edu.itba.paw.webapp.auth.PawUserDetailsService.java\n    }\n\n    @Override", "    public void configure(final WebSecurity web) throws Exception {\n        // Le digo al WebSecurity que ignore estos directorios. De esta forma si viene un request\n        // a uno de estos paths, no va a validar accesos. Cualquiera puede acceder a estos recursos.\n        web.ignoring().antMatchers(\"/css/**\", \"/js/**\", \"/img/**\", \"favicon.ico\", \"/errors/**\");\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/exceptions/UserNotFoundException.java", "chunked_list": ["package ar.edu.itba.paw.webapp.exceptions;\n\npublic class UserNotFoundException extends RuntimeException {\n    private static final long serialVersionUID = -4439804381464928244L;\n\n    public UserNotFoundException() {\n        super();\n    }\n\n    public UserNotFoundException(String message) {\n        super(message);\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/controller/UserController.java", "chunked_list": ["package ar.edu.itba.paw.webapp.controller;\n\nimport ar.edu.itba.paw.interfaces.services.UserService;\nimport ar.edu.itba.paw.models.User;\nimport ar.edu.itba.paw.webapp.dto.UserDto;\nimport ar.edu.itba.paw.webapp.exceptions.UserNotFoundException;\nimport ar.edu.itba.paw.webapp.form.UserForm;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n", "import org.springframework.stereotype.Component;\n\nimport javax.validation.Valid;\nimport javax.ws.rs.*;\nimport javax.ws.rs.core.*;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\n// Vamos a hacer un controller para endpoints del API que tengan que ver con usuarios.", "\n// Vamos a hacer un controller para endpoints del API que tengan que ver con usuarios.\n\n@Path(\"users\") // Maneja endpoints con paths /users/**\n@Component // No usamos @Controller! Usamos @Component.\npublic class UserController {\n\n    private final UserService us;\n\n    // Este objeto nos va a dejar construir URIs. Lo anotamos con con @Autowired, pero con @Context. Nos lo va a\n    // inyectar no Spring, pero Jersey, y contiene informaci\u00f3n espec\u00edfica del request actual que se est\u00e1 procesando.\n    @Context\n    private UriInfo uriInfo;\n\n    @Autowired\n    public UserController(final UserService us) {\n        this.us = us;\n    }\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)", "    public Response listUsers(@QueryParam(\"page\") @DefaultValue(\"1\") final int page) {\n        if (page < 1)\n            return Response.status(Response.Status.BAD_REQUEST).build();\n\n        final List<User> userList = us.getAll(page, 20);\n\n        // Si la lista est\u00e1 vac\u00eda, retornamos un HTTP 204 No Content\n        if (userList.isEmpty())\n            return Response.noContent().build();\n\n        // Sino, HTTP 200 OK con la lista de usuarios, y agregamos headers de paginaci\u00f3n\n        /*return Response.ok(new GenericEntity<List<User>>(userList) {})\n                .link(\"ya vamos\", \"next\")\n                .link(\"a rellenar\", \"prev\")\n                .link(\"estos campos\", \"first\")\n                .link(\"con uris\", \"last\")\n                .build();*/\n\n        // Tenemos que wrappear el userList en una subclase an\u00f3nima de GenericEntity para que lo pueda reconocer bien\n        // y nos arme un json array. El tema es que por default esto solo trae los campos de User que tienen getter y\n        // setter, o sea que el \u00fanico campo que trae es la contrase\u00f1a. Tenemos que cambiar esto!\n        // Una buena pr\u00e1ctica es separar la entidad de dominio (User) con la representaci\u00f3n que la API expone. Entonces\n        // creamos un paquete nuevo en webapp, llamado dto, o \"Data Transfer Object\". Creamos una clase UserDto con la\n        // representaci\u00f3n de c\u00f3mo se ve un usuario en la API, le agregamos m\u00e9todos static para crearlos desde User/s,\n        // y entonces en vez de usar User para la lista de respueta, usamos UserDto:\n\n        List<UserDto> userDtoList = UserDto.fromUserList(uriInfo, userList);\n        return Response.ok(new GenericEntity<List<UserDto>>(userDtoList) {})\n                .link(uriInfo.getRequestUriBuilder().replaceQueryParam(\"page\", page + 1).build(), \"next\")\n                .link(uriInfo.getRequestUriBuilder().replaceQueryParam(\"page\", page - 1).build(), \"prev\")\n                // TODO: Agregar verificaci\u00f3n en los next y prev, si no existe no incluirlo!\n                // Tip: Mover la adici\u00f3n de estos headers a una helper function\n                // No tenemos como implementar el first y last, habr\u00eda que buscar el total count de usuarios, pero\n                // es buena pr\u00e1ctica incluirlos.\n                //.link(uriInfo.getRequestUriBuilder().replaceQueryParam(\"page\", page + 1).build(), \"first\")\n                //.link(uriInfo.getRequestUriBuilder().replaceQueryParam(\"page\", page + 1).build(), \"last\")\n                .build();\n    }\n\n    // Con @Produces podemos especificar el tipo de retorno del endpoint, y con @Consumes podemos especificar qu\u00e9 pide.\n    // Si nuestro api tiene varias versiones, est\u00e1 MAL hacer api.mysite.com/v1/users y api.mysite.com/v2/users! La\n    // forma en la que distinguis versiones es en el endpoint un @Consumes(\"application/vnd.createuserform.v1+json\").\n    // @Produces define el header Content-Type en la respuesta.\n\n    @GET\n    @Path(\"/{id}\")", "    public Response getUser(@PathParam(\"id\") final long id) {\n        final User user = us.findById(id).orElseThrow(UserNotFoundException::new);\n\n        // OJO: Ac\u00e1 tambi\u00e9n usamos el UserDto y no el User en la respuesta!!\n        return Response.ok(UserDto.fromUser(uriInfo, user)).build();\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createUser(@Valid final UserForm userForm) {\n        // NOTA: No tengo que hacer la verificaci\u00f3n de errores del form! Con el @Valid, si el form no es v\u00e1lido, el\n        // error se maneja desde otro lado.\n\n        final User user = us.create(userForm.getEmail(), userForm.getPassword());\n        return Response.created(uriInfo.getBaseUriBuilder().path(\"/users\").path(String.valueOf(user.getUserId())).build()).build();\n    }\n}\n", "    public Response createUser(@Valid final UserForm userForm) {\n        // NOTA: No tengo que hacer la verificaci\u00f3n de errores del form! Con el @Valid, si el form no es v\u00e1lido, el\n        // error se maneja desde otro lado.\n\n        final User user = us.create(userForm.getEmail(), userForm.getPassword());\n        return Response.created(uriInfo.getBaseUriBuilder().path(\"/users\").path(String.valueOf(user.getUserId())).build()).build();\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/form/UserForm.java", "chunked_list": ["package ar.edu.itba.paw.webapp.form;\n\nimport org.hibernate.validator.constraints.Email;\nimport org.hibernate.validator.constraints.NotBlank;\n\nimport javax.validation.constraints.Size;\n\n// Usando los paquetes javax.validation.validation-api y org.hibernate.hibernate-validator que agregamos a los POM,\n// podemos hacer uso de POJOs para validaci\u00f3n de datos en un formulario. Esto nos permite simplificar enormemente\n// el c\u00f3digo de un formulario, cosa que aplicamos al HelloWorldController.register() a trav\u00e9s de esta clase.", "// podemos hacer uso de POJOs para validaci\u00f3n de datos en un formulario. Esto nos permite simplificar enormemente\n// el c\u00f3digo de un formulario, cosa que aplicamos al HelloWorldController.register() a trav\u00e9s de esta clase.\n// Para que se use el formulario, en vez de pasar los par\u00e1metros del form como par\u00e1metros del m\u00e9todo register(),\n// cambiamos para que sea register(@Validate final UserForm userForm, final BindingResult errors).\n\n// Para cada par\u00e1metro del form hacemos un campo privado en la clase. Cada uno de los campos del form se mappea por\n// nombre con cada uno de los campos de esta clase.\n\n// Podemos agregar annotations para sumar validaciones. No te olvides de crear getters y setters para todos estos!\n", "// Podemos agregar annotations para sumar validaciones. No te olvides de crear getters y setters para todos estos!\n\n// Para ver ejemplos de todos los constraints que se pueden poner, mirar javax.validation.constraints. Esto incluye\n// @Min, @Max, @NotNull, @Size, @Pattern, y m\u00e1s. Adem\u00e1s de los que se definen ah\u00ed (los de javax.validation son solo las\n// definiciones, hibernate tiene las implementaciones) podemos ver los que suma hibernate suma otros validadores\n// como @Email, @Length, @NotBlank, @NotEmpty, @URL, @SafeHtml, @Range, @CreditCardNumber...\n\npublic class UserForm {\n\n    @NotBlank\n    @Size(min = 6, max = 128) // Especifico rango del length del string\n    // @Pattern(regexp = \"^[a-zA-Z0-9]+$\") // Debe validar con tal regex, lo dejo como ejemplo pero mejor usar email\n    @Email\n    private String email;\n\n    // Si fueras a querer un mensaje propio en una anotaci\u00f3n, podes usar el par\u00e1metro message que toman. Por ejemplo:\n    // @Email(message = \"{badEmail}\"). Esto es particularmente util si tenes varias del mismo tipo en un solo campo.\n\n    @NotBlank\n    @Size(min = 8)\n    private String password;\n\n    @NotBlank\n    @Size(min = 8)\n    private String repeatPassword;\n\n    // NOTA: Si tu form incluye fechas, podes usar tipos de java.util o java.time, por ejemplo LocalDate, LocalTime,\n    // LocalDateTime, Year, YearMonth, etc. y validarlos con, por ejemplo @Past y @Future.\n", "    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n", "    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getRepeatPassword() {\n        return repeatPassword;\n    }\n", "    public String getRepeatPassword() {\n        return repeatPassword;\n    }\n\n    public void setRepeatPassword(String repeatPassword) {\n        this.repeatPassword = repeatPassword;\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/mapper/UserNotFoundExceptionMapper.java", "chunked_list": ["package ar.edu.itba.paw.webapp.mapper;\n\nimport ar.edu.itba.paw.webapp.exceptions.UserNotFoundException;\n\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.ext.ExceptionMapper;\nimport javax.ws.rs.ext.Provider;\n\n@Provider\npublic class UserNotFoundExceptionMapper implements ExceptionMapper<UserNotFoundException> {\n    @Override", "@Provider\npublic class UserNotFoundExceptionMapper implements ExceptionMapper<UserNotFoundException> {\n    @Override\n    public Response toResponse(UserNotFoundException exception) {\n        return Response.status(Response.Status.NOT_FOUND).build();\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/mapper/ValidationExceptionMapper.java", "chunked_list": ["package ar.edu.itba.paw.webapp.mapper;\n\nimport ar.edu.itba.paw.webapp.dto.ValidationErrorDto;\n\nimport javax.validation.ConstraintViolationException;\nimport javax.ws.rs.core.GenericEntity;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.ext.ExceptionMapper;\nimport javax.ws.rs.ext.Provider;\nimport java.util.List;", "import javax.ws.rs.ext.Provider;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Provider\npublic class ValidationExceptionMapper implements ExceptionMapper<ConstraintViolationException> {\n\n    @Override\n    public Response toResponse(ConstraintViolationException exception) {\n        List<ValidationErrorDto> validationErrors = exception.getConstraintViolations().stream().map(ValidationErrorDto::fromConstraintViolation).collect(Collectors.toList());\n\n        return Response.status(Response.Status.BAD_REQUEST).entity(new GenericEntity<List<ValidationErrorDto>>(validationErrors) {}).build();\n    }\n}", "    public Response toResponse(ConstraintViolationException exception) {\n        List<ValidationErrorDto> validationErrors = exception.getConstraintViolations().stream().map(ValidationErrorDto::fromConstraintViolation).collect(Collectors.toList());\n\n        return Response.status(Response.Status.BAD_REQUEST).entity(new GenericEntity<List<ValidationErrorDto>>(validationErrors) {}).build();\n    }\n}"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/dto/ValidationErrorDto.java", "chunked_list": ["package ar.edu.itba.paw.webapp.dto;\n\nimport javax.validation.ConstraintViolation;\n\npublic class ValidationErrorDto {\n\n    private String message;\n    private String path;\n    public static ValidationErrorDto fromConstraintViolation(ConstraintViolation<?> violation) {\n        ValidationErrorDto dto = new ValidationErrorDto();\n        dto.message = violation.getMessage();\n        dto.path = violation.getPropertyPath().toString();\n\n        return dto;\n    }\n", "    public static ValidationErrorDto fromConstraintViolation(ConstraintViolation<?> violation) {\n        ValidationErrorDto dto = new ValidationErrorDto();\n        dto.message = violation.getMessage();\n        dto.path = violation.getPropertyPath().toString();\n\n        return dto;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n", "    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    public String getPath() {\n        return path;\n    }\n", "    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n}\n"]}
{"filename": "webapp/src/main/java/ar/edu/itba/paw/webapp/dto/UserDto.java", "chunked_list": ["package ar.edu.itba.paw.webapp.dto;\n\nimport ar.edu.itba.paw.models.User;\n\nimport javax.ws.rs.core.UriInfo;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class UserDto {\n    private String email;\n    private URI self;\n    private URI assignedIssues;\n    private URI createdIssues;\n", "\npublic class UserDto {\n    private String email;\n    private URI self;\n    private URI assignedIssues;\n    private URI createdIssues;\n\n    public static UserDto fromUser(final UriInfo uri, final User user) {\n        final UserDto dto = new UserDto();\n        dto.email = user.getEmail();\n        dto.self = uri.getBaseUriBuilder().path(\"/users\").path(String.valueOf(user.getUserId())).build();\n        dto.assignedIssues = uri.getBaseUriBuilder().path(\"/issues\").queryParam(\"assignedTo\", user.getUserId()).build();\n        dto.createdIssues = uri.getBaseUriBuilder().path(\"/issues\").queryParam(\"createdBy\", user.getUserId()).build();\n\n        return dto;\n    }\n", "    public static List<UserDto> fromUserList(final UriInfo uri, final List<User> userList) {\n        return userList.stream().map(u -> fromUser(uri, u)).collect(Collectors.toList());\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n", "    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public URI getSelf() {\n        return self;\n    }\n\n    public void setSelf(URI self) {\n        this.self = self;\n    }\n", "    public void setSelf(URI self) {\n        this.self = self;\n    }\n\n    public URI getAssignedIssues() {\n        return assignedIssues;\n    }\n\n    public void setAssignedIssues(URI assignedIssues) {\n        this.assignedIssues = assignedIssues;\n    }\n", "    public void setAssignedIssues(URI assignedIssues) {\n        this.assignedIssues = assignedIssues;\n    }\n\n    public URI getCreatedIssues() {\n        return createdIssues;\n    }\n\n    public void setCreatedIssues(URI createdIssues) {\n        this.createdIssues = createdIssues;\n    }\n}\n", "    public void setCreatedIssues(URI createdIssues) {\n        this.createdIssues = createdIssues;\n    }\n}\n"]}
