{"filename": "src/main/java/com/tcoded/folialib/FoliaLib.java", "chunked_list": ["package com.tcoded.folialib;\n\nimport com.tcoded.folialib.enums.ImplementationType;\nimport com.tcoded.folialib.impl.*;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class FoliaLib {\n\n    private final JavaPlugin plugin;\n\n    private final ImplementationType implementationType;\n    private final ServerImplementation implementation;\n\n    public FoliaLib(JavaPlugin plugin) {\n        this.plugin = plugin;\n\n        // Find the implementation type based on the class names\n        ImplementationType foundType = ImplementationType.UNKNOWN;\n        typeLoop:", "        for (ImplementationType type : ImplementationType.values()) {\n            String[] classNames = type.getClassNames();\n\n            // Check if any of the class names are present\n            for (String className : classNames) {\n                try {\n                    // Try to load the class\n                    Class.forName(className);\n\n                    // Found the server type, remember that and break the loop\n                    foundType = type;\n                    break typeLoop;\n                } catch (ClassNotFoundException ignored) {}\n            }\n        }\n\n        // Apply the implementation based on the type\n        this.implementationType = foundType;\n        switch (foundType) {\n            case FOLIA -> this.implementation = new FoliaImplementation(this);\n            case PAPER -> this.implementation = new PaperImplementation(this);\n            case SPIGOT -> this.implementation = new SpigotImplementation(this);\n            default -> this.implementation = new UnsupportedImplementation(this);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")", "    public ImplementationType getImplType() {\n        return implementationType;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public ServerImplementation getImpl() {\n        return implementation;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public boolean isFolia() {\n        return implementationType == ImplementationType.FOLIA;\n    }\n\n    @SuppressWarnings(\"unused\")", "    public boolean isFolia() {\n        return implementationType == ImplementationType.FOLIA;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public boolean isPaper() {\n        return implementationType == ImplementationType.PAPER;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public boolean isSpigot() {\n        return implementationType == ImplementationType.SPIGOT;\n    }\n\n    @SuppressWarnings(\"unused\")", "    public boolean isSpigot() {\n        return implementationType == ImplementationType.SPIGOT;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public boolean isUnsupported() {\n        return implementationType == ImplementationType.UNKNOWN;\n    }\n\n    public JavaPlugin getPlugin() {\n        return plugin;\n    }\n}", "    public JavaPlugin getPlugin() {\n        return plugin;\n    }\n}"]}
{"filename": "src/main/java/com/tcoded/folialib/util/TimeConverter.java", "chunked_list": ["package com.tcoded.folialib.util;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class TimeConverter {\n\n    public static long toTicks(long time, TimeUnit unit) {\n        return unit.toMillis(time) / 50;\n    }\n\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/wrapper/WrappedTask.java", "chunked_list": ["package com.tcoded.folialib.wrapper;\n\nimport org.bukkit.plugin.Plugin;\n\n@SuppressWarnings(\"unused\")\npublic interface WrappedTask {\n\n    void cancel();\n\n    boolean isCancelled();\n\n    Plugin getOwningPlugin();\n\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/wrapper/task/WrappedBukkitTask.java", "chunked_list": ["package com.tcoded.folialib.wrapper.task;\n\nimport com.tcoded.folialib.wrapper.WrappedTask;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.scheduler.BukkitTask;\n\npublic class WrappedBukkitTask implements WrappedTask {\n\n    private final BukkitTask task;\n\n    public WrappedBukkitTask(BukkitTask task) {\n        this.task = task;\n    }\n\n    @Override", "    public void cancel() {\n        this.task.cancel();\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return this.task.isCancelled();\n    }\n\n    @Override\n    public Plugin getOwningPlugin() {\n        return this.task.getOwner();\n    }\n}\n", "    public Plugin getOwningPlugin() {\n        return this.task.getOwner();\n    }\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/wrapper/task/WrappedFoliaTask.java", "chunked_list": ["package com.tcoded.folialib.wrapper.task;\n\nimport com.tcoded.folialib.wrapper.WrappedTask;\nimport io.papermc.paper.threadedregions.scheduler.ScheduledTask;\nimport org.bukkit.plugin.Plugin;\n\npublic class WrappedFoliaTask implements WrappedTask {\n\n    private final ScheduledTask task;\n\n    public WrappedFoliaTask(ScheduledTask task) {\n        this.task = task;\n    }\n\n    @Override", "    public void cancel() {\n        this.task.cancel();\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return this.task.isCancelled();\n    }\n\n    @Override\n    public Plugin getOwningPlugin() {\n        return this.task.getOwningPlugin();\n    }\n}\n", "    public Plugin getOwningPlugin() {\n        return this.task.getOwningPlugin();\n    }\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/enums/EntityTaskResult.java", "chunked_list": ["package com.tcoded.folialib.enums;\n\npublic enum EntityTaskResult {\n\n    SUCCESS,\n    ENTITY_RETIRED,\n    SCHEDULER_RETIRED\n\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/enums/ImplementationType.java", "chunked_list": ["package com.tcoded.folialib.enums;\n\npublic enum ImplementationType {\n\n    // Ordered by priority\n    @SuppressWarnings(\"SpellCheckingInspection\")\n    FOLIA (\"io.papermc.paper.threadedregions.RegionizedServer\"),\n    @SuppressWarnings(\"SpellCheckingInspection\")\n    PAPER (\"com.destroystokyo.paper.PaperConfig\", \"io.papermc.paper.configuration.Configuration\"),\n    @SuppressWarnings(\"SpellCheckingInspection\")\n    SPIGOT (\"org.spigotmc.SpigotConfig\"),\n    UNKNOWN;\n\n    private final String[] classNames;\n\n    ImplementationType(String... classNames) {\n        this.classNames = classNames;\n    }\n\n    public String[] getClassNames() {\n        return classNames;\n    }\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/impl/UnsupportedImplementation.java", "chunked_list": ["package com.tcoded.folialib.impl;\n\nimport com.tcoded.folialib.FoliaLib;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.logging.Logger;\n\npublic class UnsupportedImplementation extends SpigotImplementation {\n\n    public UnsupportedImplementation(FoliaLib foliaLib) {\n        super(foliaLib);\n\n        JavaPlugin plugin = foliaLib.getPlugin();\n        Logger logger = plugin.getLogger();\n\n        logger.warning(\n                String.format(\"\"\"\n                                            \n                                ---------------------------------------------------------------------\n                                FoliaLib does not support this server software! (%s)\n                                FoliaLib will attempt to use the default spigot implementation.\n                                ---------------------------------------------------------------------\n                                \"\"\",\n                        plugin.getServer().getVersion()\n                )\n        );\n    }\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/impl/ServerImplementation.java", "chunked_list": ["package com.tcoded.folialib.impl;\n\nimport com.tcoded.folialib.enums.EntityTaskResult;\nimport com.tcoded.folialib.wrapper.WrappedTask;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\n\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;", "import java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(\"unused\")\npublic interface ServerImplementation {\n\n    // ----- Run now -----\n\n    /**\n     * Folia: Synced with the server daylight cycle tick\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param runnable Task to run\n     * @return Future when the task is completed\n     */\n    CompletableFuture<Void> runNextTick(Runnable runnable);\n\n    /**\n     * Folia: Async\n     * Paper: Async\n     * Spigot: Async\n     * @param runnable Task to run\n     * @return Future when the task is completed\n     */\n    CompletableFuture<Void> runAsync(Runnable runnable);\n\n    // ----- Run Later -----\n\n    /**\n     * Folia: Synced with the server daylight cycle tick\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param runnable Task to run\n     * @param delay Delay before execution\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runLater(Runnable runnable, long delay, TimeUnit unit);\n\n    /**\n     * Folia: Async\n     * Paper: Async\n     * Spigot: Async\n     * @param runnable Task to run\n     * @param delay Delay before execution\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runLaterAsync(Runnable runnable, long delay, TimeUnit unit);\n\n    // ----- Global Timers -----\n\n    /**\n     * Folia: Synced with the server daylight cycle tick\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param runnable Task to run\n     * @param delay Delay before first execution\n     * @param period Delay between executions\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runTimer(Runnable runnable, long delay, long period, TimeUnit unit);\n\n    /**\n     * Folia: Async\n     * Paper: Async\n     * Spigot: Async\n     * @param runnable Task to run\n     * @param delay Delay before first execution\n     * @param period Delay between executions\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runTimerAsync(Runnable runnable, long delay, long period, TimeUnit unit);\n\n\n    // ----- Location/Region based -----\n\n    /**\n     * Folia: Synced with the tick of the region of the chunk of the location\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param location Location to run the task at\n     * @param runnable Task to run\n     * @return Future when the task is completed\n     */\n    CompletableFuture<Void> runAtLocation(Location location, Runnable runnable);\n\n    /**\n     * Folia: Synced with the tick of the region of the chunk of the location\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param location Location to run the task at\n     * @param runnable Task to run\n     * @param delay Delay before execution\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runAtLocationLater(Location location, Runnable runnable, long delay, TimeUnit unit);\n\n    /**\n     * Folia: Synced with the tick of the region of the chunk of the location\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param location Location to run the task at\n     * @param runnable Task to run\n     * @param delay Delay before first execution\n     * @param period Delay between executions\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runAtLocationTimer(Location location, Runnable runnable, long delay, long period, TimeUnit unit);\n\n\n    // ----- Entity based -----\n\n    /**\n     * Folia: Synced with the tick of the region of the entity (even if the entity moves)\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param entity Entity to run the task at\n     * @param runnable Task to run\n     * @return Future when the task is completed\n     */\n    CompletableFuture<EntityTaskResult> runAtEntity(Entity entity, Runnable runnable);\n\n    /**\n     * Folia: Synced with the tick of the region of the entity (even if the entity moves)\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param entity Entity to run the task at\n     * @param runnable Task to run\n     * @return Future when the task is completed\n     */\n    CompletableFuture<EntityTaskResult> runAtEntityWithFallback(Entity entity, Runnable runnable, Runnable fallback);\n\n    /**\n     * Folia: Synced with the tick of the region of the entity (even if the entity moves)\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param entity Entity to run the task at\n     * @param runnable Task to run\n     * @param delay Delay before execution\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runAtEntityLater(Entity entity, Runnable runnable, long delay, TimeUnit unit);\n\n    /**\n     * Folia: Synced with the tick of the region of the entity (even if the entity moves)\n     * Paper: Synced with the server main thread\n     * Spigot: Synced with the server main thread\n     * @param entity Entity to run the task at\n     * @param runnable Task to run\n     * @param delay Delay before first execution\n     * @param period Delay between executions\n     * @param unit Time unit\n     * @return WrappedTask instance\n     */\n    WrappedTask runAtEntityTimer(Entity entity, Runnable runnable, long delay, long period, TimeUnit unit);\n\n    /**\n     * Cancel a task\n     * @param task Task to cancel\n     */\n    void cancelTask(WrappedTask task);\n\n    /**\n     * Cancel all tasks\n     */\n    void cancelAllTasks();\n\n    /**\n     * Get a player by name (approximately)\n     * @param name Name of the player\n     * @return Player instance\n     */\n    Player getPlayer(String name);\n\n    /**\n     * Get a player by name (exactly)\n     * @param name Name of the player\n     * @return Player instance\n     */\n    Player getPlayerExact(String name);\n\n    /**\n     * Get a player by UUID\n     * @param uuid UUID of the player\n     * @return Player instance\n     */\n    Player getPlayer(UUID uuid);\n\n    /**\n     * Teleport a player to a location async\n     * @return Future when the teleport is completed or failed\n     */\n    CompletableFuture<Boolean> teleportAsync(Player player, Location location);\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/impl/PaperImplementation.java", "chunked_list": ["package com.tcoded.folialib.impl;\n\nimport com.tcoded.folialib.FoliaLib;\n\npublic class PaperImplementation extends SpigotImplementation {\n\n    public PaperImplementation(FoliaLib foliaLib) {\n        super(foliaLib);\n    }\n\n    // Don't need to override anything, since we're extending SpigotImplementation\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/impl/FoliaImplementation.java", "chunked_list": ["package com.tcoded.folialib.impl;\n\nimport com.tcoded.folialib.FoliaLib;\nimport com.tcoded.folialib.enums.EntityTaskResult;\nimport com.tcoded.folialib.util.TimeConverter;\nimport com.tcoded.folialib.wrapper.WrappedTask;\nimport com.tcoded.folialib.wrapper.task.WrappedFoliaTask;\nimport io.papermc.paper.threadedregions.scheduler.AsyncScheduler;\nimport io.papermc.paper.threadedregions.scheduler.GlobalRegionScheduler;\nimport org.bukkit.Chunk;", "import io.papermc.paper.threadedregions.scheduler.GlobalRegionScheduler;\nimport org.bukkit.Chunk;\nimport org.bukkit.Location;\nimport org.bukkit.World;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;", "import java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class FoliaImplementation implements ServerImplementation {\n\n    private final JavaPlugin plugin;\n    private final GlobalRegionScheduler globalRegionScheduler;\n    private final AsyncScheduler asyncScheduler;\n\n    public FoliaImplementation(FoliaLib foliaLib) {\n        this.plugin = foliaLib.getPlugin();\n        this.globalRegionScheduler = plugin.getServer().getGlobalRegionScheduler();\n        this.asyncScheduler = plugin.getServer().getAsyncScheduler();\n    }\n\n    @Override\n    public CompletableFuture<Void> runNextTick(Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.globalRegionScheduler.execute(plugin, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override\n    public CompletableFuture<Void> runAsync(Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.asyncScheduler.runNow(plugin, task -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runLater(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.globalRegionScheduler.runDelayed(\n                        plugin, task -> runnable.run(), TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runLaterAsync(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.asyncScheduler.runDelayed(\n                        plugin, task -> runnable.run(), delay, unit\n                )\n        );\n    }\n\n    @Override", "    public WrappedTask runLaterAsync(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.asyncScheduler.runDelayed(\n                        plugin, task -> runnable.run(), delay, unit\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runTimer(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.globalRegionScheduler.runAtFixedRate(\n                        plugin, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override", "    public WrappedTask runTimer(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.globalRegionScheduler.runAtFixedRate(\n                        plugin, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override", "    public WrappedTask runTimerAsync(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.asyncScheduler.runAtFixedRate(\n                        plugin, task -> runnable.run(),\n                        delay, period, unit\n                )\n        );\n    }\n\n    @Override\n    public CompletableFuture<Void> runAtLocation(Location location, Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.plugin.getServer().getRegionScheduler().execute(plugin, location, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runAtLocationLater(Location location, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.plugin.getServer().getRegionScheduler().runDelayed(\n                        plugin, location, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runAtLocationTimer(Location location, Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.plugin.getServer().getRegionScheduler().runAtFixedRate(\n                        plugin, location, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override\n    public CompletableFuture<EntityTaskResult> runAtEntity(Entity entity, Runnable runnable) {\n        CompletableFuture<EntityTaskResult> future = new CompletableFuture<>();\n\n        boolean success = entity.getScheduler().execute(this.plugin, () -> {\n            runnable.run();\n            future.complete(EntityTaskResult.SUCCESS);\n        }, null, 0);\n", "    public WrappedTask runAtLocationTimer(Location location, Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.plugin.getServer().getRegionScheduler().runAtFixedRate(\n                        plugin, location, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override\n    public CompletableFuture<EntityTaskResult> runAtEntity(Entity entity, Runnable runnable) {\n        CompletableFuture<EntityTaskResult> future = new CompletableFuture<>();\n\n        boolean success = entity.getScheduler().execute(this.plugin, () -> {\n            runnable.run();\n            future.complete(EntityTaskResult.SUCCESS);\n        }, null, 0);\n", "        if (!success) {\n            future.complete(EntityTaskResult.SCHEDULER_RETIRED);\n        }\n\n        return future;\n    }\n\n    @Override\n    public CompletableFuture<EntityTaskResult> runAtEntityWithFallback(Entity entity, Runnable runnable, Runnable fallback) {\n        CompletableFuture<EntityTaskResult> future = new CompletableFuture<>();\n\n        boolean success = entity.getScheduler().execute(this.plugin, () -> {\n            runnable.run();\n            future.complete(EntityTaskResult.SUCCESS);\n        }, () -> {\n            fallback.run();\n            future.complete(EntityTaskResult.ENTITY_RETIRED);\n        }, 0);\n", "        if (!success) {\n            future.complete(EntityTaskResult.SCHEDULER_RETIRED);\n        }\n\n        return future;\n    }\n\n    @Override\n    public WrappedTask runAtEntityLater(Entity entity, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                entity.getScheduler().runDelayed(\n                        plugin,\n                        task -> runnable.run(),\n                        null,\n                        TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override", "    public WrappedTask runAtEntityLater(Entity entity, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                entity.getScheduler().runDelayed(\n                        plugin,\n                        task -> runnable.run(),\n                        null,\n                        TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override", "    public WrappedTask runAtEntityTimer(Entity entity, Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                entity.getScheduler().runAtFixedRate(\n                        plugin,\n                        task -> runnable.run(),\n                        null,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override", "    public void cancelTask(WrappedTask task) {\n        task.cancel();\n    }\n\n    @Override\n    public void cancelAllTasks() {\n        this.globalRegionScheduler.cancelTasks(plugin);\n        this.asyncScheduler.cancelTasks(plugin);\n    }\n\n    @Override", "    public Player getPlayer(String name) {\n        // This is thread-safe in folia\n        return this.plugin.getServer().getPlayer(name);\n    }\n\n    @Override\n    public Player getPlayerExact(String name) {\n        // This is thread-safe in folia\n        return this.plugin.getServer().getPlayerExact(name);\n    }\n\n    @Override", "    public Player getPlayer(UUID uuid) {\n        // This is thread-safe in folia\n        return this.plugin.getServer().getPlayer(uuid);\n    }\n\n    @Override\n    public CompletableFuture<Boolean> teleportAsync(Player player, Location location) {\n        return player.teleportAsync(location);\n    }\n}\n"]}
{"filename": "src/main/java/com/tcoded/folialib/impl/SpigotImplementation.java", "chunked_list": ["package com.tcoded.folialib.impl;\n\nimport com.tcoded.folialib.FoliaLib;\nimport com.tcoded.folialib.enums.EntityTaskResult;\nimport com.tcoded.folialib.util.TimeConverter;\nimport com.tcoded.folialib.wrapper.WrappedTask;\nimport com.tcoded.folialib.wrapper.task.WrappedBukkitTask;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;", "import org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport org.bukkit.scheduler.BukkitScheduler;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;", "import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class SpigotImplementation implements ServerImplementation {\n\n    private final JavaPlugin plugin;\n    @SuppressWarnings(\"deprecation\")\n    private final @NotNull BukkitScheduler scheduler;\n\n    public SpigotImplementation(FoliaLib foliaLib) {\n        this.plugin = foliaLib.getPlugin();\n        this.scheduler = plugin.getServer().getScheduler();\n    }\n\n    @Override\n    public CompletableFuture<Void> runNextTick(Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.scheduler.runTask(plugin, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override\n    public CompletableFuture<Void> runAsync(Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.scheduler.runTaskAsynchronously(plugin, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runLater(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );\n    }\n\n    @Override\n    public WrappedTask runLaterAsync(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLaterAsynchronously(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );\n    }\n\n    @Override", "    public WrappedTask runTimer(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskTimer(\n                        plugin, runnable,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );\n    }\n\n    @Override\n    public WrappedTask runTimerAsync(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskTimerAsynchronously(\n                        plugin, runnable,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );\n    }\n\n    @Override\n    public CompletableFuture<Void> runAtLocation(Location location, Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.scheduler.runTask(plugin, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runTimerAsync(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskTimerAsynchronously(\n                        plugin, runnable,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );\n    }\n\n    @Override\n    public CompletableFuture<Void> runAtLocation(Location location, Runnable runnable) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        this.scheduler.runTask(plugin, () -> {\n            runnable.run();\n            future.complete(null);\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runAtLocationLater(Location location, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );\n    }\n\n    @Override\n    public WrappedTask runAtLocationTimer(Location location, Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskTimer(\n                        plugin, runnable,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );\n    }\n\n    @Override\n    public CompletableFuture<EntityTaskResult> runAtEntity(Entity entity, Runnable runnable) {\n        CompletableFuture<EntityTaskResult> future = new CompletableFuture<>();\n\n        this.scheduler.runTask(plugin, () -> {\n            runnable.run();\n            future.complete(EntityTaskResult.SUCCESS);\n        });\n\n        return future;\n    }\n\n    @Override\n    public CompletableFuture<EntityTaskResult> runAtEntityWithFallback(Entity entity, Runnable runnable, Runnable fallback) {\n        CompletableFuture<EntityTaskResult> future = new CompletableFuture<>();\n\n        this.scheduler.runTask(plugin, () -> {", "            if (entity.isValid()) {\n                runnable.run();\n                future.complete(EntityTaskResult.SUCCESS);\n            } else {\n                fallback.run();\n                future.complete(EntityTaskResult.ENTITY_RETIRED);\n            }\n        });\n\n        return future;\n    }\n\n    @Override", "    public WrappedTask runAtEntityLater(Entity entity, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );\n    }\n\n    @Override\n    public WrappedTask runAtEntityTimer(Entity entity, Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskTimer(\n                        plugin, runnable,\n                        TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );\n    }\n\n    @Override", "    public void cancelTask(WrappedTask task) {\n        task.cancel();\n    }\n\n    @Override\n    public void cancelAllTasks() {\n        this.scheduler.cancelTasks(plugin);\n    }\n\n    @Override\n    public Player getPlayer(String name) {\n        // Already on the main thread", "    public Player getPlayer(String name) {\n        // Already on the main thread\n        if (this.plugin.getServer().isPrimaryThread()) {\n            return this.plugin.getServer().getPlayer(name);\n        }\n        // Not on the main thread, we need to wait until the next tick\n        else {\n            try {\n                return this.scheduler.callSyncMethod(plugin, () -> this.plugin.getServer().getPlayer(name)).get();\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        // Fallback to null\n        return null;\n    }\n\n    @Override", "    public Player getPlayerExact(String name) {\n        // Already on the main thread\n        if (this.plugin.getServer().isPrimaryThread()) {\n            return this.plugin.getServer().getPlayerExact(name);\n        }\n        // Not on the main thread, we need to wait until the next tick\n        else {\n            try {\n                return this.scheduler.callSyncMethod(plugin, () -> this.plugin.getServer().getPlayerExact(name)).get();\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        // Fallback to null\n        return null;\n    }\n\n    @SuppressWarnings(\"DuplicatedCode\")\n    @Override", "    public Player getPlayer(UUID uuid) {\n        // Already on the main thread\n        if (this.plugin.getServer().isPrimaryThread()) {\n            return this.plugin.getServer().getPlayer(uuid);\n        }\n        // Not on the main thread, we need to wait until the next tick\n        else {\n            try {\n                return this.scheduler.callSyncMethod(plugin, () -> this.plugin.getServer().getPlayer(uuid)).get();\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // Fallback to null\n        return null;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> teleportAsync(Player player, Location location) {\n        CompletableFuture<Boolean> future = new CompletableFuture<>();\n\n        this.runAtEntity(player, () -> {", "            if (player.isValid() && player.isOnline()) {\n                player.teleport(location);\n                future.complete(true);\n            } else {\n                future.complete(false);\n            }\n        });\n\n        return future;\n    }\n}\n"]}
