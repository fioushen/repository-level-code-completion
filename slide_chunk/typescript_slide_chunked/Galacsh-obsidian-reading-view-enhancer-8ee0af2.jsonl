{"filename": "src/styles.ts", "chunked_list": ["import { SELECTED_BLOCK } from \"./constants\";\n\n/**\n * Style rule that holds the template\n * and the function to inject variables\n */\nclass StyleRule {\n\tprivate template: string;\n\tprivate injectVariables: (template: string) => string;\n\tisActive: boolean;\n\n\tconstructor(template: string, injectVariables: (template: string) => string) {\n\t\tthis.template = template;\n\t\tthis.isActive = false;\n\t\tthis.injectVariables = injectVariables;\n\t}\n\n\t/**\n\t * Get the rule after injecting variables\n\t *\n\t * @returns {string} The rule\n\t */\n\tgetRule() {\n\t\treturn this.injectVariables(this.template);\n\t}\n}\n\n/**\n * Block color rule.\n *\n * Accepts a block color and injects it into the template.\n */", "export class BlockColorRule extends StyleRule {\n\tprivate blockColor: string;\n\n\tconstructor() {\n\t\tconst template = `\n\t\t\t.${SELECTED_BLOCK} {\n\t\t\t\tposition: relative;\n\t\t\t}\n\t\t\t\n\t\t\t.${SELECTED_BLOCK}::before {\n\t\t\t\tcontent: \"\";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tpointer-events: none;\n\t\t\t\tbackground-color: {{BLOCK_COLOR}}1a;\n\t\t\t}\n\t\t`;\n\t\tsuper(template, (template: string) => {\n\t\t\treturn template.replace(\"{{BLOCK_COLOR}}\", this.blockColor);\n\t\t});\n\n\t\tthis.isActive = true;\n\t}\n\n\t/**\n\t * Set the block color\n\t *\n\t * @param blockColor {string} The block color\n\t */\n\tset(blockColor: string) {\n\t\tthis.blockColor = blockColor;\n\t}\n}\n\n/**\n * Collapse indicator rule.\n *\n * No variables to inject.\n */", "export class CollapseIndicatorRule extends StyleRule {\n\tconstructor() {\n\t\tconst template = `\n\t\t\t.markdown-preview-section .collapse-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t`;\n\t\tsuper(template, (template: string) => template);\n\t}\n}\n\n/**\n * Prevent table overflowing rule.\n *\n * No variables to inject.\n */", "export class PreventTableOverflowingRule extends StyleRule {\n\tconstructor() {\n\t\tconst template = `\n\t\t\t.markdown-preview-section > div:has(table) {\n\t\t\t\toverflow: auto;\n\t\t\t}\n\n\t\t\t.markdown-preview-section thead > tr > th,\n\t\t\t.markdown-preview-section tbody > tr > td {\n\t\t\t\twhite-space: nowrap;\n\t\t\t}\n\t\t`;\n\t\tsuper(template, (template: string) => template);\n\t}\n}\n\n/**\n * Scrollable code rule.\n *\n * No variables to inject.\n */", "export class ScrollableCodeRule extends StyleRule {\n\tconstructor() {\n\t\tconst template = `\n\t\t\t.markdown-preview-section div > pre {\n\t\t\t\toverflow: hidden;\n\t\t\t\twhite-space: pre-wrap;\n\t\t\t}\n\n\t\t\t.markdown-preview-section div > pre > code {\n\t\t\t\tdisplay: block;\n\t\t\t\toverflow: auto;\n\t\t\t\twhite-space: pre;\n\t\t\t}\n\t\t`;\n\t\tsuper(template, (template: string) => template);\n\t}\n}\n", "type RuleKey =\n\t| \"block-color\"\n\t| \"collapse-indicator\"\n\t| \"prevent-table-overflowing\"\n\t| \"scrollable-code\";\n\n/**\n * The class that manages all style rules.\n */\nexport default class RveStyles {\n\tstyleTag: HTMLStyleElement;\n\trules: Record<RuleKey, StyleRule>;\n\n\tconstructor() {\n\t\tthis.styleTag = document.createElement(\"style\");\n\t\tthis.styleTag.id = \"rve-styles\";\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(this.styleTag);\n\n\t\tthis.rules = {\n\t\t\t\"block-color\": new BlockColorRule(),\n\t\t\t\"collapse-indicator\": new CollapseIndicatorRule(),\n\t\t\t\"prevent-table-overflowing\": new PreventTableOverflowingRule(),\n\t\t\t\"scrollable-code\": new ScrollableCodeRule(),\n\t\t};\n\t}\n\n\t/**\n\t * Clean up the style tag\n\t */\n\tcleanup() {\n\t\tthis.styleTag.remove();\n\t}\n\n\t/**\n\t * Get a rule by key\n\t *\n\t * @param rule {RuleKey} rule's key\n\t * @returns {StyleRule} One of the rules\n\t */\n\tof(rule: RuleKey) {\n\t\treturn this.rules[rule];\n\t}\n\n\t/**\n\t * Apply all active rules\n\t */\n\tapply() {\n\t\tconst style = Object.values(this.rules)\n\t\t\t.filter((rule) => rule.isActive)\n\t\t\t.map((rule) => rule.getRule())\n\t\t\t.join(\"\\n\");\n\n\t\tthis.styleTag.innerHTML = style;\n\t}\n}\n", "export default class RveStyles {\n\tstyleTag: HTMLStyleElement;\n\trules: Record<RuleKey, StyleRule>;\n\n\tconstructor() {\n\t\tthis.styleTag = document.createElement(\"style\");\n\t\tthis.styleTag.id = \"rve-styles\";\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(this.styleTag);\n\n\t\tthis.rules = {\n\t\t\t\"block-color\": new BlockColorRule(),\n\t\t\t\"collapse-indicator\": new CollapseIndicatorRule(),\n\t\t\t\"prevent-table-overflowing\": new PreventTableOverflowingRule(),\n\t\t\t\"scrollable-code\": new ScrollableCodeRule(),\n\t\t};\n\t}\n\n\t/**\n\t * Clean up the style tag\n\t */\n\tcleanup() {\n\t\tthis.styleTag.remove();\n\t}\n\n\t/**\n\t * Get a rule by key\n\t *\n\t * @param rule {RuleKey} rule's key\n\t * @returns {StyleRule} One of the rules\n\t */\n\tof(rule: RuleKey) {\n\t\treturn this.rules[rule];\n\t}\n\n\t/**\n\t * Apply all active rules\n\t */\n\tapply() {\n\t\tconst style = Object.values(this.rules)\n\t\t\t.filter((rule) => rule.isActive)\n\t\t\t.map((rule) => rule.getRule())\n\t\t\t.join(\"\\n\");\n\n\t\tthis.styleTag.innerHTML = style;\n\t}\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { Plugin } from \"obsidian\";\nimport RveStyles, { BlockColorRule } from \"./styles\";\nimport { RveSettingTab, RveSettings, DEFAULT_SETTINGS } from \"./settings\";\nimport Commands from \"./commands\";\nimport BlockSelector from \"./block-selector\";\n\nexport default class ReadingViewEnhancer extends Plugin {\n\tsettings: RveSettings;\n\tstyles: RveStyles;\n\tblockSelector: BlockSelector;\n\n\t/**\n\t * On load,\n\t *\n\t * - Load settings & styles\n\t * - Activate block selector\n\t *     - It actually do its work if settings.enableBlockSelector is true\n\t * - Register all commands\n\t * - Add settings tab\n\t */\n\tasync onload() {\n\t\t// Settings & Styles\n\t\tawait this.loadSettings();\n\t\tthis.styles = new RveStyles();\n\t\tthis.app.workspace.onLayoutReady(() => this.applySettingsToStyles());\n\n\t\t// Activate block selector.\n\t\tthis.blockSelector = new BlockSelector(this);\n\t\tthis.blockSelector.activate();\n\n\t\t// Register commands\n\t\tnew Commands(this).register();\n\n\t\t// Add settings tab at last\n\t\tthis.addSettingTab(new RveSettingTab(this));\n\n\t\t// Leave a message in the console\n\t\tconsole.log(\"Loaded 'Reading View Enhancer'\");\n\t}\n\n\t/**\n\t * On unload,\n\t *\n\t * - Remove all styles\n\t */\n\tasync onunload() {\n\t\tthis.styles.cleanup();\n\n\t\t// Leave a message in the console\n\t\tconsole.log(\"Unloaded 'Reading View Enhancer'\");\n\t}\n\n\t// ===================================================================\n\n\t/**\n\t * Load settings\n\t */\n\tasync loadSettings() {\n\t\tthis.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n\t}\n\n\t/**\n\t * Save settings\n\t */\n\tasync saveSettings() {\n\t\tawait this.saveData(this.settings);\n\t}\n\n\t/**\n\t * Apply settings to styles\n\t *\n\t * - Apply block color\n\t * - Apply always on collapse indicator\n\t * - Apply prevent table overflowing\n\t * - Apply scrollable code\n\t */\n\tprivate applySettingsToStyles() {\n\t\tthis.applyBlockColor();\n\t\tthis.applyAlwaysOnCollapse();\n\t\tthis.applyPreventTableOverflowing();\n\t\tthis.applyScrollableCode();\n\t\tthis.styles.apply();\n\t}\n\n\t/**\n\t * Apply block color\n\t *\n\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t */\n\tapplyBlockColor(isImmediate = false) {\n\t\tconst blockColor = this.styles.of(\"block-color\") as BlockColorRule;\n\t\tblockColor.set(this.settings.blockColor);", "\t\tif (isImmediate) this.styles.apply();\n\t}\n\n\t/**\n\t * Apply always on collapse indicator\n\t *\n\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t */\n\tapplyAlwaysOnCollapse(isImmediate = false) {\n\t\tthis.styles.of(\"collapse-indicator\").isActive =\n\t\t\tthis.settings.alwaysOnCollapseIndicator;", "\t\tif (isImmediate) this.styles.apply();\n\t}\n\n\t/**\n\t * Apply prevent table overflowing\n\t *\n\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t */\n\tapplyPreventTableOverflowing(isImmediate = false) {\n\t\tthis.styles.of(\"prevent-table-overflowing\").isActive =\n\t\t\tthis.settings.preventTableOverflowing;", "\t\tif (isImmediate) this.styles.apply();\n\t}\n\n\t/**\n\t * Apply scrollable code\n\t *\n\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t */\n\tapplyScrollableCode(isImmediate = false) {\n\t\tthis.styles.of(\"scrollable-code\").isActive = this.settings.scrollableCode;\n\t\tif (isImmediate) this.styles.apply();\n\t}\n}\n", "\t\tif (isImmediate) this.styles.apply();\n\t}\n}\n"]}
{"filename": "src/constants.ts", "chunked_list": ["/**\n * Class name for the preview view\n */\nexport const MARKDOWN_PREVIEW_VIEW = \"markdown-preview-view\";\n\n/**\n * Class name for the frontmatter element\n */\nexport const FRONTMATTER = \"frontmatter\";\n", "export const FRONTMATTER = \"frontmatter\";\n\n/**\n * List of selectors for block elements\n */\nexport const BLOCKS = [\n\t\"p\",\n\t\"li\",\n\t\"table\",\n\t\"h1\",", "\t\"table\",\n\t\"h1\",\n\t\"h2\",\n\t\"h3\",\n\t\"h4\",\n\t\"h5\",\n\t\"h6\",\n\t\"pre\",\n\t\"blockquote\",\n\t\"img\",", "\t\"blockquote\",\n\t\"img\",\n\t\"video\",\n\t\"audio\",\n\t\"iframe\",\n\t\"[data-callout]\",\n];\n\n/**\n * Class name for block selector", "/**\n * Class name for block selector\n */\nexport const BLOCK_SELECTOR = \"rve-block-selector\";\n\n/**\n * Attribute name for block elements\n */\nexport const BLOCK_ATTR = \"data-rve-block\";\n", "export const BLOCK_ATTR = \"data-rve-block\";\n\n/**\n * Class name for selected block\n */\nexport const SELECTED_BLOCK = \"rve-selected-block\";\n\n/**\n * Selector for collapse indicators\n */", " * Selector for collapse indicators\n */\nexport const COLLAPSE_INDICATORS = [\".collapse-indicator\", \".callout-fold\"];\n\n/**\n * Class name for collapsed block\n */\nexport const IS_COLLAPSED = \"is-collapsed\";\n", ""]}
{"filename": "src/commands/commands.ts", "chunked_list": ["import { RveCommand } from \".\";\nimport ReadingViewEnhancer from \"src/main\";\nimport { MarkdownView, Platform } from \"obsidian\";\n\n/**\n * Rerender all reading views\n *\n * @param plugin {ReadingViewEnhancer} Plugin instance\n * @returns {RveCommand} Rerender all reading views command\n */", " * @returns {RveCommand} Rerender all reading views command\n */\nexport const rerenderAllReadingViews: RveCommand = (\n\tplugin: ReadingViewEnhancer\n) => ({\n\tid: \"rerender-all-reading-views\",\n\tname: \"Rerender all reading views\",\n\tcallback: () => {\n\t\tconst { workspace } = plugin.app;\n\t\tworkspace.getLeavesOfType(\"markdown\").forEach((leaf) => {\n\t\t\tif (leaf.view.getState().mode === \"preview\") {\n\t\t\t\t// @ts-ignore\n\t\t\t\tleaf.view.previewMode?.rerender(true);\n\t\t\t}\n\t\t});\n\t},\n});\n\n/**\n * Select top block in the view\n *\n * @param plugin {ReadingViewEnhancer} Plugin instance\n * @returns {RveCommand} Select top block in the view command\n */\nexport const selectTopBlockInTheView: RveCommand = (\n\tplugin: ReadingViewEnhancer\n) => ({\n\tid: \"select-top-block-in-the-view\",\n\tname: \"Select Top Block in the View\",\n\tcheckCallback: (checking: boolean): boolean => {\n\t\t// If checking is set to true, perform a preliminary check.", "\t\tconst { workspace } = plugin.app;\n\t\tworkspace.getLeavesOfType(\"markdown\").forEach((leaf) => {\n\t\t\tif (leaf.view.getState().mode === \"preview\") {\n\t\t\t\t// @ts-ignore\n\t\t\t\tleaf.view.previewMode?.rerender(true);\n\t\t\t}\n\t\t});\n\t},\n});\n\n/**\n * Select top block in the view\n *\n * @param plugin {ReadingViewEnhancer} Plugin instance\n * @returns {RveCommand} Select top block in the view command\n */\nexport const selectTopBlockInTheView: RveCommand = (\n\tplugin: ReadingViewEnhancer\n) => ({\n\tid: \"select-top-block-in-the-view\",\n\tname: \"Select Top Block in the View\",\n\tcheckCallback: (checking: boolean): boolean => {\n\t\t// If checking is set to true, perform a preliminary check.", "\t\tif (checking) {\n\t\t\tif (isNotReadingView(plugin)) return false;\n\t\t\telse if (isNotEnabled(plugin)) return false;\n\t\t\telse if (isMobileAndDisabled(plugin)) return false;\n\t\t\telse return true;\n\t\t}\n\t\t// If checking is set to false, perform an action.\n\t\telse {\n\t\t\tconst container = getReadingViewContainer(plugin);\n\t\t\tif (container) {\n\t\t\t\tplugin.blockSelector.selectTopBlockInTheView(container);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t},\n});\n\nconst isNotReadingView = (plugin: ReadingViewEnhancer) => {\n\tconst activeView = getActiveView(plugin);\n\treturn activeView?.getState().mode !== \"preview\";\n};\n\nconst isNotEnabled = (plugin: ReadingViewEnhancer) => {\n\treturn !plugin.settings.enableBlockSelector;\n};\n\nconst isMobileAndDisabled = (plugin: ReadingViewEnhancer) => {\n\treturn (\n\t\t(Platform.isMobile || Platform.isMobileApp) &&\n\t\tplugin.settings.disableBlockSelectorOnMobile\n\t);\n};\n\nconst getReadingViewContainer = (plugin: ReadingViewEnhancer) => {\n\tconst activeView = getActiveView(plugin);\n\treturn activeView?.previewMode.containerEl;\n};\n\nconst getActiveView = (plugin: ReadingViewEnhancer) => {\n\tconst { workspace } = plugin.app;\n\treturn workspace.getActiveViewOfType(MarkdownView);\n};\n", "\t\t\tif (container) {\n\t\t\t\tplugin.blockSelector.selectTopBlockInTheView(container);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t},\n});\n\nconst isNotReadingView = (plugin: ReadingViewEnhancer) => {\n\tconst activeView = getActiveView(plugin);\n\treturn activeView?.getState().mode !== \"preview\";\n};\n\nconst isNotEnabled = (plugin: ReadingViewEnhancer) => {\n\treturn !plugin.settings.enableBlockSelector;\n};\n\nconst isMobileAndDisabled = (plugin: ReadingViewEnhancer) => {\n\treturn (\n\t\t(Platform.isMobile || Platform.isMobileApp) &&\n\t\tplugin.settings.disableBlockSelectorOnMobile\n\t);\n};\n\nconst getReadingViewContainer = (plugin: ReadingViewEnhancer) => {\n\tconst activeView = getActiveView(plugin);\n\treturn activeView?.previewMode.containerEl;\n};\n\nconst getActiveView = (plugin: ReadingViewEnhancer) => {\n\tconst { workspace } = plugin.app;\n\treturn workspace.getActiveViewOfType(MarkdownView);\n};\n"]}
{"filename": "src/commands/index.ts", "chunked_list": ["import { Command } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\nimport * as commands from \"./commands\";\n\nexport interface RveCommand {\n\t(plugin: ReadingViewEnhancer): Command;\n}\n\n/**\n * Set commands for plugin.\n * Loads all commands from `commands` directory and add them to plugin.\n */", "export default class Commands {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(plugin: ReadingViewEnhancer) {\n\t\tthis.plugin = plugin;\n\t}\n\n\tregister() {\n\t\tObject.values(commands)\n\t\t\t.map((revCommand: RveCommand) => revCommand(this.plugin))\n\t\t\t.forEach((command) => this.plugin.addCommand(command));\n\t}\n}\n"]}
{"filename": "src/settings/index.ts", "chunked_list": ["import { PluginSettingTab } from \"obsidian\";\nimport ReadingViewEnhancer from \"../main\";\nimport BlockSelectorSettings from \"./block\";\nimport MiscellaneousSettings from \"./miscellaneous\";\n\nexport interface RveSettings {\n\tblockColor: string;\n\tenableBlockSelector: boolean;\n\tdisableBlockSelectorOnMobile: boolean;\n\talwaysOnCollapseIndicator: boolean;\n\tpreventTableOverflowing: boolean;\n\tscrollableCode: boolean;\n}\n\nexport const DEFAULT_SETTINGS: RveSettings = {\n\tblockColor: \"#8b6cef\", // Obsidian default color\n\tenableBlockSelector: false,\n\tdisableBlockSelectorOnMobile: false,\n\talwaysOnCollapseIndicator: false,\n\tpreventTableOverflowing: false,\n\tscrollableCode: false,\n};\n\n// ===================================================================\n\n/**\n * Settings tab.\n * In this tab, you can change settings.\n *\n * - Block color\n * - Enable/Disable Block Selector\n */", "export class RveSettingTab extends PluginSettingTab {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(plugin: ReadingViewEnhancer) {\n\t\tsuper(app, plugin);\n\t\tthis.plugin = plugin;\n\t}\n\n\t/**\n\t * Displays settings tab.\n\t */\n\tdisplay() {\n\t\tconst { containerEl } = this;\n\n\t\t// Clear all first\n\t\tcontainerEl.empty();\n\n\t\t// Add header\n\t\tcontainerEl.createEl(\"h1\", { text: \"Reading View Enhancer\" });\n\n\t\t// Add block selector settings\n\t\tnew BlockSelectorSettings(containerEl, this.plugin);\n\n\t\t// Add miscellaneous settings\n\t\tnew MiscellaneousSettings(containerEl, this.plugin);\n\t}\n}\n"]}
{"filename": "src/settings/miscellaneous/always-on-collapse-indicator.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Always on collapse indicator setting component\n */\nexport default class AlwaysOnCollapseIndicatorSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\tworkspaceEl: HTMLElement;\n\n\tconstructor(settingsTabEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(settingsTabEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Always on collapse indicator\")\n\t\t\t.setDesc(\"Set collapse indicators always visible in reading view.\")\n\t\t\t.addToggle((toggle) => this.alwaysOnCollapseIndicator(toggle));\n\t}\n\n\t/**\n\t * Creates toggle component\n\t *\n\t * @param toggle {ToggleComponent} Toggle component\n\t */\n\talwaysOnCollapseIndicator(toggle: ToggleComponent) {\n\t\tconst { settings } = this.plugin;\n\n\t\ttoggle.setValue(settings.alwaysOnCollapseIndicator).onChange((changed) => {\n\t\t\tsettings.alwaysOnCollapseIndicator = changed;\n\t\t\tthis.plugin.saveSettings();\n\t\t\tthis.plugin.applyAlwaysOnCollapse(true);\n\t\t});\n\t}\n}\n"]}
{"filename": "src/settings/miscellaneous/scrollable-code.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Scrollable code setting component\n */\nexport default class ScrollableCodeSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(containerEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Scrollable Code\")\n\t\t\t.setDesc(\"Make code blocks scrollable instead of line break.\")\n\t\t\t.addToggle((toggle) => this.setCodeScrollable(toggle));\n\t}\n\n\tsetCodeScrollable(toggle: ToggleComponent) {\n\t\ttoggle.setValue(this.plugin.settings.scrollableCode);\n\n\t\t// save on change\n\t\ttoggle.onChange((changed) => {\n\t\t\tthis.plugin.settings.scrollableCode = changed;\n\t\t\tthis.plugin.saveSettings();\n\t\t\tthis.plugin.applyScrollableCode(true);\n\t\t});\n\t}\n}\n"]}
{"filename": "src/settings/miscellaneous/prevent-table-overflow.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Prevent table overflow setting component\n */\nexport default class PreventTableOverflowingSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(containerEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Prevent Table Overflowing\")\n\t\t\t.setDesc(\n\t\t\t\t\"Make tables scrollable to prevent table overflowing. \" +\n\t\t\t\t\t\"In Obsidian v1.1.16, table with a long text makes a horizontal scroll bar on the whole view. \" +\n\t\t\t\t\t\"This setting prevents that.\"\n\t\t\t)\n\t\t\t.addToggle((toggle) => this.preventTableOverflowing(toggle));\n\t}\n\n\tpreventTableOverflowing(toggle: ToggleComponent) {\n\t\ttoggle.setValue(this.plugin.settings.preventTableOverflowing);\n\n\t\t// save on change\n\t\ttoggle.onChange((changed) => {\n\t\t\tthis.plugin.settings.preventTableOverflowing = changed;\n\t\t\tthis.plugin.saveSettings();\n\t\t\tthis.plugin.applyPreventTableOverflowing(true);\n\t\t});\n\t}\n}\n"]}
{"filename": "src/settings/miscellaneous/index.ts", "chunked_list": ["import ReadingViewEnhancer from \"src/main\";\nimport AlwaysOnCollapseIndicatorSetting from \"./always-on-collapse-indicator\";\nimport PreventTableOverflowingSetting from \"./prevent-table-overflow\";\nimport ScrollableCodeSetting from \"./scrollable-code\";\n\n/**\n * Registers settings components not related to block.\n */\nexport default class MiscellaneousSettings {\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tcontainerEl.createEl(\"h2\", { text: \"Miscellaneous\" });\n\t\tnew AlwaysOnCollapseIndicatorSetting(containerEl, plugin);\n\t\tnew PreventTableOverflowingSetting(containerEl, plugin);\n\t\tnew ScrollableCodeSetting(containerEl, plugin);\n\t}\n}\n", "export default class MiscellaneousSettings {\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tcontainerEl.createEl(\"h2\", { text: \"Miscellaneous\" });\n\t\tnew AlwaysOnCollapseIndicatorSetting(containerEl, plugin);\n\t\tnew PreventTableOverflowingSetting(containerEl, plugin);\n\t\tnew ScrollableCodeSetting(containerEl, plugin);\n\t}\n}\n"]}
{"filename": "src/settings/block/block-selector.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Enable block selector setting component\n */\nexport default class EnableBlockSelectorSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(containerEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Enable Block Selector\")\n\t\t\t.setDesc(\n\t\t\t\t\"To take effect of changing this setting, \" +\n\t\t\t\t\t\"you can either reopen (close & open) reading views or restart Obsidian. \" +\n\t\t\t\t\t\"Alternatively, you can run the \u2018Rerender all reading views\u2019 command. \" +\n\t\t\t\t\t\"Please note that when you rerender reading views, the file title will disappear.\"\n\t\t\t)\n\t\t\t.addToggle((toggle) => this.setEnableSelector(toggle));\n\t}\n\n\t/**\n\t * Creates toggle component that enables/disables block selector.\n\t *\n\t * @param toggle {ToggleComponent} Toggle component\n\t */\n\tsetEnableSelector(toggle: ToggleComponent) {\n\t\ttoggle.setValue(this.plugin.settings.enableBlockSelector);\n\n\t\t// save on change\n\t\ttoggle.onChange((changed) => {\n\t\t\tthis.plugin.settings.enableBlockSelector = changed;\n\t\t\tthis.plugin.saveSettings();\n\t\t});\n\t}\n}\n"]}
{"filename": "src/settings/block/block-color.ts", "chunked_list": ["import { toHex } from \"color2k\";\nimport { ButtonComponent, ColorComponent, Setting } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Block color setting component\n */\nexport default class BlockColorSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\tworkspaceEl: HTMLElement;\n\n\tconstructor(settingsTabEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(settingsTabEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Block Color\")\n\t\t\t.setDesc(\n\t\t\t\t\"Set background color of the block in reading view. Transparency will be set automatically\"\n\t\t\t)\n\t\t\t.addColorPicker((color) => this.colorPicker(color));\n\t}\n\n\t/**\n\t * Creates color picker component.\n\t * Also, creates a button to set color to the current accent color.\n\t *\n\t * @param color {ColorComponent} Color component\n\t */\n\tcolorPicker(color: ColorComponent) {\n\t\tconst { settings } = this.plugin;\n\t\tcolor.setValue(settings.blockColor).onChange((changed) => {\n\t\t\t// save on change\n\t\t\tsettings.blockColor = toHex(changed);\n\t\t\tthis.plugin.saveSettings();\n\t\t\tthis.plugin.applyBlockColor(true);\n\t\t});\n\t\tthis.addButton((button) => this.accentColorButton(button, color));\n\t}\n\n\t/**\n\t * Creates a button to use current accent color.\n\t * Used in {@link colorPicker}.\n\t *\n\t * @param button {ButtonComponent} Button component\n\t * @param color {ColorComponent} Color component\n\t */\n\taccentColorButton(button: ButtonComponent, color: ColorComponent) {\n\t\tbutton.setButtonText(\"Use current accent color\").onClick(() => {\n\t\t\tconst accentColor = this.getAccentColor();\n\t\t\tcolor.setValue(accentColor);\n\n\t\t\tthis.plugin.settings.blockColor = accentColor;\n\t\t\tthis.plugin.saveSettings();\n\t\t\tthis.plugin.applyBlockColor(true);\n\t\t});\n\t}\n\n\t/**\n\t * Gets current accent color from Obsidian.\n\t *\n\t * @returns Current accent color in hex format\n\t */\n\tprivate getAccentColor(): string {\n\t\tconst workspaceEl = this.plugin.app.workspace.containerEl;\n\t\tconst accentColor = toHex(\n\t\t\tgetComputedStyle(workspaceEl).getPropertyValue(\"--color-accent\").trim()\n\t\t);\n\t\treturn accentColor;\n\t}\n}\n"]}
{"filename": "src/settings/block/block-selector-mobile.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\nimport ReadingViewEnhancer from \"src/main\";\n\n/**\n * Disable block selector on mobile setting component\n */\nexport default class DisableBlockSelectorOnMobileSetting extends Setting {\n\tplugin: ReadingViewEnhancer;\n\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tsuper(containerEl);\n\t\tthis.plugin = plugin;\n\n\t\tthis.setName(\"Disable Block Selector on Mobile\")\n\t\t\t.setDesc(\n\t\t\t\t\"To take effect of changing this setting, \" +\n\t\t\t\t\t\"you can either reopen (close & open) reading views or restart Obsidian. \" +\n\t\t\t\t\t\"Alternatively, you can run the \u2018Rerender all reading views\u2019 command. \" +\n\t\t\t\t\t\"Please note that when you rerender reading views, the file title will disappear.\"\n\t\t\t)\n\t\t\t.addToggle((toggle) => this.setDisableSelectorOnMobile(toggle));\n\t}\n\n\t/**\n\t * Creates toggle component that enables/disables block selector on mobile.\n\t *\n\t * @param toggle {ToggleComponent} Toggle component\n\t */\n\tsetDisableSelectorOnMobile(toggle: ToggleComponent) {\n\t\ttoggle.setValue(this.plugin.settings.disableBlockSelectorOnMobile);\n\n\t\t// save on change\n\t\ttoggle.onChange((changed) => {\n\t\t\tthis.plugin.settings.disableBlockSelectorOnMobile = changed;\n\t\t\tthis.plugin.saveSettings();\n\t\t});\n\t}\n}\n"]}
{"filename": "src/settings/block/index.ts", "chunked_list": ["import ReadingViewEnhancer from \"src/main\";\nimport BlockColorSetting from \"./block-color\";\nimport EnableBlockSelectorSetting from \"./block-selector\";\nimport DisableBlockSelectorOnMobileSetting from \"./block-selector-mobile\";\n\n/**\n * Registers settings components related to block selector.\n */\nexport default class BlockSelectorSettings {\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tcontainerEl.createEl(\"h2\", { text: \"Block Selector\" });\n\t\tnew BlockColorSetting(containerEl, plugin);\n\t\tnew EnableBlockSelectorSetting(containerEl, plugin);\n\t\tnew DisableBlockSelectorOnMobileSetting(containerEl, plugin);\n\t}\n}\n", "export default class BlockSelectorSettings {\n\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\tcontainerEl.createEl(\"h2\", { text: \"Block Selector\" });\n\t\tnew BlockColorSetting(containerEl, plugin);\n\t\tnew EnableBlockSelectorSetting(containerEl, plugin);\n\t\tnew DisableBlockSelectorOnMobileSetting(containerEl, plugin);\n\t}\n}\n"]}
{"filename": "src/block-selector/selection-handler.ts", "chunked_list": ["import { BLOCK_ATTR, COLLAPSE_INDICATORS, SELECTED_BLOCK } from \"../constants\";\nimport {\n\tfindNextBlock,\n\tfindPreviousBlock,\n\tisBottomInView,\n\tisTopInView,\n\tscrollBottomIntoView,\n\tscrollTopIntoView,\n} from \"./selection-util\";\n", "} from \"./selection-util\";\n\n/**\n * Handle block selection.\n * This class is used by BlockSelector.\n */\nexport default class SelectionHandler {\n\tselectedBlock: HTMLElement | null;\n\n\tconstructor() {\n\t\tthis.selectedBlock = null;\n\t}\n\n\t/**\n\t * Select block element\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tselect(block: HTMLElement) {\n\t\tblock.focus();\n\t\tblock.addClass(SELECTED_BLOCK);\n\t\tthis.selectedBlock = block;\n\t}\n\n\t/**\n\t * Unselect block element.\n\t * If there is no selected block, do nothing.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tunselect() {", "\t\tif (this.selectedBlock) {\n\t\t\tthis.selectedBlock.removeClass(SELECTED_BLOCK);\n\t\t\tthis.selectedBlock.blur();\n\t\t\tthis.selectedBlock = null;\n\t\t}\n\t}\n\n\t/**\n\t * Trigger 'select' on clicked block element.\n\t *\n\t * @param e {MouseEvent} Mouse event\n\t */\n\tonBlockClick(e: MouseEvent) {\n\t\tconst target = e.target as HTMLElement;\n\t\tconst block = target.closest(`[${BLOCK_ATTR}=true]`);", "\t\tif (block instanceof HTMLElement) {\n\t\t\tthis.select(block);\n\t\t}\n\t}\n\n\t/**\n\t * On keydown, navigate between blocks or fold/unfold blocks.\n\t *\n\t * - `ArrowDown`: Select next block\n\t * - `ArrowUp`: Select previous block\n\t * - `ArrowLeft` & `ArrowRight`: Fold/Unfold block\n\t *\n\t * If selected block is too long,\n\t * `ArrowDown` and `ArrowUp` scrolls to see the element's bottom or top.\n\t * This is for loading adjacent blocks which are not in the DOM tree.\n\t *\n\t * @param e {KeyboardEvent} Keyboard event\n\t * @param scrollable {HTMLElement} Scrollable parent element\n\t */\n\tonKeyDown(e: KeyboardEvent) {\n\t\tconst block = e.target as HTMLElement;\n", "\t\tif (e.key === \"ArrowDown\") {\n\t\t\te.preventDefault();\n\t\t\tthis.selectNextBlockOrScroll(block);\n\t\t} else if (e.key === \"ArrowUp\") {\n\t\t\te.preventDefault();\n\t\t\tthis.selectPreviousBlockOrScroll(block);\n\t\t} else if (e.key === \"ArrowRight\" || e.key === \"ArrowLeft\") {\n\t\t\te.preventDefault();\n\t\t\tthis.toggleFold(block);\n\t\t} else if (e.key === \"Escape\") {\n\t\t\tthis.unselect();\n\t\t}\n\t}\n\n\t/**\n\t * Select next block or scroll to see the block's bottom.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tprivate selectNextBlockOrScroll(block: HTMLElement) {", "\t\t} else if (e.key === \"Escape\") {\n\t\t\tthis.unselect();\n\t\t}\n\t}\n\n\t/**\n\t * Select next block or scroll to see the block's bottom.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tprivate selectNextBlockOrScroll(block: HTMLElement) {", "\t\tif (!isBottomInView(block)) {\n\t\t\tscrollBottomIntoView(block);\n\t\t} else {\n\t\t\tconst next = findNextBlock(block);\n\t\t\tif (next) this.select(next as HTMLElement);\n\t\t}\n\t}\n\n\t/**\n\t * Select previous block or scroll to see the block's top.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tprivate selectPreviousBlockOrScroll(block: HTMLElement) {", "\t\tif (!isTopInView(block)) {\n\t\t\tscrollTopIntoView(block);\n\t\t} else {\n\t\t\tconst prev = findPreviousBlock(block);\n\t\t\tif (prev) this.select(prev as HTMLElement);\n\t\t}\n\t}\n\n\t/**\n\t * Select top block in the view\n\t *\n\t * @param viewContainer {HTMLElement} View container element\n\t */\n\tselectTopBlockInTheView(viewContainer: HTMLElement) {\n\t\tconst blocks = viewContainer.querySelectorAll(`[${BLOCK_ATTR}=true]`);\n\n\t\t// If there is no block, do nothing", "\t\tif (blocks.length === 0) return;\n\n\t\t// Get the index of the topmost block in the view\n\t\tlet topIndex = -1;\n\t\tfor (let i = 0; i < blocks.length; i++) {\n\t\t\ttopIndex = i;\n\n\t\t\tconst rect = blocks[i].getBoundingClientRect();\n\t\t\tif (rect.bottom > 120) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst topBlock = blocks[topIndex];\n\t\tthis.select(topBlock as HTMLElement);\n\t}\n\n\t/**\n\t * Fold/Unfold block.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tprivate toggleFold(block: HTMLElement) {\n\t\tconst collapseIndicator = block.querySelector(\n\t\t\tCOLLAPSE_INDICATORS.join(\",\")\n\t\t) as HTMLElement;", "\t\t\tif (rect.bottom > 120) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst topBlock = blocks[topIndex];\n\t\tthis.select(topBlock as HTMLElement);\n\t}\n\n\t/**\n\t * Fold/Unfold block.\n\t *\n\t * @param block {HTMLElement} Block element\n\t */\n\tprivate toggleFold(block: HTMLElement) {\n\t\tconst collapseIndicator = block.querySelector(\n\t\t\tCOLLAPSE_INDICATORS.join(\",\")\n\t\t) as HTMLElement;", "\t\tif (collapseIndicator) {\n\t\t\tcollapseIndicator.click();\n\t\t}\n\t}\n}\n"]}
{"filename": "src/block-selector/index.ts", "chunked_list": ["import { MarkdownPostProcessorContext, Platform } from \"obsidian\";\n\nimport ReadingViewEnhancer from \"src/main\";\nimport SelectionHandler from \"./selection-handler\";\nimport { BLOCKS, BLOCK_ATTR, BLOCK_SELECTOR, FRONTMATTER } from \"../constants\";\n\n/**\n * BlockSelector enables to navigate between blocks and fold/unfold blocks.\n *\n * Block elements are elements that are having block level elements.", " *\n * Block elements are elements that are having block level elements.\n * For example, a paragraph is a block element.\n *\n * You can select a block by clicking on it and then use arrow keys to navigate between blocks.\n * For selected block, the background color will be changed.\n * You can also use `ArrowLeft` and `ArrowRight` to fold/unfold blocks.\n * Foldable blocks are having `collapse-indicator` or `callout-fold` class.\n */\nexport default class BlockSelector {\n\tplugin: ReadingViewEnhancer;\n\tselectionHandler: SelectionHandler;\n\tselectedBlock: HTMLElement | null;\n\n\t/**\n\t * Initialize BlockSelector.\n\t * Register markdown post processor to blockify some elements.\n\t *\n\t * @param plugin {ReadingViewEnhancer} Plugin instance\n\t */\n\tconstructor(plugin: ReadingViewEnhancer) {\n\t\tthis.plugin = plugin;\n\t\tthis.selectionHandler = new SelectionHandler();\n\t}\n\n\t/**\n\t * Activate BlockSelector\n\t */\n\tactivate() {\n\t\tthis.plugin.registerMarkdownPostProcessor(this.blockify.bind(this));\n\t}\n\n\t/**\n\t * Select top block in the view\n\t *\n\t * @param viewContainer {HTMLElement} View container element\n\t */\n\tselectTopBlockInTheView(viewContainer: HTMLElement) {\n\t\tthis.selectionHandler.selectTopBlockInTheView(viewContainer);\n\t}\n\n\t/**\n\t * Blockify some elements.\n\t * If container is not initialized, initialize it.\n\t * Transform some elements to block elements.\n\t */\n\tprivate blockify(\n\t\telement: HTMLElement,\n\t\tcontext: MarkdownPostProcessorContext\n\t) {\n\t\t// If block selector is disabled, do nothing", " */\nexport default class BlockSelector {\n\tplugin: ReadingViewEnhancer;\n\tselectionHandler: SelectionHandler;\n\tselectedBlock: HTMLElement | null;\n\n\t/**\n\t * Initialize BlockSelector.\n\t * Register markdown post processor to blockify some elements.\n\t *\n\t * @param plugin {ReadingViewEnhancer} Plugin instance\n\t */\n\tconstructor(plugin: ReadingViewEnhancer) {\n\t\tthis.plugin = plugin;\n\t\tthis.selectionHandler = new SelectionHandler();\n\t}\n\n\t/**\n\t * Activate BlockSelector\n\t */\n\tactivate() {\n\t\tthis.plugin.registerMarkdownPostProcessor(this.blockify.bind(this));\n\t}\n\n\t/**\n\t * Select top block in the view\n\t *\n\t * @param viewContainer {HTMLElement} View container element\n\t */\n\tselectTopBlockInTheView(viewContainer: HTMLElement) {\n\t\tthis.selectionHandler.selectTopBlockInTheView(viewContainer);\n\t}\n\n\t/**\n\t * Blockify some elements.\n\t * If container is not initialized, initialize it.\n\t * Transform some elements to block elements.\n\t */\n\tprivate blockify(\n\t\telement: HTMLElement,\n\t\tcontext: MarkdownPostProcessorContext\n\t) {\n\t\t// If block selector is disabled, do nothing", "\t\tif (!this.plugin.settings.enableBlockSelector) return;\n\n\t\t// If it's mobile but block selector is disabled on mobile, do nothing\n\t\tif (\n\t\t\t(Platform.isMobile || Platform.isMobileApp) &&\n\t\t\tthis.plugin.settings.disableBlockSelectorOnMobile\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// @ts-ignore\n\t\tconst container = context?.containerEl;", "\t\tif (this.isContainerNotInitialized(container)) {\n\t\t\tthis.initializeContainer(container);\n\t\t}\n\n\t\tthis.elementsToBlocks(element);\n\t}\n\n\t/**\n\t * Check if container is initialized.\n\t *\n\t * @param container {MarkdownPostProcessorContext.containerEl} Container element\n\t * @returns {boolean} True if container is initialized\n\t */\n\tprivate isContainerNotInitialized(container: HTMLElement) {\n\t\treturn (\n\t\t\tcontainer instanceof HTMLElement && !container.hasClass(BLOCK_SELECTOR)\n\t\t);\n\t}\n\n\t/**\n\t * Initialize container.\n\t * Add some event listeners to container.\n\t *\n\t * @param container {MarkdownPostProcessorContext.containerEl} Container element\n\t */\n\tprivate initializeContainer(container: HTMLElement) {\n\t\t// Mark container as initialized\n\t\tcontainer.addClass(BLOCK_SELECTOR);\n\n\t\t// On click, select block element\n\t\tcontainer.addEventListener(\"click\", (e) =>\n\t\t\tthis.selectionHandler.onBlockClick(e)\n\t\t);\n\n\t\t// On focusout, unselect block element\n\t\tcontainer.addEventListener(\"focusout\", () =>\n\t\t\tthis.selectionHandler.unselect()\n\t\t);\n\n\t\t// On keydown, navigate between blocks or fold/unfold blocks\n\t\tcontainer.addEventListener(\"keydown\", (e) =>\n\t\t\tthis.selectionHandler.onKeyDown(e)\n\t\t);\n\t}\n\n\t/**\n\t * Set `data-rve-block` attribute to block elements.\n\t *\n\t * @param element {HTMLElement} Element to start searching\n\t */\n\tprivate elementsToBlocks(element: HTMLElement) {\n\t\tconst elements = element.querySelectorAll(BLOCKS.join(\", \"));\n\t\telements.forEach((el) => {", "\t\t\tif (el.hasClass(FRONTMATTER)) return;\n\t\t\tel.setAttribute(BLOCK_ATTR, \"true\");\n\t\t\tel.setAttribute(\"tabindex\", \"-1\");\n\t\t});\n\t}\n}\n"]}
{"filename": "src/block-selector/selection-util.ts", "chunked_list": ["import { BLOCK_ATTR, IS_COLLAPSED, MARKDOWN_PREVIEW_VIEW } from \"../constants\";\n\nexport const isBottomInView = (block: HTMLElement) => {\n\tconst rect = block.getBoundingClientRect();\n\treturn rect.bottom <= window.innerHeight;\n};\n\nexport const scrollBottomIntoView = (block: HTMLElement) => {\n\tconst rect = block.getBoundingClientRect();\n\tconst scrollable = getScrollParent(block);", "\tconst rect = block.getBoundingClientRect();\n\tconst scrollable = getScrollParent(block);\n\tscrollable?.scrollBy({\n\t\tbehavior: \"auto\",\n\t\ttop: rect.bottom - scrollable.clientHeight + 200,\n\t});\n};\n\nexport const isTopInView = (block: HTMLElement) => {\n\tconst rect = block.getBoundingClientRect();", "export const isTopInView = (block: HTMLElement) => {\n\tconst rect = block.getBoundingClientRect();\n\treturn rect.top >= 0;\n};\n\nexport const scrollTopIntoView = (block: HTMLElement) => {\n\tconst rect = block.getBoundingClientRect();\n\tconst scrollable = getScrollParent(block);\n\tscrollable?.scrollBy({\n\t\tbehavior: \"auto\",", "\tscrollable?.scrollBy({\n\t\tbehavior: \"auto\",\n\t\ttop: rect.top - 200,\n\t});\n};\n\n/**\n * Find next block element to select.\n * Return null if there is no next block element.\n *", " * Return null if there is no next block element.\n *\n * @param currentElement {HTMLElement} Current element to start searching\n * @returns {HTMLElement | null} Next block element\n */\nexport const findNextBlock = (\n\tcurrentElement: HTMLElement\n): HTMLElement | null => {\n\tlet nextBlock = null;\n", "\tlet nextBlock = null;\n\n\t// Start by checking if there's a block element inside the current element\n\tif (!isCollapsed(currentElement)) {\n\t\tconst children = currentElement.children;\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tnextBlock = findBlock(children[i] as HTMLElement);\n\t\t\tif (nextBlock) return nextBlock;\n\t\t}\n\t}\n\n\t// Check next siblings of current element\n\tlet nextSibling = currentElement.nextElementSibling;", "\twhile (nextSibling) {\n\t\tnextBlock = findBlock(nextSibling as HTMLElement);\n\t\tif (nextBlock) return nextBlock;\n\n\t\tnextSibling = nextSibling.nextElementSibling;\n\t}\n\n\t// Check next siblings of parent block element\n\tlet parent = currentElement.parentElement;\n\twhile (parent && !parent.hasClass(MARKDOWN_PREVIEW_VIEW)) {\n\t\tlet parentSibling = parent.nextElementSibling;", "\twhile (parent && !parent.hasClass(MARKDOWN_PREVIEW_VIEW)) {\n\t\tlet parentSibling = parent.nextElementSibling;\n\t\twhile (parentSibling) {\n\t\t\tnextBlock = findBlock(parentSibling as HTMLElement);\n\t\t\tif (nextBlock) return nextBlock;\n\n\t\t\tparentSibling = parentSibling.nextElementSibling;\n\t\t}\n\t\tparent = parent.parentElement;\n\t}\n\n\t// If no block element found, return null\n\treturn null;\n};\n\n/**\n * Find previous block element to select.\n * Return null if there is no previous block element.\n *\n * @param currentElement {HTMLElement} Current element to start searching\n * @returns {HTMLElement | null} Previous block element\n */\nexport const findPreviousBlock = (\n\tcurrentElement: HTMLElement\n): HTMLElement | null => {\n\t// Check previous siblings of current element\n\tlet prevSibling = currentElement.previousElementSibling;", "\twhile (prevSibling) {\n\t\tconst prevBlock = findLastBlock(prevSibling as HTMLElement);\n\t\tif (prevBlock) return prevBlock;\n\n\t\tprevSibling = prevSibling.previousElementSibling;\n\t}\n\n\t// Check previous siblings of parent block element\n\tlet parent = currentElement.parentElement;\n\twhile (parent && !parent.classList.contains(MARKDOWN_PREVIEW_VIEW)) {\n\t\t// Check ancestors of current element first", "\twhile (parent && !parent.classList.contains(MARKDOWN_PREVIEW_VIEW)) {\n\t\t// Check ancestors of current element first\n\t\tif (isBlock(parent)) return parent;\n\n\t\tlet parentSibling = parent.previousElementSibling;\n\t\twhile (parentSibling) {\n\t\t\tconst prevBlock = findLastBlock(parentSibling as HTMLElement);\n\t\t\tif (prevBlock) return prevBlock;\n\n\t\t\tparentSibling = parentSibling.previousElementSibling;\n\t\t}\n\t\tparent = parent.parentElement;\n\t}\n\n\t// If no block element found, return null\n\treturn null;\n};\n\n/**\n * Check if the given element is collapsed\n *\n * @param element {HTMLElement} Element to check\n * @returns {boolean} True if the element is collapsed\n */\nconst isCollapsed = (element: HTMLElement) => {\n\treturn element.hasClass(IS_COLLAPSED);\n};\n\n/**\n * Find first block element inside the given element\n *\n * @param element {HTMLElement} Element to search\n * @returns {HTMLElement | null} First block element\n */\nconst findBlock = (element: HTMLElement): HTMLElement | null => {", "\tif (isBlock(element)) {\n\t\treturn element;\n\t}\n\n\tlet block = null;\n\tconst childElements = element.children;\n\tfor (let i = 0; i < childElements.length; i++) {\n\t\tblock = findBlock(childElements[i] as HTMLElement);\n\t\tif (block) return block;\n\t}\n\n\treturn null;\n};\n\n/**\n * Find last block element inside the given element\n *\n * @param element {HTMLElement} Element to search\n * @returns {HTMLElement | null} Last block element\n */\nconst findLastBlock = (element: HTMLElement): HTMLElement | null => {", "\t\tif (block) return block;\n\t}\n\n\treturn null;\n};\n\n/**\n * Find last block element inside the given element\n *\n * @param element {HTMLElement} Element to search\n * @returns {HTMLElement | null} Last block element\n */\nconst findLastBlock = (element: HTMLElement): HTMLElement | null => {", "\tif (isCollapsed(element) && isBlock(element)) return element;\n\n\tlet block = null;\n\tconst childElements = element.children;\n\tfor (let i = childElements.length - 1; i >= 0; i--) {\n\t\tblock = findLastBlock(childElements[i] as HTMLElement);\n\t\tif (block) return block;\n\t}\n\n\tif (isBlock(element)) return element;\n\telse return null;\n};\n\n/**\n * Check if the given element is a block element\n *\n * @param element {HTMLElement} Element to check\n * @returns {boolean} True if the element is a block element\n */\nconst isBlock = (element: HTMLElement) => {\n\treturn element.getAttribute(BLOCK_ATTR) === \"true\";\n};\n\n/**\n * Return the scrollable parent element of the given element\n *\n * @param node {HTMLElement} Element to start searching\n * @returns {HTMLElement | null} Scrollable parent element\n */\nconst getScrollParent = (node: HTMLElement): HTMLElement | null => {", "\tif (isBlock(element)) return element;\n\telse return null;\n};\n\n/**\n * Check if the given element is a block element\n *\n * @param element {HTMLElement} Element to check\n * @returns {boolean} True if the element is a block element\n */\nconst isBlock = (element: HTMLElement) => {\n\treturn element.getAttribute(BLOCK_ATTR) === \"true\";\n};\n\n/**\n * Return the scrollable parent element of the given element\n *\n * @param node {HTMLElement} Element to start searching\n * @returns {HTMLElement | null} Scrollable parent element\n */\nconst getScrollParent = (node: HTMLElement): HTMLElement | null => {", "\tif (node == null) return null;\n\n\tif (node.scrollHeight > node.clientHeight) {\n\t\treturn node;\n\t} else {\n\t\treturn getScrollParent(node.parentNode as HTMLElement);\n\t}\n};\n"]}
