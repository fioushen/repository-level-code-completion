{"filename": "__mocks__/obsidian.ts", "chunked_list": ["// This file is required to exclude obsidian package dependency from jest unit tests\nimport moment from \"moment\";\n\nexport { moment as moment };\n"]}
{"filename": "__mocks__/nanoid.ts", "chunked_list": ["export function customAlphabet(alphabet: string, defaultSize?: number): (size?: number) => string {\n    return () => \"\"\n}\n"]}
{"filename": "src/path.ts", "chunked_list": ["export interface ParsedPath {\n  /**\n   * parent directory name (if exist)\n   */\n  dir: string;\n  /**\n   * name with extension\n   */\n  name: string;\n  /**\n   *  name without extension\n   */\n  basename: string;\n  /**\n   * extension\n   */\n  extension: string;\n}\n\nconst lastSeparatorRegex = /[/\\\\](?!.*[/\\\\])/g;\nconst lastPeriodRegex = /\\.(?!.*\\.)/g;\n", "export function parsePath(path: string): ParsedPath {\n  const pathComponent = path.split(lastSeparatorRegex);\n  let dir = \"\";\n  let name;\n\n  if (pathComponent.length == 2) [dir, name] = pathComponent;\n  else [name] = pathComponent;\n\n  const nameComponent = name.split(lastPeriodRegex);\n  const basename = nameComponent[0];\n  let extension = \"\";", "  if (nameComponent.length > 1) extension = nameComponent[1];\n\n  return {\n    dir,\n    name,\n    basename,\n    extension,\n  };\n}\n"]}
{"filename": "src/obsidian-ex.d.ts", "chunked_list": ["import { EditorState } from \"@codemirror/state\";\nimport \"obsidian\";\n\ndeclare module \"obsidian\" {\n  enum PopoverState {\n    Showing,\n    Shown,\n    Hiding,\n    Hidden,\n  }\n", "  interface HoverParent {\n    type?: string;\n  }\n  interface HoverPopover {\n    parent: HoverParent | null;\n    targetEl: HTMLElement;\n    hoverEl: HTMLElement;\n    position(pos?: MousePos): void;\n    hide(): void;\n    show(): void;\n    shouldShowSelf(): boolean;\n    timer: number;\n    waitTime: number;\n    shouldShow(): boolean;\n    transition(): void;\n  }\n", "  interface MousePos {\n    x: number;\n    y: number;\n  }\n  interface PagePreviewPlugin {\n    onLinkHover(\n      parent: HoverParent,\n      tergetEl: HTMLElement,\n      link: string,\n      sourcePath: string,\n      state: EditorState\n    );\n  }", "  interface InternalPlugins {\n    \"page-preview\": PagePreviewPlugin;\n  }\n\n  interface App {\n    internalPlugins: {\n      getEnabledPluginById<T extends keyof InternalPlugins>(id: T): InternalPlugins[T] | undefined;\n    };\n  }\n  interface MarkdownRenderer {\n    renderer: {\n      set(markdown: string): void;\n    };\n  }", "  interface MarkdownRenderer {\n    renderer: {\n      set(markdown: string): void;\n    };\n  }\n  interface MarkdownRendererConstructorType {\n    new (app: App, container: HTMLElement, queed: boolean): MarkdownRenderer;\n  }\n\n  interface Workspace {\n    registerEditorExtension(extension: Extension): void;\n    unregisterEditorExtension(extension: Extension): void;\n  }\n", "  interface Workspace {\n    registerEditorExtension(extension: Extension): void;\n    unregisterEditorExtension(extension: Extension): void;\n  }\n\n  interface PopoverSuggest<T> {\n    suggestEl: HTMLDivElement;\n    suggestions: {\n      setSuggestions(list: T[]);\n    };\n    setAutoDestroy(el: HTMLElement);\n    reposition({ left: number, right: number, top: number, bottom: number });\n  }\n", "  interface ClickableToken {\n    type: string;\n    text: string;\n    start: EditorPosition;\n    end: EditorPosition;\n  }\n\n  interface Editor {\n    getClickableTokenAt?: (pos: EditorPosition) => ClickableToken | undefined;\n  }\n}\n"]}
{"filename": "src/view.ts", "chunked_list": ["import { ItemView, WorkspaceLeaf } from \"obsidian\";\n\nimport Component from \"./components/MainComponent.svelte\";\nimport DendronTreePlugin from \"./main\";\nimport * as store from \"./store\";\nimport { dendronActivityBarName } from \"./icons\";\n\nexport const VIEW_TYPE_DENDRON = \"dendron-tree-view\";\n\nexport class DendronView extends ItemView {\n  component: Component;\n  icon = dendronActivityBarName;\n\n  constructor(leaf: WorkspaceLeaf, private plugin: DendronTreePlugin) {\n    super(leaf);\n  }\n\n  getViewType() {\n    return VIEW_TYPE_DENDRON;\n  }\n\n  getDisplayText() {\n    return \"Dendron Tree\";\n  }\n\n  async onOpen() {\n    store.plugin.set(this.plugin);\n    this.component = new Component({\n      target: this.contentEl,\n    });\n  }\n\n  async onClose() {\n    this.component.$destroy();\n  }\n}\n", "\nexport class DendronView extends ItemView {\n  component: Component;\n  icon = dendronActivityBarName;\n\n  constructor(leaf: WorkspaceLeaf, private plugin: DendronTreePlugin) {\n    super(leaf);\n  }\n\n  getViewType() {\n    return VIEW_TYPE_DENDRON;\n  }\n\n  getDisplayText() {\n    return \"Dendron Tree\";\n  }\n\n  async onOpen() {\n    store.plugin.set(this.plugin);\n    this.component = new Component({\n      target: this.contentEl,\n    });\n  }\n\n  async onClose() {\n    this.component.$destroy();\n  }\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { Menu, Plugin, TAbstractFile, TFile, addIcon } from \"obsidian\";\nimport { DendronView, VIEW_TYPE_DENDRON } from \"./view\";\nimport { activeFile, dendronVaultList } from \"./store\";\nimport { LookupModal } from \"./modal/lookup\";\nimport { dendronActivityBarIcon, dendronActivityBarName } from \"./icons\";\nimport { DEFAULT_SETTINGS, DendronTreePluginSettings, DendronTreeSettingTab } from \"./settings\";\nimport { parsePath } from \"./path\";\nimport { DendronWorkspace } from \"./engine/workspace\";\nimport { CustomResolver } from \"./custom-resolver\";\n\nexport default class DendronTreePlugin extends Plugin {\n  settings: DendronTreePluginSettings;\n  workspace: DendronWorkspace = new DendronWorkspace(this.app);\n  customResolver?: CustomResolver;\n\n  async onload() {\n    await this.loadSettings();\n    await this.migrateSettings();\n\n    addIcon(dendronActivityBarName, dendronActivityBarIcon);\n\n    this.addCommand({\n      id: \"dendron-lookup\",\n      name: \"Lookup Note\",\n      callback: () => {\n        new LookupModal(this.app, this.workspace).open();\n      },\n    });\n\n    this.addSettingTab(new DendronTreeSettingTab(this.app, this));\n\n    this.registerView(VIEW_TYPE_DENDRON, (leaf) => new DendronView(leaf, this));\n\n    this.addRibbonIcon(dendronActivityBarName, \"Open Dendron Tree\", () => {\n      this.activateView();\n    });\n\n    this.app.workspace.onLayoutReady(() => {\n      this.onRootFolderChanged();\n\n      this.registerEvent(this.app.vault.on(\"create\", this.onCreateFile));\n      this.registerEvent(this.app.vault.on(\"delete\", this.onDeleteFile));\n      this.registerEvent(this.app.vault.on(\"rename\", this.onRenameFile));\n      this.registerEvent(this.app.metadataCache.on(\"resolve\", this.onResolveMetadata));\n      this.registerEvent(this.app.workspace.on(\"file-open\", this.onOpenFile, this));\n      this.registerEvent(this.app.workspace.on(\"file-menu\", this.onFileMenu));\n    });\n\n    this.configureCustomResolver();\n  }\n\n  async migrateSettings() {", "import { CustomResolver } from \"./custom-resolver\";\n\nexport default class DendronTreePlugin extends Plugin {\n  settings: DendronTreePluginSettings;\n  workspace: DendronWorkspace = new DendronWorkspace(this.app);\n  customResolver?: CustomResolver;\n\n  async onload() {\n    await this.loadSettings();\n    await this.migrateSettings();\n\n    addIcon(dendronActivityBarName, dendronActivityBarIcon);\n\n    this.addCommand({\n      id: \"dendron-lookup\",\n      name: \"Lookup Note\",\n      callback: () => {\n        new LookupModal(this.app, this.workspace).open();\n      },\n    });\n\n    this.addSettingTab(new DendronTreeSettingTab(this.app, this));\n\n    this.registerView(VIEW_TYPE_DENDRON, (leaf) => new DendronView(leaf, this));\n\n    this.addRibbonIcon(dendronActivityBarName, \"Open Dendron Tree\", () => {\n      this.activateView();\n    });\n\n    this.app.workspace.onLayoutReady(() => {\n      this.onRootFolderChanged();\n\n      this.registerEvent(this.app.vault.on(\"create\", this.onCreateFile));\n      this.registerEvent(this.app.vault.on(\"delete\", this.onDeleteFile));\n      this.registerEvent(this.app.vault.on(\"rename\", this.onRenameFile));\n      this.registerEvent(this.app.metadataCache.on(\"resolve\", this.onResolveMetadata));\n      this.registerEvent(this.app.workspace.on(\"file-open\", this.onOpenFile, this));\n      this.registerEvent(this.app.workspace.on(\"file-menu\", this.onFileMenu));\n    });\n\n    this.configureCustomResolver();\n  }\n\n  async migrateSettings() {", "    function pathToVaultConfig(path: string) {\n      const { name } = parsePath(path);\n      if (name.length === 0)\n        return {\n          name: \"root\",\n          path: \"/\",\n        };\n      let processed = path;\n      if (processed.endsWith(\"/\")) processed = processed.slice(0, -1);\n      if (processed.startsWith(\"/\") && processed.length > 1) processed = processed.slice(1);\n      return {\n        name,\n        path: processed,\n      };\n    }\n", "      if (processed.endsWith(\"/\")) processed = processed.slice(0, -1);\n      if (processed.startsWith(\"/\") && processed.length > 1) processed = processed.slice(1);\n      return {\n        name,\n        path: processed,\n      };\n    }\n\n    if (this.settings.vaultPath) {\n      this.settings.vaultList = [pathToVaultConfig(this.settings.vaultPath)];\n      this.settings.vaultPath = undefined;\n      await this.saveSettings();\n    }", "    if (this.settings.vaultPath) {\n      this.settings.vaultList = [pathToVaultConfig(this.settings.vaultPath)];\n      this.settings.vaultPath = undefined;\n      await this.saveSettings();\n    }\n    if (this.settings.vaultList.length > 0 && typeof this.settings.vaultList[0] === \"string\") {\n      this.settings.vaultList = (this.settings.vaultList as unknown as string[]).map((path) =>\n        pathToVaultConfig(path)\n      );\n      await this.saveSettings();\n    }\n  }\n\n  onunload() {}\n\n  onRootFolderChanged() {\n    this.workspace.changeVault(this.settings.vaultList);\n    this.updateNoteStore();\n  }\n\n  configureCustomResolver() {", "    if (this.settings.customResolver && !this.customResolver) {\n      this.customResolver = new CustomResolver(this, this.workspace);\n      this.addChild(this.customResolver);\n    } else if (!this.settings.customResolver && this.customResolver) {\n      this.removeChild(this.customResolver);\n      this.customResolver = undefined;\n    }\n  }\n\n  updateNoteStore() {\n    dendronVaultList.set(this.workspace.vaultList);\n  }\n\n  onCreateFile = async (file: TAbstractFile) => {\n    const vault = this.workspace.findVaultByParent(file.parent);", "    if (vault && vault.onFileCreated(file)) {\n      if (this.settings.autoGenerateFrontmatter && file instanceof TFile && file.stat.size === 0)\n        await vault.generateFronmatter(file);\n      this.updateNoteStore();\n    }\n  };\n\n  onDeleteFile = (file: TAbstractFile) => {\n    // file.parent is null when file is deleted\n    const parsed = parsePath(file.path);\n    const vault = this.workspace.findVaultByParentPath(parsed.dir);", "    if (vault && vault.onFileDeleted(parsed)) {\n      this.updateNoteStore();\n    }\n  };\n\n  onRenameFile = (file: TAbstractFile, oldPath: string) => {\n    const oldParsed = parsePath(oldPath);\n    const oldVault = this.workspace.findVaultByParentPath(oldParsed.dir);\n    let update = false;\n    if (oldVault) {\n      update = oldVault.onFileDeleted(oldParsed);\n    }\n\n    const newVault = this.workspace.findVaultByParent(file.parent);", "    if (oldVault) {\n      update = oldVault.onFileDeleted(oldParsed);\n    }\n\n    const newVault = this.workspace.findVaultByParent(file.parent);\n    if (newVault) {\n      update = newVault.onFileCreated(file) || update;\n    }\n    if (update) this.updateNoteStore();\n  };\n\n  onOpenFile(file: TFile | null) {\n    activeFile.set(file);", "    if (update) this.updateNoteStore();\n  };\n\n  onOpenFile(file: TFile | null) {\n    activeFile.set(file);\n    if (file && this.settings.autoReveal) this.revealFile(file);\n  }\n\n  onFileMenu = (menu: Menu, file: TAbstractFile) => {\n    if (!(file instanceof TFile)) return;\n\n    menu.addItem((item) => {\n      item\n        .setIcon(dendronActivityBarName)\n        .setTitle(\"Reveal in Dendron Tree\")\n        .onClick(() => this.revealFile(file));\n    });\n  };\n\n  onResolveMetadata = (file: TFile) => {\n    const vault = this.workspace.findVaultByParent(file.parent);", "    if (!(file instanceof TFile)) return;\n\n    menu.addItem((item) => {\n      item\n        .setIcon(dendronActivityBarName)\n        .setTitle(\"Reveal in Dendron Tree\")\n        .onClick(() => this.revealFile(file));\n    });\n  };\n\n  onResolveMetadata = (file: TFile) => {\n    const vault = this.workspace.findVaultByParent(file.parent);", "    if (vault && vault.onMetadataChanged(file)) {\n      this.updateNoteStore();\n    }\n  };\n\n  revealFile(file: TFile) {\n    const vault = this.workspace.findVaultByParent(file.parent);\n    if (!vault) return;\n    const note = vault.tree.getFromFileName(file.basename);\n    if (!note) return;\n    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON)) {", "    if (!note) return;\n    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON)) {\n      if (!(leaf.view instanceof DendronView)) continue;\n      leaf.view.component.focusTo(vault, note);\n    }\n  }\n\n  async activateView() {\n    const leafs = this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON);\n    if (leafs.length == 0) {\n      const leaf = this.app.workspace.getLeftLeaf(false);\n      await leaf.setViewState({\n        type: VIEW_TYPE_DENDRON,\n        active: true,\n      });\n      this.app.workspace.revealLeaf(leaf);\n    } else {\n      leafs.forEach((leaf) => this.app.workspace.revealLeaf(leaf));\n    }\n  }\n\n  async loadSettings() {\n    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n  }\n\n  async saveSettings() {\n    await this.saveData(this.settings);\n  }\n}\n", "    if (leafs.length == 0) {\n      const leaf = this.app.workspace.getLeftLeaf(false);\n      await leaf.setViewState({\n        type: VIEW_TYPE_DENDRON,\n        active: true,\n      });\n      this.app.workspace.revealLeaf(leaf);\n    } else {\n      leafs.forEach((leaf) => this.app.workspace.revealLeaf(leaf));\n    }\n  }\n\n  async loadSettings() {\n    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n  }\n\n  async saveSettings() {\n    await this.saveData(this.settings);\n  }\n}\n"]}
{"filename": "src/store.ts", "chunked_list": ["import { derived, get, writable } from \"svelte/store\";\nimport type DendronTreePlugin from \"./main\";\nimport { TFile } from \"obsidian\";\nimport { DendronVault } from \"./engine/vault\";\n\nexport const plugin = writable<DendronTreePlugin>();\nexport const getPlugin = () => get(plugin);\n\nexport const activeFile = writable<TFile | null>();\n\nexport const dendronVaultList = writable<DendronVault[]>([]);\nexport const getDendronVaultList = () => get(dendronVaultList);\n\nexport const showVaultPath = derived(dendronVaultList, ($list) => $list.length > 1);\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { App, OpenViewState, TAbstractFile, TFile, Vault } from \"obsidian\";\nimport { customAlphabet as nanoid } from \"nanoid\";\n\nexport function getFolderFile(vault: Vault, path: string) {\n  return path.length === 0 ? vault.getRoot() : vault.getAbstractFileByPath(path);\n}\n\nexport function openFile(\n  app: App,\n  file: TAbstractFile | undefined | null,\n  openState?: OpenViewState\n) {", "  if (!file || !(file instanceof TFile)) return;\n  const leaf = app.workspace.getLeaf();\n  return leaf.openFile(file, openState);\n}\n\nconst alphanumericLowercase = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nexport const generateUUID = nanoid(alphanumericLowercase, 23);\n"]}
{"filename": "src/settings.ts", "chunked_list": ["import { App, Notice, PluginSettingTab, Setting } from \"obsidian\";\nimport DendronTreePlugin from \"./main\";\nimport { VaultConfig } from \"./engine/vault\";\nimport { AddVaultModal } from \"./modal/add-vault\";\n\nexport interface DendronTreePluginSettings {\n  /**\n   * @deprecated use vaultList\n   */\n  vaultPath?: string;\n  vaultList: VaultConfig[];\n  autoGenerateFrontmatter: boolean;\n  autoReveal: boolean;\n  customResolver: boolean;\n}\n\nexport const DEFAULT_SETTINGS: DendronTreePluginSettings = {\n  vaultList: [\n    {\n      name: \"root\",\n      path: \"/\",\n    },\n  ],\n  autoGenerateFrontmatter: true,\n  autoReveal: true,\n  customResolver: false,\n};\n", "export class DendronTreeSettingTab extends PluginSettingTab {\n  plugin: DendronTreePlugin;\n\n  constructor(app: App, plugin: DendronTreePlugin) {\n    super(app, plugin);\n    this.plugin = plugin;\n  }\n\n  display(): void {\n    const { containerEl } = this;\n\n    containerEl.empty();\n\n    containerEl.createEl(\"h2\", { text: \"Dendron Tree Settting\" });\n\n    new Setting(containerEl)\n      .setName(\"Auto Generate Front Matter\")\n      .setDesc(\"Generate front matter for new file even if file is created outside of Dendron tree\")\n      .addToggle((toggle) => {\n        toggle.setValue(this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {\n          this.plugin.settings.autoGenerateFrontmatter = value;\n          await this.plugin.saveSettings();\n        });\n      });\n\n    new Setting(containerEl)\n      .setName(\"Auto Reveal\")\n      .setDesc(\"Automatically reveal active file in Dendron Tree\")\n      .addToggle((toggle) => {\n        toggle.setValue(this.plugin.settings.autoReveal).onChange(async (value) => {\n          this.plugin.settings.autoReveal = value;\n          await this.plugin.saveSettings();\n        });\n      });\n\n    new Setting(containerEl)\n      .setName(\"Custom Resolver\")\n      .setDesc(\n        \"Use custom resolver to resolve ref/embed and link. (Please reopen editor after change this setting)\"\n      )\n      .addToggle((toggle) => {\n        toggle.setValue(this.plugin.settings.customResolver).onChange(async (value) => {\n          this.plugin.settings.customResolver = value;\n          await this.plugin.saveSettings();\n        });\n      });\n\n    new Setting(containerEl).setName(\"Vault List\").setHeading();", "    for (const vault of this.plugin.settings.vaultList) {\n      new Setting(containerEl)\n        .setName(vault.name)\n        .setDesc(`Folder: ${vault.path}`)\n        .addButton((btn) => {\n          btn.setButtonText(\"Remove\").onClick(async () => {\n            this.plugin.settings.vaultList.remove(vault);\n            await this.plugin.saveSettings();\n            this.display();\n          });\n        });\n    }\n    new Setting(containerEl).addButton((btn) => {\n      btn.setButtonText(\"Add Vault\").onClick(() => {\n        new AddVaultModal(this.app, (config) => {\n          const list = this.plugin.settings.vaultList;\n          const nameLowecase = config.name.toLowerCase();", "          if (list.find(({ name }) => name.toLowerCase() === nameLowecase)) {\n            new Notice(\"Vault with same name already exist\");\n            return false;\n          }\n          if (list.find(({ path }) => path === config.path)) {\n            new Notice(\"Vault with same path already exist\");\n            return false;\n          }\n\n          list.push(config);\n          this.plugin.saveSettings().then(() => this.display());\n          return true;\n        }).open();\n      });\n    });\n  }\n  hide() {\n    super.hide();\n    this.plugin.onRootFolderChanged();\n    this.plugin.configureCustomResolver();\n  }\n}\n"]}
{"filename": "src/path.test.ts", "chunked_list": ["import { parsePath } from \"./path\";\n\ndescribe(\"parse path\", () => {\n  it(\"parse path with 2 component\", () => {\n    expect(parsePath(\"abc/ll.md\")).toStrictEqual({\n      dir: \"abc\",\n      name: \"ll.md\",\n      basename: \"ll\",\n      extension: \"md\",\n    });", "      extension: \"md\",\n    });\n  });\n  it(\"parse path with 1 component\", () => {\n    expect(parsePath(\"hugo.md\")).toStrictEqual({\n      dir: \"\",\n      name: \"hugo.md\",\n      basename: \"hugo\",\n      extension: \"md\",\n    });", "      extension: \"md\",\n    });\n  });\n  it(\"parse path with name contain multiple dot\", () => {\n    expect(parsePath(\"baca.buku.md\")).toStrictEqual({\n      dir: \"\",\n      name: \"baca.buku.md\",\n      basename: \"baca.buku\",\n      extension: \"md\",\n    });", "      extension: \"md\",\n    });\n  });\n  it(\"parse path with multiple component\", () => {\n    expect(parsePath(\"baca/buku/dirumah/pacar.md\")).toStrictEqual({\n      dir: \"baca/buku/dirumah\",\n      name: \"pacar.md\",\n      basename: \"pacar\",\n      extension: \"md\",\n    });", "      extension: \"md\",\n    });\n  });\n  it(\"parse windows path\", () => {\n    expect(parsePath(\"abc\\\\ll.md\")).toStrictEqual({\n      dir: \"abc\",\n      name: \"ll.md\",\n      basename: \"ll\",\n      extension: \"md\",\n    });", "      extension: \"md\",\n    });\n  });\n});\n"]}
{"filename": "src/icons.ts", "chunked_list": ["export const dendronActivityBarName = \"dendron-activity-bar\";\nexport const dendronActivityBarIcon = `<path d=\"M51.263 53.512a5.349 5.349 0 0 0-5.349 5.348 5.349 5.349 0 0 0 2.399 4.456c.014-.185.031-.356.031-.595h5.814c0 .221-.014.436-.027.652a5.349 5.349 0 0 0 2.48-4.513 5.349 5.349 0 0 0-5.348-5.348zm-2.95 9.804a5.349 5.349 0 0 0 .201.122 5.349 5.349 0 0 1-.201-.122zm.201.122a5.349 5.349 0 0 0 .4.219 5.349 5.349 0 0 1-.4-.219zm.4.219a5.349 5.349 0 0 0 .177.088 5.349 5.349 0 0 1-.177-.088zm.177.088a5.349 5.349 0 0 0 .562.21 5.349 5.349 0 0 1-.562-.21zm.562.21a5.349 5.349 0 0 0 .187.056 5.349 5.349 0 0 1-.187-.057zm.187.056a5.349 5.349 0 0 0 .603.131 5.349 5.349 0 0 1-.603-.131Zm.603.131a5.349 5.349 0 0 0 .152.02 5.349 5.349 0 0 1-.152-.02Zm.152.02a5.349 5.349 0 0 0 .668.047 5.349 5.349 0 0 1-.668-.047Zm.668.047a5.349 5.349 0 0 0 .669-.048 5.349 5.349 0 0 1-.67.048zm.669-.048a5.349 5.349 0 0 0 .18-.025 5.349 5.349 0 0 1-.18.026zm.18-.025a5.349 5.349 0 0 0 .645-.14 5.349 5.349 0 0 1-.644.14zm2.017-.762a5.349 5.349 0 0 1-.559.305 5.349 5.349 0 0 0 .56-.305zm-.559.305a5.349 5.349 0 0 1-.185.084 5.349 5.349 0 0 0 .185-.084zm-.185.084a5.349 5.349 0 0 1-.561.21 5.349 5.349 0 0 0 .56-.21zm-.561.21a5.349 5.349 0 0 1-.067.022 5.349 5.349 0 0 0 .067-.022zm20.218-8.717c-2.223 0-4.058 1.835-4.058 4.058s1.835 4.058 4.058 4.058c2.222 0 4.058-1.835 4.058-4.058s-1.836-4.058-4.058-4.058zm0 3.14c.526 0 .918.392.918.918a.896.896 0 0 1-.918.919.896.896 0 0 1-.919-.919c0-.526.393-.919.919-.919zM53.154 43.51c-.798 4.917 2.592 9.621 7.51 10.42 4.916.797 9.62-2.593 10.419-7.51.797-4.917-2.593-9.621-7.51-10.419s-9.621 2.593-10.419 7.51zm5.739.932c.294-1.816 1.933-2.997 3.749-2.702 1.815.295 2.996 1.933 2.702 3.749-.295 1.815-1.934 2.996-3.75 2.701-1.815-.294-2.996-1.933-2.701-3.748zM42.46 18.465c-6.727 0-12.244 5.516-12.244 12.244s5.517 12.244 12.244 12.244c6.728 0 12.245-5.516 12.245-12.244S49.188 18.465 42.46 18.465zm0 5.814a6.387 6.387 0 0 1 6.43 6.43 6.387 6.387 0 0 1-6.43 6.43 6.387 6.387 0 0 1-6.43-6.43 6.387 6.387 0 0 1 6.43-6.43zm28.547 38.186v5.116c0 1.432-.194 1.47-.662 1.777a2.75 2.75 0 0 1-.439.22l-.022.01-.064.024c-.276.11-.628.234-1.02.371-.385.136-.817.29-1.283.477l-.01.003-.001.001-14.22 5-.032.013c-1.121.439-3.369 1.019-5.427 2.193-2.058 1.174-4.164 3.413-4.003 6.528l-.003-.105v14.956a50 50 0 0 0 3.71.265 50 50 0 0 0 .36-.026V84.04l-.003-.052c-.072-1.385.555-1.984 1.956-2.783 1.401-.8 3.34-1.33 4.893-1.938l-.067.025 14.231-5.004.045-.018c.905-.367 2.238-.593 3.633-1.51 1.395-.916 2.498-2.82 2.498-5.179v-5.116Zm-3.49 7.995zM39.6 41.453V73.67c-.03.306-.047.617-.047.935h.047v24.023a50 50 0 0 0 7.93.686 50 50 0 0 0 3.047-.218v-5.02l-.002-.053c-.05-1.37.239-1.562.97-2.113.73-.55 1.932-.957 3.326-1.722l-.04.021 4.38-2.317c.76-.38 2.244-.973 3.572-2.394 1.335-1.427 2.236-3.671 2.236-6.417V52.395h-5.814v26.686c0 1.662-.332 2.086-.669 2.447-.337.36-.952.674-1.952 1.178l-.027.013-4.464 2.361-.02.011c-.513.282-2.293.869-4.028 2.176-1.022.77-2.009 1.974-2.631 3.467v-16.94c.078-.574.253-.763.496-1.011.332-.339 1.085-.756 2.205-1.295 1.121-.54 2.617-1.218 3.916-2.65 1.3-1.433 2.127-3.597 2.127-6.117h-5.814c0 .72-.067 1.176-.178 1.5a1.737 1.737 0 0 1-.198.407 2.522 2.522 0 0 1-.244.304c-.349.385-1.051.798-2.128 1.316l-.182.087V41.453Zm11-35.639c5.965 0 11.756 1.163 17.198 3.465a43.866 43.866 0 0 1 14.046 9.477 44.246 44.246 0 0 1 9.477 14.046c2.302 5.442 3.465 11.233 3.465 17.198s-1.163 11.756-3.465 17.198a43.866 43.866 0 0 1-9.477 14.046 44.246 44.246 0 0 1-14.046 9.477c-5.454 2.302-11.233 3.465-17.198 3.465s-11.756-1.163-17.198-3.465a43.866 43.866 0 0 1-14.046-9.477 44.246 44.246 0 0 1-9.477-14.046C7.577 61.756 6.414 55.965 6.414 50s1.163-11.756 3.465-17.198a43.866 43.866 0 0 1 9.477-14.046 44.246 44.246 0 0 1 14.046-9.477A44.073 44.073 0 0 1 50.6 5.814M50.6 0C22.984 0 .6 22.384.6 50s22.384 50 50 50 50-22.384 50-50-22.384-50-50-50z\" fill=\"currentcolor\"/>`;\n"]}
{"filename": "src/modal/lookup.ts", "chunked_list": ["import { App, SuggestModal, getIcon } from \"obsidian\";\nimport { Note } from \"../engine/note\";\nimport { openFile } from \"../utils\";\nimport { DendronVault } from \"../engine/vault\";\nimport { SelectVaultModal } from \"./select-vault\";\nimport { DendronWorkspace } from \"../engine/workspace\";\n\ninterface LookupItem {\n  note: Note;\n  vault: DendronVault;\n}\n", "export class LookupModal extends SuggestModal<LookupItem | null> {\n  constructor(app: App, private workspace: DendronWorkspace, private initialQuery: string = \"\") {\n    super(app);\n  }\n\n  onOpen(): void {\n    super.onOpen();\n    if (this.initialQuery.length > 0) {\n      this.inputEl.value = this.initialQuery;\n      this.inputEl.dispatchEvent(new Event(\"input\"));\n    }\n  }\n\n  getSuggestions(query: string): (LookupItem | null)[] {\n    const queryLowercase = query.toLowerCase();\n    const result: (LookupItem | null)[] = [];\n\n    let foundExact = true;\n", "    for (const vault of this.workspace.vaultList) {\n      let currentFoundExact = false;\n      for (const note of vault.tree.flatten()) {\n        const path = note.getPath();\n        const item: LookupItem = {\n          note,\n          vault,\n        };\n        if (path === queryLowercase) {\n          currentFoundExact = true;\n          result.unshift(item);\n          continue;\n        }", "        if (path === queryLowercase) {\n          currentFoundExact = true;\n          result.unshift(item);\n          continue;\n        }\n        if (\n          note.title.toLowerCase().includes(queryLowercase) ||\n          note.name.includes(queryLowercase) ||\n          path.includes(queryLowercase)\n        )\n          result.push(item);\n      }\n\n      foundExact = foundExact && currentFoundExact;\n    }\n", "    if (!foundExact && queryLowercase.trim().length > 0) result.unshift(null);\n\n    return result;\n  }\n  renderSuggestion(item: LookupItem | null, el: HTMLElement) {\n    el.classList.add(\"mod-complex\");\n    el.createEl(\"div\", { cls: \"suggestion-content\" }, (el) => {\n      el.createEl(\"div\", { text: item?.note.title ?? \"Create New\", cls: \"suggestion-title\" });\n      el.createEl(\"small\", {\n        text: item\n          ? item.note.getPath() +\n            (this.workspace.vaultList.length > 1 ? ` (${item.vault.config.name})` : \"\")\n          : \"Note does not exist\",\n        cls: \"suggestion-content\",\n      });\n    });", "    if (!item || !item.note.file)\n      el.createEl(\"div\", { cls: \"suggestion-aux\" }, (el) => {\n        el.append(getIcon(\"plus\")!);\n      });\n  }\n  async onChooseSuggestion(item: LookupItem | null, evt: MouseEvent | KeyboardEvent) {\n    if (item && item.note.file) {\n      openFile(this.app, item.note.file);\n      return;\n    }\n\n    const path = item ? item.note.getPath() : this.inputEl.value;\n\n    const doCreate = async (vault: DendronVault) => {\n      const file = await vault.createNote(path);\n      return openFile(vault.app, file);\n    };", "    if (item?.vault) {\n      await doCreate(item.vault);\n    } else if (this.workspace.vaultList.length == 1) {\n      await doCreate(this.workspace.vaultList[0]);\n    } else {\n      new SelectVaultModal(this.app, this.workspace, doCreate).open();\n    }\n  }\n}\n"]}
{"filename": "src/modal/add-vault.ts", "chunked_list": ["import { App, Modal, Notice, PopoverSuggest, Setting, TFolder, TextComponent } from \"obsidian\";\nimport { VaultConfig } from \"src/engine/vault\";\n\nclass FolderSuggester extends PopoverSuggest<TFolder> {\n  constructor(\n    public app: App,\n    public inputEl: HTMLInputElement,\n    public onSelected: (folder: TFolder) => void\n  ) {\n    super(app);\n\n    inputEl.addEventListener(\"input\", this.onInputChange);\n    inputEl.addEventListener(\"focus\", this.onInputChange);\n    inputEl.addEventListener(\"blur\", () => this.close());\n    this.suggestEl.on(\"mousedown\", \".suggestion-item\", (e) => e.preventDefault());\n    this.suggestEl.classList.add(\"dendron-folder-suggest\");\n  }\n  onInputChange = () => {\n    const suggestionList = this.getSuggestions(this.inputEl.value);", "    if (suggestionList.length === 0) {\n      this.close();\n      return;\n    }\n    this.suggestions.setSuggestions(suggestionList);\n    this.open();\n    this.setAutoDestroy(this.inputEl);\n    this.suggestEl.style.width = `${this.inputEl.offsetWidth}px`;\n    const loc = this.inputEl.getBoundingClientRect();\n    this.reposition({\n      left: loc.left,\n      right: loc.right,\n      top: loc.top,\n      bottom: loc.top + this.inputEl.offsetHeight,\n    });\n  };\n  getSuggestions(query: string) {\n    const queryLowercase = query.toLowerCase();\n    return this.app.vault\n      .getAllLoadedFiles()\n      .filter(\n        (file) => file instanceof TFolder && file.path.toLowerCase().contains(queryLowercase)\n      ) as TFolder[];\n  }\n  renderSuggestion(value: TFolder, el: HTMLElement): void {\n    el.createDiv({\n      text: value.path,\n    });\n  }\n  selectSuggestion(value: TFolder, evt: MouseEvent | KeyboardEvent): void {\n    this.inputEl.value = value.path;\n    this.close();\n    this.onSelected(value);\n  }\n}\n", "export class AddVaultModal extends Modal {\n  folder?: TFolder;\n  nameText: TextComponent;\n\n  constructor(app: App, public onSubmit: (config: VaultConfig) => boolean) {\n    super(app);\n  }\n\n  generateName({ path, name }: TFolder) {\n    if (path === \"/\") return \"root\";\n    return name;\n  }\n\n  onOpen(): void {\n    new Setting(this.contentEl).setHeading().setName(\"Add Vault\");\n    new Setting(this.contentEl).setName(\"Vault Path\").addText((text) => {\n      new FolderSuggester(this.app, text.inputEl, (newFolder) => {\n        const currentName = this.nameText.getValue();", "    if (path === \"/\") return \"root\";\n    return name;\n  }\n\n  onOpen(): void {\n    new Setting(this.contentEl).setHeading().setName(\"Add Vault\");\n    new Setting(this.contentEl).setName(\"Vault Path\").addText((text) => {\n      new FolderSuggester(this.app, text.inputEl, (newFolder) => {\n        const currentName = this.nameText.getValue();\n        if (\n          currentName.length === 0 ||\n          (this.folder && currentName === this.generateName(this.folder))\n        )\n          this.nameText.setValue(this.generateName(newFolder));\n\n        this.folder = newFolder;\n      });\n    });\n    new Setting(this.contentEl).setName(\"Vault Name\").addText((text) => {\n      this.nameText = text;\n    });\n    new Setting(this.contentEl).addButton((btn) => {\n      btn\n        .setCta()\n        .setButtonText(\"Add Text\")\n        .onClick(() => {\n          const name = this.nameText.getValue();", "        if (\n          currentName.length === 0 ||\n          (this.folder && currentName === this.generateName(this.folder))\n        )\n          this.nameText.setValue(this.generateName(newFolder));\n\n        this.folder = newFolder;\n      });\n    });\n    new Setting(this.contentEl).setName(\"Vault Name\").addText((text) => {\n      this.nameText = text;\n    });\n    new Setting(this.contentEl).addButton((btn) => {\n      btn\n        .setCta()\n        .setButtonText(\"Add Text\")\n        .onClick(() => {\n          const name = this.nameText.getValue();", "          if (!this.folder || name.trim().length === 0) {\n            new Notice(\"Please specify Vault Path and Vault Name\");\n            return;\n          }\n\n          if (\n            this.onSubmit({\n              path: this.folder.path,\n              name,\n            })\n          )\n            this.close();\n        });\n    });\n  }\n\n  onClose() {\n    this.contentEl.empty();\n  }\n}\n"]}
{"filename": "src/modal/select-vault.ts", "chunked_list": ["import { App, SuggestModal } from \"obsidian\";\nimport { DendronVault } from \"../engine/vault\";\nimport { DendronWorkspace } from \"../engine/workspace\";\n\nexport class SelectVaultModal extends SuggestModal<DendronVault> {\n  constructor(\n    app: App,\n    private workspace: DendronWorkspace,\n    private onSelected: (item: DendronVault) => void\n  ) {\n    super(app);\n  }\n\n  getSuggestions(query: string): DendronVault[] | Promise<DendronVault[]> {\n    const queryLowercase = query.toLowerCase();\n    return this.workspace.vaultList.filter(\n      (value) =>\n        value.config.path.toLowerCase().contains(queryLowercase) ||\n        value.config.name.toLowerCase().contains(queryLowercase)\n    );\n  }\n  renderSuggestion(value: DendronVault, el: HTMLElement) {\n    el.createEl(\"div\", { text: value.config.name });\n    el.createEl(\"small\", {\n      text: value.config.path,\n    });\n  }\n  onChooseSuggestion(item: DendronVault, evt: MouseEvent | KeyboardEvent) {\n    this.onSelected(item);\n  }\n}\n"]}
{"filename": "src/modal/invalid-root.ts", "chunked_list": ["import { Modal, Setting } from \"obsidian\";\nimport { DendronVault } from \"../engine/vault\";\n\nexport class InvalidRootModal extends Modal {\n  constructor(private dendronVault: DendronVault) {\n    super(dendronVault.app);\n  }\n\n  onOpen(): void {\n    this.contentEl.createEl(\"h1\", { text: \"Invalid Root\" });\n    this.contentEl.createEl(\"p\", {\n      text: `\"${this.dendronVault.config.path}\" is not folder. Do you want to create this folder?`,\n    });\n    new Setting(this.contentEl).addButton((button) => {\n      button\n        .setButtonText(\"Create\")\n        .setCta()\n        .onClick(async () => {\n          await this.dendronVault.createRootFolder();\n          this.dendronVault.init();\n          this.close();\n        });\n    });\n  }\n\n  onClose() {\n    this.contentEl.empty();\n  }\n}\n"]}
{"filename": "src/engine/note.ts", "chunked_list": ["import { TFile } from \"obsidian\";\n\nexport interface NoteMetadata {\n  title?: string;\n}\n\nexport class Note {\n  name: string;\n  children: Note[] = [];\n  file?: TFile;\n  parent?: Note;\n  title = \"\";\n\n  constructor(private originalName: string, private titlecase: boolean) {\n    this.name = originalName.toLowerCase();\n    this.syncMetadata(undefined);\n  }\n\n  appendChild(note: Note) {", "    if (note.parent) throw Error(\"Note has parent\");\n    note.parent = this;\n    this.children.push(note);\n  }\n\n  removeChildren(note: Note) {\n    note.parent = undefined;\n    const index = this.children.indexOf(note);\n    this.children.splice(index, 1);\n  }\n\n  findChildren(name: string) {\n    const lower = name.toLowerCase();\n    return this.children.find((note) => note.name == lower);\n  }\n\n  sortChildren(rescursive: boolean) {\n    this.children.sort((a, b) => a.name.localeCompare(b.name));", "    if (rescursive) this.children.forEach((child) => child.sortChildren(rescursive));\n  }\n\n  getPath(original = false) {\n    const component: string[] = [];\n    const notes = this.getPathNotes();\n\n    if (notes.length === 1) return original ? notes[0].originalName : notes[0].name;\n\n    for (const note of notes) {\n      if (!note.parent && note.name === \"root\") continue;\n      component.push(original ? note.originalName : note.name);\n    }\n\n    return component.join(\".\");\n  }\n\n  getPathNotes() {\n    const notes: Note[] = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let current: Note | undefined = this;", "    for (const note of notes) {\n      if (!note.parent && note.name === \"root\") continue;\n      component.push(original ? note.originalName : note.name);\n    }\n\n    return component.join(\".\");\n  }\n\n  getPathNotes() {\n    const notes: Note[] = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let current: Note | undefined = this;", "    while (current) {\n      notes.unshift(current);\n      current = current.parent;\n    }\n    return notes;\n  }\n\n  syncMetadata(metadata: NoteMetadata | undefined) {\n    this.title = metadata?.title ?? generateNoteTitle(this.originalName, this.titlecase);\n  }\n}\n\n/**\n * Check whetever generated note title must be title case or not\n * @param baseName file base name\n */\n", "export function isUseTitleCase(baseName: string) {\n  return baseName.toLowerCase() === baseName;\n}\n\n/**\n * Generate title for note\n * @param originalName name of note before lowercased (not filename)\n * @param titlecase use title case or use original name\n * @returns title for note\n */\n", "export function generateNoteTitle(originalName: string, titlecase: boolean) {\n  if (!titlecase) return originalName;\n  return originalName\n    .split(\"-\")\n    .map((item) => item.trim())\n    .filter((item) => item.length > 0)\n    .map((word) => {\n      return word[0].toUpperCase() + word.substring(1).toLowerCase();\n    })\n    .join(\" \");\n}\n", "export class NoteTree {\n  root: Note = new Note(\"root\", true);\n\n  sort() {\n    this.root.sortChildren(true);\n  }\n\n  public static getPathFromFileName(name: string) {\n    return name.split(\".\");\n  }\n\n  private static isRootPath(path: string[]) {\n    return path.length === 1 && path[0] === \"root\";\n  }\n\n  addFile(file: TFile, sort = false) {\n    const titlecase = isUseTitleCase(file.basename);\n    const path = NoteTree.getPathFromFileName(file.basename);\n\n    let currentNote: Note = this.root;\n", "    if (!NoteTree.isRootPath(path))\n      for (const name of path) {\n        let note: Note | undefined = currentNote.findChildren(name);\n\n        if (!note) {\n          note = new Note(name, titlecase);\n          currentNote.appendChild(note);\n          if (sort) currentNote.sortChildren(false);\n        }\n\n        currentNote = note;\n      }\n\n    currentNote.file = file;\n    return currentNote;\n  }\n\n  getFromFileName(name: string) {\n    const path = NoteTree.getPathFromFileName(name);\n", "    if (NoteTree.isRootPath(path)) return this.root;\n\n    let currentNote: Note = this.root;\n\n    for (const name of path) {\n      const found = currentNote.findChildren(name);\n      if (!found) return undefined;\n      currentNote = found;\n    }\n\n    return currentNote;\n  }\n\n  deleteByFileName(name: string) {\n    const note = this.getFromFileName(name);", "    if (!note) return;\n\n    note.file = undefined;\n    if (note.children.length == 0) {\n      let currentNote: Note | undefined = note;\n      while (\n        currentNote &&\n        currentNote.parent &&\n        !currentNote.file &&\n        currentNote.children.length == 0\n      ) {\n        const parent: Note | undefined = currentNote.parent;\n        parent.removeChildren(currentNote);\n        currentNote = parent;\n      }\n    }\n\n    return note;\n  }\n\n  private static *flattenInternal(root: Note): Generator<Note> {\n    yield root;", "    for (const child of root.children) yield* this.flattenInternal(child);\n  }\n\n  flatten() {\n    return Array.from(NoteTree.flattenInternal(this.root));\n  }\n}\n"]}
{"filename": "src/engine/note.test.ts", "chunked_list": ["import type { Stat, TFile, Vault } from \"obsidian\";\nimport { Note, NoteTree, generateNoteTitle, isUseTitleCase } from \"./note\";\nimport { parsePath } from \"../path\";\n\ndescribe(\"note title\", () => {\n  it(\"use title case when file name is lowercase\", () => {\n    expect(generateNoteTitle(\"kamu-milikku\", isUseTitleCase(\"aku.cinta.kamu-milikku.md\"))).toBe(\n      \"Kamu Milikku\"\n    );\n  });", "    );\n  });\n  it(\"use file name when note name contain uppercase\", () => {\n    expect(generateNoteTitle(\"Kamu-Milikku\", isUseTitleCase(\"aku.cinta.Kamu-Milikku.md\"))).toBe(\n      \"Kamu-Milikku\"\n    );\n  });\n  it(\"use file name when file name contain uppercase\", () => {\n    expect(generateNoteTitle(\"kamu-milikku\", isUseTitleCase(\"Aku.cinta.kamu-milikku.md\"))).toBe(\n      \"kamu-milikku\"", "    expect(generateNoteTitle(\"kamu-milikku\", isUseTitleCase(\"Aku.cinta.kamu-milikku.md\"))).toBe(\n      \"kamu-milikku\"\n    );\n  });\n});\n\ndescribe(\"note class\", () => {\n  it(\"append and remove child work\", () => {\n    const child = new Note(\"lala\", true);\n    expect(child.parent).toBeUndefined();", "    const child = new Note(\"lala\", true);\n    expect(child.parent).toBeUndefined();\n\n    const parent = new Note(\"apa\", true);\n    expect(parent.children).toEqual([]);\n\n    parent.appendChild(child);\n    expect(child.parent).toBe(parent);\n    expect(parent.children).toEqual([child]);\n", "    expect(parent.children).toEqual([child]);\n\n    parent.removeChildren(child);\n    expect(child.parent).toBeUndefined();\n    expect(parent.children).toEqual([]);\n  });\n  it(\"append child must throw if child already has parent\", () => {\n    const origParent = new Note(\"root\", true);\n    const parent = new Note(\"root2\", true);\n    const child = new Note(\"child\", true);", "    const parent = new Note(\"root2\", true);\n    const child = new Note(\"child\", true);\n\n    origParent.appendChild(child);\n\n    expect(() => parent.appendChild(child)).toThrowError(\"has parent\");\n  });\n  it(\"find children work\", () => {\n    const parent = new Note(\"parent\", true);\n    const child1 = new Note(\"child1\", true);", "    const parent = new Note(\"parent\", true);\n    const child1 = new Note(\"child1\", true);\n    const child2 = new Note(\"child2\", true);\n    const child3 = new Note(\"child3\", true);\n\n    parent.appendChild(child1);\n    parent.appendChild(child2);\n    parent.appendChild(child3);\n\n    expect(parent.findChildren(\"child1\")).toBe(child1);", "\n    expect(parent.findChildren(\"child1\")).toBe(child1);\n    expect(parent.findChildren(\"child2\")).toBe(child2);\n    expect(parent.findChildren(\"child3\")).toBe(child3);\n    expect(parent.findChildren(\"child4\")).toBeUndefined();\n  });\n  it(\"non-recursive sort children work\", () => {\n    const parent = new Note(\"parent\", true);\n    const child1 = new Note(\"gajak\", true);\n    const child2 = new Note(\"lumba\", true);", "    const child1 = new Note(\"gajak\", true);\n    const child2 = new Note(\"lumba\", true);\n    const child3 = new Note(\"biawak\", true);\n\n    parent.appendChild(child1);\n    parent.appendChild(child2);\n    parent.appendChild(child3);\n\n    expect(parent.children).toEqual([child1, child2, child3]);\n    parent.sortChildren(false);", "    expect(parent.children).toEqual([child1, child2, child3]);\n    parent.sortChildren(false);\n    expect(parent.children).toEqual([child3, child1, child2]);\n  });\n  it(\"recursive sort children work\", () => {\n    const parent = new Note(\"parent\", true);\n    const child1 = new Note(\"lumba\", true);\n    const child2 = new Note(\"galak\", true);\n    const grandchild1 = new Note(\"lupa\", true);\n    const grandchild2 = new Note(\"apa\", true);", "    const grandchild1 = new Note(\"lupa\", true);\n    const grandchild2 = new Note(\"apa\", true);\n    const grandchild3 = new Note(\"abu\", true);\n    const grandchild4 = new Note(\"lagi\", true);\n\n    parent.appendChild(child1);\n    child1.appendChild(grandchild1);\n    child1.appendChild(grandchild2);\n    parent.appendChild(child2);\n    child2.appendChild(grandchild3);", "    parent.appendChild(child2);\n    child2.appendChild(grandchild3);\n    child2.appendChild(grandchild4);\n\n    expect(parent.children).toEqual([child1, child2]);\n    expect(child1.children).toEqual([grandchild1, grandchild2]);\n    expect(child2.children).toEqual([grandchild3, grandchild4]);\n    parent.sortChildren(true);\n    expect(parent.children).toEqual([child2, child1]);\n    expect(child1.children).toEqual([grandchild2, grandchild1]);", "    expect(parent.children).toEqual([child2, child1]);\n    expect(child1.children).toEqual([grandchild2, grandchild1]);\n    expect(child2.children).toEqual([grandchild3, grandchild4]);\n  });\n\n  it(\"get path on non-root\", () => {\n    const root = new Note(\"root\", true);\n    const ch1 = new Note(\"parent\", true);\n    const ch2 = new Note(\"parent2\", true);\n    const ch3 = new Note(\"child\", true);", "    const ch2 = new Note(\"parent2\", true);\n    const ch3 = new Note(\"child\", true);\n\n    root.appendChild(ch1);\n    ch1.appendChild(ch2);\n    ch2.appendChild(ch3);\n\n    expect(ch3.getPath()).toBe(\"parent.parent2.child\");\n    expect(ch3.getPathNotes()).toEqual([root, ch1, ch2, ch3]);\n  });", "    expect(ch3.getPathNotes()).toEqual([root, ch1, ch2, ch3]);\n  });\n\n  it(\"get path on root\", () => {\n    const root = new Note(\"root\", true);\n    expect(root.getPath()).toBe(\"root\");\n    expect(root.getPathNotes()).toEqual([root]);\n  });\n\n  it(\"use generated title when titlecase true\", () => {", "\n  it(\"use generated title when titlecase true\", () => {\n    const note = new Note(\"aku-cinta\", true);\n    expect(note.title).toBe(\"Aku Cinta\");\n  });\n\n  it(\"use filename as title when titlecase false\", () => {\n    const note = new Note(\"aKu-ciNta\", false);\n    expect(note.title).toBe(\"aKu-ciNta\");\n  });", "    expect(note.title).toBe(\"aKu-ciNta\");\n  });\n\n  it(\"use metadata title when has metadata\", () => {\n    const note = new Note(\"aKu-ciNta\", false);\n    note.syncMetadata({\n      title: \"Butuh Kamu\",\n    });\n    expect(note.title).toBe(\"Butuh Kamu\");\n  });", "    expect(note.title).toBe(\"Butuh Kamu\");\n  });\n});\n\nfunction createTFile(path: string): TFile {\n  const { basename, name, extension } = parsePath(path);\n  return {\n    basename,\n    extension,\n    name,\n    parent: null,\n    path: path,\n    stat: null as unknown as Stat,\n    vault: null as unknown as Vault,\n  };\n}\n\ndescribe(\"tree class\", () => {\n  it(\"add file without sort\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    expect(tree.root.children.length).toBe(1);\n    expect(tree.root.children[0].name).toBe(\"abc\");\n    expect(tree.root.children[0].children.length).toBe(1);\n    expect(tree.root.children[0].children[0].name).toBe(\"def\");\n    expect(tree.root.children[0].children[0].children.length).toBe(2);\n    expect(tree.root.children[0].children[0].children[0].name).toBe(\"jkl\");\n    expect(tree.root.children[0].children[0].children[1].name).toBe(\"ghi\");\n  });\n\n  it(\"add file with sort\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.jkl.md\"), true);\n    tree.addFile(createTFile(\"abc.def.ghi.md\"), true);\n    tree.addFile(createTFile(\"abc.def.mno.md\"), true);\n    expect(tree.root.children[0].children[0].children.length).toBe(3);\n    expect(tree.root.children[0].children[0].children[0].name).toBe(\"ghi\");\n    expect(tree.root.children[0].children[0].children[1].name).toBe(\"jkl\");\n    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n  });\n  it(\"get note by file base name\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    expect(tree.getFromFileName(\"abc.def.jkl\")?.name).toBe(\"jkl\");\n    expect(tree.getFromFileName(\"abc.def.ghi\")?.name).toBe(\"ghi\");\n    expect(tree.getFromFileName(\"abc.def.mno\")).toBeUndefined();\n  });\n  it(\"get note using blank path\", () => {\n\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    expect(tree.getFromFileName(\"\")).toBeUndefined()\n  })\n  it(\"delete note if do not have children\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.md\"));\n    tree.deleteByFileName(\"abc\");\n    expect(tree.getFromFileName(\"abc\")).toBeUndefined();\n  });\n  it(\"do not delete note if have children\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.md\"));\n    tree.addFile(createTFile(\"abc.def.md\"));\n    tree.deleteByFileName(\"abc\");\n    expect(tree.getFromFileName(\"abc\")?.name).toBe(\"abc\");\n    expect(tree.getFromFileName(\"abc.def\")?.name).toBe(\"def\");\n  });\n  it(\"delete note and parent if do not have children and parent file is null\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    tree.deleteByFileName(\"abc.def.ghi\");\n    expect(tree.getFromFileName(\"abc.def.ghi\")).toBeUndefined();\n    expect(tree.getFromFileName(\"abc.def\")).toBeUndefined();\n    expect(tree.getFromFileName(\"abc\")?.name).toBe(\"abc\");\n  });\n  it(\"sort note\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    tree.addFile(createTFile(\"abc.def.mno.md\"));\n    expect(tree.root.children[0].children[0].children.length).toBe(3);\n    expect(tree.root.children[0].children[0].children[0].name).toBe(\"jkl\");\n    expect(tree.root.children[0].children[0].children[1].name).toBe(\"ghi\");\n    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n    tree.sort();\n    expect(tree.root.children[0].children[0].children[0].name).toBe(\"ghi\");\n    expect(tree.root.children[0].children[0].children[1].name).toBe(\"jkl\");\n    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n  });\n  it(\"flatten note\", () => {\n    const tree = new NoteTree();\n    tree.addFile(createTFile(\"abc.def.md\"));\n    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n    tree.addFile(createTFile(\"abc.jkl.mno.md\"));\n    expect(tree.flatten().map((note) => note.getPath())).toEqual([\n      \"root\",\n      \"abc\",\n      \"abc.def\",\n      \"abc.def.ghi\",\n      \"abc.jkl\",\n      \"abc.jkl.mno\",\n    ]);\n  });\n});\n"]}
{"filename": "src/engine/vault.ts", "chunked_list": ["import { App, TAbstractFile, TFile, TFolder } from \"obsidian\";\nimport { NoteMetadata, NoteTree } from \"./note\";\nimport { InvalidRootModal } from \"../modal/invalid-root\";\nimport { generateUUID, getFolderFile } from \"../utils\";\nimport { ParsedPath } from \"../path\";\n\nexport interface VaultConfig {\n  path: string;\n  name: string;\n}\n", "export class DendronVault {\n  folder: TFolder;\n  tree: NoteTree;\n  isIniatialized = false;\n\n  constructor(public app: App, public config: VaultConfig) {}\n\n  private resolveMetadata(file: TFile): NoteMetadata | undefined {\n    const frontmatter = this.app.metadataCache.getFileCache(file)?.frontmatter;\n    if (!frontmatter) return undefined;\n    return {\n      title: frontmatter[\"title\"],\n    };\n  }\n\n  init() {", "    if (!frontmatter) return undefined;\n    return {\n      title: frontmatter[\"title\"],\n    };\n  }\n\n  init() {\n    if (this.isIniatialized) return;\n\n    this.tree = new NoteTree();\n\n    const root = getFolderFile(this.app.vault, this.config.path);", "    if (!(root instanceof TFolder)) {\n      new InvalidRootModal(this).open();\n      return;\n    }\n\n    this.folder = root;\n\n    for (const child of root.children)\n      if (child instanceof TFile && this.isNote(child.extension))\n        this.tree.addFile(child).syncMetadata(this.resolveMetadata(child));\n\n    this.tree.sort();\n    this.isIniatialized = true;\n  }\n\n  async createRootFolder() {\n    return await this.app.vault.createFolder(this.config.path);\n  }\n\n  async createNote(baseName: string) {\n    const filePath = `${this.config.path}/${baseName}.md`;\n    return await this.app.vault.create(filePath, \"\");\n  }\n\n  async generateFronmatter(file: TFile) {", "      if (child instanceof TFile && this.isNote(child.extension))\n        this.tree.addFile(child).syncMetadata(this.resolveMetadata(child));\n\n    this.tree.sort();\n    this.isIniatialized = true;\n  }\n\n  async createRootFolder() {\n    return await this.app.vault.createFolder(this.config.path);\n  }\n\n  async createNote(baseName: string) {\n    const filePath = `${this.config.path}/${baseName}.md`;\n    return await this.app.vault.create(filePath, \"\");\n  }\n\n  async generateFronmatter(file: TFile) {", "    if (!this.isNote(file.extension)) return;\n\n    const note = this.tree.getFromFileName(file.basename);\n\n    if (!note) return false;\n\n    return await this.app.fileManager.processFrontMatter(file, (fronmatter) => {\n      if (!fronmatter.id) fronmatter.id = generateUUID();\n      if (!fronmatter.title) fronmatter.title = note.title;\n      if (fronmatter.desc === undefined) fronmatter.desc = \"\";\n      if (!fronmatter.created) fronmatter.created = file.stat.ctime;", "      if (!fronmatter.title) fronmatter.title = note.title;\n      if (fronmatter.desc === undefined) fronmatter.desc = \"\";\n      if (!fronmatter.created) fronmatter.created = file.stat.ctime;\n      if (!fronmatter.updated) fronmatter.updated = file.stat.mtime;\n    });\n  }\n\n  isNote(extension: string) {\n    return extension === \"md\";\n  }\n\n  onFileCreated(file: TAbstractFile): boolean {", "    if (!(file instanceof TFile) || !this.isNote(file.extension)) return false;\n\n    this.tree.addFile(file, true).syncMetadata(this.resolveMetadata(file));\n    return true;\n  }\n\n  onMetadataChanged(file: TFile): boolean {\n    if (!this.isNote(file.extension)) return false;\n\n    const note = this.tree.getFromFileName(file.basename);\n    if (!note) return false;\n\n    note.syncMetadata(this.resolveMetadata(file));\n    return true;\n  }\n\n  onFileDeleted(parsed: ParsedPath): boolean {", "    if (!note) return false;\n\n    note.syncMetadata(this.resolveMetadata(file));\n    return true;\n  }\n\n  onFileDeleted(parsed: ParsedPath): boolean {\n    if (!this.isNote(parsed.extension)) return false;\n\n    const note = this.tree.deleteByFileName(parsed.basename);\n    if (note?.parent) {\n      note.syncMetadata(undefined);\n    }\n    return true;\n  }\n}\n", "    if (note?.parent) {\n      note.syncMetadata(undefined);\n    }\n    return true;\n  }\n}\n"]}
{"filename": "src/engine/workspace.ts", "chunked_list": ["import { App, TFolder, parseLinktext } from \"obsidian\";\nimport { DendronVault, VaultConfig } from \"./vault\";\nimport { getFolderFile } from \"../utils\";\nimport { RefTarget, parseRefSubpath } from \"./ref\";\nimport { parsePath } from \"../path\";\n\nconst DENDRON_URI_START = \"dendron://\";\n\nexport class DendronWorkspace {\n  vaultList: DendronVault[] = [];\n\n  constructor(public app: App) {}\n\n  changeVault(vaultList: VaultConfig[]) {\n    this.vaultList = vaultList.map((config) => {\n      return (\n        this.vaultList.find(\n          (vault) => vault.config.name === config.name && vault.config.path === config.path\n        ) ?? new DendronVault(this.app, config)\n      );\n    });", "export class DendronWorkspace {\n  vaultList: DendronVault[] = [];\n\n  constructor(public app: App) {}\n\n  changeVault(vaultList: VaultConfig[]) {\n    this.vaultList = vaultList.map((config) => {\n      return (\n        this.vaultList.find(\n          (vault) => vault.config.name === config.name && vault.config.path === config.path\n        ) ?? new DendronVault(this.app, config)\n      );\n    });", "    for (const vault of this.vaultList) {\n      vault.init();\n    }\n  }\n\n  findVaultByParent(parent: TFolder | null): DendronVault | undefined {\n    return this.vaultList.find((vault) => vault.folder === parent);\n  }\n\n  findVaultByParentPath(path: string): DendronVault | undefined {\n    const file = getFolderFile(this.app.vault, path);\n    return file instanceof TFolder ? this.findVaultByParent(file) : undefined;\n  }\n\n  resolveRef(sourcePath: string, link: string): RefTarget | null {", "    if (link.startsWith(DENDRON_URI_START)) {\n      const [vaultName, rest] = link.slice(DENDRON_URI_START.length).split(\"/\", 2) as (\n        | string\n        | undefined\n      )[];\n      const { path, subpath } = rest\n        ? parseLinktext(rest)\n        : {\n            path: undefined,\n            subpath: undefined,\n          };\n      const vault = this.vaultList.find(({ config }) => config.name === vaultName);\n\n      return {\n        type: \"maybe-note\",\n        vaultName: vaultName ?? \"\",\n        vault,\n        note: path ? vault?.tree?.getFromFileName(path) : undefined,\n        path: path ?? \"\",\n        subpath: subpath ? parseRefSubpath(subpath) : undefined,\n      };\n    }\n    const { dir: vaultDir } = parsePath(sourcePath);\n    const vault = this.findVaultByParentPath(vaultDir);\n", "    if (!vault) return null;\n\n    const { path, subpath } = parseLinktext(link);\n    const target = this.app.metadataCache.getFirstLinkpathDest(path, sourcePath);\n\n    if (target && target.extension !== \"md\")\n      return {\n        type: \"file\",\n        file: target,\n      };\n\n    const note = vault.tree.getFromFileName(path);\n    return {\n      type: \"maybe-note\",\n      vaultName: vault.config.name,\n      vault: vault,\n      note,\n      path,\n      subpath: parseRefSubpath(subpath.slice(1) ?? \"\"),\n    };\n  }\n}\n"]}
{"filename": "src/engine/ref.ts", "chunked_list": ["import { CachedMetadata, HeadingCache, TFile } from \"obsidian\";\nimport { Note } from \"./note\";\nimport { DendronVault } from \"./vault\";\nimport GithubSlugger from \"github-slugger\";\n\nexport interface MaybeNoteRef {\n  type: \"maybe-note\";\n  vaultName: string;\n  vault?: DendronVault;\n  note?: Note;\n  path: string;\n  subpath?: RefSubpath;\n}\n", "export interface FileRef {\n  type: \"file\";\n  file: TFile;\n}\n\nexport type RefTarget = MaybeNoteRef | FileRef;\n\nexport type RefAnchor =\n  | {\n      type: \"begin\";\n    }\n  | {\n      type: \"end\";\n    }\n  | {\n      type: \"wildcard\";\n    }\n  | {\n      type: \"block\";\n      name: string;\n    }\n  | {\n      type: \"header\";\n      name: string;\n      lineOffset: number;\n    };\n", "export interface RefRange {\n  start: number;\n  startLineOffset: number;\n  /* undefined = end of file */\n  end: number | undefined;\n}\n\nexport interface RefSubpath {\n  text: string;\n  start: RefAnchor;\n  end?: RefAnchor;\n}\n", "export function parseRefAnchor(pos: string): RefAnchor {\n  if (pos === \"*\") {\n    return {\n      type: \"wildcard\",\n    };\n  } else if (pos === \"^begin\") {\n    return {\n      type: \"begin\",\n    };\n  } else if (pos === \"^end\") {\n    return {\n      type: \"end\",\n    };", "  } else if (pos === \"^end\") {\n    return {\n      type: \"end\",\n    };\n  } else if (pos.startsWith(\"^\")) {\n    return {\n      type: \"block\",\n      name: pos.slice(1),\n    };\n  } else {\n    const [name, lineOffsetStr] = pos.split(\",\", 2);\n    return {\n      type: \"header\",\n      name,\n      lineOffset: parseInt(lineOffsetStr ?? \"0\"),\n    };\n  }\n}\n", "function findHeadingByGithubSlug(headings: HeadingCache[], name: string) {\n  const slugger = new GithubSlugger();\n  const index = headings.findIndex(({ heading }) => slugger.slug(heading) === name);\n  return {\n    index,\n    heading: headings[index],\n  };\n}\n\nexport function getRefContentRange(subpath: RefSubpath, metadata: CachedMetadata): RefRange | null {\n  const range: RefRange = {\n    start: 0,\n    startLineOffset: 0,\n    end: undefined,\n  };\n\n  const { start, end } = subpath;\n", "export function getRefContentRange(subpath: RefSubpath, metadata: CachedMetadata): RefRange | null {\n  const range: RefRange = {\n    start: 0,\n    startLineOffset: 0,\n    end: undefined,\n  };\n\n  const { start, end } = subpath;\n\n  if (start.type === \"begin\") {\n    range.start = 0;\n    range.end = metadata.headings?.[0].position.start.offset;", "  if (start.type === \"begin\") {\n    range.start = 0;\n    range.end = metadata.headings?.[0].position.start.offset;\n  } else if (start.type === \"end\" || start.type === \"wildcard\") {\n    return null;\n  } else if (start.type === \"block\") {\n    if (!metadata.blocks) return null;\n\n    const block = metadata.blocks[start.name];\n    if (!block) return null;\n\n    const { position } = block;\n\n    range.start = position.start.offset;\n    range.end = position.end.offset;", "    if (!block) return null;\n\n    const { position } = block;\n\n    range.start = position.start.offset;\n    range.end = position.end.offset;\n  } else if (start.type === \"header\") {\n    if (!metadata.headings) return null;\n\n    const { index: startHeadingIndex, heading: startHeading } = findHeadingByGithubSlug(\n      metadata.headings,\n      start.name\n    );\n", "    if (!startHeading) return null;\n\n    range.start = startHeading.position.start.offset;\n    range.startLineOffset = start.lineOffset;\n\n    let endHeading: HeadingCache | undefined;\n\n    if (end && end.type === \"wildcard\") {\n      endHeading = metadata.headings?.[startHeadingIndex + 1];\n    } else {\n      endHeading = metadata.headings?.find(\n        ({ level }, index) => index > startHeadingIndex && level <= startHeading.level\n      );\n    }\n\n    range.end = endHeading?.position.start.offset;\n  }\n", "  if (!end) return range;\n\n  if (end.type === \"begin\") {\n    return null;\n  } else if (end.type === \"end\") {\n    range.end = undefined;\n  } else if (end.type === \"header\") {\n    if (!metadata.headings) return null;\n    const { heading } = findHeadingByGithubSlug(metadata.headings, end.name);\n    if (!heading) return null;\n    range.end = heading?.position.end.offset;", "    if (!heading) return null;\n    range.end = heading?.position.end.offset;\n  } else if (end.type === \"block\") {\n    const block = metadata.blocks?.[end.name];\n    if (!block) return null;\n    range.end = block?.position.end.offset;\n  }\n\n  return range;\n}\n", "export function anchorToLinkSubpath(\n  anchor: RefAnchor,\n  headings: HeadingCache[] | undefined\n): string | null {\n  if (anchor.type === \"header\") {\n    let name = anchor.name;\n    if (headings) {\n      const { heading } = findHeadingByGithubSlug(headings, name);\n      if (heading) {\n        name = heading.heading;\n      }\n    }\n    return `#${name}`;", "      if (heading) {\n        name = heading.heading;\n      }\n    }\n    return `#${name}`;\n  } else if (anchor.type === \"block\") return `#^${anchor.name}`;\n  return \"\";\n}\n\nexport function parseRefSubpath(str: string): RefSubpath | undefined {\n  if (str.length > 0) {\n    const [startStr, endStr] = str.split(\":#\", 2);\n    const start = parseRefAnchor(startStr);\n\n    let end: RefAnchor | undefined;", "export function parseRefSubpath(str: string): RefSubpath | undefined {\n  if (str.length > 0) {\n    const [startStr, endStr] = str.split(\":#\", 2);\n    const start = parseRefAnchor(startStr);\n\n    let end: RefAnchor | undefined;\n    if (endStr) end = parseRefAnchor(endStr);\n    return {\n      text: str,\n      start,\n      end,\n    };\n  }\n  return undefined;\n}\n"]}
{"filename": "src/custom-resolver/ref-render.ts", "chunked_list": ["import {\n  App,\n  ButtonComponent,\n  MarkdownRenderChild,\n  MarkdownRenderer,\n  MarkdownRendererConstructorType,\n  OpenViewState,\n  TFile,\n  setIcon,\n} from \"obsidian\";", "  setIcon,\n} from \"obsidian\";\nimport { openFile } from \"../utils\";\nimport { MaybeNoteRef, RefRange, getRefContentRange, anchorToLinkSubpath } from \"../engine/ref\";\nimport { dendronActivityBarName } from \"../icons\";\n\nconst MarkdownRendererConstructor = MarkdownRenderer as unknown as MarkdownRendererConstructorType;\n\nclass RefMarkdownRenderer extends MarkdownRendererConstructor {\n  constructor(public parent: NoteRefRenderChild, queed: boolean) {\n    super(parent.app, parent.previewEl, queed);\n  }\n\n  get file(): TFile {\n    return this.parent.file;\n  }\n\n  edit(markdown: string) {\n    this.parent.editContent(markdown);\n  }\n}\n", "class RefMarkdownRenderer extends MarkdownRendererConstructor {\n  constructor(public parent: NoteRefRenderChild, queed: boolean) {\n    super(parent.app, parent.previewEl, queed);\n  }\n\n  get file(): TFile {\n    return this.parent.file;\n  }\n\n  edit(markdown: string) {\n    this.parent.editContent(markdown);\n  }\n}\n", "export class NoteRefRenderChild extends MarkdownRenderChild {\n  previewEl: HTMLElement;\n  renderer: RefMarkdownRenderer;\n  file: TFile;\n  range: RefRange | null;\n  markdown?: string;\n  found = false;\n\n  constructor(\n    public readonly app: App,\n    public readonly containerEl: HTMLElement,\n    public readonly ref: MaybeNoteRef\n  ) {\n    super(containerEl);\n", "    if (!ref.note || !ref.note.file)\n      throw Error(\"NoteRefChild only accept ref with non-blank note and file\");\n\n    this.file = ref.note.file;\n\n    this.containerEl.classList.add(\"dendron-embed\", \"markdown-embed\", \"inline-embed\", \"is-loaded\");\n    this.containerEl.setText(\"\");\n\n    const icon = this.containerEl.createDiv(\"dendron-icon\");\n    setIcon(icon, dendronActivityBarName);\n\n    this.previewEl = this.containerEl.createDiv(\"markdown-embed-content\");\n\n    const buttonComponent = new ButtonComponent(this.containerEl);\n    buttonComponent.buttonEl.remove();\n    buttonComponent.buttonEl = this.containerEl.createDiv(\n      \"markdown-embed-link\"\n    ) as unknown as HTMLButtonElement;\n    buttonComponent.setIcon(\"lucide-link\").setTooltip(\"Open link\");\n    buttonComponent.buttonEl.onclick = () => {\n      const openState: OpenViewState = {};", "      if (this.ref.subpath) {\n        openState.eState = {\n          subpath: anchorToLinkSubpath(\n            this.ref.subpath.start,\n            this.app.metadataCache.getFileCache(this.file)?.headings\n          ),\n        };\n      }\n      openFile(this.app, this.ref.note?.file, openState);\n    };\n\n    this.renderer = new RefMarkdownRenderer(this, true);\n    this.addChild(this.renderer);\n  }\n\n  async getContent(): Promise<string> {\n    this.markdown = await this.app.vault.cachedRead(this.file);\n", "    if (!this.ref.subpath) {\n      this.found = true;\n      return this.markdown;\n    }\n\n    const metadata = this.app.metadataCache.getFileCache(this.file);\n    if (metadata) {\n      this.range = getRefContentRange(this.ref.subpath, metadata);\n      if (this.range) {\n        let currentLineIndex = 0;\n        while (currentLineIndex < this.range.startLineOffset) {", "      if (this.range) {\n        let currentLineIndex = 0;\n        while (currentLineIndex < this.range.startLineOffset) {\n          if (this.markdown[this.range.start] === \"\\n\") currentLineIndex++;\n          this.range.start++;\n        }\n\n        this.found = true;\n        return this.markdown.substring(this.range.start, this.range.end);\n      }\n    }\n\n    this.found = false;\n    return \"### Unable to find section \"\n      .concat(this.ref.subpath.text, \" in \")\n      .concat(this.file.basename);\n  }\n\n  editContent(target: string) {", "    if (!this.found || !this.markdown) return;\n\n    let md;\n    if (!this.range) {\n      md = target;\n    } else {\n      const before = this.markdown.substring(0, this.range.start);\n      md = before + target;\n      if (this.range.end) {\n        const after = this.markdown.substring(this.range.end);\n        md += after;\n      }\n    }\n    this.app.vault.modify(this.file, md);\n  }\n\n  async loadFile() {\n    const content = await this.getContent();\n    this.renderer.renderer.set(content);\n  }\n\n  onload(): void {\n    super.onload();\n    this.registerEvent(\n      this.app.metadataCache.on(\"changed\", async (file, data) => {", "      if (this.range.end) {\n        const after = this.markdown.substring(this.range.end);\n        md += after;\n      }\n    }\n    this.app.vault.modify(this.file, md);\n  }\n\n  async loadFile() {\n    const content = await this.getContent();\n    this.renderer.renderer.set(content);\n  }\n\n  onload(): void {\n    super.onload();\n    this.registerEvent(\n      this.app.metadataCache.on(\"changed\", async (file, data) => {", "        if (file === this.file) {\n          this.loadFile();\n        }\n      })\n    );\n  }\n}\n\nexport class UnresolvedRefRenderChild extends MarkdownRenderChild {\n  constructor(app: App, containerEl: HTMLElement, target: MaybeNoteRef) {\n    super(containerEl);\n\n    this.containerEl.classList.add(\"dendron-embed\", \"file-embed\", \"mod-empty\", \"is-loaded\");\n    this.containerEl.setText(\"\");\n\n    const icon = this.containerEl.createDiv(\"dendron-icon\");\n    setIcon(icon, dendronActivityBarName);\n    const content = this.containerEl.createDiv();\n\n    const { vaultName, vault, path } = target;\n", "export class UnresolvedRefRenderChild extends MarkdownRenderChild {\n  constructor(app: App, containerEl: HTMLElement, target: MaybeNoteRef) {\n    super(containerEl);\n\n    this.containerEl.classList.add(\"dendron-embed\", \"file-embed\", \"mod-empty\", \"is-loaded\");\n    this.containerEl.setText(\"\");\n\n    const icon = this.containerEl.createDiv(\"dendron-icon\");\n    setIcon(icon, dendronActivityBarName);\n    const content = this.containerEl.createDiv();\n\n    const { vaultName, vault, path } = target;\n", "    if (vaultName === \"\") {\n      content.setText(\"Vault name are unspecified in link.\");\n      return;\n    } else if (!vault) {\n      content.setText(`Vault ${vaultName} are not found.`);\n      return;\n    } else if (path === \"\") {\n      content.setText(\"Note path are unspecified in link.\");\n      return;\n    }\n    content.setText(`\"${target.path}\" is not created yet. Click to create.`);\n\n    this.containerEl.onclick = () => {\n      vault.createNote(path).then((file) => openFile(app, file));\n    };\n  }\n}\n", "export function createRefRenderer(target: MaybeNoteRef, app: App, container: HTMLElement) {\n  if (!target.note || !target.note.file) {\n    return new UnresolvedRefRenderChild(app, container, target);\n  } else {\n    return new NoteRefRenderChild(app, container, target);\n  }\n}\n"]}
{"filename": "src/custom-resolver/link-render.ts", "chunked_list": ["import { App } from \"obsidian\";\nimport { DendronWorkspace } from \"../engine/workspace\";\n\nexport function renderLinkTitle(\n  app: App,\n  workspace: DendronWorkspace,\n  href: string,\n  title: string | undefined,\n  sourcePath: string\n) {\n  if (title) {\n    return title;\n  }\n  const ref = workspace.resolveRef(sourcePath, href);", "  if (title) {\n    return title;\n  }\n  const ref = workspace.resolveRef(sourcePath, href);\n  if (!ref || ref.type !== \"maybe-note\" || !ref.note?.file) {\n    return href;\n  }\n\n  const fileTitle = app.metadataCache.getFileCache(ref.note.file)?.frontmatter?.[\"title\"];\n  return fileTitle ?? href;\n}\n"]}
{"filename": "src/custom-resolver/link-live.ts", "chunked_list": ["import { syntaxTree, tokenClassNodeProp } from \"@codemirror/language\";\nimport { RangeSetBuilder } from \"@codemirror/state\";\nimport {\n  Decoration,\n  DecorationSet,\n  EditorView,\n  PluginValue,\n  ViewUpdate,\n  WidgetType,\n} from \"@codemirror/view\";", "  WidgetType,\n} from \"@codemirror/view\";\nimport { editorInfoField, App } from \"obsidian\";\nimport { editorLivePreviewField } from \"obsidian\";\nimport { RefTarget } from \"../engine/ref\";\nimport { DendronWorkspace } from \"../engine/workspace\";\nimport { renderLinkTitle } from \"./link-render\";\n\nclass LinkWidget extends WidgetType {\n  containerEl: HTMLSpanElement;\n  ref: RefTarget | null;\n\n  constructor(\n    public app: App,\n    public workspace: DendronWorkspace,\n    public sourcePath: string,\n    public href: string,\n    public title: string | undefined\n  ) {\n    super();\n  }\n\n  initDOM() {\n    this.containerEl = createSpan(\n      {\n        cls: \"cm-hmd-internal-link\",\n      },\n      (el) => {\n        el.createSpan({\n          cls: \"cm-underline\",\n        });\n      }\n    );\n    this.updateTitle();\n\n    this.containerEl.addEventListener(\"click\", () => {\n      this.app.workspace.openLinkText(this.href, this.sourcePath);\n    });\n  }\n  updateTitle() {\n    this.containerEl.children[0].setText(\n      renderLinkTitle(this.app, this.workspace, this.href, this.title, this.sourcePath)\n    );\n  }\n  toDOM(view: EditorView): HTMLElement {", "class LinkWidget extends WidgetType {\n  containerEl: HTMLSpanElement;\n  ref: RefTarget | null;\n\n  constructor(\n    public app: App,\n    public workspace: DendronWorkspace,\n    public sourcePath: string,\n    public href: string,\n    public title: string | undefined\n  ) {\n    super();\n  }\n\n  initDOM() {\n    this.containerEl = createSpan(\n      {\n        cls: \"cm-hmd-internal-link\",\n      },\n      (el) => {\n        el.createSpan({\n          cls: \"cm-underline\",\n        });\n      }\n    );\n    this.updateTitle();\n\n    this.containerEl.addEventListener(\"click\", () => {\n      this.app.workspace.openLinkText(this.href, this.sourcePath);\n    });\n  }\n  updateTitle() {\n    this.containerEl.children[0].setText(\n      renderLinkTitle(this.app, this.workspace, this.href, this.title, this.sourcePath)\n    );\n  }\n  toDOM(view: EditorView): HTMLElement {", "    if (!this.containerEl) this.initDOM();\n    return this.containerEl;\n  }\n}\n\ninterface LinkData {\n  start: number;\n  end: number;\n  href: string;\n  title: string | undefined;\n  hasAlias: boolean;\n  showSource: boolean;\n}\n", "export class LinkLivePlugin implements PluginValue {\n  decorations: DecorationSet = Decoration.none;\n  widgets: LinkWidget[] = [];\n\n  constructor(public app: App, public workspace: DendronWorkspace, public editorView: EditorView) {\n    this.decorations = this.buildDecorations(editorView);\n  }\n\n  update(update: ViewUpdate): void {\n    this.decorations = this.buildDecorations(update.view);\n  }\n\n  getLinks(view: EditorView) {\n    const links: LinkData[] = [];\n", "    for (const { from, to } of view.visibleRanges) {\n      let linkStart = -1;\n      let linkTitle: string | undefined = undefined;\n      let linkHref = \"\";\n      syntaxTree(view.state).iterate({\n        from,\n        to,\n        enter(node) {\n          const tokenClass = node.type.prop(tokenClassNodeProp);\n          if (!tokenClass) return;\n\n          const tokenClassList = tokenClass.split(\" \");", "          if (!tokenClass) return;\n\n          const tokenClassList = tokenClass.split(\" \");\n          if (\n            tokenClassList.contains(\"formatting-link-start\") &&\n            !tokenClassList.contains(\"formatting-embed\")\n          ) {\n            linkStart = node.from;\n          } else if (linkStart >= 0) {\n            if (tokenClassList.contains(\"hmd-internal-link\")) {\n              const text = view.state.doc.sliceString(node.from, node.to);", "          } else if (linkStart >= 0) {\n            if (tokenClassList.contains(\"hmd-internal-link\")) {\n              const text = view.state.doc.sliceString(node.from, node.to);\n              if (tokenClassList.contains(\"link-has-alias\")) {\n                linkTitle = text;\n              } else {\n                linkHref = text;\n              }\n            } else if (tokenClassList.contains(\"formatting-link-end\")) {\n              links.push({\n                start: linkStart,\n                end: node.to,\n                href: linkHref,\n                title: linkTitle,\n                hasAlias: !!linkTitle,\n                showSource: true,\n              });\n              linkStart = -1;\n              linkTitle = undefined;\n              linkHref = \"\";\n            }\n          }\n        },\n      });\n    }\n    return links;\n  }\n\n  configureLinkVisibility(links: LinkData[], view: EditorView) {\n    const prevDecorations = view.state.facet(EditorView.decorations);\n", "            } else if (tokenClassList.contains(\"formatting-link-end\")) {\n              links.push({\n                start: linkStart,\n                end: node.to,\n                href: linkHref,\n                title: linkTitle,\n                hasAlias: !!linkTitle,\n                showSource: true,\n              });\n              linkStart = -1;\n              linkTitle = undefined;\n              linkHref = \"\";\n            }\n          }\n        },\n      });\n    }\n    return links;\n  }\n\n  configureLinkVisibility(links: LinkData[], view: EditorView) {\n    const prevDecorations = view.state.facet(EditorView.decorations);\n", "    for (const decorFn of prevDecorations) {\n      if (typeof decorFn !== \"function\") continue;\n      const decor = decorFn(view);\n      const iter = decor.iter();\n\n      let found = false;\n      while (iter.value) {\n        if ((iter.value as any).isReplace) {\n          const link = links.find(({ start }) => start === iter.from);\n          if (link) {\n            found = true;\n            link.showSource = false;", "          if (link) {\n            found = true;\n            link.showSource = false;\n            if (link.hasAlias) {\n              iter.next(); // skip before pipe\n              iter.next(); // skip pipe\n              iter.next(); // skip after pipe\n            } else {\n              iter.next(); // skip text\n            }\n\n            iter.next();\n          }\n        }\n        iter.next();\n      }", "      if (found) break;\n    }\n  }\n\n  getWidget(link: LinkData, sourcePath: string) {\n    const lastWidgetIndex = this.widgets.findIndex(\n      (widget) => widget.href === link.href && widget.sourcePath === sourcePath\n    );\n    if (lastWidgetIndex >= 0) {\n      const widget = this.widgets[lastWidgetIndex];\n      widget.title = link.title;\n      widget.updateTitle();\n\n      this.widgets.splice(lastWidgetIndex, 1);\n\n      return widget;\n    }\n    return new LinkWidget(this.app, this.workspace, sourcePath, link.href, link.title);\n  }\n\n  buildDecorations(view: EditorView): DecorationSet {", "    if (lastWidgetIndex >= 0) {\n      const widget = this.widgets[lastWidgetIndex];\n      widget.title = link.title;\n      widget.updateTitle();\n\n      this.widgets.splice(lastWidgetIndex, 1);\n\n      return widget;\n    }\n    return new LinkWidget(this.app, this.workspace, sourcePath, link.href, link.title);\n  }\n\n  buildDecorations(view: EditorView): DecorationSet {", "    if (!view.state.field(editorLivePreviewField)) {\n      return Decoration.none;\n    }\n\n    const links = this.getLinks(view);\n    if (links.length === 0) return Decoration.none;\n\n    this.configureLinkVisibility(links, view);\n\n    const builder = new RangeSetBuilder<Decoration>();\n    const currentWidgets: LinkWidget[] = [];\n    const sourcePath = view.state.field(editorInfoField).file?.path ?? \"\";\n", "    for (const link of links) {\n      if (link.showSource) continue;\n\n      const widget = this.getWidget(link, sourcePath);\n      currentWidgets.push(widget);\n\n      builder.add(\n        link.start,\n        link.end,\n        Decoration.widget({\n          widget,\n        })\n      );\n    }\n\n    this.widgets = currentWidgets;\n\n    return builder.finish();\n  }\n}\n"]}
{"filename": "src/custom-resolver/link-markdown-processor.ts", "chunked_list": ["import { App, MarkdownPostProcessor } from \"obsidian\";\nimport { DendronWorkspace } from \"../engine/workspace\";\nimport { renderLinkTitle } from \"./link-render\";\n\nexport function createLinkMarkdownProcessor(\n  app: App,\n  workspace: DendronWorkspace\n): MarkdownPostProcessor {\n  return (el, ctx) => {\n    console.log();\n    const linksEl = el.querySelectorAll(\".internal-link\");\n", "    if (linksEl.length == 0) return;\n\n    const section = ctx.getSectionInfo(el);\n    const cache = app.metadataCache.getCache(ctx.sourcePath);\n\n    if (!section || !cache?.links) return;\n\n    const links = cache.links.filter(\n      (link) =>\n        link.position.start.line >= section.lineStart && link.position.end.line <= section.lineEnd\n    );\n", "    if (links.length !== linksEl.length) {\n      console.warn(\"Cannot post process link\");\n      return;\n    }\n\n    linksEl.forEach((el, index) => {\n      const link = links[index];\n      // used to check is wikilink or not\n      // aria-label and data-tooltip-position only appear when link is wikilink with alias\n      if (!link.original.startsWith(\"[[\") || !link.original.endsWith(\"]]\")) return;\n\n      let title: string | undefined, href: string;\n      const split = link.original.substring(2, link.original.length - 2).split(\"|\", 2);", "      if (!link.original.startsWith(\"[[\") || !link.original.endsWith(\"]]\")) return;\n\n      let title: string | undefined, href: string;\n      const split = link.original.substring(2, link.original.length - 2).split(\"|\", 2);\n      if (split.length == 1) href = split[0];\n      else {\n        title = split[0];\n        href = split[1];\n      }\n\n      const titleText = renderLinkTitle(app, workspace, href, title, ctx.sourcePath);\n      el.setText(titleText);\n      el.setAttribute(\"href\", href);\n      el.setAttribute(\"data-href\", href);\n      el.setAttribute(\"aria-label\", href);\n      el.setAttribute(\"data-tooltip-position\", \"top\");\n    });\n  };\n}\n"]}
{"filename": "src/custom-resolver/link-hover.ts", "chunked_list": ["import { App, HoverPopover, PagePreviewPlugin, PopoverState } from \"obsidian\";\nimport { DendronWorkspace } from \"src/engine/workspace\";\nimport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\n\nexport function createLinkHoverHandler(\n  app: App,\n  workspace: DendronWorkspace,\n  originalBoundedFunction: PagePreviewPlugin[\"onLinkHover\"]\n): PagePreviewPlugin[\"onLinkHover\"] {\n  return (parent, targetEl, link, sourcePath, state) => {\n    const ref = workspace.resolveRef(sourcePath, link);\n", "    if (!ref || ref.type !== \"maybe-note\")\n      return originalBoundedFunction(parent, targetEl, link, sourcePath, state);\n\n    if (\n      !(\n        parent.hoverPopover &&\n        parent.hoverPopover.state !== PopoverState.Hidden &&\n        parent.hoverPopover.targetEl === targetEl\n      )\n    ) {\n      const popOver = new HoverPopover(parent, targetEl);\n\n      setTimeout(async () => {", "        if (popOver.state === PopoverState.Hidden) return;\n\n        const container = popOver.hoverEl.createDiv();\n        const component = createRefRenderer(ref, app, container);\n        popOver.addChild(component);\n        if (component instanceof NoteRefRenderChild) await component.loadFile();\n\n        if (popOver.state === PopoverState.Shown) popOver.position();\n      }, 100);\n    }\n  };\n}\n"]}
{"filename": "src/custom-resolver/link-ref-clickbale.ts", "chunked_list": ["import { EditorView, PluginValue } from \"@codemirror/view\";\nimport { Editor, editorInfoField } from \"obsidian\";\n\ntype GetClickableTokenType = Required<Editor>[\"getClickableTokenAt\"];\n\nexport class LinkRefClickbale implements PluginValue {\n  static createClickableTokenAtWrapper(original: GetClickableTokenType): GetClickableTokenType {\n    return function (this: Editor, ...args) {\n      const result: ReturnType<GetClickableTokenType> = original.call(this, ...args);\n      if (result && result.type === \"internal-link\") {\n        const raw = this.getRange(result.start, result.end);\n        const split = raw.split(\"|\", 2);", "      if (result && result.type === \"internal-link\") {\n        const raw = this.getRange(result.start, result.end);\n        const split = raw.split(\"|\", 2);\n        if (split.length === 2) {\n          result.text = split[1];\n        }\n      }\n      return result;\n    };\n  }\n\n  getClickableTokenAtOrig: Editor[\"getClickableTokenAt\"];\n\n  constructor(private view: EditorView) {\n    const editor = view.state.field(editorInfoField).editor;", "    if (editor && editor.getClickableTokenAt) {\n      this.getClickableTokenAtOrig = editor.getClickableTokenAt;\n      editor.getClickableTokenAt = LinkRefClickbale.createClickableTokenAtWrapper(\n        this.getClickableTokenAtOrig\n      );\n    }\n  }\n\n  destroy(): void {\n    if (this.getClickableTokenAtOrig) {\n      const editor = this.view.state.field(editorInfoField).editor;", "    if (this.getClickableTokenAtOrig) {\n      const editor = this.view.state.field(editorInfoField).editor;\n      if (editor) {\n        editor.getClickableTokenAt = this.getClickableTokenAtOrig;\n      }\n    }\n  }\n}\n"]}
{"filename": "src/custom-resolver/index.ts", "chunked_list": ["import { Component, MarkdownPreviewRenderer, PagePreviewPlugin, Plugin, Workspace } from \"obsidian\";\nimport { DendronWorkspace } from \"../engine/workspace\";\nimport { createLinkHoverHandler } from \"./link-hover\";\nimport { ViewPlugin } from \"@codemirror/view\";\nimport { RefLivePlugin } from \"./ref-live\";\nimport { createRefMarkdownProcessor } from \"./ref-markdown-processor\";\nimport { createLinkOpenHandler } from \"./link-open\";\nimport { LinkLivePlugin } from \"./link-live\";\nimport { createLinkMarkdownProcessor } from \"./link-markdown-processor\";\nimport { LinkRefClickbale } from \"./link-ref-clickbale\";", "import { createLinkMarkdownProcessor } from \"./link-markdown-processor\";\nimport { LinkRefClickbale } from \"./link-ref-clickbale\";\n\nexport class CustomResolver extends Component {\n  pagePreviewPlugin?: PagePreviewPlugin;\n  originalLinkHover: PagePreviewPlugin[\"onLinkHover\"];\n  originalOpenLinkText: Workspace[\"openLinkText\"];\n  refPostProcessor = createRefMarkdownProcessor(this.plugin.app, this.workspace);\n  linkPostProcessor = createLinkMarkdownProcessor(this.plugin.app, this.workspace);\n  refEditorExtenstion = ViewPlugin.define((v) => {\n    return new RefLivePlugin(this.plugin.app, this.workspace);\n  });\n  linkEditorExtenstion = ViewPlugin.define(\n    (view) => {\n      return new LinkLivePlugin(this.plugin.app, this.workspace, view);\n    },\n    {\n      decorations: (value) => value.decorations,\n    }\n  );\n  linkRefClickbaleExtension = ViewPlugin.define((v) => {\n    return new LinkRefClickbale(v);\n  });\n\n  constructor(public plugin: Plugin, public workspace: DendronWorkspace) {\n    super();\n  }\n\n  onload(): void {\n    this.plugin.app.workspace.onLayoutReady(() => {\n      this.plugin.app.workspace.registerEditorExtension(this.refEditorExtenstion);\n      this.plugin.app.workspace.registerEditorExtension(this.linkEditorExtenstion);\n      this.plugin.app.workspace.registerEditorExtension(this.linkRefClickbaleExtension);\n\n      this.pagePreviewPlugin = this.plugin.app.internalPlugins.getEnabledPluginById(\"page-preview\");", "      if (!this.pagePreviewPlugin) return;\n\n      this.originalLinkHover = this.pagePreviewPlugin.onLinkHover;\n      this.pagePreviewPlugin.onLinkHover = createLinkHoverHandler(\n        this.plugin.app,\n        this.workspace,\n        this.originalLinkHover.bind(this.pagePreviewPlugin)\n      );\n    });\n\n    MarkdownPreviewRenderer.registerPostProcessor(this.refPostProcessor);\n    MarkdownPreviewRenderer.registerPostProcessor(this.linkPostProcessor);\n\n    this.originalOpenLinkText = this.plugin.app.workspace.openLinkText;\n    this.plugin.app.workspace.openLinkText = createLinkOpenHandler(\n      this.workspace,\n      this.originalOpenLinkText.bind(this.plugin.app.workspace)\n    );\n  }\n\n  onunload(): void {\n    this.plugin.app.workspace.openLinkText = this.originalOpenLinkText;\n    MarkdownPreviewRenderer.unregisterPostProcessor(this.linkPostProcessor);\n    MarkdownPreviewRenderer.unregisterPostProcessor(this.refPostProcessor);\n    this.plugin.app.workspace.unregisterEditorExtension(this.linkRefClickbaleExtension);\n    this.plugin.app.workspace.unregisterEditorExtension(this.linkEditorExtenstion);\n    this.plugin.app.workspace.unregisterEditorExtension(this.refEditorExtenstion);\n", "    if (!this.pagePreviewPlugin) return;\n    this.pagePreviewPlugin.onLinkHover = this.originalLinkHover;\n  }\n}\n"]}
{"filename": "src/custom-resolver/link-open.ts", "chunked_list": ["import { Notice, Workspace } from \"obsidian\";\nimport { anchorToLinkSubpath } from \"src/engine/ref\";\nimport { DendronWorkspace } from \"src/engine/workspace\";\n\nexport function createLinkOpenHandler(\n  workspace: DendronWorkspace,\n  originalBoundedFunction: Workspace[\"openLinkText\"]\n): Workspace[\"openLinkText\"] {\n  return async (linktext, sourcePath, newLeaf, openViewState) => {\n    const target = workspace.resolveRef(sourcePath, linktext);\n", "    if (!target || target.type !== \"maybe-note\")\n      return originalBoundedFunction(linktext, sourcePath, newLeaf, openViewState);\n\n    let file = target.note?.file;\n\n    if (!file) {\n      if (target.vaultName === \"\") {\n        new Notice(\"Vault name is unspecified in link.\");\n        return;\n      } else if (!target.vault) {\n        new Notice(`Vault ${target.vaultName} is not found.`);\n        return;", "      } else if (!target.vault) {\n        new Notice(`Vault ${target.vaultName} is not found.`);\n        return;\n      } else if (target.path === \"\") {\n        new Notice(\"Note path is unspecified in link.\");\n        return;\n      }\n\n      file = await target.vault.createNote(target.path);\n    }\n\n    let newLink = file.path;", "    if (target.subpath)\n      newLink += anchorToLinkSubpath(\n        target.subpath.start,\n        app.metadataCache.getFileCache(file)?.headings\n      );\n    return originalBoundedFunction(newLink, \"\", newLeaf, openViewState);\n  };\n}\n"]}
{"filename": "src/custom-resolver/ref-live.ts", "chunked_list": ["import { EditorView, PluginValue, ViewUpdate } from \"@codemirror/view\";\nimport { App, Component, editorLivePreviewField } from \"obsidian\";\nimport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\nimport { DendronWorkspace } from \"../engine/workspace\";\n\ninterface InternalEmbedWidget {\n  end: number;\n  href: string;\n  sourcePath: string;\n  start: string;\n  title: string;\n  children: Component[];\n  containerEl: HTMLElement;\n  hacked?: boolean;\n\n  initDOM(): HTMLElement;\n  addChild(c: Component): void;\n  applyTitle(container: HTMLElement, title: string): void;\n}\n", "export class RefLivePlugin implements PluginValue {\n  constructor(public app: App, public workspace: DendronWorkspace) {}\n\n  update(update: ViewUpdate) {\n    if (!update.state.field(editorLivePreviewField)) {\n      return;\n    }\n\n    update.view.state.facet(EditorView.decorations).forEach((d) => {\n      if (typeof d !== \"function\") {\n        const iter = d.iter();", "      if (typeof d !== \"function\") {\n        const iter = d.iter();\n        while (iter.value) {\n          const widget = iter.value.spec.widget;\n          if (widget && widget.href && widget.sourcePath && widget.title) {\n            const internalWidget = widget as InternalEmbedWidget;\n            this.hack(internalWidget);\n          }\n          iter.next();\n        }\n      }\n    });\n  }\n\n  hack(widget: InternalEmbedWidget) {", "    if (widget.hacked) {\n      return;\n    }\n    widget.hacked = true;\n\n    const target = this.workspace.resolveRef(widget.sourcePath, widget.href);\n\n    if (!target || target.type !== \"maybe-note\") return;\n\n    const loadComponent = (widget: InternalEmbedWidget) => {\n      const renderer = createRefRenderer(target, this.app, widget.containerEl);", "      if (renderer instanceof NoteRefRenderChild) renderer.loadFile();\n      widget.addChild(renderer);\n    };\n\n    widget.initDOM = function (this: InternalEmbedWidget) {\n      this.containerEl = createDiv(\"internal-embed\");\n      loadComponent(this);\n      return this.containerEl;\n    };\n\n    widget.applyTitle = function (\n      this: InternalEmbedWidget,\n      container: HTMLElement,\n      title: string\n    ) {\n      this.title = title;\n    };\n", "    if (widget.containerEl) {\n      console.log(\"Workaround\");\n      widget.children[0].unload();\n      widget.children.pop();\n      loadComponent(widget);\n    }\n  }\n}\n"]}
{"filename": "src/custom-resolver/ref-markdown-processor.ts", "chunked_list": ["import { DendronWorkspace } from \"../engine/workspace\";\nimport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\nimport { App, MarkdownPostProcessor } from \"obsidian\";\n\nexport function createRefMarkdownProcessor(\n  app: App,\n  workspace: DendronWorkspace\n): MarkdownPostProcessor {\n  return (element, context) => {\n    const embeddedItems = element.querySelectorAll(\".internal-embed\");\n    const promises: Promise<void>[] = [];\n    embeddedItems.forEach((el) => {\n      const link = el.getAttribute(\"src\");", "      if (!link) return;\n\n      const target = workspace.resolveRef(context.sourcePath, link);\n      if (!target || target.type !== \"maybe-note\") return;\n\n      const renderer = createRefRenderer(target, app, el as HTMLElement);\n      if (renderer instanceof NoteRefRenderChild) promises.push(renderer.loadFile());\n\n      context.addChild(renderer);\n    });\n    return Promise.all(promises);\n  };\n}\n"]}
