{"filename": "types/config.d.ts", "chunked_list": ["interface SESSIONS {\n    [key: string]: ColfSession\n}\n\ninterface Config {\n    INGAME_NAME: string\n    WEBHOOK_URL: string\n    FLIP_ACTION_DELAY: number\n    USE_COFL_CHAT: boolean\n    ENABLE_CONSOLE_INPUT: boolean\n    SESSIONS: SESSIONS\n    USE_WINDOW_SKIPS: boolean\n}\n", "interface ColfSession {\n    id: string\n    expires: Date\n}\n"]}
{"filename": "types/fastWindowClick.d.ts", "chunked_list": ["interface FastWindowClicker {\n    clickPurchase(price: number, windowId: number): void\n    clickBedPurchase(price: number, windowId: number): void\n    clickConfirm(price: number, itemName: string, windowId: number): void\n    onAuctionWasAlreadyBought(): void\n    getLastWindowId(): number\n}\n"]}
{"filename": "types/webhook.d.ts", "chunked_list": ["interface Webhook {\n    content: string\n    username?: string\n    avatar_url: string\n    tts: boolean\n    embeds?: Array<Embed>\n}\n\ninterface Embed {\n    title: string\n    description?: string\n    url?: string\n    timestamp?: number\n    color?: number\n    footer?: EmbedFooter\n    image?: string\n    thumbnail?: EmbedThumbnail\n    author?: EmbedAuthor\n    fields?: Array<EmbedField>\n}\n", "interface Embed {\n    title: string\n    description?: string\n    url?: string\n    timestamp?: number\n    color?: number\n    footer?: EmbedFooter\n    image?: string\n    thumbnail?: EmbedThumbnail\n    author?: EmbedAuthor\n    fields?: Array<EmbedField>\n}\n", "interface EmbedFooter {\n    text: string\n    icon_url?: string\n}\n\ninterface EmbedAuthor {\n    name: string\n    url?: string\n    icon_url?: string\n}\n", "interface EmbedField {\n    name: string\n    value: string\n    inline: boolean\n}\n\ninterface EmbedThumbnail {\n    url: string\n    proxy_url?: string\n    height?: number\n    width?: number\n}\n"]}
{"filename": "types/autobuy.d.ts", "chunked_list": ["import { Bot } from 'mineflayer'\n\ninterface SellData {\n    price: number\n    slot: number\n    duration: number\n    itemName: string\n    id: string\n}\n\ninterface TradeData {\n    target: string\n    slots: number[]\n    coins: number\n}\n", "interface TradeData {\n    target: string\n    slots: number[]\n    coins: number\n}\n\ninterface SwapData {\n    profile: string\n}\n\ninterface Flip {\n    id: string\n    startingBid: number\n    purchaseAt: Date\n    itemName: string\n    target: number\n}\n", "interface Flip {\n    id: string\n    startingBid: number\n    purchaseAt: Date\n    itemName: string\n    target: number\n}\n\ninterface TextMessageData {\n    text: string\n}\n", "interface TextMessageData {\n    text: string\n}\n\ninterface MyBot extends Bot {\n    state?: 'purchasing' | 'selling' | 'claiming' | 'gracePeriod'\n    lastViewAuctionCommandForPurchase?: string\n    privacySettings?: any\n}\n"]}
{"filename": "src/swapProfileHandler.ts", "chunked_list": ["import { MyBot, SwapData } from '../types/autobuy'\nimport { log } from './logger'\nimport { clickWindow, getWindowTitle } from './utils'\n\nexport async function swapProfile(bot: MyBot, data: SwapData) {\n    bot.setQuickBarSlot(8)\n    bot.activateItem()\n    bot.on('windowOpen', window => {\n        let title = getWindowTitle(window)\n        if (title == 'SkyBlock Menu') {\n            clickWindow(bot, 48)\n        }", "        if (title == 'SkyBlock Menu') {\n            clickWindow(bot, 48)\n        }\n        if (title == 'Profile Management') {\n            let clickSlot\n            window.slots.forEach(item => {\n                if (item && (item.nbt.value as any).display.value.Name.value.includes((data as SwapData).profile)) clickSlot = item.slot\n            })\n            log('Clickslot is ' + clickSlot)\n            clickWindow(bot, clickSlot)\n        }", "        if (title.includes('Profile:')) {\n            clickWindow(bot, 11)\n            log('Successfully swapped profiles')\n        }\n    })\n}\n"]}
{"filename": "src/AFKHandler.ts", "chunked_list": ["import { ScoreBoard } from 'mineflayer'\nimport { MyBot } from '../types/autobuy'\nimport { printMcChatToConsole, log } from './logger'\nimport { sleep } from './utils'\n\nexport function initAFKHandler(bot: MyBot) {\n    let consecutiveTeleportAttempts = 0\n    registerCheckInverval()\n\n    function registerCheckInverval() {\n        setTimeout(async () => {\n            let teleportWasTried = await tryToTeleportToIsland(bot)", "    function registerCheckInverval() {\n        setTimeout(async () => {\n            let teleportWasTried = await tryToTeleportToIsland(bot)\n            if (teleportWasTried) {\n                consecutiveTeleportAttempts++\n                log(`ConsecutiveTeleportAttemps: ${consecutiveTeleportAttempts}`)\n                registerCheckInverval()\n            } else {\n                consecutiveTeleportAttempts = 0\n                registerCheckInverval()\n            }\n        }, 10000 * (consecutiveTeleportAttempts + 1))\n    }\n}\n", "export async function tryToTeleportToIsland(bot: MyBot, delayBeforeTeleport = 5000) {\n    if (isLimbo(bot.scoreboard.sidebar)) {\n        await sleep(delayBeforeTeleport)\n        log('Bot seems to be in limbo. Sending \"/lobby\"')\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fYou seem to be in limbo.')\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fWarping back to lobby...')\n        bot.chat('/lobby')\n        return true\n    }\n\n    if (\n        !bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')).find(e => e.includes('Purse:') || e.includes('Piggy:'))\n    ) {\n        await sleep(delayBeforeTeleport)\n        log(`Bot seems to be in lobby (Sidebar title = ${bot.scoreboard.sidebar.title}). Sending \"/play sb\"`)\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fYou seem to be in the lobby.')\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fWarping back into skyblock...')\n        bot.chat('/play sb')\n        return true\n    }\n\n    let scoreboard = bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, ''))", "    if (\n        !bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')).find(e => e.includes('Purse:') || e.includes('Piggy:'))\n    ) {\n        await sleep(delayBeforeTeleport)\n        log(`Bot seems to be in lobby (Sidebar title = ${bot.scoreboard.sidebar.title}). Sending \"/play sb\"`)\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fYou seem to be in the lobby.')\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fWarping back into skyblock...')\n        bot.chat('/play sb')\n        return true\n    }\n\n    let scoreboard = bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, ''))", "    if (!scoreboard.find(e => e.includes('Your Island'))) {\n        await sleep(delayBeforeTeleport)\n        log('Bot is not on island. Warping back')\n        log(bot.scoreboard)\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fYou seem to not be on your island.')\n        printMcChatToConsole('\u00a7f[\u00a74BAF\u00a7f]: \u00a7fWarping back to island...')\n        bot.chat('/is')\n        return true\n    }\n    return false\n}\n", "function isLimbo(sidebar: ScoreBoard) {\n    let isLimbo = true\n    sidebar.items.forEach(item => {\n        if (item.displayName.getText(null).replace(item.name, '') !== '') {\n            isLimbo = false\n        }\n    })\n    return isLimbo\n}\n"]}
{"filename": "src/coflSessionManager.ts", "chunked_list": ["import { getConfigProperty, updatePersistentConfigProperty } from './configHelper'\nimport crypto from 'crypto'\n\nconst SESSIONS_KEY = 'SESSIONS'\n\nexport function getSessionId(username: string): string {\n    let sessions = getConfigProperty(SESSIONS_KEY) as SESSIONS\n\n    if (!sessions) {\n        sessions = {}\n        updatePersistentConfigProperty(SESSIONS_KEY, {})\n    }\n", "    if (!sessions) {\n        sessions = {}\n        updatePersistentConfigProperty(SESSIONS_KEY, {})\n    }\n\n    if (!sessions[username]) {\n        sessions[username] = {\n            id: crypto.randomUUID(),\n            expires: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 180)\n        }\n        updatePersistentConfigProperty(SESSIONS_KEY, sessions)\n    }\n", "    if (isExpired(sessions[username].expires)) {\n        delete sessions[username]\n        updatePersistentConfigProperty(SESSIONS_KEY, sessions)\n        return null\n    } else {\n        return sessions[username].id\n    }\n}\n\nexport function isExpired(date: Date) {\n    return date.getTime() < new Date().getTime()\n}\n", "export function isExpired(date: Date) {\n    return date.getTime() < new Date().getTime()\n}\n"]}
{"filename": "src/consoleHandler.ts", "chunked_list": ["import readline from 'readline'\nimport { getConfigProperty } from './configHelper'\n\nexport function setupConsoleInterface(ws: WebSocket) {\n    if (!getConfigProperty('ENABLE_CONSOLE_INPUT')) {\n        return\n    }\n\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    })\n\n    rl.on('line', input => {", "        if (input?.startsWith('/cofl') && input?.split(' ').length >= 2) {\n            let splits = input.split(' ')\n            splits.shift() // remove /cofl\n            let command = splits.shift()\n\n            ws.send(\n                JSON.stringify({\n                    type: command,\n                    data: `\"${splits.join(' ')}\"`\n                })\n            )\n        } else {\n            ws.send(\n                JSON.stringify({\n                    type: 'chat',\n                    data: `\"${input}\"`\n                })\n            )\n        }\n    })\n}\n"]}
{"filename": "src/ingameMessageHandler.ts", "chunked_list": ["import { MyBot } from '../types/autobuy'\nimport { log, printMcChatToConsole } from './logger'\nimport { clickWindow, getWindowTitle } from './utils'\nimport { ChatMessage } from 'prismarine-chat'\nimport { sendWebhookItemPurchased, sendWebhookItemSold } from './webhookHandler'\n\nexport function registerIngameMessageHandler(bot: MyBot, wss: WebSocket) {\n    bot.on('message', (message: ChatMessage, type) => {\n        let text = message.getText(null)\n        if (type == 'chat') {\n            printMcChatToConsole(message.toAnsi())", "        if (type == 'chat') {\n            printMcChatToConsole(message.toAnsi())\n            if (text.startsWith('You purchased')) {\n                wss.send(\n                    JSON.stringify({\n                        type: 'uploadTab',\n                        data: JSON.stringify(Object.keys(bot.players).map(playername => bot.players[playername].displayName.getText(null)))\n                    })\n                )\n                wss.send(\n                    JSON.stringify({\n                        type: 'uploadScoreboard',\n                        data: JSON.stringify(bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')))\n                    })\n                )\n                claimPurchased(bot)\n\n                sendWebhookItemPurchased(text.split(' purchased ')[1].split(' for ')[0], text.split(' for ')[1].split(' coins!')[0])\n            }", "            if (text.startsWith('[Auction]') && text.includes('bought') && text.includes('for')) {\n                log('New item sold')\n                claimSoldItem(bot, text.split(' bought ')[1].split(' for ')[0])\n\n                sendWebhookItemSold(\n                    text.split(' bought ')[1].split(' for ')[0],\n                    text.split(' for ')[1].split(' coins')[0],\n                    text.split('[Auction] ')[1].split(' bought ')[0]\n                )\n            }\n            if (bot.privacySettings && bot.privacySettings.chatRegex.test(text)) {\n                wss.send(\n                    JSON.stringify({\n                        type: 'chatBatch',\n                        data: JSON.stringify([text])\n                    })\n                )\n            }\n        }\n    })\n}\n", "            if (bot.privacySettings && bot.privacySettings.chatRegex.test(text)) {\n                wss.send(\n                    JSON.stringify({\n                        type: 'chatBatch',\n                        data: JSON.stringify([text])\n                    })\n                )\n            }\n        }\n    })\n}\n", "function claimPurchased(bot: MyBot) {\n    if (bot.state) {\n        log('Currently busy with something else (' + bot.state + ') -> not claiming purchased item')\n        setTimeout(() => {\n            claimPurchased(bot)\n        }, 1000)\n        return\n    }\n    bot.state = 'claiming'\n    bot.chat('/ah')\n\n    setTimeout(() => {\n        log('Claiming of purchased auction failed. Removing lock')\n        bot.state = null\n    }, 5000)\n\n    bot.on('windowOpen', window => {\n        let title = getWindowTitle(window)\n        log('Claiming auction window: ' + title)\n", "        if (title.toString().includes('Auction House')) {\n            clickWindow(bot, 13)\n        }\n\n        if (title.toString().includes('Your Bids')) {\n            let slotToClick = -1\n            for (let i = 0; i < window.slots.length; i++) {\n                const slot = window.slots[i]\n                let name = (slot?.nbt as any)?.value?.display?.value?.Name?.value?.toString()\n                if (slot?.type === 380 && name?.includes('Claim') && name?.includes('All')) {\n                    log('Found cauldron to claim all purchased auctions -> clicking index ' + i)\n                    clickWindow(bot, i)\n                    bot.removeAllListeners('windowOpen')\n                    bot.state = null\n                    return\n                }\n                let lore = (slot?.nbt as any)?.value?.display?.value?.Lore?.value?.value?.toString()", "                if (slot?.type === 380 && name?.includes('Claim') && name?.includes('All')) {\n                    log('Found cauldron to claim all purchased auctions -> clicking index ' + i)\n                    clickWindow(bot, i)\n                    bot.removeAllListeners('windowOpen')\n                    bot.state = null\n                    return\n                }\n                let lore = (slot?.nbt as any)?.value?.display?.value?.Lore?.value?.value?.toString()\n                if (lore?.includes('Status:') && lore?.includes('Sold!')) {\n                    log('Found claimable purchased auction. Gonna click index ' + i)\n                    log(JSON.stringify(slot))\n                    slotToClick = i\n                }\n            }\n            clickWindow(bot, slotToClick)\n        }\n", "                if (lore?.includes('Status:') && lore?.includes('Sold!')) {\n                    log('Found claimable purchased auction. Gonna click index ' + i)\n                    log(JSON.stringify(slot))\n                    slotToClick = i\n                }\n            }\n            clickWindow(bot, slotToClick)\n        }\n\n        if (title.toString().includes('BIN Auction View')) {\n            if (!window.slots[31]) {\n                log('Weird error trying to claim purchased auction', 'warn')\n                log(window.title)\n                log(JSON.stringify(window.slots))\n                bot.removeAllListeners('windowOpen')\n                bot.state = null\n                return\n            }", "        if (title.toString().includes('BIN Auction View')) {\n            if (!window.slots[31]) {\n                log('Weird error trying to claim purchased auction', 'warn')\n                log(window.title)\n                log(JSON.stringify(window.slots))\n                bot.removeAllListeners('windowOpen')\n                bot.state = null\n                return\n            }\n            if (window.slots[31].name.includes('gold_block')) {\n                log('Claiming purchased auction...')\n                clickWindow(bot, 31)\n            }\n            bot.removeAllListeners('windowOpen')\n            bot.state = null\n        }\n    })\n}\n", "            if (window.slots[31].name.includes('gold_block')) {\n                log('Claiming purchased auction...')\n                clickWindow(bot, 31)\n            }\n            bot.removeAllListeners('windowOpen')\n            bot.state = null\n        }\n    })\n}\n\nasync function claimSoldItem(bot: MyBot, itemName: string) {", "async function claimSoldItem(bot: MyBot, itemName: string) {\n    if (bot.state) {\n        log('Currently busy with something else (' + bot.state + ') -> not claiming sold item')\n        setTimeout(() => {\n            claimSoldItem(bot, itemName)\n        }, 1000)\n        return\n    }\n\n    let timeout = setTimeout(() => {\n        log('Seems something went wrong while claiming sold item. Removing lock')\n        bot.state = null\n        bot.removeAllListeners('windowOpen')\n    }, 10000)\n\n    bot.state = 'claiming'\n    bot.chat('/ah')\n\n    bot.on('windowOpen', window => {\n        let title = getWindowTitle(window)", "        if (title.toString().includes('Auction House')) {\n            clickWindow(bot, 15)\n        }\n        if (title.toString().includes('Manage Auctions')) {\n            log('Claiming sold auction...')\n            let clickSlot\n\n            for (let i = 0; i < window.slots.length; i++) {\n                const item = window.slots[i] as any\n                if (item?.nbt?.value?.display?.value?.Lore && JSON.stringify(item.nbt.value.display.value.Lore).includes('Sold for')) {\n                    clickSlot = item.slot\n                }", "                if (item?.nbt?.value?.display?.value?.Lore && JSON.stringify(item.nbt.value.display.value.Lore).includes('Sold for')) {\n                    clickSlot = item.slot\n                }\n                if (item && item.type === 380 && (item.nbt as any).value?.display?.value?.Name?.value?.toString().includes('Claim All')) {\n                    log(item)\n                    log('Found cauldron to claim all sold auctions -> clicking index ' + item.slot)\n                    clickWindow(bot, item.slot)\n                    clearTimeout(timeout)\n                    bot.removeAllListeners('windowOpen')\n                    bot.state = null\n                    return\n                }\n            }\n\n            log('Clicking auction to claim, index: ' + clickSlot)\n            log(JSON.stringify(window.slots[clickSlot]))\n\n            clickWindow(bot, clickSlot)\n        }", "        if (title == 'BIN Auction View') {\n            if (window.slots[31].name.includes('gold_block')) {\n                log('Clicking slot 31, claiming purchased auction')\n                clickWindow(bot, 31)\n            }\n            clearTimeout(timeout)\n            bot.removeAllListeners('windowOpen')\n            bot.state = null\n        }\n    })\n}\n"]}
{"filename": "src/flipHandler.ts", "chunked_list": ["import { Flip, MyBot } from '../types/autobuy'\nimport { getConfigProperty } from './configHelper'\nimport { getFastWindowClicker } from './fastWindowClick'\nimport { log, printMcChatToConsole } from './logger'\nimport { clickWindow, getWindowTitle, numberWithThousandsSeparators, sleep } from './utils'\n\nexport async function flipHandler(bot: MyBot, flip: Flip) {\n    flip.purchaseAt = new Date(flip.purchaseAt)\n\n    if (bot.state) {\n        setTimeout(() => {\n            flipHandler(bot, flip)\n        }, 1100)\n        return\n    }\n    bot.state = 'purchasing'\n    let timeout = setTimeout(() => {", "    if (bot.state) {\n        setTimeout(() => {\n            flipHandler(bot, flip)\n        }, 1100)\n        return\n    }\n    bot.state = 'purchasing'\n    let timeout = setTimeout(() => {\n        if (bot.state === 'purchasing') {\n            log(\"Resetting 'bot.state === purchasing' lock\")\n            bot.state = null\n            bot.removeAllListeners('windowOpen')\n        }\n    }, 10000)\n    let isBed = flip.purchaseAt.getTime() > new Date().getTime()\n    let delayUntilBuyStart = isBed ? flip.purchaseAt.getTime() - new Date().getTime() : getConfigProperty('FLIP_ACTION_DELAY')\n\n    bot.lastViewAuctionCommandForPurchase = `/viewauction ${flip.id}`\n    await sleep(delayUntilBuyStart)\n    bot.chat(bot.lastViewAuctionCommandForPurchase)\n\n    printMcChatToConsole(\n        `\u00a7f[\u00a74BAF\u00a7f]: \u00a7fTrying to purchase flip${isBed ? ' (Bed)' : ''}: ${flip.itemName} \u00a7for ${numberWithThousandsSeparators(\n            flip.startingBid\n        )} coins (Target: ${numberWithThousandsSeparators(flip.target)})`\n    )\n", "        if (bot.state === 'purchasing') {\n            log(\"Resetting 'bot.state === purchasing' lock\")\n            bot.state = null\n            bot.removeAllListeners('windowOpen')\n        }\n    }, 10000)\n    let isBed = flip.purchaseAt.getTime() > new Date().getTime()\n    let delayUntilBuyStart = isBed ? flip.purchaseAt.getTime() - new Date().getTime() : getConfigProperty('FLIP_ACTION_DELAY')\n\n    bot.lastViewAuctionCommandForPurchase = `/viewauction ${flip.id}`\n    await sleep(delayUntilBuyStart)\n    bot.chat(bot.lastViewAuctionCommandForPurchase)\n\n    printMcChatToConsole(\n        `\u00a7f[\u00a74BAF\u00a7f]: \u00a7fTrying to purchase flip${isBed ? ' (Bed)' : ''}: ${flip.itemName} \u00a7for ${numberWithThousandsSeparators(\n            flip.startingBid\n        )} coins (Target: ${numberWithThousandsSeparators(flip.target)})`\n    )\n", "    if (getConfigProperty('USE_WINDOW_SKIPS')) {\n        useWindowSkipPurchase(flip, isBed)\n\n        // clear timeout after 1sec, so there are no weird overlaps that mess up the windowIds\n        setTimeout(() => {\n            bot.state = null\n            clearTimeout(timeout)\n        }, 2500)\n    } else {\n        useRegularPurchase(bot)\n    }\n}\n", "async function useRegularPurchase(bot: MyBot) {\n    bot.addListener('windowOpen', async window => {\n        let title = getWindowTitle(window)\n        if (title.toString().includes('BIN Auction View')) {\n            await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n            clickWindow(bot, 31)\n        }\n        if (title.toString().includes('Confirm Purchase')) {\n            await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n            clickWindow(bot, 11)\n            bot.removeAllListeners('windowOpen')\n            bot.state = null\n            return\n        }\n    })\n}\n", "async function useWindowSkipPurchase(flip: Flip, isBed: boolean) {\n    let lastWindowId = getFastWindowClicker().getLastWindowId()\n\n    if (isBed) {\n        getFastWindowClicker().clickBedPurchase(flip.startingBid, lastWindowId + 1)\n    } else {\n        getFastWindowClicker().clickPurchase(flip.startingBid, lastWindowId + 1)\n    }\n    await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n    getFastWindowClicker().clickConfirm(flip.startingBid, flip.itemName, lastWindowId + 2)\n}\n"]}
{"filename": "src/BAF.ts", "chunked_list": ["import { ScoreBoard } from 'mineflayer'\nimport { createBot } from 'mineflayer'\nimport { createFastWindowClicker } from './fastWindowClick'\nimport { addLoggerToClientWriteFunction, initLogger, log, printMcChatToConsole } from './logger'\nimport { clickWindow, isCoflChatMessage, removeMinecraftColorCodes, sleep } from './utils'\nimport { onWebsocketCreateAuction } from './sellHandler'\nimport { tradePerson } from './tradeHandler'\nimport { swapProfile } from './swapProfileHandler'\nimport { flipHandler } from './flipHandler'\nimport { registerIngameMessageHandler } from './ingameMessageHandler'", "import { flipHandler } from './flipHandler'\nimport { registerIngameMessageHandler } from './ingameMessageHandler'\nimport { MyBot, TextMessageData } from '../types/autobuy'\nimport { getConfigProperty, initConfigHelper, updatePersistentConfigProperty } from './configHelper'\nimport { getSessionId } from './coflSessionManager'\nimport { sendWebhookInitialized } from './webhookHandler'\nimport { setupConsoleInterface } from './consoleHandler'\nimport { initAFKHandler, tryToTeleportToIsland } from './AFKHandler'\nconst WebSocket = require('ws')\nvar prompt = require('prompt-sync')()", "const WebSocket = require('ws')\nvar prompt = require('prompt-sync')()\ninitConfigHelper()\ninitLogger()\nconst version = '1.5.0-af'\nlet wss: WebSocket\nlet ingameName = getConfigProperty('INGAME_NAME')\n\nif (!ingameName) {\n    ingameName = prompt('Enter your ingame name: ')\n    updatePersistentConfigProperty('INGAME_NAME', ingameName)\n}\n\nconst bot: MyBot = createBot({\n    username: ingameName,\n    auth: 'microsoft',\n    logErrors: true,\n    version: '1.17',\n    host: 'mc.hypixel.net'\n})\nbot.setMaxListeners(0)\n\nbot.state = 'gracePeriod'\ncreateFastWindowClicker(bot._client)\n", "if (!ingameName) {\n    ingameName = prompt('Enter your ingame name: ')\n    updatePersistentConfigProperty('INGAME_NAME', ingameName)\n}\n\nconst bot: MyBot = createBot({\n    username: ingameName,\n    auth: 'microsoft',\n    logErrors: true,\n    version: '1.17',\n    host: 'mc.hypixel.net'\n})\nbot.setMaxListeners(0)\n\nbot.state = 'gracePeriod'\ncreateFastWindowClicker(bot._client)\n", "if (getConfigProperty('LOG_PACKAGES')) {\n    addLoggerToClientWriteFunction(bot._client)\n}\n\nbot.once('login', connectWebsocket)\nbot.once('spawn', async () => {\n    await bot.waitForChunksToLoad()\n    await sleep(2000)\n    bot.chat('/play sb')\n    bot.on('scoreboardTitleChanged', onScoreboardChanged)\n    registerIngameMessageHandler(bot, wss)\n})\n", "function connectWebsocket() {\n    wss = new WebSocket(`wss://sky.coflnet.com/modsocket?player=${ingameName}&version=${version}&SId=${getSessionId(ingameName)}`)\n    wss.onopen = function () {\n        setupConsoleInterface(wss)\n        sendWebhookInitialized()\n    }\n    wss.onmessage = onWebsocketMessage\n    wss.onclose = function (e) {\n        log('Connection closed. Reconnecting... ', 'warn')\n        setTimeout(function () {\n            connectWebsocket()\n        }, 1000)\n    }\n    wss.onerror = function (err) {\n        log('Connection error: ' + JSON.stringify(err), 'error')\n        wss.close()\n    }\n}\n", "async function onWebsocketMessage(msg) {\n    let message = JSON.parse(msg.data)\n    let data = JSON.parse(message.data)\n\n    switch (message.type) {\n        case 'flip':\n            log(message, 'debug')\n            flipHandler(bot, data)\n            break\n        case 'chatMessage':\n            for (let da of [...(data as TextMessageData[])]) {\n                let isCoflChat = isCoflChatMessage(da.text)", "            for (let da of [...(data as TextMessageData[])]) {\n                let isCoflChat = isCoflChatMessage(da.text)\n                if (!isCoflChat) {\n                    log(message, 'debug')\n                }\n                if (getConfigProperty('USE_COFL_CHAT') || !isCoflChat) {\n                    printMcChatToConsole(da.text)\n                }\n            }\n            break\n        case 'writeToChat':\n            let isCoflChat = isCoflChatMessage(data.text)", "            if (!isCoflChat) {\n                log(message, 'debug')\n            }\n            if (getConfigProperty('USE_COFL_CHAT') || !isCoflChat) {\n                printMcChatToConsole((data as TextMessageData).text)\n            }\n            break\n        case 'swapProfile':\n            log(message, 'debug')\n            swapProfile(bot, data)\n            break\n        case 'createAuction':\n            log(message, 'debug')\n            onWebsocketCreateAuction(bot, data)\n            break\n        case 'trade':\n            log(message, 'debug')\n            tradePerson(bot, wss, data)\n            break\n        case 'tradeResponse':\n            let tradeDisplay = (bot.currentWindow.slots[39].nbt.value as any).display.value.Name.value", "            if (tradeDisplay.includes('Deal!') || tradeDisplay.includes('Warning!')) {\n                await sleep(3400)\n            }\n            clickWindow(bot, 39)\n            break\n        case 'getInventory':\n            log('Uploading inventory...')\n            wss.send(\n                JSON.stringify({\n                    type: 'uploadInventory',\n                    data: JSON.stringify(bot.inventory)\n                })\n            )\n            break\n        case 'execute':\n            log(message, 'debug')\n            bot.chat(data)\n            break\n        case 'privacySettings':\n            log(message, 'debug')\n            data.chatRegex = new RegExp(data.chatRegex)\n            bot.privacySettings = data\n            break\n    }\n}\n", "async function onScoreboardChanged() {\n    if (\n        bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')).find(e => e.includes('Purse:') || e.includes('Piggy:'))\n    ) {\n        bot.removeListener('scoreboardTitleChanged', onScoreboardChanged)\n        log('Joined SkyBlock')\n        initAFKHandler(bot)\n        setTimeout(() => {\n            log('Waited for grace period to end. Flips can now be bought.')\n            bot.state = null\n            bot.removeAllListeners('scoreboardTitleChanged')\n\n            wss.send(\n                JSON.stringify({\n                    type: 'uploadScoreboard',\n                    data: JSON.stringify(bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')))\n                })\n            )\n        }, 5500)\n        await sleep(2500)\n        tryToTeleportToIsland(bot, 0)\n    }\n}\n"]}
{"filename": "src/tradeHandler.ts", "chunked_list": ["import { MyBot, TradeData } from '../types/autobuy'\nimport { log } from './logger'\nimport { clickWindow, sleep } from './utils'\n\nexport async function tradePerson(bot: MyBot, websocket: WebSocket, data: TradeData) {\n    let addedCoins = false\n    let addedItems = false\n    let trading = true\n    while (trading) {\n        bot.chat('/trade ' + data.target)\n\n        bot.on('message', async msgE => {\n            let msg = msgE.getText(null)\n", "    while (trading) {\n        bot.chat('/trade ' + data.target)\n\n        bot.on('message', async msgE => {\n            let msg = msgE.getText(null)\n\n            if (msg == 'You cannot trade while the server is lagging!') {\n                bot.chat('The server is lagging, give it a second')\n                await sleep(5000)\n            } else if (msg.startsWith('Cannot find player named')) {\n                log('Player is not avaliable to trade with, please rerequest when they are capable of trading')\n                trading = false\n                return", "            } else if (msg.startsWith('Cannot find player named')) {\n                log('Player is not avaliable to trade with, please rerequest when they are capable of trading')\n                trading = false\n                return\n            } else if (msg == 'You are too far away to trade with that player!') {\n                bot.chat('Hey ' + data.target + ' come here so we can trade!')\n            } else if (msg.startsWith('You have sent a trade request to ')) {\n                log('successfully sent trade, waiting for them to accept')\n                bot.on('windowOpen', async window => {\n                    trading = false\n\n                    log('Trade window opened')", "                    if (!addedItems) {\n                        for (let slot of data.slots) {\n                            slot += 44\n                            clickWindow(bot, slot)\n                            log('Clicked slot ' + slot)\n                        }\n                        log('Added all items')\n                    }\n                    if (data.coins > 0 && !addedCoins) {\n                        bot._client.once('open_sign_entity', ({ location }) => {\n                            let price = data.coins\n                            log('New sign entity')\n                            log('price to set ' + Math.floor(price).toString())\n                            bot._client.write('update_sign', {\n                                location: {\n                                    x: location.z,\n                                    y: location.y,\n                                    z: location.z\n                                },\n                                text1: `\\\"${Math.floor(price).toString()}\\\"`,\n                                text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n                                text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n                                text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n                            })\n                            addedCoins = true\n                        })\n                        clickWindow(bot, 36)\n                    }", "                    if (data.coins > 0 && !addedCoins) {\n                        bot._client.once('open_sign_entity', ({ location }) => {\n                            let price = data.coins\n                            log('New sign entity')\n                            log('price to set ' + Math.floor(price).toString())\n                            bot._client.write('update_sign', {\n                                location: {\n                                    x: location.z,\n                                    y: location.y,\n                                    z: location.z\n                                },\n                                text1: `\\\"${Math.floor(price).toString()}\\\"`,\n                                text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n                                text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n                                text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n                            })\n                            addedCoins = true\n                        })\n                        clickWindow(bot, 36)\n                    }", "                    if (!(data.coins > 0) || addedCoins) {\n                        websocket.send(JSON.stringify({ type: 'affirmFlip', data: [JSON.stringify(window.slots)] }))\n                    }\n                })\n            }\n        })\n\n        await sleep(5000)\n    }\n}\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import { Client, PacketMeta } from 'minecraft-protocol'\nimport winston from 'winston'\nimport { getConfigProperty } from './configHelper'\nlet fs = require('fs')\nlet path = require('path')\nlet logFilePath = path.join((process as any).pkg ? process.argv[0] : process.argv[1], '..')\n\nlet logger: winston.Logger\n\nexport function initLogger() {\n    const loggerConfig = {\n        format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n        transports: [],\n        exceptionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })],\n        rejectionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })]\n    }\n    loggerConfig.transports.push(\n        new winston.transports.File({\n            dirname: logFilePath,\n            filename: 'log.txt',\n            level: 'debug',\n            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n            options: {\n                flags: 'w'\n            }\n        })\n    )\n    loggerConfig.transports.push(\n        new winston.transports.Console({\n            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n            level: 'none'\n        })\n    )\n    logger = winston.createLogger(loggerConfig)\n}\n", "\nexport function initLogger() {\n    const loggerConfig = {\n        format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n        transports: [],\n        exceptionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })],\n        rejectionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })]\n    }\n    loggerConfig.transports.push(\n        new winston.transports.File({\n            dirname: logFilePath,\n            filename: 'log.txt',\n            level: 'debug',\n            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n            options: {\n                flags: 'w'\n            }\n        })\n    )\n    loggerConfig.transports.push(\n        new winston.transports.Console({\n            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n            level: 'none'\n        })\n    )\n    logger = winston.createLogger(loggerConfig)\n}\n", "export function log(string: any, level?: string) {\n    logger.log(level || 'info', string)\n}\n\nexport function logPacket(packet: any, packetMeta: PacketMeta, toServer: boolean) {\n    if (!getConfigProperty('LOG_PACKAGES')) {\n        return\n    }\n\n    if (packetMeta.name !== 'window_click' && packetMeta.name !== 'open_window' && packetMeta.name !== 'window_items') {\n        return\n    }\n\n    fs.writeFileSync(\n        'packets.log',\n        `${toServer ? 'toServer' : 'toClient'}: ${JSON.stringify(packet)}\\n${JSON.stringify(packetMeta)}\\n----------------------------------------------\\n`,\n        { flag: 'a+' }\n    )\n}\n", "    if (packetMeta.name !== 'window_click' && packetMeta.name !== 'open_window' && packetMeta.name !== 'window_items') {\n        return\n    }\n\n    fs.writeFileSync(\n        'packets.log',\n        `${toServer ? 'toServer' : 'toClient'}: ${JSON.stringify(packet)}\\n${JSON.stringify(packetMeta)}\\n----------------------------------------------\\n`,\n        { flag: 'a+' }\n    )\n}\n", "export function printMcChatToConsole(string: string) {\n    let msg = ''\n    let split = string.split('\u00a7')\n    msg += split[0]\n    for (let a of string.split('\u00a7').slice(1, split.length)) {\n        let color = a.charAt(0)\n        let message\n\n        if (Object.keys(colors).includes(color)) {\n            msg += colors[color]\n        }\n        message = a.substring(1, a.length)\n        msg += message\n    }\n    console.log('\\x1b[0m\\x1b[1m\\x1b[90m' + msg + '\\x1b[0m')\n}\n", "        if (Object.keys(colors).includes(color)) {\n            msg += colors[color]\n        }\n        message = a.substring(1, a.length)\n        msg += message\n    }\n    console.log('\\x1b[0m\\x1b[1m\\x1b[90m' + msg + '\\x1b[0m')\n}\n\n// this function adds a logging function to the wrtie function of the client\n// resulting in all sent packets being logged by the logPacket function", "// this function adds a logging function to the wrtie function of the client\n// resulting in all sent packets being logged by the logPacket function\nexport function addLoggerToClientWriteFunction(client: Client) {\n    ;(function () {\n        var old_prototype = client.write.prototype\n        var old_init = client.write\n        client.write = function (name, packet) {\n            old_init.apply(this, arguments)\n            logPacket(packet, { name: name, state: null }, true)\n        }\n        client.write.prototype = old_prototype\n    })()\n}\n\nconst colors = {\n    0: '\\x1b[0m\\x1b[30m',\n    1: '\\x1b[0m\\x1b[34m',\n    2: '\\x1b[0m\\x1b[32m',\n    3: '\\x1b[0m\\x1b[36m',\n    4: '\\x1b[0m\\x1b[31m',\n    5: '\\x1b[0m\\x1b[35m',\n    6: '\\x1b[0m\\x1b[33m',\n    7: '\\x1b[0m\\x1b[1m\\x1b[90m',\n    8: '\\x1b[0m\\x1b[90m',\n    9: '\\x1b[0m\\x1b[34m',\n    a: '\\x1b[0m\\x1b[32m',\n    b: '\\x1b[0m\\x1b[36m',\n    c: '\\x1b[0m\\x1b[31m',\n    d: '\\x1b[0m\\x1b[35m',\n    e: '\\x1b[0m\\x1b[33m',\n    f: '\\x1b[0m\\x1b[37m'\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export async function clickWindow(bot, slot: number) {\n    return bot.clickWindow(slot, 0, 0)\n}\n\nexport async function sleep(ms: number): Promise<void> {\n    return await new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function getWindowTitle(window) {\n    if (window.title) {\n        let parsed = JSON.parse(window.title)\n        return parsed.extra ? parsed['extra'][0]['text'] : parsed.translate\n    }", "export function getWindowTitle(window) {\n    if (window.title) {\n        let parsed = JSON.parse(window.title)\n        return parsed.extra ? parsed['extra'][0]['text'] : parsed.translate\n    }\n    if (window.windowTitle) {\n        return JSON.parse(window.windowTitle)['extra'][0]['text']\n    }\n    return ''\n}\n", "export function numberWithThousandsSeparators(number?: number): string {\n    if (!number) {\n        return '0'\n    }\n    var parts = number.toString().split('.')\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n    return parts.join('.')\n}\n\nexport function isCoflChatMessage(message: string) {\n    return removeMinecraftColorCodes(message).startsWith('[Chat]')\n}\n", "export function isCoflChatMessage(message: string) {\n    return removeMinecraftColorCodes(message).startsWith('[Chat]')\n}\n\nexport function removeMinecraftColorCodes(text: string) {\n    return text?.replace(/\u00a7[0-9a-fk-or]/gi, '')\n}\n"]}
{"filename": "src/fastWindowClick.ts", "chunked_list": ["import { Client } from 'minecraft-protocol'\nimport { log, logPacket, printMcChatToConsole } from './logger'\nimport { numberWithThousandsSeparators } from './utils'\n\nlet windowClicker\n\nexport function getFastWindowClicker(): FastWindowClicker {\n    if (windowClicker) {\n        return windowClicker\n    }\n    throw 'Window Clicker not created!'\n}\n", "export function createFastWindowClicker(client: Client) {\n    let actionCounter = 1\n    let lastWindowId = 0\n\n    let _windowClicker = {\n        // click purchase in window \"BIN Auction View\"\n        clickPurchase: function (price: number, windowId: number) {\n            client.write('window_click', {\n                windowId: windowId,\n                slot: 31,\n                mouseButton: 0,\n                action: actionCounter,\n                mode: 0,\n                item: {\n                    blockId: 371,\n                    itemCount: 1,\n                    itemDamage: 0,\n                    nbtData: {\n                        type: 'compound',\n                        name: '',\n                        value: {\n                            overrideMeta: { type: 'byte', value: 1 },\n                            display: {\n                                type: 'compound',\n                                value: {\n                                    Lore: {\n                                        type: 'list',\n                                        value: {\n                                            type: 'string',\n                                            value: ['', `\u252c\u00ba7Price: \u252c\u00ba6${numberWithThousandsSeparators(price)} coins`, '', '\u252c\u00baeClick to purchase!']\n                                        }\n                                    },\n                                    Name: { type: 'string', value: '\u252c\u00ba6Buy Item Right Now' }\n                                }\n                            },\n                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n                        }\n                    }\n                }\n            })\n            actionCounter += 1\n        },\n        clickBedPurchase: function (price: number, windowId: number) {\n            client.write('window_click', {\n                windowId: windowId,\n                slot: 31,\n                mouseButton: 0,\n                action: actionCounter,\n                mode: 0,\n                item: {\n                    blockId: 355,\n                    itemCount: 1,\n                    itemDamage: 0,\n                    nbtData: {\n                        type: 'compound',\n                        name: '',\n                        value: {\n                            overrideMeta: { type: 'byte', value: 1 },\n                            display: {\n                                type: 'compound',\n                                value: {\n                                    Lore: {\n                                        type: 'list',\n                                        value: {\n                                            type: 'string',\n                                            value: ['', `\u252c\u00ba7Price: \u252c\u00ba6${numberWithThousandsSeparators(price)} coins`, '', '\u252c\u00bacCan be bought soon!']\n                                        }\n                                    },\n                                    Name: { type: 'string', value: '\u252c\u00ba6Buy Item Right Now' }\n                                }\n                            },\n                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n                        }\n                    }\n                }\n            })\n            actionCounter += 1\n        },\n        // click confirm in window \"Confirm Purchase\"\n        clickConfirm: function (price: number, itemName: string, windowId: number) {\n            client.write('window_click', {\n                windowId: windowId,\n                slot: 11,\n                mouseButton: 0,\n                action: actionCounter,\n                mode: 0,\n                item: {\n                    blockId: 159,\n                    itemCount: 1,\n                    itemDamage: 13,\n                    nbtData: {\n                        type: 'compound',\n                        name: '',\n                        value: {\n                            overrideMeta: { type: 'byte', value: 1 },\n                            display: {\n                                type: 'compound',\n                                value: {\n                                    Lore: {\n                                        type: 'list',\n                                        value: {\n                                            type: 'string',\n                                            value: [\n                                                `\u252c\u00ba7Purchasing: \u252c\u00baa\u252c\u00baf\u252c\u00ba9${itemName.replace(/\u00a7/g, '\u252c\u00ba')}`,\n                                                `\u252c\u00ba7Cost: \u252c\u00ba6${numberWithThousandsSeparators(Math.floor(price))} coins`\n                                            ]\n                                        }\n                                    },\n                                    Name: { type: 'string', value: '\u252c\u00baaConfirm' }\n                                }\n                            },\n                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n                        }\n                    }\n                }\n            })\n            actionCounter += 1\n        },\n        getLastWindowId: function () {\n            return lastWindowId\n        }\n    }\n\n    client.on('packet', function (packet, packetMeta) {", "        if (packetMeta.name === 'open_window') {\n            lastWindowId = packet.windowId\n        }\n        logPacket(packet, packetMeta, false)\n    })\n    windowClicker = _windowClicker\n}\n"]}
{"filename": "src/sellHandler.ts", "chunked_list": ["import { MyBot, SellData } from '../types/autobuy'\nimport { log, printMcChatToConsole } from './logger'\nimport { clickWindow, getWindowTitle, numberWithThousandsSeparators, removeMinecraftColorCodes } from './utils'\nimport { sendWebhookItemListed } from './webhookHandler'\n\nlet setPrice = false\nlet durationSet = false\nlet retryCount = 0\n\nexport async function onWebsocketCreateAuction(bot: MyBot, data: SellData) {\n    if (bot.state) {\n        log('Currently busy with something else (' + bot.state + ') -> not selling')", "\nexport async function onWebsocketCreateAuction(bot: MyBot, data: SellData) {\n    if (bot.state) {\n        log('Currently busy with something else (' + bot.state + ') -> not selling')\n        if (retryCount > 3) {\n            retryCount = 0\n            return\n        }\n        setTimeout(() => {\n            retryCount++\n            onWebsocketCreateAuction(bot, data)\n        }, 1000)\n        return\n    }\n    bot.state = 'selling'\n    log('Selling item...')\n    log(data)\n    sellItem(data, bot)\n}\n", "async function sellItem(data: SellData, bot: MyBot) {\n    let timeout = setTimeout(() => {\n        log('Seems something went wrong while selling. Removing lock', 'warn')\n        bot.state = null\n        bot.removeAllListeners('windowOpen')\n    }, 10000)\n\n    let handler = function (window: any) {\n        sellHandler(data, bot, window, () => {\n            clearTimeout(timeout)\n            bot.removeAllListeners('windowOpen')\n        })\n    }\n    bot.on('windowOpen', handler)\n    bot.chat('/ah')\n}\n", "async function sellHandler(data: SellData, bot: MyBot, sellWindow, removeEventListenerCallback: Function) {\n    let title = getWindowTitle(sellWindow)\n    log(title)\n    if (title.toString().includes('Auction House')) {\n        clickWindow(bot, 15)\n    }\n    if (title == 'Manage Auctions') {\n        let clickSlot\n        for (let i = 0; i < sellWindow.slots.length; i++) {\n            const item = sellWindow.slots[i]\n            if (item && item.nbt.value.display.value.Name.value.includes('Create Auction')) {", "        for (let i = 0; i < sellWindow.slots.length; i++) {\n            const item = sellWindow.slots[i]\n            if (item && item.nbt.value.display.value.Name.value.includes('Create Auction')) {\n                if (item && (item.nbt as any).value?.display?.value?.Lore?.value?.value?.toString().includes('You reached the maximum number')) {\n                    log('Maximum number of auctons reached -> cant sell')\n                    removeEventListenerCallback()\n                    bot.state = null\n                    return\n                }\n                clickSlot = item.slot\n            }\n        }\n        clickWindow(bot, clickSlot)\n    }", "    if (title == 'Create Auction') {\n        clickWindow(bot, 48)\n    }\n\n    if (title == 'Create BIN Auction') {\n        if (!setPrice && !durationSet) {\n            if (!sellWindow.slots[13].nbt.value.display.value.Name.value.includes('Click an item in your inventory!')) {\n                clickWindow(bot, 13)\n            }\n\n            // calculate item slot, by calculating the slot index without the chest\n            let itemSlot = data.slot - bot.inventory.inventoryStart + sellWindow.inventoryStart", "            if (!sellWindow.slots[itemSlot]) {\n                bot.state = null\n                removeEventListenerCallback()\n                log('No item at index ' + itemSlot + ' found -> probably already sold', 'warn')\n                return\n            }\n\n            let id = sellWindow.slots[itemSlot]?.nbt?.value?.ExtraAttributes?.value?.id?.value\n            let uuid = sellWindow.slots[itemSlot]?.nbt?.value?.ExtraAttributes?.value?.uuid?.value\n            if (data.id !== id && data.id !== uuid) {\n                bot.state = null\n                removeEventListenerCallback()\n                log('Item at index ' + itemSlot + '\" does not match item that is supposed to be sold: \"' + data.id + '\" -> dont sell', 'warn')\n                log(JSON.stringify(sellWindow.slots[itemSlot]))\n                return\n            }\n\n            clickWindow(bot, itemSlot)\n            bot._client.once('open_sign_entity', ({ location }) => {\n                let price = (data as SellData).price\n                log('Price to set ' + Math.floor(price).toString())\n                bot._client.write('update_sign', {\n                    location: {\n                        x: location.z,\n                        y: location.y,\n                        z: location.z\n                    },\n                    text1: `\\\"${Math.floor(price).toString()}\\\"`,\n                    text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n                    text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n                    text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n                })\n            })\n            log('opening pricer')\n            clickWindow(bot, 31)\n            setPrice = true", "            if (data.id !== id && data.id !== uuid) {\n                bot.state = null\n                removeEventListenerCallback()\n                log('Item at index ' + itemSlot + '\" does not match item that is supposed to be sold: \"' + data.id + '\" -> dont sell', 'warn')\n                log(JSON.stringify(sellWindow.slots[itemSlot]))\n                return\n            }\n\n            clickWindow(bot, itemSlot)\n            bot._client.once('open_sign_entity', ({ location }) => {\n                let price = (data as SellData).price\n                log('Price to set ' + Math.floor(price).toString())\n                bot._client.write('update_sign', {\n                    location: {\n                        x: location.z,\n                        y: location.y,\n                        z: location.z\n                    },\n                    text1: `\\\"${Math.floor(price).toString()}\\\"`,\n                    text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n                    text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n                    text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n                })\n            })\n            log('opening pricer')\n            clickWindow(bot, 31)\n            setPrice = true", "        } else if (setPrice && !durationSet) {\n            clickWindow(bot, 33)\n        } else if (setPrice && durationSet) {\n            const resetAndTakeOutItem = () => {\n                clickWindow(bot, 13) // Take the item out of the window\n                removeEventListenerCallback()\n                setPrice = false\n                durationSet = false\n                bot.state = null\n            }\n", "            try {\n                const lore = <string[]>sellWindow.slots[29]?.nbt?.value?.display?.value?.Lore?.value?.value\n                let priceLine = lore.find(el => removeMinecraftColorCodes(el).includes('Item price'))\n                if (!priceLine) {\n                    log('Price not present', 'error')\n                    log(sellWindow.slots[29])\n                    resetAndTakeOutItem()\n                    return\n                }\n                if (priceLine.startsWith('{')) {\n                    let obj = JSON.parse(priceLine)\n                    priceLine = obj.extra[1].text.replace(/[,.]/g, '').split(' coins')[0]\n                } else {\n                    priceLine = removeMinecraftColorCodes(priceLine)\n\n                    priceLine = priceLine.split(': ')[1].split(' coins')[0]\n                    priceLine = priceLine.replace(/[,.]/g, '')\n                }\n", "                if (priceLine.startsWith('{')) {\n                    let obj = JSON.parse(priceLine)\n                    priceLine = obj.extra[1].text.replace(/[,.]/g, '').split(' coins')[0]\n                } else {\n                    priceLine = removeMinecraftColorCodes(priceLine)\n\n                    priceLine = priceLine.split(': ')[1].split(' coins')[0]\n                    priceLine = priceLine.replace(/[,.]/g, '')\n                }\n\n                if (Number(priceLine) !== Math.floor(data.price)) {\n                    log('Price is not the one that should be there', 'error')\n                    log(data)\n                    log(sellWindow.slots[29])\n                    resetAndTakeOutItem()\n                    return\n                }", "                if (Number(priceLine) !== Math.floor(data.price)) {\n                    log('Price is not the one that should be there', 'error')\n                    log(data)\n                    log(sellWindow.slots[29])\n                    resetAndTakeOutItem()\n                    return\n                }\n            } catch (e) {\n                log('Checking if correct price was set in sellHandler through an error: ' + JSON.stringify(e), 'error')\n            }\n\n            clickWindow(bot, 29)\n        }\n    }", "    if (title == 'Auction Duration') {\n        setAuctionDuration(bot, data.duration).then(() => {\n            durationSet = true\n        })\n        clickWindow(bot, 16)\n    }\n    if (title == 'Confirm BIN Auction') {\n        clickWindow(bot, 11)\n    }\n    if (title == 'BIN Auction View') {\n        log('Successfully listed an item')\n        removeEventListenerCallback()\n        setPrice = false\n        durationSet = false\n        bot.state = null\n        printMcChatToConsole(`\u00a7f[\u00a74BAF\u00a7f]: \u00a7fItem listed: ${data.itemName} \u00a7ffor ${numberWithThousandsSeparators(data.price)} coins`)\n        sendWebhookItemListed(data.itemName, numberWithThousandsSeparators(data.price), data.duration)\n        bot.closeWindow(sellWindow)\n    }\n}\n", "    if (title == 'BIN Auction View') {\n        log('Successfully listed an item')\n        removeEventListenerCallback()\n        setPrice = false\n        durationSet = false\n        bot.state = null\n        printMcChatToConsole(`\u00a7f[\u00a74BAF\u00a7f]: \u00a7fItem listed: ${data.itemName} \u00a7ffor ${numberWithThousandsSeparators(data.price)} coins`)\n        sendWebhookItemListed(data.itemName, numberWithThousandsSeparators(data.price), data.duration)\n        bot.closeWindow(sellWindow)\n    }\n}\n", "async function setAuctionDuration(bot: MyBot, time: number) {\n    log('setAuctionDuration function')\n    return new Promise<void>(resolve => {\n        bot._client.once('open_sign_entity', ({ location }) => {\n            bot._client.write('update_sign', {\n                location: {\n                    x: location.z,\n                    y: location.y,\n                    z: location.z\n                },\n                text1: `\\\"${Math.floor(time).toString()}\\\"`,\n                text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n                text3: '{\"italic\":false,\"extra\":[\"Auction\"],\"text\":\"\"}',\n                text4: '{\"italic\":false,\"extra\":[\"hours\"],\"text\":\"\"}'\n            })\n            resolve()\n        })\n    })\n}\n"]}
{"filename": "src/configHelper.ts", "chunked_list": ["let fs = require('fs')\nlet path = require('path')\nlet filePath = path.join((process as any).pkg ? process.argv[0] : process.argv[1], '..', 'config.toml')\n\nvar json2toml = require('json2toml')\nvar toml = require('toml')\nlet config: Config = {\n    INGAME_NAME: '',\n    WEBHOOK_URL: '',\n    FLIP_ACTION_DELAY: 100,", "    WEBHOOK_URL: '',\n    FLIP_ACTION_DELAY: 100,\n    ENABLE_CONSOLE_INPUT: true,\n    USE_COFL_CHAT: true,\n    SESSIONS: {},\n    USE_WINDOW_SKIPS: false\n}\n\njson2toml({ simple: true })\n\nexport function initConfigHelper() {", "json2toml({ simple: true })\n\nexport function initConfigHelper() {\n    if (fs.existsSync(filePath)) {\n        let existingConfig = toml.parse(fs.readFileSync(filePath, { encoding: 'utf8', flag: 'r' }))\n\n        // add new default values to existing config if new property was added in newer version\n        let hadChange = false\n        Object.keys(config).forEach(key => {\n            if (existingConfig[key] === undefined) {\n                existingConfig[key] = config[key]\n                hadChange = true\n            }\n        })", "            if (existingConfig[key] === undefined) {\n                existingConfig[key] = config[key]\n                hadChange = true\n            }\n        })\n        if (hadChange) {\n            fs.writeFileSync(filePath, json2toml(existingConfig))\n        }\n\n        config = existingConfig\n    }\n}\n", "export function updatePersistentConfigProperty(property: string, value: any) {\n    config[property] = value\n    fs.writeFileSync(filePath, json2toml(config))\n}\n\nexport function getConfigProperty(property: string): any {\n    return config[property]\n}\n"]}
{"filename": "src/webhookHandler.ts", "chunked_list": ["import axios from 'axios'\nimport { getConfigProperty } from './configHelper'\n\nfunction sendWebhookData(options: Partial<Webhook>): void {\n    let data = {\n        content: options.content || '',\n        avatar_url: options.avatar_url,\n        tts: options.tts,\n        embeds: options.embeds || [],\n        username: options.username || 'BAF'\n    }\n    axios.post(getConfigProperty('WEBHOOK_URL'), data)\n}\n", "function isWebhookConfigured() {\n    return !!getConfigProperty('WEBHOOK_URL')\n}\n\nexport function sendWebhookInitialized() {\n    if (!isWebhookConfigured()) {\n        return\n    }\n    let ingameName = getConfigProperty('INGAME_NAME')\n    sendWebhookData({\n        content: 'Initialized Connection',\n        embeds: [\n            {\n                title: 'Initialized Connection',\n                fields: [\n                    { name: 'Connected as:', value: `\\`\\`\\`${ingameName}\\`\\`\\``, inline: false },\n                    {\n                        name: 'Started at:',\n                        value: `<t:${(Date.now() / 1000).toFixed(0)}:t>`,\n                        inline: false\n                    }\n                ],\n                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n            }\n        ]\n    })\n}\n", "export function sendWebhookItemPurchased(itemName: string, price: string) {\n    if (!isWebhookConfigured()) {\n        return\n    }\n    let ingameName = getConfigProperty('INGAME_NAME')\n    sendWebhookData({\n        embeds: [\n            {\n                title: 'Item Purchased',\n                fields: [\n                    {\n                        name: 'Item:',\n                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n                        inline: true\n                    },\n                    {\n                        name: 'Bought for:',\n                        value: `\\`\\`\\`${price}\\`\\`\\``,\n                        inline: true\n                    }\n                ],\n                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n            }\n        ]\n    })\n}\n", "export function sendWebhookItemSold(itemName: string, price: string, purchasedBy: string) {\n    if (!isWebhookConfigured()) {\n        return\n    }\n    let ingameName = getConfigProperty('INGAME_NAME')\n    sendWebhookData({\n        embeds: [\n            {\n                title: 'Item Sold',\n                fields: [\n                    {\n                        name: 'Purchased by:',\n                        value: `\\`\\`\\`${purchasedBy}\\`\\`\\``,\n                        inline: true\n                    },\n                    {\n                        name: 'Item Sold:',\n                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n                        inline: true\n                    },\n                    {\n                        name: 'Sold for:',\n                        value: `\\`\\`\\`${price}\\`\\`\\``,\n                        inline: true\n                    }\n                ],\n                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n            }\n        ]\n    })\n}\n", "export function sendWebhookItemListed(itemName: string, price: string, duration: number) {\n    if (!isWebhookConfigured()) {\n        return\n    }\n    let ingameName = getConfigProperty('INGAME_NAME')\n    sendWebhookData({\n        embeds: [\n            {\n                title: 'Item Listed',\n                fields: [\n                    {\n                        name: 'Listed Item:',\n                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'Item Price:',\n                        value: `\\`\\`\\`${price}\\`\\`\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'AH Duration:',\n                        value: `\\`\\`\\`${duration}h\\`\\`\\``,\n                        inline: false\n                    }\n                ],\n                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n            }\n        ]\n    })\n}\n"]}
