{"filename": "test/stackid.test.ts", "chunked_list": ["import { test, expect, describe } from 'vitest'\nimport { Capture, Match, Template } from \"aws-cdk-lib/assertions\";\nimport * as cdk from \"aws-cdk-lib\";\nimport * as baselime from \"../src/index\";\nimport { gt } from '../src/utils/filter';\n\n\ndescribe('stack id', () => {\n    test('stackId is added by default', () => {\n        const app = new cdk.App();", "    test('stackId is added by default', () => {\n        const app = new cdk.App();\n        const stack = new cdk.Stack(app, 'TestStack');\n        \n        baselime.Baselime.init(stack, {\n            apiKey: 'xxxx',\n        });\n\n        const query = new baselime.Query('abc', {\n            parameters: {", "        const query = new baselime.Query('abc', {\n            parameters: {\n                filters: [\n                    gt('timestamp', 1234)\n                ]\n            }\n        })\n        const template = Template.fromStack(stack);\n        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n            Parameters: {", "        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n            Parameters: {\n                filters: [\n                    \"timestamp > 1234\",\n                    \"$baselime.stackId = TestStack\"\n                ]\n            }\n        })\n    });\n", "    });\n\n\n    test('stackId is not added if parameter is set on init', () => {\n        const app = new cdk.App();\n        const stack = new cdk.Stack(app, 'TestStack');\n        \n        baselime.Baselime.init(stack, {\n            apiKey: 'xxxx',\n            disableStackFilter: true,", "            apiKey: 'xxxx',\n            disableStackFilter: true,\n        });\n\n        const query = new baselime.Query('abc', {\n            parameters: {\n                filters: [\n                    gt('timestamp', 1234)\n                ]\n            }", "                ]\n            }\n        })\n        const template = Template.fromStack(stack);\n        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n            Parameters: {\n                filters: [\n                    \"timestamp > 1234\",\n                ]\n            }", "                ]\n            }\n        })\n    })\n\n    test('stackId is not added if parameter is set on query', () => {\n        const app = new cdk.App();\n        const stack = new cdk.Stack(app, 'TestStack');\n        \n        baselime.Baselime.init(stack, {", "        \n        baselime.Baselime.init(stack, {\n            apiKey: 'xxxx',\n        });\n\n        const query = new baselime.Query('abc', {\n            disableStackFilter: true,\n            parameters: {\n                filters: [\n                    gt('timestamp', 1234)", "                filters: [\n                    gt('timestamp', 1234)\n                ]\n            }\n        })\n        const template = Template.fromStack(stack);\n        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n            Parameters: {\n                filters: [\n                    \"timestamp > 1234\",", "                filters: [\n                    \"timestamp > 1234\",\n                ]\n            }\n        })\n    })\n});\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { Construct } from \"constructs\";\nimport { Channel } from './types/alert';\n\ninterface BaselimeConfiguration {\n\t/**\n\t * The Baselime API key\n\t */\n\treadonly apiKey: string;\n\t/**\n\t * The region to deploy this Observability as Code to.\n\t *\n\t * @default - Defaults to the CDK_DEPLOY_REGION environment variable\n\t */\n\treadonly region?: string;\n\t/**\n\t * The name of this service.\n\t * \n\t * @default - Defaults to the CDK stack name\n\t */\n\treadonly serviceName?: string;\n\t/**\n\t * The channel to send all the alerts for this service by default.\n\t */\n\treadonly defaultChannel?: Channel;\n\t/**\n\t * Wether or not to add a filter on stack name for all the queries created in this service\n\t * When `disableStackFilter` is set to `true`, this filter is removed:\n\t * `$baselime.stackId = stackName`\n\t * \n\t * @default - Defaults to false\n\t */\n\treadonly disableStackFilter?: boolean;\n\t/**\n\t * The AWS Account ID where Baselime is deployed.\n\t * Change this property only if you have self-deployed the entire Baselime BackEnd\n\t * \n\t * @default - Defaults to the Baselime AWS Account ID\n\t */\n\treadonly _account?: string;\n}\n\nexport namespace Baselime {\n\tlet construct: Construct;\n\tlet baselimeSecret: string;\n\tlet serviceName: string | undefined;\n\tlet serviceToken: string;\n\tlet defaultChannel: Channel | undefined;\n\tlet disableStackFilter: boolean | undefined;\n\n\t/**\n\t * Initialize Baselime CDK. Make sure to use this method in the beginning of the stack.\n\t *\n\t * @param {Construct} target\n\t * @param {BaselimeConfiguration} options\n\t * @example\n\t * import { Baselime } from '@baselime/cdk'\n\t * import * as cdk from 'aws-cdk-lib'\n\t * import { Construct } from 'constructs'\n\t *", "\t * export class ExamplesStack extends cdk.Stack {\n\t *   constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n\t *     super(scope, id, props)\n\t *\n\t *     Baselime.init(this, {\n\t *       apiKey: process.env.BASELIME_API_KEY, // Ideally use SSM or Secrets Manager\n\t *       serviceName: 'my-service',\n\t *\t\t defaultChannel: { type: \"slack\", targets: [\"baselime-alerts\"] },\n\t *     });\n\t */\n\texport function init(\n\t\ttarget: Construct,\n\t\toptions: BaselimeConfiguration,\n\t) {\n\t\tconstruct = target;\n\t\tbaselimeSecret = options.apiKey;\n\t\tserviceName = options.serviceName;\n\t\tserviceToken = `arn:aws:lambda:${options.region || process.env.CDK_DEPLOY_REGION || \"eu-west-1\"\n\t\t\t}:${options._account || \"097948374213\"}:function:baselime-orl-cloudformation`;\n\t\tdefaultChannel = options.defaultChannel;\n\t\tdisableStackFilter = options.disableStackFilter;\n\t}\n", "\texport function init(\n\t\ttarget: Construct,\n\t\toptions: BaselimeConfiguration,\n\t) {\n\t\tconstruct = target;\n\t\tbaselimeSecret = options.apiKey;\n\t\tserviceName = options.serviceName;\n\t\tserviceToken = `arn:aws:lambda:${options.region || process.env.CDK_DEPLOY_REGION || \"eu-west-1\"\n\t\t\t}:${options._account || \"097948374213\"}:function:baselime-orl-cloudformation`;\n\t\tdefaultChannel = options.defaultChannel;\n\t\tdisableStackFilter = options.disableStackFilter;\n\t}\n", "\texport function getConstruct() {\n\t\treturn construct;\n\t}\n\n\texport function getApiKey() {\n\t\treturn baselimeSecret;\n\t}\n\n\texport function getServiceName() {\n\t\treturn serviceName;\n\t}\n", "\texport function getServiceName() {\n\t\treturn serviceName;\n\t}\n\n\texport function getServiceToken() {\n\t\treturn serviceToken;\n\t}\n\n\texport function getDefaultChannel() {\n\t\treturn defaultChannel;\n\t}\n", "\texport function getDefaultChannel() {\n\t\treturn defaultChannel;\n\t}\n\n\texport function getDisableStackFilter() {\n\t\treturn disableStackFilter;\n\t}\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["\nexport interface QueryProps {\n\tDescription?: string;\n\tService?: string;\n\tParameters: {\n\t\tdatasets: string[];\n\t\tcalculations?: string[];\n\t\tfilters?: string[];\n\t\tgroupBys?: Array<{\n\t\t\ttype: \"string\" | \"number\" | \"boolean\";\n\t\t\tvalue: string;\n\t\t}>;\n\t\torderBy?: {\n\t\t\tvalue: string;\n\t\t\torder?: \"ASC\" | \"DESC\";\n\t\t};\n\t\tlimit?: number;\n\t\tneedle?: {\n\t\t\tvalue: string;\n\t\t\tisRegex?: boolean;\n\t\t\tmatchCase?: boolean;\n\t\t}\n\t};\n}\n\nexport * from \"./resources/query\";\nexport * from \"./resources/alert\";\nexport * from \"./resources/dashboard\";\nexport * from \"./config\";\n\nexport * as filter from \"./utils/filter\";\nexport * as threshold from './utils/threshold';\nexport * as calc from './utils/calc';"]}
{"filename": "src/utils/filter.ts", "chunked_list": ["\n\n/**\n * Creates a filter operation object that narrows down the results where the key equals the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string | number | boolean} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function eq(key: string, value: string | number | boolean) {\n\treturn { key, value, operation: \"=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not equal the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string | number | boolean} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function eq(key: string, value: string | number | boolean) {\n\treturn { key, value, operation: \"=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not equal the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string | number | boolean} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function neq(key: string, value: string | number | boolean) {\n\treturn { key, value, operation: \"!=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is greater than the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function neq(key: string, value: string | number | boolean) {\n\treturn { key, value, operation: \"!=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is greater than the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function gt(key: string, value: number) {\n\treturn { key, value, operation: \">\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is greater than or equal to the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function gt(key: string, value: number) {\n\treturn { key, value, operation: \">\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is greater than or equal to the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function gte(key: string, value: number) {\n\treturn { key, value, operation: \">=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is less than the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function gte(key: string, value: number) {\n\treturn { key, value, operation: \">=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is less than the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function lt(key: string, value: number) {\n\treturn { key, value, operation: \"<\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is less than or equal the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function lt(key: string, value: number) {\n\treturn { key, value, operation: \"<\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is less than or equal the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {number} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function lte(key: string, value: number) {\n\treturn { key, value, operation: \"<=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key includes the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function lte(key: string, value: number) {\n\treturn { key, value, operation: \"<=\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key includes the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function includes(key: string, value: string) {\n\treturn { key, value, operation: \"INCLUDES\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not include the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function includes(key: string, value: string) {\n\treturn { key, value, operation: \"INCLUDES\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not include the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function notIncludes(key: string, value: string) {\n\treturn { key, value, operation: \"DOES_NOT_INCLUDE\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key matches the regex.\n *  @param {string} key The field in the data used for filtering.\n *  @param {RegExp} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function notIncludes(key: string, value: string) {\n\treturn { key, value, operation: \"DOES_NOT_INCLUDE\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key matches the regex.\n *  @param {string} key The field in the data used for filtering.\n *  @param {RegExp} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function regex(key: string, value: RegExp) {\n\treturn { key, value: value.source, operation: \"MATCH_REGEX\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key starts with the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function regex(key: string, value: RegExp) {\n\treturn { key, value: value.source, operation: \"MATCH_REGEX\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key starts with the value.\n *  @param {string} key The field in the data used for filtering.\n *  @param {string} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function startsWith(key: string, value: string) {\n\treturn { key, value: value, operation: \"STARTS_WITH\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is one of the values\n *  @param {string} key The field in the data used for filtering.\n *  @param {string[]} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function startsWith(key: string, value: string) {\n\treturn { key, value: value, operation: \"STARTS_WITH\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is one of the values\n *  @param {string} key The field in the data used for filtering.\n *  @param {string[]} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function inArray(key: string, value: string[]) {\n\treturn { key, value: value, operation: \"IN\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is not one of the values\n *  @param {string} key The field in the data used for filtering.\n *  @param {string[]} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function inArray(key: string, value: string[]) {\n\treturn { key, value: value, operation: \"IN\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key is not one of the values\n *  @param {string} key The field in the data used for filtering.\n *  @param {string[]} value The value for the specified key used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function notInArray(key: string, value: string[]) {\n\treturn { key, value: value, operation: \"NOT_IN\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key exists\n *  @param {string} key The field in the data used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function notInArray(key: string, value: string[]) {\n\treturn { key, value: value, operation: \"NOT_IN\" } as const;\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key exists\n *  @param {string} key The field in the data used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function exists(key: string) {\n    return { key, operation: \"EXISTS\" } as const\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not exist\n *  @param {string} key The field in the data used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */", "export function exists(key: string) {\n    return { key, operation: \"EXISTS\" } as const\n}\n\n/**\n * Creates a filter operation object that narrows down the results where the key does not exist\n *  @param {string} key The field in the data used for filtering.\n *  @returns {Object} A filter operation object with the key, value, and operation properties.\n */\nexport function notExists(key: string) {\n    return { key, operation: \"NOT_EXISTS\" } as const\n}", "export function notExists(key: string) {\n    return { key, operation: \"NOT_EXISTS\" } as const\n}"]}
{"filename": "src/utils/threshold.ts", "chunked_list": ["\n\n/**\n * Triggers alert where calculation result equals the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */\nexport function eq(value: number) {\n\treturn { value, operation: \"=\" } as const;\n}\n\n/**\n * Triggers alert where calculation result does not equal the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */", "export function neq(value: number) {\n\treturn { value, operation: \"!=\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is greater than the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */\nexport function gt(value: number) {\n\treturn { value, operation: \">\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is greater than or equal to the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */", "export function gt(value: number) {\n\treturn { value, operation: \">\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is greater than or equal to the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */\nexport function gte(value: number) {\n\treturn { value, operation: \">=\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is less than the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */", "export function gte(value: number) {\n\treturn { value, operation: \">=\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is less than the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */\nexport function lt(value: number) {\n\treturn { value, operation: \"<\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is less than or equal to the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */", "export function lt(value: number) {\n\treturn { value, operation: \"<\" } as const;\n}\n\n/**\n * Triggers alert where calculation result is less than or equal to the value.\n *  @param {number} value The value used in the comparison\n *  @returns {Object} A threshold object\n */\nexport function lte(value: number) {\n\treturn { value, operation: \"<=\" } as const;\n}", "export function lte(value: number) {\n\treturn { value, operation: \"<=\" } as const;\n}"]}
{"filename": "src/utils/calc.ts", "chunked_list": ["export function count(alias?: string) {\n  return { operation: \"COUNT\", alias } as const\n}\n\nexport function countDistinct(key: string, alias?: string) {\n  return { operation: \"COUNT_DISTINCT\", key, alias } as const;\n}\n\nexport function max(key: string, alias?: string) {\n  return { operation: \"MAX\", key, alias } as const;\n}\n", "export function max(key: string, alias?: string) {\n  return { operation: \"MAX\", key, alias } as const;\n}\n\nexport function min(key: string, alias?: string) {\n  return { operation: \"MIN\", key, alias } as const;\n}\n\nexport function sum(key: string, alias?: string) {\n  return { operation: \"SUM\", key, alias } as const;\n}\n", "export function sum(key: string, alias?: string) {\n  return { operation: \"SUM\", key, alias } as const;\n}\n\nexport function avg(key: string, alias?: string) {\n  return { operation: \"AVG\", key, alias } as const;\n}\n\nexport function median(key: string, alias?: string) {\n  return { operation: \"MEDIAN\", key, alias } as const;\n}\n", "export function median(key: string, alias?: string) {\n  return { operation: \"MEDIAN\", key, alias } as const;\n}\n\nexport function p001(key: string, alias?: string) {\n  return { operation: \"P001\", key, alias } as const;\n}\n\nexport function p01(key: string, alias?: string) {\n  return { operation: \"P01\", key, alias } as const;\n}\n", "export function p01(key: string, alias?: string) {\n  return { operation: \"P01\", key, alias } as const;\n}\n\nexport function p05(key: string, alias?: string) {\n  return { operation: \"P05\", key, alias } as const;\n}\n\nexport function p10(key: string, alias?: string) {\n  return { operation: \"P10\", key, alias } as const;\n}\n", "export function p10(key: string, alias?: string) {\n  return { operation: \"P10\", key, alias } as const;\n}\n\nexport function p25(key: string, alias?: string) {\n  return { operation: \"P25\", key, alias } as const;\n}\n\nexport function p75(key: string, alias?: string) {\n  return { operation: \"P75\", key, alias } as const;\n}\n", "export function p75(key: string, alias?: string) {\n  return { operation: \"P75\", key, alias } as const;\n}\n\nexport function p90(key: string, alias?: string) {\n  return { operation: \"P90\", key, alias } as const;\n}\n\nexport function p95(key: string, alias?: string) {\n  return { operation: \"P95\", key, alias } as const;\n}\n", "export function p95(key: string, alias?: string) {\n  return { operation: \"P95\", key, alias } as const;\n}\n\nexport function p99(key: string, alias?: string) {\n  return { operation: \"P99\", key, alias } as const;\n}\n\nexport function p999(key: string, alias?: string) {\n  return { operation: \"P999\", key, alias } as const;\n}\n", "export function p999(key: string, alias?: string) {\n  return { operation: \"P999\", key, alias } as const;\n}\n\nexport function stdDev(key: string, alias?: string) {\n  return { operation: \"STDDEV\", key, alias } as const;\n}\n\nexport function variance(key: string, alias?: string) {\n  return { operation: \"VARIANCE\", key, alias } as const;\n}", "export function variance(key: string, alias?: string) {\n  return { operation: \"VARIANCE\", key, alias } as const;\n}"]}
{"filename": "src/utils/needle.ts", "chunked_list": ["\n/**\n * Creates a needle object that narrows down the results by searching for the needle in the haystack of events.\n *  @param {string | RegExp} value The field in the data used for filtering.\n *  @param {Object} params Extra parameters for the search.\n *  @returns {Object} A needle object with the value, matchCase, and isRegex properties.\n */\nexport function search(value: string | RegExp, params?: { matchCase: boolean }) {\n  return { value, isRegex: value instanceof RegExp, matchCase: params?.matchCase } as const;\n}\n"]}
{"filename": "src/utils/service-name.ts", "chunked_list": ["import { Stack } from \"aws-cdk-lib\";\nimport { Baselime as Config } from \"../config\";\n\nexport function getServiceName(stack: Stack): string {\n  const s = Config.getServiceName();\n  if (s) {\n    return s;\n  }\n  const tags = stack.tags.tagValues();\n\n  const isSST = Object.keys(tags).some((el) => el.includes(\"sst\"));\n", "  if (isSST) {\n    return `${tags['sst:stage']}-${tags['sst:app']}`;\n  }\n\n  return stack.stackName;\n}\n"]}
{"filename": "src/resources/dashboard.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\nimport { Baselime as Config } from \"../config\";\n\nimport { DashboardProps } from \"../types/dashboard\";\nimport { getServiceName } from \"../utils/service-name\";\n\nexport class Dashboard extends CfnResource {\n\tconstructor(id: string, props: DashboardProps) {\n\t\tconst stack = Stack.of(Config.getConstruct());\n\n\t\tconst parameters = {\n\t\t\t...props.parameters,\n\t\t\twidgets: props.parameters.widgets.map(el => ({ ...el, query: el.query.ref }))\n\t\t}\n\n\t\tsuper(Config.getConstruct(), id, {\n\t\t\ttype: \"Custom::BaselimeDashboard\",\n\t\t\tproperties: {\n\t\t\t\tid,\n\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\tDescription: props.description,\n\t\t\t\tService: getServiceName(stack),\n\t\t\t\tParameters: parameters,\n\t\t\t\tOrigin: \"cdk\"\n\t\t\t},\n\t\t});\n\t}\n}\n"]}
{"filename": "src/resources/query.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\nimport { Baselime as Config } from \"../config\";\n\nimport { QueryProps, Filter, DeploymentQueryParameters } from \"../types/query\";\nimport { AlertProps } from \"../types/alert\";\nimport { Alert } from './alert';\nimport { getServiceName } from '../utils/service-name';\n\nfunction buildCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\tconst short = buildShortCalculation(cal);\n\treturn `${short}${cal.alias ? ` as ${cal.alias}` : \"\"}`;\n}\n", "function buildCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\tconst short = buildShortCalculation(cal);\n\treturn `${short}${cal.alias ? ` as ${cal.alias}` : \"\"}`;\n}\n\nfunction hasDuplicates<T>(array: T[]) {\n\treturn (new Set(array)).size !== array.length;\n}\n\nfunction buildShortCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\tif (cal.operation === \"COUNT\") {\n\t\treturn cal.operation;\n\t}\n\treturn `${cal.operation}(${cal.key})`;\n}\n", "function buildShortCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\tif (cal.operation === \"COUNT\") {\n\t\treturn cal.operation;\n\t}\n\treturn `${cal.operation}(${cal.key})`;\n}\n\nfunction getCalculationAlias(cal: { alias?: string; operation: string; key?: string }) {\n\treturn cal.alias ? cal.alias : buildShortCalculation(cal);\n}\n", "export function stringifyFilter(filter: Filter): string {\n\tconst { key, operation, value } = filter;\n\tif (!operation) {\n\t\treturn `${key} = ${value}`;\n\t}\n\tif ([\"EXISTS\", \"DOES_NOT_EXIST\"].includes(operation)) {\n\t\treturn `${key} ${operation}`;\n\t}\n\tif ([\"IN\", \"NOT_IN\"].some(o => o === operation)) {\n\t\treturn `${key} ${operation} (${value})`;\n\t}\n\treturn `${key} ${operation} ${value}`;\n}\n\n/**\n * \n */", "\tif ([\"IN\", \"NOT_IN\"].some(o => o === operation)) {\n\t\treturn `${key} ${operation} (${value})`;\n\t}\n\treturn `${key} ${operation} ${value}`;\n}\n\n/**\n * \n */\nexport class Query<TKey extends string> extends CfnResource {\n\tid: string;\n\tprops: QueryProps<TKey>\n\tconstructor(id: string, props: QueryProps<TKey>) {\n\t\tconst stack = Stack.of(Config.getConstruct());\n\n\t\tconst calcs = props.parameters.calculations;\n\t\tconst orderByOptions = calcs?.map(cal => getCalculationAlias(cal));\n", "export class Query<TKey extends string> extends CfnResource {\n\tid: string;\n\tprops: QueryProps<TKey>\n\tconstructor(id: string, props: QueryProps<TKey>) {\n\t\tconst stack = Stack.of(Config.getConstruct());\n\n\t\tconst calcs = props.parameters.calculations;\n\t\tconst orderByOptions = calcs?.map(cal => getCalculationAlias(cal));\n\n\t\tif (calcs?.length && hasDuplicates(calcs.filter(c => c.alias).map(c => c.alias))) {\n\t\t\tthrow Error(\"Aliases must me unique across all calculations / visualisations.\")\n\t\t}\n", "\t\tif (calcs?.length && hasDuplicates(calcs.filter(c => c.alias).map(c => c.alias))) {\n\t\t\tthrow Error(\"Aliases must me unique across all calculations / visualisations.\")\n\t\t}\n\n\t\tif (props.parameters.orderBy && !orderByOptions?.includes(props.parameters.orderBy.value)) {\n\t\t\tthrow Error(\"The orderBy must be present in the calculations / visualisations.\")\n\t\t}\n\n\t\tconst disableStackFilter = props.disableStackFilter || Config.getDisableStackFilter();\n\t\t\n\t\tif (!disableStackFilter) {\n\t\t\tprops.parameters.filters?.push({ operation: \"=\", key: \"$baselime.stackId\", value: stack.stackName })\n\t\t}\n\n\t\tconst Parameters: DeploymentQueryParameters = {\n\t\t\t...props.parameters,\n\t\t\tdatasets: props.parameters.datasets || ['lambda-logs'],\n\t\t\tcalculations: props.parameters.calculations ? props.parameters.calculations.map(buildCalculation) : [],\n\t\t\tfilters: props.parameters.filters?.map(stringifyFilter),\n\t\t\tgroupBys: props.parameters.groupBys?.map(groupBy => {\n\t\t\t\treturn {\n\t\t\t\t\t...groupBy,\n\t\t\t\t\ttype: groupBy?.type || \"string\"\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfilterCombination: props.parameters.filterCombination || \"AND\",\n\t\t};\n\n\t\tsuper(Config.getConstruct(), id, {\n\t\t\ttype: \"Custom::BaselimeQuery\",\n\t\t\tproperties: {\n\t\t\t\tid,\n\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\tDescription: props.description,\n\t\t\t\tService: getServiceName(stack),\n\t\t\t\tParameters,\n\t\t\t\tOrigin: \"cdk\"\n\t\t\t},\n\t\t});\n\t\tthis.id = id;\n\t\tthis.props = props;\n\t}\n\n\taddAlert(alert: ChangeFields<AlertProps<TKey>, {\n\t\tparameters: Omit<AlertProps<TKey>['parameters'], \"query\">\n\t}>) {\n\t\tconst alertProps = {\n\t\t\t...alert,\n\t\t\tparameters: {\n\t\t\t\t...alert.parameters,\n\t\t\t\tquery: this\n\t\t\t}\n\t\t}\n\n\t\tnew Alert(`${this.id}-alert`, alertProps);\n\t}\n\n\taddFilters(filters: QueryProps<string>[\"parameters\"][\"filters\"]) {\n\t\tthis.addPropertyOverride('Parameters.filters', [...filters || []])\n\t}\n};\n", "\t\tif (!disableStackFilter) {\n\t\t\tprops.parameters.filters?.push({ operation: \"=\", key: \"$baselime.stackId\", value: stack.stackName })\n\t\t}\n\n\t\tconst Parameters: DeploymentQueryParameters = {\n\t\t\t...props.parameters,\n\t\t\tdatasets: props.parameters.datasets || ['lambda-logs'],\n\t\t\tcalculations: props.parameters.calculations ? props.parameters.calculations.map(buildCalculation) : [],\n\t\t\tfilters: props.parameters.filters?.map(stringifyFilter),\n\t\t\tgroupBys: props.parameters.groupBys?.map(groupBy => {\n\t\t\t\treturn {\n\t\t\t\t\t...groupBy,\n\t\t\t\t\ttype: groupBy?.type || \"string\"\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfilterCombination: props.parameters.filterCombination || \"AND\",\n\t\t};\n\n\t\tsuper(Config.getConstruct(), id, {\n\t\t\ttype: \"Custom::BaselimeQuery\",\n\t\t\tproperties: {\n\t\t\t\tid,\n\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\tDescription: props.description,\n\t\t\t\tService: getServiceName(stack),\n\t\t\t\tParameters,\n\t\t\t\tOrigin: \"cdk\"\n\t\t\t},\n\t\t});\n\t\tthis.id = id;\n\t\tthis.props = props;\n\t}\n\n\taddAlert(alert: ChangeFields<AlertProps<TKey>, {\n\t\tparameters: Omit<AlertProps<TKey>['parameters'], \"query\">\n\t}>) {\n\t\tconst alertProps = {\n\t\t\t...alert,\n\t\t\tparameters: {\n\t\t\t\t...alert.parameters,\n\t\t\t\tquery: this\n\t\t\t}\n\t\t}\n\n\t\tnew Alert(`${this.id}-alert`, alertProps);\n\t}\n\n\taddFilters(filters: QueryProps<string>[\"parameters\"][\"filters\"]) {\n\t\tthis.addPropertyOverride('Parameters.filters', [...filters || []])\n\t}\n};\n", "type ChangeFields<T, R> = Omit<T, keyof R> & R;\n"]}
{"filename": "src/resources/alert.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\nimport { Baselime as Config } from \"../config\";\nimport { Query } from \"./query\";\nimport { AlertProps, DeploymentAlertParameters } from \"../types/alert\";\nimport { QueryProps } from \"../types/query\";\nimport { getServiceName } from \"../utils/service-name\";\n\nexport class Alert<TKey extends string> extends CfnResource {\n\n\tconstructor(id: string, props: AlertProps<TKey>) {\n\t\tconst stack = Stack.of(Config.getConstruct());\n\t\tconst defaultFrequency = \"1hour\";\n\t\tconst defaultWindow = \"1hour\";\n\n\t\tlet Parameters: DeploymentAlertParameters | undefined = undefined;\n", "\t\tif (\"ref\" in props.parameters.query) {\n\t\t\tParameters = {\n\t\t\t\t...props.parameters,\n\t\t\t\tthreshold: `${props.parameters.threshold?.operation || \">\"} ${props.parameters.threshold?.value\n\t\t\t\t\t}`,\n\t\t\t\tquery: props.parameters.query.ref,\n\t\t\t\tfrequency: props.parameters.frequency || defaultFrequency,\n\t\t\t\twindow: props.parameters.window || defaultWindow,\n\t\t\t};\n\t\t}\n", "\t\tif (\"filters\" in props.parameters.query) {\n\t\t\tconst query = new Query(`${id}-query`, {\n\t\t\t\tparameters: {\n\t\t\t\t\t...props.parameters.query,\n\t\t\t\t\tcalculations: props.parameters.query.calculations || [\n\t\t\t\t\t\t{ operation: \"COUNT\" },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tParameters = {\n\t\t\t\t...props.parameters,\n\t\t\t\tthreshold: `${props.parameters.threshold?.operation || \">\"} ${props.parameters.threshold?.value || 0\n\t\t\t\t\t}`,\n\t\t\t\tquery: query.ref,\n\t\t\t\tfrequency: props.parameters.frequency || defaultFrequency,\n\t\t\t\twindow: props.parameters.window || defaultWindow,\n\t\t\t};\n\t\t}\n", "\t\tif (!Parameters) throw new Error(\"Invalid alert parameters. Declare at least one of filters or ref in the query.\")\n\n\t\tsuper(Config.getConstruct(), id, {\n\t\t\ttype: \"Custom::BaselimeAlert\",\n\t\t\tproperties: {\n\t\t\t\tid,\n\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\tenabled: props.enabled,\n\t\t\t\tDescription: props.description,\n\t\t\t\tService: getServiceName(stack),\n\t\t\t\tParameters,\n\t\t\t\tChannels: props.channels || Config.getDefaultChannel() && [Config.getDefaultChannel()],\n\t\t\t\tOrigin: \"cdk\",\n\t\t\t},\n\t\t});\n\t}\n}\n"]}
{"filename": "src/types/dashboard.ts", "chunked_list": ["import { CfnResource } from \"aws-cdk-lib\";\n\nexport type DashboardProps = {\n\tdescription?: string;\n\tparameters: DeploymentDashboardParameters;\n};\n\ninterface DeploymentDashboardParameters {\n\twidgets: Array<{\n\t\tname?: string;\n\t\tdescription?: string;\n\t\tquery: CfnResource;\n\t}>;\n}"]}
{"filename": "src/types/query.ts", "chunked_list": ["import { F } from \"ts-toolbelt\";\n\nexport type QueryProps<TKey extends string> = {\n\tdescription?: string;\n\tparameters: QueryParameters<TKey>\n\tdisableStackFilter?: boolean\n};\n\nexport type QueryParameters<TKey extends string> = {\n\tdatasets?: Datasets[];\n\tfilterCombination?: \"AND\" | \"OR\";\n\tfilters: Filter[];\n\tneedle?: Needle;\n\tcalculations?: never;\n\tgroupBys?: never;\n\torderBy?: never;\n\tlimit?: number;\n} | {\n\tdatasets?: Datasets[];\n\tfilterCombination?: \"AND\" | \"OR\";\n\tfilters?: Filter[];\n\tneedle?: Needle;\n\tcalculations?: Calculation<TKey>[];\n\tgroupBys?: QueryGroupBy[];\n\torderBy?: {\n\t\t// This doesn\"t quite work yet. It should be a union of the key in the filters\n\t\tvalue: F.NoInfer<TKey> | \"COUNT\";\n\t\torder?: \"ASC\" | \"DESC\";\n\t};\n\tlimit?: number;\n};\n", "export type QueryParameters<TKey extends string> = {\n\tdatasets?: Datasets[];\n\tfilterCombination?: \"AND\" | \"OR\";\n\tfilters: Filter[];\n\tneedle?: Needle;\n\tcalculations?: never;\n\tgroupBys?: never;\n\torderBy?: never;\n\tlimit?: number;\n} | {\n\tdatasets?: Datasets[];\n\tfilterCombination?: \"AND\" | \"OR\";\n\tfilters?: Filter[];\n\tneedle?: Needle;\n\tcalculations?: Calculation<TKey>[];\n\tgroupBys?: QueryGroupBy[];\n\torderBy?: {\n\t\t// This doesn\"t quite work yet. It should be a union of the key in the filters\n\t\tvalue: F.NoInfer<TKey> | \"COUNT\";\n\t\torder?: \"ASC\" | \"DESC\";\n\t};\n\tlimit?: number;\n};\n", "type Needle = {\n\tvalue: string;\n\tisRegex?: boolean;\n\tmatchCase?: boolean;\n};\n\nexport type QueryGroupBy = {\n\ttype?: \"string\" | \"number\" | \"boolean\";\n\tvalue: string;\n}\n", "type Datasets =\n\t| \"lambda-logs\"\n\t| \"cloudwatch-metrics\"\n\t| \"apigateway-logs\"\n\t| \"cloudtrail\"\n\t| \"ecs-logs\"\n\t| \"otel\"\n\t| \"apprunner-logs\"\n\t| \"x-ray\";\n\nexport type Calculation<TKey extends string> =\n\t| BaseCalculationObject<TKey>\n\t| CountCalculation<TKey>;\n", "export type Calculation<TKey extends string> =\n\t| BaseCalculationObject<TKey>\n\t| CountCalculation<TKey>;\n\nexport type Filter =\n\t| { key: Keys; operation: QueryOperationArray; value: string[] }\n\t| { key: Keys; operation: QueryOperationNull; value?: never }\n\t| {\n\t\tkey: Keys;\n\t\toperation?: QueryOperationString;\n\t\tvalue: string | number | boolean;\n\t};\n", "type Keys =\n\t| string\n\t| \"$baselime.acount\"\n\t| \"$baselime.baselimeId\"\n\t| \"$baselime.namespace\"\n\t| \"$baselime.region\"\n\t| \"$baselime.requestId\"\n\t| \"$baselime.service\"\n\t| \"$baselime.spanId\"\n\t| \"$baselime.traceId\";\n", "export type QueryOperationString =\n\t| \"=\"\n\t| \"!=\"\n\t| \">\"\n\t| \">=\"\n\t| \"<\"\n\t| \"<=\"\n\t| \"LIKE\"\n\t| \"NOT_LIKE\"\n\t| \"INCLUDES\"\n\t| \"MATCH_REGEX\"\n\t| \"DOES_NOT_INCLUDE\"\n\t| \"STARTS_WITH\";\n", "export type QueryOperationArray = \"IN\" | \"NOT_IN\";\n\nexport type QueryOperationNull = \"EXISTS\" | \"DOES_NOT_EXIST\";\n\ntype BaseCalculationObject<TKey> = {\n\toperation:\n\t| \"COUNT_DISTINCT\"\n\t| \"MAX\"\n\t| \"MIN\"\n\t| \"SUM\"\n\t| \"AVG\"\n\t| \"MEDIAN\"\n\t| \"P001\"\n\t| \"P01\"\n\t| \"P05\"\n\t| \"P10\"\n\t| \"P25\"\n\t| \"P75\"\n\t| \"P90\"\n\t| \"P95\"\n\t| \"P99\"\n\t| \"P999\"\n\t| \"STDDEV\"\n\t| \"VARIANCE\";\n\tkey: TKey;\n\talias?: TKey;\n};\n", "type CountCalculation<TKey> = {\n\toperation: TKey extends \"COUNT\" ? \"COUNT\" : string;\n\talias?: TKey;\n\tkey?: never;\n};\n\nexport type DeploymentQueryParameters = {\n\tdatasets: string[];\n\tcalculations?: string[];\n\tfilterCombination: \"AND\" | \"OR\";\n\tfilters?: string[];\n\tgroupBys?: QueryGroupBy[];\n\torderBy?: {\n\t\tvalue: string;\n\t\torder?: \"ASC\" | \"DESC\";\n\t};\n\tlimit?: number;\n\tneedle?: {\n\t\tvalue: string;\n\t\tisRegex?: boolean;\n\t\tmatchCase?: boolean;\n\t}\n};\n"]}
{"filename": "src/types/alert.ts", "chunked_list": ["import { CfnResource } from \"aws-cdk-lib\";\nimport { QueryOperationString, QueryParameters } from \"./query\";\n\nexport type AlertProps<TKey extends string> = {\n\tdescription?: string;\n\tenabled?: boolean;\n\tparameters: {\n\t\tquery: CfnResource | QueryParameters<TKey>,\n\t\tthreshold?: {\n\t\t\toperation?: QueryOperationString,\n\t\t\tvalue: string | number\n\t\t},\n\t\tfrequency?: string,\n\t\twindow?: string,\n\t};\n\tchannels?: Channel[];\n};\n", "export type Channel = { type: ChannelTypes; targets: string[] }\n\ntype ChannelTypes = \"slack\" | \"webhook\" | \"email\";\n\nexport type DeploymentAlertParameters = {\n\tquery: string;\n\tthreshold: string;\n\tfrequency: string;\n\twindow: string;\n};\n"]}
