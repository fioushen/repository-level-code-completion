{"filename": "src/consts/index.ts", "chunked_list": ["import cloudflareIpRanges from \"./ip-ranges.json\";\n\nimport { rangeToIpArray } from \"~/helpers/rangeToIpArray\";\n\nexport const allIps: string[] = cloudflareIpRanges.flatMap((range) =>\n  rangeToIpArray(range)\n);\n"]}
{"filename": "src/helpers/randomizeElements.ts", "chunked_list": ["export function randomizeElements<T>(arr: T[]) {\n  return [...arr].sort(() => Math.random() - 0.5);\n}\n"]}
{"filename": "src/helpers/copyIPToClipboard.ts", "chunked_list": ["import { toast } from \"react-hot-toast\";\nexport async function copyIPToClipboard(ip: string) {\n  try {\n    await navigator.clipboard.writeText(ip);\n    toast.success(`IP ${ip} copied to clipboard!`);\n  } catch (error) {\n    toast.error(`Failed to copy IP ${ip} to clipboard!`);\n    console.error(error);\n  }\n}\n"]}
{"filename": "src/helpers/rangeToIpArray.ts", "chunked_list": ["export function rangeToIpArray(range: string) {\n  const parts = range.split(\"/\");\n  if (parts.length !== 2) {\n    throw new Error(`Invalid IP Range format ${range} `);\n  }\n  const [ip, maskString] = parts as [string, string];\n  const mask = parseInt(maskString, 10);\n  const ipParts = ip.split(\".\");\n  if (ipParts.length !== 4) {\n    throw new Error(\"Invalid IP\");\n  }\n  const [first, second, third, forth] = ipParts as [\n    string,\n    string,\n    string,\n    string\n  ];\n\n  const start =\n    (parseInt(first, 10) << 24) |\n    (parseInt(second, 10) << 16) |\n    (parseInt(third, 10) << 8) |\n    parseInt(forth, 10) |\n    0; // convert to unsigned int\n  const end = start | (0xffffffff >>> mask) | 0; // convert to unsigned int\n\n  const ips: string[] = [];", "  if (ipParts.length !== 4) {\n    throw new Error(\"Invalid IP\");\n  }\n  const [first, second, third, forth] = ipParts as [\n    string,\n    string,\n    string,\n    string\n  ];\n\n  const start =\n    (parseInt(first, 10) << 24) |\n    (parseInt(second, 10) << 16) |\n    (parseInt(third, 10) << 8) |\n    parseInt(forth, 10) |\n    0; // convert to unsigned int\n  const end = start | (0xffffffff >>> mask) | 0; // convert to unsigned int\n\n  const ips: string[] = [];", "  for (let i = start; i <= end; i++) {\n    const ip = [\n      (i >> 24) & 0xff,\n      (i >> 16) & 0xff,\n      (i >> 8) & 0xff,\n      i & 0xff,\n    ].join(\".\");\n    ips.push(ip);\n  }\n  return ips;\n}\n"]}
{"filename": "src/helpers/download.ts", "chunked_list": ["type AcceptableObject = Record<string, unknown>;\ntype CreateFn = (arr: AcceptableObject[]) => Blob;\nconst createJSON: CreateFn = (arr) => {\n  const jsonString = JSON.stringify(arr, null, 2);\n  const blob = new Blob([jsonString], {\n    type: \"application/json;charset=utf-8;\",\n  });\n  return blob;\n};\nconst createCSV: CreateFn = (arr) => {\n  const keys = Object.keys(arr[0] as AcceptableObject);\n  const csvHeader = keys.join(\",\");\n  const csvContent = arr\n    .map((el) => keys.map((key) => String(el[key] || \"\")).join(\",\"))\n    .join(\"\\n\");\n  const csvString = `${csvHeader}\\n${csvContent}`;\n  const blob = new Blob([csvString], { type: \"text/csv\" });\n  return blob;\n};", "export function download(arr: AcceptableObject[], format: \"json\" | \"csv\") {\n  if (!arr.length) return;\n  const blob = format === \"json\" ? createJSON(arr) : createCSV(arr);\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"href\", url);\n  link.setAttribute(\"download\", `ip-list.${format}`);\n  link.style.display = \"none\";\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n}\n"]}
{"filename": "src/swr/cacheProviders/localstorage.ts", "chunked_list": ["import { type State } from \"swr\";\nconst CACHE_KEY = \"swr-cache\";\nexport const localStorageProvider = () => {\n  const isServer = typeof window === \"undefined\";\n  const localStorageData: unknown = JSON.parse(\n    (!isServer && localStorage.getItem(CACHE_KEY)) || \"[]\"\n  );\n\n  const map = new Map<string, State<unknown, unknown> | undefined>(\n    Array.isArray(localStorageData) ? localStorageData : []\n  );\n", "  if (!isServer) {\n    // Before unloading the app, we write back all the data into `localStorage`.\n    window.addEventListener(\"beforeunload\", () => {\n      const appCache = JSON.stringify(Array.from(map.entries()));\n      localStorage.setItem(CACHE_KEY, appCache);\n    });\n  }\n\n  // We still use the map for write & read for performance.\n  return map;\n};\n"]}
{"filename": "src/swr/fetchers/userIP.ts", "chunked_list": ["import { type IPInfo } from \"~/types\";\n\nexport const fetchUserIPInfo = async (detectedIP = \"\") => {\n  const res = await fetch(`https://freeipapi.com/api/json/${detectedIP}`);\n  const ipInfo = (await res.json()) as IPInfo;\n  return ipInfo;\n};\n"]}
{"filename": "src/hooks/useUserIPInfo.ts", "chunked_list": ["import useSWR from \"swr\";\nimport { fetchUserIPInfo } from \"~/swr/fetchers/userIP\";\n\nexport const useUserIPInfo = () => {\n  const swr = useSWR(\"ipInfo\", () => fetchUserIPInfo(), {\n    fallbackData: {\n      ipVersion: 0,\n      ipAddress: \"0.0.0.0\",\n      latitude: 0,\n      longitude: 0,", "      latitude: 0,\n      longitude: 0,\n      countryName: \"-\",\n      countryCode: \"-\",\n      timeZone: \"+00:00\",\n      zipCode: \"00000\",\n      cityName: \"-\",\n      regionName: \"-\",\n    },\n  });", "    },\n  });\n\n  return {\n    loading: (!swr.data && !swr.error) || swr.isValidating,\n    error: swr.error as unknown,\n    ipInfo: swr.data,\n  };\n};\n", "};\n"]}
{"filename": "src/hooks/useIPScanner.ts", "chunked_list": ["import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { randomizeElements } from \"~/helpers/randomizeElements\";\nimport pick from \"lodash/pick\";\n\ntype ValidIP = {\n  ip: string;\n  latency: number;\n};\n\nconst TRY_CHARS = [\"\", \"|\", \"/\", \"-\", \"\\\\\"] as const;\nconst MAX_TRIES = TRY_CHARS.length;", "export type TryChar = (typeof TRY_CHARS)[number];\n\nexport type Settings = {\n  maxIPCount: number;\n  maxLatency: number;\n  ipRegex: string;\n};\n\ntype SettingKeys = keyof Settings;\n\ntype ScanState = \"idle\" | \"stopping\" | \"scanning\";\n", "type SettingKeys = keyof Settings;\n\ntype ScanState = \"idle\" | \"stopping\" | \"scanning\";\n\ntype ScannerStore = Settings & {\n  testNo: number;\n  validIPs: ValidIP[];\n  currentIP: string;\n  tryChar: TryChar;\n  currentLatency: number;\n  color: \"red\" | \"green\";\n  scanState: ScanState;\n  dispatch: (newState: Partial<ScannerStore>) => void;\n  reset: () => void;\n  increaseTestNo: () => void;\n  addValidIP: (validIP: ValidIP) => void;\n  setSettings: (newSettings: Partial<Settings>) => void;\n  getScanState: () => ScanState;\n  getValidIPCount: () => number;\n};\n", "type FunctionalKeys = {\n  [K in keyof ScannerStore]: ScannerStore[K] extends (\n    ...args: never[]\n  ) => unknown\n    ? K\n    : never;\n}[keyof ScannerStore];\n\nexport const settingsInitialValues: Pick<ScannerStore, SettingKeys> = {\n  maxIPCount: 5,\n  maxLatency: 1000,\n  ipRegex: \"\",\n};\n\nconst initialState: Omit<ScannerStore, FunctionalKeys> = {\n  ...settingsInitialValues,\n  testNo: 0,\n  validIPs: [],\n  currentIP: \"\",\n  tryChar: \"\",\n  currentLatency: 0,\n  color: \"red\",\n  scanState: \"idle\",\n};\n\nexport const useScannerStore = create<ScannerStore>()(\n  persist(\n    (set, get) => ({\n      ...initialState,\n      getScanState: () => get().scanState,\n      getValidIPCount: () => get().validIPs.length,\n      setSettings: (newSettings) => {\n        set(newSettings);\n      },\n      dispatch: (newState) => {\n        set(newState);\n      },\n      addValidIP(validIP) {\n        set((state) => {\n          const newArr = [...state.validIPs, validIP];\n          const validIPs = newArr.sort((a, b) => a.latency - b.latency);\n          return {\n            validIPs,\n          };\n        });\n      },\n      reset: () => {\n        set({\n          testNo: 0,\n          validIPs: [],\n          currentIP: \"\",\n          tryChar: \"\",\n          currentLatency: 0,\n          color: \"red\",\n          scanState: \"idle\",\n        });\n      },\n      increaseTestNo: () => {\n        set((state) => ({ testNo: state.testNo + 1 }));\n      },\n    }),\n    {\n      name: \"scanner-store\",\n      partialize: (state) => pick(state, Object.keys(settingsInitialValues)),\n      version: 1,\n    }\n  )\n);\n", "type IPScannerProps = {\n  allIps: string[];\n};\n\nexport const useIPScanner = ({ allIps }: IPScannerProps) => {\n  const {\n    dispatch,\n    reset,\n    increaseTestNo,\n    addValidIP,\n    getScanState,\n    getValidIPCount,\n    ...state\n  } = useScannerStore();", "  function setToIdle() {\n    dispatch({ scanState: \"idle\", tryChar: \"\" });\n  }\n  async function startScan() {\n    reset();\n    try {\n      const ips = state.ipRegex\n        ? allIps.filter((el) => new RegExp(state.ipRegex).test(el))\n        : allIps;\n\n      dispatch({ scanState: \"scanning\" });\n      await testIPs(randomizeElements(ips));\n      setToIdle();", "    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  function stopScan() {\n    if (getScanState() === \"scanning\") {\n      dispatch({ scanState: \"stopping\" });\n    } else {\n      setToIdle();\n    }\n  }\n", "  async function testIPs(ipList: string[]) {\n    for (const ip of ipList) {\n      increaseTestNo();\n      const url = `https://${ip}/__down`;\n\n      let testCount = 0;\n\n      const startTime = performance.now();\n      const multiply =\n        state.maxLatency <= 500 ? 1.5 : state.maxLatency <= 1000 ? 1.2 : 1;\n      let timeout = 1.5 * multiply * state.maxLatency;", "      for (let i = 0; i < MAX_TRIES; i++) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n          controller.abort();\n        }, Math.trunc(timeout));\n        const newState: Partial<ScannerStore> = {\n          currentIP: ip,\n          tryChar: TRY_CHARS[i] || \"\",\n        };\n\n        if (i === 0) {\n          timeout = multiply * state.maxLatency;\n          newState.color = \"red\";\n          newState.currentLatency = 0;\n        } else {\n          timeout = 1.2 * multiply * state.maxLatency;\n          newState.color = \"green\";\n          newState.currentLatency = Math.floor(\n            (performance.now() - startTime) / (i + 1)\n          );\n        }\n\n        dispatch(newState);\n", "        if (i === 0) {\n          timeout = multiply * state.maxLatency;\n          newState.color = \"red\";\n          newState.currentLatency = 0;\n        } else {\n          timeout = 1.2 * multiply * state.maxLatency;\n          newState.color = \"green\";\n          newState.currentLatency = Math.floor(\n            (performance.now() - startTime) / (i + 1)\n          );\n        }\n\n        dispatch(newState);\n", "        try {\n          await fetch(url, {\n            signal: controller.signal,\n          });\n\n          testCount++;\n        } catch (error) {\n          // don't increase testResult if it's not an abort error\n          if (!(error instanceof Error && error.name === \"AbortError\")) {\n            testCount++;\n          }\n        }\n        clearTimeout(timeoutId);\n      }\n\n      const latency = Math.floor((performance.now() - startTime) / MAX_TRIES);\n", "          if (!(error instanceof Error && error.name === \"AbortError\")) {\n            testCount++;\n          }\n        }\n        clearTimeout(timeoutId);\n      }\n\n      const latency = Math.floor((performance.now() - startTime) / MAX_TRIES);\n\n      if (testCount === MAX_TRIES && latency <= state.maxLatency) {\n        addValidIP({\n          ip,\n          latency,\n        });\n      }\n", "      if (testCount === MAX_TRIES && latency <= state.maxLatency) {\n        addValidIP({\n          ip,\n          latency,\n        });\n      }\n\n      if (\n        getScanState() !== \"scanning\" ||\n        getValidIPCount() >= state.maxIPCount\n      ) {\n        break;\n      }\n    }\n  }\n\n  return {\n    ...state,\n    startScan,\n    stopScan,\n  };\n};\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["export type IPInfo = {\n  ipVersion: number;\n  ipAddress: string;\n  latitude: number;\n  longitude: number;\n  countryName: string;\n  countryCode: string;\n  timeZone: string;\n  zipCode: string;\n  cityName: string;\n  regionName: string;\n};\n"]}
