{"filename": "src/utils.ts", "chunked_list": ["import Express from \"express\";\nimport { ApiError } from \"./const/errors\";\n\nexport function sendErrorResponse(res: Express.Response, error: ApiError) {\n    res.status(error.status);\n    res.json(error)\n}\n\nexport function sendJSONResponse(res: Express.Response, obj: any, status?: number) {\n    res.status(obj.status ?? status ?? 200);\n    res.json(obj)\n}\n\n", "export function sendJSONResponse(res: Express.Response, obj: any, status?: number) {\n    res.status(obj.status ?? status ?? 200);\n    res.json(obj)\n}\n\n\nexport function isURL(u: string): boolean {\n\t\ttry {\n\t\t\t\tnew URL(u)\n\t\t\t\treturn true;\n\t\t} catch { return false }\n\n}\n"]}
{"filename": "src/server.ts", "chunked_list": ["import express from \"express\";\nimport routeEmailValidate from \"./routes/EmailValidate\"\nimport routeEmailSend from \"./routes/EmailSend\"\n\nimport EmailCache from \"./models/EmailCache\";\n\nimport { ErrorCodes } from \"./const/errors\";\nimport { sendErrorResponse } from \"./utils\" ;\n\nimport path from \"node:path\";", "\nimport path from \"node:path\";\n\nconst app = express();\n\napp.use(express.static('./public'))\n\napp.use(express.json());\napp.use((err: any, req: any, res: any, next: any) => {\n    if (err instanceof SyntaxError) \n\t\t\t\tsendErrorResponse(res as express.Response, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\tmessage: \"Bad JSON input\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 400\n\t\t\t\t})\n        return;\n});\n\n(async () => {\n    await EmailCache.init();\n\t\tapp.get(\"/\", (req, res) => {\n\t\t\t\tconsole.log(path.join(__dirname, \"./public/index.html\"))\n\t\t\t\tres.sendFile(path.join(__dirname, \"../public/index.html\"))\n\t\t})\n    app.get(\"/api/v1/email/validate\", routeEmailValidate)\n\t\tapp.post(\"/api/v1/email/send\", routeEmailSend)\n})();\n\nprocess.on(\"exit\", async () => {\n   await EmailCache.close();\n})\n\nexport default app;\n\n\n", "app.use((err: any, req: any, res: any, next: any) => {\n    if (err instanceof SyntaxError) \n\t\t\t\tsendErrorResponse(res as express.Response, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\tmessage: \"Bad JSON input\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 400\n\t\t\t\t})\n        return;\n});\n\n(async () => {\n    await EmailCache.init();\n\t\tapp.get(\"/\", (req, res) => {\n\t\t\t\tconsole.log(path.join(__dirname, \"./public/index.html\"))\n\t\t\t\tres.sendFile(path.join(__dirname, \"../public/index.html\"))\n\t\t})\n    app.get(\"/api/v1/email/validate\", routeEmailValidate)\n\t\tapp.post(\"/api/v1/email/send\", routeEmailSend)\n})();\n\nprocess.on(\"exit\", async () => {\n   await EmailCache.close();\n})\n\nexport default app;\n\n\n"]}
{"filename": "src/index.ts", "chunked_list": ["import server from \"./server\";\nconst PORT = process.env.PORT || 3000;\n\nserver.listen(PORT, () => {\n    console.log(`server listening at http://127.0.0.1:${PORT}`)\n})"]}
{"filename": "src/const/vars.ts", "chunked_list": ["import dotenv from \"dotenv\";\ndotenv.config();\n\nexport const MAIL_CONFIG = {\n\t\taddress: process.env.MAIL_ADDRESS,\n\t\tpassword: process.env.MAIL_PASSWORD,\n}\n\nexport const REDIS_CONFIG = {\n\tusername: process.env.REDIS_USERNAME,", "export const REDIS_CONFIG = {\n\tusername: process.env.REDIS_USERNAME,\n\tpassword: process.env.REDIS_PASSWORD,\n\thost: process.env.REDIS_HOST,\n\tport: Number(process.env.REDIS_PORT),\n}"]}
{"filename": "src/const/email.ts", "chunked_list": ["export interface Mail {\n\t\tto: Array<{\n\t\t\t\tname: string,\n\t\t\t\temail: string,\n\t\t}>\n\n\t\tfrom: {\n\t\t\t\temail: string,\n\t\t\t\tname: string,\n\t\t}\n\n\t\tsubject: string,\n\n\t\tbody: {\n\t\t\t\ttype: \"text\" | \"html\",\n\t\t\t\tcontent: string,\n\t\t}\n}\n"]}
{"filename": "src/const/errors.ts", "chunked_list": ["export enum ErrorCodes {\n  VALIDATION = 'validation_error',\n  DATABASE = 'database_error',\n  EXTERNAL_SERVICE = 'external_service_error',\n  RESOURCE_NOT_FOUND = 'resource_not_found_error',\n  BAD_INPUT = \"bad_input\",\n  TOO_MANY_REQUESTS = \"too_many_requests\",\n  INTERNAL_ERROR = \"internal_error\",\n}\n\nexport interface ApiError {\n\t\terror: {\n\t\t\t\tcode: ErrorCodes,\n\t\t\t\tmessage: string,\n\t\t\t\tdetails?: any,\n\t\t}\n\t\tstatus: number,\n}\n", "export interface ApiError {\n\t\terror: {\n\t\t\t\tcode: ErrorCodes,\n\t\t\t\tmessage: string,\n\t\t\t\tdetails?: any,\n\t\t}\n\t\tstatus: number,\n}\n"]}
{"filename": "src/const/mailSchema.ts", "chunked_list": ["const schema = {\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"to\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},", "        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"email\": {\"type\": \"string\", \"format\": \"email\"}\n        },\n        \"required\": [\"name\", \"email\"]\n      },\n      \"minItems\": 1\n    },\n\t\t\"from\": {\"type\": \"string\"},\n    \"subject\": {\"type\": \"string\"},", "\t\t\"from\": {\"type\": \"string\"},\n    \"subject\": {\"type\": \"string\"},\n    \"body\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"type\": {\"type\": \"string\", \"enum\": [\"text\", \"html\"]},\n        \"content\": {\"type\": \"string\"}\n      },\n      \"required\": [\"type\", \"content\"]\n    }", "      \"required\": [\"type\", \"content\"]\n    }\n  },\n  \"required\": [\"to\", \"from\", \"subject\", \"body\"]\n}\n\n\nexport default schema;\n", ""]}
{"filename": "src/models/RateLimiter.ts", "chunked_list": ["import Express from \"express\";\n\nclass RateLimiter {\n\t\ttimeout: number;\n\t\tlimit: number;\n\t\ttimeOfLastRequestByIp: Map<string, number>;\n\t\trequestsSentByIp: Map<string, number>;\n\n\t\tconstructor(limit: number, timeout: number) {\n\t\t\t\tthis.timeOfLastRequestByIp = new Map();\n\t\t\t\tthis.requestsSentByIp = new Map();\n\t\t\t\tthis.limit = limit;\n\t\t\t\tthis.timeout = timeout;\n\t\t}\n\n\t\tcheckIfTimedOut(req: Express.Request): boolean {\n\t\t\t\tconst { ip } = req;\n\n\t\t\t\tconst reqCount = this.requestsSentByIp.get(ip) ?? 0;\n\t\t\t\tconst timeOfLast = this.timeOfLastRequestByIp.get(ip) ?? 0;\n", "\t\t\t\tif (reqCount === this.limit && (Date.now() - timeOfLast) < this.timeout) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t}\n\n\t\tlogRequest(req: Express.Request) {\n\t\t\t\tconst { ip } = req;\n\t\t\t\tthis.timeOfLastRequestByIp.set(ip, Date.now());\n\t\t\t\tconst reqCount = this.requestsSentByIp.get(ip) ?? 0;\n\t\t\t\tthis.requestsSentByIp.set(ip, reqCount + 1);\n\t\t}\n\n\t\tresetRequest(req: Express.Request) {\n\t\t\t\tconst { ip } = req;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.requestsSentByIp.set(ip, 0);\n\t\t\t\t}, this.timeout)\n\t\t}\n}\n\nexport default RateLimiter;\n"]}
{"filename": "src/models/EmailCache.ts", "chunked_list": ["import { createClient } from \"redis\";\nimport { REDIS_CONFIG } from \"../const/vars\";\n\nclass EmailCache {\n\tclient: any;\n\n\tconstructor() {\n\t\tthis.client = createClient({\n\t\t\tsocket: {\n\t\t\t\thost: REDIS_CONFIG.host,\n\t\t\t\tport: REDIS_CONFIG.port,\n\t\t\t},\n\t\t\tusername: REDIS_CONFIG.username,\n\t\t\tpassword: REDIS_CONFIG.password\n\t\t\t\n\t\t});\n\t}\n\n\tasync init() {\n\t\tawait this.client.connect();\n\t}\n\n\tasync pushEmail(email: string, validity: Array<boolean>): Promise<string> {", "\t\ttry {\n\t\t\tconst resp = await this.client.set(email, JSON.stringify(validity));\n\t\t\treturn email;\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync getEmail(email: string): Promise<Array<boolean> | null> {\n\t\ttry {\n\t\t\tconst resp = await this.client.get(email)\n\t\t\treturn JSON.parse(resp ?? \"[]\");", "\t\ttry {\n\t\t\tconst resp = await this.client.get(email)\n\t\t\treturn JSON.parse(resp ?? \"[]\");\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync close() {\n\t\tthis.client.close();\n\t}\n}\n\nexport default new EmailCache();\n\n"]}
{"filename": "src/routes/EmailValidate.ts", "chunked_list": ["import Express from \"express\";\nimport { ErrorCodes } from \"../const/errors\";\nimport { sendErrorResponse, sendJSONResponse, isURL } from \"../utils\";\nimport dns from \"node:dns\";\n\nimport EmailCache from \"../models/EmailCache\";\nimport RateLimiter from \"../models/RateLimiter\";\n\nconst RATE_TIMEOUT = 5000;\nconst RATE_LIMITER = new RateLimiter(5, RATE_TIMEOUT); // Throttle the requests to prevent overload ", "const RATE_TIMEOUT = 5000;\nconst RATE_LIMITER = new RateLimiter(5, RATE_TIMEOUT); // Throttle the requests to prevent overload \n\nfunction validateEmailSyntax(email: string): boolean {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  const maxDomainLength = 255;\n  const maxLocalPartLength = 64;\n  const maxEmailLength = maxLocalPartLength + 1 + maxDomainLength;\n  if (email.length > maxEmailLength) {\n    return false;\n  }\n  const [localPart, domain] = email.split(\"@\");\n", "  if (email.length > maxEmailLength) {\n    return false;\n  }\n  const [localPart, domain] = email.split(\"@\");\n\n  if (localPart?.length > maxLocalPartLength || domain?.length > maxDomainLength) {\n    return false;\n  }\n  return regex.test(email);\n}\n", "function validateEmailDomain(email: string): Promise<boolean>  {\n\t\tif (!validateEmailSyntax(email)) return Promise.resolve(false);\n\t\tconst [mail, tld] = email.split(\"@\");\n\t\tif (!tld || !isURL(tld)) return Promise.resolve(false);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tdns.resolve(tld, \"MX\", (err, addresses) => {\n\t\t\t\t\t\tif (err) resolve(false);\n\t\t\t\t\t\tresolve(addresses?.length > 0)\n\t\t\t\t})\n    })\n}\n\nexport default async function (req: Express.Request, res: Express.Response) {\n\t\tconst queryEmail = req.query?.email;", "\t\tif (RATE_LIMITER.checkIfTimedOut(req)) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.TOO_MANY_REQUESTS,\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\t\tretry_after: `${RATE_TIMEOUT} ms`\n\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmessage: \"Too many requests. Please try again later\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 429\n\t\t\t\t});\n\t\t\t\tRATE_LIMITER.resetRequest(req);\n\t\t\t\treturn;\n\t\t}\n\t\tRATE_LIMITER.logRequest(req);\n", "\t\tif (!queryEmail || queryEmail?.length === 0) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\tmessage: \"email is a required argument\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 400\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst cachedEmailData = await EmailCache.getEmail(queryEmail as string);\n\n\t\tlet emailChecks;", "\t\tif (cachedEmailData?.length) {\n\t\t\t\temailChecks = cachedEmailData;\n\t\t} else {\n\t\t\t\temailChecks = [\n\t\t\t\t\t\tvalidateEmailSyntax(queryEmail as string),\n\t\t\t\t\t\tawait validateEmailDomain(queryEmail as string)\n\t\t\t\t]\n\t\t}\n\n\t\temailChecks = emailChecks as Array<boolean>;\n\n\t\tconst response = {\n\t\t\t\tdata: {\n\t\t\t\t\t\temail: queryEmail as string,\n\t\t\t\t\t\tvalid: emailChecks.every(e => e),\n\t\t\t\t\t\tformat_valid: emailChecks[0],\n\t\t\t\t\t\tdomain_valid: emailChecks[1],\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t}\n", "\t\tif (!cachedEmailData?.length) {\n\t\t\t\tawait EmailCache.pushEmail(queryEmail as string, emailChecks as Array<boolean>);\n\t\t}\n\n\t\tsendJSONResponse(res, response)\n}\n"]}
{"filename": "src/routes/EmailSend.ts", "chunked_list": ["import Express from \"express\";\nimport { ErrorCodes } from \"../const/errors\";\nimport { sendErrorResponse, sendJSONResponse, isURL } from \"../utils\";\n\nimport { MAIL_CONFIG } from \"../const/vars\";\n\nimport nodemailer from \"nodemailer\"\n;\n\nimport mailSchema from \"../const/mailSchema\";", "\nimport mailSchema from \"../const/mailSchema\";\nimport { Mail } from \"../const/email\";\n\nimport RateLimiter from \"../models/RateLimiter\";\n\nconst RATE_TIMEOUT = 20_000;\nconst RATE_LIMITER = new RateLimiter(1, RATE_TIMEOUT); // Throttle the requests to prevent overload \n\nimport Ajv from \"ajv\";", "\nimport Ajv from \"ajv\";\n\nconst ajv = new Ajv({ allErrors: true });\n\najv.addFormat('email', {\n\t\ttype: 'string',\n\t\tvalidate: (value: string) => {\n\t\t\t\tconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\t\t\t\treturn emailRegex.test(value);", "\t\t\t\tconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\t\t\t\treturn emailRegex.test(value);\n\t\t},\n});\n\nconst transporter = nodemailer.createTransport({\n  maxConnections: 2,\n  pool: true,\n  service: \"hotmail\",\n  auth: {", "  service: \"hotmail\",\n  auth: {\n\t  user: MAIL_CONFIG.address,\n    pass: MAIL_CONFIG.password\n  }\n});\n\nfunction sendMail(blob: Mail): Promise<string> {\n\t\tconst toEmails = blob.to.map(e => e.email);\n\t\tconst fromEmail = blob.from;\n\t\tconst body = `Forwarded via Zap<https://github.com/aadv1k/zap> originally by ${fromEmail}\\n` + blob.body.content;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t\ttransporter.sendMail({\n\t\t\t\t\t\tfrom: MAIL_CONFIG.address,\n\t\t\t\t\t\tto: toEmails,\n\t\t\t\t\t\tsubject: blob.subject,\n\t\t\t\t\t\thtml: body\n\t\t\t\t}, (error: any, info: any) => {", "\t\t\t\t\t\tif (error) reject(error);\n\t\t\t\t\t\tresolve(info.messageId);\n\t\t\t\t})\n\t\t})\n\n}\n\nexport default async function (req: Express.Request, res: Express.Response) {\n\t\tif (RATE_LIMITER.checkIfTimedOut(req)) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.TOO_MANY_REQUESTS,\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\t\tretry_after: `${RATE_TIMEOUT} ms`\n\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmessage: \"Too many requests. Please try again later\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 429\n\t\t\t\t});\n\t\t\t\tRATE_LIMITER.resetRequest(req);\n\t\t\t\treturn;\n\t\t}\n\t\tRATE_LIMITER.logRequest(req);\n\n\t\tlet body: Mail;\n", "\t\tif (RATE_LIMITER.checkIfTimedOut(req)) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.TOO_MANY_REQUESTS,\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\t\tretry_after: `${RATE_TIMEOUT} ms`\n\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmessage: \"Too many requests. Please try again later\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 429\n\t\t\t\t});\n\t\t\t\tRATE_LIMITER.resetRequest(req);\n\t\t\t\treturn;\n\t\t}\n\t\tRATE_LIMITER.logRequest(req);\n\n\t\tlet body: Mail;\n", "\t\ttry {\n\t\t\t\tbody = req.body;\n\t\t} catch (err) {\n\t\t\t\tconsole.log(\"DEBUG LOG >>>>> \", err)\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\tmessage: \"Invalid JSON data\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 400\n\t\t\t\t})\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst isMailValid = ajv.validate(mailSchema, body);", "\t\tif (!isMailValid)  {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\tmessage: \"Bad input\",\n\t\t\t\t\t\t\t\tdetails: ajv.errors,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 400\n\t\t\t\t})\n\t\t\t\treturn;\n\t\t}\n", "\t\ttry {\n\t\t\t\tconst receivedMailId = await sendMail(body);\n\t\t\t\tsendJSONResponse(res, {\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tmessageId: receivedMailId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 200,\n\t\t\t\t}, 200)\n\t\t} catch (error) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.INTERNAL_ERROR,\n\t\t\t\t\t\t\t\tmessage: \"Internall error while sending mail\",\n\t\t\t\t\t\t\t\tdetails: error,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 500\n\t\t\t\t})\n\t\t}\n}\n\n", "\t\t} catch (error) {\n\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: ErrorCodes.INTERNAL_ERROR,\n\t\t\t\t\t\t\t\tmessage: \"Internall error while sending mail\",\n\t\t\t\t\t\t\t\tdetails: error,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: 500\n\t\t\t\t})\n\t\t}\n}\n\n"]}
