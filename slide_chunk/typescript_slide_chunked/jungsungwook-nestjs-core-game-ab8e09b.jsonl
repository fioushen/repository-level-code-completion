{"filename": "src/main.ts", "chunked_list": ["import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { IoAdapter } from '@nestjs/platform-socket.io';\nimport * as dotenv from 'dotenv';\nimport * as path from 'path';\nimport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\n\ndotenv.config({ path: path.resolve(__dirname, '../.env') });\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const options = new DocumentBuilder()\n        .setTitle('API')\n        .setDescription('The API description')\n        .setVersion('1.0')\n        .addTag('nestjs-game-api')\n        .build();\n  const document = SwaggerModule.createDocument(app, options);\n  SwaggerModule.setup('api-docs', app, document);\n  \n  app.useWebSocketAdapter(new IoAdapter(app));\n  app.enableCors();\n  await app.listen(3000);\n}\nbootstrap();\n", "async function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const options = new DocumentBuilder()\n        .setTitle('API')\n        .setDescription('The API description')\n        .setVersion('1.0')\n        .addTag('nestjs-game-api')\n        .build();\n  const document = SwaggerModule.createDocument(app, options);\n  SwaggerModule.setup('api-docs', app, document);\n  \n  app.useWebSocketAdapter(new IoAdapter(app));\n  app.enableCors();\n  await app.listen(3000);\n}\nbootstrap();\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { CacheModule, MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';\nimport { GatewayModule } from './socket-gateways/gateway.module';\nimport path from 'path';\nimport { resolve } from 'path';\nimport * as dotenv from 'dotenv';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from './auth/auth.module';\nimport { AuthTokenMiddleware } from './auth/authToken.middleware';\nimport { UsersModule } from './pages/users/users.module';", "import { AuthTokenMiddleware } from './auth/authToken.middleware';\nimport { UsersModule } from './pages/users/users.module';\nimport { User } from './pages/users/user.entity';\nimport { SchedulerModule } from './pages/schedule/scheduler.module';\nimport { MatchModule } from './pages/match/match.module';\n\ndotenv.config({ path: resolve(__dirname, '../.env') });\n\n@Module({\n  imports: [", "@Module({\n  imports: [\n    CacheModule.register(\n      {\n        isGlobal: true,\n        ttl: 60*60*12, // seconds\n        max: 1000, // maximum number of items in cache\n      },\n    ),\n    ConfigModule.forRoot({", "    ),\n    ConfigModule.forRoot({\n      isGlobal: true,\n      envFilePath: '.env',\n    }),\n    TypeOrmModule.forRoot({\n      type: 'mariadb',\n      host: process.env.DB_HOST || 'localhost',\n      port: parseInt(process.env.DB_PORT) as number,\n      username: process.env.DB_USER as string || 'abcd',", "      port: parseInt(process.env.DB_PORT) as number,\n      username: process.env.DB_USER as string || 'abcd',\n      password: process.env.DB_PASS,\n      database: process.env.DB_DATABASE,\n      timezone: '+09:00',\n      entities: [User,],\n      synchronize: true,\n    }),\n    GatewayModule,\n    UsersModule,", "    GatewayModule,\n    UsersModule,\n    AuthModule,\n    SchedulerModule,\n    MatchModule,\n  ],\n})\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(AuthTokenMiddleware)\n      .forRoutes({ path: '*', method: RequestMethod.ALL });\n  }\n}\n"]}
{"filename": "src/socket-gateways/gateway.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\nimport { CoreGateway } from './gateway.core';\nimport { PlayerGateway } from './player/gateway.player';\nimport { UsersModule } from 'src/pages/users/users.module';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { BroadcastModule } from 'src/pages/broadcast/broadcast.module';\nimport { Movement2dModule } from 'src/movement2d/movement2d.module';\nimport { RedisCacheModule } from 'src/cache/redis.module';\nimport { ChatModule } from 'src/pages/chat/chat.module';\nimport { ChatGateWay } from './chat/gateway.chat';", "import { ChatModule } from 'src/pages/chat/chat.module';\nimport { ChatGateWay } from './chat/gateway.chat';\nimport { MatchModule } from 'src/pages/match/match.module';\nimport { MatchGateway } from './match/gateway.match';\n\n@Module({\n    imports:[\n        UsersModule,\n        AuthModule,\n        BroadcastModule,", "        AuthModule,\n        BroadcastModule,\n        Movement2dModule,\n        RedisCacheModule,\n        forwardRef(() => MatchModule),\n        ChatModule,\n    ],\n    providers: [\n        CoreGateway,\n        PlayerGateway,", "        CoreGateway,\n        PlayerGateway,\n        ChatGateWay,\n        MatchGateway,\n    ],\n    exports: [\n        CoreGateway,\n        PlayerGateway,\n        ChatGateWay,\n        MatchGateway,", "        ChatGateWay,\n        MatchGateway,\n    ],\n})\nexport class GatewayModule { }"]}
{"filename": "src/socket-gateways/gateway.core.ts", "chunked_list": ["import {\n    MessageBody,\n    SubscribeMessage,\n    WebSocketGateway,\n    WebSocketServer,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\n\n@WebSocketGateway(8080, { \n    transports: ['websocket'] ,", "@WebSocketGateway(8080, { \n    transports: ['websocket'] ,\n    cors: {\n        origin: '*',\n    },\n})\nexport class CoreGateway {\n    @WebSocketServer()\n    server: Server;\n\n    @SubscribeMessage('ClientToServer')\n    async handleMessage(@MessageBody() data) {\n        const returnText = 'Server received: ' + data;\n        console.log(returnText);\n        this.server.emit('ServerToClient', returnText);\n    }\n\n    @SubscribeMessage('ping')\n    async handlePing(@MessageBody() data) {\n        this.server.emit('pong', 'pong');\n    }\n\n    async getClients(){\n        const socket = this.server.sockets.sockets;\n        return socket;\n    }\n}"]}
{"filename": "src/socket-gateways/player/gateway.player.ts", "chunked_list": ["import {\n    ConnectedSocket,\n    MessageBody,\n    SubscribeMessage,\n    WebSocketGateway,\n    WebSocketServer,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\nimport { UsersService } from 'src/pages/users/users.service';\nimport { Movement2dService } from 'src/movement2d/movement2d.service';", "import { UsersService } from 'src/pages/users/users.service';\nimport { Movement2dService } from 'src/movement2d/movement2d.service';\nimport { BroadcastService } from 'src/pages/broadcast/broadcast.service';\nimport { RedisCacheService } from 'src/cache/redis.service';\nimport { generateSessionId } from 'src/utils/util';\n/**\n * \ubcf8\uc778\uc758 \uce90\ub9ad\ud130\uc640 \ub2e4\ub978 \ud50c\ub808\uc774\uc5b4\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c \uc8fc\uace0 \ubc1b\ub294 \uac8c\uc774\ud2b8\uc6e8\uc774\n * @Todo\n * 1. \ubcf8\uc778\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c Broadcast\n * 2. \ub2e4\ub978 \ud50c\ub808\uc774\uc5b4\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c Broadcast", " * 1. \ubcf8\uc778\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c Broadcast\n * 2. \ub2e4\ub978 \ud50c\ub808\uc774\uc5b4\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c Broadcast\n * 3. \ubcf8\uc778\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c \ud2b9\uc815 \ud50c\ub808\uc774\uc5b4\uc5d0\uac8c \uc804\uc1a1\n * 4. \ub2e4\ub978 \ud50c\ub808\uc774\uc5b4\uc758 \uce90\ub9ad\ud130 \uc815\ubcf4\ub97c \ud2b9\uc815 \ud50c\ub808\uc774\uc5b4\uc5d0\uac8c \uc804\uc1a1\n * \n * @Memo\n * - \ub370\ub4dc\ub808\ucee4\ub2dd\uc740 \ucda9\ub3cc\uccb4\ub85c \uc778\ud55c \uc704\uce58 \uc815\ubcf4\uac00 \ubc14\ub00c\uc9c0 \uc54a\uc744 \ub54c \uc0ac\uc6a9\ud558\uae30\uc5d0 \uc801\ud569\ud558\ub2e4.\n */\n\n@WebSocketGateway(8080, { ", "\n@WebSocketGateway(8080, { \n    transports: ['websocket'] ,\n    cors: {\n        origin: '*',\n    },\n})\nexport class PlayerGateway {\n    constructor(\n        private userService: UsersService,\n        private broadcastService: BroadcastService,\n        private movemoent2dService: Movement2dService,\n        private redisService: RedisCacheService,\n    ) {}\n    @WebSocketServer()\n    server: Server;\n\n    /**\n     * \n     * @todo\n     * - \ub2e4\uc911 \ud074\ub77c\uc774\uc5b8\ud2b8 \uc811\uc18d \uc2dc \ucc98\ub9ac \n     */\n    async handleConnection(client: Socket) {\n        // const test = setInterval(async () => {\n        //     console.log('ping');\n        // }, 1000);\n        // const testId = test[Symbol.toPrimitive]() as number;\n        // console.log(testId)\n        // const end = setTimeout(async () => {\n        //     clearInterval(testId);\n        //     console.log('pong');\n        // }, 5000);\n        const reqHeaders = client.handshake.headers;\n\n        let refreshToken = '';", "        if(reqHeaders.refresh_token) refreshToken = reqHeaders.refresh_token as string;\n        else refreshToken = client.handshake.auth.refresh_token as string;\n\n        // if(!reqHeaders.refreshToken) throw new Error('No refreshToken');\n        try{\n            const user = await this.userService.getUser(refreshToken);\n            if(user.statusCode == '404') throw new Error('User not found');\n            const userObj = user.contents;\n            const socketId = client.id;\n            const socketIdUpdate = await this.userService.socketIdUpdate(userObj, socketId);\n            if(socketIdUpdate.statusCode == '404') throw new Error('User not found');\n            await this.redisService.set(socketId, userObj.customId);\n            console.log('PlayerGateway: ' + userObj.customId + ' connected');\n\n            // \uc720\uc800 \uc815\ubcf4 broadcast\n            const {x , y} = await this.redisService.get(userObj.customId + \"_position\") || {x: 0, y: 0};\n            // connection to socket\n            const otherUsers = await this.userService.getConnectedUser();\n            const otherPlayerInfo : {\n                customId: string,\n                x: number,\n                y: number,\n            }[] = [];", "            if(socketIdUpdate.statusCode == '404') throw new Error('User not found');\n            await this.redisService.set(socketId, userObj.customId);\n            console.log('PlayerGateway: ' + userObj.customId + ' connected');\n\n            // \uc720\uc800 \uc815\ubcf4 broadcast\n            const {x , y} = await this.redisService.get(userObj.customId + \"_position\") || {x: 0, y: 0};\n            // connection to socket\n            const otherUsers = await this.userService.getConnectedUser();\n            const otherPlayerInfo : {\n                customId: string,\n                x: number,\n                y: number,\n            }[] = [];", "            for(let i = 0; i < otherUsers.contents.length; i++){\n                const {customId} = otherUsers.contents[i];\n                if(customId == userObj.customId) continue;\n                const {x, y} = await this.redisService.get(customId + \"_position\") || {x: 0, y: 0};\n                otherPlayerInfo.push({\n                    customId: customId,\n                    x: x,\n                    y: y,\n                });\n            }\n            client.emit(\"connection\", {\n                myInfo: {\n                    customId : userObj.customId,\n                    x: x,\n                    y: y,\n                },\n                otherPlayer : otherPlayerInfo,\n            });\n\n            await this.broadcastService.serverBroadcast(this.server, 'enter_lobby', {\n                player: userObj.customId,\n                x: x,\n                y: y,\n            });\n        }", "        catch(e){\n            console.log(e);\n            client.disconnect();\n        }\n    }\n\n    async handleDisconnect(client: Socket) {\n        const reqHeaders = client.handshake.headers;\n        let refreshToken = '';\n        if(reqHeaders.refresh_token) refreshToken = reqHeaders.refresh_token as string;\n        else refreshToken = client.handshake.auth.refresh_token as string;\n", "        if(reqHeaders.refresh_token) refreshToken = reqHeaders.refresh_token as string;\n        else refreshToken = client.handshake.auth.refresh_token as string;\n\n        try{\n            const socketIdUpdate = await this.userService.disconnectSocketId(client.id);\n            if(socketIdUpdate.statusCode == '404') throw new Error('User not found');\n            console.log('PlayerGateway: ' + socketIdUpdate.contents.customId + ' disconnected');\n            const check = await this.redisService.get(client.id);\n            if(check){\n                await this.redisService.del(client.id);\n            }\n            ['w','a','s','d'].forEach(async (key) => {\n                const interval = await this.redisService.get(socketIdUpdate.contents.customId + \"_interval_\" + key);\n", "            if(check){\n                await this.redisService.del(client.id);\n            }\n            ['w','a','s','d'].forEach(async (key) => {\n                const interval = await this.redisService.get(socketIdUpdate.contents.customId + \"_interval_\" + key);\n\n                if(interval){\n                    clearInterval(interval);\n                    await this.redisService.del(socketIdUpdate.contents.customId + \"_interval_\" + key);\n                }\n            });\n            await this.broadcastService.serverBroadcast(this.server, 'disconnection', {\n                player: socketIdUpdate.contents.customId,\n            });\n        }       ", "        catch(e){\n            client.disconnect();\n        }\n    }\n\n    /**\n     * @Description\n     * 2Directional Movement (2D)\ub97c \ucc98\ub9ac\ud558\ub294 \uba54\uc18c\ub4dc.\n     * \ud0a4\ubcf4\ub4dc \uc785\ub825\uc744 \ubc1b\uc544\uc11c \ucc98\ub9ac\ud568.\n     */\n    @SubscribeMessage('move2d_key')\n    async handleMove2d(\n        @MessageBody() data : { key: string, isUp: boolean, timestamp: number },\n        @ConnectedSocket() client: Socket,\n    ) {", "        try{\n            const userCustomId = await this.redisService.get(client.id);\n            if(!userCustomId) throw new Error('User not found');\n            if(!data.key) throw new Error('Key not found');\n            if(data.isUp == undefined) throw new Error('isUp not found');\n            const pos = await this.redisService.get(userCustomId + \"_position\");\n            if (!pos||!pos.hasOwnProperty('x')||!pos.hasOwnProperty('y')||pos.x==undefined||pos.y==undefined) {\n                const rand_session_id = generateSessionId();\n                client.emit(\"request_position\", userCustomId + \"_\" + rand_session_id);\n                await this.redisService.set(userCustomId + \"_\" + rand_session_id, { clientId: client.id, key: data.key, isUp: data.isUp, timestamp: data.timestamp});\n                return;\n            }\n            await this.movemoent2dService.move2d_key(this.server, 'returnMove2dKey', userCustomId, data.key, data.isUp);", "        }catch(e){\n            client.emit('error', e.message);\n        }\n    }\n\n    /**\n     * @Description\n     * \ud074\ub77c\uc774\uc5b8\ud2b8\ub85c\ubd80\ud130 \ubcf8\uc778\uc758 \uc704\uce58 \uc815\ubcf4\ub97c \ubc1b\uc544\uc11c \ucc98\ub9ac\ud558\ub294 \uba54\uc18c\ub4dc.\n     * request \uc804\uc6a9.\n     */\n    @SubscribeMessage('response_position_key')\n    async handlePlayerPosition(\n        @MessageBody() data: { x: number, y: number, session_id: string},\n        @ConnectedSocket() client: Socket,\n    ) {", "        try{\n            const userCustomId = await this.redisService.get(client.id);\n            if(!userCustomId) throw new Error('User not found');\n            if(data.x == undefined || data.y == undefined) throw new Error('Position not found');\n            if(!data.session_id) throw new Error('Session id not found');\n            const session_data = await this.redisService.get(data.session_id);\n            if(!session_data||session_data.clientId != client.id) throw new Error('Invalid session');\n            await this.redisService.set(userCustomId + \"_position\", { x: data.x, y: data.y });\n            const key = session_data.key;\n            const isUp = session_data.isUp;\n            await this.movemoent2dService.move2d_key(this.server, 'returnMove2dKey', userCustomId, key, isUp);\n            await this.redisService.del(data.session_id);\n", "        }catch(e){\n            client.emit('error', e.message);\n        }\n    }\n\n    /**\n     * @Description\n     * 2Directional Movement (2D)\ub97c \ucc98\ub9ac\ud558\ub294 \uba54\uc18c\ub4dc.\n     * \uc774\ub3d9 \ubc29\ud5a5\uc744 \ubc1b\uc544\uc11c \ucc98\ub9ac\ud568.\n     */\n    @SubscribeMessage('move2d_direction')\n    async handleMove2dDirection(\n        @MessageBody() data: { direction: string },\n        @ConnectedSocket() client: Socket,\n    ) {", "        try{\n            const userCustomId = await this.redisService.get(client.id);\n            if(!userCustomId) throw new Error('User not found');\n            if(!data.direction) throw new Error('Direction not found');\n            await this.movemoent2dService.move2d_direction(this.server, 'returnMove2dDirection', userCustomId, data.direction);\n        }catch(e){\n            client.emit('error', e.message);\n        }\n    }\n}"]}
{"filename": "src/socket-gateways/chat/gateway.chat.ts", "chunked_list": ["import { ConnectedSocket, MessageBody, SubscribeMessage, WebSocketGateway, WebSocketServer } from \"@nestjs/websockets\";\nimport { Server, Socket } from \"socket.io\";\nimport { RedisCacheService } from \"src/cache/redis.service\";\nimport { BroadcastService } from \"src/pages/broadcast/broadcast.service\";\nimport { UsersService } from \"src/pages/users/users.service\";\n\n@WebSocketGateway(8080, {\n    transports: ['websocket'],\n    cors: {\n        origin: '*',", "    cors: {\n        origin: '*',\n    },\n})\nexport class ChatGateWay {\n    constructor(\n        private userService: UsersService,\n        private broadcastService: BroadcastService,\n        private redisService: RedisCacheService,\n    ) { }\n    @WebSocketServer()\n    server: Server;\n\n    @SubscribeMessage('send_chat')\n    async handleChat(\n        @MessageBody() data: { message: string },\n        @ConnectedSocket() client: Socket\n    ) {", "        try {\n            const userCustomId = await this.redisService.get(client.id);\n            if (!userCustomId) throw new Error('User not found');\n\n            if (!data.message) throw new Error('Message is undefined');\n            if (data.message.replace(/\\s/g, '').length == 0) throw new Error('Message is empty');\n            if (data.message.length > 100) throw new Error('Message is too long');\n\n            const returnObj = {\n                type: \"message\",\n                message: data.message,\n                sender: userCustomId,\n                timestamp: new Date().getTime(),\n            }\n            const chatLog: Object[] = await this.redisService.get('chatLog');", "            if(chatLog) await this.redisService.set('chatLog', [...chatLog, returnObj]);\n            else await this.redisService.set('chatLog', [returnObj]);\n\n            this.server.emit('receive_chat', returnObj);\n        } catch (err) {\n            client.emit('error', err.message);\n        }\n    }\n\n}"]}
{"filename": "src/socket-gateways/match/gateway.match.ts", "chunked_list": ["import { WebSocketGateway, WebSocketServer } from \"@nestjs/websockets\";\nimport { Server } from \"socket.io\";\nimport { MatchStatus, MatchDto, CustomMatchDto } from \"src/pages/match/dto/match.dto\";\n\n@WebSocketGateway(8080, {\n    transports: ['websocket'],\n    cors: {\n        origin: '*',\n    },\n})\nexport class MatchGateway {\n    constructor() { }\n    @WebSocketServer()\n    server: Server;\n\n    async broadcastMatchinfo(\n        info_type: MatchStatus,\n        socketId: string,\n        userId: string,\n        matchInfo: MatchDto | CustomMatchDto\n    ) {\n        this.server.to(socketId).emit(info_type, {\n            userId: userId,\n            matchInfo: matchInfo,\n        });\n    }\n}", "    },\n})\nexport class MatchGateway {\n    constructor() { }\n    @WebSocketServer()\n    server: Server;\n\n    async broadcastMatchinfo(\n        info_type: MatchStatus,\n        socketId: string,\n        userId: string,\n        matchInfo: MatchDto | CustomMatchDto\n    ) {\n        this.server.to(socketId).emit(info_type, {\n            userId: userId,\n            matchInfo: matchInfo,\n        });\n    }\n}"]}
{"filename": "src/pages/chat/chat.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { ChatService } from './chat.service';\nimport { RedisCacheModule } from 'src/cache/redis.module';\nimport { ChatController } from './chat.controller';\nimport { GatewayModule } from 'src/socket-gateways/gateway.module';\n\n@Module({\n    imports: [", "@Module({\n    imports: [\n        TypeOrmModule.forFeature([]),\n        AuthModule,\n        RedisCacheModule,\n        forwardRef(() => GatewayModule),\n    ],\n    controllers: [ChatController],\n    providers: [ChatService],\n    exports: [ChatService],", "    providers: [ChatService],\n    exports: [ChatService],\n})\nexport class ChatModule { }\n"]}
{"filename": "src/pages/chat/chat.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\nimport { Server, Socket } from \"socket.io\";\nimport { RedisCacheService } from \"src/cache/redis.service\";\nimport { ChatDto } from \"./dto/chat.dto\";\n\n@Injectable()\nexport class ChatService {\n    constructor(\n        private redisService: RedisCacheService,\n    ){}\n\n    async getChatLog(limit: number): Promise<ChatDto[]>{", "        try{\n            const chatLog = await this.redisService.get(\"chatLog\");\n            if(!chatLog) {\n                await this.redisService.set(\"chatLog\", []);\n                return [];\n            }\n            if(chatLog.length > limit) return chatLog.slice(chatLog.length - limit, chatLog.length);\n            else return chatLog;\n        }catch(e){\n            throw new Error(e);\n        }\n    }\n}", "        }catch(e){\n            throw new Error(e);\n        }\n    }\n}"]}
{"filename": "src/pages/chat/chat.controller.ts", "chunked_list": ["import{ Controller, Get, Param, Query } from '@nestjs/common';\nimport { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\nimport { ChatService } from './chat.service';\nimport { ChatDto } from './dto/chat.dto';\n\n@Controller('chat')\n@ApiTags('\ucc44\ud305')\nexport class ChatController {\n    constructor(\n        private readonly chatService: ChatService,\n    ){}\n\n    @Get('log')\n    @ApiOperation({\n        summary: '\ucc44\ud305 \ub85c\uadf8 \uac00\uc838\uc624\uae30',\n        description: '\ucc44\ud305 \ub85c\uadf8\ub97c \uac00\uc838\uc635\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ucc44\ud305 \ub85c\uadf8 \uac00\uc838\uc624\uae30 \uc131\uacf5',\n        type: ChatDto,\n        status: 200\n    })\n    async getChatLog(\n        @Query('limit') limit: number = 10\n    ): Promise<ChatDto[]>{", "        try{\n            const result = await this.chatService.getChatLog(limit);\n            return result;\n        }catch(e){\n            throw new Error(e);\n        }\n    }\n\n}"]}
{"filename": "src/pages/chat/dto/chat.dto.ts", "chunked_list": ["export class ChatDto {\n    type: string;\n    message: string;\n    sender: string;\n    timestamp: number;\n}"]}
{"filename": "src/pages/users/user.repository.ts", "chunked_list": ["import { DataSource, Repository } from \"typeorm\";\nimport { User } from \"./user.entity\";\nimport * as bcrypt from 'bcryptjs';\nimport { ConflictException, Injectable, InternalServerErrorException } from \"@nestjs/common\";\nimport { AuthCredentialDto } from \"src/auth/dto/auth-credential.dto\";\n\n\n@Injectable()\nexport class UserRepository extends Repository<User>{\n    constructor(private dataSource: DataSource) {\n        super(User, dataSource.createEntityManager());\n    }\n    async createUser(authCredentialDto: AuthCredentialDto): Promise<User> {\n        const { customId, name, email, password } = authCredentialDto;\n\n        const salt = await bcrypt.genSalt();\n        const hashedPassword = await bcrypt.hash(password, salt);\n\n        const user = this.create({\n            customId,\n            name,\n            email,\n            password : hashedPassword\n        })", "export class UserRepository extends Repository<User>{\n    constructor(private dataSource: DataSource) {\n        super(User, dataSource.createEntityManager());\n    }\n    async createUser(authCredentialDto: AuthCredentialDto): Promise<User> {\n        const { customId, name, email, password } = authCredentialDto;\n\n        const salt = await bcrypt.genSalt();\n        const hashedPassword = await bcrypt.hash(password, salt);\n\n        const user = this.create({\n            customId,\n            name,\n            email,\n            password : hashedPassword\n        })", "        try{\n            await this.save(user);\n            return user;\n        }\n        catch(error){\n            if(error.code === '23505'){\n                throw new ConflictException('User already exists');\n            }\n            else{\n                console.log(error);\n                throw new InternalServerErrorException();\n            }\n        }\n    }\n}"]}
{"filename": "src/pages/users/user.entity.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\nimport { BaseEntity, Column, Entity, PrimaryGeneratedColumn, Unique } from 'typeorm';\n\n@Entity()\n@Unique(['customId'])\nexport class User extends BaseEntity{\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uace0\uc720\ubc88\ud638', example: '1'})\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc544\uc774\ub514', example: 'jswcyber'})\n    @Column()\n    customId: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc774\ub984', example: '\uc815\uc131\uc6b1'})\n    @Column({ length: 30 })\n    name: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc774\uba54\uc77c', example: 'jswcyber@naver.com'})\n    @Column({ length: 60 })\n    email: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \ube44\ubc00\ubc88\ud638', example: 'Qlalfqjsgh1234!@'})\n    @Column()\n    password: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uad8c\ud55c', example: 'admin'})\n    @Column({ default:1 })\n    role: number;\n\n    @ApiProperty({description: 'Refresh Token'})\n    @Column({ nullable: true })\n    refreshToken: string;\n\n    @ApiProperty({description: '\uc18c\ucf13 \uc544\uc774\ub514'})\n    @Column({ nullable: true })\n    socketId: string;\n\n    @ApiProperty({description: '\uac00\uc785\uc77c', example: '2021-01-01 00:00:00'})\n    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n    createdAt: Date;\n\n    @ApiProperty({description: '\ub9c8\uc9c0\ub9c9 \uc811\uc18d\uc77c', example: '2021-01-01 00:00:00'})\n    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n    updatedAt: Date;\n\n    @ApiProperty({description: '\uc811\uc18d \uc885\ub8cc\uc77c', example: '2021-01-01 00:00:00'})\n    @Column({ type: 'timestamp', nullable: true })\n    exitAt: Date;\n}"]}
{"filename": "src/pages/users/users.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserRepository } from './user.repository';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [", "@Module({\n  imports: [\n    TypeOrmModule.forFeature([User]),\n    AuthModule\n  ],\n  controllers: [UsersController],\n  providers: [UsersService, UserRepository],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n", "})\nexport class UsersModule {}\n"]}
{"filename": "src/pages/users/users.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { User } from './user.entity';\nimport { UserRepository } from './user.repository';\nimport { EntityManager, IsNull, Not } from 'typeorm';\nimport * as bcrypt from 'bcryptjs';\nimport * as jwt from 'jsonwebtoken';\nimport { Server, Socket } from 'socket.io';\n", "import { Server, Socket } from 'socket.io';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(UserRepository)\n    private userRepository: UserRepository\n  ) { }\n\n  async getAllUsers(): Promise<{ statusCode: string, contents: User[] }> {\n    const userObj = await this.userRepository.find();\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async getUserInfo(user: User): Promise<{ statusCode: string, contents: User }> {\n    const userObj = await this.userRepository.findOne({ where: { customId: user.customId } });\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async getUser(refreshToken: string): Promise<{ statusCode: string, contents: User }> {\n    const userId = await jwt.verify(refreshToken, process.env.JWT_REFRESH_TOKEN_SECRET, (err, decoded) => {", "      if (err) {\n        return null;\n      }\n      return decoded['id'];\n    });\n\n    if (userId == null) {\n      return { statusCode: '404', contents: null };\n    }\n\n    const userObj = await this.userRepository.createQueryBuilder(\"user\")\n      .select([\"user.id\", \"user.customId\", \"user.name\", \"user.email\", \"user.role\", \"user.refreshToken\", \"user.socketId\"])\n      .where('user.id = :id', { id: userId })\n      .getOne();\n\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async socketIdUpdate(user: User, socketId: string): Promise<{ statusCode: string, contents: User }> {\n    const userObj = await this.userRepository.findOne({ where: { customId: user.customId } });\n    userObj.socketId = socketId;\n    userObj.updatedAt = new Date();\n    await this.userRepository.save(userObj);\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async disconnectSocketId(socketId: string): Promise<{ statusCode: string, contents: User }> {\n    const userObj = await this.userRepository.findOne({ where: { socketId: socketId } });\n    userObj.socketId = null;\n    userObj.exitAt = new Date();\n    await this.userRepository.save(userObj);\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async updateDisconnectSocketId(customId: string): Promise<{ statusCode: string, contents: User }> {\n    const userObj = await this.userRepository.findOne({ where: { customId: customId } });\n    userObj.socketId = null;\n    userObj.exitAt = new Date();\n    await this.userRepository.save(userObj);\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async userSocketConnectionCheck(userId: number) {\n    const userObj = await this.userRepository.findOne({ where: { id: userId } });", "    if (userObj.socketId == null) {\n      return;\n    }\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async getUserByCustomId(customId: string): Promise<{ statusCode: string, contents: User }> {\n    const userObj = await this.userRepository.findOne({ where: { customId: customId } });\n    return { statusCode: '200', contents: userObj };\n  }\n\n  async getConnectedUser(): Promise<{ statusCode: string, contents: User[] }> {\n    //socketId\uac00 null\uc774 \uc544\ub2cc \uc720\uc800\ub4e4\uc744 \uac00\uc838\uc628\ub2e4.\n    const userObj = await this.userRepository.find({ where: { socketId: Not(IsNull()) } });\n    return { statusCode: '200', contents: userObj };\n  }\n}"]}
{"filename": "src/pages/users/users.controller.ts", "chunked_list": ["import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { AuthGuard } from '@nestjs/passport';\nimport { User } from './user.entity';\nimport { GetUser } from 'src/auth/get-user.decorator';\nimport { ApiTags } from '@nestjs/swagger';\n\n@Controller('users')\n@ApiTags('\ud68c\uc6d0 \uc815\ubcf4')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Get()\n  @UseGuards(AuthGuard(\"jwt\"))\n  getUserInfo(@GetUser() user:User) : Promise<{statusCode:string, contents:User}> {\n    return this.usersService.getUserInfo(user);\n  }\n}", "@Controller('users')\n@ApiTags('\ud68c\uc6d0 \uc815\ubcf4')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Get()\n  @UseGuards(AuthGuard(\"jwt\"))\n  getUserInfo(@GetUser() user:User) : Promise<{statusCode:string, contents:User}> {\n    return this.usersService.getUserInfo(user);\n  }\n}"]}
{"filename": "src/pages/users/dto/user-info.dto.ts", "chunked_list": ["export enum UserStatus {\n    ONLINE = 'online',\n    OFFLINE = 'offline',\n    RANDOM_MATCHING = 'random_matching',\n    CUSTOM_MATCHING = 'custom_matching',\n    MATCHING_SUCCESS = 'matching_success',\n}\n\nexport class UserInfo {\n    status: UserStatus;\n}", "export class UserInfo {\n    status: UserStatus;\n}"]}
{"filename": "src/pages/users/dto/create-user.dto.ts", "chunked_list": ["import { IsNotEmpty } from \"class-validator\";\n\nexport class CreateUserDto {\n    @IsNotEmpty()\n    customId: string;\n    @IsNotEmpty()\n    name: string;\n    @IsNotEmpty()\n    email: string;\n    @IsNotEmpty()\n    password: string;\n}\n"]}
{"filename": "src/pages/match/match.service.ts", "chunked_list": ["import { HttpException, HttpStatus, Injectable } from \"@nestjs/common\";\nimport { Server, Socket } from \"socket.io\";\nimport { RedisCacheService } from \"src/cache/redis.service\";\nimport { MatchStatus, MatchDto, MatchType, MatchCreateDto, MatchJoinDto, CustomMatchDto } from \"./dto/match.dto\";\nimport { generateSessionId } from \"src/utils/util\";\nimport { MatchGateway } from \"src/socket-gateways/match/gateway.match\";\nimport { UsersService } from \"../users/users.service\";\nimport { UserInfo, UserStatus } from \"../users/dto/user-info.dto\";\n/**\n * @todo", "/**\n * @todo\n * @notice\n * - \ubaa8\ub4e0 \ub300\uae30\uc5f4\uc774\ub098 \ubc29\ub4e4\uc740 Redis \uc5d0 \uc800\uc7a5\ub418\uc5b4\uc57c \ud55c\ub2e4.\n * - \ub05d\uc5d0 _queue \ub97c \ubd99\uc5ec\uc11c \uc800\uc7a5\ud55c\ub2e4.\n */\n@Injectable()\nexport class MatchService {\n    constructor(\n        private redisService: RedisCacheService,\n        private matchGateway: MatchGateway,\n        private usersService: UsersService,\n    ) { }\n\n    async updateMatchQueue(matchType: MatchType, queue: MatchDto[]): Promise<void> {", "        try {\n            await this.redisService.set(matchType + \"_queue\", queue);\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async getMatchQueue(matchType: string): Promise<MatchDto[]> {\n        try {\n            const queue: MatchDto[] = await this.redisService.get(matchType + \"_queue\");\n            return queue;\n        }", "        try {\n            const queue: MatchDto[] = await this.redisService.get(matchType + \"_queue\");\n            return queue;\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    // Cron \uc5d0\uc11c \uc720\uc800\ub97c \ub2e4\ub978 \ub9e4\uce58\ub85c \uc62e\uae30\ub294 \uc791\uc5c5\uc744 \uc218\ud589\ud560 \ub54c \uc0ac\uc6a9\ud55c\ub2e4.\n    async replaceMatchQueue(customIds: string[]): Promise<void> {", "        try {\n            customIds.forEach(async (customId: string) => {\n                const match = await this.randomMatch_1on1_queue(customId);\n                const socketId = (await this.usersService.getUser(customId)).contents.socketId;\n                await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_CHANGE, socketId, customId, match);\n            });\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async randomMatch_1on1_queue(customId: string) {", "        try {\n            const user = await this.usersService.getUserByCustomId(customId);\n            const queue: MatchDto[] = await this.redisService.get(MatchType.RANDOM_MATCH_1ON1 + \"_queue\");\n\n            if (!queue) {\n                const newQueue: MatchDto[] = [];\n                const matchId = generateSessionId();\n                const newMatch: MatchDto = {\n                    match_id: matchId,\n                    match_type: MatchType.RANDOM_MATCH_1ON1,\n                    match_status: MatchStatus.MATCH_START,\n                    match_start_time: new Date(),\n                    match_end_time: null,\n                    join_user: [customId],\n                };\n                newQueue.push(newMatch);\n                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", newQueue);\n                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, newMatch);\n                return newMatch;\n            }\n\n            const match: MatchDto = queue.find((match: MatchDto) => match.match_status === MatchStatus.MATCH_START && match.join_user.length < 2);", "            if (match) {\n                match.join_user.push(customId);\n                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", queue);\n                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, match);\n                return match;\n            } else {\n                const matchId = generateSessionId();\n                const newMatch: MatchDto = {\n                    match_id: matchId,\n                    match_type: MatchType.RANDOM_MATCH_1ON1,\n                    match_status: MatchStatus.MATCH_START,\n                    match_start_time: new Date(),\n                    match_end_time: null,\n                    join_user: [customId],\n                };\n                queue.push(newMatch);\n                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", queue);\n                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, newMatch);\n                return newMatch;\n            }", "        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async createCustomMatch(customId: string, dto: MatchCreateDto) {\n        try {\n            const user = await this.usersService.getUserByCustomId(customId);\n            const user_status: UserInfo = await this.redisService.get(customId + \"_info\");\n            if (\n                !user_status\n                || !user_status.status\n                || user_status.status == UserStatus.CUSTOM_MATCHING\n                || user_status.status == UserStatus.MATCHING_SUCCESS\n                || user_status.status == UserStatus.RANDOM_MATCHING\n                || user_status.status == UserStatus.OFFLINE\n            ) throw new Error(\"\ubc29\uc744 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n            const match: CustomMatchDto = {\n                match_id: generateSessionId(),\n                match_type: dto.match_type,\n                match_status: MatchStatus.MATCH_START,\n                match_start_time: new Date(),\n                match_end_time: null,\n                join_user: [customId],\n                match_title: dto.match_title,\n                match_private: dto.match_private,\n                match_owner: customId,\n            }", "            if (\n                !user_status\n                || !user_status.status\n                || user_status.status == UserStatus.CUSTOM_MATCHING\n                || user_status.status == UserStatus.MATCHING_SUCCESS\n                || user_status.status == UserStatus.RANDOM_MATCHING\n                || user_status.status == UserStatus.OFFLINE\n            ) throw new Error(\"\ubc29\uc744 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n            const match: CustomMatchDto = {\n                match_id: generateSessionId(),\n                match_type: dto.match_type,\n                match_status: MatchStatus.MATCH_START,\n                match_start_time: new Date(),\n                match_end_time: null,\n                join_user: [customId],\n                match_title: dto.match_title,\n                match_private: dto.match_private,\n                match_owner: customId,\n            }", "            if(match.match_private) match.match_password = dto.match_password;\n            \n            await this.redisService.push(dto.match_type + \"_queue\", match);\n            await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_CREATE, user.contents.socketId, customId, match);\n            return match;\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async joinCustomMatch(body: MatchJoinDto, customId: string) {", "        try {\n            const user = await this.usersService.getUserByCustomId(customId);\n            const user_status: UserInfo = await this.redisService.get(customId + \"_info\");\n            if (\n                !user_status\n                || !user_status.status\n                || user_status.status == UserStatus.CUSTOM_MATCHING\n                || user_status.status == UserStatus.MATCHING_SUCCESS\n                || user_status.status == UserStatus.RANDOM_MATCHING\n                || user_status.status == UserStatus.OFFLINE\n            ) throw new Error(\"\ubc29\uc5d0 \ucc38\uc5ec\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n            const match: CustomMatchDto = await this.getCustomMatch(body.match_id);", "            if (!match) throw new Error(\"\ubc29\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\");\n            if (match.join_user.length >= 2) throw new Error(\"\ubc29\uc774 \uaf49 \ucc3c\uc2b5\ub2c8\ub2e4.\");\n            if (match.match_private){\n                if (match.match_password != body.match_password) throw new Error(\"\ube44\ubc00\ubc88\ud638\uac00 \ud2c0\ub838\uc2b5\ub2c8\ub2e4.\");\n            }\n            match.join_user.push(customId);\n            await this.redisService.set(match.match_type + \"_queue\", match);\n            await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_JOIN, user.contents.socketId, customId, match);\n            return match;\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async leaveMatch_1on1(socket: Socket, server: Server) {\n    }\n\n    async getCustomMatches() {\n        const matches: MatchDto[] = [];", "        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async leaveMatch_1on1(socket: Socket, server: Server) {\n    }\n\n    async getCustomMatches() {\n        const matches: MatchDto[] = [];\n        for (const type in MatchType) {\n            const match: MatchDto[] = await this.redisService.get(type + \"_queue\");", "        for (const type in MatchType) {\n            const match: MatchDto[] = await this.redisService.get(type + \"_queue\");\n            if(match) matches.push(...match);\n        }\n\n        if(!matches) return [];\n        return matches;\n    }\n\n    async getCustomMatch(matchId: string): Promise<CustomMatchDto> {\n        const matches: CustomMatchDto[] = [];", "        for (const type in MatchType) {\n            const match: CustomMatchDto[] = await this.redisService.get(type + \"_queue\");\n            if(match) matches.push(...match);\n        }\n        if(!matches) throw new HttpException(\"\ubc29\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\", HttpStatus.BAD_REQUEST);\n        const match: CustomMatchDto = matches.find((match: CustomMatchDto) => match.match_id === matchId);\n        return match;\n    }\n\n    async getMyMatchProgress(customId: string) {\n        try {\n            let match_type: string[] = Object.values(MatchType);\n            match_type.forEach(async (type: string) => {\n                const matches: MatchDto[] = await this.redisService.get(type + \"_queue\");", "        try {\n            let match_type: string[] = Object.values(MatchType);\n            match_type.forEach(async (type: string) => {\n                const matches: MatchDto[] = await this.redisService.get(type + \"_queue\");\n                if (matches) {\n                    const match: MatchDto = matches.find((match: MatchDto) => match.join_user.includes(customId));\n                    if (match) {\n                        return match;\n                    }\n                }\n            });\n            return null", "        } catch (e) {\n            throw new Error(e);\n        }\n    }\n}"]}
{"filename": "src/pages/match/match.controller.ts", "chunked_list": ["import { Body, Controller, Get, HttpException, Param, Post, UseGuards } from \"@nestjs/common\";\nimport { ApiOperation, ApiResponse, ApiTags } from \"@nestjs/swagger\";\nimport { MatchService } from \"./match.service\";\nimport { AuthGuard } from \"@nestjs/passport\";\nimport { GetUser } from \"src/auth/get-user.decorator\";\nimport { User } from \"../users/user.entity\";\nimport { DefaultResponseMatchDto, MatchCreateDto, MatchDto, MatchJoinDto } from \"./dto/match.dto\";\n\n@Controller('match')\n@ApiTags('\ub9e4\uce6d')\nexport class MatchController {\n    constructor(private readonly matchService: MatchService) { }\n\n    @Get('random-match-1on1-queue')\n    @ApiOperation({\n        summary: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4',\n        description: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4\uc5d0 \ucc38\uac00\ud569\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4 \ucc38\uac00 \uc131\uacf5',\n        type: DefaultResponseMatchDto,\n        status: 200\n    })\n    @UseGuards(AuthGuard(\"jwt\"))\n    async randomMatch_1on1_queue(\n        @GetUser() user: User\n    ): Promise<DefaultResponseMatchDto> {", "@Controller('match')\n@ApiTags('\ub9e4\uce6d')\nexport class MatchController {\n    constructor(private readonly matchService: MatchService) { }\n\n    @Get('random-match-1on1-queue')\n    @ApiOperation({\n        summary: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4',\n        description: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4\uc5d0 \ucc38\uac00\ud569\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ub79c\ub364 \ub9e4\uce6d 1:1 \ub300\uae30\uc5f4 \ucc38\uac00 \uc131\uacf5',\n        type: DefaultResponseMatchDto,\n        status: 200\n    })\n    @UseGuards(AuthGuard(\"jwt\"))\n    async randomMatch_1on1_queue(\n        @GetUser() user: User\n    ): Promise<DefaultResponseMatchDto> {", "        try {\n            const result = await this.matchService.randomMatch_1on1_queue(user.customId);\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new HttpException(e.message, e.status);\n        }\n    }\n\n    @Post('create-custom-match')\n    @ApiOperation({\n        summary: '\ucee4\uc2a4\ud140 \ub9e4\uce6d\uc0dd\uc131',\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d\uc744 \uc0dd\uc131\ud569\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d \uc0dd\uc131 \uc131\uacf5',\n        type: DefaultResponseMatchDto,\n        status: 200\n    })\n    @UseGuards(AuthGuard(\"jwt\"))\n    async createMatch_1on1(\n        @GetUser() user: User,\n        @Body() body:MatchCreateDto\n    ): Promise<DefaultResponseMatchDto> {", "        try {\n            const result = await this.matchService.createCustomMatch(user.customId, body);\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new HttpException(e.message, e.status);\n        }\n\n    }\n\n    @Post('join-custom-match')\n    @ApiOperation({\n        summary: '\ucee4\uc2a4\ud140 \ub9e4\uce6d \ucc38\uac00',\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d\uc5d0 \ucc38\uac00\ud569\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d \ucc38\uac00 \uc131\uacf5',\n        type: DefaultResponseMatchDto,\n        status: 200\n    })\n    @UseGuards(AuthGuard(\"jwt\"))\n    async joinMatch_1on1(\n        @GetUser() user: User,\n        @Body() body: MatchJoinDto\n    ): Promise<DefaultResponseMatchDto> {", "        try {\n            const result = await this.matchService.joinCustomMatch(body, user.customId);\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new HttpException(e.message, e.status);\n        }\n    }\n\n    @Get('custom-matches')\n    @ApiOperation({\n        summary: '\ucee4\uc2a4\ud140 \ub9e4\uce6d 1:1 \ubaa9\ub85d',\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d 1:1 \ubaa9\ub85d\uc744 \uac00\uc838\uc635\ub2c8\ub2e4.'\n    })\n    async getCustomMatch(\n    ) {", "        try {\n            const result = await this.matchService.getCustomMatches();\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    @Get('custom-match/:matchId')\n    @ApiOperation({\n        summary: '\ucee4\uc2a4\ud140 \ub9e4\uce6d 1:1 \uc815\ubcf4',\n        description: '\ucee4\uc2a4\ud140 \ub9e4\uce6d 1:1 \uc815\ubcf4\ub97c \uac00\uc838\uc635\ub2c8\ub2e4.'\n    })\n    async getCustomMatchById(\n        @Param('matchId') matchId: string\n    ): Promise<DefaultResponseMatchDto> {", "        try {\n            const result = await this.matchService.getCustomMatch(matchId);\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new HttpException(e.message, e.status);\n        }\n    }\n\n    @Get('my-match-progress')\n    @ApiOperation({\n        summary: '\ub0b4 \ub9e4\uce6d \uc9c4\ud589 \uc0c1\ud669',\n        description: '\ub0b4 \ub9e4\uce6d \uc9c4\ud589 \uc0c1\ud669\uc744 \uac00\uc838\uc635\ub2c8\ub2e4.'\n    })\n    @ApiResponse({\n        description: '\ub0b4 \ub9e4\uce6d \uc9c4\ud589 \uc0c1\ud669 \uac00\uc838\uc624\uae30 \uc131\uacf5',\n        type: DefaultResponseMatchDto,\n        status: 200\n    })\n    @UseGuards(AuthGuard(\"jwt\"))\n    async getMyMatchProgress(\n        @GetUser() user: User\n    ): Promise<DefaultResponseMatchDto> {", "        try {\n            const result = await this.matchService.getMyMatchProgress(user.customId);\n            return {\n                statusCode: 200,\n                contents: result\n            }\n        } catch (e) {\n            throw new HttpException(e.message, e.status);\n        }\n    }\n}"]}
{"filename": "src/pages/match/match.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { MatchService } from './match.service';\nimport { RedisCacheModule } from 'src/cache/redis.module';\nimport { GatewayModule } from 'src/socket-gateways/gateway.module';\nimport { UsersModule } from '../users/users.module';\nimport { MatchController } from './match.controller';\n\n@Module({", "\n@Module({\n    imports: [\n        TypeOrmModule.forFeature([]),\n        AuthModule,\n        RedisCacheModule,\n        UsersModule,\n        forwardRef(() => GatewayModule),\n    ],\n    controllers: [MatchController,],", "    ],\n    controllers: [MatchController,],\n    providers: [MatchService,],\n    exports: [MatchService],\n})\nexport class MatchModule { }\n"]}
{"filename": "src/pages/match/dto/match.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\nexport class MatchDto {\n    @ApiProperty({\n        description: '\ub9e4\uce58 ID',\n        example: '1234567890',\n    })\n    match_id: string;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \ud0c0\uc785',\n        example: 'random_match_1on1',\n    })\n    match_type: MatchType;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \uc0c1\ud0dc',\n        example: 'match_change',\n    })\n    match_status: MatchStatus;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \uc0dd\uc131 \uc2dc\uac04',\n        example: '2021-01-01T00:00:00.000Z',\n    })\n    match_start_time: Date;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \uc885\ub8cc \uc2dc\uac04',\n        example: '2021-01-01T00:00:00.000Z',\n    })\n    match_end_time?: Date;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \ub7ad\ud06c \uc810\uc218',\n        example: 1000,\n    })\n    match_rank_score?: number;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \ucc38\uac00 \uc720\uc800',\n        example: ['jswcyber', 'abc123'],\n    })\n    join_user: string[];\n}\n", "export class CustomMatchDto extends MatchDto {\n    @ApiProperty({\n        description: '\ubc29 \uc81c\ubaa9',\n        example: '\ub79c\ub364 \ub9e4\uce6d 1:1',\n    })\n    match_title: string;\n\n    @ApiProperty({\n        description: '\ubc29 \ube44\ubc00\ubc88\ud638',\n        example: '1234',\n    })\n    match_password?: string;\n\n    @ApiProperty({\n        description: '\ube44\ubc00 \ubc29 \uc5ec\ubd80',\n        example: true,\n    })\n    match_private: boolean;\n\n    @ApiProperty({\n        description: '\ubc29\uc7a5 \uc720\uc800',\n        example: 'jswcyber',\n    })\n    match_owner: string;\n}\n", "export class DefaultResponseMatchDto {\n    @ApiProperty({\n        description: '\uc751\ub2f5 \ucf54\ub4dc',\n        example: 200,\n    })\n    statusCode: number;\n\n    @ApiProperty({\n        description: '\uc804\ub2ec \ub370\uc774\ud130'\n    })\n    contents: MatchDto;\n}\n", "export class MatchCreateDto {\n    @ApiProperty({\n        description: '\ub9e4\uce58 \ud0c0\uc785',\n        example: 'random_match_1on1',\n    })\n    match_type: MatchType;\n\n    @ApiProperty({\n        description: '\ubc29 \uc81c\ubaa9',\n        example: '\ub79c\ub364 \ub9e4\uce6d 1:1',\n    })\n    match_title: string;\n\n    @ApiProperty({\n        description: '\ubc29 \ube44\ubc00\ubc88\ud638',\n        example: '1234',\n    })\n    match_password?: string;\n\n    @ApiProperty({\n        description: '\ube44\ubc00 \ubc29 \uc5ec\ubd80',\n        example: true,\n    })\n    match_private: boolean;\n}\n", "export class MatchJoinDto {\n    @ApiProperty({\n        description: '\ub9e4\uce58 ID',\n        example: '1234567890',\n    })\n    match_id: string;\n\n    @ApiProperty({\n        description: '\ub9e4\uce58 \ud0c0\uc785',\n        example: 'random_match_1on1',\n    })\n    match_type: MatchType;\n\n    @ApiProperty({\n        description: '\ubc29 \ube44\ubc00\ubc88\ud638',\n        example: '1234',\n    })\n    match_password: string;\n}\n", "export enum MatchType {\n    RANDOM_MATCH_1ON1 = \"random_match_1on1\",\n    RANDOM_MATCH_2ON2 = \"random_match_2on2\",\n    CUSTOM_MATCH_1ON1 = \"custom_match_1on1\",\n}\n\nexport enum MatchStatus {\n    MATCH_CHANGE = \"match_change\",\n    MATCH_START = \"match_start\",\n    MATCH_SUCCESS = \"match_success\",\n    MATCH_CANCEL = \"match_cancel\",\n    MATCH_CREATE = \"match_create\",\n    MATCH_JOIN = \"match_join\",\n}"]}
{"filename": "src/pages/broadcast/broadcast.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\nimport { Server, Socket } from \"socket.io\";\n\n@Injectable()\nexport class BroadcastService {\n    constructor(){}\n\n    async serverBroadcast(server: Server, channel: string, data: any){\n        server.emit(channel, data);\n    }\n}"]}
{"filename": "src/pages/broadcast/broadcast.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { BroadcastService } from './broadcast.service';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([]),\n    AuthModule\n  ],", "    AuthModule\n  ],\n  controllers: [],\n  providers: [BroadcastService],\n  exports: [BroadcastService],\n})\nexport class BroadcastModule {}\n"]}
{"filename": "src/pages/schedule/scheduler.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { SchedulerService } from './scheduler.service';\nimport { ScheduleModule } from '@nestjs/schedule';\nimport { UsersModule } from '../users/users.module';\nimport { GatewayModule } from 'src/socket-gateways/gateway.module';\nimport { MatchModule } from '../match/match.module';\n\n@Module({", "\n@Module({\n    imports: [\n        TypeOrmModule.forFeature([]),\n        ScheduleModule.forRoot(),\n        AuthModule,\n        UsersModule,\n        GatewayModule,\n        MatchModule,\n    ],", "        MatchModule,\n    ],\n    controllers: [],\n    providers: [SchedulerService],\n    exports: [SchedulerService],\n})\nexport class SchedulerModule { }\n"]}
{"filename": "src/pages/schedule/scheduler.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\nimport { Server, Socket } from \"socket.io\";\nimport { Cron, CronExpression, SchedulerRegistry } from \"@nestjs/schedule\";\nimport { CronJob } from \"cron\";\nimport { UsersService } from \"../users/users.service\";\nimport { WebSocketServer } from \"@nestjs/websockets\";\nimport { CoreGateway } from \"src/socket-gateways/gateway.core\";\nimport { MatchService } from \"../match/match.service\";\nimport { MatchStatus, MatchDto, MatchType } from \"../match/dto/match.dto\";\nimport { MatchGateway } from \"src/socket-gateways/match/gateway.match\";", "import { MatchStatus, MatchDto, MatchType } from \"../match/dto/match.dto\";\nimport { MatchGateway } from \"src/socket-gateways/match/gateway.match\";\nimport { async } from \"rxjs\";\n\n@Injectable()\nexport class SchedulerService {\n    constructor(\n        private schedulerRegistry: SchedulerRegistry,\n        private usersService: UsersService,\n        private matchService: MatchService,\n        private coreGateway: CoreGateway,\n        private matchGateway: MatchGateway,\n    ) { }\n\n    async createCronJob(name: string, time: string, callback: () => void) {\n        const job = new CronJob(time, callback);\n\n        this.schedulerRegistry.addCronJob(name, job);\n        job.start();\n    }\n\n    async deleteCronJob(name: string) {\n        const job = this.schedulerRegistry.getCronJob(name);\n        job.stop();\n        this.schedulerRegistry.deleteCronJob(name);\n    }\n\n    async getCronJob(name: string) {\n        return this.schedulerRegistry.getCronJob(name);\n    }\n\n    /**\n     * @description\n     * - 1\ubd84 \uac04\uaca9\uc73c\ub85c \uc811\uc18d\ud55c \uc720\uc800\uc640 \uc811\uc18d\ud558\uc9c0 \uc54a\uc740 \uc720\uc800\ub97c \uad6c\ubd84\ud568.\n     * - \uc811\uc18d\uc774 \ub04a\uae34 \uc720\uc800\uc758 \uc18c\ucf13\uc744 \uc81c\uac70.\n     */\n    @Cron(CronExpression.EVERY_10_SECONDS, {\n        name: \"disconnect-user-cron\",\n    })\n    async disconnectUserCron() {\n        const allUsers = (await this.usersService.getAllUsers()).contents;\n        const socket = await this.coreGateway.getClients();\n        const disconnectedUser = [];\n        const connectedUser = [];\n", "        for (let i = 0; i < allUsers.length; i++) {\n            const user = allUsers[i];\n            const isHas = socket.has(user.socketId);\n            if (isHas) {\n                connectedUser.push(user);\n            } else {\n                disconnectedUser.push(user);\n            }\n        }\n\n        disconnectedUser.forEach(async (user) => {", "            if (user.socketId === null) return;\n            await this.usersService.updateDisconnectSocketId(user.customId);\n        });\n    }\n\n    /**\n     * @description\n     * - Match Queue\uc5d0 \uc788\ub294 \uc720\uc800\ub4e4\uc744 \ub9e4\uce6d\uc2dc\ud0b4.\n     * @todo\n     * - \ub9e4\uce58 \uc131\uc0ac \uc2dc history\ub97c DB\uc5d0 \uc800\uc7a5\ud568.\n     */\n    @Cron(CronExpression.EVERY_5_SECONDS, {\n        name: \"match-queue-cron\",\n    })\n    async matchQueueCron() {\n        const queue : MatchDto[] = await this.matchService.getMatchQueue(MatchType.RANDOM_MATCH_1ON1);\n        ", "        if (!queue) return;\n        await this.matchService.updateMatchQueue(MatchType.RANDOM_MATCH_1ON1, []);\n\n        for (const match of queue) {\n            if (match.join_user.length >= 2) {\n                if (match.join_user.length > 2) {\n                    const overUsers: string[] = match.join_user.splice(2, match.join_user.length - 2);\n                    this.matchService.replaceMatchQueue(overUsers);\n                }\n                match.match_status = MatchStatus.MATCH_SUCCESS;\n                match.match_end_time = new Date();\n                const broadUserInfo = [];", "                for(const userId of match.join_user) {\n                    const user = (await this.usersService.getUserByCustomId(userId)).contents;\n                    if (!user || user.socketId === null) {\n                        match.match_status = MatchStatus.MATCH_START;\n                        match.match_end_time = null;\n                        match.join_user.splice(match.join_user.indexOf(userId), 1);\n                        break;\n                    }\n                    broadUserInfo.push({\n                        userId: userId,\n                        socketId: user.socketId,\n                    });\n                }", "                if (match.match_status === MatchStatus.MATCH_SUCCESS) {\n                    broadUserInfo.forEach(async(user) => {\n                        await this.matchGateway.broadcastMatchinfo(\n                            MatchStatus.MATCH_SUCCESS,\n                            user.socketId,\n                            user.customId,\n                            match\n                        );\n                    });\n                    queue.splice(queue.indexOf(match), 1);\n                }\n            }\n        }\n\n        const nowQueue = await this.matchService.getMatchQueue(MatchType.RANDOM_MATCH_1ON1);\n        await this.matchService.updateMatchQueue(MatchType.RANDOM_MATCH_1ON1, [...nowQueue, ...queue]);\n    }\n}"]}
{"filename": "src/auth/get-user.decorator.ts", "chunked_list": ["import { createParamDecorator, ExecutionContext } from \"@nestjs/common\";\nimport { User } from \"src/pages/users/user.entity\";\n\nexport const GetUser = createParamDecorator((data, ctx: ExecutionContext): User => {\n    const req = ctx.switchToHttp().getRequest();\n    return req.user;\n})"]}
{"filename": "src/auth/auth.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserRepository } from 'src/pages/users/user.repository';\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtStrategy } from './jwt.strategy';\nimport { UsersService } from 'src/pages/users/users.service';\nimport { ConfigService } from '@nestjs/config';", "import { UsersService } from 'src/pages/users/users.service';\nimport { ConfigService } from '@nestjs/config';\nimport { User } from 'src/pages/users/user.entity';\nimport { JwtRefreshStrategy } from './jwt-refresh.strategy';\n\n@Module({\n  imports: [\n    PassportModule.register({ defaultStrategy: 'jwt' }),\n    JwtModule.registerAsync({\n      inject: [ConfigService],", "    JwtModule.registerAsync({\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => ({\n        secret : process.env.JWT_SECRET,\n        signOptions : {\n          expiresIn : 3600\n        },\n      }),\n    }),\n    TypeOrmModule.forFeature([User]),", "    }),\n    TypeOrmModule.forFeature([User]),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService, JwtStrategy, JwtRefreshStrategy, UsersService, UserRepository],\n  exports: [JwtStrategy, JwtRefreshStrategy, PassportModule]\n})\nexport class AuthModule {}\n"]}
{"filename": "src/auth/auth.controller.ts", "chunked_list": ["import { Body, Controller, Post, ValidationPipe, UseGuards, UseInterceptors, Get, Req, Res, HttpException } from '@nestjs/common';\nimport { User } from 'src/pages/users/user.entity';\nimport { AuthGuard } from '@nestjs/passport';\nimport { AuthService } from './auth.service';\nimport { AuthCredentialDto } from './dto/auth-credential.dto';\nimport { GetUser } from './get-user.decorator';\nimport { AuthLoginDto } from './dto/auth-login.dto';\nimport { ApiTags, ApiOperation, ApiCreatedResponse, ApiResponse } from '@nestjs/swagger';\nimport { DefaultResponseDto } from './dto/default-response.dto';\nimport { ErrorResponseDto } from './dto/error-response.dto';", "import { DefaultResponseDto } from './dto/default-response.dto';\nimport { ErrorResponseDto } from './dto/error-response.dto';\nimport { TransactionInterceptor } from 'src/decorators/TransactionInterceptor.decorator';\nimport { TransactionManager } from 'src/decorators/TransactionManager.decorator';\nimport { EntityManager } from 'typeorm';\n\n@Controller('auth')\n@UseInterceptors(TransactionInterceptor)\n@ApiTags('\uc720\uc800 \uc778\uc99d')\nexport class AuthController {\n    constructor(\n        private authService: AuthService\n    ) {}\n    @Post('/signup')\n    @ApiOperation({summary: '\ud68c\uc6d0\uac00\uc785', description: '\ud68c\uc6d0\uac00\uc785 \uc9c4\ud589'})\n    @ApiResponse({description: '\ud68c\uc6d0\uac00\uc785 \uc131\uacf5', type: DefaultResponseDto, status: 201})\n    @ApiResponse({description: '\ud68c\uc6d0\uac00\uc785 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    async signUp(\n        @Body(ValidationPipe) authCredentialDto: AuthCredentialDto,\n        @TransactionManager() queryRunnerManager: EntityManager,\n    ): Promise<DefaultResponseDto> {", "@ApiTags('\uc720\uc800 \uc778\uc99d')\nexport class AuthController {\n    constructor(\n        private authService: AuthService\n    ) {}\n    @Post('/signup')\n    @ApiOperation({summary: '\ud68c\uc6d0\uac00\uc785', description: '\ud68c\uc6d0\uac00\uc785 \uc9c4\ud589'})\n    @ApiResponse({description: '\ud68c\uc6d0\uac00\uc785 \uc131\uacf5', type: DefaultResponseDto, status: 201})\n    @ApiResponse({description: '\ud68c\uc6d0\uac00\uc785 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    async signUp(\n        @Body(ValidationPipe) authCredentialDto: AuthCredentialDto,\n        @TransactionManager() queryRunnerManager: EntityManager,\n    ): Promise<DefaultResponseDto> {", "        try{\n            const result = await this.authService.signUp({\n                authCredentialDto,\n                queryRunner:queryRunnerManager,\n            });\n            return result;\n        }catch(error){\n            throw new HttpException(error.message, 401);\n        }\n    }\n\n    @Post('/signin')\n    @ApiOperation({summary: '\ub85c\uadf8\uc778', description: '\ub85c\uadf8\uc778 \uc9c4\ud589'})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc131\uacf5', type: DefaultResponseDto})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    async signIn(\n        @Body(ValidationPipe) authLoginDto: AuthLoginDto,\n        @TransactionManager() queryRunnerManager: EntityManager,\n        @Res({ passthrough: true }) response,\n    ): Promise<DefaultResponseDto> {", "        try{\n            const result = await this.authService.signIn({\n                authLoginDto,\n                queryRunnerManager,\n            });\n            response.cookie('Refresh', result.contents.refreshToken, {\n                httpOnly: true,\n                maxAge: process.env.JWT_REFRESH_EXPIRATION_TIME,\n            });\n            return {\n                statusCode: result.statusCode,\n                contents: {\n                    accessToken: result.contents.accessToken,\n                    refreshToken: result.contents.refreshToken,\n                },\n            };", "        }catch(error){\n            throw new HttpException(error.message, 404);\n        }\n    }\n\n    @Get('/signout')\n    @ApiOperation({summary: '\ub85c\uadf8\uc544\uc6c3', description: '\ub85c\uadf8\uc544\uc6c3 \uc9c4\ud589'})\n    @ApiResponse({description: '\ub85c\uadf8\uc544\uc6c3 \uc131\uacf5', type: DefaultResponseDto})\n    @ApiResponse({description: '\ub85c\uadf8\uc544\uc6c3 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    async signOut(\n        @Res({ passthrough: true }) response,\n        @GetUser() user: User,\n    ): Promise<DefaultResponseDto> {", "        try{\n            if(!user) throw new Error('\ub85c\uadf8\uc778\uc774 \ub418\uc5b4\uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.');\n            await this.authService.signOut(user);\n            response.clearCookie('Refresh');\n            return {\n                statusCode: \"200\",\n                contents: \"\ub85c\uadf8\uc544\uc6c3 \uc131\uacf5\",\n            };\n        }catch(error){\n            throw new HttpException(error.message, 500);\n        }\n    }\n\n    @Get('/refresh')\n    @ApiOperation({summary: 'Refresh Token \uc73c\ub85c AccessToken \ubc1c\uae09', description: '\ud5e4\ub354\uc778\uacbd\uc6b0 refresh_token, \ucfe0\ud0a4\uc778 \uacbd\uc6b0 Refresh'})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc131\uacf5', type: DefaultResponseDto})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    @UseGuards(AuthGuard('jwt-refresh-token'))\n    async signInByRefreshToken(\n        @TransactionManager() queryRunnerManager: EntityManager,\n        @GetUser() user: User,\n    ): Promise<DefaultResponseDto> {", "        }catch(error){\n            throw new HttpException(error.message, 500);\n        }\n    }\n\n    @Get('/refresh')\n    @ApiOperation({summary: 'Refresh Token \uc73c\ub85c AccessToken \ubc1c\uae09', description: '\ud5e4\ub354\uc778\uacbd\uc6b0 refresh_token, \ucfe0\ud0a4\uc778 \uacbd\uc6b0 Refresh'})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc131\uacf5', type: DefaultResponseDto})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc2e4\ud328', type: ErrorResponseDto , status: 401})\n    @UseGuards(AuthGuard('jwt-refresh-token'))\n    async signInByRefreshToken(\n        @TransactionManager() queryRunnerManager: EntityManager,\n        @GetUser() user: User,\n    ): Promise<DefaultResponseDto> {", "        try{\n            const accessToken = await this.authService.getAccessToken(user);\n            return {\n                statusCode: \"200\",\n                contents: accessToken,\n            };\n        }catch(error){\n            throw new HttpException(error.message, 401);\n        }\n    }\n\n    @Get('/islogin')\n    @ApiOperation({summary: '\ub85c\uadf8\uc778 \uc5ec\ubd80 \ud655\uc778', description: '\ub85c\uadf8\uc778 \uc5ec\ubd80 \ud655\uc778'})\n    @ApiResponse({description: '\ub85c\uadf8\uc778 \uc5ec\ubd80 \ud655\uc778', type: DefaultResponseDto})\n    @UseGuards(AuthGuard(\"jwt\"))\n    async isLogin(\n        @GetUser() user: User,\n    ): Promise<DefaultResponseDto> {", "        try{\n            return {\n                statusCode: \"200\",\n                contents: {\n                    id: user.id,\n                    email: user.email,\n                    name: user.name,\n                    role: user.role,\n                    customId: user.customId,\n                },\n            };", "        }catch(error){\n            throw new HttpException(error.message, 500);\n        }\n    }\n}\n"]}
{"filename": "src/auth/jwt.strategy.ts", "chunked_list": ["import { PassportStrategy } from \"@nestjs/passport\";\nimport { ExtractJwt, Strategy } from \"passport-jwt\";\nimport { AuthService } from \"./auth.service\";\nimport { UserRepository } from \"src/pages/users/user.repository\";\nimport { UnauthorizedException } from \"@nestjs/common\";\nimport { User } from \"src/pages/users/user.entity\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\n\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n    constructor(\n        @InjectRepository(UserRepository)\n        private UserRepository: UserRepository\n    ) {\n        super({\n            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n            secretOrKey: process.env.JWT_SECRET,\n        });\n    }\n\n    async validate(payload) : Promise<User> {\n        const { customId } = payload;\n        const user = await this.UserRepository.findOne({ where : {customId} });", "export class JwtStrategy extends PassportStrategy(Strategy) {\n    constructor(\n        @InjectRepository(UserRepository)\n        private UserRepository: UserRepository\n    ) {\n        super({\n            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n            secretOrKey: process.env.JWT_SECRET,\n        });\n    }\n\n    async validate(payload) : Promise<User> {\n        const { customId } = payload;\n        const user = await this.UserRepository.findOne({ where : {customId} });", "        if (!user) {\n            throw new UnauthorizedException();\n        }\n        return user;\n    }\n}"]}
{"filename": "src/auth/authToken.middleware.ts", "chunked_list": ["import { Injectable, NestMiddleware } from '@nestjs/common'\nimport { InjectRepository } from '@nestjs/typeorm'\nimport { Request, Response } from 'express'\nimport * as jwt from 'jsonwebtoken'\nimport { User } from 'src/pages/users/user.entity'\n\n@Injectable()\nexport class AuthTokenMiddleware implements NestMiddleware {\n    public async use(req: any, res: Response, next: () => void) {\n        req.user = await this.verifyUser(req)\n        return next()\n    }\n\n    private async verifyUser(req: Request): Promise<User> {\n        let user: User = null", "        try {\n            const { authorization } = req.headers\n            const token = authorization.replace('Bearer ', '').replace('bearer ', '')\n            const decoded = await this.verifyToken(token)\n\n            // user = await this.userRepository.findOne({ where : {customId : decoded.customId} });\n            user = decoded;\n        } catch (e) {}\n\n        return user;\n    }\n\n    private async verifyToken(token: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {", "                if (err) reject(err)\n                resolve(decoded)\n            })\n        })\n    }\n}"]}
{"filename": "src/auth/auth.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from 'src/pages/users/user.entity';\nimport { UserRepository } from 'src/pages/users/user.repository';\nimport { AuthCredentialDto } from './dto/auth-credential.dto';\nimport { UnauthorizedException } from \"@nestjs/common/exceptions\";\nimport * as bcrypt from 'bcryptjs';\nimport { AuthLoginDto } from './dto/auth-login.dto';\nimport { DefaultResponseDto } from './dto/default-response.dto';", "import { AuthLoginDto } from './dto/auth-login.dto';\nimport { DefaultResponseDto } from './dto/default-response.dto';\nimport { EntityManager } from 'typeorm';\n\n@Injectable()\nexport class AuthService {\n    constructor(\n        @InjectRepository(UserRepository)\n        private userRepository: UserRepository,\n        private jwtService: JwtService\n    ) {}\n\n    async signUp(args:{\n        authCredentialDto: AuthCredentialDto,\n        queryRunner: EntityManager,\n    }) : Promise<DefaultResponseDto> {", "        try{\n            const IdCheck = await args.queryRunner.findOne(User,{\n                where:{ customId : args.authCredentialDto.customId }\n            });\n            if(IdCheck){\n                throw new UnauthorizedException('Id already exists');\n            }\n\n            const EmailCheck = await args.queryRunner.findOne(User,{\n                where:{ email : args.authCredentialDto.email }\n            });", "            if(EmailCheck){\n                throw new UnauthorizedException('Email already exists');\n            }\n        } catch (error) {\n            throw new UnauthorizedException(error.message);\n        }\n        const user = await this.userRepository.createUser(args.authCredentialDto);\n        return {statusCode:\"200\", contents : user};\n    }\n\n    async signIn(args:{\n        authLoginDto: AuthLoginDto,\n        queryRunnerManager: EntityManager,\n    }) : Promise<DefaultResponseDto> {\n        const {customId , password } = args.authLoginDto;\n        const user = await this.userRepository.findOne(\n            {where:{ customId : customId }}\n        );\n", "        if(user && await bcrypt.compare(password, user.password)){\n            const payload = { customId : user.customId };\n            const accessToken = await this.jwtService.sign(payload, {\n                secret: process.env.JWT_SECRET,\n                expiresIn: process.env.JWT_SECRET_EXPIRATION_TIME,\n            });\n            const refreshToken = await this.jwtService.sign({id: user.id}, { \n                secret: process.env.JWT_REFRESH_TOKEN_SECRET,\n                expiresIn: process.env.JWT_REFRESH_TOKEN_EXPIRATION_TIME,\n            });\n\n            await this.setCurrentRefreshToken(refreshToken, user.id)\n\n            return {statusCode:\"200\", contents : {accessToken, refreshToken}};\n        }\n        else{\n            throw new UnauthorizedException('login failed');\n        }\n    }\n\n    async setCurrentRefreshToken(refreshToken: string, id: number) {\n        const hashedRefreshToken = await bcrypt.hash(refreshToken, 10);\n        await this.userRepository.update(id, { refreshToken : hashedRefreshToken });\n    }\n    \n    async getUserIfRefreshTokenMatches(refreshToken: string, id: number) {\n        const user = await this.userRepository.findOne({\n            where: { id },\n        });\n", "        if(user.refreshToken == null){\n            throw new UnauthorizedException('refresh token is null');\n        }\n    \n        const isRefreshTokenMatching = await bcrypt.compare(\n            refreshToken,\n            user.refreshToken,\n        );\n    \n        if (isRefreshTokenMatching) {\n            return user;\n        }else{\n            throw new UnauthorizedException('not matching refresh token');\n        }\n    }\n    \n    async removeRefreshToken(id: number) {\n        return this.userRepository.update(id, {\n            refreshToken: null,\n        });\n    }\n    \n    async getAccessToken(user:User) {", "        if (isRefreshTokenMatching) {\n            return user;\n        }else{\n            throw new UnauthorizedException('not matching refresh token');\n        }\n    }\n    \n    async removeRefreshToken(id: number) {\n        return this.userRepository.update(id, {\n            refreshToken: null,\n        });\n    }\n    \n    async getAccessToken(user:User) {", "        try{\n            const payload = { customId : user.customId };\n            const accessToken = await this.jwtService.sign(payload);\n            return accessToken;\n        }catch(e){\n            throw new UnauthorizedException(e.message);\n        }\n    }\n\n    async signOut(user:User){\n        const userObject = await this.userRepository.findOne({\n            where: { customId : user.customId },\n        });", "        if(userObject){\n            await this.removeRefreshToken(userObject.id);\n            return {statusCode:\"200\", contents : \"sign out success\"};\n        }\n        else{\n            throw new UnauthorizedException('user not found');\n        }\n    }\n}\n"]}
{"filename": "src/auth/jwt-refresh.strategy.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class JwtRefreshStrategy extends PassportStrategy(\n    Strategy,\n    'jwt-refresh-token',\n) {\n    constructor(\n        private readonly authService: AuthService,\n    ) {\n        super({\n            jwtFromRequest: ExtractJwt.fromExtractors([\n                (request) => {", "                    if(request?.headers?.refresh_token){\n                        return request?.headers?.refresh_token;\n                    }\n                    return request?.cookies?.Refresh;\n                },\n            ]),\n            secretOrKey: process.env.JWT_REFRESH_TOKEN_SECRET,\n            passReqToCallback: true,\n        });\n    }\n\n    async validate(req, payload: any) {\n        const refreshToken = req.cookies?.Refresh || req.headers?.refresh_token;\n        return this.authService.getUserIfRefreshTokenMatches(\n            refreshToken,\n            payload.id,\n        );\n    }\n}"]}
{"filename": "src/auth/dto/auth-credential.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\nimport { IsNotEmpty } from \"class-validator\";\n\nexport class AuthCredentialDto {\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc544\uc774\ub514', example: 'jswcyber'})\n    @IsNotEmpty()\n    customId: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc774\ub984', example: '\uc815\uc131\uc6b1'})\n    @IsNotEmpty()\n    name: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc774\uba54\uc77c', example: 'jswcyber@naver.com'})\n    @IsNotEmpty()\n    email: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \ube44\ubc00\ubc88\ud638', example: 'Qlalfqjsgh1234!@'})\n    @IsNotEmpty()\n    password: string;\n}\n"]}
{"filename": "src/auth/dto/error-response.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\nimport { IsNotEmpty } from \"class-validator\";\n\nexport class ErrorResponseDto {\n    @ApiProperty({description: '\uc751\ub2f5 \ucf54\ub4dc', example: '4xx'})\n    @IsNotEmpty()\n    statusCode: string;\n\n    @ApiProperty({description: '\uc5d0\ub7ec \uc804\ub2ec', example: ''})\n    @IsNotEmpty()\n    contents: any;\n}\n"]}
{"filename": "src/auth/dto/default-response.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\nimport { IsNotEmpty } from \"class-validator\";\n\nexport class DefaultResponseDto {\n    @ApiProperty({description: '\uc751\ub2f5 \ucf54\ub4dc', example: '2xx'})\n    @IsNotEmpty()\n    statusCode: string;\n\n    @ApiProperty({description: '\uc751\ub2f5 \ub0b4\uc6a9', example: ''})\n    @IsNotEmpty()\n    contents: any;\n}\n"]}
{"filename": "src/auth/dto/auth-login.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\nimport { IsNotEmpty } from \"class-validator\";\n\nexport class AuthLoginDto {\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \uc544\uc774\ub514', example: 'jswcyber'})\n    @IsNotEmpty()\n    customId: string;\n\n    @ApiProperty({description: '\uc0ac\uc6a9\uc790 \ube44\ubc00\ubc88\ud638', example: 'Qlalfqjsgh1234!@'})\n    @IsNotEmpty()\n    password: string;\n}\n"]}
{"filename": "src/utils/util.ts", "chunked_list": ["export const generateSessionId = () => {\n    const rand_session_id = Math.random().toString(36).substr(2, 11);\n    return rand_session_id;\n}"]}
{"filename": "src/movement2d/movement2d.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AuthModule } from 'src/auth/auth.module';\nimport { Movement2dService } from './movement2d.service';\nimport { RedisCacheModule } from 'src/cache/redis.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([]),\n    AuthModule,", "    TypeOrmModule.forFeature([]),\n    AuthModule,\n    RedisCacheModule,\n  ],\n  controllers: [],\n  providers: [Movement2dService],\n  exports: [Movement2dService],\n})\nexport class Movement2dModule {}\n", "export class Movement2dModule {}\n"]}
{"filename": "src/movement2d/movement2d.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\nimport { Server, Socket } from \"socket.io\";\nimport { RedisCacheService } from \"src/cache/redis.service\";\n\n/**\n * 2D \ud658\uacbd\uc5d0\uc11c\uc758 \uc6c0\uc9c1\uc784\uc744 \ucc98\ub9ac\ud558\ub294 \uc11c\ube44\uc2a4\n */\n@Injectable()\nexport class Movement2dService {\n    constructor(\n        private redisService: RedisCacheService,\n    ) { }\n\n    /**\n     * \ud0a4\ubcf4\ub4dc\uc758 \uc785\ub825\uc744 \ubc1b\uc544\uc11c \ub3c4\ucc29 \uc9c0\uc810\uc744 \uacc4\uc0b0\ud55c \ud6c4, \uadf8 \uacb0\uacfc\ub97c \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc804\uc1a1\ud55c\ub2e4.\n     * @param server \n     * @param channel \n     * @param userCustomId\n     * @param key\n     * @param isUp\n     */\n    async move2d_key(server: Server, channel: string, userCustomId: any, key:any, isUp: boolean) {", "export class Movement2dService {\n    constructor(\n        private redisService: RedisCacheService,\n    ) { }\n\n    /**\n     * \ud0a4\ubcf4\ub4dc\uc758 \uc785\ub825\uc744 \ubc1b\uc544\uc11c \ub3c4\ucc29 \uc9c0\uc810\uc744 \uacc4\uc0b0\ud55c \ud6c4, \uadf8 \uacb0\uacfc\ub97c \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc804\uc1a1\ud55c\ub2e4.\n     * @param server \n     * @param channel \n     * @param userCustomId\n     * @param key\n     * @param isUp\n     */\n    async move2d_key(server: Server, channel: string, userCustomId: any, key:any, isUp: boolean) {", "        try {\n            const { x, y } = await this.redisService.get(userCustomId+\"_position\");\n            let newX = x;\n            let newY = y;\n            if(!isUp){\n                switch (key) {\n                    case \"s\":\n                        newY -= 5;\n                        break;\n                    case \"w\":\n                        newY += 5;\n                        break;\n                    case \"a\":\n                        newX -= 5;\n                        break;\n                    case \"d\":\n                        newX += 5;\n                        break;\n                }\n                // \uc804\uccb4 \uc0ac\uc6a9\uc790\ub4e4\uc5d0\uac8c \uc774\ub3d9\uc744 \uc54c\ub9bc. (\ud604\uc7ac \uc704\uce58, \uc774\ub3d9 \ubc29\ud5a5, \uc774\ub3d9 \uc18d\ub3c4)\n                // \uc11c\ubc84\uc5d0\uc11c\ub3c4 \uc774\ub3d9\uc744 \uacc4\uc0b0\ud574\uc11c \uc704\uce58\ub97c \uc5c5\ub370\uc774\ud2b8.\n                const already = await this.redisService.get(userCustomId+\"_interval_\"+key);", "                if(already) return;\n                \n                const interval = setInterval(this.calculatePosition, 100, this.redisService, server, channel, userCustomId, key, isUp, 5);\n                await this.redisService.set(userCustomId+\"_interval_\"+key, interval[Symbol.toPrimitive]() as number);\n                server.emit(\"position_start\",{\n                    player: userCustomId,\n                    x: newX,\n                    y: newY,\n                    direction: key,\n                    speed: 5\n                })\n            }else{\n                // \uc804\uccb4 \uc0ac\uc6a9\uc790\ub4e4\uc5d0\uac8c \uc774\ub3d9\uc774 \uba48\ucda4\uc744 \uc54c\ub9bc.( \uc11c\ubc84\uc5d0\uc11c \uacc4\uc0b0\ub41c \uc704\uce58 )\n                // \uc11c\ubc84\uc5d0\uc11c\ub3c4 \uc774\ub3d9\uc744 \uacc4\uc0b0\ud574\uc11c \uc704\uce58\ub97c \uc5c5\ub370\uc774\ud2b8.\n                const interval : number = await this.redisService.get(userCustomId+\"_interval_\"+key);\n                clearInterval(interval);\n                \n                await this.redisService.del(userCustomId+\"_interval_\"+key);\n                server.emit(\"position_stop\",{\n                    player: userCustomId,\n                    x: newX,\n                    y: newY,\n                    speed: 0\n                })\n\n            }\n            await this.redisService.set(userCustomId+\"_position\", { x: newX, y: newY });", "        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async calculatePosition(redisService: RedisCacheService ,server: Server, channel: string, userCustomId: any, key:any, isUp: boolean, speed: number) {\n        try {\n            const { x, y } = await redisService.get(userCustomId+\"_position\");\n            let newX = x;\n            let newY = y;\n            if(!isUp){\n                switch (key) {\n                    case \"s\":\n                        newY -= speed;\n                        break;\n                    case \"w\":\n                        newY += speed;\n                        break;\n                    case \"a\":\n                        newX -= speed;\n                        break;\n                    case \"d\":\n                        newX += speed;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            await redisService.set(userCustomId+\"_position\", { x: newX, y: newY });\n            // \uc2e4\uc2dc\uac04\uc73c\ub85c \uc774\ub3d9\uc744 \uc54c\ub9bc. //////////////////////////////\n            server.emit(channel, {\n                player: userCustomId,\n                x: newX,\n                y: newY,\n                direction: key,\n                speed: speed\n            });\n            ///////////////////////////////////////////////////////", "            if(!isUp){\n                switch (key) {\n                    case \"s\":\n                        newY -= speed;\n                        break;\n                    case \"w\":\n                        newY += speed;\n                        break;\n                    case \"a\":\n                        newX -= speed;\n                        break;\n                    case \"d\":\n                        newX += speed;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            await redisService.set(userCustomId+\"_position\", { x: newX, y: newY });\n            // \uc2e4\uc2dc\uac04\uc73c\ub85c \uc774\ub3d9\uc744 \uc54c\ub9bc. //////////////////////////////\n            server.emit(channel, {\n                player: userCustomId,\n                x: newX,\n                y: newY,\n                direction: key,\n                speed: speed\n            });\n            ///////////////////////////////////////////////////////", "        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * \uc774\ub3d9 \ubc29\ud5a5\uc744 \uc785\ub825\ubc1b\uc544\uc11c \ud574\ub2f9 \uc774\ub3d9 \ubc29\ud5a5\uc744 \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc804\uc1a1\ud55c\ub2e4.\n     * \uc11c\ubc84\uc5d0\uc11c\ub3c4 \uc774\ub3d9 \ubc29\ud5a5\uc744 \uacc4\uc0b0\ud574\uc11c \uc704\uce58\ub97c \uc5c5\ub370\uc774\ud2b8\ud55c\ub2e4.\n     * @param server\n     * @param channel\n     * @param userCustomId\n     * @param direction\n    */\n    async move2d_direction(server: Server, channel: string, userCustomId: any, direction: any) {", "        try {\n            server.emit(channel, {\n                direction: direction,\n                player: userCustomId\n            });\n        } catch (e){\n            throw new Error(e);\n        }\n    }\n}"]}
{"filename": "src/cache/redis.service.ts", "chunked_list": ["import { Injectable, Inject, CACHE_MANAGER } from '@nestjs/common';\nimport { Cache } from 'cache-manager';\n\n@Injectable()\nexport class RedisCacheService {\n    constructor(@Inject(CACHE_MANAGER) private readonly cache: Cache) { }\n\n    async get(key: string): Promise<any> {\n        return await this.cache.get(key);\n    }\n\n    async set(key: string, value: any, option?: any) {\n        await this.cache.set(key, value, option);\n    }\n\n    async reset() {\n        await this.cache.reset();\n    }\n\n    async del(key: string) {\n        await this.cache.del(key);\n    }\n\n    async concat(key: string, value: any[]) {\n        const data : any[] = await this.get(key);", "        if (data) {\n            await this.set(key, data.concat(value));\n        }else{\n            await this.set(key, [value]);\n        }\n    }\n\n    async push(key: string, value: any) {\n        const data : any[] = await this.get(key);\n        if (data) {\n            await this.set(key, data.push(value));\n        }else{\n            await this.set(key, [value]);\n        }\n    }\n}", "        if (data) {\n            await this.set(key, data.push(value));\n        }else{\n            await this.set(key, [value]);\n        }\n    }\n}"]}
{"filename": "src/cache/redis.module.ts", "chunked_list": ["import { CacheModule, Module } from '@nestjs/common';\nimport * as redisStore from 'cache-manager-redis-store';\nimport * as dotenv from 'dotenv';\nimport { RedisCacheService } from './redis.service';\ndotenv.config();\n\nconst cacheModule = CacheModule.register({\n    useFactory: async () => ({\n        store: redisStore,\n        host: process.env.REDIS_HOST,   // env\uc5d0\uc11c \uc815\uc758\ud568", "        store: redisStore,\n        host: process.env.REDIS_HOST,   // env\uc5d0\uc11c \uc815\uc758\ud568\n        port: process.env.REDIS_PORT,   // env\uc5d0\uc11c \uc815\uc758\ud568\n        ttl: 60 * 60 * 12, // \uce90\uc2dc \uc720\uc9c0 \uc2dc\uac04\n    }),\n});\n\n@Module({\n    imports: [cacheModule],\n    providers: [RedisCacheService],", "    imports: [cacheModule],\n    providers: [RedisCacheService],\n    exports: [RedisCacheService],\n})\nexport class RedisCacheModule { }"]}
{"filename": "src/decorators/TransactionManager.decorator.ts", "chunked_list": ["import { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\n\nexport const TransactionManager = createParamDecorator(\n    (data: unknown, ctx: ExecutionContext) => {\n      const req = ctx.switchToHttp().getRequest();\n      return req.queryRunnerManager;\n    },\n  );"]}
{"filename": "src/decorators/TransactionInterceptor.decorator.ts", "chunked_list": ["import { CallHandler, ExecutionContext, HttpException, Injectable, InternalServerErrorException, NestInterceptor } from \"@nestjs/common\";\nimport { Observable, catchError, tap } from \"rxjs\";\nimport { QueryRunner, DataSource } from \"typeorm\";\n\n@Injectable()\nexport class TransactionInterceptor implements NestInterceptor {\n  constructor(private readonly dataSource: DataSource) {}\n  async intercept(\n    context: ExecutionContext,\n    next: CallHandler,\n  ): Promise<Observable<any>> {\n    const req = context.switchToHttp().getRequest();\n    const queryRunner: QueryRunner = await this.dbInit();\n\n    req.queryRunnerManager = queryRunner.manager;\n\n    return next.handle().pipe(\n      catchError(async (e) => {\n        await queryRunner.rollbackTransaction();\n        await queryRunner.release();\n", "        if (e instanceof HttpException) {\n          throw new HttpException(e.message, e.getStatus());\n        } else {\n          throw new InternalServerErrorException(e.message);\n        }\n      }),\n      tap(async () => {\n        await queryRunner.commitTransaction();\n        await queryRunner.release();\n      }),\n    );\n  }\n\n  private async dbInit(): Promise<QueryRunner> {\n    const queryRunner = this.dataSource.createQueryRunner();\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    return queryRunner;\n  }\n}"]}
